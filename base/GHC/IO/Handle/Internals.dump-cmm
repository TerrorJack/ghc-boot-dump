
==================== Output Cmm ====================
2018-03-16 16:05:06.60932734 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:06.61337116 UTC

[section ""data" . GHC.IO.Handle.Internals.augmentIOError_closure" {
     GHC.IO.Handle.Internals.augmentIOError_closure:
         const GHC.IO.Handle.Internals.augmentIOError_info;
 },
 sat_sa7Q2_entry() //  [R1]
         { info_tbl: [(ca8mN,
                       label: sat_sa7Q2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8mN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca8mO; else goto ca8mP;
       ca8mO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8mP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ca8mG_info;
           _sa7PL::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sa7PL::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua8ng; else goto ca8mH;
       ua8ng: // global
           call _ca8mG(R1) args: 0, res: 0, upd: 0;
       ca8mH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8mG() //  [R1]
         { info_tbl: [(ca8mG,
                       label: block_ca8mG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8mG: // global
           if (R1 & 7 == 1) goto ca8mK; else goto ca8mL;
       ca8mK: // global
           _sa7PL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca8mS_info;
           R1 = _sa7PL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua8nf; else goto ca8mU;
       ua8nf: // global
           call _ca8mS(R1) args: 0, res: 0, upd: 0;
       ca8mU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ca8mL: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ca8mS() //  [R1]
         { info_tbl: [(ca8mS,
                       label: block_ca8mS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8mS: // global
           if (R1 & 7 == 1) goto ca8n0; else goto ca8n7;
       ca8n0: // global
           Hp = Hp + 16;
           _sa7PV::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ca8na; else goto ca8n2;
       ca8n2: // global
           _sa7PW::P64 = P64[_sa7PV::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa7PW::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ca8n7: // global
           Hp = Hp + 16;
           _sa7PV::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ca8na; else goto ca8n9;
       ca8na: // global
           HpAlloc = 16;
           R1 = _sa7PV::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8n9: // global
           _sa7PY::P64 = P64[_sa7PV::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa7PY::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.augmentIOError_entry() //  [R2, R3, R4]
         { info_tbl: [(ca8nh,
                       label: GHC.IO.Handle.Internals.augmentIOError_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8nh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8nk; else goto ca8nl;
       ca8nk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.augmentIOError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8nl: // global
           I64[Sp - 24] = block_ca8mx_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8np; else goto ca8my;
       ua8np: // global
           call _ca8mx(R1) args: 0, res: 0, upd: 0;
       ca8my: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8mx() //  [R1]
         { info_tbl: [(ca8mx,
                       label: block_ca8mx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8mx: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ca8no; else goto ca8nn;
       ca8no: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8nn: // global
           _sa7PO::P64 = P64[R1 + 15];
           _sa7PQ::P64 = P64[R1 + 31];
           _sa7PR::P64 = P64[R1 + 39];
           _sa7PS::P64 = P64[R1 + 47];
           I64[Hp - 96] = sat_sa7Q2_info;
           _sa7PL::P64 = P64[Sp + 16];
           P64[Hp - 80] = _sa7PL::P64;
           P64[Hp - 72] = _sa7PS::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa7PL::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sa7PO::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sa7PQ::P64;
           P64[Hp - 8] = _sa7PR::P64;
           P64[Hp] = Hp - 96;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.615597322 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle14_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle14_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.616375272 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle13_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle13_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle13_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle13_entry() //  [R1]
         { info_tbl: [(ca8nw,
                       label: GHC.IO.Handle.Internals.wantReadableHandle13_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8nw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8nx; else goto ca8ny;
       ca8nx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8ny: // global
           (_ca8nt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8nt::I64 == 0) goto ca8nv; else goto ca8nu;
       ca8nv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8nu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8nt::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle14_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.61730177 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle12_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle12_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle13_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.618064017 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle11_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle11_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle11_entry() //  [R1]
         { info_tbl: [(ca8nF,
                       label: GHC.IO.Handle.Internals.wantReadableHandle11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8nF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8nG; else goto ca8nH;
       ca8nG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8nH: // global
           (_ca8nC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8nC::I64 == 0) goto ca8nE; else goto ca8nD;
       ca8nE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8nD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8nC::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle12_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.619063206 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle1_entry() //  []
         { info_tbl: [(ca8nN,
                       label: GHC.IO.Handle.Internals.ioe_closedHandle1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8nN: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.61984308 UTC

[section ""data" . ioe_closedHandle2_ra7Pb_closure" {
     ioe_closedHandle2_ra7Pb_closure:
         const ioe_closedHandle2_ra7Pb_info;
         const 0;
 },
 ioe_closedHandle2_ra7Pb_entry() //  []
         { info_tbl: [(ca8nU,
                       label: ioe_closedHandle2_ra7Pb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8nU: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.620614269 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle_entry() //  []
         { info_tbl: [(ca8o1,
                       label: GHC.IO.Handle.Internals.ioe_closedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8o1: // global
           call ioe_closedHandle2_ra7Pb_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.621273079 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle10_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle10_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.622004176 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle9_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle9_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle9_entry() //  [R1]
         { info_tbl: [(ca8oa,
                       label: GHC.IO.Handle.Internals.wantReadableHandle9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8oa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8ob; else goto ca8oc;
       ca8ob: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8oc: // global
           (_ca8o7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8o7::I64 == 0) goto ca8o9; else goto ca8o8;
       ca8o9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8o8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8o7::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.62287446 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle8_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle9_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.623676158 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle7_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle7_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle7_entry() //  [R1]
         { info_tbl: [(ca8oj,
                       label: GHC.IO.Handle.Internals.wantReadableHandle7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8oj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8ok; else goto ca8ol;
       ca8ok: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8ol: // global
           (_ca8og::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8og::I64 == 0) goto ca8oi; else goto ca8oh;
       ca8oi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8oh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8og::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.624649047 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() //  []
         { info_tbl: [(ca8oq,
                       label: GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8oq: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.62547295 UTC

[section ""data" . ioe_semiclosedHandle2_ra7Pc_closure" {
     ioe_semiclosedHandle2_ra7Pc_closure:
         const ioe_semiclosedHandle2_ra7Pc_info;
         const 0;
 },
 ioe_semiclosedHandle2_ra7Pc_entry() //  []
         { info_tbl: [(ca8ox,
                       label: ioe_semiclosedHandle2_ra7Pc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ox: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.62622921 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle_entry() //  []
         { info_tbl: [(ca8oE,
                       label: GHC.IO.Handle.Internals.ioe_semiclosedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8oE: // global
           call ioe_semiclosedHandle2_ra7Pc_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.626910015 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_4_closure" {
     GHC.IO.Handle.Internals.hLookAhead_4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.627640531 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_3_closure" {
     GHC.IO.Handle.Internals.hLookAhead_3_closure:
         const GHC.IO.Handle.Internals.hLookAhead_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_3_entry() //  [R1]
         { info_tbl: [(ca8oN,
                       label: GHC.IO.Handle.Internals.hLookAhead_3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8oN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8oO; else goto ca8oP;
       ca8oO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8oP: // global
           (_ca8oK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8oK::I64 == 0) goto ca8oM; else goto ca8oL;
       ca8oM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8oL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8oK::I64;
           R2 = GHC.IO.Handle.Internals.hLookAhead_4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.628627832 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF1_closure" {
     GHC.IO.Handle.Internals.ioe_EOF1_closure:
         const GHC.IO.Handle.Internals.ioe_EOF1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF1_entry() //  []
         { info_tbl: [(ca8oU,
                       label: GHC.IO.Handle.Internals.ioe_EOF1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8oU: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.629586345 UTC

[section ""data" . ioe_EOF2_ra7Pd_closure" {
     ioe_EOF2_ra7Pd_closure:
         const ioe_EOF2_ra7Pd_info;
         const 0;
 },
 ioe_EOF2_ra7Pd_entry() //  []
         { info_tbl: [(ca8p1,
                       label: ioe_EOF2_ra7Pd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8p1: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.630339008 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF_closure" {
     GHC.IO.Handle.Internals.ioe_EOF_closure:
         const GHC.IO.Handle.Internals.ioe_EOF_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF_entry() //  []
         { info_tbl: [(ca8p8,
                       label: GHC.IO.Handle.Internals.ioe_EOF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8p8: // global
           call ioe_EOF2_ra7Pd_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.631015865 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,114,101,97,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.631702105 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle5_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle5_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle5_entry() //  [R1]
         { info_tbl: [(ca8ph,
                       label: GHC.IO.Handle.Internals.wantReadableHandle5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ph: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8pi; else goto ca8pj;
       ca8pi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8pj: // global
           (_ca8pe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8pe::I64 == 0) goto ca8pg; else goto ca8pf;
       ca8pg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8pf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8pe::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.632573615 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle4_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.633377817 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle3_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle3_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle3_entry() //  [R1]
         { info_tbl: [(ca8pq,
                       label: GHC.IO.Handle.Internals.wantReadableHandle3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8pq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8pr; else goto ca8ps;
       ca8pr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8ps: // global
           (_ca8pn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8pn::I64 == 0) goto ca8pp; else goto ca8po;
       ca8pp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8po: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8pn::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.63434705 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable1_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable1_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable1_entry() //  []
         { info_tbl: [(ca8px,
                       label: GHC.IO.Handle.Internals.ioe_notReadable1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8px: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.635151909 UTC

[section ""data" . ioe_notReadable2_ra7Pe_closure" {
     ioe_notReadable2_ra7Pe_closure:
         const ioe_notReadable2_ra7Pe_info;
         const 0;
 },
 ioe_notReadable2_ra7Pe_entry() //  []
         { info_tbl: [(ca8pE,
                       label: ioe_notReadable2_ra7Pe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8pE: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.635973353 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable_entry() //  []
         { info_tbl: [(ca8pL,
                       label: GHC.IO.Handle.Internals.ioe_notReadable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8pL: // global
           call ioe_notReadable2_ra7Pe_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.63661453 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantWritableHandle5_bytes" {
     GHC.IO.Handle.Internals.wantWritableHandle5_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,119,114,105,116,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.637353154 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle4_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle4_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle4_entry() //  [R1]
         { info_tbl: [(ca8pU,
                       label: GHC.IO.Handle.Internals.wantWritableHandle4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8pU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8pV; else goto ca8pW;
       ca8pV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8pW: // global
           (_ca8pR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8pR::I64 == 0) goto ca8pT; else goto ca8pS;
       ca8pT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8pS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8pR::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.638246268 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle3_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantWritableHandle4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.638993187 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle2_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle2_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle2_entry() //  [R1]
         { info_tbl: [(ca8q3,
                       label: GHC.IO.Handle.Internals.wantWritableHandle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8q3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8q4; else goto ca8q5;
       ca8q4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8q5: // global
           (_ca8q0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8q0::I64 == 0) goto ca8q2; else goto ca8q1;
       ca8q2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8q1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8q0::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.639991718 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable1_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable1_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable1_entry() //  []
         { info_tbl: [(ca8qa,
                       label: GHC.IO.Handle.Internals.ioe_notWritable1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8qa: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.640773034 UTC

[section ""data" . ioe_notWritable2_ra7Pf_closure" {
     ioe_notWritable2_ra7Pf_closure:
         const ioe_notWritable2_ra7Pf_info;
         const 0;
 },
 ioe_notWritable2_ra7Pf_entry() //  []
         { info_tbl: [(ca8qh,
                       label: ioe_notWritable2_ra7Pf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8qh: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.641959032 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable_entry() //  []
         { info_tbl: [(ca8qo,
                       label: GHC.IO.Handle.Internals.ioe_notWritable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8qo: // global
           call ioe_notWritable2_ra7Pf_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.642673505 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantSeekableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantSeekableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.643360603 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle5_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle5_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle5_entry() //  [R1]
         { info_tbl: [(ca8qx,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8qx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8qy; else goto ca8qz;
       ca8qy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8qz: // global
           (_ca8qu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8qu::I64 == 0) goto ca8qw; else goto ca8qv;
       ca8qw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8qv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8qu::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.644244809 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle4_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.645033768 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle3_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle3_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle3_entry() //  [R1]
         { info_tbl: [(ca8qG,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8qG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8qH; else goto ca8qI;
       ca8qH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8qI: // global
           (_ca8qD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8qD::I64 == 0) goto ca8qF; else goto ca8qE;
       ca8qF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8qE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8qD::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.645916411 UTC

[section ""cstring" . GHC.IO.Handle.Internals.flushBuffer6_bytes" {
     GHC.IO.Handle.Internals.flushBuffer6_bytes:
         I8[] [99,97,110,110,111,116,32,102,108,117,115,104,32,116,104,101,32,114,101,97,100,32,98,117,102,102,101,114,58,32,117,110,100,101,114,108,121,105,110,103,32,100,101,118,105,99,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.646692063 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer5_closure" {
     GHC.IO.Handle.Internals.flushBuffer5_closure:
         const GHC.IO.Handle.Internals.flushBuffer5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer5_entry() //  [R1]
         { info_tbl: [(ca8qP,
                       label: GHC.IO.Handle.Internals.flushBuffer5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8qP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8qQ; else goto ca8qR;
       ca8qQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8qR: // global
           (_ca8qM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8qM::I64 == 0) goto ca8qO; else goto ca8qN;
       ca8qO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8qN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8qM::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.647568348 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer4_closure" {
     GHC.IO.Handle.Internals.flushBuffer4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.flushBuffer5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.648321629 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer3_closure" {
     GHC.IO.Handle.Internals.flushBuffer3_closure:
         const GHC.IO.Handle.Internals.flushBuffer3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer3_entry() //  [R1]
         { info_tbl: [(ca8qY,
                       label: GHC.IO.Handle.Internals.flushBuffer3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8qY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8qZ; else goto ca8r0;
       ca8qZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8r0: // global
           (_ca8qV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8qV::I64 == 0) goto ca8qX; else goto ca8qW;
       ca8qX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8qW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8qV::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.650455439 UTC

[section ""cstring" . lvl_ra7Pg_bytes" {
     lvl_ra7Pg_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.651201873 UTC

[section ""data" . lvl1_ra7Ph_closure" {
     lvl1_ra7Ph_closure:
         const lvl1_ra7Ph_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra7Ph_entry() //  [R1]
         { info_tbl: [(ca8r7,
                       label: lvl1_ra7Ph_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8r7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8r8; else goto ca8r9;
       ca8r8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8r9: // global
           (_ca8r4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8r4::I64 == 0) goto ca8r6; else goto ca8r5;
       ca8r6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8r5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8r4::I64;
           R2 = lvl_ra7Pg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.652099712 UTC

[section ""cstring" . lvl2_ra7Pi_bytes" {
     lvl2_ra7Pi_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.653378365 UTC

[section ""data" . GHC.IO.Handle.Internals.$wioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.$wioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.$wioe_bufsiz_info;
         const 0;
 },
 sat_sa7Qi_entry() //  [R1]
         { info_tbl: [(ca8rt,
                       label: sat_sa7Qi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8rt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8ru; else goto ca8rv;
       ca8ru: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8rv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8rq_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca8rq() //  [R1, R2]
         { info_tbl: [(ca8rq,
                       label: block_ca8rq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8rq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8ry; else goto ca8rx;
       ca8ry: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ca8rx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Qj_entry() //  [R1]
         { info_tbl: [(ca8rz,
                       label: sat_sa7Qj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8rz: // global
           _sa7Qj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca8rA; else goto ca8rB;
       ca8rB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8rD; else goto ca8rC;
       ca8rD: // global
           HpAlloc = 24;
           goto ca8rA;
       ca8rA: // global
           R1 = _sa7Qj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8rC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Qj::P64;
           _sa7Qd::I64 = I64[_sa7Qj::P64 + 16];
           I64[Hp - 16] = sat_sa7Qi_info;
           I64[Hp] = _sa7Qd::I64;
           R3 = Hp - 16;
           R2 = lvl2_ra7Pi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Ql_entry() //  [R1]
         { info_tbl: [(ca8rF,
                       label: sat_sa7Ql_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8rF: // global
           _sa7Ql::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca8rG; else goto ca8rH;
       ca8rH: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca8rJ; else goto ca8rI;
       ca8rJ: // global
           HpAlloc = 80;
           goto ca8rG;
       ca8rG: // global
           R1 = _sa7Ql::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8rI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Ql::P64;
           _sa7Qd::I64 = I64[_sa7Ql::P64 + 16];
           I64[Hp - 72] = sat_sa7Qj_info;
           I64[Hp - 56] = _sa7Qd::I64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = lvl1_ra7Ph_closure;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.$wioe_bufsiz_entry() //  [R2]
         { info_tbl: [(ca8rK,
                       label: GHC.IO.Handle.Internals.$wioe_bufsiz_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8rK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8rO; else goto ca8rN;
       ca8rO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8rN: // global
           I64[Hp - 16] = sat_sa7Ql_info;
           I64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.655668806 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz1_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz1_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz1_entry() //  [R2]
         { info_tbl: [(ca8rW,
                       label: GHC.IO.Handle.Internals.ioe_bufsiz1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8rW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca8rX; else goto ca8rY;
       ca8rX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8rY: // global
           I64[Sp - 8] = block_ca8rT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8s2; else goto ca8rU;
       ua8s2: // global
           call _ca8rT(R1) args: 0, res: 0, upd: 0;
       ca8rU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8rT() //  [R1]
         { info_tbl: [(ca8rT,
                       label: block_ca8rT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8rT: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.656749235 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz_entry() //  [R2]
         { info_tbl: [(ca8s7,
                       label: GHC.IO.Handle.Internals.ioe_bufsiz_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8s7: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.ioe_bufsiz1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.658891867 UTC

[section ""data" . GHC.IO.Handle.Internals.$wstreamEncode_closure" {
     GHC.IO.Handle.Internals.$wstreamEncode_closure:
         const GHC.IO.Handle.Internals.$wstreamEncode_info;
 },
 GHC.IO.Handle.Internals.$wstreamEncode_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca8sg,
                       label: GHC.IO.Handle.Internals.$wstreamEncode_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8sg: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca8sh; else goto ca8si;
       ca8sh: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wstreamEncode_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8si: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _ca8sk() args: 0, res: 0, upd: 0;
     }
 },
 _ca8sk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8sk: // global
           I64[Sp - 8] = block_ca8sm_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8sm() //  [R1]
         { info_tbl: [(ca8sm,
                       label: block_ca8sm_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8sm: // global
           I64[Sp] = block_ca8so_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8tk; else goto ca8sr;
       ua8tk: // global
           call _ca8so(R1) args: 0, res: 0, upd: 0;
       ca8sr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8so() //  [R1]
         { info_tbl: [(ca8so,
                       label: block_ca8so_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8so: // global
           I64[Sp - 8] = block_ca8sv_info;
           _sa7QE::P64 = P64[R1 + 15];
           _sa7QF::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa7QF::P64;
           P64[Sp + 32] = _sa7QE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8tl; else goto ca8sx;
       ua8tl: // global
           call _ca8sv(R1) args: 0, res: 0, upd: 0;
       ca8sx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8sv() //  [R1]
         { info_tbl: [(ca8sv,
                       label: block_ca8sv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8sv: // global
           if (R1 & 7 == 3) goto ca8sQ; else goto ca8sD;
       ca8sQ: // global
           I64[Sp] = block_ca8sJ_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto ua8tm; else goto ca8sK;
       ua8tm: // global
           call _ca8sJ(R1) args: 0, res: 0, upd: 0;
       ca8sK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca8sD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8sG; else goto ca8sF;
       ca8sG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8sF: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8sJ() //  [R1]
         { info_tbl: [(ca8sJ,
                       label: block_ca8sJ_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8sJ: // global
           I64[Sp] = block_ca8sO_info;
           _sa7QN::I64 = I64[R1 + 39];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sa7QN::I64;
           if (R1 & 7 != 0) goto ua8tn; else goto ca8sS;
       ua8tn: // global
           call _ca8sO(R1) args: 0, res: 0, upd: 0;
       ca8sS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8sO() //  [R1]
         { info_tbl: [(ca8sO,
                       label: block_ca8sO_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8sO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8sY; else goto ca8sX;
       ca8sY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8sX: // global
           _sa7QF::P64 = P64[Sp + 8];
           if (I64[Sp + 40] == I64[R1 + 39]) goto ca8t9; else goto ca8t4;
       ca8t9: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_ca8t6_info;
           R3 = _sa7QF::P64;
           R2 = R1;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       ca8t4: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sa7QF::P64;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8t6() //  [R1]
         { info_tbl: [(ca8t6,
                       label: block_ca8t6_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8t6: // global
           I64[Sp] = block_ca8t8_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8to; else goto ca8tb;
       ua8to: // global
           call _ca8t8(R1) args: 0, res: 0, upd: 0;
       ca8tb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8t8() //  [R1]
         { info_tbl: [(ca8t8,
                       label: block_ca8t8_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8t8: // global
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 8;
           call _ca8sk() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.661423914 UTC

[section ""data" . GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure" {
     GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure:
         const GHC.Types.I#_con_info;
         const 2048;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.662176988 UTC

[section ""data" . GHC.IO.Handle.Internals.initBufferState_closure" {
     GHC.IO.Handle.Internals.initBufferState_closure:
         const GHC.IO.Handle.Internals.initBufferState_info;
 },
 GHC.IO.Handle.Internals.initBufferState_entry() //  [R2]
         { info_tbl: [(ca8tB,
                       label: GHC.IO.Handle.Internals.initBufferState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8tB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca8tC; else goto ca8tD;
       ca8tC: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.initBufferState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8tD: // global
           I64[Sp - 8] = block_ca8tu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8tK; else goto ca8tv;
       ua8tK: // global
           call _ca8tu(R1) args: 0, res: 0, upd: 0;
       ca8tv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8tu() //  [R1]
         { info_tbl: [(ca8tu,
                       label: block_ca8tu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8tu: // global
           if (R1 & 7 == 3) goto ca8tz; else goto ca8ty;
       ca8tz: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca8ty: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.663511722 UTC

[section ""data" . lvl3_ra7Pj_closure" {
     lvl3_ra7Pj_closure:
         const lvl3_ra7Pj_info;
 },
 lvl3_ra7Pj_entry() //  []
         { info_tbl: [(ca8tY,
                       label: lvl3_ra7Pj_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8tY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8u1; else goto ca8u2;
       ca8u1: // global
           R1 = lvl3_ra7Pj_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca8u2: // global
           I64[Sp - 8] = block_ca8tP_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ca8tP() //  []
         { info_tbl: [(ca8tP,
                       label: block_ca8tP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8tP: // global
           I64[Sp] = block_ca8tR_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8tR() //  [R1]
         { info_tbl: [(ca8tR,
                       label: block_ca8tR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8tR: // global
           I64[Sp - 8] = block_ca8tT_info;
           _sa7Ra::P64 = R1;
           R1 = 4;
           P64[Sp] = _sa7Ra::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8tT() //  [R1]
         { info_tbl: [(ca8tT,
                       label: block_ca8tT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8tT: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca8u7; else goto ca8u6;
       ca8u7: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8u6: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.665029135 UTC

[section ""data" . GHC.IO.Handle.Internals.noCharBuffer_closure" {
     GHC.IO.Handle.Internals.noCharBuffer_closure:
         const GHC.IO.Handle.Internals.noCharBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noCharBuffer_entry() //  [R1]
         { info_tbl: [(ca8ug,
                       label: GHC.IO.Handle.Internals.noCharBuffer_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ug: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8uh; else goto ca8ui;
       ca8uh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8ui: // global
           (_ca8ub::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8ub::I64 == 0) goto ca8ud; else goto ca8uc;
       ca8ud: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8uc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8ub::I64;
           I64[Sp - 24] = block_ca8ue_info;
           Sp = Sp - 24;
           call lvl3_ra7Pj_entry() args: 8, res: 8, upd: 24;
     }
 },
 _ca8ue() //  [R1]
         { info_tbl: [(ca8ue,
                       label: block_ca8ue_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ue: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.666335401 UTC

[section ""data" . lvl4_ra7Pk_closure" {
     lvl4_ra7Pk_closure:
         const lvl4_ra7Pk_info;
 },
 lvl4_ra7Pk_entry() //  []
         { info_tbl: [(ca8ux,
                       label: lvl4_ra7Pk_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ux: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8uA; else goto ca8uB;
       ca8uA: // global
           R1 = lvl4_ra7Pk_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca8uB: // global
           I64[Sp - 8] = block_ca8uo_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ca8uo() //  []
         { info_tbl: [(ca8uo,
                       label: block_ca8uo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8uo: // global
           I64[Sp] = block_ca8uq_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8uq() //  [R1]
         { info_tbl: [(ca8uq,
                       label: block_ca8uq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8uq: // global
           I64[Sp - 8] = block_ca8us_info;
           _sa7Ro::P64 = R1;
           R1 = 1;
           P64[Sp] = _sa7Ro::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8us() //  [R1]
         { info_tbl: [(ca8us,
                       label: block_ca8us_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8us: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca8uG; else goto ca8uF;
       ca8uG: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8uF: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.667787494 UTC

[section ""data" . GHC.IO.Handle.Internals.noByteBuffer_closure" {
     GHC.IO.Handle.Internals.noByteBuffer_closure:
         const GHC.IO.Handle.Internals.noByteBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noByteBuffer_entry() //  [R1]
         { info_tbl: [(ca8uP,
                       label: GHC.IO.Handle.Internals.noByteBuffer_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8uP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8uQ; else goto ca8uR;
       ca8uQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8uR: // global
           (_ca8uK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8uK::I64 == 0) goto ca8uM; else goto ca8uL;
       ca8uM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8uL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8uK::I64;
           I64[Sp - 24] = block_ca8uN_info;
           Sp = Sp - 24;
           call lvl4_ra7Pk_entry() args: 8, res: 8, upd: 24;
     }
 },
 _ca8uN() //  [R1]
         { info_tbl: [(ca8uN,
                       label: block_ca8uN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8uN: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.668724346 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule4_bytes" {
     GHC.IO.Handle.Internals.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.669651899 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule3_closure" {
     GHC.IO.Handle.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.670232152 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule2_bytes" {
     GHC.IO.Handle.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.670787243 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule1_closure" {
     GHC.IO.Handle.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.671316989 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule_closure" {
     GHC.IO.Handle.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Internals.$trModule3_closure+1;
         const GHC.IO.Handle.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.67186964 UTC

[section ""cstring" . lvl5_ra7Pl_bytes" {
     lvl5_ra7Pl_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,102,105,110,97,108,105,122,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.672524311 UTC

[section ""data" . lvl6_ra7Pm_closure" {
     lvl6_ra7Pm_closure:
         const lvl6_ra7Pm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra7Pm_entry() //  [R1]
         { info_tbl: [(ca8uZ,
                       label: lvl6_ra7Pm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8uZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8v0; else goto ca8v1;
       ca8v0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8v1: // global
           (_ca8uW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8uW::I64 == 0) goto ca8uY; else goto ca8uX;
       ca8uY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8uX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8uW::I64;
           R2 = lvl5_ra7Pl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.673650317 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_finalizedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_finalizedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_finalizedHandle_entry() //  [R2]
         { info_tbl: [(ca8v8,
                       label: GHC.IO.Handle.Internals.ioe_finalizedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8v8: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ca8vc; else goto ca8vb;
       ca8vc: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8vb: // global
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = lvl6_ra7Pm_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.675459159 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs1_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs1_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs1_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs1_entry() //  [R2]
         { info_tbl: [(ca8vk,
                       label: GHC.IO.Handle.Internals.closeTextCodecs1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8vk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8vl; else goto ca8vm;
       ca8vl: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.closeTextCodecs1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8vm: // global
           I64[Sp - 8] = block_ca8vh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8wr; else goto ca8vi;
       ua8wr: // global
           call _ca8vh(R1) args: 0, res: 0, upd: 0;
       ca8vi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8vh() //  [R1]
         { info_tbl: [(ca8vh,
                       label: block_ca8vh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8vh: // global
           I64[Sp - 8] = block_ca8vp_info;
           _sa7RO::P64 = P64[R1 + 87];
           R1 = P64[R1 + 95];
           P64[Sp] = _sa7RO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8wq; else goto ca8vr;
       ua8wq: // global
           call _ca8vp(R1) args: 0, res: 0, upd: 0;
       ca8vr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8vp() //  [R1]
         { info_tbl: [(ca8vp,
                       label: block_ca8vp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8vp: // global
           if (R1 & 7 == 1) goto ca8vy; else goto ca8vU;
       ca8vy: // global
           _sa7RO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca8vv_info;
           R1 = _sa7RO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua8ws; else goto ca8vz;
       ua8ws: // global
           call _ca8vv(R1) args: 0, res: 0, upd: 0;
       ca8vz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca8vU: // global
           I64[Sp] = block_ca8vS_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8wt; else goto ca8vV;
       ua8wt: // global
           call _ca8vS(R1) args: 0, res: 0, upd: 0;
       ca8vV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8vv() //  [R1]
         { info_tbl: [(ca8vv,
                       label: block_ca8vv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8vv: // global
           if (R1 & 7 == 1) goto ua8wp; else goto ca8vK;
       ua8wp: // global
           Sp = Sp + 8;
           call _ca8wa() args: 0, res: 0, upd: 0;
       ca8vK: // global
           I64[Sp] = block_ca8vI_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8wu; else goto ca8vL;
       ua8wu: // global
           call _ca8vI(R1) args: 0, res: 0, upd: 0;
       ca8vL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8vI() //  [R1]
         { info_tbl: [(ca8vI,
                       label: block_ca8vI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8vI: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8vS() //  [R1]
         { info_tbl: [(ca8vS,
                       label: block_ca8vS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8vS: // global
           I64[Sp] = block_ca8vZ_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8vZ() //  []
         { info_tbl: [(ca8vZ,
                       label: block_ca8vZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8vZ: // global
           _sa7RO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca8w1_info;
           R1 = _sa7RO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua8ww; else goto ca8w4;
       ua8ww: // global
           call _ca8w1(R1) args: 0, res: 0, upd: 0;
       ca8w4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8w1() //  [R1]
         { info_tbl: [(ca8w1,
                       label: block_ca8w1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8w1: // global
           if (R1 & 7 == 1) goto ua8wo; else goto ca8wf;
       ua8wo: // global
           Sp = Sp + 8;
           call _ca8wa() args: 0, res: 0, upd: 0;
       ca8wf: // global
           I64[Sp] = block_ca8wd_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8wx; else goto ca8wg;
       ua8wx: // global
           call _ca8wd(R1) args: 0, res: 0, upd: 0;
       ca8wg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8wa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8wa: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8wd() //  [R1]
         { info_tbl: [(ca8wd,
                       label: block_ca8wd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8wd: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.677919871 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs_entry() //  [R2]
         { info_tbl: [(ca8wD,
                       label: GHC.IO.Handle.Internals.closeTextCodecs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8wD: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.closeTextCodecs1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.679989746 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding1_closure" {
     GHC.IO.Handle.Internals.openTextEncoding1_closure:
         const GHC.IO.Handle.Internals.openTextEncoding1_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding1_entry() //  [R2, R3, R4]
         { info_tbl: [(ca8wR,
                       label: GHC.IO.Handle.Internals.openTextEncoding1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8wR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca8wS; else goto ca8wT;
       ca8wS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.openTextEncoding1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8wT: // global
           I64[Sp - 24] = block_ca8wK_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8yp; else goto ca8wL;
       ua8yp: // global
           call _ca8wK(R1) args: 0, res: 0, upd: 0;
       ca8wL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8wK() //  [R1]
         { info_tbl: [(ca8wK,
                       label: block_ca8wK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8wK: // global
           if (R1 & 7 == 1) goto ca8wO; else goto ca8wP;
       ca8wO: // global
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8wP: // global
           I64[Sp] = block_ca8wZ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8yo; else goto ca8x1;
       ua8yo: // global
           call _ca8wZ(R1) args: 0, res: 0, upd: 0;
       ca8x1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8wZ() //  [R1]
         { info_tbl: [(ca8wZ,
                       label: block_ca8wZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8wZ: // global
           I64[Sp - 16] = block_ca8x7_info;
           _sa7St::P64 = P64[R1 + 15];
           _sa7Su::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _sa7Su::P64;
           P64[Sp] = _sa7St::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8yq; else goto ca8xP;
       ua8yq: // global
           call _ca8x7(R1) args: 0, res: 0, upd: 0;
       ca8xP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8x7() //  [R1]
         { info_tbl: [(ca8x7,
                       label: block_ca8x7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8x7: // global
           _sa7St::P64 = P64[Sp + 16];
           _ca8ye::P64 = R1 & 7;
           if (_ca8ye::P64 != 3) goto ua8yi; else goto ca8y0;
       ua8yi: // global
           if (_ca8ye::P64 != 6) goto ca8xV; else goto ca8y9;
       ca8xV: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
       ca8y9: // global
           I64[Sp] = block_ca8y7_info;
           R1 = _sa7St::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ca8y0: // global
           I64[Sp] = block_ca8xY_info;
           R1 = _sa7St::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8y7() //  [R1]
         { info_tbl: [(ca8y7,
                       label: block_ca8y7_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8y7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8yd; else goto ca8yc;
       ca8yd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8yc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
     }
 },
 _ca8xY() //  [R1]
         { info_tbl: [(ca8xY,
                       label: block_ca8xY_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8xY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8y4; else goto ca8y3;
       ca8y4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8y3: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
     }
 },
 _sa7Sv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa7Sv: // global
           I64[Sp - 8] = block_ca8xc_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8yu; else goto ca8xe;
       ua8yu: // global
           call _ca8xc(R1) args: 0, res: 0, upd: 0;
       ca8xe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8xc() //  [R1]
         { info_tbl: [(ca8xc,
                       label: block_ca8xc_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8xc: // global
           _sa7Su::P64 = P64[Sp + 8];
           _ca8yh::P64 = R1 & 7;
           if (_ca8yh::P64 < 5) goto ua8yj; else goto ua8yk;
       ua8yj: // global
           if (_ca8yh::P64 < 4) goto ca8xk; else goto ca8xr;
       ca8xk: // global
           R3 = P64[Sp + 16];
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8xr: // global
           I64[Sp + 8] = block_ca8xn_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ua8yk: // global
           if (_ca8yh::P64 < 6) goto ca8xB; else goto ca8xL;
       ca8xB: // global
           I64[Sp + 8] = block_ca8xx_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ca8xL: // global
           I64[Sp + 8] = block_ca8xH_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8xn() //  [R1]
         { info_tbl: [(ca8xn,
                       label: block_ca8xn_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8xn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8xu; else goto ca8xt;
       ca8xu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8xt: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8xx() //  [R1]
         { info_tbl: [(ca8xx,
                       label: block_ca8xx_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8xx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8xE; else goto ca8xD;
       ca8xE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8xD: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8xH() //  [R1]
         { info_tbl: [(ca8xH,
                       label: block_ca8xH_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8xH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8xO; else goto ca8xN;
       ca8xO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8xN: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.683626632 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding_closure" {
     GHC.IO.Handle.Internals.openTextEncoding_closure:
         const GHC.IO.Handle.Internals.openTextEncoding_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding_entry() //  [R2, R3, R4]
         { info_tbl: [(ca8yz,
                       label: GHC.IO.Handle.Internals.openTextEncoding_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8yz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.openTextEncoding1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.68486751 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry() //  [R2]
         { info_tbl: [(ca8yJ,
                       label: GHC.IO.Handle.Internals.flushByteWriteBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8yJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca8yN; else goto ca8yO;
       ca8yN: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8yO: // global
           I64[Sp - 8] = block_ca8yG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8z8; else goto ca8yH;
       ua8z8: // global
           call _ca8yG(R1) args: 0, res: 0, upd: 0;
       ca8yH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8yG() //  [R1]
         { info_tbl: [(ca8yG,
                       label: block_ca8yG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8yG: // global
           I64[Sp - 24] = block_ca8yM_info;
           _sa7SY::P64 = P64[R1 + 15];
           _sa7T0::P64 = P64[R1 + 31];
           _sa7T2::P64 = P64[R1 + 47];
           R1 = P64[_sa7T2::P64 + 8];
           P64[Sp - 16] = _sa7T0::P64;
           P64[Sp - 8] = _sa7T2::P64;
           P64[Sp] = _sa7SY::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8z7; else goto ca8yQ;
       ua8z7: // global
           call _ca8yM(R1) args: 0, res: 0, upd: 0;
       ca8yQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8yM() //  [R1]
         { info_tbl: [(ca8yM,
                       label: block_ca8yM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8yM: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ca8z3; else goto ca8z0;
       ca8z3: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca8z0: // global
           _sa7T0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca8yY_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7T0::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca8yY() //  [R1]
         { info_tbl: [(ca8yY,
                       label: block_ca8yY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8yY: // global
           _sa7T2::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7T2::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7T2::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.686524809 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer_entry() //  [R2]
         { info_tbl: [(ca8zd,
                       label: GHC.IO.Handle.Internals.flushByteWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8zd: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.687957654 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer1_entry() //  [R2]
         { info_tbl: [(ca8zn,
                       label: GHC.IO.Handle.Internals.flushWriteBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8zn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca8zr; else goto ca8zs;
       ca8zr: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8zs: // global
           I64[Sp - 8] = block_ca8zk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8A7; else goto ca8zl;
       ua8A7: // global
           call _ca8zk(R1) args: 0, res: 0, upd: 0;
       ca8zl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8zk() //  [R1]
         { info_tbl: [(ca8zk,
                       label: block_ca8zk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8zk: // global
           I64[Sp - 24] = block_ca8zq_info;
           _sa7Tw::P64 = P64[R1 + 15];
           _sa7Ty::P64 = P64[R1 + 31];
           _sa7TA::P64 = P64[R1 + 47];
           R1 = P64[_sa7TA::P64 + 8];
           P64[Sp - 16] = _sa7Ty::P64;
           P64[Sp - 8] = _sa7TA::P64;
           P64[Sp] = _sa7Tw::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8A6; else goto ca8zu;
       ua8A6: // global
           call _ca8zq(R1) args: 0, res: 0, upd: 0;
       ca8zu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8zq() //  [R1]
         { info_tbl: [(ca8zq,
                       label: block_ca8zq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8zq: // global
           I64[Sp] = block_ca8zy_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ua8A8; else goto ca8zA;
       ua8A8: // global
           call _ca8zy(R1) args: 0, res: 0, upd: 0;
       ca8zA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8zy() //  [R1]
         { info_tbl: [(ca8zy,
                       label: block_ca8zy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8zy: // global
           if (R1 & 7 == 1) goto ua8A4; else goto ca8zL;
       ua8A4: // global
           Sp = Sp + 32;
           call _ca8zZ() args: 0, res: 0, upd: 0;
       ca8zL: // global
           _sa7TY::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_ca8zJ_info;
           R1 = _sa7TY::P64;
           if (R1 & 7 != 0) goto ua8A9; else goto ca8zM;
       ua8A9: // global
           call _ca8zJ(R1) args: 0, res: 0, upd: 0;
       ca8zM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8zJ() //  [R1]
         { info_tbl: [(ca8zJ,
                       label: block_ca8zJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8zJ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ua8A5; else goto ca8zW;
       ua8A5: // global
           Sp = Sp + 32;
           call _ca8zZ() args: 0, res: 0, upd: 0;
       ca8zW: // global
           _sa7Ty::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca8zU_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7Ty::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca8zZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8zZ: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8zU() //  [R1]
         { info_tbl: [(ca8zU,
                       label: block_ca8zU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8zU: // global
           _sa7TA::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7TA::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7TA::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.690108404 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer_entry() //  [R2]
         { info_tbl: [(ca8Ag,
                       label: GHC.IO.Handle.Internals.flushWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ag: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.690850933 UTC

[section ""cstring" . lvl7_ra7Pn_bytes" {
     lvl7_ra7Pn_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.691679907 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf2_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf2_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf2_entry() //  [R1]
         { info_tbl: [(ca8Ar,
                       label: GHC.IO.Handle.Internals.decodeByteBuf2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ar: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8As; else goto ca8At;
       ca8As: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8At: // global
           (_ca8Am::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8Am::I64 == 0) goto ca8Ao; else goto ca8An;
       ca8Ao: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8An: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8Am::I64;
           I64[Sp - 24] = block_ca8Ap_info;
           R2 = lvl7_ra7Pn_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca8Ap() //  [R1]
         { info_tbl: [(ca8Ap,
                       label: block_ca8Ap_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ap: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.693844211 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf1_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf1_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf1_entry() //  [R2, R3]
         { info_tbl: [(ca8AE,
                       label: GHC.IO.Handle.Internals.decodeByteBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8AE: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ca8AF; else goto ca8AG;
       ca8AF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.decodeByteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8AG: // global
           I64[Sp - 16] = block_ca8AB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8BH; else goto ca8AC;
       ua8BH: // global
           call _ca8AB(R1) args: 0, res: 0, upd: 0;
       ca8AC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8AB() //  [R1]
         { info_tbl: [(ca8AB,
                       label: block_ca8AB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8AB: // global
           I64[Sp - 24] = block_ca8AJ_info;
           _sa7Ul::P64 = P64[R1 + 47];
           _sa7Un::P64 = P64[R1 + 63];
           R1 = P64[R1 + 95];
           P64[Sp - 16] = _sa7Un::P64;
           P64[Sp - 8] = P64[_sa7Ul::P64 + 8];
           P64[Sp] = _sa7Ul::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8BG; else goto ca8AL;
       ua8BG: // global
           call _ca8AJ(R1) args: 0, res: 0, upd: 0;
       ca8AL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8AJ() //  [R1]
         { info_tbl: [(ca8AJ,
                       label: block_ca8AJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8AJ: // global
           if (R1 & 7 == 1) goto ca8AX; else goto ca8Bo;
       ca8AX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8B0; else goto ca8AZ;
       ca8B0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8AZ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sa7Uy::P64 = P64[Sp + 16];
           P64[Hp] = _sa7Uy::P64;
           _sa7Ud::P64 = P64[Sp + 32];
           _sa7Un::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Un::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Un::P64);
           I64[Sp + 16] = block_ca8AT_info;
           R3 = _sa7Ud::P64;
           R2 = _sa7Uy::P64;
           Sp = Sp + 16;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ca8Bo: // global
           I64[Sp] = block_ca8B9_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8BI; else goto ca8Ba;
       ua8BI: // global
           call _ca8B9(R1) args: 0, res: 0, upd: 0;
       ca8Ba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8AT() //  [R1]
         { info_tbl: [(ca8AT,
                       label: block_ca8AT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8AT: // global
           I64[Sp] = block_ca8AV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8BJ; else goto ca8B2;
       ua8BJ: // global
           call _ca8AV(R1) args: 0, res: 0, upd: 0;
       ca8B2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8AV() //  [R1]
         { info_tbl: [(ca8AV,
                       label: block_ca8AV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8AV: // global
           _sa7Ul::P64 = P64[Sp + 8];
           _sa7UH::P64 = P64[R1 + 15];
           _sa7UI::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sa7Ul::P64 + 8] = _sa7UH::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Ul::P64);
           R1 = _sa7UI::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8B9() //  [R1]
         { info_tbl: [(ca8B9,
                       label: block_ca8B9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8B9: // global
           I64[Sp - 16] = block_ca8Be_info;
           _sa7UM::P64 = P64[R1 + 7];
           _sa7UN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sa7UN::P64;
           P64[Sp] = _sa7UM::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Be() //  [R1]
         { info_tbl: [(ca8Be,
                       label: block_ca8Be_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Be: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8Bs; else goto ca8Br;
       ca8Bs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Br: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa7Uy::P64 = P64[Sp + 32];
           P64[Hp] = _sa7Uy::P64;
           _sa7Ud::P64 = P64[Sp + 48];
           _sa7Un::P64 = P64[Sp + 24];
           _sa7UM::P64 = P64[Sp + 16];
           _sa7UN::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Un::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Un::P64);
           I64[Sp + 32] = block_ca8Bk_info;
           R5 = _sa7Ud::P64;
           R4 = _sa7Uy::P64;
           R3 = _sa7UN::P64;
           R2 = _sa7UM::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Bk() //  [R1]
         { info_tbl: [(ca8Bk,
                       label: block_ca8Bk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Bk: // global
           I64[Sp] = block_ca8Bm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8BK; else goto ca8Bu;
       ua8BK: // global
           call _ca8Bm(R1) args: 0, res: 0, upd: 0;
       ca8Bu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Bm() //  [R1]
         { info_tbl: [(ca8Bm,
                       label: block_ca8Bm_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Bm: // global
           _sa7Ul::P64 = P64[Sp + 8];
           _sa7V0::P64 = P64[R1 + 7];
           _sa7V1::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa7Ul::P64 + 8] = _sa7V0::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Ul::P64);
           R1 = _sa7V1::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.696897724 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf_entry() //  [R2, R3]
         { info_tbl: [(ca8BP,
                       label: GHC.IO.Handle.Internals.decodeByteBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8BP: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.698634124 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(ca8BZ,
                       label: GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8BZ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ca8C3; else goto ca8C4;
       ca8C3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8C4: // global
           I64[Sp - 16] = block_ca8BW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8CI; else goto ca8BX;
       ua8CI: // global
           call _ca8BW(R1) args: 0, res: 0, upd: 0;
       ca8BX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8BW() //  [R1]
         { info_tbl: [(ca8BW,
                       label: block_ca8BW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8BW: // global
           I64[Sp - 32] = block_ca8C2_info;
           _sa7V6::P64 = R1;
           _sa7V8::P64 = P64[R1 + 15];
           _sa7Va::P64 = P64[R1 + 31];
           _sa7Vc::P64 = P64[R1 + 47];
           R1 = P64[_sa7Vc::P64 + 8];
           P64[Sp - 24] = _sa7V8::P64;
           P64[Sp - 16] = _sa7Va::P64;
           P64[Sp - 8] = _sa7Vc::P64;
           P64[Sp] = _sa7V6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua8CH; else goto ca8C6;
       ua8CH: // global
           call _ca8C2(R1) args: 0, res: 0, upd: 0;
       ca8C6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8C2() //  [R1]
         { info_tbl: [(ca8C2,
                       label: block_ca8C2_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8C2: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ca8Ck; else goto ca8Ce;
       ca8Ck: // global
           _sa7Va::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca8Ch_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa7Va::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
       ca8Ce: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _ca8Ch() //  [R1]
         { info_tbl: [(ca8Ch,
                       label: block_ca8Ch_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ch: // global
           I64[Sp] = block_ca8Cj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8CJ; else goto ca8Cm;
       ua8CJ: // global
           call _ca8Cj(R1) args: 0, res: 0, upd: 0;
       ca8Cm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Cj() //  [R1]
         { info_tbl: [(ca8Cj,
                       label: block_ca8Cj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Cj: // global
           I64[Sp - 8] = block_ca8Cq_info;
           _sa7VD::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa7VD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8CK; else goto ca8Cs;
       ua8CK: // global
           call _ca8Cq(R1) args: 0, res: 0, upd: 0;
       ca8Cs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Cq() //  [R1]
         { info_tbl: [(ca8Cq,
                       label: block_ca8Cq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Cq: // global
           if (R1 & 7 == 1) goto ca8Cy; else goto ca8CC;
       ca8Cy: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca8CC: // global
           _sa7V4::P64 = P64[Sp + 32];
           _sa7V6::P64 = P64[Sp + 24];
           _sa7Vc::P64 = P64[Sp + 16];
           _sa7VD::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Vc::P64 + 8] = _sa7VD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Vc::P64);
           R3 = _sa7V4::P64;
           R2 = _sa7V6::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.700824886 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking_entry() //  [R2,
                                                                R3]
         { info_tbl: [(ca8CP,
                       label: GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8CP: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.704812212 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle2_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle2_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle2_info;
         const 0;
 },
 sat_sa7WE_entry() //  [R1]
         { info_tbl: [(ca8DJ,
                       label: sat_sa7WE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8DJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8DN; else goto ca8DO;
       ca8DN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8DO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8DG_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8DS; else goto ca8DH;
       ua8DS: // global
           call _ca8DG(R1) args: 0, res: 0, upd: 0;
       ca8DH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8DG() //  [R1]
         { info_tbl: [(ca8DG,
                       label: block_ca8DG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8DG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8DR; else goto ca8DQ;
       ca8DR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8DQ: // global
           _sa7Wz::P64 = P64[R1 + 7];
           _sa7Wy::I64 = I64[R1 + 23];
           _sa7WB::I64 = I64[R1 + 31];
           _sa7WC::I64 = I64[R1 + 39];
           _sa7WD::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Wz::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Wy::I64;
           I64[Hp - 16] = _sa7WB::I64;
           I64[Hp - 8] = _sa7WC::I64;
           I64[Hp] = _sa7WD::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7WQ_entry() //  [R1]
         { info_tbl: [(ca8E3,
                       label: sat_sa7WQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8E3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8E7; else goto ca8E8;
       ca8E7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8E8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8E0_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8Ec; else goto ca8E1;
       ua8Ec: // global
           call _ca8E0(R1) args: 0, res: 0, upd: 0;
       ca8E1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8E0() //  [R1]
         { info_tbl: [(ca8E0,
                       label: block_ca8E0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8E0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8Eb; else goto ca8Ea;
       ca8Eb: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8Ea: // global
           _sa7WL::P64 = P64[R1 + 7];
           _sa7WK::I64 = I64[R1 + 23];
           _sa7WN::I64 = I64[R1 + 31];
           _sa7WO::I64 = I64[R1 + 39];
           _sa7WP::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7WL::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7WK::I64;
           I64[Hp - 16] = _sa7WN::I64;
           I64[Hp - 8] = _sa7WO::I64;
           I64[Hp] = _sa7WP::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7X2_entry() //  [R1]
         { info_tbl: [(ca8El,
                       label: sat_sa7X2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8El: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8Ep; else goto ca8Eq;
       ca8Ep: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8Eq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8Ei_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8Eu; else goto ca8Ej;
       ua8Eu: // global
           call _ca8Ei(R1) args: 0, res: 0, upd: 0;
       ca8Ej: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8Ei() //  [R1]
         { info_tbl: [(ca8Ei,
                       label: block_ca8Ei_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ei: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8Et; else goto ca8Es;
       ca8Et: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8Es: // global
           _sa7WX::P64 = P64[R1 + 7];
           _sa7WW::I64 = I64[R1 + 23];
           _sa7WZ::I64 = I64[R1 + 31];
           _sa7X0::I64 = I64[R1 + 39];
           _sa7X1::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7WX::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7WW::I64;
           I64[Hp - 16] = _sa7WZ::I64;
           I64[Hp - 8] = _sa7X0::I64;
           I64[Hp] = _sa7X1::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Xe_entry() //  [R1]
         { info_tbl: [(ca8EF,
                       label: sat_sa7Xe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8EF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8EJ; else goto ca8EK;
       ca8EJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8EK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8EC_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8EO; else goto ca8ED;
       ua8EO: // global
           call _ca8EC(R1) args: 0, res: 0, upd: 0;
       ca8ED: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8EC() //  [R1]
         { info_tbl: [(ca8EC,
                       label: block_ca8EC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8EC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8EN; else goto ca8EM;
       ca8EN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8EM: // global
           _sa7X9::P64 = P64[R1 + 7];
           _sa7X8::I64 = I64[R1 + 23];
           _sa7Xb::I64 = I64[R1 + 31];
           _sa7Xc::I64 = I64[R1 + 39];
           _sa7Xd::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7X9::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7X8::I64;
           I64[Hp - 16] = _sa7Xb::I64;
           I64[Hp - 8] = _sa7Xc::I64;
           I64[Hp] = _sa7Xd::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Xq_entry() //  [R1]
         { info_tbl: [(ca8EX,
                       label: sat_sa7Xq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8EX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8F1; else goto ca8F2;
       ca8F1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8F2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8EU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8F6; else goto ca8EV;
       ua8F6: // global
           call _ca8EU(R1) args: 0, res: 0, upd: 0;
       ca8EV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8EU() //  [R1]
         { info_tbl: [(ca8EU,
                       label: block_ca8EU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8EU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8F5; else goto ca8F4;
       ca8F5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8F4: // global
           _sa7Xl::P64 = P64[R1 + 7];
           _sa7Xk::I64 = I64[R1 + 23];
           _sa7Xn::I64 = I64[R1 + 31];
           _sa7Xo::I64 = I64[R1 + 39];
           _sa7Xp::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Xl::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Xk::I64;
           I64[Hp - 16] = _sa7Xn::I64;
           I64[Hp - 8] = _sa7Xo::I64;
           I64[Hp] = _sa7Xp::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7XC_entry() //  [R1]
         { info_tbl: [(ca8Fh,
                       label: sat_sa7XC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Fh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8Fl; else goto ca8Fm;
       ca8Fl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8Fm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8Fe_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8Fq; else goto ca8Ff;
       ua8Fq: // global
           call _ca8Fe(R1) args: 0, res: 0, upd: 0;
       ca8Ff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8Fe() //  [R1]
         { info_tbl: [(ca8Fe,
                       label: block_ca8Fe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Fe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8Fp; else goto ca8Fo;
       ca8Fp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8Fo: // global
           _sa7Xx::P64 = P64[R1 + 7];
           _sa7Xw::I64 = I64[R1 + 23];
           _sa7Xz::I64 = I64[R1 + 31];
           _sa7XA::I64 = I64[R1 + 39];
           _sa7XB::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Xx::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Xw::I64;
           I64[Hp - 16] = _sa7Xz::I64;
           I64[Hp - 8] = _sa7XA::I64;
           I64[Hp] = _sa7XB::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle2_entry() //  [R2, R3]
         { info_tbl: [(ca8Fr,
                       label: GHC.IO.Handle.Internals.wantReadableHandle2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Fr: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ca8Fs; else goto ca8Ft;
       ca8Fs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8Ft: // global
           I64[Sp - 16] = block_ca8CW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8Gr; else goto ca8CX;
       ua8Gr: // global
           call _ca8CW(R1) args: 0, res: 0, upd: 0;
       ca8CX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8CW() //  [R1]
         { info_tbl: [(ca8CW,
                       label: block_ca8CW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8CW: // global
           I64[Sp - 40] = block_ca8D1_info;
           _sa7VL::P64 = R1;
           _sa7VN::P64 = P64[R1 + 15];
           _sa7VP::P64 = P64[R1 + 31];
           _sa7VR::P64 = P64[R1 + 47];
           _sa7VU::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sa7VN::P64;
           P64[Sp - 24] = _sa7VP::P64;
           P64[Sp - 16] = _sa7VR::P64;
           P64[Sp - 8] = _sa7VU::P64;
           P64[Sp] = _sa7VL::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ua8Gl; else goto ca8D2;
       ua8Gl: // global
           call _ca8D1(R1) args: 0, res: 0, upd: 0;
       ca8D2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8D1() //  [R1]
         { info_tbl: [(ca8D1,
                       label: block_ca8D1_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8D1: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto ca8Fy;
               case 2 : goto ca8FB;
               case 3 : goto ua8Gj;
               case 4, 5 : goto ca8FK;
               case 6 : goto ca8FM;
           }
       ca8FM: // global
           _sa7W5::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_ca8Db_info;
           R1 = _sa7W5::P64;
           if (R1 & 7 != 0) goto ua8Gm; else goto ca8Dc;
       ua8Gm: // global
           call _ca8Db(R1) args: 0, res: 0, upd: 0;
       ca8Dc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca8FK: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ua8Gj: // global
           Sp = Sp + 40;
           call _ca8FR() args: 0, res: 0, upd: 0;
       ca8FB: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca8Fy: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8Db() //  [R1]
         { info_tbl: [(ca8Db,
                       label: block_ca8Db_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Db: // global
           I64[Sp - 16] = block_ca8Dg_info;
           _sa7Wb::I64 = I64[R1 + 39];
           _sa7Wc::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa7Wc::I64;
           I64[Sp] = _sa7Wb::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8Go; else goto ca8Dh;
       ua8Go: // global
           call _ca8Dg(R1) args: 0, res: 0, upd: 0;
       ca8Dh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Dg() //  [R1]
         { info_tbl: [(ca8Dg,
                       label: block_ca8Dg_info
                       rep:StackRep [True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Dg: // global
           if (R1 & 7 == 1) goto ua8Gk; else goto ca8FS;
       ua8Gk: // global
           Sp = Sp + 56;
           call _ca8FR() args: 0, res: 0, upd: 0;
       ca8FS: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca8FV; else goto ca8FU;
       ca8FV: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8FU: // global
           _sa7VR::P64 = P64[Sp + 40];
           if (I64[Sp + 16] == I64[Sp + 8]) goto ca8G7; else goto ca8FX;
       ca8G7: // global
           _sa7VU::P64 = P64[Sp + 48];
           _sa7Xi::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7Xq_info;
           P64[Hp - 24] = _sa7Xi::P64;
           _sa7VI::P64 = P64[Sp + 64];
           _sa7VL::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7Xu::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7XC_info;
           P64[Hp] = _sa7Xu::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 72;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       ca8FX: // global
           _sa7Wh::P64 = P64[_sa7VR::P64 + 8];
           Hp = Hp - 48;
           I64[Sp + 16] = block_ca8Dp_info;
           R1 = _sa7Wh::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ua8Gp; else goto ca8Dq;
       ua8Gp: // global
           call _ca8Dp(R1) args: 0, res: 0, upd: 0;
       ca8Dq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Dp() //  [R1]
         { info_tbl: [(ca8Dp,
                       label: block_ca8Dp_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Dp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca8G0; else goto ca8FZ;
       ca8G0: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8FZ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ca8G6; else goto ca8G2;
       ca8G6: // global
           _sa7VU::P64 = P64[Sp + 32];
           _sa7WU::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7X2_info;
           P64[Hp - 24] = _sa7WU::P64;
           _sa7VI::P64 = P64[Sp + 48];
           _sa7VL::P64 = P64[Sp + 40];
           _sa7VR::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7X6::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7Xe_info;
           P64[Hp] = _sa7X6::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       ca8G2: // global
           Hp = Hp - 48;
           _sa7VP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca8Dx_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa7VP::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca8Dx() //  [R1]
         { info_tbl: [(ca8Dx,
                       label: block_ca8Dx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Dx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca8G5; else goto ca8G4;
       ca8G5: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8G4: // global
           _sa7VI::P64 = P64[Sp + 32];
           _sa7VL::P64 = P64[Sp + 24];
           _sa7VR::P64 = P64[Sp + 8];
           _sa7VU::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           _sa7Ww::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7WE_info;
           P64[Hp - 24] = _sa7Ww::P64;
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7WI::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7WQ_info;
           P64[Hp] = _sa7WI::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8FR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8FR: // global
           R2 = P64[Sp];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.712319534 UTC

[section ""data" . lvl8_ra7Po_closure" {
     lvl8_ra7Po_closure:
         const GHC.IO.Handle.Types.BlockBuffering_con_info;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.718736048 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle5_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle5_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle5_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Gt: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 56, res: 0, upd: 8;
     }
 },
 buf_state_sa7XU_entry() //  [R1]
         { info_tbl: [(ca8I4,
                       label: buf_state_sa7XU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8I4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8I5; else goto ca8I6;
       ca8I5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8I6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8HX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8Id; else goto ca8HY;
       ua8Id: // global
           call _ca8HX(R1) args: 0, res: 0, upd: 0;
       ca8HY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8HX() //  [R1]
         { info_tbl: [(ca8HX,
                       label: block_ca8HX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8HX: // global
           if (R1 & 7 == 3) goto ca8I2; else goto ca8I1;
       ca8I2: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ca8I1: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yk_entry() //  [R1]
         { info_tbl: [(ca8IA,
                       label: sat_sa7Yk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8IA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8IB; else goto ca8IC;
       ca8IB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8IC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.outputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yj_entry() //  [R1]
         { info_tbl: [(ca8IH,
                       label: sat_sa7Yj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8IH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8II; else goto ca8IJ;
       ca8II: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8IJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.inputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yl_entry() //  [R1]
         { info_tbl: [(ca8IK,
                       label: sat_sa7Yl_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8IK: // global
           if ((Sp + -136) < SpLim) (likely: False) goto ca8IM; else goto ca8IN;
       ca8IM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8IN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_ca8Ip_info;
           _sa7XE::P64 = P64[R1 + 16];
           _sa7XF::P64 = P64[R1 + 24];
           _sa7XG::P64 = P64[R1 + 32];
           _sa7XJ::P64 = P64[R1 + 48];
           _sa7XL::P64 = P64[R1 + 56];
           _sa7XM::P64 = P64[R1 + 64];
           _sa7XO::P64 = P64[R1 + 72];
           _sa7XR::P64 = P64[R1 + 80];
           _sa7XS::P64 = P64[R1 + 88];
           _sa7Y1::P64 = P64[R1 + 96];
           _sa7Y5::P64 = P64[R1 + 104];
           _sa7Y8::P64 = P64[R1 + 112];
           _sa7Y9::P64 = P64[R1 + 120];
           _sa7Yc::P64 = P64[R1 + 128];
           R1 = P64[R1 + 40];
           P64[Sp - 128] = _sa7XE::P64;
           P64[Sp - 120] = _sa7XF::P64;
           P64[Sp - 112] = _sa7XG::P64;
           P64[Sp - 104] = _sa7XJ::P64;
           P64[Sp - 96] = _sa7XL::P64;
           P64[Sp - 88] = _sa7XM::P64;
           P64[Sp - 80] = _sa7XO::P64;
           P64[Sp - 72] = _sa7XR::P64;
           P64[Sp - 64] = _sa7XS::P64;
           P64[Sp - 56] = _sa7Y1::P64;
           P64[Sp - 48] = _sa7Y5::P64;
           P64[Sp - 40] = _sa7Y8::P64;
           P64[Sp - 32] = _sa7Y9::P64;
           P64[Sp - 24] = _sa7Yc::P64;
           Sp = Sp - 136;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8Ip() //  [R1]
         { info_tbl: [(ca8Ip,
                       label: block_ca8Ip_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ip: // global
           I64[Sp] = block_ca8Ir_info;
           _sa7Yg::P64 = R1;
           R1 = P64[Sp + 96];
           P64[Sp + 96] = _sa7Yg::P64;
           if (R1 & 7 != 0) goto ua8IS; else goto ca8Is;
       ua8IS: // global
           call _ca8Ir(R1) args: 0, res: 0, upd: 0;
       ca8Is: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8Ir() //  [R1]
         { info_tbl: [(ca8Ir,
                       label: block_ca8Ir_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ir: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ca8IR; else goto ca8IQ;
       ca8IR: // global
           HpAlloc = 184;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8IQ: // global
           _sa7Yi::P64 = P64[R1 + 7];
           I64[Hp - 176] = sat_sa7Yk_info;
           _sa7XM::P64 = P64[Sp + 48];
           P64[Hp - 160] = _sa7XM::P64;
           I64[Hp - 152] = sat_sa7Yj_info;
           P64[Hp - 136] = _sa7XM::P64;
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = _sa7Yi::P64;
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = Hp - 152;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 127;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yr_entry() //  [R1]
         { info_tbl: [(ca8J6,
                       label: sat_sa7Yr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8J6: // global
           _sa7Yr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca8J7; else goto ca8J8;
       ca8J8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8Ja; else goto ca8J9;
       ca8Ja: // global
           HpAlloc = 16;
           goto ca8J7;
       ca8J7: // global
           R1 = _sa7Yr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8J9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Yr::P64;
           _sa7XI::P64 = P64[_sa7Yr::P64 + 16];
           _sa7Yf::P64 = P64[_sa7Yr::P64 + 24];
           _sa7Yp::P64 = P64[_sa7Yr::P64 + 32];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _sa7Yf::P64;
           R3 = Hp - 7;
           R2 = _sa7XI::P64;
           R1 = _sa7Yp::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Z1_entry() //  [R1]
         { info_tbl: [(ca8Jk,
                       label: sat_sa7Z1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Jk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8Jl; else goto ca8Jm;
       ca8Jl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8Jm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8Jd_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8Jt; else goto ca8Je;
       ua8Jt: // global
           call _ca8Jd(R1) args: 0, res: 0, upd: 0;
       ca8Je: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8Jd() //  [R1]
         { info_tbl: [(ca8Jd,
                       label: block_ca8Jd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Jd: // global
           if (R1 & 7 == 1) goto ca8Jh; else goto ca8Ji;
       ca8Jh: // global
           R1 = lvl8_ra7Po_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ca8Ji: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(ca8Jy,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle5_info
                       rep:HeapRep static {
                             Fun {arity: 12
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Jy: // global
           if ((Sp + -96) < SpLim) (likely: False) goto ca8Jz; else goto ca8JA;
       ca8Jz: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 96, res: 0, upd: 8;
       ca8JA: // global
           I64[Sp - 48] = block_ca8Hm_info;
           R1 = P64[Sp + 16];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ua8LK; else goto ca8Hn;
       ua8LK: // global
           call _ca8Hm(R1) args: 0, res: 0, upd: 0;
       ca8Hn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Hm() //  [R1]
         { info_tbl: [(ca8Hm,
                       label: block_ca8Hm_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Hm: // global
           if (R1 & 7 == 1) goto ca8Jv; else goto ca8Jw;
       ca8Jv: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _ca8GA() args: 0, res: 0, upd: 0;
       ca8Jw: // global
           I64[Sp] = block_ca8Hs_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8LC; else goto ca8Ht;
       ua8LC: // global
           call _ca8Hs(R1) args: 0, res: 0, upd: 0;
       ca8Ht: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Hs() //  [R1]
         { info_tbl: [(ca8Hs,
                       label: block_ca8Hs_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Hs: // global
           I64[Sp - 16] = block_ca8Kt_info;
           _sa7Z6::P64 = P64[R1 + 15];
           _sa7Z7::P64 = P64[R1 + 23];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _sa7Z7::P64;
           P64[Sp] = _sa7Z6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8LE; else goto ca8KP;
       ua8LE: // global
           call _ca8Kt(R1) args: 0, res: 0, upd: 0;
       ca8KP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Kt() //  [R1]
         { info_tbl: [(ca8Kt,
                       label: block_ca8Kt_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Kt: // global
           _sa7Z6::P64 = P64[Sp + 16];
           _ca8Le::P64 = R1 & 7;
           if (_ca8Le::P64 != 3) goto ua8Lm; else goto ca8L0;
       ua8Lm: // global
           if (_ca8Le::P64 != 6) goto ca8KV; else goto ca8L9;
       ca8KV: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
       ca8L9: // global
           I64[Sp] = block_ca8L7_info;
           R1 = _sa7Z6::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ca8L0: // global
           I64[Sp] = block_ca8KY_info;
           R1 = _sa7Z6::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8L7() //  [R1]
         { info_tbl: [(ca8L7,
                       label: block_ca8L7_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8L7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8Ld; else goto ca8Lc;
       ca8Ld: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Lc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
     }
 },
 _ca8KY() //  [R1]
         { info_tbl: [(ca8KY,
                       label: block_ca8KY_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8KY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8L4; else goto ca8L3;
       ca8L4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8L3: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
     }
 },
 _sa7Z8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa7Z8: // global
           I64[Sp - 8] = block_ca8HC_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8LO; else goto ca8HD;
       ua8LO: // global
           call _ca8HC(R1) args: 0, res: 0, upd: 0;
       ca8HD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8HC() //  [R1]
         { info_tbl: [(ca8HC,
                       label: block_ca8HC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8HC: // global
           _sa7Z7::P64 = P64[Sp + 8];
           _ca8Lh::P64 = R1 & 7;
           if (_ca8Lh::P64 < 5) goto ua8Lk; else goto ua8Ll;
       ua8Lk: // global
           if (_ca8Lh::P64 < 4) goto ca8Kz; else goto ca8KB;
       ca8Kz: // global
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _ca8GA() args: 0, res: 0, upd: 0;
       ca8KB: // global
           I64[Sp + 8] = block_ca8HI_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ua8Ll: // global
           if (_ca8Lh::P64 < 6) goto ca8KG; else goto ca8KL;
       ca8KG: // global
           I64[Sp + 8] = block_ca8HN_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ca8KL: // global
           I64[Sp + 8] = block_ca8HS_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8HI() //  [R1]
         { info_tbl: [(ca8HI,
                       label: block_ca8HI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8HI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8KE; else goto ca8KD;
       ca8KE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8KD: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _ca8GA() args: 0, res: 0, upd: 0;
     }
 },
 _ca8HN() //  [R1]
         { info_tbl: [(ca8HN,
                       label: block_ca8HN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8HN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8KJ; else goto ca8KI;
       ca8KJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8KI: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _ca8GA() args: 0, res: 0, upd: 0;
     }
 },
 _ca8HS() //  [R1]
         { info_tbl: [(ca8HS,
                       label: block_ca8HS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8HS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8KO; else goto ca8KN;
       ca8KO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8KN: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _ca8GA() args: 0, res: 0, upd: 0;
     }
 },
 _ca8GA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8GA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8JD; else goto ca8JC;
       ca8JD: // global
           HpAlloc = 24;
           _sa7XR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca8Gz_info;
           R2 = P64[Sp];
           R1 = _sa7XR::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ca8JC: // global
           I64[Hp - 16] = buf_state_sa7XU_info;
           P64[Hp] = P64[Sp + 56];
           I64[Sp - 16] = block_ca8GE_info;
           R2 = P64[Sp + 24];
           I64[Sp - 40] = stg_ap_ppv_info;
           P64[Sp - 32] = P64[Sp + 40];
           _ca8GC::P64 = Hp - 16;
           P64[Sp - 24] = _ca8GC::P64;
           P64[Sp - 8] = _ca8GC::P64;
           Sp = Sp - 40;
           call GHC.IO.BufferedIO.newBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca8Gz() //  [R1, R2]
         { info_tbl: [(ca8Gz,
                       label: block_ca8Gz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Gz: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _ca8GA() args: 0, res: 0, upd: 0;
     }
 },
 _ca8GE() //  [R1]
         { info_tbl: [(ca8GE,
                       label: block_ca8GE_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8GE: // global
           I64[Sp - 8] = block_ca8GG_info;
           _sa7XY::P64 = R1;
           R1 = R1;
           P64[Sp] = _sa7XY::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8GG() //  [R1]
         { info_tbl: [(ca8GG,
                       label: block_ca8GG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8GG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8JH; else goto ca8JG;
       ca8JH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8JG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_ca8GJ_info;
           _sa7Y1::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _sa7Y1::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8GJ() //  [R1]
         { info_tbl: [(ca8GJ,
                       label: block_ca8GJ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8GJ: // global
           I64[Sp] = block_ca8GN_info;
           _sa7Y5::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _sa7Y5::P64;
           if (R1 & 7 != 0) goto ua8Lz; else goto ca8GO;
       ua8Lz: // global
           call _ca8GN(R1) args: 0, res: 0, upd: 0;
       ca8GO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8GN() //  [R1]
         { info_tbl: [(ca8GN,
                       label: block_ca8GN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8GN: // global
           if (R1 & 7 == 1) goto ca8K8; else goto ca8Kh;
       ca8K8: // global
           I64[Sp] = block_ca8GS_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       ca8Kh: // global
           I64[Sp] = block_ca8H6_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8GS() //  [R1]
         { info_tbl: [(ca8GS,
                       label: block_ca8GS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8GS: // global
           I64[Sp - 8] = block_ca8GU_info;
           _sa7Yz::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sa7Yz::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8GU() //  [R1]
         { info_tbl: [(ca8GU,
                       label: block_ca8GU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8GU: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca8Kc; else goto ca8Kb;
       ca8Kc: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Kb: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_ca8H1_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8H1() //  [R1]
         { info_tbl: [(ca8H1,
                       label: block_ca8H1_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8H1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca8Kf; else goto ca8Ke;
       ca8Kf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Ke: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 7;
           P64[Sp] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           call _sa7Y6() args: 0, res: 0, upd: 0;
     }
 },
 _ca8H6() //  [R1]
         { info_tbl: [(ca8H6,
                       label: block_ca8H6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8H6: // global
           I64[Sp - 8] = block_ca8H8_info;
           _sa7YM::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sa7YM::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8H8() //  [R1]
         { info_tbl: [(ca8H8,
                       label: block_ca8H8_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8H8: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca8Kl; else goto ca8Kk;
       ca8Kl: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Kk: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_ca8Hf_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Hf() //  [R1]
         { info_tbl: [(ca8Hf,
                       label: block_ca8Hf_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Hf: // global
           I64[Sp] = block_ca8Hh_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 64];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ca8Hh() //  [R1]
         { info_tbl: [(ca8Hh,
                       label: block_ca8Hh_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Hh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca8Kp; else goto ca8Ko;
       ca8Kp: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Ko: // global
           I64[Hp - 32] = sat_sa7Z1_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = Hp - 32;
           P64[Sp + 16] = Hp - 7;
           call _sa7Y6() args: 0, res: 0, upd: 0;
     }
 },
 _sa7Y6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa7Y6: // global
           I64[Sp - 8] = block_ca8Ih_info;
           R1 = GHC.IO.Handle.Types.BufferListNil_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Ih() //  [R1]
         { info_tbl: [(ca8Ih,
                       label: block_ca8Ih_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ih: // global
           I64[Sp - 8] = block_ca8Ij_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _ca8Ij() //  [R1]
         { info_tbl: [(ca8Ij,
                       label: block_ca8Ij_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ij: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ca8JN; else goto ca8JM;
       ca8JN: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8JM: // global
           I64[Hp - 128] = sat_sa7Yl_info;
           P64[Hp - 112] = P64[Sp + 56];
           P64[Hp - 104] = P64[Sp + 64];
           P64[Hp - 96] = P64[Sp + 72];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 112];
           P64[Hp - 64] = P64[Sp + 120];
           P64[Hp - 56] = P64[Sp + 136];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 104];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 80] = block_ca8IT_info;
           R2 = Hp - 128;
           _sa7Yf::P64 = R1;
           R1 = R1;
           P64[Sp + 136] = _sa7Yf::P64;
           Sp = Sp + 80;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8IT() //  []
         { info_tbl: [(ca8IT,
                       label: block_ca8IT_info
                       rep:StackRep [False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8IT: // global
           I64[Sp] = block_ca8IV_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ua8LJ; else goto ca8IW;
       ua8LJ: // global
           call _ca8IV(R1) args: 0, res: 0, upd: 0;
       ca8IW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8IV() //  [R1]
         { info_tbl: [(ca8IV,
                       label: block_ca8IV_info
                       rep:StackRep [False, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8IV: // global
           _sa7XI::P64 = P64[Sp + 8];
           _sa7Yf::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto ca8JS; else goto ca8JZ;
       ca8JS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8JV; else goto ca8JU;
       ca8JV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8JU: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = _sa7XI::P64;
           P64[Hp] = _sa7Yf::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca8JZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca8K2; else goto ca8K1;
       ca8K2: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8K1: // global
           _sa7Yp::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_sa7Yr_info;
           P64[Hp - 16] = _sa7XI::P64;
           P64[Hp - 8] = _sa7Yf::P64;
           P64[Hp] = _sa7Yp::P64;
           I64[Sp] = block_ca8JW_info;
           R3 = Hp - 32;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _sa7Yf::P64;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8JW() //  [R1]
         { info_tbl: [(ca8JW,
                       label: block_ca8JW_info
                       rep:StackRep [False, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8JW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8K5; else goto ca8K4;
       ca8K5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8K4: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.731031463 UTC

[section ""data" . GHC.IO.Handle.Internals.mkHandle_closure" {
     GHC.IO.Handle.Internals.mkHandle_closure:
         const GHC.IO.Handle.Internals.mkHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8LQ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkHandle_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 56, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkHandle_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca8LU,
                       label: GHC.IO.Handle.Internals.mkHandle_info
                       rep:HeapRep static {
                             Fun {arity: 12
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8LU: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.732228249 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO1_closure" {
     GHC.IO.Handle.Internals.debugIO1_closure:
         const GHC.IO.Handle.Internals.debugIO1_info;
 },
 GHC.IO.Handle.Internals.debugIO1_entry() //  []
         { info_tbl: [(ca8M1,
                       label: GHC.IO.Handle.Internals.debugIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8M1: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.733074243 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO_closure" {
     GHC.IO.Handle.Internals.debugIO_closure:
         const GHC.IO.Handle.Internals.debugIO_info;
 },
 GHC.IO.Handle.Internals.debugIO_entry() //  [R2]
         { info_tbl: [(ca8M8,
                       label: GHC.IO.Handle.Internals.debugIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8M8: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.debugIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.73759195 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwriteCharBuffer_closure" {
     GHC.IO.Handle.Internals.$wwriteCharBuffer_closure:
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_info;
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Mc: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(ca8Mj,
                       label: GHC.IO.Handle.Internals.$wwriteCharBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Mj: // global
           if ((Sp + -104) < SpLim) (likely: False) goto ca8Mk; else goto ua8Pp;
       ca8Mk: // global
           R1 = GHC.IO.Handle.Internals.$wwriteCharBuffer_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ua8Pp: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _ca8Md() args: 0, res: 0, upd: 0;
     }
 },
 _ca8Md() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Md: // global
           _sa7Zz::P64 = P64[Sp];
           I64[Sp] = block_ca8Mg_info;
           R1 = _sa7Zz::P64;
           if (R1 & 7 != 0) goto ua8PF; else goto ca8Mh;
       ua8PF: // global
           call _ca8Mg(R1) args: 0, res: 0, upd: 0;
       ca8Mh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Mg() //  [R1]
         { info_tbl: [(ca8Mg,
                       label: block_ca8Mg_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Mg: // global
           I64[Sp - 48] = block_ca8Mq_info;
           _sa7ZH::P64 = R1;
           _sa7ZJ::P64 = P64[R1 + 15];
           _sa7ZL::P64 = P64[R1 + 31];
           _sa7ZN::P64 = P64[R1 + 47];
           _sa7ZO::P64 = P64[R1 + 55];
           R1 = P64[R1 + 87];
           P64[Sp - 40] = _sa7ZJ::P64;
           P64[Sp - 32] = _sa7ZL::P64;
           P64[Sp - 24] = _sa7ZN::P64;
           P64[Sp - 16] = _sa7ZO::P64;
           P64[Sp - 8] = P64[_sa7ZN::P64 + 8];
           P64[Sp] = _sa7ZH::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ua8PG; else goto ca8Ou;
       ua8PG: // global
           call _ca8Mq(R1) args: 0, res: 0, upd: 0;
       ca8Ou: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Mq() //  [R1]
         { info_tbl: [(ca8Mq,
                       label: block_ca8Mq_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Mq: // global
           if (R1 & 7 == 1) goto ca8OI; else goto ca8Pa;
       ca8OI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8OL; else goto ca8OK;
       ca8OL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8OK: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_ca8Oz_info;
           R3 = P64[Sp + 40];
           R2 = Hp - 47;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ca8Pa: // global
           I64[Sp] = block_ca8OV_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8PI; else goto ca8OW;
       ua8PI: // global
           call _ca8OV(R1) args: 0, res: 0, upd: 0;
       ca8OW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Oz() //  [R1]
         { info_tbl: [(ca8Oz,
                       label: block_ca8Oz_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Oz: // global
           I64[Sp] = block_ca8OB_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8Q1; else goto ca8OC;
       ua8Q1: // global
           call _ca8OB(R1) args: 0, res: 0, upd: 0;
       ca8OC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8OB() //  [R1]
         { info_tbl: [(ca8OB,
                       label: block_ca8OB_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8OB: // global
           I64[Sp] = block_ca8OG_info;
           _sa80U::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp + 96] = _sa80U::P64;
           if (R1 & 7 != 0) goto ua8Q2; else goto ca8OO;
       ua8Q2: // global
           call _ca8OG(R1) args: 0, res: 0, upd: 0;
       ca8OO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8OG() //  [R1]
         { info_tbl: [(ca8OG,
                       label: block_ca8OG_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8OG: // global
           P64[Sp + 96] = P64[Sp + 96];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 72] = P64[R1 + 7];
           P64[Sp + 64] = P64[R1 + 15];
           I64[Sp + 56] = I64[R1 + 31];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 8;
           call _ca8Ms() args: 0, res: 0, upd: 0;
     }
 },
 _ca8OV() //  [R1]
         { info_tbl: [(ca8OV,
                       label: block_ca8OV_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8OV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8Pd; else goto ca8Pc;
       ca8Pd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Pc: // global
           _sa815::P64 = P64[R1 + 7];
           _sa816::P64 = P64[R1 + 15];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_ca8P1_info;
           R5 = P64[Sp + 40];
           R4 = Hp - 47;
           R3 = _sa816::P64;
           R2 = _sa815::P64;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca8P1() //  [R1]
         { info_tbl: [(ca8P1,
                       label: block_ca8P1_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8P1: // global
           I64[Sp] = block_ca8P3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8Q4; else goto ca8P4;
       ua8Q4: // global
           call _ca8P3(R1) args: 0, res: 0, upd: 0;
       ca8P4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8P3() //  [R1]
         { info_tbl: [(ca8P3,
                       label: block_ca8P3_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8P3: // global
           I64[Sp] = block_ca8P8_info;
           _sa81f::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _sa81f::P64;
           if (R1 & 7 != 0) goto ua8Q5; else goto ca8Pg;
       ua8Q5: // global
           call _ca8P8(R1) args: 0, res: 0, upd: 0;
       ca8Pg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8P8() //  [R1]
         { info_tbl: [(ca8P8,
                       label: block_ca8P8_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8P8: // global
           I64[Sp] = I64[R1 + 47];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp + 56] = I64[R1 + 31];
           P64[Sp + 64] = P64[R1 + 15];
           P64[Sp + 72] = P64[R1 + 7];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 96] = P64[Sp + 96];
           Sp = Sp - 8;
           call _ca8Ms() args: 0, res: 0, upd: 0;
     }
 },
 _ca8Ms() //  []
         { info_tbl: [(ca8Ms,
                       label: block_ca8Ms_info
                       rep:StackRep [True, False, False, False, False, True, False, True,
                                     False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ms: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8Mx; else goto ca8Mw;
       ca8Mx: // global
           HpAlloc = 56;
           I64[Sp] = block_ca8Ms_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ca8Mw: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 88];
           _sa807::I64 = I64[Sp + 64];
           I64[Hp - 16] = _sa807::I64;
           I64[Hp - 8] = I64[Sp + 48];
           _sa809::I64 = I64[Sp + 8];
           I64[Hp] = _sa809::I64;
           _ca8My::P64 = Hp - 47;
           if (_sa807::I64 == _sa809::I64) goto ua8Ps; else goto ca8N1;
       ua8Ps: // global
           P64[Sp + 96] = _ca8My::P64;
           Sp = Sp + 16;
           call _sa80b() args: 0, res: 0, upd: 0;
       ca8N1: // global
           I64[Sp] = block_ca8MZ_info;
           R1 = P64[Sp + 104];
           P64[Sp + 88] = _ca8My::P64;
           if (R1 & 7 != 0) goto ua8PJ; else goto ca8N2;
       ua8PJ: // global
           call _ca8MZ(R1) args: 0, res: 0, upd: 0;
       ca8N2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8MZ() //  [R1]
         { info_tbl: [(ca8MZ,
                       label: block_ca8MZ_info
                       rep:StackRep [True, False, False, False, False, True, False, True,
                                     True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8MZ: // global
           _sa7ZO::P64 = P64[Sp + 40];
           _sa80r::P64 = P64[R1 + 7];
           _sa80s::P64 = P64[R1 + 15];
           _sa80q::I64 = I64[R1 + 23];
           _sa80t::I64 = I64[R1 + 31];
           _sa80u::I64 = I64[R1 + 39];
           _sa80v::I64 = I64[R1 + 47];
           if (_sa80u::I64 == _sa80v::I64) goto sa80w; else goto ca8Or;
       ca8Or: // global
           if (_sa80u::I64 != I64[Sp + 96]) goto sa80w; else goto ua8Pt;
       sa80w: // global
           I64[Sp - 8] = block_ca8Nc_info;
           R1 = _sa7ZO::P64;
           I64[Sp] = _sa80v::I64;
           I64[Sp + 40] = _sa80u::I64;
           I64[Sp + 64] = _sa80t::I64;
           P64[Sp + 72] = _sa80s::P64;
           P64[Sp + 80] = _sa80r::P64;
           I64[Sp + 96] = _sa80q::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8PO; else goto ca8Ne;
       ua8PO: // global
           call _ca8Nc(R1) args: 0, res: 0, upd: 0;
       ca8Ne: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ua8Pt: // global
           P64[Sp + 96] = P64[Sp + 88];
           Sp = Sp + 16;
           call _sa80b() args: 0, res: 0, upd: 0;
     }
 },
 _ca8Nc() //  [R1]
         { info_tbl: [(ca8Nc,
                       label: block_ca8Nc_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Nc: // global
           _ca8Pm::P64 = R1 & 7;
           if (_ca8Pm::P64 < 3) goto ua8Po; else goto ca8NB;
       ua8Po: // global
           _ca8My::P64 = P64[Sp + 96];
           if (_ca8Pm::P64 < 2) goto ua8Pu; else goto ca8Nw;
       ua8Pu: // global
           P64[Sp + 104] = _ca8My::P64;
           Sp = Sp + 24;
           call _sa80b() args: 0, res: 0, upd: 0;
       ca8Nw: // global
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _ca8My::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto ua8Pv; else goto ua8Pw;
       ua8Pv: // global
           Sp = Sp + 120;
           call _ca8Oe() args: 0, res: 0, upd: 0;
       ua8Pw: // global
           Sp = Sp + 8;
           call _ca8Od() args: 0, res: 0, upd: 0;
       ca8NB: // global
           I64[Sp] = block_ca8Nz_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto ua8PQ; else goto ca8NC;
       ua8PQ: // global
           call _ca8Nz(R1) args: 0, res: 0, upd: 0;
       ca8NC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Nz() //  [R1]
         { info_tbl: [(ca8Nz,
                       label: block_ca8Nz_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Nz: // global
           if (R1 & 7 == 1) goto ca8NQ; else goto ca8NV;
       ca8NQ: // global
           _ca8My::P64 = P64[Sp + 96];
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _ca8My::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto ua8PA; else goto ua8PB;
       ua8PA: // global
           Sp = Sp + 120;
           call _ca8Oe() args: 0, res: 0, upd: 0;
       ua8PB: // global
           Sp = Sp + 8;
           call _ca8Od() args: 0, res: 0, upd: 0;
       ca8NV: // global
           I64[Sp] = block_ca8NT_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8PU; else goto ca8NW;
       ua8PU: // global
           call _ca8NT(R1) args: 0, res: 0, upd: 0;
       ca8NW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8NT() //  [R1]
         { info_tbl: [(ca8NT,
                       label: block_ca8NT_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8NT: // global
           _ca8My::P64 = P64[Sp + 96];
           if (%MO_S_Lt_W64(I64[Sp + 16] - I64[Sp + 56],
                            I64[R1 + 7])) goto ca8Og; else goto ua8Px;
       ca8Og: // global
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _ca8My::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto ua8Py; else goto ua8Pz;
       ua8Py: // global
           Sp = Sp + 120;
           call _ca8Oe() args: 0, res: 0, upd: 0;
       ua8Pz: // global
           Sp = Sp + 8;
           call _ca8Od() args: 0, res: 0, upd: 0;
       ua8Px: // global
           P64[Sp + 104] = _ca8My::P64;
           Sp = Sp + 24;
           call _sa80b() args: 0, res: 0, upd: 0;
     }
 },
 _ca8Od() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Od: // global
           P64[Sp + 56] = P64[Sp + 56];
           _sa7ZD::I64 = I64[Sp + 64];
           I64[Sp + 64] = I64[Sp + 96];
           _sa7ZC::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sa7ZC::P64;
           I64[Sp + 88] = _sa7ZD::I64;
           I64[Sp + 96] = I64[Sp + 40];
           I64[Sp + 104] = I64[Sp];
           Sp = Sp + 56;
           call _ca8Md() args: 0, res: 0, upd: 0;
     }
 },
 _sa80b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa80b: // global
           _sa7ZL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca8ME_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7ZL::P64;
           P64[Sp] = P64[Sp + 80];
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca8ME() //  [R1]
         { info_tbl: [(ca8ME,
                       label: block_ca8ME_info
                       rep:StackRep [False, True, True, False, True, True, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ME: // global
           _sa7ZN::P64 = P64[Sp + 8];
           _sa803::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           I64[Sp + 24] = block_ca8MJ_info;
           R1 = _sa803::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ua8PL; else goto ca8MM;
       ua8PL: // global
           call _ca8MJ(R1) args: 0, res: 0, upd: 0;
       ca8MM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8MJ() //  [R1]
         { info_tbl: [(ca8MJ,
                       label: block_ca8MJ_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8MJ: // global
           _sa80l::I64 = I64[R1 + 39];
           _sa80m::I64 = I64[R1 + 47];
           if (_sa80l::I64 == _sa80m::I64) goto ua8PD; else goto ca8MU;
       ua8PD: // global
           Sp = Sp + 64;
           call _ca8Oe() args: 0, res: 0, upd: 0;
       ca8MU: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 40] = I64[R1 + 31];
           I64[Sp + 48] = _sa80l::I64;
           I64[Sp + 56] = _sa80m::I64;
           Sp = Sp + 8;
           call _ca8Md() args: 0, res: 0, upd: 0;
     }
 },
 _ca8Oe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Oe: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.747727781 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer1_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer1_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer1_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer1_entry() //  [R2, R3]
         { info_tbl: [(ca8Qe,
                       label: GHC.IO.Handle.Internals.writeCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Qe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8Qf; else goto ca8Qg;
       ca8Qf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.writeCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8Qg: // global
           I64[Sp - 16] = block_ca8Qb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8Qk; else goto ca8Qc;
       ua8Qk: // global
           call _ca8Qb(R1) args: 0, res: 0, upd: 0;
       ca8Qc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Qb() //  [R1]
         { info_tbl: [(ca8Qb,
                       label: block_ca8Qb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Qb: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.748907148 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer_entry() //  [R2, R3]
         { info_tbl: [(ca8Qp,
                       label: GHC.IO.Handle.Internals.writeCharBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Qp: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.writeCharBuffer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.751780352 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer3_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer3_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer3_info;
 },
 sat_sa82j_entry() //  [R1]
         { info_tbl: [(ca8R0,
                       label: sat_sa82j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8R0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8R4; else goto ca8R5;
       ca8R4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8R5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8QX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8R9; else goto ca8QY;
       ua8R9: // global
           call _ca8QX(R1) args: 0, res: 0, upd: 0;
       ca8QY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8QX() //  [R1]
         { info_tbl: [(ca8QX,
                       label: block_ca8QX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8QX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8R8; else goto ca8R7;
       ca8R8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8R7: // global
           _sa82e::P64 = P64[R1 + 7];
           _sa82f::P64 = P64[R1 + 15];
           _sa82d::I64 = I64[R1 + 23];
           _sa82g::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa82e::P64;
           P64[Hp - 32] = _sa82f::P64;
           I64[Hp - 24] = _sa82d::I64;
           I64[Hp - 16] = _sa82g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa82C_entry() //  [R1]
         { info_tbl: [(ca8Rw,
                       label: sat_sa82C_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Rw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca8RD; else goto ca8RE;
       ca8RD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8RE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ca8Rt_info;
           _sa82s::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa82s::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua8RI; else goto ca8Ru;
       ua8RI: // global
           call _ca8Rt(R1) args: 0, res: 0, upd: 0;
       ca8Ru: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8Rt() //  [R1]
         { info_tbl: [(ca8Rt,
                       label: block_ca8Rt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Rt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8RH; else goto ca8RG;
       ca8RH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8RG: // global
           _sa82w::P64 = P64[R1 + 7];
           _sa82x::P64 = P64[R1 + 15];
           _sa82v::I64 = I64[R1 + 23];
           _sa82y::I64 = I64[R1 + 31];
           _sa82A::I64 = I64[R1 + 47];
           _sa82B::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa82w::P64;
           P64[Hp - 32] = _sa82x::P64;
           I64[Hp - 24] = _sa82v::I64;
           I64[Hp - 16] = _sa82y::I64;
           I64[Hp - 8] = _sa82B::I64;
           I64[Hp] = _sa82A::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushCharBuffer3_entry() //  [R2]
         { info_tbl: [(ca8RJ,
                       label: GHC.IO.Handle.Internals.flushCharBuffer3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8RJ: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ca8RK; else goto ca8RL;
       ca8RK: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8RL: // global
           I64[Sp - 8] = block_ca8Qw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8SR; else goto ca8Qx;
       ua8SR: // global
           call _ca8Qw(R1) args: 0, res: 0, upd: 0;
       ca8Qx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Qw() //  [R1]
         { info_tbl: [(ca8Qw,
                       label: block_ca8Qw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Qw: // global
           I64[Sp - 32] = block_ca8QB_info;
           _sa81G::P64 = P64[R1 + 47];
           _sa81I::P64 = P64[R1 + 63];
           _sa81J::P64 = P64[R1 + 71];
           _sa81M::P64 = P64[R1 + 95];
           R1 = P64[_sa81J::P64 + 8];
           P64[Sp - 24] = _sa81I::P64;
           P64[Sp - 16] = _sa81J::P64;
           P64[Sp - 8] = _sa81M::P64;
           P64[Sp] = _sa81G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua8SL; else goto ca8QC;
       ua8SL: // global
           call _ca8QB(R1) args: 0, res: 0, upd: 0;
       ca8QC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8QB() //  [R1]
         { info_tbl: [(ca8QB,
                       label: block_ca8QB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8QB: // global
           I64[Sp - 16] = block_ca8QG_info;
           _sa81Z::I64 = I64[R1 + 39];
           _sa820::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa820::I64;
           I64[Sp] = _sa81Z::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8SM; else goto ca8QH;
       ua8SM: // global
           call _ca8QG(R1) args: 0, res: 0, upd: 0;
       ca8QH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8QG() //  [R1]
         { info_tbl: [(ca8QG,
                       label: block_ca8QG_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8QG: // global
           if (R1 & 7 != 1) goto ca8Sy; else goto ca8Su;
       ca8Su: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ca8Sy; else goto ca8RQ;
       ca8Sy: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca8RQ: // global
           _sa825::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_ca8QO_info;
           R1 = _sa825::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ua8SN; else goto ca8QP;
       ua8SN: // global
           call _ca8QO(R1) args: 0, res: 0, upd: 0;
       ca8QP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8QO() //  [R1]
         { info_tbl: [(ca8QO,
                       label: block_ca8QO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8QO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8RT; else goto ca8RS;
       ca8RT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8RS: // global
           _sa81J::P64 = P64[Sp + 8];
           _sa827::P64 = P64[R1 + 7];
           _sa828::P64 = P64[R1 + 15];
           _sa82b::P64 = P64[_sa81J::P64 + 8];
           I64[Hp - 16] = sat_sa82j_info;
           P64[Hp] = _sa82b::P64;
           call MO_WriteBarrier();
           P64[_sa81J::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81J::P64);
           I64[Sp - 8] = block_ca8Rd_info;
           R1 = _sa82b::P64;
           P64[Sp] = _sa828::P64;
           P64[Sp + 8] = _sa827::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8SO; else goto ca8Re;
       ua8SO: // global
           call _ca8Rd(R1) args: 0, res: 0, upd: 0;
       ca8Re: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Rd() //  [R1]
         { info_tbl: [(ca8Rd,
                       label: block_ca8Rd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Rd: // global
           _sa82s::I64 = I64[R1 + 39];
           if (_sa82s::I64 != 0) goto ca8RW; else goto ca8Sr;
       ca8RW: // global
           I64[Sp - 24] = block_ca8Rk_info;
           _sa82n::P64 = P64[R1 + 7];
           _sa82o::P64 = P64[R1 + 15];
           _sa82m::I64 = I64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 16] = _sa82o::P64;
           I64[Sp - 8] = _sa82s::I64;
           P64[Sp] = _sa82n::P64;
           I64[Sp + 24] = _sa82m::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8SP; else goto ca8Rl;
       ua8SP: // global
           call _ca8Rk(R1) args: 0, res: 0, upd: 0;
       ca8Rl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca8Sr: // global
           _sa81G::P64 = P64[Sp + 32];
           _sa828::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = _sa828::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca8Rk() //  [R1]
         { info_tbl: [(ca8Rk,
                       label: block_ca8Rk_info
                       rep:StackRep [False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Rk: // global
           if (R1 & 7 == 1) goto ca8RY; else goto ca8Sg;
       ca8RY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca8S1; else goto ca8S0;
       ca8S1: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8S0: // global
           I64[Hp - 24] = sat_sa82C_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sa81G::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca8Sg: // global
           I64[Sp] = block_ca8S4_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8SQ; else goto ca8S5;
       ua8SQ: // global
           call _ca8S4(R1) args: 0, res: 0, upd: 0;
       ca8S5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8S4() //  [R1]
         { info_tbl: [(ca8S4,
                       label: block_ca8S4_info
                       rep:StackRep [False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8S4: // global
           I64[Sp - 8] = block_ca8S9_info;
           R2 = P64[Sp + 40];
           _sa82G::P64 = P64[R1 + 7];
           _sa82H::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa82H::P64;
           P64[Sp + 40] = _sa82G::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8S9() //  [R1]
         { info_tbl: [(ca8S9,
                       label: block_ca8S9_info
                       rep:StackRep [False, False, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8S9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8Sk; else goto ca8Sj;
       ca8Sk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Sj: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 56] = block_ca8Sc_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 48];
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Sc() //  [R1]
         { info_tbl: [(ca8Sc,
                       label: block_ca8Sc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Sc: // global
           I64[Sp] = block_ca8Se_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8SS; else goto ca8Sm;
       ua8SS: // global
           call _ca8Se(R1) args: 0, res: 0, upd: 0;
       ca8Sm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Se() //  [R1]
         { info_tbl: [(ca8Se,
                       label: block_ca8Se_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Se: // global
           _sa81G::P64 = P64[Sp + 8];
           _sa82T::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = _sa82T::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.756885206 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharReadBuffer_info;
 },
 GHC.IO.Handle.Internals.flushCharReadBuffer_entry() //  [R2]
         { info_tbl: [(ca8SX,
                       label: GHC.IO.Handle.Internals.flushCharReadBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8SX: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.757586148 UTC

[section ""cstring" . lvl9_ra7Pp_bytes" {
     lvl9_ra7Pp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.75827057 UTC

[section ""data" . lvl10_ra7Pq_closure" {
     lvl10_ra7Pq_closure:
         const lvl10_ra7Pq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ra7Pq_entry() //  [R1]
         { info_tbl: [(ca8T6,
                       label: lvl10_ra7Pq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8T6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8T7; else goto ca8T8;
       ca8T7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8T8: // global
           (_ca8T3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8T3::I64 == 0) goto ca8T5; else goto ca8T4;
       ca8T5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8T4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8T3::I64;
           R2 = lvl9_ra7Pp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.75930836 UTC

[section ""data" . lvl11_ra7Pr_closure" {
     lvl11_ra7Pr_closure:
         const lvl11_ra7Pr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_ra7Pr_entry() //  [R1]
         { info_tbl: [(ca8Tf,
                       label: lvl11_ra7Pr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Tf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8Tg; else goto ca8Th;
       ca8Tg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8Th: // global
           (_ca8Tc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8Tc::I64 == 0) goto ca8Te; else goto ca8Td;
       ca8Te: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8Td: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8Tc::I64;
           R2 = GHC.IO.Handle.Internals.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.760291214 UTC

[section ""data" . lvl12_ra7Ps_closure" {
     lvl12_ra7Ps_closure:
         const lvl12_ra7Ps_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ra7Ps_entry() //  [R1]
         { info_tbl: [(ca8To,
                       label: lvl12_ra7Ps_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8To: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8Tp; else goto ca8Tq;
       ca8Tp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8Tq: // global
           (_ca8Tl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8Tl::I64 == 0) goto ca8Tn; else goto ca8Tm;
       ca8Tn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8Tm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8Tl::I64;
           R2 = GHC.IO.Handle.Internals.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.761190501 UTC

[section ""cstring" . lvl13_ra7Pt_bytes" {
     lvl13_ra7Pt_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.761915862 UTC

[section ""data" . lvl14_ra7Pu_closure" {
     lvl14_ra7Pu_closure:
         const lvl14_ra7Pu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ra7Pu_entry() //  [R1]
         { info_tbl: [(ca8Tx,
                       label: lvl14_ra7Pu_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Tx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8Ty; else goto ca8Tz;
       ca8Ty: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8Tz: // global
           (_ca8Tu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8Tu::I64 == 0) goto ca8Tw; else goto ca8Tv;
       ca8Tw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8Tv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8Tu::I64;
           R2 = lvl13_ra7Pt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.762799067 UTC

[section ""data" . lvl15_ra7Pv_closure" {
     lvl15_ra7Pv_closure:
         const GHC.Types.I#_con_info;
         const 487;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.763414213 UTC

[section ""data" . lvl16_ra7Pw_closure" {
     lvl16_ra7Pw_closure:
         const GHC.Types.I#_con_info;
         const 12;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.76397987 UTC

[section ""data" . lvl17_ra7Px_closure" {
     lvl17_ra7Px_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.764584071 UTC

[section ""data" . lvl18_ra7Py_closure" {
     lvl18_ra7Py_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl11_ra7Pr_closure;
         const lvl12_ra7Ps_closure;
         const lvl14_ra7Pu_closure;
         const lvl15_ra7Pv_closure+1;
         const lvl16_ra7Pw_closure+1;
         const lvl15_ra7Pv_closure+1;
         const lvl17_ra7Px_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.765182781 UTC

[section ""data" . lvl19_ra7Pz_closure" {
     lvl19_ra7Pz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl10_ra7Pq_closure;
         const lvl18_ra7Py_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.765920157 UTC

[section ""cstring" . lvl20_ra7PA_bytes" {
     lvl20_ra7PA_bytes:
         I8[] [105,110,116,101,114,110,97,108,32,73,79,32,108,105,98,114,97,114,121,32,101,114,114,111,114,58,32,67,104,97,114,32,98,117,102,102,101,114,32,110,111,110,45,101,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.76669522 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer2_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer2_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer2_entry() //  [R1]
         { info_tbl: [(ca8TI,
                       label: GHC.IO.Handle.Internals.flushCharBuffer2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8TI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8TJ; else goto ca8TK;
       ca8TJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8TK: // global
           (_ca8TD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8TD::I64 == 0) goto ca8TF; else goto ca8TE;
       ca8TF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8TE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8TD::I64;
           I64[Sp - 24] = block_ca8TG_info;
           R2 = lvl20_ra7PA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca8TG() //  [R1]
         { info_tbl: [(ca8TG,
                       label: block_ca8TG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8TG: // global
           R3 = R1;
           R2 = lvl19_ra7Pz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.768260556 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer1_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer1_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer1_entry() //  [R2]
         { info_tbl: [(ca8TV,
                       label: GHC.IO.Handle.Internals.flushCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8TV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca8TZ; else goto ca8U0;
       ca8TZ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8U0: // global
           I64[Sp - 8] = block_ca8TS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8Uq; else goto ca8TT;
       ua8Uq: // global
           call _ca8TS(R1) args: 0, res: 0, upd: 0;
       ca8TT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8TS() //  [R1]
         { info_tbl: [(ca8TS,
                       label: block_ca8TS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8TS: // global
           _sa83j::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_ca8TY_info;
           _sa830::P64 = R1;
           R1 = _sa83j::P64;
           P64[Sp] = _sa830::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8Up; else goto ca8U2;
       ua8Up: // global
           call _ca8TY(R1) args: 0, res: 0, upd: 0;
       ca8U2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8TY() //  [R1]
         { info_tbl: [(ca8TY,
                       label: block_ca8TY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8TY: // global
           I64[Sp - 16] = block_ca8U6_info;
           _sa83p::I64 = I64[R1 + 39];
           _sa83q::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa83q::I64;
           I64[Sp] = _sa83p::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8Ur; else goto ca8U8;
       ua8Ur: // global
           call _ca8U6(R1) args: 0, res: 0, upd: 0;
       ca8U8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8U6() //  [R1]
         { info_tbl: [(ca8U6,
                       label: block_ca8U6_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8U6: // global
           if (R1 & 7 == 1) goto ca8Ue; else goto ca8Un;
       ca8Ue: // global
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
       ca8Un: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ca8Um; else goto ca8Ul;
       ca8Um: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca8Ul: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.769939129 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer_entry() //  [R2]
         { info_tbl: [(ca8Uw,
                       label: GHC.IO.Handle.Internals.flushCharBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Uw: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.77165414 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer2_closure" {
     GHC.IO.Handle.Internals.flushBuffer2_closure:
         const GHC.IO.Handle.Internals.flushBuffer2_info;
         const 0;
 },
 sat_sa844_entry() //  [R1]
         { info_tbl: [(ca8V4,
                       label: sat_sa844_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8V4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8V5; else goto ca8V6;
       ca8V5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8V6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -(I64[R1 + 24] - I64[R1 + 16]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushBuffer2_entry() //  [R2]
         { info_tbl: [(ca8V9,
                       label: GHC.IO.Handle.Internals.flushBuffer2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8V9: // global
           if ((Sp + -112) < SpLim) (likely: False) goto ca8Va; else goto ca8Vb;
       ca8Va: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8Vb: // global
           I64[Sp - 8] = block_ca8UD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8VC; else goto ca8UE;
       ua8VC: // global
           call _ca8UD(R1) args: 0, res: 0, upd: 0;
       ca8UE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8UD() //  [R1]
         { info_tbl: [(ca8UD,
                       label: block_ca8UD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8UD: // global
           I64[Sp - 24] = block_ca8UI_info;
           _sa83x::P64 = P64[R1 + 7];
           _sa83A::P64 = P64[R1 + 31];
           _sa83C::P64 = P64[R1 + 47];
           R1 = P64[_sa83C::P64 + 8];
           P64[Sp - 16] = _sa83A::P64;
           P64[Sp - 8] = _sa83C::P64;
           P64[Sp] = _sa83x::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8VA; else goto ca8UJ;
       ua8VA: // global
           call _ca8UI(R1) args: 0, res: 0, upd: 0;
       ca8UJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8UI() //  [R1]
         { info_tbl: [(ca8UI,
                       label: block_ca8UI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8UI: // global
           _sa83V::I64 = I64[R1 + 39];
           _sa83W::I64 = I64[R1 + 47];
           if (_sa83V::I64 == _sa83W::I64) goto ca8Vu; else goto ca8Vf;
       ca8Vu: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca8Vf: // global
           I64[Sp - 48] = block_ca8UQ_info;
           R2 = P64[Sp + 24];
           I64[Sp - 64] = stg_ap_pv_info;
           P64[Sp - 56] = P64[Sp + 8];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sa83V::I64;
           I64[Sp - 8] = _sa83W::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ca8UQ() //  [R1]
         { info_tbl: [(ca8UQ,
                       label: block_ca8UQ_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8UQ: // global
           I64[Sp] = block_ca8US_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8VB; else goto ca8UT;
       ua8VB: // global
           call _ca8US(R1) args: 0, res: 0, upd: 0;
       ca8UT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8US() //  [R1]
         { info_tbl: [(ca8US,
                       label: block_ca8US_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8US: // global
           if (R1 & 7 == 1) goto ca8Vk; else goto ca8Vm;
       ca8Vk: // global
           R1 = GHC.IO.Handle.Internals.flushBuffer3_closure;
           Sp = Sp + 80;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca8Vm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca8Vp; else goto ca8Vo;
       ca8Vp: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Vo: // global
           I64[Hp - 24] = sat_sa844_info;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 40];
           I64[Sp] = block_ca8Vl_info;
           R2 = P64[Sp + 72];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 16] = GHC.IO.Device.RelativeSeek_closure+2;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _ca8Vl() //  [R1]
         { info_tbl: [(ca8Vl,
                       label: block_ca8Vl_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Vl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8Vt; else goto ca8Vs;
       ca8Vt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Vs: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sa83C::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sa83C::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa83C::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.774301652 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteReadBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushByteReadBuffer_entry() //  [R2]
         { info_tbl: [(ca8VH,
                       label: GHC.IO.Handle.Internals.flushByteReadBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8VH: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.777911022 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer1_closure" {
     GHC.IO.Handle.Internals.flushBuffer1_closure:
         const GHC.IO.Handle.Internals.flushBuffer1_info;
         const 0;
 },
 sat_sa856_entry() //  [R1]
         { info_tbl: [(ca8Ws,
                       label: sat_sa856_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Ws: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca8Ww; else goto ca8Wx;
       ca8Ww: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8Wx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca8Wp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8WB; else goto ca8Wq;
       ua8WB: // global
           call _ca8Wp(R1) args: 0, res: 0, upd: 0;
       ca8Wq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8Wp() //  [R1]
         { info_tbl: [(ca8Wp,
                       label: block_ca8Wp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Wp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8WA; else goto ca8Wz;
       ca8WA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8Wz: // global
           _sa851::P64 = P64[R1 + 7];
           _sa852::P64 = P64[R1 + 15];
           _sa850::I64 = I64[R1 + 23];
           _sa853::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa851::P64;
           P64[Hp - 32] = _sa852::P64;
           I64[Hp - 24] = _sa850::I64;
           I64[Hp - 16] = _sa853::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa85p_entry() //  [R1]
         { info_tbl: [(ca8WY,
                       label: sat_sa85p_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8WY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca8X5; else goto ca8X6;
       ca8X5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8X6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ca8WV_info;
           _sa85f::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa85f::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua8Xa; else goto ca8WW;
       ua8Xa: // global
           call _ca8WV(R1) args: 0, res: 0, upd: 0;
       ca8WW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca8WV() //  [R1]
         { info_tbl: [(ca8WV,
                       label: block_ca8WV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8WV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8X9; else goto ca8X8;
       ca8X9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca8X8: // global
           _sa85j::P64 = P64[R1 + 7];
           _sa85k::P64 = P64[R1 + 15];
           _sa85i::I64 = I64[R1 + 23];
           _sa85l::I64 = I64[R1 + 31];
           _sa85n::I64 = I64[R1 + 47];
           _sa85o::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa85j::P64;
           P64[Hp - 32] = _sa85k::P64;
           I64[Hp - 24] = _sa85i::I64;
           I64[Hp - 16] = _sa85l::I64;
           I64[Hp - 8] = _sa85o::I64;
           I64[Hp] = _sa85n::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushBuffer1_entry() //  [R2]
         { info_tbl: [(ca8Xb,
                       label: GHC.IO.Handle.Internals.flushBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Xb: // global
           if ((Sp + -80) < SpLim) (likely: False) goto ca8Xc; else goto ca8Xd;
       ca8Xc: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8Xd: // global
           I64[Sp - 8] = block_ca8VO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua8YN; else goto ca8VP;
       ua8YN: // global
           call _ca8VO(R1) args: 0, res: 0, upd: 0;
       ca8VP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8VO() //  [R1]
         { info_tbl: [(ca8VO,
                       label: block_ca8VO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8VO: // global
           I64[Sp - 56] = block_ca8VT_info;
           _sa84c::P64 = R1;
           _sa84e::P64 = P64[R1 + 15];
           _sa84g::P64 = P64[R1 + 31];
           _sa84i::P64 = P64[R1 + 47];
           _sa84k::P64 = P64[R1 + 63];
           _sa84l::P64 = P64[R1 + 71];
           _sa84o::P64 = P64[R1 + 95];
           R1 = P64[_sa84l::P64 + 8];
           P64[Sp - 48] = _sa84e::P64;
           P64[Sp - 40] = _sa84g::P64;
           P64[Sp - 32] = _sa84i::P64;
           P64[Sp - 24] = _sa84k::P64;
           P64[Sp - 16] = _sa84l::P64;
           P64[Sp - 8] = _sa84o::P64;
           P64[Sp] = _sa84c::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ua8YE; else goto ca8VU;
       ua8YE: // global
           call _ca8VT(R1) args: 0, res: 0, upd: 0;
       ca8VU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8VT() //  [R1]
         { info_tbl: [(ca8VT,
                       label: block_ca8VT_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8VT: // global
           I64[Sp] = block_ca8VY_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ua8YF; else goto ca8VZ;
       ua8YF: // global
           call _ca8VY(R1) args: 0, res: 0, upd: 0;
       ca8VZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8VY() //  [R1]
         { info_tbl: [(ca8VY,
                       label: block_ca8VY_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8VY: // global
           if (R1 & 7 == 1) goto ca8Xi; else goto ca8Y9;
       ca8Xi: // global
           _sa84G::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_ca8W3_info;
           R1 = _sa84G::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ua8YG; else goto ca8W4;
       ua8YG: // global
           call _ca8W3(R1) args: 0, res: 0, upd: 0;
       ca8W4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca8Y9: // global
           _sa85M::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_ca8Y7_info;
           R1 = _sa85M::P64;
           if (R1 & 7 != 0) goto ua8YH; else goto ca8Ya;
       ua8YH: // global
           call _ca8Y7(R1) args: 0, res: 0, upd: 0;
       ca8Ya: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8W3() //  [R1]
         { info_tbl: [(ca8W3,
                       label: block_ca8W3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8W3: // global
           I64[Sp - 16] = block_ca8W8_info;
           _sa84M::I64 = I64[R1 + 39];
           _sa84N::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa84N::I64;
           I64[Sp] = _sa84M::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua8YI; else goto ca8W9;
       ua8YI: // global
           call _ca8W8(R1) args: 0, res: 0, upd: 0;
       ca8W9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8W8() //  [R1]
         { info_tbl: [(ca8W8,
                       label: block_ca8W8_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8W8: // global
           _sa84c::P64 = P64[Sp + 56];
           if (R1 & 7 != 1) goto ca8Y4; else goto ca8Y0;
       ca8Y0: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ca8Y4; else goto ca8Xm;
       ca8Y4: // global
           R2 = _sa84c::P64;
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       ca8Xm: // global
           _sa84S::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_ca8Wg_info;
           R1 = _sa84S::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ua8YJ; else goto ca8Wh;
       ua8YJ: // global
           call _ca8Wg(R1) args: 0, res: 0, upd: 0;
       ca8Wh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Wg() //  [R1]
         { info_tbl: [(ca8Wg,
                       label: block_ca8Wg_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Wg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8Xp; else goto ca8Xo;
       ca8Xp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Xo: // global
           _sa84l::P64 = P64[Sp + 24];
           _sa84U::P64 = P64[R1 + 7];
           _sa84V::P64 = P64[R1 + 15];
           _sa84Y::P64 = P64[_sa84l::P64 + 8];
           I64[Hp - 16] = sat_sa856_info;
           P64[Hp] = _sa84Y::P64;
           call MO_WriteBarrier();
           P64[_sa84l::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84l::P64);
           I64[Sp] = block_ca8WF_info;
           R1 = _sa84Y::P64;
           P64[Sp + 16] = _sa84V::P64;
           P64[Sp + 24] = _sa84U::P64;
           if (R1 & 7 != 0) goto ua8YK; else goto ca8WG;
       ua8YK: // global
           call _ca8WF(R1) args: 0, res: 0, upd: 0;
       ca8WG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8WF() //  [R1]
         { info_tbl: [(ca8WF,
                       label: block_ca8WF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8WF: // global
           _sa85f::I64 = I64[R1 + 39];
           if (_sa85f::I64 != 0) goto ca8Xs; else goto ca8XX;
       ca8Xs: // global
           I64[Sp - 24] = block_ca8WM_info;
           _sa85a::P64 = P64[R1 + 7];
           _sa85b::P64 = P64[R1 + 15];
           _sa859::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sa85b::P64;
           I64[Sp - 8] = _sa85f::I64;
           P64[Sp] = _sa85a::P64;
           I64[Sp + 32] = _sa859::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua8YL; else goto ca8WN;
       ua8YL: // global
           call _ca8WM(R1) args: 0, res: 0, upd: 0;
       ca8WN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca8XX: // global
           _sa84c::P64 = P64[Sp + 40];
           _sa84i::P64 = P64[Sp + 8];
           _sa84V::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = _sa84V::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ca8WM() //  [R1]
         { info_tbl: [(ca8WM,
                       label: block_ca8WM_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8WM: // global
           if (R1 & 7 == 1) goto ca8Xu; else goto ca8XM;
       ca8Xu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca8Xx; else goto ca8Xw;
       ca8Xx: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8Xw: // global
           I64[Hp - 24] = sat_sa85p_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sa84c::P64 = P64[Sp + 64];
           _sa84i::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       ca8XM: // global
           I64[Sp] = block_ca8XA_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua8YM; else goto ca8XB;
       ua8YM: // global
           call _ca8XA(R1) args: 0, res: 0, upd: 0;
       ca8XB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8XA() //  [R1]
         { info_tbl: [(ca8XA,
                       label: block_ca8XA_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8XA: // global
           I64[Sp - 8] = block_ca8XF_info;
           R2 = P64[Sp + 48];
           _sa85t::P64 = P64[R1 + 7];
           _sa85u::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa85u::P64;
           P64[Sp + 48] = _sa85t::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8XF() //  [R1]
         { info_tbl: [(ca8XF,
                       label: block_ca8XF_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8XF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca8XQ; else goto ca8XP;
       ca8XQ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8XP: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_ca8XI_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca8XI() //  [R1]
         { info_tbl: [(ca8XI,
                       label: block_ca8XI_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8XI: // global
           I64[Sp] = block_ca8XK_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua8YO; else goto ca8XS;
       ua8YO: // global
           call _ca8XK(R1) args: 0, res: 0, upd: 0;
       ca8XS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8XK() //  [R1]
         { info_tbl: [(ca8XK,
                       label: block_ca8XK_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8XK: // global
           _sa84c::P64 = P64[Sp + 40];
           _sa84i::P64 = P64[Sp + 8];
           _sa85G::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = _sa85G::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ca8Y7() //  [R1]
         { info_tbl: [(ca8Y7,
                       label: block_ca8Y7_info
                       rep:StackRep [False, False, False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Y7: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ca8Yn; else goto ca8Yk;
       ca8Yn: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca8Yk: // global
           _sa84g::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca8Yi_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa84g::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca8Yi() //  [R1]
         { info_tbl: [(ca8Yi,
                       label: block_ca8Yi_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Yi: // global
           _sa84i::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.784107477 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer_closure" {
     GHC.IO.Handle.Internals.flushBuffer_closure:
         const GHC.IO.Handle.Internals.flushBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer_entry() //  [R2]
         { info_tbl: [(ca8YT,
                       label: GHC.IO.Handle.Internals.flushBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8YT: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.784839264 UTC

[section ""cstring" . lvl21_ra7PB_bytes" {
     lvl21_ra7PB_bytes:
         I8[] [71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,56,56,49,58,55,45,51,48,124,74,117,115,116,32,100,101,99,111,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.785592688 UTC

[section ""data" . lvl22_ra7PC_closure" {
     lvl22_ra7PC_closure:
         const lvl22_ra7PC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ra7PC_entry() //  [R1]
         { info_tbl: [(ca8Z2,
                       label: lvl22_ra7PC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Z2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8Z3; else goto ca8Z4;
       ca8Z3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8Z4: // global
           (_ca8YZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca8YZ::I64 == 0) goto ca8Z1; else goto ca8Z0;
       ca8Z1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca8Z0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca8YZ::I64;
           R2 = lvl21_ra7PB_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.791516803 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_2_closure" {
     GHC.IO.Handle.Internals.hLookAhead_2_closure:
         const GHC.IO.Handle.Internals.hLookAhead_2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_2_entry() //  [R2, R3]
         { info_tbl: [(ca8Zc,
                       label: GHC.IO.Handle.Internals.hLookAhead_2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Zc: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ca8Zg; else goto ca8Zh;
       ca8Zg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca8Zh: // global
           I64[Sp - 16] = block_ca8Z9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua91H; else goto ca8Za;
       ua91H: // global
           call _ca8Z9(R1) args: 0, res: 0, upd: 0;
       ca8Za: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Z9() //  [R1]
         { info_tbl: [(ca8Z9,
                       label: block_ca8Z9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Z9: // global
           I64[Sp - 48] = block_ca8Zf_info;
           _sa862::P64 = R1;
           _sa864::P64 = P64[R1 + 15];
           _sa866::P64 = P64[R1 + 31];
           _sa868::P64 = P64[R1 + 47];
           _sa86a::P64 = P64[R1 + 63];
           _sa86e::P64 = P64[R1 + 95];
           R1 = P64[_sa868::P64 + 8];
           P64[Sp - 40] = _sa864::P64;
           P64[Sp - 32] = _sa866::P64;
           P64[Sp - 24] = _sa868::P64;
           P64[Sp - 16] = _sa86a::P64;
           P64[Sp - 8] = _sa86e::P64;
           P64[Sp] = _sa862::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ua91G; else goto ca8Zj;
       ua91G: // global
           call _ca8Zf(R1) args: 0, res: 0, upd: 0;
       ca8Zj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Zf() //  [R1]
         { info_tbl: [(ca8Zf,
                       label: block_ca8Zf_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Zf: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ca91r; else goto ca91g;
       ca91r: // global
           _sa866::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca91j_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa866::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       ca91g: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sa86t() args: 0, res: 0, upd: 0;
     }
 },
 _ca91j() //  [R1]
         { info_tbl: [(ca91j,
                       label: block_ca91j_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca91j: // global
           I64[Sp] = block_ca91l_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua91S; else goto ca91m;
       ua91S: // global
           call _ca91l(R1) args: 0, res: 0, upd: 0;
       ca91m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca91l() //  [R1]
         { info_tbl: [(ca91l,
                       label: block_ca91l_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca91l: // global
           I64[Sp - 8] = block_ca91q_info;
           _sa87O::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa87O::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua91T; else goto ca91u;
       ua91T: // global
           call _ca91q(R1) args: 0, res: 0, upd: 0;
       ca91u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca91q() //  [R1]
         { info_tbl: [(ca91q,
                       label: block_ca91q_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca91q: // global
           if (I64[R1 + 7] == 0) goto ca91C; else goto ca91B;
       ca91C: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca91B: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _sa86t() args: 0, res: 0, upd: 0;
     }
 },
 _sa86t() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa86t: // global
           I64[Sp - 8] = block_ca8Zt_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua91V; else goto ca8Zv;
       ua91V: // global
           call _ca8Zt(R1) args: 0, res: 0, upd: 0;
       ca8Zv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8Zt() //  [R1]
         { info_tbl: [(ca8Zt,
                       label: block_ca8Zt_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8Zt: // global
           if (R1 & 7 == 1) goto ca8ZU; else goto ca90N;
       ca8ZU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca8ZX; else goto ca8ZW;
       ca8ZX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca8ZW: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sa86v::P64 = P64[Sp + 8];
           P64[Hp] = _sa86v::P64;
           _sa860::P64 = P64[Sp + 48];
           _sa86a::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa86a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa86a::P64);
           I64[Sp + 8] = block_ca8ZD_info;
           R3 = _sa860::P64;
           R2 = _sa86v::P64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ca90N: // global
           I64[Sp] = block_ca90l_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua91J; else goto ca90m;
       ua91J: // global
           call _ca90l(R1) args: 0, res: 0, upd: 0;
       ca90m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8ZD() //  [R1]
         { info_tbl: [(ca8ZD,
                       label: block_ca8ZD_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ZD: // global
           I64[Sp] = block_ca8ZF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua91K; else goto ca8ZG;
       ua91K: // global
           call _ca8ZF(R1) args: 0, res: 0, upd: 0;
       ca8ZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8ZF() //  [R1]
         { info_tbl: [(ca8ZF,
                       label: block_ca8ZF_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ZF: // global
           _sa868::P64 = P64[Sp + 8];
           _sa86E::P64 = P64[R1 + 15];
           _sa86F::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sa868::P64 + 8] = _sa86E::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa868::P64);
           I64[Sp + 16] = block_ca8ZN_info;
           R1 = _sa86F::P64;
           P64[Sp + 24] = _sa86E::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ua91L; else goto ca8ZO;
       ua91L: // global
           call _ca8ZN(R1) args: 0, res: 0, upd: 0;
       ca8ZO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8ZN() //  [R1]
         { info_tbl: [(ca8ZN,
                       label: block_ca8ZN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ZN: // global
           I64[Sp - 8] = block_ca8ZS_info;
           _sa86H::P64 = R1;
           _sa86N::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sa86N::I64;
           P64[Sp + 24] = _sa86H::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua91M; else goto ca901;
       ua91M: // global
           call _ca8ZS(R1) args: 0, res: 0, upd: 0;
       ca901: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca8ZS() //  [R1]
         { info_tbl: [(ca8ZS,
                       label: block_ca8ZS_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8ZS: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto ca90d; else goto ca909;
       ca90d: // global
           _sa86E::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca90c_info;
           _sa86O::P64 = R1;
           R1 = _sa86E::P64;
           P64[Sp + 32] = _sa86O::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ua91N; else goto ca90e;
       ua91N: // global
           call _ca90c(R1) args: 0, res: 0, upd: 0;
       ca90e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca909: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca90c() //  [R1]
         { info_tbl: [(ca90c,
                       label: block_ca90c_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca90c: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 _ca90l() //  [R1]
         { info_tbl: [(ca90l,
                       label: block_ca90l_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca90l: // global
           I64[Sp - 8] = block_ca90q_info;
           _sa875::P64 = P64[R1 + 7];
           _sa876::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sa876::P64;
           P64[Sp + 32] = _sa875::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca90q() //  [R1]
         { info_tbl: [(ca90q,
                       label: block_ca90q_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca90q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca90R; else goto ca90Q;
       ca90R: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca90Q: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa86v::P64 = P64[Sp + 16];
           P64[Hp] = _sa86v::P64;
           _sa860::P64 = P64[Sp + 56];
           _sa86a::P64 = P64[Sp + 32];
           _sa875::P64 = P64[Sp + 40];
           _sa876::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa86a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa86a::P64);
           I64[Sp + 16] = block_ca90w_info;
           R5 = _sa860::P64;
           R4 = _sa86v::P64;
           R3 = _sa876::P64;
           R2 = _sa875::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca90w() //  [R1]
         { info_tbl: [(ca90w,
                       label: block_ca90w_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca90w: // global
           I64[Sp] = block_ca90y_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua91O; else goto ca90z;
       ua91O: // global
           call _ca90y(R1) args: 0, res: 0, upd: 0;
       ca90z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca90y() //  [R1]
         { info_tbl: [(ca90y,
                       label: block_ca90y_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca90y: // global
           _sa868::P64 = P64[Sp + 8];
           _sa87j::P64 = P64[R1 + 7];
           _sa87k::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa868::P64 + 8] = _sa87j::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa868::P64);
           I64[Sp + 16] = block_ca90G_info;
           R1 = _sa87k::P64;
           P64[Sp + 24] = _sa87j::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ua91P; else goto ca90H;
       ua91P: // global
           call _ca90G(R1) args: 0, res: 0, upd: 0;
       ca90H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca90G() //  [R1]
         { info_tbl: [(ca90G,
                       label: block_ca90G_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca90G: // global
           I64[Sp - 8] = block_ca90L_info;
           _sa87m::P64 = R1;
           _sa87s::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sa87s::I64;
           P64[Sp + 24] = _sa87m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua91Q; else goto ca90V;
       ua91Q: // global
           call _ca90L(R1) args: 0, res: 0, upd: 0;
       ca90V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca90L() //  [R1]
         { info_tbl: [(ca90L,
                       label: block_ca90L_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca90L: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto ca917; else goto ca913;
       ca917: // global
           _sa87j::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca916_info;
           _sa87t::P64 = R1;
           R1 = _sa87j::P64;
           P64[Sp + 32] = _sa87t::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ua91R; else goto ca918;
       ua91R: // global
           call _ca916(R1) args: 0, res: 0, upd: 0;
       ca918: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca913: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca916() //  [R1]
         { info_tbl: [(ca916,
                       label: block_ca916_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca916: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Internals.$wreadTextDevice'_closure" {
     GHC.IO.Handle.Internals.$wreadTextDevice'_closure:
         const GHC.IO.Handle.Internals.$wreadTextDevice'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca91X: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ua95a_srtd" {
     ua95a_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 7516192769;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(ca924,
                       label: GHC.IO.Handle.Internals.$wreadTextDevice'_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca924: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca92u; else goto ua94N;
       ca92u: // global
           R1 = GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ua94N: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _ca91Y() args: 0, res: 0, upd: 0;
     }
 },
 _ca91Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca91Y: // global
           _sa87T::P64 = P64[Sp];
           I64[Sp] = block_ca921_info;
           R1 = _sa87T::P64;
           if (R1 & 7 != 0) goto ua94R; else goto ca922;
       ua94R: // global
           call _ca921(R1) args: 0, res: 0, upd: 0;
       ca922: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95b_srtd" {
     ua95b_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca921() //  [R1]
         { info_tbl: [(ca921,
                       label: block_ca921_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca921: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca92y; else goto ca92x;
       ca92y: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca92x: // global
           _sa87U::I64 = I64[Sp + 8];
           _sa87V::P64 = P64[Sp + 16];
           _sa87W::P64 = P64[Sp + 24];
           _sa87X::I64 = I64[Sp + 32];
           _sa87Y::I64 = I64[Sp + 40];
           _sa884::P64 = P64[R1 + 15];
           _sa886::P64 = P64[R1 + 31];
           _sa888::P64 = P64[R1 + 47];
           _sa88a::P64 = P64[R1 + 63];
           _sa88e::P64 = P64[R1 + 95];
           _sa88j::I64 = I64[Sp + 48] - _sa87Y::I64;
           (_sa88p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_sa87U::I64, _sa87U::I64 + _sa87Y::I64, _sa88j::I64);
           call MO_Touch(_sa87V::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa87V::P64;
           P64[Hp - 32] = _sa87W::P64;
           I64[Hp - 24] = _sa87U::I64;
           I64[Hp - 16] = _sa87X::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sa88j::I64;
           I64[Sp + 16] = block_ca92m_info;
           R2 = _sa884::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa886::P64;
           P64[Sp + 8] = Hp - 47;
           P64[Sp + 24] = _sa88e::P64;
           P64[Sp + 32] = _sa88a::P64;
           P64[Sp + 40] = _sa888::P64;
           P64[Sp + 48] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95c_srtd" {
     ua95c_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca92m() //  [R1]
         { info_tbl: [(ca92m,
                       label: block_ca92m_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca92m: // global
           I64[Sp] = block_ca92o_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua94T; else goto ca92p;
       ua94T: // global
           call _ca92o(R1) args: 0, res: 0, upd: 0;
       ca92p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95d_srtd" {
     ua95d_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca92o() //  [R1]
         { info_tbl: [(ca92o,
                       label: block_ca92o_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca92o: // global
           I64[Sp - 8] = block_ca92t_info;
           _sa88x::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa88x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua94U; else goto ca92B;
       ua94U: // global
           call _ca92t(R1) args: 0, res: 0, upd: 0;
       ca92B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95e_srtd" {
     ua95e_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca92t() //  [R1]
         { info_tbl: [(ca92t,
                       label: block_ca92t_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca92t: // global
           if (I64[R1 + 7] == 0) goto ca93O; else goto ca92K;
       ca93O: // global
           _sa88x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca93N_info;
           R1 = _sa88x::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua94W; else goto ca93P;
       ua94W: // global
           call _ca93N(R1) args: 0, res: 0, upd: 0;
       ca93P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca92K: // global
           I64[Sp] = block_ca92I_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ua94V; else goto ca92L;
       ua94V: // global
           call _ca92I(R1) args: 0, res: 0, upd: 0;
       ca92L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95f_srtd" {
     ua95f_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca93N() //  [R1]
         { info_tbl: [(ca93N,
                       label: block_ca93N_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca93N: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ca94K; else goto ca93Z;
       ca94K: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca93Z: // global
           _sa88e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca93X_info;
           _sa89i::P64 = R1;
           R1 = _sa88e::P64;
           P64[Sp + 16] = _sa89i::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua954; else goto ca940;
       ua954: // global
           call _ca93X(R1) args: 0, res: 0, upd: 0;
       ca940: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca93X() //  [R1]
         { info_tbl: [(ca93X,
                       label: block_ca93X_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca93X: // global
           if (R1 & 7 == 1) goto ua94Q; else goto ca94v;
       ua94Q: // global
           Sp = Sp + 40;
           call _ca946() args: 0, res: 0, upd: 0;
       ca94v: // global
           I64[Sp] = block_ca949_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua955; else goto ca94a;
       ua955: // global
           call _ca949(R1) args: 0, res: 0, upd: 0;
       ca94a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca949() //  [R1]
         { info_tbl: [(ca949,
                       label: block_ca949_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca949: // global
           _sa89i::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca94e_info;
           R3 = P64[Sp + 32];
           R2 = _sa89i::P64;
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca94e() //  [R1]
         { info_tbl: [(ca94e,
                       label: block_ca94e_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca94e: // global
           I64[Sp] = block_ca94g_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua957; else goto ca94h;
       ua957: // global
           call _ca94g(R1) args: 0, res: 0, upd: 0;
       ca94h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca94g() //  [R1]
         { info_tbl: [(ca94g,
                       label: block_ca94g_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca94g: // global
           _sa888::P64 = P64[Sp + 8];
           _sa89D::P64 = P64[R1 + 7];
           _sa89E::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa888::P64 + 8] = _sa89D::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa888::P64);
           I64[Sp + 8] = block_ca94o_info;
           R1 = _sa89E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua958; else goto ca94p;
       ua958: // global
           call _ca94o(R1) args: 0, res: 0, upd: 0;
       ca94p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca94o() //  [R1]
         { info_tbl: [(ca94o,
                       label: block_ca94o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca94o: // global
           I64[Sp - 8] = block_ca94t_info;
           _sa89G::P64 = R1;
           _sa89M::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           I64[Sp] = _sa89M::I64;
           P64[Sp + 16] = _sa89G::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua959; else goto ca94A;
       ua959: // global
           call _ca94t(R1) args: 0, res: 0, upd: 0;
       ca94A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca94t() //  [R1]
         { info_tbl: [(ca94t,
                       label: block_ca94t_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca94t: // global
           _sa89G::P64 = P64[Sp + 24];
           if (I64[Sp + 8] == I64[R1 + 47]) goto ca94J; else goto ca94I;
       ca94J: // global
           R3 = _sa89G::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       ca94I: // global
           R1 = _sa89G::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ua95g_srtd" {
     ua95g_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca92I() //  [R1]
         { info_tbl: [(ca92I,
                       label: block_ca92I_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca92I: // global
           if (R1 & 7 == 1) goto ua94O; else goto ca93m;
       ua94O: // global
           Sp = Sp + 56;
           call _ca946() args: 0, res: 0, upd: 0;
       ca93m: // global
           I64[Sp] = block_ca92U_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua94X; else goto ca92V;
       ua94X: // global
           call _ca92U(R1) args: 0, res: 0, upd: 0;
       ca92V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca946() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca946: // global
           R1 = lvl22_ra7PC_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ua95h_srtd" {
     ua95h_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca92U() //  [R1]
         { info_tbl: [(ca92U,
                       label: block_ca92U_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca92U: // global
           I64[Sp - 8] = block_ca92Z_info;
           _sa88F::P64 = P64[R1 + 7];
           _sa88G::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sa88G::P64;
           P64[Sp + 16] = _sa88F::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95i_srtd" {
     ua95i_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca92Z() //  [R1]
         { info_tbl: [(ca92Z,
                       label: block_ca92Z_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca92Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca93q; else goto ca93p;
       ca93q: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca93p: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa88x::P64 = P64[Sp + 16];
           P64[Hp] = _sa88x::P64;
           _sa880::P64 = P64[Sp + 56];
           _sa88a::P64 = P64[Sp + 32];
           _sa88F::P64 = P64[Sp + 24];
           _sa88G::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa88a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa88a::P64);
           I64[Sp + 32] = block_ca935_info;
           R5 = _sa880::P64;
           R4 = _sa88x::P64;
           R3 = _sa88G::P64;
           R2 = _sa88F::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95j_srtd" {
     ua95j_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca935() //  [R1]
         { info_tbl: [(ca935,
                       label: block_ca935_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca935: // global
           I64[Sp] = block_ca937_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua94Z; else goto ca938;
       ua94Z: // global
           call _ca937(R1) args: 0, res: 0, upd: 0;
       ca938: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95k_srtd" {
     ua95k_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca937() //  [R1]
         { info_tbl: [(ca937,
                       label: block_ca937_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca937: // global
           _sa880::P64 = P64[Sp + 24];
           _sa888::P64 = P64[Sp + 8];
           _sa88T::P64 = P64[R1 + 7];
           _sa88U::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa888::P64 + 8] = _sa88T::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa888::P64);
           I64[Sp] = block_ca93f_info;
           R1 = _sa880::P64;
           P64[Sp + 8] = _sa88U::P64;
           P64[Sp + 24] = _sa88T::P64;
           if (R1 & 7 != 0) goto ua950; else goto ca93g;
       ua950: // global
           call _ca93f(R1) args: 0, res: 0, upd: 0;
       ca93g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95l_srtd" {
     ua95l_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca93f() //  [R1]
         { info_tbl: [(ca93f,
                       label: block_ca93f_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca93f: // global
           I64[Sp] = block_ca93k_info;
           _sa892::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sa892::I64;
           if (R1 & 7 != 0) goto ua951; else goto ca93u;
       ua951: // global
           call _ca93k(R1) args: 0, res: 0, upd: 0;
       ca93u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua95m_srtd" {
     ua95m_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca93k() //  [R1]
         { info_tbl: [(ca93k,
                       label: block_ca93k_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca93k: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto ca93G; else goto ca93C;
       ca93G: // global
           I64[Sp + 8] = block_ca93F_info;
           _sa893::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sa893::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua952; else goto ca93H;
       ua952: // global
           call _ca93F(R1) args: 0, res: 0, upd: 0;
       ca93H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca93C: // global
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ua95n_srtd" {
     ua95n_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _ca93F() //  [R1]
         { info_tbl: [(ca93F,
                       label: block_ca93F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca93F: // global
           P64[Sp - 40] = P64[Sp + 8];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 8] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 40;
           call _ca91Y() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.803645365 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDevice_closure" {
     GHC.IO.Handle.Internals.readTextDevice_closure:
         const GHC.IO.Handle.Internals.readTextDevice_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDevice_entry() //  [R2, R3]
         { info_tbl: [(ca95s,
                       label: GHC.IO.Handle.Internals.readTextDevice_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca95s: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.805222256 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_1_closure" {
     GHC.IO.Handle.Internals.hLookAhead_1_closure:
         const GHC.IO.Handle.Internals.hLookAhead_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_1_entry() //  [R2]
         { info_tbl: [(ca95C,
                       label: GHC.IO.Handle.Internals.hLookAhead_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca95C: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca95G; else goto ca95H;
       ca95G: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca95H: // global
           I64[Sp - 8] = block_ca95z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua96d; else goto ca95A;
       ua96d: // global
           call _ca95z(R1) args: 0, res: 0, upd: 0;
       ca95A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca95z() //  [R1]
         { info_tbl: [(ca95z,
                       label: block_ca95z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca95z: // global
           I64[Sp - 16] = block_ca95F_info;
           _sa89X::P64 = R1;
           _sa8a6::P64 = P64[R1 + 71];
           R1 = P64[_sa8a6::P64 + 8];
           P64[Sp - 8] = _sa8a6::P64;
           P64[Sp] = _sa89X::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua96c; else goto ca95J;
       ua96c: // global
           call _ca95F(R1) args: 0, res: 0, upd: 0;
       ca95J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca95F() //  [R1]
         { info_tbl: [(ca95F,
                       label: block_ca95F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca95F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca95P; else goto ca95O;
       ca95P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca95O: // global
           _sa8aj::P64 = P64[R1 + 7];
           _sa8ai::I64 = I64[R1 + 23];
           _sa8am::I64 = I64[R1 + 39];
           if (_sa8am::I64 == I64[R1 + 47]) goto ca968; else goto ca95Z;
       ca968: // global
           Hp = Hp - 16;
           I64[Sp - 16] = block_ca961_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = _sa8am::I64;
           P64[Sp] = _sa8aj::P64;
           I64[Sp + 16] = _sa8ai::I64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       ca95Z: // global
           _sa8a6::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8a6::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8a6::P64);
           _sa8as::I64 = %MO_UU_Conv_W32_W64(I32[_sa8ai::I64 + (_sa8am::I64 << 2)]);
           call MO_Touch(_sa8aj::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sa8as::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca961() //  [R1]
         { info_tbl: [(ca961,
                       label: block_ca961_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca961: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca96b; else goto ca96a;
       ca96b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca96a: // global
           _sa8a6::P64 = P64[Sp + 24];
           _sa8ai::I64 = I64[Sp + 32];
           _sa8aj::P64 = P64[Sp + 16];
           _sa8am::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8a6::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8a6::P64);
           _sa8aB::I64 = %MO_UU_Conv_W32_W64(I32[_sa8ai::I64 + (_sa8am::I64 << 2)]);
           call MO_Touch(_sa8aj::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sa8aB::I64;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.807300407 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead__closure" {
     GHC.IO.Handle.Internals.hLookAhead__closure:
         const GHC.IO.Handle.Internals.hLookAhead__info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead__entry() //  [R2]
         { info_tbl: [(ca96i,
                       label: GHC.IO.Handle.Internals.hLookAhead__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca96i: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.808231978 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help2_closure" {
     GHC.IO.Handle.Internals.hClose_help2_closure:
         const GHC.IO.Handle.Internals.hClose_help2_info;
 },
 GHC.IO.Handle.Internals.hClose_help2_entry() //  [R2]
         { info_tbl: [(ca96q,
                       label: GHC.IO.Handle.Internals.hClose_help2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca96q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca96u; else goto ca96t;
       ca96u: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca96t: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.812538688 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help1_closure" {
     GHC.IO.Handle.Internals.hClose_help1_closure:
         const GHC.IO.Handle.Internals.hClose_help1_info;
         const 0;
 },
 sat_sa8bs_entry() //  [R1]
         { info_tbl: [(ca96R,
                       label: sat_sa8bs_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca96R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca96S; else goto ca96T;
       ca96S: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca96T: // global
           I64[Sp - 32] = block_ca96O_info;
           _sa8aL::P64 = P64[R1 + 7];
           _sa8aN::P64 = P64[R1 + 15];
           _sa8aP::P64 = P64[R1 + 23];
           R1 = P64[_sa8aP::P64 + 8];
           P64[Sp - 24] = _sa8aL::P64;
           P64[Sp - 16] = _sa8aN::P64;
           P64[Sp - 8] = _sa8aP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua97v; else goto ca96P;
       ua97v: // global
           call _ca96O(R1) args: 0, res: 0, upd: 0;
       ca96P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca96O() //  [R1]
         { info_tbl: [(ca96O,
                       label: block_ca96O_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca96O: // global
           I64[Sp] = block_ca96W_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ua97u; else goto ca96Y;
       ua97u: // global
           call _ca96W(R1) args: 0, res: 0, upd: 0;
       ca96Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca96W() //  [R1]
         { info_tbl: [(ca96W,
                       label: block_ca96W_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca96W: // global
           if (R1 & 7 == 1) goto ua97s; else goto ca979;
       ua97s: // global
           Sp = Sp + 32;
           call _ca97n() args: 0, res: 0, upd: 0;
       ca979: // global
           _sa8bf::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_ca977_info;
           R1 = _sa8bf::P64;
           if (R1 & 7 != 0) goto ua97w; else goto ca97a;
       ua97w: // global
           call _ca977(R1) args: 0, res: 0, upd: 0;
       ca97a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca977() //  [R1]
         { info_tbl: [(ca977,
                       label: block_ca977_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca977: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ua97t; else goto ca97k;
       ua97t: // global
           Sp = Sp + 32;
           call _ca97n() args: 0, res: 0, upd: 0;
       ca97k: // global
           _sa8aN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca97i_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa8aN::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca97n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca97n: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca97i() //  [R1]
         { info_tbl: [(ca97i,
                       label: block_ca97i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca97i: // global
           _sa8aP::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8aP::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aP::P64);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8bI_entry() //  [R1]
         { info_tbl: [(ca98a,
                       label: sat_sa8bI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca98a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca98b; else goto ca98c;
       ca98b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca98c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ca983_info;
           _sa8by::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8by::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua98j; else goto ca984;
       ua98j: // global
           call _ca983(R1) args: 0, res: 0, upd: 0;
       ca984: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca983() //  [R1]
         { info_tbl: [(ca983,
                       label: block_ca983_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca983: // global
           if (R1 & 7 == 1) goto ca987; else goto ca988;
       ca987: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca988: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8bX_entry() //  [R1]
         { info_tbl: [(ca98E,
                       label: sat_sa8bX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca98E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca98F; else goto ca98G;
       ca98F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca98G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ca98x_info;
           _sa8by::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8by::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua98N; else goto ca98y;
       ua98N: // global
           call _ca98x(R1) args: 0, res: 0, upd: 0;
       ca98y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca98x() //  [R1]
         { info_tbl: [(ca98x,
                       label: block_ca98x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca98x: // global
           if (R1 & 7 == 1) goto ca98B; else goto ca98C;
       ca98B: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ca98C: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8cf_entry() //  [R1]
         { info_tbl: [(ca990,
                       label: sat_sa8cf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca990: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca991; else goto ca992;
       ca991: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca992: // global
           I64[Sp - 8] = block_ca98Y_info;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.IO.Device.close_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ca98Y() //  []
         { info_tbl: [(ca98Y,
                       label: block_ca98Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca98Y: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.hClose_help1_entry() //  [R2]
         { info_tbl: [(ca994,
                       label: GHC.IO.Handle.Internals.hClose_help1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca994: // global
           if ((Sp + -144) < SpLim) (likely: False) goto ca995; else goto ca996;
       ca995: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca996: // global
           I64[Sp - 8] = block_ca96z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9al; else goto ca96A;
       ua9al: // global
           call _ca96z(R1) args: 0, res: 0, upd: 0;
       ca96A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca96z() //  [R1]
         { info_tbl: [(ca96z,
                       label: block_ca96z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca96z: // global
           I64[Sp - 128] = block_ca96E_info;
           _sa8aJ::P64 = R1;
           _sa8aK::P64 = P64[R1 + 7];
           _sa8aL::P64 = P64[R1 + 15];
           _sa8aM::P64 = P64[R1 + 23];
           _sa8aN::P64 = P64[R1 + 31];
           _sa8aP::P64 = P64[R1 + 47];
           _sa8aQ::P64 = P64[R1 + 55];
           _sa8aR::P64 = P64[R1 + 63];
           _sa8aS::P64 = P64[R1 + 71];
           _sa8aT::P64 = P64[R1 + 79];
           _sa8aU::P64 = P64[R1 + 87];
           _sa8aV::P64 = P64[R1 + 95];
           _sa8aW::P64 = P64[R1 + 103];
           _sa8aX::P64 = P64[R1 + 111];
           _sa8aY::P64 = P64[R1 + 119];
           _sa8aZ::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sa8aK::P64;
           P64[Sp - 112] = _sa8aL::P64;
           P64[Sp - 104] = _sa8aM::P64;
           P64[Sp - 96] = _sa8aN::P64;
           P64[Sp - 88] = _sa8aP::P64;
           P64[Sp - 80] = _sa8aQ::P64;
           P64[Sp - 72] = _sa8aR::P64;
           P64[Sp - 64] = _sa8aS::P64;
           P64[Sp - 56] = _sa8aT::P64;
           P64[Sp - 48] = _sa8aU::P64;
           P64[Sp - 40] = _sa8aV::P64;
           P64[Sp - 32] = _sa8aW::P64;
           P64[Sp - 24] = _sa8aX::P64;
           P64[Sp - 16] = _sa8aY::P64;
           P64[Sp - 8] = _sa8aZ::P64;
           P64[Sp] = _sa8aJ::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto ua9ah; else goto ca96F;
       ua9ah: // global
           call _ca96E(R1) args: 0, res: 0, upd: 0;
       ca96F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca96E() //  [R1]
         { info_tbl: [(ca96E,
                       label: block_ca96E_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca96E: // global
           if (R1 & 7 == 1) goto ca9a5; else goto ca999;
       ca9a5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9a8; else goto ca9a7;
       ca9a8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9a7: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca999: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca99c; else goto ca99b;
       ca99c: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca99b: // global
           I64[Hp - 24] = sat_sa8bs_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_ca97z_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca97z() //  [R1]
         { info_tbl: [(ca97z,
                       label: block_ca97z_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca97z: // global
           I64[Sp] = block_ca98O_info;
           _sa8bv::P64 = R1;
           R1 = P64[Sp + 120];
           P64[Sp + 128] = _sa8bv::P64;
           if (R1 & 7 != 0) goto ua9ai; else goto ca98P;
       ua9ai: // global
           call _ca98O(R1) args: 0, res: 0, upd: 0;
       ca98P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca98O() //  [R1]
         { info_tbl: [(ca98O,
                       label: block_ca98O_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca98O: // global
           if (R1 & 7 == 1) goto ca99S; else goto ca9a1;
       ca99S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca99V; else goto ca99U;
       ca99V: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca99U: // global
           I64[Hp - 16] = sat_sa8cf_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_ca99Q_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       ca9a1: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _sa8bw() args: 0, res: 0, upd: 0;
     }
 },
 _ca99Q() //  [R1]
         { info_tbl: [(ca99Q,
                       label: block_ca99Q_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca99Q: // global
           P64[Sp] = R1;
           call _sa8bw() args: 0, res: 0, upd: 0;
     }
 },
 _sa8bw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8bw: // global
           _sa8aP::P64 = P64[Sp + 40];
           _sa8aS::P64 = P64[Sp + 64];
           _sa8aT::P64 = P64[Sp + 72];
           _sa8aV::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sa8aT::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aT::P64);
           call MO_WriteBarrier();
           P64[_sa8aS::P64 + 8] = GHC.IO.Handle.Internals.noCharBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aS::P64);
           call MO_WriteBarrier();
           P64[_sa8aP::P64 + 8] = GHC.IO.Handle.Internals.noByteBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aP::P64);
           I64[Sp - 8] = block_ca99e_info;
           R1 = _sa8aV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9aq; else goto ca99w;
       ua9aq: // global
           call _ca99e(R1) args: 0, res: 0, upd: 0;
       ca99w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca99e() //  [R1]
         { info_tbl: [(ca99e,
                       label: block_ca99e_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca99e: // global
           if (R1 & 7 == 1) goto ua9af; else goto ca99M;
       ua9af: // global
           Sp = Sp + 8;
           call _sa8bC() args: 0, res: 0, upd: 0;
       ca99M: // global
           I64[Sp] = block_ca99F_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua9am; else goto ca99G;
       ua9am: // global
           call _ca99F(R1) args: 0, res: 0, upd: 0;
       ca99G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca99F() //  [R1]
         { info_tbl: [(ca99F,
                       label: block_ca99F_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca99F: // global
           I64[Sp] = block_ca99K_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca99K() //  []
         { info_tbl: [(ca99K,
                       label: block_ca99K_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca99K: // global
           Sp = Sp + 8;
           call _sa8bC() args: 0, res: 0, upd: 0;
     }
 },
 _sa8bC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8bC: // global
           I64[Sp - 8] = block_ca97U_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9ar; else goto ca97V;
       ua9ar: // global
           call _ca97U(R1) args: 0, res: 0, upd: 0;
       ca97V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca97U() //  [R1]
         { info_tbl: [(ca97U,
                       label: block_ca97U_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca97U: // global
           if (R1 & 7 == 1) goto ca99k; else goto ca99r;
       ca99k: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto ca99n; else goto ca99m;
       ca99n: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca99m: // global
           I64[Hp - 184] = sat_sa8bI_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = GHC.Base.Nothing_closure+1;
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca99r: // global
           I64[Sp] = block_ca98m_info;
           _sa8bE::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 88] = _sa8bE::P64;
           if (R1 & 7 != 0) goto ua9aj; else goto ca98n;
       ua9aj: // global
           call _ca98m(R1) args: 0, res: 0, upd: 0;
       ca98n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca98m() //  [R1]
         { info_tbl: [(ca98m,
                       label: block_ca98m_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca98m: // global
           I64[Sp] = block_ca98r_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca98r() //  [R1]
         { info_tbl: [(ca98r,
                       label: block_ca98r_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca98r: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto ca99v; else goto ca99u;
       ca99v: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca99u: // global
           I64[Hp - 184] = sat_sa8bX_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.820501146 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help_closure" {
     GHC.IO.Handle.Internals.hClose_help_closure:
         const GHC.IO.Handle.Internals.hClose_help_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hClose_help_entry() //  [R2]
         { info_tbl: [(ca9aw,
                       label: GHC.IO.Handle.Internals.hClose_help_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9aw: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.821698891 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer1_closure" {
     GHC.IO.Handle.Internals.handleFinalizer1_closure:
         const GHC.IO.Handle.Internals.handleFinalizer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer1_entry() //  [R2, R3]
         { info_tbl: [(ca9aG,
                       label: GHC.IO.Handle.Internals.handleFinalizer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9aG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9aT; else goto ca9aU;
       ca9aT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.handleFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9aU: // global
           I64[Sp - 8] = block_ca9aD_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9b1; else goto ca9aE;
       ua9b1: // global
           call _ca9aD(R1) args: 0, res: 0, upd: 0;
       ca9aE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9aD() //  [R1]
         { info_tbl: [(ca9aD,
                       label: block_ca9aD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9aD: // global
           I64[Sp - 8] = block_ca9aJ_info;
           _sa8cp::P64 = P64[R1 + 7];
           R1 = _sa8cp::P64;
           P64[Sp] = _sa8cp::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9aJ() //  [R1]
         { info_tbl: [(ca9aJ,
                       label: block_ca9aJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9aJ: // global
           I64[Sp] = block_ca9aL_info;
           R2 = R1;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9aL() //  [R1]
         { info_tbl: [(ca9aL,
                       label: block_ca9aL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9aL: // global
           I64[Sp] = block_ca9aN_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9b2; else goto ca9aO;
       ua9b2: // global
           call _ca9aN(R1) args: 0, res: 0, upd: 0;
       ca9aO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9aN() //  [R1]
         { info_tbl: [(ca9aN,
                       label: block_ca9aN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9aN: // global
           _sa8cp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9aS_info;
           R2 = P64[R1 + 7];
           R1 = _sa8cp::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9aS() //  []
         { info_tbl: [(ca9aS,
                       label: block_ca9aS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9aS: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.823377626 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer_closure" {
     GHC.IO.Handle.Internals.handleFinalizer_closure:
         const GHC.IO.Handle.Internals.handleFinalizer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer_entry() //  [R2, R3]
         { info_tbl: [(ca9b7,
                       label: GHC.IO.Handle.Internals.handleFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9b7: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.handleFinalizer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.824144838 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle4_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.825462242 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle1_closure" {
     GHC.IO.Handle.Internals.mkFileHandle1_closure:
         const GHC.IO.Handle.Internals.mkFileHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9bb: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sa8cK_entry() //  [R1]
         { info_tbl: [(ca9bs,
                       label: sat_sa8cK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9bs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9bt; else goto ca9bu;
       ca9bt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9bu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9bj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9bJ; else goto ca9bk;
       ua9bJ: // global
           call _ca9bj(R1) args: 0, res: 0, upd: 0;
       ca9bk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9bj() //  [R1]
         { info_tbl: [(ca9bj,
                       label: block_ca9bj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9bj: // global
           _ca9br::P64 = R1 & 7;
           if (_ca9br::P64 < 3) goto ua9bH; else goto ua9bI;
       ua9bH: // global
           if (_ca9br::P64 < 2) goto ca9bn; else goto ca9bo;
       ca9bn: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ca9bo: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ua9bI: // global
           if (_ca9br::P64 < 4) goto ca9bp; else goto ca9bq;
       ca9bp: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ca9bq: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(ca9bK,
                       label: GHC.IO.Handle.Internals.mkFileHandle1_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9bK: // global
           _sa8cE::P64 = R6;
           _sa8cD::P64 = R5;
           _sa8cC::P64 = R4;
           _sa8cB::P64 = R3;
           _sa8cA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto ca9bL; else goto ca9bM;
       ca9bM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9bO; else goto ca9bN;
       ca9bO: // global
           HpAlloc = 24;
           goto ca9bL;
       ca9bL: // global
           R1 = GHC.IO.Handle.Internals.mkFileHandle1_closure;
           P64[Sp - 40] = _sa8cA::P64;
           P64[Sp - 32] = _sa8cB::P64;
           P64[Sp - 24] = _sa8cC::P64;
           P64[Sp - 16] = _sa8cD::P64;
           P64[Sp - 8] = _sa8cE::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ca9bN: // global
           I64[Hp - 16] = sat_sa8cK_info;
           P64[Hp] = P64[Sp];
           R6 = _sa8cE::P64;
           R5 = _sa8cD::P64;
           R4 = _sa8cC::P64;
           R3 = _sa8cB::P64;
           R2 = _sa8cA::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = GHC.Types.True_closure+2;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 8] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.827784853 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle_closure" {
     GHC.IO.Handle.Internals.mkFileHandle_closure:
         const GHC.IO.Handle.Internals.mkFileHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9bQ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(ca9bU,
                       label: GHC.IO.Handle.Internals.mkFileHandle_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9bU: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.828845948 UTC

[section ""cstring" . lvl23_ra7PD_bytes" {
     lvl23_ra7PD_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,54,58,51,45,51,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.829629053 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle3_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle3_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle3_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle3_entry() //  []
         { info_tbl: [(ca9c3,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9c3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca9c4; else goto ca9c5;
       ca9c4: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9c5: // global
           I64[Sp - 8] = block_ca9c1_info;
           R2 = lvl23_ra7PD_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9c1() //  [R1]
         { info_tbl: [(ca9c1,
                       label: block_ca9c1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9c1: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.830600849 UTC

[section ""cstring" . lvl24_ra7PE_bytes" {
     lvl24_ra7PE_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,48,58,51,45,51,53]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.831354859 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle2_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle2_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle2_entry() //  []
         { info_tbl: [(ca9cf,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9cf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca9cg; else goto ca9ch;
       ca9cg: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9ch: // global
           I64[Sp - 8] = block_ca9cd_info;
           R2 = lvl24_ra7PE_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9cd() //  [R1]
         { info_tbl: [(ca9cd,
                       label: block_ca9cd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9cd: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.836420276 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle1_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle1_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9cm: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(ca9cz,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle1_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9cz: // global
           if ((Sp + -96) < SpLim) (likely: False) goto ca9cA; else goto ca9cB;
       ca9cA: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ca9cB: // global
           I64[Sp - 48] = block_ca9cq_info;
           _sa8cT::P64 = R6;
           R6 = R6;
           _sa8cS::P64 = R5;
           R5 = R5;
           _sa8cR::P64 = R4;
           R4 = R4;
           _sa8cQ::P64 = R3;
           R3 = R3;
           _sa8cP::P64 = R2;
           R2 = R2;
           P64[Sp - 96] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 88] = GHC.Types.True_closure+2;
           P64[Sp - 80] = P64[Sp];
           P64[Sp - 72] = P64[Sp + 8];
           P64[Sp - 64] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp - 56] = GHC.Base.Nothing_closure+1;
           P64[Sp - 40] = _sa8cP::P64;
           P64[Sp - 32] = _sa8cQ::P64;
           P64[Sp - 24] = _sa8cR::P64;
           P64[Sp - 16] = _sa8cS::P64;
           P64[Sp - 8] = _sa8cT::P64;
           Sp = Sp - 96;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
     }
 },
 _ca9cq() //  [R1]
         { info_tbl: [(ca9cq,
                       label: block_ca9cq_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9cq: // global
           I64[Sp] = block_ca9cs_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9d6; else goto ca9ct;
       ua9d6: // global
           call _ca9cs(R1) args: 0, res: 0, upd: 0;
       ca9ct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9cs() //  [R1]
         { info_tbl: [(ca9cs,
                       label: block_ca9cs_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9cs: // global
           if (R1 & 7 == 1) goto ca9cw; else goto ca9cx;
       ca9cw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca9cM; else goto ca9cL;
       ca9cM: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9cL: // global
           _sa8d2::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = _sa8d2::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           _sa8cS::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_ca9cH_info;
           R6 = P64[Sp + 40];
           R5 = _sa8cS::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp - 16] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 8] = P64[Sp + 56];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = Hp - 6;
           P64[Sp + 56] = _sa8d2::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
       ca9cx: // global
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.mkDuplexHandle2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _ca9cH() //  [R1]
         { info_tbl: [(ca9cH,
                       label: block_ca9cH_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9cH: // global
           I64[Sp] = block_ca9cJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9d7; else goto ca9cO;
       ua9d7: // global
           call _ca9cJ(R1) args: 0, res: 0, upd: 0;
       ca9cO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9cJ() //  [R1]
         { info_tbl: [(ca9cJ,
                       label: block_ca9cJ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9cJ: // global
           if (R1 & 7 == 1) goto ca9cU; else goto ca9d1;
       ca9cU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca9cX; else goto ca9cW;
       ca9cX: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9cW: // global
           _sa8da::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sa8da::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca9d1: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle3_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.839107728 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9d9: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(ca9dd,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9dd: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.840983472 UTC

[section ""data" . $wlvl_ra7PF_closure" {
     $wlvl_ra7PF_closure:
         const $wlvl_ra7PF_info;
         const 0;
 },
 sat_sa8dy_entry() //  [R1]
         { info_tbl: [(ca9dz,
                       label: sat_sa8dy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9dz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca9dA; else goto ca9dB;
       ca9dA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9dB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ca9ds_info;
           _sa8dn::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8dn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua9e2; else goto ca9dt;
       ua9e2: // global
           call _ca9ds(R1) args: 0, res: 0, upd: 0;
       ca9dt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9ds() //  [R1]
         { info_tbl: [(ca9ds,
                       label: block_ca9ds_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ds: // global
           if (R1 & 7 == 1) goto ca9dw; else goto ca9dx;
       ca9dw: // global
           _sa8dn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9dE_info;
           R1 = _sa8dn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua9e1; else goto ca9dG;
       ua9e1: // global
           call _ca9dE(R1) args: 0, res: 0, upd: 0;
       ca9dG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ca9dx: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ca9dE() //  [R1]
         { info_tbl: [(ca9dE,
                       label: block_ca9dE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9dE: // global
           if (R1 & 7 == 1) goto ca9dM; else goto ca9dT;
       ca9dM: // global
           Hp = Hp + 16;
           _sa8dr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ca9dW; else goto ca9dO;
       ca9dO: // global
           _sa8ds::P64 = P64[_sa8dr::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa8ds::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ca9dT: // global
           Hp = Hp + 16;
           _sa8dr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ca9dW; else goto ca9dV;
       ca9dW: // global
           HpAlloc = 16;
           R1 = _sa8dr::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9dV: // global
           _sa8du::P64 = P64[_sa8dr::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa8du::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8dA_entry() //  [R1]
         { info_tbl: [(ca9e5,
                       label: sat_sa8dA_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9e5: // global
           _sa8dA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9e6; else goto ca9e7;
       ca9e7: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ca9e9; else goto ca9e8;
       ca9e9: // global
           HpAlloc = 104;
           goto ca9e6;
       ca9e6: // global
           R1 = _sa8dA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9e8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa8dA::P64;
           _sa8di::P64 = P64[_sa8dA::P64 + 16];
           _sa8dj::P64 = P64[_sa8dA::P64 + 24];
           _sa8dk::P64 = P64[_sa8dA::P64 + 32];
           _sa8dl::P64 = P64[_sa8dA::P64 + 40];
           _sa8dm::P64 = P64[_sa8dA::P64 + 48];
           _sa8dn::P64 = P64[_sa8dA::P64 + 56];
           I64[Hp - 96] = sat_sa8dy_info;
           P64[Hp - 80] = _sa8dl::P64;
           P64[Hp - 72] = _sa8dn::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa8dn::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sa8di::P64;
           P64[Hp - 24] = _sa8dm::P64;
           P64[Hp - 16] = _sa8dj::P64;
           P64[Hp - 8] = _sa8dk::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_ra7PF_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca9ea,
                       label: $wlvl_ra7PF_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ea: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ca9ee; else goto ca9ed;
       ca9ee: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_ra7PF_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ca9ed: // global
           I64[Hp - 56] = sat_sa8dA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 56;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.844335585 UTC

[section ""data" . GHC.IO.Handle.Internals.$wdo_operation_closure" {
     GHC.IO.Handle.Internals.$wdo_operation_closure:
         const GHC.IO.Handle.Internals.$wdo_operation_info;
         const 0;
 },
 sat_sa8e5_entry() //  [R1, R2]
         { info_tbl: [(ca9ex,
                       label: sat_sa8e5_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ex: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ca9eB; else goto ca9eC;
       ca9eB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9eC: // global
           I64[Sp - 48] = block_ca9es_info;
           _sa8dK::P64 = R2;
           R2 = P64[R1 + 38];
           _sa8dB::P64 = P64[R1 + 6];
           _sa8dC::P64 = P64[R1 + 14];
           _sa8dD::P64 = P64[R1 + 22];
           _sa8dE::P64 = P64[R1 + 30];
           R1 = _sa8dE::P64;
           P64[Sp - 40] = _sa8dB::P64;
           P64[Sp - 32] = _sa8dC::P64;
           P64[Sp - 24] = _sa8dD::P64;
           P64[Sp - 16] = _sa8dE::P64;
           P64[Sp - 8] = _sa8dK::P64;
           Sp = Sp - 48;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9es() //  []
         { info_tbl: [(ca9es,
                       label: block_ca9es_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9es: // global
           I64[Sp] = block_ca9eu_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto ua9fk; else goto ca9ev;
       ua9fk: // global
           call _ca9eu(R1) args: 0, res: 0, upd: 0;
       ca9ev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9eu() //  [R1]
         { info_tbl: [(ca9eu,
                       label: block_ca9eu_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9eu: // global
           I64[Sp - 16] = block_ca9eA_info;
           _sa8dO::P64 = P64[R1 + 7];
           R2 = _sa8dO::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sa8dO::P64;
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9eA() //  [R1]
         { info_tbl: [(ca9eA,
                       label: block_ca9eA_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9eA: // global
           I64[Sp] = block_ca9eI_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9eI() //  [R1]
         { info_tbl: [(ca9eI,
                       label: block_ca9eI_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9eI: // global
           if (R1 & 7 == 1) goto ca9eQ; else goto ca9fd;
       ca9eQ: // global
           _sa8dO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca9eN_info;
           R2 = _sa8dO::P64;
           Sp = Sp + 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       ca9fd: // global
           I64[Sp + 16] = block_ca9fb_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9eN() //  [R1]
         { info_tbl: [(ca9eN,
                       label: block_ca9eN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9eN: // global
           I64[Sp] = block_ca9eU_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9eU() //  [R1]
         { info_tbl: [(ca9eU,
                       label: block_ca9eU_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9eU: // global
           _sa8dN::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto ca9f1; else goto ca9f6;
       ca9f1: // global
           R1 = _sa8dN::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca9f6: // global
           I64[Sp] = block_ca9f4_info;
           R2 = _sa8dN::P64;
           R1 = CurrentTSO;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9f4() //  []
         { info_tbl: [(ca9f4,
                       label: block_ca9f4_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9f4: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _ca9fb() //  [R1]
         { info_tbl: [(ca9fb,
                       label: block_ca9fb_info
                       rep:StackRep [False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9fb: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 47];
           R4 = P64[R1 + 39];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 15];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 40;
           call $wlvl_ra7PF_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wdo_operation_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9fl,
                       label: GHC.IO.Handle.Internals.$wdo_operation_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9fl: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca9fm; else goto ca9fn;
       ca9fm: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wdo_operation_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9fn: // global
           I64[Sp - 40] = block_ca9ej_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ej() //  [R1]
         { info_tbl: [(ca9ej,
                       label: block_ca9ej_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ej: // global
           I64[Sp - 8] = block_ca9el_info;
           R2 = R1;
           _sa8dI::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _sa8dI::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9el() //  [R1]
         { info_tbl: [(ca9el,
                       label: block_ca9el_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9el: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca9fr; else goto ca9fq;
       ca9fr: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9fq: // global
           I64[Hp - 40] = sat_sa8e5_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 38;
           R1 = R1;
           Sp = Sp + 48;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.847949242 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_1_closure" {
     GHC.IO.Handle.Internals.withHandle_1_closure:
         const GHC.IO.Handle.Internals.withHandle_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9fz,
                       label: GHC.IO.Handle.Internals.withHandle_1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9fz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca9fA; else goto ca9fB;
       ca9fA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9fB: // global
           I64[Sp - 32] = block_ca9fw_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua9fF; else goto ca9fx;
       ua9fF: // global
           call _ca9fw(R1) args: 0, res: 0, upd: 0;
       ca9fx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9fw() //  [R1]
         { info_tbl: [(ca9fw,
                       label: block_ca9fw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9fw: // global
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.849645564 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle__'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle__'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle__'_info;
         const 0;
 },
 sat_sa8ev_entry() //  [R1]
         { info_tbl: [(ca9fY,
                       label: sat_sa8ev_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9fY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9fZ; else goto ca9g0;
       ca9fZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9g0: // global
           I64[Sp - 16] = block_ca9fU_info;
           _sa8ef::P64 = P64[R1 + 23];
           R5 = _sa8ef::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8ef::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9fU() //  [R1]
         { info_tbl: [(ca9fU,
                       label: block_ca9fU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9fU: // global
           _sa8ef::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9fW_info;
           R2 = R1;
           R1 = _sa8ef::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9fW() //  []
         { info_tbl: [(ca9fW,
                       label: block_ca9fW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9fW: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwithHandle__'_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(ca9g6,
                       label: GHC.IO.Handle.Internals.$wwithHandle__'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9g6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca9g7; else goto ca9g8;
       ca9g7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle__'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9g8: // global
           I64[Sp - 40] = block_ca9fK_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9fK() //  [R1]
         { info_tbl: [(ca9fK,
                       label: block_ca9fK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9fK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9gb; else goto ca9ga;
       ca9gb: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9ga: // global
           _sa8ed::P64 = P64[Sp + 8];
           _sa8ee::P64 = P64[Sp + 16];
           _sa8ef::P64 = P64[Sp + 24];
           _sa8eg::P64 = P64[Sp + 32];
           if (R1 == 0) goto ca9g5; else goto ca9g4;
       ca9g5: // global
           I64[Hp - 32] = sat_sa8ev_info;
           P64[Hp - 24] = _sa8ed::P64;
           P64[Hp - 16] = _sa8ee::P64;
           P64[Hp - 8] = _sa8ef::P64;
           P64[Hp] = _sa8eg::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9g4: // global
           Hp = Hp - 40;
           I64[Sp + 16] = block_ca9gc_info;
           R5 = _sa8ef::P64;
           R4 = _sa8eg::P64;
           R3 = _sa8ee::P64;
           R2 = _sa8ed::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9gc() //  [R1]
         { info_tbl: [(ca9gc,
                       label: block_ca9gc_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9gc: // global
           I64[Sp + 16] = block_ca9ge_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ge() //  []
         { info_tbl: [(ca9ge,
                       label: block_ca9ge_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ge: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.851904034 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'1_closure" {
     GHC.IO.Handle.Internals.withHandle__'1_closure:
         const GHC.IO.Handle.Internals.withHandle__'1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9gp,
                       label: GHC.IO.Handle.Internals.withHandle__'1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9gp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca9gq; else goto ca9gr;
       ca9gq: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle__'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9gr: // global
           I64[Sp - 32] = block_ca9gm_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua9gv; else goto ca9gn;
       ua9gv: // global
           call _ca9gm(R1) args: 0, res: 0, upd: 0;
       ca9gn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9gm() //  [R1]
         { info_tbl: [(ca9gm,
                       label: block_ca9gm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9gm: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.853086379 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'_closure" {
     GHC.IO.Handle.Internals.withHandle__'_closure:
         const GHC.IO.Handle.Internals.withHandle__'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9gA,
                       label: GHC.IO.Handle.Internals.withHandle__'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9gA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle__'1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.855576434 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles__1_closure" {
     GHC.IO.Handle.Internals.withAllHandles__1_closure:
         const GHC.IO.Handle.Internals.withAllHandles__1_info;
         const 0;
 },
 sat_sa8eX_entry() //  [R1]
         { info_tbl: [(ca9h0,
                       label: sat_sa8eX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9h0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9h1; else goto ca9h2;
       ca9h1: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9h2: // global
           I64[Sp - 16] = block_ca9gW_info;
           _sa8eJ::P64 = P64[R1 + 31];
           R5 = _sa8eJ::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8eJ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9gW() //  [R1]
         { info_tbl: [(ca9gW,
                       label: block_ca9gW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9gW: // global
           _sa8eJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9gY_info;
           R2 = R1;
           R1 = _sa8eJ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9gY() //  []
         { info_tbl: [(ca9gY,
                       label: block_ca9gY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9gY: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8fj_entry() //  [R1]
         { info_tbl: [(ca9hs,
                       label: sat_sa8fj_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9hs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9ht; else goto ca9hu;
       ca9ht: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9hu: // global
           I64[Sp - 16] = block_ca9ho_info;
           _sa8f0::P64 = P64[R1 + 31];
           R5 = _sa8f0::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8f0::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ho() //  [R1]
         { info_tbl: [(ca9ho,
                       label: block_ca9ho_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ho: // global
           _sa8f0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9hq_info;
           R2 = R1;
           R1 = _sa8f0::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9hq() //  []
         { info_tbl: [(ca9hq,
                       label: block_ca9hq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9hq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8fu_entry() //  [R1]
         { info_tbl: [(ca9hJ,
                       label: sat_sa8fu_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9hJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9hK; else goto ca9hL;
       ca9hK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9hL: // global
           I64[Sp - 16] = block_ca9hF_info;
           _sa8eZ::P64 = P64[R1 + 31];
           R5 = _sa8eZ::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8eZ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9hF() //  [R1]
         { info_tbl: [(ca9hF,
                       label: block_ca9hF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9hF: // global
           _sa8eZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9hH_info;
           R2 = R1;
           R1 = _sa8eZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9hH() //  []
         { info_tbl: [(ca9hH,
                       label: block_ca9hH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9hH: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.withAllHandles__1_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9hS,
                       label: GHC.IO.Handle.Internals.withAllHandles__1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9hS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca9hT; else goto ca9hU;
       ca9hT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withAllHandles__1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9hU: // global
           I64[Sp - 24] = block_ca9gH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9iB; else goto ca9gI;
       ua9iB: // global
           call _ca9gH(R1) args: 0, res: 0, upd: 0;
       ca9gI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9gH() //  [R1]
         { info_tbl: [(ca9gH,
                       label: block_ca9gH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9gH: // global
           if (R1 & 7 == 1) goto ca9hP; else goto ca9hQ;
       ca9hP: // global
           I64[Sp - 16] = block_ca9gM_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       ca9hQ: // global
           I64[Sp - 24] = block_ca9h7_info;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9gM() //  [R1]
         { info_tbl: [(ca9gM,
                       label: block_ca9gM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9gM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9hY; else goto ca9hX;
       ca9hY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9hX: // global
           _sa8eD::P64 = P64[Sp + 24];
           _sa8eF::P64 = P64[Sp + 32];
           _sa8eH::P64 = P64[Sp + 16];
           _sa8eJ::P64 = P64[Sp + 8];
           if (R1 == 0) goto ca9i7; else goto ca9i3;
       ca9i7: // global
           I64[Hp - 32] = sat_sa8eX_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8eJ::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9i3: // global
           Hp = Hp - 40;
           I64[Sp] = block_ca9hZ_info;
           R5 = _sa8eJ::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9hZ() //  [R1]
         { info_tbl: [(ca9hZ,
                       label: block_ca9hZ_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9hZ: // global
           I64[Sp + 32] = block_ca9ii_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9h7() //  [R1]
         { info_tbl: [(ca9h7,
                       label: block_ca9h7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9h7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9ib; else goto ca9ia;
       ca9ib: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9ia: // global
           _sa8eD::P64 = P64[Sp + 32];
           _sa8eF::P64 = P64[Sp + 40];
           _sa8eH::P64 = P64[Sp + 24];
           _sa8eZ::P64 = P64[Sp + 8];
           if (R1 == 0) goto ca9iy; else goto ca9it;
       ca9iy: // global
           I64[Hp - 32] = sat_sa8fu_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8eZ::P64;
           I64[Sp + 8] = block_ca9ix_info;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       ca9it: // global
           Hp = Hp - 40;
           I64[Sp] = block_ca9ip_info;
           R5 = _sa8eZ::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ix() //  []
         { info_tbl: [(ca9ix,
                       label: block_ca9ix_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ix: // global
           call _sa8f4() args: 0, res: 0, upd: 0;
     }
 },
 _ca9ip() //  [R1]
         { info_tbl: [(ca9ip,
                       label: block_ca9ip_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ip: // global
           _sa8eZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_sa8f4_info;
           R2 = R1;
           R1 = _sa8eZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _sa8f4() //  []
         { info_tbl: [(sa8f4,
                       label: block_sa8f4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8f4: // global
           I64[Sp] = block_ca9he_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9he() //  [R1]
         { info_tbl: [(ca9he,
                       label: block_ca9he_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9he: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9if; else goto ca9ie;
       ca9if: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9ie: // global
           _sa8eD::P64 = P64[Sp + 24];
           _sa8eF::P64 = P64[Sp + 32];
           _sa8eH::P64 = P64[Sp + 16];
           _sa8f0::P64 = P64[Sp + 8];
           if (R1 == 0) goto ca9io; else goto ca9ik;
       ca9io: // global
           I64[Hp - 32] = sat_sa8fj_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8f0::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9ik: // global
           Hp = Hp - 40;
           I64[Sp] = block_ca9ig_info;
           R5 = _sa8f0::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ig() //  [R1]
         { info_tbl: [(ca9ig,
                       label: block_ca9ig_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ig: // global
           I64[Sp + 32] = block_ca9ii_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ii() //  []
         { info_tbl: [(ca9ii,
                       label: block_ca9ii_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ii: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.860391634 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles___closure" {
     GHC.IO.Handle.Internals.withAllHandles___closure:
         const GHC.IO.Handle.Internals.withAllHandles___info;
         const 0;
 },
 GHC.IO.Handle.Internals.withAllHandles___entry() //  [R2, R3, R4]
         { info_tbl: [(ca9iH,
                       label: GHC.IO.Handle.Internals.withAllHandles___info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9iH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.861757181 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle'_info;
         const 0;
 },
 io_sa8fG_entry() //  [R1]
         { info_tbl: [(ca9j0,
                       label: io_sa8fG_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9j0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9j4; else goto ca9j5;
       ca9j4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9j5: // global
           I64[Sp - 16] = block_ca9iV_info;
           _sa8fA::P64 = P64[R1 + 23];
           R5 = _sa8fA::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8fA::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9iV() //  [R1]
         { info_tbl: [(ca9iV,
                       label: block_ca9iV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9iV: // global
           I64[Sp] = block_ca9iX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9ja; else goto ca9iY;
       ua9ja: // global
           call _ca9iX(R1) args: 0, res: 0, upd: 0;
       ca9iY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9iX() //  [R1]
         { info_tbl: [(ca9iX,
                       label: block_ca9iX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9iX: // global
           I64[Sp] = block_ca9j3_info;
           R2 = P64[R1 + 7];
           _sa8fN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8fN::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9j3() //  []
         { info_tbl: [(ca9j3,
                       label: block_ca9j3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9j3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwithHandle'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9jf,
                       label: GHC.IO.Handle.Internals.$wwithHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9jf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca9jg; else goto ca9jh;
       ca9jg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9jh: // global
           I64[Sp - 40] = block_ca9iO_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9iO() //  [R1]
         { info_tbl: [(ca9iO,
                       label: block_ca9iO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9iO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9jk; else goto ca9jj;
       ca9jk: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9jj: // global
           I64[Hp - 32] = io_sa8fG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           _ca9iQ::P64 = Hp - 31;
           if (R1 == 0) goto ca9je; else goto ca9jd;
       ca9je: // global
           R1 = _ca9iQ::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9jd: // global
           R1 = _ca9iQ::P64;
           Sp = Sp + 40;
           call io_sa8fG_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.863856959 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle1_closure" {
     GHC.IO.Handle.Internals.withHandle1_closure:
         const GHC.IO.Handle.Internals.withHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9js,
                       label: GHC.IO.Handle.Internals.withHandle1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9js: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca9jt; else goto ca9ju;
       ca9jt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9ju: // global
           I64[Sp - 32] = block_ca9jp_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua9jy; else goto ca9jq;
       ua9jy: // global
           call _ca9jp(R1) args: 0, res: 0, upd: 0;
       ca9jq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9jp() //  [R1]
         { info_tbl: [(ca9jp,
                       label: block_ca9jp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9jp: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.865094459 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle'_closure" {
     GHC.IO.Handle.Internals.withHandle'_closure:
         const GHC.IO.Handle.Internals.withHandle'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9jD,
                       label: GHC.IO.Handle.Internals.withHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9jD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.866429949 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'1_closure" {
     GHC.IO.Handle.Internals.withHandle_'1_closure:
         const GHC.IO.Handle.Internals.withHandle_'1_info;
         const 0;
 },
 sat_sa8ga_entry() //  [R1, R2]
         { info_tbl: [(ca9jX,
                       label: sat_sa8ga_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9jX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9jY; else goto ca9jZ;
       ca9jY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9jZ: // global
           I64[Sp - 16] = block_ca9jU_info;
           _sa8g4::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8g4::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9jU() //  [R1]
         { info_tbl: [(ca9jU,
                       label: block_ca9jU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9jU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9k2; else goto ca9k1;
       ca9k2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9k1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.withHandle_'1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9k3,
                       label: GHC.IO.Handle.Internals.withHandle_'1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9k3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca9k4; else goto ca9k5;
       ca9k4: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9k5: // global
           I64[Sp - 32] = block_ca9jK_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua9k9; else goto ca9jL;
       ua9k9: // global
           call _ca9jK(R1) args: 0, res: 0, upd: 0;
       ca9jL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9jK() //  [R1]
         { info_tbl: [(ca9jK,
                       label: block_ca9jK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9jK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9k8; else goto ca9k7;
       ca9k8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9k7: // global
           _sa8g3::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sa8ga_info;
           P64[Hp] = P64[Sp + 24];
           R5 = Hp - 6;
           R4 = _sa8g3::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.868229922 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'_closure" {
     GHC.IO.Handle.Internals.withHandle_'_closure:
         const GHC.IO.Handle.Internals.withHandle_'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9ke,
                       label: GHC.IO.Handle.Internals.withHandle_'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ke: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle_'1_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.870921116 UTC

[section ""data" . withHandle_2_ra7PG_closure" {
     withHandle_2_ra7PG_closure:
         const withHandle_2_ra7PG_info;
         const 0;
 },
 sat_sa8gt_entry() //  [R1, R2]
         { info_tbl: [(ca9kF,
                       label: sat_sa8gt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9kF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9kG; else goto ca9kH;
       ca9kG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9kH: // global
           I64[Sp - 16] = block_ca9kC_info;
           _sa8gn::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8gn::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9kC() //  [R1]
         { info_tbl: [(ca9kC,
                       label: block_ca9kC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9kC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9kK; else goto ca9kJ;
       ca9kK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9kJ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8gl_entry() //  [R1]
         { info_tbl: [(ca9kQ,
                       label: io_sa8gl_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9kQ: // global
           _sa8gl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9kU; else goto ca9kV;
       ca9kV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9kX; else goto ca9kW;
       ca9kX: // global
           HpAlloc = 16;
           goto ca9kU;
       ca9kU: // global
           R1 = _sa8gl::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9kW: // global
           _sa8gb::P64 = P64[_sa8gl::P64 + 7];
           _sa8gd::P64 = P64[_sa8gl::P64 + 15];
           _sa8gf::P64 = P64[_sa8gl::P64 + 23];
           _sa8gh::P64 = P64[_sa8gl::P64 + 31];
           I64[Hp - 8] = sat_sa8gt_info;
           P64[Hp] = _sa8gd::P64;
           I64[Sp - 16] = block_ca9kL_info;
           R5 = _sa8gh::P64;
           R4 = Hp - 6;
           R3 = _sa8gf::P64;
           R2 = _sa8gb::P64;
           P64[Sp - 8] = _sa8gh::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9kL() //  [R1]
         { info_tbl: [(ca9kL,
                       label: block_ca9kL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9kL: // global
           I64[Sp] = block_ca9kN_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9l2; else goto ca9kO;
       ua9l2: // global
           call _ca9kN(R1) args: 0, res: 0, upd: 0;
       ca9kO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9kN() //  [R1]
         { info_tbl: [(ca9kN,
                       label: block_ca9kN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9kN: // global
           I64[Sp] = block_ca9kT_info;
           R2 = P64[R1 + 7];
           _sa8gz::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8gz::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9kT() //  []
         { info_tbl: [(ca9kT,
                       label: block_ca9kT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9kT: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8gQ_entry() //  [R1, R2]
         { info_tbl: [(ca9lk,
                       label: sat_sa8gQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9lk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9ll; else goto ca9lm;
       ca9ll: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9lm: // global
           I64[Sp - 16] = block_ca9lh_info;
           _sa8gK::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8gK::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9lh() //  [R1]
         { info_tbl: [(ca9lh,
                       label: block_ca9lh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9lh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9lp; else goto ca9lo;
       ca9lp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9lo: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8gI_entry() //  [R1]
         { info_tbl: [(ca9lv,
                       label: io_sa8gI_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9lv: // global
           _sa8gI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9lz; else goto ca9lA;
       ca9lA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9lC; else goto ca9lB;
       ca9lC: // global
           HpAlloc = 16;
           goto ca9lz;
       ca9lz: // global
           R1 = _sa8gI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9lB: // global
           _sa8gb::P64 = P64[_sa8gI::P64 + 7];
           _sa8gd::P64 = P64[_sa8gI::P64 + 15];
           _sa8gf::P64 = P64[_sa8gI::P64 + 23];
           _sa8gD::P64 = P64[_sa8gI::P64 + 31];
           I64[Hp - 8] = sat_sa8gQ_info;
           P64[Hp] = _sa8gd::P64;
           I64[Sp - 16] = block_ca9lq_info;
           R5 = _sa8gD::P64;
           R4 = Hp - 6;
           R3 = _sa8gf::P64;
           R2 = _sa8gb::P64;
           P64[Sp - 8] = _sa8gD::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9lq() //  [R1]
         { info_tbl: [(ca9lq,
                       label: block_ca9lq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9lq: // global
           I64[Sp] = block_ca9ls_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9lH; else goto ca9lt;
       ua9lH: // global
           call _ca9ls(R1) args: 0, res: 0, upd: 0;
       ca9lt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ls() //  [R1]
         { info_tbl: [(ca9ls,
                       label: block_ca9ls_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ls: // global
           I64[Sp] = block_ca9ly_info;
           R2 = P64[R1 + 7];
           _sa8gW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8gW::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ly() //  []
         { info_tbl: [(ca9ly,
                       label: block_ca9ly_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ly: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 withHandle_2_ra7PG_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9lM,
                       label: withHandle_2_ra7PG_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9lM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca9lN; else goto ca9lO;
       ca9lN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle_2_ra7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9lO: // global
           I64[Sp - 24] = block_ca9kl_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9m5; else goto ca9km;
       ua9m5: // global
           call _ca9kl(R1) args: 0, res: 0, upd: 0;
       ca9km: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9kl() //  [R1]
         { info_tbl: [(ca9kl,
                       label: block_ca9kl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9kl: // global
           if (R1 & 7 == 1) goto ca9lJ; else goto ca9lK;
       ca9lJ: // global
           I64[Sp - 16] = block_ca9kq_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       ca9lK: // global
           I64[Sp - 16] = block_ca9l5_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9kq() //  [R1]
         { info_tbl: [(ca9kq,
                       label: block_ca9kq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9kq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9lS; else goto ca9lR;
       ca9lS: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9lR: // global
           I64[Hp - 32] = io_sa8gl_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _ca9ks::P64 = Hp - 31;
           if (R1 == 0) goto ca9lW; else goto ca9lV;
       ca9lW: // global
           R1 = _ca9ks::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9lV: // global
           R1 = _ca9ks::P64;
           Sp = Sp + 40;
           call io_sa8gl_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9l5() //  [R1]
         { info_tbl: [(ca9l5,
                       label: block_ca9l5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9l5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9m0; else goto ca9lZ;
       ca9m0: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9lZ: // global
           I64[Hp - 32] = io_sa8gI_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _ca9l7::P64 = Hp - 31;
           if (R1 == 0) goto ca9m4; else goto ca9m3;
       ca9m4: // global
           R1 = _ca9l7::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9m3: // global
           R1 = _ca9l7::P64;
           Sp = Sp + 40;
           call io_sa8gI_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.875285007 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__closure" {
     GHC.IO.Handle.Internals.withHandle__closure:
         const GHC.IO.Handle.Internals.withHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__entry() //  [R2, R3, R4]
         { info_tbl: [(ca9ma,
                       label: GHC.IO.Handle.Internals.withHandle__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ma: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle_2_ra7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.877769203 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_1_info;
         const 0;
 },
 sat_sa8hh_entry() //  [R1, R2]
         { info_tbl: [(ca9mB,
                       label: sat_sa8hh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9mB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9mC; else goto ca9mD;
       ca9mC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9mD: // global
           I64[Sp - 16] = block_ca9my_info;
           R3 = R2;
           _sa8hb::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sa8hb::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9my() //  [R1]
         { info_tbl: [(ca9my,
                       label: block_ca9my_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9my: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9mG; else goto ca9mF;
       ca9mG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9mF: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8h9_entry() //  [R1]
         { info_tbl: [(ca9mM,
                       label: io_sa8h9_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9mM: // global
           _sa8h9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9mQ; else goto ca9mR;
       ca9mR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9mT; else goto ca9mS;
       ca9mT: // global
           HpAlloc = 16;
           goto ca9mQ;
       ca9mQ: // global
           R1 = _sa8h9::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9mS: // global
           _sa8gZ::P64 = P64[_sa8h9::P64 + 7];
           _sa8h1::P64 = P64[_sa8h9::P64 + 15];
           _sa8h3::P64 = P64[_sa8h9::P64 + 23];
           _sa8h5::P64 = P64[_sa8h9::P64 + 31];
           I64[Hp - 8] = sat_sa8hh_info;
           P64[Hp] = _sa8h1::P64;
           I64[Sp - 16] = block_ca9mH_info;
           R5 = _sa8h5::P64;
           R4 = Hp - 6;
           R3 = _sa8h3::P64;
           R2 = _sa8gZ::P64;
           P64[Sp - 8] = _sa8h5::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9mH() //  [R1]
         { info_tbl: [(ca9mH,
                       label: block_ca9mH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9mH: // global
           I64[Sp] = block_ca9mJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9mY; else goto ca9mK;
       ua9mY: // global
           call _ca9mJ(R1) args: 0, res: 0, upd: 0;
       ca9mK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9mJ() //  [R1]
         { info_tbl: [(ca9mJ,
                       label: block_ca9mJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9mJ: // global
           I64[Sp] = block_ca9mP_info;
           R2 = P64[R1 + 7];
           _sa8hn::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8hn::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9mP() //  []
         { info_tbl: [(ca9mP,
                       label: block_ca9mP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9mP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8hE_entry() //  [R1, R2]
         { info_tbl: [(ca9ng,
                       label: sat_sa8hE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ng: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9nh; else goto ca9ni;
       ca9nh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9ni: // global
           I64[Sp - 16] = block_ca9nd_info;
           R3 = R2;
           _sa8hy::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sa8hy::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9nd() //  [R1]
         { info_tbl: [(ca9nd,
                       label: block_ca9nd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9nd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9nl; else goto ca9nk;
       ca9nl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9nk: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8hw_entry() //  [R1]
         { info_tbl: [(ca9nr,
                       label: io_sa8hw_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9nr: // global
           _sa8hw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9nv; else goto ca9nw;
       ca9nw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9ny; else goto ca9nx;
       ca9ny: // global
           HpAlloc = 16;
           goto ca9nv;
       ca9nv: // global
           R1 = _sa8hw::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9nx: // global
           _sa8gZ::P64 = P64[_sa8hw::P64 + 7];
           _sa8h1::P64 = P64[_sa8hw::P64 + 15];
           _sa8h3::P64 = P64[_sa8hw::P64 + 23];
           _sa8hr::P64 = P64[_sa8hw::P64 + 31];
           I64[Hp - 8] = sat_sa8hE_info;
           P64[Hp] = _sa8h1::P64;
           I64[Sp - 16] = block_ca9nm_info;
           R5 = _sa8hr::P64;
           R4 = Hp - 6;
           R3 = _sa8h3::P64;
           R2 = _sa8gZ::P64;
           P64[Sp - 8] = _sa8hr::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9nm() //  [R1]
         { info_tbl: [(ca9nm,
                       label: block_ca9nm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9nm: // global
           I64[Sp] = block_ca9no_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9nD; else goto ca9np;
       ua9nD: // global
           call _ca9no(R1) args: 0, res: 0, upd: 0;
       ca9np: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9no() //  [R1]
         { info_tbl: [(ca9no,
                       label: block_ca9no_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9no: // global
           I64[Sp] = block_ca9nu_info;
           R2 = P64[R1 + 7];
           _sa8hK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8hK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9nu() //  []
         { info_tbl: [(ca9nu,
                       label: block_ca9nu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9nu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle_1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(ca9nI,
                       label: GHC.IO.Handle.Internals.wantReadableHandle_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9nI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca9nJ; else goto ca9nK;
       ca9nJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9nK: // global
           I64[Sp - 24] = block_ca9mh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9o1; else goto ca9mi;
       ua9o1: // global
           call _ca9mh(R1) args: 0, res: 0, upd: 0;
       ca9mi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9mh() //  [R1]
         { info_tbl: [(ca9mh,
                       label: block_ca9mh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9mh: // global
           if (R1 & 7 == 1) goto ca9nF; else goto ca9nG;
       ca9nF: // global
           I64[Sp - 16] = block_ca9mm_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       ca9nG: // global
           I64[Sp - 16] = block_ca9n1_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9mm() //  [R1]
         { info_tbl: [(ca9mm,
                       label: block_ca9mm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9mm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9nO; else goto ca9nN;
       ca9nO: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9nN: // global
           I64[Hp - 32] = io_sa8h9_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _ca9mo::P64 = Hp - 31;
           if (R1 == 0) goto ca9nS; else goto ca9nR;
       ca9nS: // global
           R1 = _ca9mo::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9nR: // global
           R1 = _ca9mo::P64;
           Sp = Sp + 40;
           call io_sa8h9_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9n1() //  [R1]
         { info_tbl: [(ca9n1,
                       label: block_ca9n1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9n1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9nW; else goto ca9nV;
       ca9nW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9nV: // global
           I64[Hp - 32] = io_sa8hw_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _ca9n3::P64 = Hp - 31;
           if (R1 == 0) goto ca9o0; else goto ca9nZ;
       ca9o0: // global
           R1 = _ca9n3::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9nZ: // global
           R1 = _ca9n3::P64;
           Sp = Sp + 40;
           call io_sa8hw_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.882399101 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle__closure" {
     GHC.IO.Handle.Internals.wantReadableHandle__closure:
         const GHC.IO.Handle.Internals.wantReadableHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle__entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(ca9o6,
                       label: GHC.IO.Handle.Internals.wantReadableHandle__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9o6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.883480288 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle2_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle2_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle2_info;
         const 0;
 },
 sat_sa8hS_entry() //  [R1]
         { info_tbl: [(ca9oj,
                       label: sat_sa8hS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9oj: // global
           _sa8hS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9ok; else goto ca9ol;
       ca9ol: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ca9on; else goto ca9om;
       ca9on: // global
           HpAlloc = 72;
           goto ca9ok;
       ca9ok: // global
           R1 = _sa8hS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9om: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa8hS::P64;
           _sa8hN::P64 = P64[_sa8hS::P64 + 16];
           _sa8hO::P64 = P64[_sa8hS::P64 + 24];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa8hO::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = _sa8hN::P64;
           P64[Hp - 16] = GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.wantSeekableHandle2_entry() //  [R2, R3]
         { info_tbl: [(ca9oo,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9oo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca9os; else goto ca9or;
       ca9os: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9or: // global
           I64[Hp - 24] = sat_sa8hS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.886351401 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle1_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle1_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle1_info;
         const 0;
 },
 sat_sa8iB_entry() //  [R1, R2]
         { info_tbl: [(ca9oR,
                       label: sat_sa8iB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9oR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca9oS; else goto ca9oT;
       ca9oS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9oT: // global
           I64[Sp - 16] = block_ca9oO_info;
           _sa8hV::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sa8hV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua9pJ; else goto ca9oP;
       ua9pJ: // global
           call _ca9oO(R1) args: 0, res: 0, upd: 0;
       ca9oP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9oO() //  [R1]
         { info_tbl: [(ca9oO,
                       label: block_ca9oO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9oO: // global
           I64[Sp - 24] = block_ca9oW_info;
           _sa8i7::P64 = R1;
           _sa8i8::P64 = P64[R1 + 7];
           _sa8ib::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sa8i8::P64;
           P64[Sp - 8] = _sa8ib::P64;
           P64[Sp] = _sa8i7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9pI; else goto ca9oY;
       ua9pI: // global
           call _ca9oW(R1) args: 0, res: 0, upd: 0;
       ca9oY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9oW() //  [R1]
         { info_tbl: [(ca9oW,
                       label: block_ca9oW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9oW: // global
           _ca9pC::P64 = R1 & 7;
           if (_ca9pC::P64 < 3) goto ua9pE; else goto ua9pF;
       ua9pE: // global
           if (_ca9pC::P64 < 2) goto ca9pt; else goto ca9px;
       ca9pt: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca9px: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ua9pF: // global
           if (_ca9pC::P64 != 5) goto ca9p7; else goto ua9pG;
       ca9p7: // global
           _sa8ib::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca9p2_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sa8ib::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
       ua9pG: // global
           Sp = Sp + 40;
           call _ca9pB() args: 0, res: 0, upd: 0;
     }
 },
 _ca9p2() //  [R1]
         { info_tbl: [(ca9p2,
                       label: block_ca9p2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9p2: // global
           I64[Sp] = block_ca9p4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9pL; else goto ca9p9;
       ua9pL: // global
           call _ca9p4(R1) args: 0, res: 0, upd: 0;
       ca9p9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9p4() //  [R1]
         { info_tbl: [(ca9p4,
                       label: block_ca9p4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9p4: // global
           if (R1 & 7 == 1) goto ua9pH; else goto ca9pm;
       ua9pH: // global
           Sp = Sp + 24;
           call _ca9pB() args: 0, res: 0, upd: 0;
       ca9pm: // global
           I64[Sp] = block_ca9pi_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9pi() //  [R1]
         { info_tbl: [(ca9pi,
                       label: block_ca9pi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9pi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9pp; else goto ca9po;
       ca9pp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9po: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9pB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9pB: // global
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8i3_entry() //  [R1]
         { info_tbl: [(ca9pS,
                       label: io_sa8i3_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9pS: // global
           _sa8i3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9pW; else goto ca9pX;
       ca9pX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9pZ; else goto ca9pY;
       ca9pZ: // global
           HpAlloc = 16;
           goto ca9pW;
       ca9pW: // global
           R1 = _sa8i3::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9pY: // global
           _sa8hT::P64 = P64[_sa8i3::P64 + 7];
           _sa8hV::P64 = P64[_sa8i3::P64 + 15];
           _sa8hX::P64 = P64[_sa8i3::P64 + 23];
           _sa8hZ::P64 = P64[_sa8i3::P64 + 31];
           I64[Hp - 8] = sat_sa8iB_info;
           P64[Hp] = _sa8hV::P64;
           I64[Sp - 16] = block_ca9pN_info;
           R5 = _sa8hZ::P64;
           R4 = Hp - 6;
           R3 = _sa8hX::P64;
           R2 = _sa8hT::P64;
           P64[Sp - 8] = _sa8hZ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9pN() //  [R1]
         { info_tbl: [(ca9pN,
                       label: block_ca9pN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9pN: // global
           I64[Sp] = block_ca9pP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9q4; else goto ca9pQ;
       ua9q4: // global
           call _ca9pP(R1) args: 0, res: 0, upd: 0;
       ca9pQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9pP() //  [R1]
         { info_tbl: [(ca9pP,
                       label: block_ca9pP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9pP: // global
           I64[Sp] = block_ca9pV_info;
           R2 = P64[R1 + 7];
           _sa8iH::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8iH::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9pV() //  []
         { info_tbl: [(ca9pV,
                       label: block_ca9pV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9pV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantSeekableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(ca9q9,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9q9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca9qa; else goto ca9qb;
       ca9qa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9qb: // global
           I64[Sp - 24] = block_ca9ox_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9qn; else goto ca9oy;
       ua9qn: // global
           call _ca9ox(R1) args: 0, res: 0, upd: 0;
       ca9oy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ox() //  [R1]
         { info_tbl: [(ca9ox,
                       label: block_ca9ox_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ox: // global
           if (R1 & 7 == 1) goto ca9q6; else goto ca9q7;
       ca9q6: // global
           I64[Sp - 16] = block_ca9oC_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       ca9q7: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.wantSeekableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _ca9oC() //  [R1]
         { info_tbl: [(ca9oC,
                       label: block_ca9oC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9oC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9qf; else goto ca9qe;
       ca9qf: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9qe: // global
           I64[Hp - 32] = io_sa8i3_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _ca9oE::P64 = Hp - 31;
           if (R1 == 0) goto ca9qj; else goto ca9qi;
       ca9qj: // global
           R1 = _ca9oE::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9qi: // global
           R1 = _ca9oE::P64;
           Sp = Sp + 40;
           call io_sa8i3_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.890314687 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9qs,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9qs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.894973431 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwantWritableHandle'_closure" {
     GHC.IO.Handle.Internals.$wwantWritableHandle'_closure:
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_info;
         const 0;
 },
 sat_sa8jT_entry() //  [R1]
         { info_tbl: [(ca9rl,
                       label: sat_sa8jT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9rl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9rp; else goto ca9rq;
       ca9rp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9rq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9ri_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9ru; else goto ca9rj;
       ua9ru: // global
           call _ca9ri(R1) args: 0, res: 0, upd: 0;
       ca9rj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9ri() //  [R1]
         { info_tbl: [(ca9ri,
                       label: block_ca9ri_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ri: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9rt; else goto ca9rs;
       ca9rt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9rs: // global
           _sa8jO::P64 = P64[R1 + 7];
           _sa8jN::I64 = I64[R1 + 23];
           _sa8jQ::I64 = I64[R1 + 31];
           _sa8jR::I64 = I64[R1 + 39];
           _sa8jS::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8jO::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sa8jN::I64;
           I64[Hp - 16] = _sa8jQ::I64;
           I64[Hp - 8] = _sa8jR::I64;
           I64[Hp] = _sa8jS::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8ko_entry() //  [R1]
         { info_tbl: [(ca9rP,
                       label: sat_sa8ko_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9rP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9rT; else goto ca9rU;
       ca9rT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9rU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9rM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9rY; else goto ca9rN;
       ua9rY: // global
           call _ca9rM(R1) args: 0, res: 0, upd: 0;
       ca9rN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9rM() //  [R1]
         { info_tbl: [(ca9rM,
                       label: block_ca9rM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9rM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9rX; else goto ca9rW;
       ca9rX: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9rW: // global
           _sa8kj::P64 = P64[R1 + 7];
           _sa8kk::P64 = P64[R1 + 15];
           _sa8ki::I64 = I64[R1 + 23];
           _sa8kl::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8kj::P64;
           P64[Hp - 32] = _sa8kk::P64;
           I64[Hp - 24] = _sa8ki::I64;
           I64[Hp - 16] = _sa8kl::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8kH_entry() //  [R1]
         { info_tbl: [(ca9sl,
                       label: sat_sa8kH_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9sl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca9ss; else goto ca9st;
       ca9ss: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9st: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ca9si_info;
           _sa8kx::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa8kx::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua9sx; else goto ca9sj;
       ua9sx: // global
           call _ca9si(R1) args: 0, res: 0, upd: 0;
       ca9sj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9si() //  [R1]
         { info_tbl: [(ca9si,
                       label: block_ca9si_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9si: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9sw; else goto ca9sv;
       ca9sw: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9sv: // global
           _sa8kB::P64 = P64[R1 + 7];
           _sa8kC::P64 = P64[R1 + 15];
           _sa8kA::I64 = I64[R1 + 23];
           _sa8kD::I64 = I64[R1 + 31];
           _sa8kF::I64 = I64[R1 + 47];
           _sa8kG::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8kB::P64;
           P64[Hp - 32] = _sa8kC::P64;
           I64[Hp - 24] = _sa8kA::I64;
           I64[Hp - 16] = _sa8kD::I64;
           I64[Hp - 8] = _sa8kG::I64;
           I64[Hp] = _sa8kF::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ua9uX_srtd" {
     ua9uX_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 sat_sa8l6_entry() //  [R1, R2]
         { info_tbl: [(ca9sy,
                       label: sat_sa8l6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9sy: // global
           if ((Sp + -112) < SpLim) (likely: False) goto ca9sz; else goto ca9sA;
       ca9sz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9sA: // global
           I64[Sp - 16] = block_ca9qE_info;
           _sa8iQ::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sa8iQ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua9uP; else goto ca9qF;
       ua9uP: // global
           call _ca9qE(R1) args: 0, res: 0, upd: 0;
       ca9qF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua9uY_srtd" {
     ua9uY_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 _ca9qE() //  [R1]
         { info_tbl: [(ca9qE,
                       label: block_ca9qE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9qE: // global
           I64[Sp - 56] = block_ca9qJ_info;
           _sa8iU::P64 = R1;
           _sa8iW::P64 = P64[R1 + 15];
           _sa8iY::P64 = P64[R1 + 31];
           _sa8j0::P64 = P64[R1 + 47];
           _sa8j2::P64 = P64[R1 + 63];
           _sa8j3::P64 = P64[R1 + 71];
           _sa8j6::P64 = P64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 48] = _sa8iW::P64;
           P64[Sp - 40] = _sa8iY::P64;
           P64[Sp - 32] = _sa8j0::P64;
           P64[Sp - 24] = _sa8j2::P64;
           P64[Sp - 16] = _sa8j3::P64;
           P64[Sp - 8] = _sa8j6::P64;
           P64[Sp] = _sa8iU::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ua9uC; else goto ca9qK;
       ua9uC: // global
           call _ca9qJ(R1) args: 0, res: 0, upd: 0;
       ca9qK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ua9uZ_srtd" {
     ua9uZ_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 _ca9qJ() //  [R1]
         { info_tbl: [(ca9qJ,
                       label: block_ca9qJ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9qJ: // global
           _ca9ug::P64 = R1 & 7;
           if (_ca9ug::P64 < 4) goto ua9uu; else goto ua9uw;
       ua9uu: // global
           if (_ca9ug::P64 < 3) goto ua9uv; else goto ca9sU;
       ua9uv: // global
           if (_ca9ug::P64 < 2) goto ca9sO; else goto ca9sR;
       ca9sO: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca9sR: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca9sU: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ua9uw: // global
           if (_ca9ug::P64 < 6) goto ca9sI; else goto ca9sW;
       ca9sI: // global
           I64[Sp + 48] = block_ca9sD_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       ca9sW: // global
           _sa8jl::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_ca9qS_info;
           R1 = _sa8jl::P64;
           if (R1 & 7 != 0) goto ua9uD; else goto ca9qT;
       ua9uD: // global
           call _ca9qS(R1) args: 0, res: 0, upd: 0;
       ca9qT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9sD() //  [R1]
         { info_tbl: [(ca9sD,
                       label: block_ca9sD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9sD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9sL; else goto ca9sK;
       ca9sL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9sK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9qS() //  [R1]
         { info_tbl: [(ca9qS,
                       label: block_ca9qS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9qS: // global
           I64[Sp] = block_ca9qX_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ua9uE; else goto ca9qY;
       ua9uE: // global
           call _ca9qX(R1) args: 0, res: 0, upd: 0;
       ca9qY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9qX() //  [R1]
         { info_tbl: [(ca9qX,
                       label: block_ca9qX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9qX: // global
           if (R1 & 7 == 1) goto ca9t0; else goto ca9uc;
       ca9t0: // global
           _sa8jw::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_ca9r2_info;
           R1 = _sa8jw::P64;
           if (R1 & 7 != 0) goto ua9uF; else goto ca9r3;
       ua9uF: // global
           call _ca9r2(R1) args: 0, res: 0, upd: 0;
       ca9r3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca9uc: // global
           I64[Sp + 48] = block_ca9u8_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9r2() //  [R1]
         { info_tbl: [(ca9r2,
                       label: block_ca9r2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9r2: // global
           I64[Sp - 16] = block_ca9rv_info;
           _sa8jC::I64 = I64[R1 + 39];
           _sa8jD::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa8jD::I64;
           I64[Sp] = _sa8jC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua9uG; else goto ca9rw;
       ua9uG: // global
           call _ca9rv(R1) args: 0, res: 0, upd: 0;
       ca9rw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9rv() //  [R1]
         { info_tbl: [(ca9rv,
                       label: block_ca9rv_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9rv: // global
           if (R1 & 7 == 1) goto ca9u1; else goto ua9ux;
       ca9u1: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ua9uy; else goto ca9tn;
       ua9uy: // global
           Sp = Sp + 24;
           goto ua9uJ;
       ca9tn: // global
           _sa8ka::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp + 16] = block_ca9rD_info;
           R1 = _sa8ka::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ua9uH; else goto ca9rE;
       ua9uH: // global
           call _ca9rD(R1) args: 0, res: 0, upd: 0;
       ca9rE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ua9ux: // global
           Sp = Sp + 24;
           goto ua9uJ;
       ua9uJ: // global
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 _ca9rD() //  [R1]
         { info_tbl: [(ca9rD,
                       label: block_ca9rD_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9rD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9tq; else goto ca9tp;
       ca9tq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9tp: // global
           _sa8j3::P64 = P64[Sp + 40];
           _sa8kc::P64 = P64[R1 + 7];
           _sa8kd::P64 = P64[R1 + 15];
           _sa8kg::P64 = P64[_sa8j3::P64 + 8];
           I64[Hp - 16] = sat_sa8ko_info;
           P64[Hp] = _sa8kg::P64;
           call MO_WriteBarrier();
           P64[_sa8j3::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j3::P64);
           I64[Sp - 8] = block_ca9s2_info;
           R1 = _sa8kg::P64;
           P64[Sp] = _sa8kd::P64;
           P64[Sp + 32] = _sa8kc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9uK; else goto ca9s3;
       ua9uK: // global
           call _ca9s2(R1) args: 0, res: 0, upd: 0;
       ca9s3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9s2() //  [R1]
         { info_tbl: [(ca9s2,
                       label: block_ca9s2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9s2: // global
           _sa8kx::I64 = I64[R1 + 39];
           if (_sa8kx::I64 != 0) goto ca9tt; else goto ca9tY;
       ca9tt: // global
           I64[Sp - 24] = block_ca9s9_info;
           _sa8ks::P64 = P64[R1 + 7];
           _sa8kt::P64 = P64[R1 + 15];
           _sa8kr::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           P64[Sp - 16] = _sa8kt::P64;
           I64[Sp - 8] = _sa8kx::I64;
           P64[Sp] = _sa8ks::P64;
           I64[Sp + 56] = _sa8kr::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9uL; else goto ca9sa;
       ua9uL: // global
           call _ca9s9(R1) args: 0, res: 0, upd: 0;
       ca9sa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca9tY: // global
           _sa8j0::P64 = P64[Sp + 32];
           _sa8kd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = _sa8kd::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 16;
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 _ca9s9() //  [R1]
         { info_tbl: [(ca9s9,
                       label: block_ca9s9_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9s9: // global
           if (R1 & 7 == 1) goto ca9tv; else goto ca9tN;
       ca9tv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca9ty; else goto ca9tx;
       ca9ty: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9tx: // global
           I64[Hp - 24] = sat_sa8kH_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sa8j0::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 40;
           call _sa8jE() args: 0, res: 0, upd: 0;
       ca9tN: // global
           I64[Sp] = block_ca9tB_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua9uN; else goto ca9tC;
       ua9uN: // global
           call _ca9tB(R1) args: 0, res: 0, upd: 0;
       ca9tC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9tB() //  [R1]
         { info_tbl: [(ca9tB,
                       label: block_ca9tB_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9tB: // global
           I64[Sp - 8] = block_ca9tG_info;
           R2 = P64[Sp + 64];
           _sa8kL::P64 = P64[R1 + 7];
           _sa8kM::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa8kM::P64;
           P64[Sp + 64] = _sa8kL::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9tG() //  [R1]
         { info_tbl: [(ca9tG,
                       label: block_ca9tG_info
                       rep:StackRep [False, False, True, False, False, False, False,
                                     False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9tG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9tR; else goto ca9tQ;
       ca9tR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9tQ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sa8kd::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_ca9tJ_info;
           R5 = Hp - 47;
           R4 = _sa8kd::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 72];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9tJ() //  [R1]
         { info_tbl: [(ca9tJ,
                       label: block_ca9tJ_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9tJ: // global
           I64[Sp] = block_ca9tL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9uQ; else goto ca9tT;
       ua9uQ: // global
           call _ca9tL(R1) args: 0, res: 0, upd: 0;
       ca9tT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9tL() //  [R1]
         { info_tbl: [(ca9tL,
                       label: block_ca9tL_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9tL: // global
           _sa8j0::P64 = P64[Sp + 24];
           _sa8kY::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = _sa8kY::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 8;
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 _sa8jE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8jE: // global
           I64[Sp - 8] = block_ca9rc_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9rc() //  [R1]
         { info_tbl: [(ca9rc,
                       label: block_ca9rc_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9rc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9tg; else goto ca9tf;
       ca9tg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9tf: // global
           _sa8j3::P64 = P64[Sp + 40];
           _sa8jL::P64 = P64[_sa8j3::P64 + 8];
           I64[Hp - 16] = sat_sa8jT_info;
           P64[Hp] = _sa8jL::P64;
           _sa8iW::P64 = P64[Sp + 8];
           _sa8iY::P64 = P64[Sp + 16];
           _sa8j0::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa8j3::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j3::P64);
           I64[Sp + 16] = block_ca9t5_info;
           R2 = _sa8iW::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa8iY::P64;
           P64[Sp + 8] = P64[_sa8j0::P64 + 8];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.emptyWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca9t5() //  [R1]
         { info_tbl: [(ca9t5,
                       label: block_ca9t5_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9t5: // global
           _sa8iQ::P64 = P64[Sp + 48];
           _sa8iU::P64 = P64[Sp + 40];
           _sa8j0::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           I64[Sp + 32] = block_ca9ta_info;
           R2 = _sa8iU::P64;
           R1 = _sa8iQ::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ta() //  [R1]
         { info_tbl: [(ca9ta,
                       label: block_ca9ta_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ta: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9tk; else goto ca9tj;
       ca9tk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9tj: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9u8() //  [R1]
         { info_tbl: [(ca9u8,
                       label: block_ca9u8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9u8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9uf; else goto ca9ue;
       ca9uf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9ue: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ua9v0_srtd" {
     ua9v0_srtd:
         const Sa8nI_srt+104;
         const 62;
         const 3891391553024819201;
 },
 GHC.IO.Handle.Internals.$wwantWritableHandle'_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(ca9uS,
                       label: GHC.IO.Handle.Internals.$wwantWritableHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9uS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9uW; else goto ca9uV;
       ca9uW: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9uV: // global
           I64[Hp - 8] = sat_sa8l6_info;
           P64[Hp] = R5;
           R5 = Hp - 6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.904093537 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle1_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle1_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(ca9vc,
                       label: GHC.IO.Handle.Internals.wantWritableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9vc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9vd; else goto ca9ve;
       ca9vd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantWritableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9ve: // global
           I64[Sp - 24] = block_ca9v5_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9vl; else goto ca9v6;
       ua9vl: // global
           call _ca9v5(R1) args: 0, res: 0, upd: 0;
       ca9v6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9v5() //  [R1]
         { info_tbl: [(ca9v5,
                       label: block_ca9v5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9v5: // global
           _sa8l7::P64 = P64[Sp + 8];
           _sa8l9::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ca9v9; else goto ca9va;
       ca9v9: // global
           R5 = _sa8l9::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = _sa8l7::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       ca9va: // global
           R5 = _sa8l9::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = _sa8l7::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.905586718 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9vq,
                       label: GHC.IO.Handle.Internals.wantWritableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9vq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.907556073 UTC

[section ""data" . withHandle2_ra7PH_closure" {
     withHandle2_ra7PH_closure:
         const withHandle2_ra7PH_info;
         const 0;
 },
 io_sa8lr_entry() //  [R1]
         { info_tbl: [(ca9vO,
                       label: io_sa8lr_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9vO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9vS; else goto ca9vT;
       ca9vS: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9vT: // global
           I64[Sp - 16] = block_ca9vJ_info;
           _sa8ln::P64 = P64[R1 + 31];
           R5 = _sa8ln::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8ln::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9vJ() //  [R1]
         { info_tbl: [(ca9vJ,
                       label: block_ca9vJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9vJ: // global
           I64[Sp] = block_ca9vL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9vY; else goto ca9vM;
       ua9vY: // global
           call _ca9vL(R1) args: 0, res: 0, upd: 0;
       ca9vM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9vL() //  [R1]
         { info_tbl: [(ca9vL,
                       label: block_ca9vL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9vL: // global
           I64[Sp] = block_ca9vR_info;
           R2 = P64[R1 + 7];
           _sa8ly::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8ly::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9vR() //  []
         { info_tbl: [(ca9vR,
                       label: block_ca9vR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9vR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8lH_entry() //  [R1]
         { info_tbl: [(ca9wd,
                       label: io_sa8lH_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9wd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9wh; else goto ca9wi;
       ca9wh: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9wi: // global
           I64[Sp - 16] = block_ca9w8_info;
           _sa8lC::P64 = P64[R1 + 31];
           R5 = _sa8lC::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8lC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9w8() //  [R1]
         { info_tbl: [(ca9w8,
                       label: block_ca9w8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9w8: // global
           I64[Sp] = block_ca9wa_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9wn; else goto ca9wb;
       ua9wn: // global
           call _ca9wa(R1) args: 0, res: 0, upd: 0;
       ca9wb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9wa() //  [R1]
         { info_tbl: [(ca9wa,
                       label: block_ca9wa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9wa: // global
           I64[Sp] = block_ca9wg_info;
           R2 = P64[R1 + 7];
           _sa8lO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8lO::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9wg() //  []
         { info_tbl: [(ca9wg,
                       label: block_ca9wg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9wg: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 withHandle2_ra7PH_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9ws,
                       label: withHandle2_ra7PH_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ws: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca9wt; else goto ca9wu;
       ca9wt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle2_ra7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9wu: // global
           I64[Sp - 24] = block_ca9vx_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9wL; else goto ca9vy;
       ua9wL: // global
           call _ca9vx(R1) args: 0, res: 0, upd: 0;
       ca9vy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9vx() //  [R1]
         { info_tbl: [(ca9vx,
                       label: block_ca9vx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9vx: // global
           if (R1 & 7 == 1) goto ca9wp; else goto ca9wq;
       ca9wp: // global
           I64[Sp - 16] = block_ca9vC_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       ca9wq: // global
           I64[Sp - 16] = block_ca9w1_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9vC() //  [R1]
         { info_tbl: [(ca9vC,
                       label: block_ca9vC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9vC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9wy; else goto ca9wx;
       ca9wy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9wx: // global
           I64[Hp - 32] = io_sa8lr_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _ca9vE::P64 = Hp - 31;
           if (R1 == 0) goto ca9wC; else goto ca9wB;
       ca9wC: // global
           R1 = _ca9vE::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9wB: // global
           R1 = _ca9vE::P64;
           Sp = Sp + 40;
           call io_sa8lr_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9w1() //  [R1]
         { info_tbl: [(ca9w1,
                       label: block_ca9w1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9w1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9wG; else goto ca9wF;
       ca9wG: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9wF: // global
           I64[Hp - 32] = io_sa8lH_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _ca9w3::P64 = Hp - 31;
           if (R1 == 0) goto ca9wK; else goto ca9wJ;
       ca9wK: // global
           R1 = _ca9w3::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9wJ: // global
           R1 = _ca9w3::P64;
           Sp = Sp + 40;
           call io_sa8lH_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.910947358 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_closure" {
     GHC.IO.Handle.Internals.withHandle_closure:
         const GHC.IO.Handle.Internals.withHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9wQ,
                       label: GHC.IO.Handle.Internals.withHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9wQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle2_ra7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.913198335 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle1_info;
         const 0;
 },
 sat_sa8m3_entry() //  [R1, R2]
         { info_tbl: [(ca9xe,
                       label: sat_sa8m3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xe: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8m1_entry() //  [R1]
         { info_tbl: [(ca9xm,
                       label: io_sa8m1_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xm: // global
           _sa8m1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9xq; else goto ca9xr;
       ca9xr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9xt; else goto ca9xs;
       ca9xt: // global
           HpAlloc = 16;
           goto ca9xq;
       ca9xq: // global
           R1 = _sa8m1::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9xs: // global
           _sa8lR::P64 = P64[_sa8m1::P64 + 7];
           _sa8lT::P64 = P64[_sa8m1::P64 + 15];
           _sa8lV::P64 = P64[_sa8m1::P64 + 23];
           _sa8lX::P64 = P64[_sa8m1::P64 + 31];
           I64[Hp - 8] = sat_sa8m3_info;
           P64[Hp] = _sa8lT::P64;
           I64[Sp - 16] = block_ca9xh_info;
           R5 = _sa8lX::P64;
           R4 = Hp - 6;
           R3 = _sa8lV::P64;
           R2 = _sa8lR::P64;
           P64[Sp - 8] = _sa8lX::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9xh() //  [R1]
         { info_tbl: [(ca9xh,
                       label: block_ca9xh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xh: // global
           I64[Sp] = block_ca9xj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9xy; else goto ca9xk;
       ua9xy: // global
           call _ca9xj(R1) args: 0, res: 0, upd: 0;
       ca9xk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9xj() //  [R1]
         { info_tbl: [(ca9xj,
                       label: block_ca9xj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xj: // global
           I64[Sp] = block_ca9xp_info;
           R2 = P64[R1 + 7];
           _sa8m9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8m9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9xp() //  []
         { info_tbl: [(ca9xp,
                       label: block_ca9xp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8mk_entry() //  [R1, R2]
         { info_tbl: [(ca9xN,
                       label: sat_sa8mk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xN: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8mi_entry() //  [R1]
         { info_tbl: [(ca9xV,
                       label: io_sa8mi_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xV: // global
           _sa8mi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9xZ; else goto ca9y0;
       ca9y0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9y2; else goto ca9y1;
       ca9y2: // global
           HpAlloc = 16;
           goto ca9xZ;
       ca9xZ: // global
           R1 = _sa8mi::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9y1: // global
           _sa8lR::P64 = P64[_sa8mi::P64 + 7];
           _sa8lT::P64 = P64[_sa8mi::P64 + 15];
           _sa8lV::P64 = P64[_sa8mi::P64 + 23];
           _sa8md::P64 = P64[_sa8mi::P64 + 31];
           I64[Hp - 8] = sat_sa8mk_info;
           P64[Hp] = _sa8lT::P64;
           I64[Sp - 16] = block_ca9xQ_info;
           R5 = _sa8md::P64;
           R4 = Hp - 6;
           R3 = _sa8lV::P64;
           R2 = _sa8lR::P64;
           P64[Sp - 8] = _sa8md::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9xQ() //  [R1]
         { info_tbl: [(ca9xQ,
                       label: block_ca9xQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xQ: // global
           I64[Sp] = block_ca9xS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9y7; else goto ca9xT;
       ua9y7: // global
           call _ca9xS(R1) args: 0, res: 0, upd: 0;
       ca9xT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9xS() //  [R1]
         { info_tbl: [(ca9xS,
                       label: block_ca9xS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xS: // global
           I64[Sp] = block_ca9xY_info;
           R2 = P64[R1 + 7];
           _sa8mq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8mq::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9xY() //  []
         { info_tbl: [(ca9xY,
                       label: block_ca9xY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(ca9yc,
                       label: GHC.IO.Handle.Internals.wantReadableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9yc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca9yd; else goto ca9ye;
       ca9yd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9ye: // global
           I64[Sp - 24] = block_ca9wX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9yv; else goto ca9wY;
       ua9yv: // global
           call _ca9wX(R1) args: 0, res: 0, upd: 0;
       ca9wY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9wX() //  [R1]
         { info_tbl: [(ca9wX,
                       label: block_ca9wX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9wX: // global
           if (R1 & 7 == 1) goto ca9y9; else goto ca9ya;
       ca9y9: // global
           I64[Sp - 16] = block_ca9x2_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       ca9ya: // global
           I64[Sp - 16] = block_ca9xB_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9x2() //  [R1]
         { info_tbl: [(ca9x2,
                       label: block_ca9x2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9x2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9yi; else goto ca9yh;
       ca9yi: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9yh: // global
           I64[Hp - 32] = io_sa8m1_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _ca9x4::P64 = Hp - 31;
           if (R1 == 0) goto ca9ym; else goto ca9yl;
       ca9ym: // global
           R1 = _ca9x4::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9yl: // global
           R1 = _ca9x4::P64;
           Sp = Sp + 40;
           call io_sa8m1_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9xB() //  [R1]
         { info_tbl: [(ca9xB,
                       label: block_ca9xB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9xB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9yq; else goto ca9yp;
       ca9yq: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ca9yp: // global
           I64[Hp - 32] = io_sa8mi_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _ca9xD::P64 = Hp - 31;
           if (R1 == 0) goto ca9yu; else goto ca9yt;
       ca9yu: // global
           R1 = _ca9xD::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ca9yt: // global
           R1 = _ca9xD::P64;
           Sp = Sp + 40;
           call io_sa8mi_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.917102528 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9yA,
                       label: GHC.IO.Handle.Internals.wantReadableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9yA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.917891929 UTC

[section ""relreadonly" . Sa8nI_srt" {
     Sa8nI_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle12_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const ioe_closedHandle2_ra7Pb_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle8_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const ioe_semiclosedHandle2_ra7Pc_closure;
         const GHC.IO.Handle.Internals.hLookAhead_3_closure;
         const ioe_EOF2_ra7Pd_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle4_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle3_closure;
         const ioe_notReadable2_ra7Pe_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle3_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle2_closure;
         const ioe_notWritable2_ra7Pf_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle4_closure;
         const GHC.IO.Handle.Internals.flushBuffer4_closure;
         const lvl1_ra7Ph_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const lvl6_ra7Pm_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf1_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.Err.error_closure;
         const lvl19_ra7Pz_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer1_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer3_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
         const lvl22_ra7PC_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.noCharBuffer_closure;
         const GHC.IO.Handle.Internals.noByteBuffer_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkFileHandle1_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const $wlvl_ra7PF_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.Internals.withHandle_1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.Internals.withHandle__'1_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.withHandle1_closure;
         const GHC.IO.Handle.Internals.withHandle_'1_closure;
         const withHandle_2_ra7PG_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const withHandle2_ra7PH_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.919003485 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:06.920396406 UTC

[section ""data" . GHC.IO.Handle.Internals.augmentIOError_closure" {
     GHC.IO.Handle.Internals.augmentIOError_closure:
         const GHC.IO.Handle.Internals.augmentIOError_info;
 },
 sat_sa7Q2_entry() //  [R1]
         { info_tbl: [(ca9yX,
                       label: sat_sa7Q2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9yX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca9yY; else goto ca9yZ;
       ca9yY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9yZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ca9yQ_info;
           _sa7PL::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sa7PL::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua9zq; else goto ca9yR;
       ua9zq: // global
           call _ca9yQ(R1) args: 0, res: 0, upd: 0;
       ca9yR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9yQ() //  [R1]
         { info_tbl: [(ca9yQ,
                       label: block_ca9yQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9yQ: // global
           if (R1 & 7 == 1) goto ca9yU; else goto ca9yV;
       ca9yU: // global
           _sa7PL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9z2_info;
           R1 = _sa7PL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua9zp; else goto ca9z4;
       ua9zp: // global
           call _ca9z2(R1) args: 0, res: 0, upd: 0;
       ca9z4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ca9yV: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ca9z2() //  [R1]
         { info_tbl: [(ca9z2,
                       label: block_ca9z2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9z2: // global
           if (R1 & 7 == 1) goto ca9za; else goto ca9zh;
       ca9za: // global
           Hp = Hp + 16;
           _sa7PV::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ca9zk; else goto ca9zc;
       ca9zc: // global
           _sa7PW::P64 = P64[_sa7PV::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa7PW::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ca9zh: // global
           Hp = Hp + 16;
           _sa7PV::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ca9zk; else goto ca9zj;
       ca9zk: // global
           HpAlloc = 16;
           R1 = _sa7PV::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9zj: // global
           _sa7PY::P64 = P64[_sa7PV::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa7PY::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.augmentIOError_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9zr,
                       label: GHC.IO.Handle.Internals.augmentIOError_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9zr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9zu; else goto ca9zv;
       ca9zu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.augmentIOError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9zv: // global
           I64[Sp - 24] = block_ca9yH_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9zz; else goto ca9yI;
       ua9zz: // global
           call _ca9yH(R1) args: 0, res: 0, upd: 0;
       ca9yI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9yH() //  [R1]
         { info_tbl: [(ca9yH,
                       label: block_ca9yH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9yH: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ca9zy; else goto ca9zx;
       ca9zy: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9zx: // global
           _sa7PO::P64 = P64[R1 + 15];
           _sa7PQ::P64 = P64[R1 + 31];
           _sa7PR::P64 = P64[R1 + 39];
           _sa7PS::P64 = P64[R1 + 47];
           I64[Hp - 96] = sat_sa7Q2_info;
           _sa7PL::P64 = P64[Sp + 16];
           P64[Hp - 80] = _sa7PL::P64;
           P64[Hp - 72] = _sa7PS::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa7PL::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sa7PO::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sa7PQ::P64;
           P64[Hp - 8] = _sa7PR::P64;
           P64[Hp] = Hp - 96;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.922830963 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle14_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle14_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.923591231 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle13_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle13_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle13_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle13_entry() //  [R1]
         { info_tbl: [(ca9zG,
                       label: GHC.IO.Handle.Internals.wantReadableHandle13_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9zG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9zH; else goto ca9zI;
       ca9zH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9zI: // global
           (_ca9zD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9zD::I64 == 0) goto ca9zF; else goto ca9zE;
       ca9zF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9zE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9zD::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle14_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.927751857 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle12_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle12_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle13_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.928506537 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle11_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle11_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle11_entry() //  [R1]
         { info_tbl: [(ca9zP,
                       label: GHC.IO.Handle.Internals.wantReadableHandle11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9zP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9zQ; else goto ca9zR;
       ca9zQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9zR: // global
           (_ca9zM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9zM::I64 == 0) goto ca9zO; else goto ca9zN;
       ca9zO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9zN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9zM::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle12_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.929643753 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle1_entry() //  []
         { info_tbl: [(ca9zW,
                       label: GHC.IO.Handle.Internals.ioe_closedHandle1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9zW: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.93045774 UTC

[section ""data" . ioe_closedHandle2_ra7Pb_closure" {
     ioe_closedHandle2_ra7Pb_closure:
         const ioe_closedHandle2_ra7Pb_info;
         const 0;
 },
 ioe_closedHandle2_ra7Pb_entry() //  []
         { info_tbl: [(ca9A3,
                       label: ioe_closedHandle2_ra7Pb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9A3: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.931235932 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle_entry() //  []
         { info_tbl: [(ca9Aa,
                       label: GHC.IO.Handle.Internals.ioe_closedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Aa: // global
           call ioe_closedHandle2_ra7Pb_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.931915362 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle10_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle10_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.932615816 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle9_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle9_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle9_entry() //  [R1]
         { info_tbl: [(ca9Aj,
                       label: GHC.IO.Handle.Internals.wantReadableHandle9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Aj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9Ak; else goto ca9Al;
       ca9Ak: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Al: // global
           (_ca9Ag::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9Ag::I64 == 0) goto ca9Ai; else goto ca9Ah;
       ca9Ai: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9Ah: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9Ag::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.933456088 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle8_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle9_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.934192323 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle7_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle7_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle7_entry() //  [R1]
         { info_tbl: [(ca9As,
                       label: GHC.IO.Handle.Internals.wantReadableHandle7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9As: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9At; else goto ca9Au;
       ca9At: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Au: // global
           (_ca9Ap::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9Ap::I64 == 0) goto ca9Ar; else goto ca9Aq;
       ca9Ar: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9Aq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9Ap::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.93515137 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() //  []
         { info_tbl: [(ca9Az,
                       label: GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Az: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.935973571 UTC

[section ""data" . ioe_semiclosedHandle2_ra7Pc_closure" {
     ioe_semiclosedHandle2_ra7Pc_closure:
         const ioe_semiclosedHandle2_ra7Pc_info;
         const 0;
 },
 ioe_semiclosedHandle2_ra7Pc_entry() //  []
         { info_tbl: [(ca9AG,
                       label: ioe_semiclosedHandle2_ra7Pc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9AG: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.936813668 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle_entry() //  []
         { info_tbl: [(ca9AN,
                       label: GHC.IO.Handle.Internals.ioe_semiclosedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9AN: // global
           call ioe_semiclosedHandle2_ra7Pc_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.937568008 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_4_closure" {
     GHC.IO.Handle.Internals.hLookAhead_4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.938342569 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_3_closure" {
     GHC.IO.Handle.Internals.hLookAhead_3_closure:
         const GHC.IO.Handle.Internals.hLookAhead_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_3_entry() //  [R1]
         { info_tbl: [(ca9AW,
                       label: GHC.IO.Handle.Internals.hLookAhead_3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9AW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9AX; else goto ca9AY;
       ca9AX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9AY: // global
           (_ca9AT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9AT::I64 == 0) goto ca9AV; else goto ca9AU;
       ca9AV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9AU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9AT::I64;
           R2 = GHC.IO.Handle.Internals.hLookAhead_4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.939358992 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF1_closure" {
     GHC.IO.Handle.Internals.ioe_EOF1_closure:
         const GHC.IO.Handle.Internals.ioe_EOF1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF1_entry() //  []
         { info_tbl: [(ca9B3,
                       label: GHC.IO.Handle.Internals.ioe_EOF1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9B3: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.940133585 UTC

[section ""data" . ioe_EOF2_ra7Pd_closure" {
     ioe_EOF2_ra7Pd_closure:
         const ioe_EOF2_ra7Pd_info;
         const 0;
 },
 ioe_EOF2_ra7Pd_entry() //  []
         { info_tbl: [(ca9Ba,
                       label: ioe_EOF2_ra7Pd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ba: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.940913394 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF_closure" {
     GHC.IO.Handle.Internals.ioe_EOF_closure:
         const GHC.IO.Handle.Internals.ioe_EOF_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF_entry() //  []
         { info_tbl: [(ca9Bh,
                       label: GHC.IO.Handle.Internals.ioe_EOF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Bh: // global
           call ioe_EOF2_ra7Pd_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.941810029 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,114,101,97,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.942528431 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle5_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle5_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle5_entry() //  [R1]
         { info_tbl: [(ca9Bq,
                       label: GHC.IO.Handle.Internals.wantReadableHandle5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Bq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9Br; else goto ca9Bs;
       ca9Br: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Bs: // global
           (_ca9Bn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9Bn::I64 == 0) goto ca9Bp; else goto ca9Bo;
       ca9Bp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9Bo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9Bn::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.943373832 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle4_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.944122417 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle3_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle3_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle3_entry() //  [R1]
         { info_tbl: [(ca9Bz,
                       label: GHC.IO.Handle.Internals.wantReadableHandle3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Bz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9BA; else goto ca9BB;
       ca9BA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9BB: // global
           (_ca9Bw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9Bw::I64 == 0) goto ca9By; else goto ca9Bx;
       ca9By: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9Bx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9Bw::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.945142601 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable1_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable1_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable1_entry() //  []
         { info_tbl: [(ca9BG,
                       label: GHC.IO.Handle.Internals.ioe_notReadable1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9BG: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.946007265 UTC

[section ""data" . ioe_notReadable2_ra7Pe_closure" {
     ioe_notReadable2_ra7Pe_closure:
         const ioe_notReadable2_ra7Pe_info;
         const 0;
 },
 ioe_notReadable2_ra7Pe_entry() //  []
         { info_tbl: [(ca9BN,
                       label: ioe_notReadable2_ra7Pe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9BN: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.946798183 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable_entry() //  []
         { info_tbl: [(ca9BU,
                       label: GHC.IO.Handle.Internals.ioe_notReadable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9BU: // global
           call ioe_notReadable2_ra7Pe_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.947481669 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantWritableHandle5_bytes" {
     GHC.IO.Handle.Internals.wantWritableHandle5_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,119,114,105,116,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.948193781 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle4_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle4_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle4_entry() //  [R1]
         { info_tbl: [(ca9C3,
                       label: GHC.IO.Handle.Internals.wantWritableHandle4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9C3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9C4; else goto ca9C5;
       ca9C4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9C5: // global
           (_ca9C0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9C0::I64 == 0) goto ca9C2; else goto ca9C1;
       ca9C2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9C1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9C0::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.949091649 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle3_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantWritableHandle4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.949906125 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle2_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle2_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle2_entry() //  [R1]
         { info_tbl: [(ca9Cc,
                       label: GHC.IO.Handle.Internals.wantWritableHandle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Cc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9Cd; else goto ca9Ce;
       ca9Cd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Ce: // global
           (_ca9C9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9C9::I64 == 0) goto ca9Cb; else goto ca9Ca;
       ca9Cb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9Ca: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9C9::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.950858469 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable1_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable1_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable1_entry() //  []
         { info_tbl: [(ca9Cj,
                       label: GHC.IO.Handle.Internals.ioe_notWritable1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Cj: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.951655737 UTC

[section ""data" . ioe_notWritable2_ra7Pf_closure" {
     ioe_notWritable2_ra7Pf_closure:
         const ioe_notWritable2_ra7Pf_info;
         const 0;
 },
 ioe_notWritable2_ra7Pf_entry() //  []
         { info_tbl: [(ca9Cq,
                       label: ioe_notWritable2_ra7Pf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Cq: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.952445625 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable_entry() //  []
         { info_tbl: [(ca9Cx,
                       label: GHC.IO.Handle.Internals.ioe_notWritable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Cx: // global
           call ioe_notWritable2_ra7Pf_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.95307438 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantSeekableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantSeekableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.954152216 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle5_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle5_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle5_entry() //  [R1]
         { info_tbl: [(ca9CG,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9CG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9CH; else goto ca9CI;
       ca9CH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9CI: // global
           (_ca9CD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9CD::I64 == 0) goto ca9CF; else goto ca9CE;
       ca9CF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9CE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9CD::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.955040439 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle4_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.955823836 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle3_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle3_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle3_entry() //  [R1]
         { info_tbl: [(ca9CP,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9CP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9CQ; else goto ca9CR;
       ca9CQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9CR: // global
           (_ca9CM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9CM::I64 == 0) goto ca9CO; else goto ca9CN;
       ca9CO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9CN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9CM::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.956726768 UTC

[section ""cstring" . GHC.IO.Handle.Internals.flushBuffer6_bytes" {
     GHC.IO.Handle.Internals.flushBuffer6_bytes:
         I8[] [99,97,110,110,111,116,32,102,108,117,115,104,32,116,104,101,32,114,101,97,100,32,98,117,102,102,101,114,58,32,117,110,100,101,114,108,121,105,110,103,32,100,101,118,105,99,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.957543734 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer5_closure" {
     GHC.IO.Handle.Internals.flushBuffer5_closure:
         const GHC.IO.Handle.Internals.flushBuffer5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer5_entry() //  [R1]
         { info_tbl: [(ca9CY,
                       label: GHC.IO.Handle.Internals.flushBuffer5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9CY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9CZ; else goto ca9D0;
       ca9CZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9D0: // global
           (_ca9CV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9CV::I64 == 0) goto ca9CX; else goto ca9CW;
       ca9CX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9CW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9CV::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.958465439 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer4_closure" {
     GHC.IO.Handle.Internals.flushBuffer4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.flushBuffer5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.959238818 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer3_closure" {
     GHC.IO.Handle.Internals.flushBuffer3_closure:
         const GHC.IO.Handle.Internals.flushBuffer3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer3_entry() //  [R1]
         { info_tbl: [(ca9D7,
                       label: GHC.IO.Handle.Internals.flushBuffer3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9D7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9D8; else goto ca9D9;
       ca9D8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9D9: // global
           (_ca9D4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9D4::I64 == 0) goto ca9D6; else goto ca9D5;
       ca9D6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9D5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9D4::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.960148311 UTC

[section ""cstring" . lvl_ra7Pg_bytes" {
     lvl_ra7Pg_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.960863404 UTC

[section ""data" . lvl1_ra7Ph_closure" {
     lvl1_ra7Ph_closure:
         const lvl1_ra7Ph_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra7Ph_entry() //  [R1]
         { info_tbl: [(ca9Dg,
                       label: lvl1_ra7Ph_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Dg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9Dh; else goto ca9Di;
       ca9Dh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Di: // global
           (_ca9Dd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9Dd::I64 == 0) goto ca9Df; else goto ca9De;
       ca9Df: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9De: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9Dd::I64;
           R2 = lvl_ra7Pg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.961795966 UTC

[section ""cstring" . lvl2_ra7Pi_bytes" {
     lvl2_ra7Pi_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.964876971 UTC

[section ""data" . GHC.IO.Handle.Internals.$wioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.$wioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.$wioe_bufsiz_info;
         const 0;
 },
 sat_sa7Qi_entry() //  [R1]
         { info_tbl: [(ca9DC,
                       label: sat_sa7Qi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9DC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9DD; else goto ca9DE;
       ca9DD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9DE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9Dz_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca9Dz() //  [R1, R2]
         { info_tbl: [(ca9Dz,
                       label: block_ca9Dz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Dz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9DH; else goto ca9DG;
       ca9DH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ca9DG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Qj_entry() //  [R1]
         { info_tbl: [(ca9DI,
                       label: sat_sa7Qj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9DI: // global
           _sa7Qj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9DJ; else goto ca9DK;
       ca9DK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9DM; else goto ca9DL;
       ca9DM: // global
           HpAlloc = 24;
           goto ca9DJ;
       ca9DJ: // global
           R1 = _sa7Qj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9DL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Qj::P64;
           _sa7Qd::I64 = I64[_sa7Qj::P64 + 16];
           I64[Hp - 16] = sat_sa7Qi_info;
           I64[Hp] = _sa7Qd::I64;
           R3 = Hp - 16;
           R2 = lvl2_ra7Pi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Ql_entry() //  [R1]
         { info_tbl: [(ca9DO,
                       label: sat_sa7Ql_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9DO: // global
           _sa7Ql::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9DP; else goto ca9DQ;
       ca9DQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca9DS; else goto ca9DR;
       ca9DS: // global
           HpAlloc = 80;
           goto ca9DP;
       ca9DP: // global
           R1 = _sa7Ql::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9DR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Ql::P64;
           _sa7Qd::I64 = I64[_sa7Ql::P64 + 16];
           I64[Hp - 72] = sat_sa7Qj_info;
           I64[Hp - 56] = _sa7Qd::I64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = lvl1_ra7Ph_closure;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.$wioe_bufsiz_entry() //  [R2]
         { info_tbl: [(ca9DT,
                       label: GHC.IO.Handle.Internals.$wioe_bufsiz_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9DT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9DX; else goto ca9DW;
       ca9DX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9DW: // global
           I64[Hp - 16] = sat_sa7Ql_info;
           I64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.967127537 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz1_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz1_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz1_entry() //  [R2]
         { info_tbl: [(ca9E5,
                       label: GHC.IO.Handle.Internals.ioe_bufsiz1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9E5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca9E6; else goto ca9E7;
       ca9E6: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9E7: // global
           I64[Sp - 8] = block_ca9E2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9Eb; else goto ca9E3;
       ua9Eb: // global
           call _ca9E2(R1) args: 0, res: 0, upd: 0;
       ca9E3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9E2() //  [R1]
         { info_tbl: [(ca9E2,
                       label: block_ca9E2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9E2: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.968229823 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz_entry() //  [R2]
         { info_tbl: [(ca9Eg,
                       label: GHC.IO.Handle.Internals.ioe_bufsiz_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Eg: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.ioe_bufsiz1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.970381664 UTC

[section ""data" . GHC.IO.Handle.Internals.$wstreamEncode_closure" {
     GHC.IO.Handle.Internals.$wstreamEncode_closure:
         const GHC.IO.Handle.Internals.$wstreamEncode_info;
 },
 GHC.IO.Handle.Internals.$wstreamEncode_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ca9Ep,
                       label: GHC.IO.Handle.Internals.$wstreamEncode_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ep: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca9Eq; else goto ca9Er;
       ca9Eq: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wstreamEncode_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9Er: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _ca9Et() args: 0, res: 0, upd: 0;
     }
 },
 _ca9Et() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Et: // global
           I64[Sp - 8] = block_ca9Ev_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Ev() //  [R1]
         { info_tbl: [(ca9Ev,
                       label: block_ca9Ev_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ev: // global
           I64[Sp] = block_ca9Ex_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9Ft; else goto ca9EA;
       ua9Ft: // global
           call _ca9Ex(R1) args: 0, res: 0, upd: 0;
       ca9EA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Ex() //  [R1]
         { info_tbl: [(ca9Ex,
                       label: block_ca9Ex_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ex: // global
           I64[Sp - 8] = block_ca9EE_info;
           _sa7QE::P64 = P64[R1 + 15];
           _sa7QF::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa7QF::P64;
           P64[Sp + 32] = _sa7QE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9Fu; else goto ca9EG;
       ua9Fu: // global
           call _ca9EE(R1) args: 0, res: 0, upd: 0;
       ca9EG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9EE() //  [R1]
         { info_tbl: [(ca9EE,
                       label: block_ca9EE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9EE: // global
           if (R1 & 7 == 3) goto ca9EZ; else goto ca9EM;
       ca9EZ: // global
           I64[Sp] = block_ca9ES_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto ua9Fv; else goto ca9ET;
       ua9Fv: // global
           call _ca9ES(R1) args: 0, res: 0, upd: 0;
       ca9ET: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca9EM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9EP; else goto ca9EO;
       ca9EP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9EO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9ES() //  [R1]
         { info_tbl: [(ca9ES,
                       label: block_ca9ES_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ES: // global
           I64[Sp] = block_ca9EX_info;
           _sa7QN::I64 = I64[R1 + 39];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sa7QN::I64;
           if (R1 & 7 != 0) goto ua9Fw; else goto ca9F1;
       ua9Fw: // global
           call _ca9EX(R1) args: 0, res: 0, upd: 0;
       ca9F1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9EX() //  [R1]
         { info_tbl: [(ca9EX,
                       label: block_ca9EX_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9EX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9F7; else goto ca9F6;
       ca9F7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9F6: // global
           _sa7QF::P64 = P64[Sp + 8];
           if (I64[Sp + 40] == I64[R1 + 39]) goto ca9Fi; else goto ca9Fd;
       ca9Fi: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_ca9Ff_info;
           R3 = _sa7QF::P64;
           R2 = R1;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       ca9Fd: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sa7QF::P64;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9Ff() //  [R1]
         { info_tbl: [(ca9Ff,
                       label: block_ca9Ff_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ff: // global
           I64[Sp] = block_ca9Fh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9Fx; else goto ca9Fk;
       ua9Fx: // global
           call _ca9Fh(R1) args: 0, res: 0, upd: 0;
       ca9Fk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Fh() //  [R1]
         { info_tbl: [(ca9Fh,
                       label: block_ca9Fh_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Fh: // global
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 8;
           call _ca9Et() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.972863576 UTC

[section ""data" . GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure" {
     GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure:
         const GHC.Types.I#_con_info;
         const 2048;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.973678406 UTC

[section ""data" . GHC.IO.Handle.Internals.initBufferState_closure" {
     GHC.IO.Handle.Internals.initBufferState_closure:
         const GHC.IO.Handle.Internals.initBufferState_info;
 },
 GHC.IO.Handle.Internals.initBufferState_entry() //  [R2]
         { info_tbl: [(ca9FK,
                       label: GHC.IO.Handle.Internals.initBufferState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9FK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca9FL; else goto ca9FM;
       ca9FL: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.initBufferState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9FM: // global
           I64[Sp - 8] = block_ca9FD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9FT; else goto ca9FE;
       ua9FT: // global
           call _ca9FD(R1) args: 0, res: 0, upd: 0;
       ca9FE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9FD() //  [R1]
         { info_tbl: [(ca9FD,
                       label: block_ca9FD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9FD: // global
           if (R1 & 7 == 3) goto ca9FI; else goto ca9FH;
       ca9FI: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca9FH: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.974964853 UTC

[section ""data" . lvl3_ra7Pj_closure" {
     lvl3_ra7Pj_closure:
         const lvl3_ra7Pj_info;
 },
 lvl3_ra7Pj_entry() //  []
         { info_tbl: [(ca9G7,
                       label: lvl3_ra7Pj_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9G7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9Ga; else goto ca9Gb;
       ca9Ga: // global
           R1 = lvl3_ra7Pj_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9Gb: // global
           I64[Sp - 8] = block_ca9FY_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9FY() //  []
         { info_tbl: [(ca9FY,
                       label: block_ca9FY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9FY: // global
           I64[Sp] = block_ca9G0_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9G0() //  [R1]
         { info_tbl: [(ca9G0,
                       label: block_ca9G0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9G0: // global
           I64[Sp - 8] = block_ca9G2_info;
           _sa7Ra::P64 = R1;
           R1 = 4;
           P64[Sp] = _sa7Ra::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9G2() //  [R1]
         { info_tbl: [(ca9G2,
                       label: block_ca9G2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9G2: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca9Gg; else goto ca9Gf;
       ca9Gg: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Gf: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.976485169 UTC

[section ""data" . GHC.IO.Handle.Internals.noCharBuffer_closure" {
     GHC.IO.Handle.Internals.noCharBuffer_closure:
         const GHC.IO.Handle.Internals.noCharBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noCharBuffer_entry() //  [R1]
         { info_tbl: [(ca9Gp,
                       label: GHC.IO.Handle.Internals.noCharBuffer_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Gp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9Gq; else goto ca9Gr;
       ca9Gq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Gr: // global
           (_ca9Gk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9Gk::I64 == 0) goto ca9Gm; else goto ca9Gl;
       ca9Gm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9Gl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9Gk::I64;
           I64[Sp - 24] = block_ca9Gn_info;
           Sp = Sp - 24;
           call lvl3_ra7Pj_entry() args: 8, res: 8, upd: 24;
     }
 },
 _ca9Gn() //  [R1]
         { info_tbl: [(ca9Gn,
                       label: block_ca9Gn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Gn: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.977796977 UTC

[section ""data" . lvl4_ra7Pk_closure" {
     lvl4_ra7Pk_closure:
         const lvl4_ra7Pk_info;
 },
 lvl4_ra7Pk_entry() //  []
         { info_tbl: [(ca9GG,
                       label: lvl4_ra7Pk_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9GG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9GJ; else goto ca9GK;
       ca9GJ: // global
           R1 = lvl4_ra7Pk_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ca9GK: // global
           I64[Sp - 8] = block_ca9Gx_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9Gx() //  []
         { info_tbl: [(ca9Gx,
                       label: block_ca9Gx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Gx: // global
           I64[Sp] = block_ca9Gz_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Gz() //  [R1]
         { info_tbl: [(ca9Gz,
                       label: block_ca9Gz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Gz: // global
           I64[Sp - 8] = block_ca9GB_info;
           _sa7Ro::P64 = R1;
           R1 = 1;
           P64[Sp] = _sa7Ro::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9GB() //  [R1]
         { info_tbl: [(ca9GB,
                       label: block_ca9GB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9GB: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca9GP; else goto ca9GO;
       ca9GP: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9GO: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.979291147 UTC

[section ""data" . GHC.IO.Handle.Internals.noByteBuffer_closure" {
     GHC.IO.Handle.Internals.noByteBuffer_closure:
         const GHC.IO.Handle.Internals.noByteBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noByteBuffer_entry() //  [R1]
         { info_tbl: [(ca9GY,
                       label: GHC.IO.Handle.Internals.noByteBuffer_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9GY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9GZ; else goto ca9H0;
       ca9GZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9H0: // global
           (_ca9GT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9GT::I64 == 0) goto ca9GV; else goto ca9GU;
       ca9GV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9GU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9GT::I64;
           I64[Sp - 24] = block_ca9GW_info;
           Sp = Sp - 24;
           call lvl4_ra7Pk_entry() args: 8, res: 8, upd: 24;
     }
 },
 _ca9GW() //  [R1]
         { info_tbl: [(ca9GW,
                       label: block_ca9GW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9GW: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.980292968 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule4_bytes" {
     GHC.IO.Handle.Internals.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.980869275 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule3_closure" {
     GHC.IO.Handle.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.981734203 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule2_bytes" {
     GHC.IO.Handle.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.982305991 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule1_closure" {
     GHC.IO.Handle.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.982852877 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule_closure" {
     GHC.IO.Handle.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Internals.$trModule3_closure+1;
         const GHC.IO.Handle.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.983416725 UTC

[section ""cstring" . lvl5_ra7Pl_bytes" {
     lvl5_ra7Pl_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,102,105,110,97,108,105,122,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.984106944 UTC

[section ""data" . lvl6_ra7Pm_closure" {
     lvl6_ra7Pm_closure:
         const lvl6_ra7Pm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra7Pm_entry() //  [R1]
         { info_tbl: [(ca9H8,
                       label: lvl6_ra7Pm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9H8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9H9; else goto ca9Ha;
       ca9H9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Ha: // global
           (_ca9H5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9H5::I64 == 0) goto ca9H7; else goto ca9H6;
       ca9H7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9H6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9H5::I64;
           R2 = lvl5_ra7Pl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.985127271 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_finalizedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_finalizedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_finalizedHandle_entry() //  [R2]
         { info_tbl: [(ca9Hh,
                       label: GHC.IO.Handle.Internals.ioe_finalizedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Hh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ca9Hl; else goto ca9Hk;
       ca9Hl: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9Hk: // global
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = lvl6_ra7Pm_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.986967253 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs1_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs1_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs1_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs1_entry() //  [R2]
         { info_tbl: [(ca9Ht,
                       label: GHC.IO.Handle.Internals.closeTextCodecs1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9Hu; else goto ca9Hv;
       ca9Hu: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.closeTextCodecs1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9Hv: // global
           I64[Sp - 8] = block_ca9Hq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9IA; else goto ca9Hr;
       ua9IA: // global
           call _ca9Hq(R1) args: 0, res: 0, upd: 0;
       ca9Hr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Hq() //  [R1]
         { info_tbl: [(ca9Hq,
                       label: block_ca9Hq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Hq: // global
           I64[Sp - 8] = block_ca9Hy_info;
           _sa7RO::P64 = P64[R1 + 87];
           R1 = P64[R1 + 95];
           P64[Sp] = _sa7RO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9Iz; else goto ca9HA;
       ua9Iz: // global
           call _ca9Hy(R1) args: 0, res: 0, upd: 0;
       ca9HA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Hy() //  [R1]
         { info_tbl: [(ca9Hy,
                       label: block_ca9Hy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Hy: // global
           if (R1 & 7 == 1) goto ca9HH; else goto ca9I3;
       ca9HH: // global
           _sa7RO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9HE_info;
           R1 = _sa7RO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua9IB; else goto ca9HI;
       ua9IB: // global
           call _ca9HE(R1) args: 0, res: 0, upd: 0;
       ca9HI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca9I3: // global
           I64[Sp] = block_ca9I1_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua9IC; else goto ca9I4;
       ua9IC: // global
           call _ca9I1(R1) args: 0, res: 0, upd: 0;
       ca9I4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9HE() //  [R1]
         { info_tbl: [(ca9HE,
                       label: block_ca9HE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9HE: // global
           if (R1 & 7 == 1) goto ua9Iy; else goto ca9HT;
       ua9Iy: // global
           Sp = Sp + 8;
           call _ca9Ij() args: 0, res: 0, upd: 0;
       ca9HT: // global
           I64[Sp] = block_ca9HR_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua9ID; else goto ca9HU;
       ua9ID: // global
           call _ca9HR(R1) args: 0, res: 0, upd: 0;
       ca9HU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9HR() //  [R1]
         { info_tbl: [(ca9HR,
                       label: block_ca9HR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9HR: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9I1() //  [R1]
         { info_tbl: [(ca9I1,
                       label: block_ca9I1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9I1: // global
           I64[Sp] = block_ca9I8_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9I8() //  []
         { info_tbl: [(ca9I8,
                       label: block_ca9I8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9I8: // global
           _sa7RO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9Ia_info;
           R1 = _sa7RO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ua9IF; else goto ca9Id;
       ua9IF: // global
           call _ca9Ia(R1) args: 0, res: 0, upd: 0;
       ca9Id: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Ia() //  [R1]
         { info_tbl: [(ca9Ia,
                       label: block_ca9Ia_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ia: // global
           if (R1 & 7 == 1) goto ua9Ix; else goto ca9Io;
       ua9Ix: // global
           Sp = Sp + 8;
           call _ca9Ij() args: 0, res: 0, upd: 0;
       ca9Io: // global
           I64[Sp] = block_ca9Im_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua9IG; else goto ca9Ip;
       ua9IG: // global
           call _ca9Im(R1) args: 0, res: 0, upd: 0;
       ca9Ip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Ij() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ij: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9Im() //  [R1]
         { info_tbl: [(ca9Im,
                       label: block_ca9Im_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Im: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.989416142 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs_entry() //  [R2]
         { info_tbl: [(ca9IM,
                       label: GHC.IO.Handle.Internals.closeTextCodecs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9IM: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.closeTextCodecs1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.991428965 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding1_closure" {
     GHC.IO.Handle.Internals.openTextEncoding1_closure:
         const GHC.IO.Handle.Internals.openTextEncoding1_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding1_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9J0,
                       label: GHC.IO.Handle.Internals.openTextEncoding1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9J0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca9J1; else goto ca9J2;
       ca9J1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.openTextEncoding1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9J2: // global
           I64[Sp - 24] = block_ca9IT_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9Ky; else goto ca9IU;
       ua9Ky: // global
           call _ca9IT(R1) args: 0, res: 0, upd: 0;
       ca9IU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9IT() //  [R1]
         { info_tbl: [(ca9IT,
                       label: block_ca9IT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9IT: // global
           if (R1 & 7 == 1) goto ca9IX; else goto ca9IY;
       ca9IX: // global
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9IY: // global
           I64[Sp] = block_ca9J8_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua9Kx; else goto ca9Ja;
       ua9Kx: // global
           call _ca9J8(R1) args: 0, res: 0, upd: 0;
       ca9Ja: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9J8() //  [R1]
         { info_tbl: [(ca9J8,
                       label: block_ca9J8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9J8: // global
           I64[Sp - 16] = block_ca9Jg_info;
           _sa7St::P64 = P64[R1 + 15];
           _sa7Su::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _sa7Su::P64;
           P64[Sp] = _sa7St::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua9Kz; else goto ca9JY;
       ua9Kz: // global
           call _ca9Jg(R1) args: 0, res: 0, upd: 0;
       ca9JY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Jg() //  [R1]
         { info_tbl: [(ca9Jg,
                       label: block_ca9Jg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Jg: // global
           _sa7St::P64 = P64[Sp + 16];
           _ca9Kn::P64 = R1 & 7;
           if (_ca9Kn::P64 != 3) goto ua9Kr; else goto ca9K9;
       ua9Kr: // global
           if (_ca9Kn::P64 != 6) goto ca9K4; else goto ca9Ki;
       ca9K4: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
       ca9Ki: // global
           I64[Sp] = block_ca9Kg_info;
           R1 = _sa7St::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ca9K9: // global
           I64[Sp] = block_ca9K7_info;
           R1 = _sa7St::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Kg() //  [R1]
         { info_tbl: [(ca9Kg,
                       label: block_ca9Kg_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Kg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9Km; else goto ca9Kl;
       ca9Km: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Kl: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
     }
 },
 _ca9K7() //  [R1]
         { info_tbl: [(ca9K7,
                       label: block_ca9K7_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9K7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9Kd; else goto ca9Kc;
       ca9Kd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Kc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
     }
 },
 _sa7Sv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa7Sv: // global
           I64[Sp - 8] = block_ca9Jl_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9KD; else goto ca9Jn;
       ua9KD: // global
           call _ca9Jl(R1) args: 0, res: 0, upd: 0;
       ca9Jn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Jl() //  [R1]
         { info_tbl: [(ca9Jl,
                       label: block_ca9Jl_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Jl: // global
           _sa7Su::P64 = P64[Sp + 8];
           _ca9Kq::P64 = R1 & 7;
           if (_ca9Kq::P64 < 5) goto ua9Ks; else goto ua9Kt;
       ua9Ks: // global
           if (_ca9Kq::P64 < 4) goto ca9Jt; else goto ca9JA;
       ca9Jt: // global
           R3 = P64[Sp + 16];
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9JA: // global
           I64[Sp + 8] = block_ca9Jw_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ua9Kt: // global
           if (_ca9Kq::P64 < 6) goto ca9JK; else goto ca9JU;
       ca9JK: // global
           I64[Sp + 8] = block_ca9JG_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ca9JU: // global
           I64[Sp + 8] = block_ca9JQ_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Jw() //  [R1]
         { info_tbl: [(ca9Jw,
                       label: block_ca9Jw_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Jw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9JD; else goto ca9JC;
       ca9JD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9JC: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9JG() //  [R1]
         { info_tbl: [(ca9JG,
                       label: block_ca9JG_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9JG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9JN; else goto ca9JM;
       ca9JN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9JM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9JQ() //  [R1]
         { info_tbl: [(ca9JQ,
                       label: block_ca9JQ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9JQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9JX; else goto ca9JW;
       ca9JX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9JW: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.995077112 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding_closure" {
     GHC.IO.Handle.Internals.openTextEncoding_closure:
         const GHC.IO.Handle.Internals.openTextEncoding_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding_entry() //  [R2, R3, R4]
         { info_tbl: [(ca9KI,
                       label: GHC.IO.Handle.Internals.openTextEncoding_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9KI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.openTextEncoding1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.996314368 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry() //  [R2]
         { info_tbl: [(ca9KS,
                       label: GHC.IO.Handle.Internals.flushByteWriteBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9KS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca9KW; else goto ca9KX;
       ca9KW: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9KX: // global
           I64[Sp - 8] = block_ca9KP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9Lh; else goto ca9KQ;
       ua9Lh: // global
           call _ca9KP(R1) args: 0, res: 0, upd: 0;
       ca9KQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9KP() //  [R1]
         { info_tbl: [(ca9KP,
                       label: block_ca9KP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9KP: // global
           I64[Sp - 24] = block_ca9KV_info;
           _sa7SY::P64 = P64[R1 + 15];
           _sa7T0::P64 = P64[R1 + 31];
           _sa7T2::P64 = P64[R1 + 47];
           R1 = P64[_sa7T2::P64 + 8];
           P64[Sp - 16] = _sa7T0::P64;
           P64[Sp - 8] = _sa7T2::P64;
           P64[Sp] = _sa7SY::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9Lg; else goto ca9KZ;
       ua9Lg: // global
           call _ca9KV(R1) args: 0, res: 0, upd: 0;
       ca9KZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9KV() //  [R1]
         { info_tbl: [(ca9KV,
                       label: block_ca9KV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9KV: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ca9Lc; else goto ca9L9;
       ca9Lc: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca9L9: // global
           _sa7T0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9L7_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7T0::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca9L7() //  [R1]
         { info_tbl: [(ca9L7,
                       label: block_ca9L7_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9L7: // global
           _sa7T2::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7T2::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7T2::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.997897244 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer_entry() //  [R2]
         { info_tbl: [(ca9Lm,
                       label: GHC.IO.Handle.Internals.flushByteWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Lm: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:06.999313998 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer1_entry() //  [R2]
         { info_tbl: [(ca9Lw,
                       label: GHC.IO.Handle.Internals.flushWriteBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Lw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca9LA; else goto ca9LB;
       ca9LA: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca9LB: // global
           I64[Sp - 8] = block_ca9Lt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9Mg; else goto ca9Lu;
       ua9Mg: // global
           call _ca9Lt(R1) args: 0, res: 0, upd: 0;
       ca9Lu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Lt() //  [R1]
         { info_tbl: [(ca9Lt,
                       label: block_ca9Lt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Lt: // global
           I64[Sp - 24] = block_ca9Lz_info;
           _sa7Tw::P64 = P64[R1 + 15];
           _sa7Ty::P64 = P64[R1 + 31];
           _sa7TA::P64 = P64[R1 + 47];
           R1 = P64[_sa7TA::P64 + 8];
           P64[Sp - 16] = _sa7Ty::P64;
           P64[Sp - 8] = _sa7TA::P64;
           P64[Sp] = _sa7Tw::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9Mf; else goto ca9LD;
       ua9Mf: // global
           call _ca9Lz(R1) args: 0, res: 0, upd: 0;
       ca9LD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Lz() //  [R1]
         { info_tbl: [(ca9Lz,
                       label: block_ca9Lz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Lz: // global
           I64[Sp] = block_ca9LH_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ua9Mh; else goto ca9LJ;
       ua9Mh: // global
           call _ca9LH(R1) args: 0, res: 0, upd: 0;
       ca9LJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9LH() //  [R1]
         { info_tbl: [(ca9LH,
                       label: block_ca9LH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9LH: // global
           if (R1 & 7 == 1) goto ua9Md; else goto ca9LU;
       ua9Md: // global
           Sp = Sp + 32;
           call _ca9M8() args: 0, res: 0, upd: 0;
       ca9LU: // global
           _sa7TY::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_ca9LS_info;
           R1 = _sa7TY::P64;
           if (R1 & 7 != 0) goto ua9Mi; else goto ca9LV;
       ua9Mi: // global
           call _ca9LS(R1) args: 0, res: 0, upd: 0;
       ca9LV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9LS() //  [R1]
         { info_tbl: [(ca9LS,
                       label: block_ca9LS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9LS: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ua9Me; else goto ca9M5;
       ua9Me: // global
           Sp = Sp + 32;
           call _ca9M8() args: 0, res: 0, upd: 0;
       ca9M5: // global
           _sa7Ty::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9M3_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7Ty::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca9M8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9M8: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9M3() //  [R1]
         { info_tbl: [(ca9M3,
                       label: block_ca9M3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9M3: // global
           _sa7TA::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7TA::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7TA::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.001407265 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer_entry() //  [R2]
         { info_tbl: [(ca9Mp,
                       label: GHC.IO.Handle.Internals.flushWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Mp: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.002061684 UTC

[section ""cstring" . lvl7_ra7Pn_bytes" {
     lvl7_ra7Pn_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.002802339 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf2_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf2_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf2_entry() //  [R1]
         { info_tbl: [(ca9MA,
                       label: GHC.IO.Handle.Internals.decodeByteBuf2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9MA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9MB; else goto ca9MC;
       ca9MB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9MC: // global
           (_ca9Mv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca9Mv::I64 == 0) goto ca9Mx; else goto ca9Mw;
       ca9Mx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca9Mw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca9Mv::I64;
           I64[Sp - 24] = block_ca9My_info;
           R2 = lvl7_ra7Pn_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca9My() //  [R1]
         { info_tbl: [(ca9My,
                       label: block_ca9My_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9My: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.004875774 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf1_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf1_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf1_entry() //  [R2, R3]
         { info_tbl: [(ca9MN,
                       label: GHC.IO.Handle.Internals.decodeByteBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9MN: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ca9MO; else goto ca9MP;
       ca9MO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.decodeByteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9MP: // global
           I64[Sp - 16] = block_ca9MK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua9NQ; else goto ca9ML;
       ua9NQ: // global
           call _ca9MK(R1) args: 0, res: 0, upd: 0;
       ca9ML: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9MK() //  [R1]
         { info_tbl: [(ca9MK,
                       label: block_ca9MK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9MK: // global
           I64[Sp - 24] = block_ca9MS_info;
           _sa7Ul::P64 = P64[R1 + 47];
           _sa7Un::P64 = P64[R1 + 63];
           R1 = P64[R1 + 95];
           P64[Sp - 16] = _sa7Un::P64;
           P64[Sp - 8] = P64[_sa7Ul::P64 + 8];
           P64[Sp] = _sa7Ul::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9NP; else goto ca9MU;
       ua9NP: // global
           call _ca9MS(R1) args: 0, res: 0, upd: 0;
       ca9MU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9MS() //  [R1]
         { info_tbl: [(ca9MS,
                       label: block_ca9MS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9MS: // global
           if (R1 & 7 == 1) goto ca9N6; else goto ca9Nx;
       ca9N6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9N9; else goto ca9N8;
       ca9N9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9N8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sa7Uy::P64 = P64[Sp + 16];
           P64[Hp] = _sa7Uy::P64;
           _sa7Ud::P64 = P64[Sp + 32];
           _sa7Un::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Un::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Un::P64);
           I64[Sp + 16] = block_ca9N2_info;
           R3 = _sa7Ud::P64;
           R2 = _sa7Uy::P64;
           Sp = Sp + 16;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ca9Nx: // global
           I64[Sp] = block_ca9Ni_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua9NR; else goto ca9Nj;
       ua9NR: // global
           call _ca9Ni(R1) args: 0, res: 0, upd: 0;
       ca9Nj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9N2() //  [R1]
         { info_tbl: [(ca9N2,
                       label: block_ca9N2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9N2: // global
           I64[Sp] = block_ca9N4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9NS; else goto ca9Nb;
       ua9NS: // global
           call _ca9N4(R1) args: 0, res: 0, upd: 0;
       ca9Nb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9N4() //  [R1]
         { info_tbl: [(ca9N4,
                       label: block_ca9N4_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9N4: // global
           _sa7Ul::P64 = P64[Sp + 8];
           _sa7UH::P64 = P64[R1 + 15];
           _sa7UI::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sa7Ul::P64 + 8] = _sa7UH::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Ul::P64);
           R1 = _sa7UI::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9Ni() //  [R1]
         { info_tbl: [(ca9Ni,
                       label: block_ca9Ni_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ni: // global
           I64[Sp - 16] = block_ca9Nn_info;
           _sa7UM::P64 = P64[R1 + 7];
           _sa7UN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sa7UN::P64;
           P64[Sp] = _sa7UM::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Nn() //  [R1]
         { info_tbl: [(ca9Nn,
                       label: block_ca9Nn_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Nn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9NB; else goto ca9NA;
       ca9NB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9NA: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa7Uy::P64 = P64[Sp + 32];
           P64[Hp] = _sa7Uy::P64;
           _sa7Ud::P64 = P64[Sp + 48];
           _sa7Un::P64 = P64[Sp + 24];
           _sa7UM::P64 = P64[Sp + 16];
           _sa7UN::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Un::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Un::P64);
           I64[Sp + 32] = block_ca9Nt_info;
           R5 = _sa7Ud::P64;
           R4 = _sa7Uy::P64;
           R3 = _sa7UN::P64;
           R2 = _sa7UM::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Nt() //  [R1]
         { info_tbl: [(ca9Nt,
                       label: block_ca9Nt_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Nt: // global
           I64[Sp] = block_ca9Nv_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9NT; else goto ca9ND;
       ua9NT: // global
           call _ca9Nv(R1) args: 0, res: 0, upd: 0;
       ca9ND: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Nv() //  [R1]
         { info_tbl: [(ca9Nv,
                       label: block_ca9Nv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Nv: // global
           _sa7Ul::P64 = P64[Sp + 8];
           _sa7V0::P64 = P64[R1 + 7];
           _sa7V1::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa7Ul::P64 + 8] = _sa7V0::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Ul::P64);
           R1 = _sa7V1::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.008092988 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf_entry() //  [R2, R3]
         { info_tbl: [(ca9NY,
                       label: GHC.IO.Handle.Internals.decodeByteBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9NY: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.009542544 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(ca9O8,
                       label: GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9O8: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ca9Oc; else goto ca9Od;
       ca9Oc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9Od: // global
           I64[Sp - 16] = block_ca9O5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua9OR; else goto ca9O6;
       ua9OR: // global
           call _ca9O5(R1) args: 0, res: 0, upd: 0;
       ca9O6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9O5() //  [R1]
         { info_tbl: [(ca9O5,
                       label: block_ca9O5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9O5: // global
           I64[Sp - 32] = block_ca9Ob_info;
           _sa7V6::P64 = R1;
           _sa7V8::P64 = P64[R1 + 15];
           _sa7Va::P64 = P64[R1 + 31];
           _sa7Vc::P64 = P64[R1 + 47];
           R1 = P64[_sa7Vc::P64 + 8];
           P64[Sp - 24] = _sa7V8::P64;
           P64[Sp - 16] = _sa7Va::P64;
           P64[Sp - 8] = _sa7Vc::P64;
           P64[Sp] = _sa7V6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua9OQ; else goto ca9Of;
       ua9OQ: // global
           call _ca9Ob(R1) args: 0, res: 0, upd: 0;
       ca9Of: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Ob() //  [R1]
         { info_tbl: [(ca9Ob,
                       label: block_ca9Ob_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ob: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ca9Ot; else goto ca9On;
       ca9Ot: // global
           _sa7Va::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca9Oq_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa7Va::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
       ca9On: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _ca9Oq() //  [R1]
         { info_tbl: [(ca9Oq,
                       label: block_ca9Oq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Oq: // global
           I64[Sp] = block_ca9Os_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ua9OS; else goto ca9Ov;
       ua9OS: // global
           call _ca9Os(R1) args: 0, res: 0, upd: 0;
       ca9Ov: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Os() //  [R1]
         { info_tbl: [(ca9Os,
                       label: block_ca9Os_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Os: // global
           I64[Sp - 8] = block_ca9Oz_info;
           _sa7VD::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa7VD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9OT; else goto ca9OB;
       ua9OT: // global
           call _ca9Oz(R1) args: 0, res: 0, upd: 0;
       ca9OB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Oz() //  [R1]
         { info_tbl: [(ca9Oz,
                       label: block_ca9Oz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Oz: // global
           if (R1 & 7 == 1) goto ca9OH; else goto ca9OL;
       ca9OH: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca9OL: // global
           _sa7V4::P64 = P64[Sp + 32];
           _sa7V6::P64 = P64[Sp + 24];
           _sa7Vc::P64 = P64[Sp + 16];
           _sa7VD::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Vc::P64 + 8] = _sa7VD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Vc::P64);
           R3 = _sa7V4::P64;
           R2 = _sa7V6::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.011753143 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking_entry() //  [R2,
                                                                R3]
         { info_tbl: [(ca9OY,
                       label: GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9OY: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.015668001 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle2_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle2_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle2_info;
         const 0;
 },
 sat_sa7WE_entry() //  [R1]
         { info_tbl: [(ca9PS,
                       label: sat_sa7WE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9PS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9PW; else goto ca9PX;
       ca9PW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9PX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9PP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9Q1; else goto ca9PQ;
       ua9Q1: // global
           call _ca9PP(R1) args: 0, res: 0, upd: 0;
       ca9PQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9PP() //  [R1]
         { info_tbl: [(ca9PP,
                       label: block_ca9PP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9PP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9Q0; else goto ca9PZ;
       ca9Q0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9PZ: // global
           _sa7Wz::P64 = P64[R1 + 7];
           _sa7Wy::I64 = I64[R1 + 23];
           _sa7WB::I64 = I64[R1 + 31];
           _sa7WC::I64 = I64[R1 + 39];
           _sa7WD::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Wz::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Wy::I64;
           I64[Hp - 16] = _sa7WB::I64;
           I64[Hp - 8] = _sa7WC::I64;
           I64[Hp] = _sa7WD::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7WQ_entry() //  [R1]
         { info_tbl: [(ca9Qc,
                       label: sat_sa7WQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Qc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9Qg; else goto ca9Qh;
       ca9Qg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Qh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9Q9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9Ql; else goto ca9Qa;
       ua9Ql: // global
           call _ca9Q9(R1) args: 0, res: 0, upd: 0;
       ca9Qa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9Q9() //  [R1]
         { info_tbl: [(ca9Q9,
                       label: block_ca9Q9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Q9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9Qk; else goto ca9Qj;
       ca9Qk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9Qj: // global
           _sa7WL::P64 = P64[R1 + 7];
           _sa7WK::I64 = I64[R1 + 23];
           _sa7WN::I64 = I64[R1 + 31];
           _sa7WO::I64 = I64[R1 + 39];
           _sa7WP::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7WL::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7WK::I64;
           I64[Hp - 16] = _sa7WN::I64;
           I64[Hp - 8] = _sa7WO::I64;
           I64[Hp] = _sa7WP::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7X2_entry() //  [R1]
         { info_tbl: [(ca9Qu,
                       label: sat_sa7X2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Qu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9Qy; else goto ca9Qz;
       ca9Qy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Qz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9Qr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9QD; else goto ca9Qs;
       ua9QD: // global
           call _ca9Qr(R1) args: 0, res: 0, upd: 0;
       ca9Qs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9Qr() //  [R1]
         { info_tbl: [(ca9Qr,
                       label: block_ca9Qr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Qr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9QC; else goto ca9QB;
       ca9QC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9QB: // global
           _sa7WX::P64 = P64[R1 + 7];
           _sa7WW::I64 = I64[R1 + 23];
           _sa7WZ::I64 = I64[R1 + 31];
           _sa7X0::I64 = I64[R1 + 39];
           _sa7X1::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7WX::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7WW::I64;
           I64[Hp - 16] = _sa7WZ::I64;
           I64[Hp - 8] = _sa7X0::I64;
           I64[Hp] = _sa7X1::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Xe_entry() //  [R1]
         { info_tbl: [(ca9QO,
                       label: sat_sa7Xe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9QO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9QS; else goto ca9QT;
       ca9QS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9QT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9QL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9QX; else goto ca9QM;
       ua9QX: // global
           call _ca9QL(R1) args: 0, res: 0, upd: 0;
       ca9QM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9QL() //  [R1]
         { info_tbl: [(ca9QL,
                       label: block_ca9QL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9QL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9QW; else goto ca9QV;
       ca9QW: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9QV: // global
           _sa7X9::P64 = P64[R1 + 7];
           _sa7X8::I64 = I64[R1 + 23];
           _sa7Xb::I64 = I64[R1 + 31];
           _sa7Xc::I64 = I64[R1 + 39];
           _sa7Xd::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7X9::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7X8::I64;
           I64[Hp - 16] = _sa7Xb::I64;
           I64[Hp - 8] = _sa7Xc::I64;
           I64[Hp] = _sa7Xd::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Xq_entry() //  [R1]
         { info_tbl: [(ca9R6,
                       label: sat_sa7Xq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9R6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9Ra; else goto ca9Rb;
       ca9Ra: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Rb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9R3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9Rf; else goto ca9R4;
       ua9Rf: // global
           call _ca9R3(R1) args: 0, res: 0, upd: 0;
       ca9R4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9R3() //  [R1]
         { info_tbl: [(ca9R3,
                       label: block_ca9R3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9R3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9Re; else goto ca9Rd;
       ca9Re: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9Rd: // global
           _sa7Xl::P64 = P64[R1 + 7];
           _sa7Xk::I64 = I64[R1 + 23];
           _sa7Xn::I64 = I64[R1 + 31];
           _sa7Xo::I64 = I64[R1 + 39];
           _sa7Xp::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Xl::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Xk::I64;
           I64[Hp - 16] = _sa7Xn::I64;
           I64[Hp - 8] = _sa7Xo::I64;
           I64[Hp] = _sa7Xp::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7XC_entry() //  [R1]
         { info_tbl: [(ca9Rq,
                       label: sat_sa7XC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Rq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9Ru; else goto ca9Rv;
       ca9Ru: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Rv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9Rn_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9Rz; else goto ca9Ro;
       ua9Rz: // global
           call _ca9Rn(R1) args: 0, res: 0, upd: 0;
       ca9Ro: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9Rn() //  [R1]
         { info_tbl: [(ca9Rn,
                       label: block_ca9Rn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Rn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9Ry; else goto ca9Rx;
       ca9Ry: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9Rx: // global
           _sa7Xx::P64 = P64[R1 + 7];
           _sa7Xw::I64 = I64[R1 + 23];
           _sa7Xz::I64 = I64[R1 + 31];
           _sa7XA::I64 = I64[R1 + 39];
           _sa7XB::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Xx::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Xw::I64;
           I64[Hp - 16] = _sa7Xz::I64;
           I64[Hp - 8] = _sa7XA::I64;
           I64[Hp] = _sa7XB::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle2_entry() //  [R2, R3]
         { info_tbl: [(ca9RA,
                       label: GHC.IO.Handle.Internals.wantReadableHandle2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9RA: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ca9RB; else goto ca9RC;
       ca9RB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9RC: // global
           I64[Sp - 16] = block_ca9P5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua9SA; else goto ca9P6;
       ua9SA: // global
           call _ca9P5(R1) args: 0, res: 0, upd: 0;
       ca9P6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9P5() //  [R1]
         { info_tbl: [(ca9P5,
                       label: block_ca9P5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9P5: // global
           I64[Sp - 40] = block_ca9Pa_info;
           _sa7VL::P64 = R1;
           _sa7VN::P64 = P64[R1 + 15];
           _sa7VP::P64 = P64[R1 + 31];
           _sa7VR::P64 = P64[R1 + 47];
           _sa7VU::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sa7VN::P64;
           P64[Sp - 24] = _sa7VP::P64;
           P64[Sp - 16] = _sa7VR::P64;
           P64[Sp - 8] = _sa7VU::P64;
           P64[Sp] = _sa7VL::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ua9Su; else goto ca9Pb;
       ua9Su: // global
           call _ca9Pa(R1) args: 0, res: 0, upd: 0;
       ca9Pb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Pa() //  [R1]
         { info_tbl: [(ca9Pa,
                       label: block_ca9Pa_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Pa: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto ca9RH;
               case 2 : goto ca9RK;
               case 3 : goto ua9Ss;
               case 4, 5 : goto ca9RT;
               case 6 : goto ca9RV;
           }
       ca9RV: // global
           _sa7W5::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_ca9Pk_info;
           R1 = _sa7W5::P64;
           if (R1 & 7 != 0) goto ua9Sv; else goto ca9Pl;
       ua9Sv: // global
           call _ca9Pk(R1) args: 0, res: 0, upd: 0;
       ca9Pl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ca9RT: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ua9Ss: // global
           Sp = Sp + 40;
           call _ca9S0() args: 0, res: 0, upd: 0;
       ca9RK: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ca9RH: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9Pk() //  [R1]
         { info_tbl: [(ca9Pk,
                       label: block_ca9Pk_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Pk: // global
           I64[Sp - 16] = block_ca9Pp_info;
           _sa7Wb::I64 = I64[R1 + 39];
           _sa7Wc::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa7Wc::I64;
           I64[Sp] = _sa7Wb::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua9Sx; else goto ca9Pq;
       ua9Sx: // global
           call _ca9Pp(R1) args: 0, res: 0, upd: 0;
       ca9Pq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Pp() //  [R1]
         { info_tbl: [(ca9Pp,
                       label: block_ca9Pp_info
                       rep:StackRep [True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Pp: // global
           if (R1 & 7 == 1) goto ua9St; else goto ca9S1;
       ua9St: // global
           Sp = Sp + 56;
           call _ca9S0() args: 0, res: 0, upd: 0;
       ca9S1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca9S4; else goto ca9S3;
       ca9S4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9S3: // global
           _sa7VR::P64 = P64[Sp + 40];
           if (I64[Sp + 16] == I64[Sp + 8]) goto ca9Sg; else goto ca9S6;
       ca9Sg: // global
           _sa7VU::P64 = P64[Sp + 48];
           _sa7Xi::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7Xq_info;
           P64[Hp - 24] = _sa7Xi::P64;
           _sa7VI::P64 = P64[Sp + 64];
           _sa7VL::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7Xu::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7XC_info;
           P64[Hp] = _sa7Xu::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 72;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       ca9S6: // global
           _sa7Wh::P64 = P64[_sa7VR::P64 + 8];
           Hp = Hp - 48;
           I64[Sp + 16] = block_ca9Py_info;
           R1 = _sa7Wh::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ua9Sy; else goto ca9Pz;
       ua9Sy: // global
           call _ca9Py(R1) args: 0, res: 0, upd: 0;
       ca9Pz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Py() //  [R1]
         { info_tbl: [(ca9Py,
                       label: block_ca9Py_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Py: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca9S9; else goto ca9S8;
       ca9S9: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9S8: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ca9Sf; else goto ca9Sb;
       ca9Sf: // global
           _sa7VU::P64 = P64[Sp + 32];
           _sa7WU::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7X2_info;
           P64[Hp - 24] = _sa7WU::P64;
           _sa7VI::P64 = P64[Sp + 48];
           _sa7VL::P64 = P64[Sp + 40];
           _sa7VR::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7X6::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7Xe_info;
           P64[Hp] = _sa7X6::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       ca9Sb: // global
           Hp = Hp - 48;
           _sa7VP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ca9PG_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa7VP::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca9PG() //  [R1]
         { info_tbl: [(ca9PG,
                       label: block_ca9PG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9PG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca9Se; else goto ca9Sd;
       ca9Se: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Sd: // global
           _sa7VI::P64 = P64[Sp + 32];
           _sa7VL::P64 = P64[Sp + 24];
           _sa7VR::P64 = P64[Sp + 8];
           _sa7VU::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           _sa7Ww::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7WE_info;
           P64[Hp - 24] = _sa7Ww::P64;
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7WI::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7WQ_info;
           P64[Hp] = _sa7WI::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ca9S0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9S0: // global
           R2 = P64[Sp];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.02313802 UTC

[section ""data" . lvl8_ra7Po_closure" {
     lvl8_ra7Po_closure:
         const GHC.IO.Handle.Types.BlockBuffering_con_info;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.02895179 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle5_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle5_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle5_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9SC: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 56, res: 0, upd: 8;
     }
 },
 buf_state_sa7XU_entry() //  [R1]
         { info_tbl: [(ca9Ud,
                       label: buf_state_sa7XU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ud: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9Ue; else goto ca9Uf;
       ca9Ue: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Uf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9U6_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9Um; else goto ca9U7;
       ua9Um: // global
           call _ca9U6(R1) args: 0, res: 0, upd: 0;
       ca9U7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9U6() //  [R1]
         { info_tbl: [(ca9U6,
                       label: block_ca9U6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9U6: // global
           if (R1 & 7 == 3) goto ca9Ub; else goto ca9Ua;
       ca9Ub: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ca9Ua: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yk_entry() //  [R1]
         { info_tbl: [(ca9UJ,
                       label: sat_sa7Yk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9UJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9UK; else goto ca9UL;
       ca9UK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9UL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.outputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yj_entry() //  [R1]
         { info_tbl: [(ca9UQ,
                       label: sat_sa7Yj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9UQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9UR; else goto ca9US;
       ca9UR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9US: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.inputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yl_entry() //  [R1]
         { info_tbl: [(ca9UT,
                       label: sat_sa7Yl_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9UT: // global
           if ((Sp + -136) < SpLim) (likely: False) goto ca9UV; else goto ca9UW;
       ca9UV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9UW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_ca9Uy_info;
           _sa7XE::P64 = P64[R1 + 16];
           _sa7XF::P64 = P64[R1 + 24];
           _sa7XG::P64 = P64[R1 + 32];
           _sa7XJ::P64 = P64[R1 + 48];
           _sa7XL::P64 = P64[R1 + 56];
           _sa7XM::P64 = P64[R1 + 64];
           _sa7XO::P64 = P64[R1 + 72];
           _sa7XR::P64 = P64[R1 + 80];
           _sa7XS::P64 = P64[R1 + 88];
           _sa7Y1::P64 = P64[R1 + 96];
           _sa7Y5::P64 = P64[R1 + 104];
           _sa7Y8::P64 = P64[R1 + 112];
           _sa7Y9::P64 = P64[R1 + 120];
           _sa7Yc::P64 = P64[R1 + 128];
           R1 = P64[R1 + 40];
           P64[Sp - 128] = _sa7XE::P64;
           P64[Sp - 120] = _sa7XF::P64;
           P64[Sp - 112] = _sa7XG::P64;
           P64[Sp - 104] = _sa7XJ::P64;
           P64[Sp - 96] = _sa7XL::P64;
           P64[Sp - 88] = _sa7XM::P64;
           P64[Sp - 80] = _sa7XO::P64;
           P64[Sp - 72] = _sa7XR::P64;
           P64[Sp - 64] = _sa7XS::P64;
           P64[Sp - 56] = _sa7Y1::P64;
           P64[Sp - 48] = _sa7Y5::P64;
           P64[Sp - 40] = _sa7Y8::P64;
           P64[Sp - 32] = _sa7Y9::P64;
           P64[Sp - 24] = _sa7Yc::P64;
           Sp = Sp - 136;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9Uy() //  [R1]
         { info_tbl: [(ca9Uy,
                       label: block_ca9Uy_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Uy: // global
           I64[Sp] = block_ca9UA_info;
           _sa7Yg::P64 = R1;
           R1 = P64[Sp + 96];
           P64[Sp + 96] = _sa7Yg::P64;
           if (R1 & 7 != 0) goto ua9V1; else goto ca9UB;
       ua9V1: // global
           call _ca9UA(R1) args: 0, res: 0, upd: 0;
       ca9UB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9UA() //  [R1]
         { info_tbl: [(ca9UA,
                       label: block_ca9UA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9UA: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ca9V0; else goto ca9UZ;
       ca9V0: // global
           HpAlloc = 184;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ca9UZ: // global
           _sa7Yi::P64 = P64[R1 + 7];
           I64[Hp - 176] = sat_sa7Yk_info;
           _sa7XM::P64 = P64[Sp + 48];
           P64[Hp - 160] = _sa7XM::P64;
           I64[Hp - 152] = sat_sa7Yj_info;
           P64[Hp - 136] = _sa7XM::P64;
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = _sa7Yi::P64;
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = Hp - 152;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 127;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yr_entry() //  [R1]
         { info_tbl: [(ca9Vf,
                       label: sat_sa7Yr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Vf: // global
           _sa7Yr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca9Vg; else goto ca9Vh;
       ca9Vh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9Vj; else goto ca9Vi;
       ca9Vj: // global
           HpAlloc = 16;
           goto ca9Vg;
       ca9Vg: // global
           R1 = _sa7Yr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Vi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Yr::P64;
           _sa7XI::P64 = P64[_sa7Yr::P64 + 16];
           _sa7Yf::P64 = P64[_sa7Yr::P64 + 24];
           _sa7Yp::P64 = P64[_sa7Yr::P64 + 32];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _sa7Yf::P64;
           R3 = Hp - 7;
           R2 = _sa7XI::P64;
           R1 = _sa7Yp::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Z1_entry() //  [R1]
         { info_tbl: [(ca9Vt,
                       label: sat_sa7Z1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Vt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca9Vu; else goto ca9Vv;
       ca9Vu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9Vv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca9Vm_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ua9VC; else goto ca9Vn;
       ua9VC: // global
           call _ca9Vm(R1) args: 0, res: 0, upd: 0;
       ca9Vn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ca9Vm() //  [R1]
         { info_tbl: [(ca9Vm,
                       label: block_ca9Vm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Vm: // global
           if (R1 & 7 == 1) goto ca9Vq; else goto ca9Vr;
       ca9Vq: // global
           R1 = lvl8_ra7Po_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ca9Vr: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(ca9VH,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle5_info
                       rep:HeapRep static {
                             Fun {arity: 12
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9VH: // global
           if ((Sp + -96) < SpLim) (likely: False) goto ca9VI; else goto ca9VJ;
       ca9VI: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 96, res: 0, upd: 8;
       ca9VJ: // global
           I64[Sp - 48] = block_ca9Tv_info;
           R1 = P64[Sp + 16];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ua9XT; else goto ca9Tw;
       ua9XT: // global
           call _ca9Tv(R1) args: 0, res: 0, upd: 0;
       ca9Tw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Tv() //  [R1]
         { info_tbl: [(ca9Tv,
                       label: block_ca9Tv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Tv: // global
           if (R1 & 7 == 1) goto ca9VE; else goto ca9VF;
       ca9VE: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _ca9SJ() args: 0, res: 0, upd: 0;
       ca9VF: // global
           I64[Sp] = block_ca9TB_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ua9XL; else goto ca9TC;
       ua9XL: // global
           call _ca9TB(R1) args: 0, res: 0, upd: 0;
       ca9TC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9TB() //  [R1]
         { info_tbl: [(ca9TB,
                       label: block_ca9TB_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9TB: // global
           I64[Sp - 16] = block_ca9WC_info;
           _sa7Z6::P64 = P64[R1 + 15];
           _sa7Z7::P64 = P64[R1 + 23];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _sa7Z7::P64;
           P64[Sp] = _sa7Z6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua9XN; else goto ca9WY;
       ua9XN: // global
           call _ca9WC(R1) args: 0, res: 0, upd: 0;
       ca9WY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9WC() //  [R1]
         { info_tbl: [(ca9WC,
                       label: block_ca9WC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9WC: // global
           _sa7Z6::P64 = P64[Sp + 16];
           _ca9Xn::P64 = R1 & 7;
           if (_ca9Xn::P64 != 3) goto ua9Xv; else goto ca9X9;
       ua9Xv: // global
           if (_ca9Xn::P64 != 6) goto ca9X4; else goto ca9Xi;
       ca9X4: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
       ca9Xi: // global
           I64[Sp] = block_ca9Xg_info;
           R1 = _sa7Z6::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ca9X9: // global
           I64[Sp] = block_ca9X7_info;
           R1 = _sa7Z6::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Xg() //  [R1]
         { info_tbl: [(ca9Xg,
                       label: block_ca9Xg_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Xg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9Xm; else goto ca9Xl;
       ca9Xm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Xl: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
     }
 },
 _ca9X7() //  [R1]
         { info_tbl: [(ca9X7,
                       label: block_ca9X7_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9X7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9Xd; else goto ca9Xc;
       ca9Xd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Xc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
     }
 },
 _sa7Z8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa7Z8: // global
           I64[Sp - 8] = block_ca9TL_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua9XX; else goto ca9TM;
       ua9XX: // global
           call _ca9TL(R1) args: 0, res: 0, upd: 0;
       ca9TM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9TL() //  [R1]
         { info_tbl: [(ca9TL,
                       label: block_ca9TL_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9TL: // global
           _sa7Z7::P64 = P64[Sp + 8];
           _ca9Xq::P64 = R1 & 7;
           if (_ca9Xq::P64 < 5) goto ua9Xt; else goto ua9Xu;
       ua9Xt: // global
           if (_ca9Xq::P64 < 4) goto ca9WI; else goto ca9WK;
       ca9WI: // global
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _ca9SJ() args: 0, res: 0, upd: 0;
       ca9WK: // global
           I64[Sp + 8] = block_ca9TR_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ua9Xu: // global
           if (_ca9Xq::P64 < 6) goto ca9WP; else goto ca9WU;
       ca9WP: // global
           I64[Sp + 8] = block_ca9TW_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ca9WU: // global
           I64[Sp + 8] = block_ca9U1_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9TR() //  [R1]
         { info_tbl: [(ca9TR,
                       label: block_ca9TR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9TR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9WN; else goto ca9WM;
       ca9WN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9WM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _ca9SJ() args: 0, res: 0, upd: 0;
     }
 },
 _ca9TW() //  [R1]
         { info_tbl: [(ca9TW,
                       label: block_ca9TW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9TW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9WS; else goto ca9WR;
       ca9WS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9WR: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _ca9SJ() args: 0, res: 0, upd: 0;
     }
 },
 _ca9U1() //  [R1]
         { info_tbl: [(ca9U1,
                       label: block_ca9U1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9U1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9WX; else goto ca9WW;
       ca9WX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9WW: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _ca9SJ() args: 0, res: 0, upd: 0;
     }
 },
 _ca9SJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9SJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9VM; else goto ca9VL;
       ca9VM: // global
           HpAlloc = 24;
           _sa7XR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9SI_info;
           R2 = P64[Sp];
           R1 = _sa7XR::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ca9VL: // global
           I64[Hp - 16] = buf_state_sa7XU_info;
           P64[Hp] = P64[Sp + 56];
           I64[Sp - 16] = block_ca9SN_info;
           R2 = P64[Sp + 24];
           I64[Sp - 40] = stg_ap_ppv_info;
           P64[Sp - 32] = P64[Sp + 40];
           _ca9SL::P64 = Hp - 16;
           P64[Sp - 24] = _ca9SL::P64;
           P64[Sp - 8] = _ca9SL::P64;
           Sp = Sp - 40;
           call GHC.IO.BufferedIO.newBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca9SI() //  [R1, R2]
         { info_tbl: [(ca9SI,
                       label: block_ca9SI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9SI: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _ca9SJ() args: 0, res: 0, upd: 0;
     }
 },
 _ca9SN() //  [R1]
         { info_tbl: [(ca9SN,
                       label: block_ca9SN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9SN: // global
           I64[Sp - 8] = block_ca9SP_info;
           _sa7XY::P64 = R1;
           R1 = R1;
           P64[Sp] = _sa7XY::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9SP() //  [R1]
         { info_tbl: [(ca9SP,
                       label: block_ca9SP_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9SP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9VQ; else goto ca9VP;
       ca9VQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9VP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_ca9SS_info;
           _sa7Y1::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _sa7Y1::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9SS() //  [R1]
         { info_tbl: [(ca9SS,
                       label: block_ca9SS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9SS: // global
           I64[Sp] = block_ca9SW_info;
           _sa7Y5::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _sa7Y5::P64;
           if (R1 & 7 != 0) goto ua9XI; else goto ca9SX;
       ua9XI: // global
           call _ca9SW(R1) args: 0, res: 0, upd: 0;
       ca9SX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9SW() //  [R1]
         { info_tbl: [(ca9SW,
                       label: block_ca9SW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9SW: // global
           if (R1 & 7 == 1) goto ca9Wh; else goto ca9Wq;
       ca9Wh: // global
           I64[Sp] = block_ca9T1_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       ca9Wq: // global
           I64[Sp] = block_ca9Tf_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9T1() //  [R1]
         { info_tbl: [(ca9T1,
                       label: block_ca9T1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9T1: // global
           I64[Sp - 8] = block_ca9T3_info;
           _sa7Yz::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sa7Yz::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9T3() //  [R1]
         { info_tbl: [(ca9T3,
                       label: block_ca9T3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9T3: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca9Wl; else goto ca9Wk;
       ca9Wl: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Wk: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_ca9Ta_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Ta() //  [R1]
         { info_tbl: [(ca9Ta,
                       label: block_ca9Ta_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ta: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca9Wo; else goto ca9Wn;
       ca9Wo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Wn: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 7;
           P64[Sp] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           call _sa7Y6() args: 0, res: 0, upd: 0;
     }
 },
 _ca9Tf() //  [R1]
         { info_tbl: [(ca9Tf,
                       label: block_ca9Tf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Tf: // global
           I64[Sp - 8] = block_ca9Th_info;
           _sa7YM::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sa7YM::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Th() //  [R1]
         { info_tbl: [(ca9Th,
                       label: block_ca9Th_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Th: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca9Wu; else goto ca9Wt;
       ca9Wu: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Wt: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_ca9To_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9To() //  [R1]
         { info_tbl: [(ca9To,
                       label: block_ca9To_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9To: // global
           I64[Sp] = block_ca9Tq_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 64];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _ca9Tq() //  [R1]
         { info_tbl: [(ca9Tq,
                       label: block_ca9Tq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Tq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9Wy; else goto ca9Wx;
       ca9Wy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Wx: // global
           I64[Hp - 32] = sat_sa7Z1_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = Hp - 32;
           P64[Sp + 16] = Hp - 7;
           call _sa7Y6() args: 0, res: 0, upd: 0;
     }
 },
 _sa7Y6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa7Y6: // global
           I64[Sp - 8] = block_ca9Uq_info;
           R1 = GHC.IO.Handle.Types.BufferListNil_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Uq() //  [R1]
         { info_tbl: [(ca9Uq,
                       label: block_ca9Uq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Uq: // global
           I64[Sp - 8] = block_ca9Us_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _ca9Us() //  [R1]
         { info_tbl: [(ca9Us,
                       label: block_ca9Us_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Us: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ca9VW; else goto ca9VV;
       ca9VW: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9VV: // global
           I64[Hp - 128] = sat_sa7Yl_info;
           P64[Hp - 112] = P64[Sp + 56];
           P64[Hp - 104] = P64[Sp + 64];
           P64[Hp - 96] = P64[Sp + 72];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 112];
           P64[Hp - 64] = P64[Sp + 120];
           P64[Hp - 56] = P64[Sp + 136];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 104];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 80] = block_ca9V2_info;
           R2 = Hp - 128;
           _sa7Yf::P64 = R1;
           R1 = R1;
           P64[Sp + 136] = _sa7Yf::P64;
           Sp = Sp + 80;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9V2() //  []
         { info_tbl: [(ca9V2,
                       label: block_ca9V2_info
                       rep:StackRep [False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9V2: // global
           I64[Sp] = block_ca9V4_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ua9XS; else goto ca9V5;
       ua9XS: // global
           call _ca9V4(R1) args: 0, res: 0, upd: 0;
       ca9V5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9V4() //  [R1]
         { info_tbl: [(ca9V4,
                       label: block_ca9V4_info
                       rep:StackRep [False, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9V4: // global
           _sa7XI::P64 = P64[Sp + 8];
           _sa7Yf::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto ca9W1; else goto ca9W8;
       ca9W1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9W4; else goto ca9W3;
       ca9W4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9W3: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = _sa7XI::P64;
           P64[Hp] = _sa7Yf::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca9W8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ca9Wb; else goto ca9Wa;
       ca9Wb: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Wa: // global
           _sa7Yp::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_sa7Yr_info;
           P64[Hp - 16] = _sa7XI::P64;
           P64[Hp - 8] = _sa7Yf::P64;
           P64[Hp] = _sa7Yp::P64;
           I64[Sp] = block_ca9W5_info;
           R3 = Hp - 32;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _sa7Yf::P64;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9W5() //  [R1]
         { info_tbl: [(ca9W5,
                       label: block_ca9W5_info
                       rep:StackRep [False, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9W5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca9We; else goto ca9Wd;
       ca9We: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca9Wd: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.041025542 UTC

[section ""data" . GHC.IO.Handle.Internals.mkHandle_closure" {
     GHC.IO.Handle.Internals.mkHandle_closure:
         const GHC.IO.Handle.Internals.mkHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9XZ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkHandle_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 56, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkHandle_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca9Y3,
                       label: GHC.IO.Handle.Internals.mkHandle_info
                       rep:HeapRep static {
                             Fun {arity: 12
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Y3: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.042270981 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO1_closure" {
     GHC.IO.Handle.Internals.debugIO1_closure:
         const GHC.IO.Handle.Internals.debugIO1_info;
 },
 GHC.IO.Handle.Internals.debugIO1_entry() //  []
         { info_tbl: [(ca9Ya,
                       label: GHC.IO.Handle.Internals.debugIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ya: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.043070263 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO_closure" {
     GHC.IO.Handle.Internals.debugIO_closure:
         const GHC.IO.Handle.Internals.debugIO_info;
 },
 GHC.IO.Handle.Internals.debugIO_entry() //  [R2]
         { info_tbl: [(ca9Yh,
                       label: GHC.IO.Handle.Internals.debugIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Yh: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.debugIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.047473739 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwriteCharBuffer_closure" {
     GHC.IO.Handle.Internals.$wwriteCharBuffer_closure:
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_info;
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Yl: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(ca9Ys,
                       label: GHC.IO.Handle.Internals.$wwriteCharBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ys: // global
           if ((Sp + -104) < SpLim) (likely: False) goto ca9Yt; else goto uaa1y;
       ca9Yt: // global
           R1 = GHC.IO.Handle.Internals.$wwriteCharBuffer_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       uaa1y: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _ca9Ym() args: 0, res: 0, upd: 0;
     }
 },
 _ca9Ym() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Ym: // global
           _sa7Zz::P64 = P64[Sp];
           I64[Sp] = block_ca9Yp_info;
           R1 = _sa7Zz::P64;
           if (R1 & 7 != 0) goto uaa1O; else goto ca9Yq;
       uaa1O: // global
           call _ca9Yp(R1) args: 0, res: 0, upd: 0;
       ca9Yq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Yp() //  [R1]
         { info_tbl: [(ca9Yp,
                       label: block_ca9Yp_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Yp: // global
           I64[Sp - 48] = block_ca9Yz_info;
           _sa7ZH::P64 = R1;
           _sa7ZJ::P64 = P64[R1 + 15];
           _sa7ZL::P64 = P64[R1 + 31];
           _sa7ZN::P64 = P64[R1 + 47];
           _sa7ZO::P64 = P64[R1 + 55];
           R1 = P64[R1 + 87];
           P64[Sp - 40] = _sa7ZJ::P64;
           P64[Sp - 32] = _sa7ZL::P64;
           P64[Sp - 24] = _sa7ZN::P64;
           P64[Sp - 16] = _sa7ZO::P64;
           P64[Sp - 8] = P64[_sa7ZN::P64 + 8];
           P64[Sp] = _sa7ZH::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uaa1P; else goto caa0D;
       uaa1P: // global
           call _ca9Yz(R1) args: 0, res: 0, upd: 0;
       caa0D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Yz() //  [R1]
         { info_tbl: [(ca9Yz,
                       label: block_ca9Yz_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Yz: // global
           if (R1 & 7 == 1) goto caa0R; else goto caa1j;
       caa0R: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caa0U; else goto caa0T;
       caa0U: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa0T: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_caa0I_info;
           R3 = P64[Sp + 40];
           R2 = Hp - 47;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       caa1j: // global
           I64[Sp] = block_caa14_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaa1R; else goto caa15;
       uaa1R: // global
           call _caa14(R1) args: 0, res: 0, upd: 0;
       caa15: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa0I() //  [R1]
         { info_tbl: [(caa0I,
                       label: block_caa0I_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa0I: // global
           I64[Sp] = block_caa0K_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaa2a; else goto caa0L;
       uaa2a: // global
           call _caa0K(R1) args: 0, res: 0, upd: 0;
       caa0L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa0K() //  [R1]
         { info_tbl: [(caa0K,
                       label: block_caa0K_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa0K: // global
           I64[Sp] = block_caa0P_info;
           _sa80U::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp + 96] = _sa80U::P64;
           if (R1 & 7 != 0) goto uaa2b; else goto caa0X;
       uaa2b: // global
           call _caa0P(R1) args: 0, res: 0, upd: 0;
       caa0X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa0P() //  [R1]
         { info_tbl: [(caa0P,
                       label: block_caa0P_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa0P: // global
           P64[Sp + 96] = P64[Sp + 96];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 72] = P64[R1 + 7];
           P64[Sp + 64] = P64[R1 + 15];
           I64[Sp + 56] = I64[R1 + 31];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 8;
           call _ca9YB() args: 0, res: 0, upd: 0;
     }
 },
 _caa14() //  [R1]
         { info_tbl: [(caa14,
                       label: block_caa14_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa14: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caa1m; else goto caa1l;
       caa1m: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa1l: // global
           _sa815::P64 = P64[R1 + 7];
           _sa816::P64 = P64[R1 + 15];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_caa1a_info;
           R5 = P64[Sp + 40];
           R4 = Hp - 47;
           R3 = _sa816::P64;
           R2 = _sa815::P64;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caa1a() //  [R1]
         { info_tbl: [(caa1a,
                       label: block_caa1a_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa1a: // global
           I64[Sp] = block_caa1c_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaa2d; else goto caa1d;
       uaa2d: // global
           call _caa1c(R1) args: 0, res: 0, upd: 0;
       caa1d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa1c() //  [R1]
         { info_tbl: [(caa1c,
                       label: block_caa1c_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa1c: // global
           I64[Sp] = block_caa1h_info;
           _sa81f::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _sa81f::P64;
           if (R1 & 7 != 0) goto uaa2e; else goto caa1p;
       uaa2e: // global
           call _caa1h(R1) args: 0, res: 0, upd: 0;
       caa1p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa1h() //  [R1]
         { info_tbl: [(caa1h,
                       label: block_caa1h_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa1h: // global
           I64[Sp] = I64[R1 + 47];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp + 56] = I64[R1 + 31];
           P64[Sp + 64] = P64[R1 + 15];
           P64[Sp + 72] = P64[R1 + 7];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 96] = P64[Sp + 96];
           Sp = Sp - 8;
           call _ca9YB() args: 0, res: 0, upd: 0;
     }
 },
 _ca9YB() //  []
         { info_tbl: [(ca9YB,
                       label: block_ca9YB_info
                       rep:StackRep [True, False, False, False, False, True, False, True,
                                     False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9YB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca9YG; else goto ca9YF;
       ca9YG: // global
           HpAlloc = 56;
           I64[Sp] = block_ca9YB_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ca9YF: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 88];
           _sa807::I64 = I64[Sp + 64];
           I64[Hp - 16] = _sa807::I64;
           I64[Hp - 8] = I64[Sp + 48];
           _sa809::I64 = I64[Sp + 8];
           I64[Hp] = _sa809::I64;
           _ca9YH::P64 = Hp - 47;
           if (_sa807::I64 == _sa809::I64) goto uaa1B; else goto ca9Za;
       uaa1B: // global
           P64[Sp + 96] = _ca9YH::P64;
           Sp = Sp + 16;
           call _sa80b() args: 0, res: 0, upd: 0;
       ca9Za: // global
           I64[Sp] = block_ca9Z8_info;
           R1 = P64[Sp + 104];
           P64[Sp + 88] = _ca9YH::P64;
           if (R1 & 7 != 0) goto uaa1S; else goto ca9Zb;
       uaa1S: // global
           call _ca9Z8(R1) args: 0, res: 0, upd: 0;
       ca9Zb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9Z8() //  [R1]
         { info_tbl: [(ca9Z8,
                       label: block_ca9Z8_info
                       rep:StackRep [True, False, False, False, False, True, False, True,
                                     True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Z8: // global
           _sa7ZO::P64 = P64[Sp + 40];
           _sa80r::P64 = P64[R1 + 7];
           _sa80s::P64 = P64[R1 + 15];
           _sa80q::I64 = I64[R1 + 23];
           _sa80t::I64 = I64[R1 + 31];
           _sa80u::I64 = I64[R1 + 39];
           _sa80v::I64 = I64[R1 + 47];
           if (_sa80u::I64 == _sa80v::I64) goto sa80w; else goto caa0A;
       caa0A: // global
           if (_sa80u::I64 != I64[Sp + 96]) goto sa80w; else goto uaa1C;
       sa80w: // global
           I64[Sp - 8] = block_ca9Zl_info;
           R1 = _sa7ZO::P64;
           I64[Sp] = _sa80v::I64;
           I64[Sp + 40] = _sa80u::I64;
           I64[Sp + 64] = _sa80t::I64;
           P64[Sp + 72] = _sa80s::P64;
           P64[Sp + 80] = _sa80r::P64;
           I64[Sp + 96] = _sa80q::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaa1X; else goto ca9Zn;
       uaa1X: // global
           call _ca9Zl(R1) args: 0, res: 0, upd: 0;
       ca9Zn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaa1C: // global
           P64[Sp + 96] = P64[Sp + 88];
           Sp = Sp + 16;
           call _sa80b() args: 0, res: 0, upd: 0;
     }
 },
 _ca9Zl() //  [R1]
         { info_tbl: [(ca9Zl,
                       label: block_ca9Zl_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9Zl: // global
           _caa1v::P64 = R1 & 7;
           if (_caa1v::P64 < 3) goto uaa1x; else goto ca9ZK;
       uaa1x: // global
           _ca9YH::P64 = P64[Sp + 96];
           if (_caa1v::P64 < 2) goto uaa1D; else goto ca9ZF;
       uaa1D: // global
           P64[Sp + 104] = _ca9YH::P64;
           Sp = Sp + 24;
           call _sa80b() args: 0, res: 0, upd: 0;
       ca9ZF: // global
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _ca9YH::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto uaa1E; else goto uaa1F;
       uaa1E: // global
           Sp = Sp + 120;
           call _caa0n() args: 0, res: 0, upd: 0;
       uaa1F: // global
           Sp = Sp + 8;
           call _caa0m() args: 0, res: 0, upd: 0;
       ca9ZK: // global
           I64[Sp] = block_ca9ZI_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto uaa1Z; else goto ca9ZL;
       uaa1Z: // global
           call _ca9ZI(R1) args: 0, res: 0, upd: 0;
       ca9ZL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9ZI() //  [R1]
         { info_tbl: [(ca9ZI,
                       label: block_ca9ZI_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9ZI: // global
           if (R1 & 7 == 1) goto ca9ZZ; else goto caa04;
       ca9ZZ: // global
           _ca9YH::P64 = P64[Sp + 96];
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _ca9YH::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto uaa1J; else goto uaa1K;
       uaa1J: // global
           Sp = Sp + 120;
           call _caa0n() args: 0, res: 0, upd: 0;
       uaa1K: // global
           Sp = Sp + 8;
           call _caa0m() args: 0, res: 0, upd: 0;
       caa04: // global
           I64[Sp] = block_caa02_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaa23; else goto caa05;
       uaa23: // global
           call _caa02(R1) args: 0, res: 0, upd: 0;
       caa05: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa02() //  [R1]
         { info_tbl: [(caa02,
                       label: block_caa02_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa02: // global
           _ca9YH::P64 = P64[Sp + 96];
           if (%MO_S_Lt_W64(I64[Sp + 16] - I64[Sp + 56],
                            I64[R1 + 7])) goto caa0p; else goto uaa1G;
       caa0p: // global
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _ca9YH::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto uaa1H; else goto uaa1I;
       uaa1H: // global
           Sp = Sp + 120;
           call _caa0n() args: 0, res: 0, upd: 0;
       uaa1I: // global
           Sp = Sp + 8;
           call _caa0m() args: 0, res: 0, upd: 0;
       uaa1G: // global
           P64[Sp + 104] = _ca9YH::P64;
           Sp = Sp + 24;
           call _sa80b() args: 0, res: 0, upd: 0;
     }
 },
 _caa0m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa0m: // global
           P64[Sp + 56] = P64[Sp + 56];
           _sa7ZD::I64 = I64[Sp + 64];
           I64[Sp + 64] = I64[Sp + 96];
           _sa7ZC::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sa7ZC::P64;
           I64[Sp + 88] = _sa7ZD::I64;
           I64[Sp + 96] = I64[Sp + 40];
           I64[Sp + 104] = I64[Sp];
           Sp = Sp + 56;
           call _ca9Ym() args: 0, res: 0, upd: 0;
     }
 },
 _sa80b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa80b: // global
           _sa7ZL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca9YN_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7ZL::P64;
           P64[Sp] = P64[Sp + 80];
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ca9YN() //  [R1]
         { info_tbl: [(ca9YN,
                       label: block_ca9YN_info
                       rep:StackRep [False, True, True, False, True, True, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9YN: // global
           _sa7ZN::P64 = P64[Sp + 8];
           _sa803::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           I64[Sp + 24] = block_ca9YS_info;
           R1 = _sa803::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaa1U; else goto ca9YV;
       uaa1U: // global
           call _ca9YS(R1) args: 0, res: 0, upd: 0;
       ca9YV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca9YS() //  [R1]
         { info_tbl: [(ca9YS,
                       label: block_ca9YS_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9YS: // global
           _sa80l::I64 = I64[R1 + 39];
           _sa80m::I64 = I64[R1 + 47];
           if (_sa80l::I64 == _sa80m::I64) goto uaa1M; else goto ca9Z3;
       uaa1M: // global
           Sp = Sp + 64;
           call _caa0n() args: 0, res: 0, upd: 0;
       ca9Z3: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 40] = I64[R1 + 31];
           I64[Sp + 48] = _sa80l::I64;
           I64[Sp + 56] = _sa80m::I64;
           Sp = Sp + 8;
           call _ca9Ym() args: 0, res: 0, upd: 0;
     }
 },
 _caa0n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa0n: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.057713668 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer1_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer1_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer1_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer1_entry() //  [R2, R3]
         { info_tbl: [(caa2n,
                       label: GHC.IO.Handle.Internals.writeCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa2n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caa2o; else goto caa2p;
       caa2o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.writeCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caa2p: // global
           I64[Sp - 16] = block_caa2k_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaa2t; else goto caa2l;
       uaa2t: // global
           call _caa2k(R1) args: 0, res: 0, upd: 0;
       caa2l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa2k() //  [R1]
         { info_tbl: [(caa2k,
                       label: block_caa2k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa2k: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.058884092 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer_entry() //  [R2, R3]
         { info_tbl: [(caa2y,
                       label: GHC.IO.Handle.Internals.writeCharBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa2y: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.writeCharBuffer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.061735442 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer3_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer3_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer3_info;
 },
 sat_sa82j_entry() //  [R1]
         { info_tbl: [(caa39,
                       label: sat_sa82j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa39: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caa3d; else goto caa3e;
       caa3d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa3e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caa36_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaa3i; else goto caa37;
       uaa3i: // global
           call _caa36(R1) args: 0, res: 0, upd: 0;
       caa37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caa36() //  [R1]
         { info_tbl: [(caa36,
                       label: block_caa36_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa36: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caa3h; else goto caa3g;
       caa3h: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caa3g: // global
           _sa82e::P64 = P64[R1 + 7];
           _sa82f::P64 = P64[R1 + 15];
           _sa82d::I64 = I64[R1 + 23];
           _sa82g::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa82e::P64;
           P64[Hp - 32] = _sa82f::P64;
           I64[Hp - 24] = _sa82d::I64;
           I64[Hp - 16] = _sa82g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa82C_entry() //  [R1]
         { info_tbl: [(caa3F,
                       label: sat_sa82C_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa3F: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caa3M; else goto caa3N;
       caa3M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa3N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caa3C_info;
           _sa82s::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa82s::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaa3R; else goto caa3D;
       uaa3R: // global
           call _caa3C(R1) args: 0, res: 0, upd: 0;
       caa3D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caa3C() //  [R1]
         { info_tbl: [(caa3C,
                       label: block_caa3C_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa3C: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caa3Q; else goto caa3P;
       caa3Q: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caa3P: // global
           _sa82w::P64 = P64[R1 + 7];
           _sa82x::P64 = P64[R1 + 15];
           _sa82v::I64 = I64[R1 + 23];
           _sa82y::I64 = I64[R1 + 31];
           _sa82A::I64 = I64[R1 + 47];
           _sa82B::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa82w::P64;
           P64[Hp - 32] = _sa82x::P64;
           I64[Hp - 24] = _sa82v::I64;
           I64[Hp - 16] = _sa82y::I64;
           I64[Hp - 8] = _sa82B::I64;
           I64[Hp] = _sa82A::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushCharBuffer3_entry() //  [R2]
         { info_tbl: [(caa3S,
                       label: GHC.IO.Handle.Internals.flushCharBuffer3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa3S: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caa3T; else goto caa3U;
       caa3T: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caa3U: // global
           I64[Sp - 8] = block_caa2F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaa50; else goto caa2G;
       uaa50: // global
           call _caa2F(R1) args: 0, res: 0, upd: 0;
       caa2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa2F() //  [R1]
         { info_tbl: [(caa2F,
                       label: block_caa2F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa2F: // global
           I64[Sp - 32] = block_caa2K_info;
           _sa81G::P64 = P64[R1 + 47];
           _sa81I::P64 = P64[R1 + 63];
           _sa81J::P64 = P64[R1 + 71];
           _sa81M::P64 = P64[R1 + 95];
           R1 = P64[_sa81J::P64 + 8];
           P64[Sp - 24] = _sa81I::P64;
           P64[Sp - 16] = _sa81J::P64;
           P64[Sp - 8] = _sa81M::P64;
           P64[Sp] = _sa81G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaa4U; else goto caa2L;
       uaa4U: // global
           call _caa2K(R1) args: 0, res: 0, upd: 0;
       caa2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa2K() //  [R1]
         { info_tbl: [(caa2K,
                       label: block_caa2K_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa2K: // global
           I64[Sp - 16] = block_caa2P_info;
           _sa81Z::I64 = I64[R1 + 39];
           _sa820::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa820::I64;
           I64[Sp] = _sa81Z::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaa4V; else goto caa2Q;
       uaa4V: // global
           call _caa2P(R1) args: 0, res: 0, upd: 0;
       caa2Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa2P() //  [R1]
         { info_tbl: [(caa2P,
                       label: block_caa2P_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa2P: // global
           if (R1 & 7 != 1) goto caa4H; else goto caa4D;
       caa4D: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto caa4H; else goto caa3Z;
       caa4H: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caa3Z: // global
           _sa825::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_caa2X_info;
           R1 = _sa825::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uaa4W; else goto caa2Y;
       uaa4W: // global
           call _caa2X(R1) args: 0, res: 0, upd: 0;
       caa2Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa2X() //  [R1]
         { info_tbl: [(caa2X,
                       label: block_caa2X_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa2X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caa42; else goto caa41;
       caa42: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa41: // global
           _sa81J::P64 = P64[Sp + 8];
           _sa827::P64 = P64[R1 + 7];
           _sa828::P64 = P64[R1 + 15];
           _sa82b::P64 = P64[_sa81J::P64 + 8];
           I64[Hp - 16] = sat_sa82j_info;
           P64[Hp] = _sa82b::P64;
           call MO_WriteBarrier();
           P64[_sa81J::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81J::P64);
           I64[Sp - 8] = block_caa3m_info;
           R1 = _sa82b::P64;
           P64[Sp] = _sa828::P64;
           P64[Sp + 8] = _sa827::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaa4X; else goto caa3n;
       uaa4X: // global
           call _caa3m(R1) args: 0, res: 0, upd: 0;
       caa3n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa3m() //  [R1]
         { info_tbl: [(caa3m,
                       label: block_caa3m_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa3m: // global
           _sa82s::I64 = I64[R1 + 39];
           if (_sa82s::I64 != 0) goto caa45; else goto caa4A;
       caa45: // global
           I64[Sp - 24] = block_caa3t_info;
           _sa82n::P64 = P64[R1 + 7];
           _sa82o::P64 = P64[R1 + 15];
           _sa82m::I64 = I64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 16] = _sa82o::P64;
           I64[Sp - 8] = _sa82s::I64;
           P64[Sp] = _sa82n::P64;
           I64[Sp + 24] = _sa82m::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaa4Y; else goto caa3u;
       uaa4Y: // global
           call _caa3t(R1) args: 0, res: 0, upd: 0;
       caa3u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caa4A: // global
           _sa81G::P64 = P64[Sp + 32];
           _sa828::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = _sa828::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caa3t() //  [R1]
         { info_tbl: [(caa3t,
                       label: block_caa3t_info
                       rep:StackRep [False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa3t: // global
           if (R1 & 7 == 1) goto caa47; else goto caa4p;
       caa47: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caa4a; else goto caa49;
       caa4a: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa49: // global
           I64[Hp - 24] = sat_sa82C_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sa81G::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caa4p: // global
           I64[Sp] = block_caa4d_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaa4Z; else goto caa4e;
       uaa4Z: // global
           call _caa4d(R1) args: 0, res: 0, upd: 0;
       caa4e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa4d() //  [R1]
         { info_tbl: [(caa4d,
                       label: block_caa4d_info
                       rep:StackRep [False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa4d: // global
           I64[Sp - 8] = block_caa4i_info;
           R2 = P64[Sp + 40];
           _sa82G::P64 = P64[R1 + 7];
           _sa82H::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa82H::P64;
           P64[Sp + 40] = _sa82G::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa4i() //  [R1]
         { info_tbl: [(caa4i,
                       label: block_caa4i_info
                       rep:StackRep [False, False, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa4i: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caa4t; else goto caa4s;
       caa4t: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa4s: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 56] = block_caa4l_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 48];
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caa4l() //  [R1]
         { info_tbl: [(caa4l,
                       label: block_caa4l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa4l: // global
           I64[Sp] = block_caa4n_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaa51; else goto caa4v;
       uaa51: // global
           call _caa4n(R1) args: 0, res: 0, upd: 0;
       caa4v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa4n() //  [R1]
         { info_tbl: [(caa4n,
                       label: block_caa4n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa4n: // global
           _sa81G::P64 = P64[Sp + 8];
           _sa82T::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = _sa82T::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.066876592 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharReadBuffer_info;
 },
 GHC.IO.Handle.Internals.flushCharReadBuffer_entry() //  [R2]
         { info_tbl: [(caa56,
                       label: GHC.IO.Handle.Internals.flushCharReadBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa56: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.067501071 UTC

[section ""cstring" . lvl9_ra7Pp_bytes" {
     lvl9_ra7Pp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.068200704 UTC

[section ""data" . lvl10_ra7Pq_closure" {
     lvl10_ra7Pq_closure:
         const lvl10_ra7Pq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ra7Pq_entry() //  [R1]
         { info_tbl: [(caa5f,
                       label: lvl10_ra7Pq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa5f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caa5g; else goto caa5h;
       caa5g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa5h: // global
           (_caa5c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caa5c::I64 == 0) goto caa5e; else goto caa5d;
       caa5e: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caa5d: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caa5c::I64;
           R2 = lvl9_ra7Pp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.069169392 UTC

[section ""data" . lvl11_ra7Pr_closure" {
     lvl11_ra7Pr_closure:
         const lvl11_ra7Pr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_ra7Pr_entry() //  [R1]
         { info_tbl: [(caa5o,
                       label: lvl11_ra7Pr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa5o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caa5p; else goto caa5q;
       caa5p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa5q: // global
           (_caa5l::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caa5l::I64 == 0) goto caa5n; else goto caa5m;
       caa5n: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caa5m: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caa5l::I64;
           R2 = GHC.IO.Handle.Internals.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.070229103 UTC

[section ""data" . lvl12_ra7Ps_closure" {
     lvl12_ra7Ps_closure:
         const lvl12_ra7Ps_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ra7Ps_entry() //  [R1]
         { info_tbl: [(caa5x,
                       label: lvl12_ra7Ps_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa5x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caa5y; else goto caa5z;
       caa5y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa5z: // global
           (_caa5u::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caa5u::I64 == 0) goto caa5w; else goto caa5v;
       caa5w: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caa5v: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caa5u::I64;
           R2 = GHC.IO.Handle.Internals.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.071097128 UTC

[section ""cstring" . lvl13_ra7Pt_bytes" {
     lvl13_ra7Pt_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.071768302 UTC

[section ""data" . lvl14_ra7Pu_closure" {
     lvl14_ra7Pu_closure:
         const lvl14_ra7Pu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ra7Pu_entry() //  [R1]
         { info_tbl: [(caa5G,
                       label: lvl14_ra7Pu_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa5G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caa5H; else goto caa5I;
       caa5H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa5I: // global
           (_caa5D::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caa5D::I64 == 0) goto caa5F; else goto caa5E;
       caa5F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caa5E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caa5D::I64;
           R2 = lvl13_ra7Pt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.072635667 UTC

[section ""data" . lvl15_ra7Pv_closure" {
     lvl15_ra7Pv_closure:
         const GHC.Types.I#_con_info;
         const 487;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.07322489 UTC

[section ""data" . lvl16_ra7Pw_closure" {
     lvl16_ra7Pw_closure:
         const GHC.Types.I#_con_info;
         const 12;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.073792563 UTC

[section ""data" . lvl17_ra7Px_closure" {
     lvl17_ra7Px_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.07435706 UTC

[section ""data" . lvl18_ra7Py_closure" {
     lvl18_ra7Py_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl11_ra7Pr_closure;
         const lvl12_ra7Ps_closure;
         const lvl14_ra7Pu_closure;
         const lvl15_ra7Pv_closure+1;
         const lvl16_ra7Pw_closure+1;
         const lvl15_ra7Pv_closure+1;
         const lvl17_ra7Px_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.074969576 UTC

[section ""data" . lvl19_ra7Pz_closure" {
     lvl19_ra7Pz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl10_ra7Pq_closure;
         const lvl18_ra7Py_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.075534766 UTC

[section ""cstring" . lvl20_ra7PA_bytes" {
     lvl20_ra7PA_bytes:
         I8[] [105,110,116,101,114,110,97,108,32,73,79,32,108,105,98,114,97,114,121,32,101,114,114,111,114,58,32,67,104,97,114,32,98,117,102,102,101,114,32,110,111,110,45,101,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.076302353 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer2_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer2_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer2_entry() //  [R1]
         { info_tbl: [(caa5R,
                       label: GHC.IO.Handle.Internals.flushCharBuffer2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa5R: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caa5S; else goto caa5T;
       caa5S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa5T: // global
           (_caa5M::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caa5M::I64 == 0) goto caa5O; else goto caa5N;
       caa5O: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caa5N: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caa5M::I64;
           I64[Sp - 24] = block_caa5P_info;
           R2 = lvl20_ra7PA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caa5P() //  [R1]
         { info_tbl: [(caa5P,
                       label: block_caa5P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa5P: // global
           R3 = R1;
           R2 = lvl19_ra7Pz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.077945035 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer1_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer1_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer1_entry() //  [R2]
         { info_tbl: [(caa64,
                       label: GHC.IO.Handle.Internals.flushCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa64: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caa68; else goto caa69;
       caa68: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caa69: // global
           I64[Sp - 8] = block_caa61_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaa6z; else goto caa62;
       uaa6z: // global
           call _caa61(R1) args: 0, res: 0, upd: 0;
       caa62: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa61() //  [R1]
         { info_tbl: [(caa61,
                       label: block_caa61_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa61: // global
           _sa83j::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_caa67_info;
           _sa830::P64 = R1;
           R1 = _sa83j::P64;
           P64[Sp] = _sa830::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaa6y; else goto caa6b;
       uaa6y: // global
           call _caa67(R1) args: 0, res: 0, upd: 0;
       caa6b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa67() //  [R1]
         { info_tbl: [(caa67,
                       label: block_caa67_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa67: // global
           I64[Sp - 16] = block_caa6f_info;
           _sa83p::I64 = I64[R1 + 39];
           _sa83q::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa83q::I64;
           I64[Sp] = _sa83p::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaa6A; else goto caa6h;
       uaa6A: // global
           call _caa6f(R1) args: 0, res: 0, upd: 0;
       caa6h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa6f() //  [R1]
         { info_tbl: [(caa6f,
                       label: block_caa6f_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa6f: // global
           if (R1 & 7 == 1) goto caa6n; else goto caa6w;
       caa6n: // global
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
       caa6w: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto caa6v; else goto caa6u;
       caa6v: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caa6u: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.079595129 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer_entry() //  [R2]
         { info_tbl: [(caa6F,
                       label: GHC.IO.Handle.Internals.flushCharBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa6F: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.081362841 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer2_closure" {
     GHC.IO.Handle.Internals.flushBuffer2_closure:
         const GHC.IO.Handle.Internals.flushBuffer2_info;
         const 0;
 },
 sat_sa844_entry() //  [R1]
         { info_tbl: [(caa7d,
                       label: sat_sa844_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa7d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caa7e; else goto caa7f;
       caa7e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa7f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -(I64[R1 + 24] - I64[R1 + 16]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushBuffer2_entry() //  [R2]
         { info_tbl: [(caa7i,
                       label: GHC.IO.Handle.Internals.flushBuffer2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa7i: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caa7j; else goto caa7k;
       caa7j: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caa7k: // global
           I64[Sp - 8] = block_caa6M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaa7L; else goto caa6N;
       uaa7L: // global
           call _caa6M(R1) args: 0, res: 0, upd: 0;
       caa6N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa6M() //  [R1]
         { info_tbl: [(caa6M,
                       label: block_caa6M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa6M: // global
           I64[Sp - 24] = block_caa6R_info;
           _sa83x::P64 = P64[R1 + 7];
           _sa83A::P64 = P64[R1 + 31];
           _sa83C::P64 = P64[R1 + 47];
           R1 = P64[_sa83C::P64 + 8];
           P64[Sp - 16] = _sa83A::P64;
           P64[Sp - 8] = _sa83C::P64;
           P64[Sp] = _sa83x::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaa7J; else goto caa6S;
       uaa7J: // global
           call _caa6R(R1) args: 0, res: 0, upd: 0;
       caa6S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa6R() //  [R1]
         { info_tbl: [(caa6R,
                       label: block_caa6R_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa6R: // global
           _sa83V::I64 = I64[R1 + 39];
           _sa83W::I64 = I64[R1 + 47];
           if (_sa83V::I64 == _sa83W::I64) goto caa7D; else goto caa7o;
       caa7D: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caa7o: // global
           I64[Sp - 48] = block_caa6Z_info;
           R2 = P64[Sp + 24];
           I64[Sp - 64] = stg_ap_pv_info;
           P64[Sp - 56] = P64[Sp + 8];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sa83V::I64;
           I64[Sp - 8] = _sa83W::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _caa6Z() //  [R1]
         { info_tbl: [(caa6Z,
                       label: block_caa6Z_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa6Z: // global
           I64[Sp] = block_caa71_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaa7K; else goto caa72;
       uaa7K: // global
           call _caa71(R1) args: 0, res: 0, upd: 0;
       caa72: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa71() //  [R1]
         { info_tbl: [(caa71,
                       label: block_caa71_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa71: // global
           if (R1 & 7 == 1) goto caa7t; else goto caa7v;
       caa7t: // global
           R1 = GHC.IO.Handle.Internals.flushBuffer3_closure;
           Sp = Sp + 80;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caa7v: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caa7y; else goto caa7x;
       caa7y: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa7x: // global
           I64[Hp - 24] = sat_sa844_info;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 40];
           I64[Sp] = block_caa7u_info;
           R2 = P64[Sp + 72];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 16] = GHC.IO.Device.RelativeSeek_closure+2;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _caa7u() //  [R1]
         { info_tbl: [(caa7u,
                       label: block_caa7u_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa7u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caa7C; else goto caa7B;
       caa7C: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa7B: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sa83C::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sa83C::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa83C::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.084047063 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteReadBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushByteReadBuffer_entry() //  [R2]
         { info_tbl: [(caa7Q,
                       label: GHC.IO.Handle.Internals.flushByteReadBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa7Q: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.087359588 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer1_closure" {
     GHC.IO.Handle.Internals.flushBuffer1_closure:
         const GHC.IO.Handle.Internals.flushBuffer1_info;
         const 0;
 },
 sat_sa856_entry() //  [R1]
         { info_tbl: [(caa8B,
                       label: sat_sa856_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa8B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caa8F; else goto caa8G;
       caa8F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa8G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caa8y_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaa8K; else goto caa8z;
       uaa8K: // global
           call _caa8y(R1) args: 0, res: 0, upd: 0;
       caa8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caa8y() //  [R1]
         { info_tbl: [(caa8y,
                       label: block_caa8y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa8y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caa8J; else goto caa8I;
       caa8J: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caa8I: // global
           _sa851::P64 = P64[R1 + 7];
           _sa852::P64 = P64[R1 + 15];
           _sa850::I64 = I64[R1 + 23];
           _sa853::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa851::P64;
           P64[Hp - 32] = _sa852::P64;
           I64[Hp - 24] = _sa850::I64;
           I64[Hp - 16] = _sa853::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa85p_entry() //  [R1]
         { info_tbl: [(caa97,
                       label: sat_sa85p_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa97: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caa9e; else goto caa9f;
       caa9e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caa9f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caa94_info;
           _sa85f::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa85f::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaa9j; else goto caa95;
       uaa9j: // global
           call _caa94(R1) args: 0, res: 0, upd: 0;
       caa95: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caa94() //  [R1]
         { info_tbl: [(caa94,
                       label: block_caa94_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa94: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caa9i; else goto caa9h;
       caa9i: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caa9h: // global
           _sa85j::P64 = P64[R1 + 7];
           _sa85k::P64 = P64[R1 + 15];
           _sa85i::I64 = I64[R1 + 23];
           _sa85l::I64 = I64[R1 + 31];
           _sa85n::I64 = I64[R1 + 47];
           _sa85o::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa85j::P64;
           P64[Hp - 32] = _sa85k::P64;
           I64[Hp - 24] = _sa85i::I64;
           I64[Hp - 16] = _sa85l::I64;
           I64[Hp - 8] = _sa85o::I64;
           I64[Hp] = _sa85n::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushBuffer1_entry() //  [R2]
         { info_tbl: [(caa9k,
                       label: GHC.IO.Handle.Internals.flushBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa9k: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caa9l; else goto caa9m;
       caa9l: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caa9m: // global
           I64[Sp - 8] = block_caa7X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaaaW; else goto caa7Y;
       uaaaW: // global
           call _caa7X(R1) args: 0, res: 0, upd: 0;
       caa7Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa7X() //  [R1]
         { info_tbl: [(caa7X,
                       label: block_caa7X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa7X: // global
           I64[Sp - 56] = block_caa82_info;
           _sa84c::P64 = R1;
           _sa84e::P64 = P64[R1 + 15];
           _sa84g::P64 = P64[R1 + 31];
           _sa84i::P64 = P64[R1 + 47];
           _sa84k::P64 = P64[R1 + 63];
           _sa84l::P64 = P64[R1 + 71];
           _sa84o::P64 = P64[R1 + 95];
           R1 = P64[_sa84l::P64 + 8];
           P64[Sp - 48] = _sa84e::P64;
           P64[Sp - 40] = _sa84g::P64;
           P64[Sp - 32] = _sa84i::P64;
           P64[Sp - 24] = _sa84k::P64;
           P64[Sp - 16] = _sa84l::P64;
           P64[Sp - 8] = _sa84o::P64;
           P64[Sp] = _sa84c::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaaaN; else goto caa83;
       uaaaN: // global
           call _caa82(R1) args: 0, res: 0, upd: 0;
       caa83: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa82() //  [R1]
         { info_tbl: [(caa82,
                       label: block_caa82_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa82: // global
           I64[Sp] = block_caa87_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaaaO; else goto caa88;
       uaaaO: // global
           call _caa87(R1) args: 0, res: 0, upd: 0;
       caa88: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa87() //  [R1]
         { info_tbl: [(caa87,
                       label: block_caa87_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa87: // global
           if (R1 & 7 == 1) goto caa9r; else goto caaai;
       caa9r: // global
           _sa84G::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_caa8c_info;
           R1 = _sa84G::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaaaP; else goto caa8d;
       uaaaP: // global
           call _caa8c(R1) args: 0, res: 0, upd: 0;
       caa8d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caaai: // global
           _sa85M::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_caaag_info;
           R1 = _sa85M::P64;
           if (R1 & 7 != 0) goto uaaaQ; else goto caaaj;
       uaaaQ: // global
           call _caaag(R1) args: 0, res: 0, upd: 0;
       caaaj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa8c() //  [R1]
         { info_tbl: [(caa8c,
                       label: block_caa8c_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa8c: // global
           I64[Sp - 16] = block_caa8h_info;
           _sa84M::I64 = I64[R1 + 39];
           _sa84N::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa84N::I64;
           I64[Sp] = _sa84M::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaaaR; else goto caa8i;
       uaaaR: // global
           call _caa8h(R1) args: 0, res: 0, upd: 0;
       caa8i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa8h() //  [R1]
         { info_tbl: [(caa8h,
                       label: block_caa8h_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa8h: // global
           _sa84c::P64 = P64[Sp + 56];
           if (R1 & 7 != 1) goto caaad; else goto caaa9;
       caaa9: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto caaad; else goto caa9v;
       caaad: // global
           R2 = _sa84c::P64;
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       caa9v: // global
           _sa84S::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_caa8p_info;
           R1 = _sa84S::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaaaS; else goto caa8q;
       uaaaS: // global
           call _caa8p(R1) args: 0, res: 0, upd: 0;
       caa8q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa8p() //  [R1]
         { info_tbl: [(caa8p,
                       label: block_caa8p_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa8p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caa9y; else goto caa9x;
       caa9y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa9x: // global
           _sa84l::P64 = P64[Sp + 24];
           _sa84U::P64 = P64[R1 + 7];
           _sa84V::P64 = P64[R1 + 15];
           _sa84Y::P64 = P64[_sa84l::P64 + 8];
           I64[Hp - 16] = sat_sa856_info;
           P64[Hp] = _sa84Y::P64;
           call MO_WriteBarrier();
           P64[_sa84l::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84l::P64);
           I64[Sp] = block_caa8O_info;
           R1 = _sa84Y::P64;
           P64[Sp + 16] = _sa84V::P64;
           P64[Sp + 24] = _sa84U::P64;
           if (R1 & 7 != 0) goto uaaaT; else goto caa8P;
       uaaaT: // global
           call _caa8O(R1) args: 0, res: 0, upd: 0;
       caa8P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa8O() //  [R1]
         { info_tbl: [(caa8O,
                       label: block_caa8O_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa8O: // global
           _sa85f::I64 = I64[R1 + 39];
           if (_sa85f::I64 != 0) goto caa9B; else goto caaa6;
       caa9B: // global
           I64[Sp - 24] = block_caa8V_info;
           _sa85a::P64 = P64[R1 + 7];
           _sa85b::P64 = P64[R1 + 15];
           _sa859::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sa85b::P64;
           I64[Sp - 8] = _sa85f::I64;
           P64[Sp] = _sa85a::P64;
           I64[Sp + 32] = _sa859::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaaU; else goto caa8W;
       uaaaU: // global
           call _caa8V(R1) args: 0, res: 0, upd: 0;
       caa8W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caaa6: // global
           _sa84c::P64 = P64[Sp + 40];
           _sa84i::P64 = P64[Sp + 8];
           _sa84V::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = _sa84V::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caa8V() //  [R1]
         { info_tbl: [(caa8V,
                       label: block_caa8V_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa8V: // global
           if (R1 & 7 == 1) goto caa9D; else goto caa9V;
       caa9D: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caa9G; else goto caa9F;
       caa9G: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa9F: // global
           I64[Hp - 24] = sat_sa85p_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sa84c::P64 = P64[Sp + 64];
           _sa84i::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       caa9V: // global
           I64[Sp] = block_caa9J_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaaaV; else goto caa9K;
       uaaaV: // global
           call _caa9J(R1) args: 0, res: 0, upd: 0;
       caa9K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa9J() //  [R1]
         { info_tbl: [(caa9J,
                       label: block_caa9J_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa9J: // global
           I64[Sp - 8] = block_caa9O_info;
           R2 = P64[Sp + 48];
           _sa85t::P64 = P64[R1 + 7];
           _sa85u::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa85u::P64;
           P64[Sp + 48] = _sa85t::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa9O() //  [R1]
         { info_tbl: [(caa9O,
                       label: block_caa9O_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa9O: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caa9Z; else goto caa9Y;
       caa9Z: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caa9Y: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_caa9R_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caa9R() //  [R1]
         { info_tbl: [(caa9R,
                       label: block_caa9R_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa9R: // global
           I64[Sp] = block_caa9T_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaaX; else goto caaa1;
       uaaaX: // global
           call _caa9T(R1) args: 0, res: 0, upd: 0;
       caaa1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caa9T() //  [R1]
         { info_tbl: [(caa9T,
                       label: block_caa9T_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa9T: // global
           _sa84c::P64 = P64[Sp + 40];
           _sa84i::P64 = P64[Sp + 8];
           _sa85G::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = _sa85G::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caaag() //  [R1]
         { info_tbl: [(caaag,
                       label: block_caaag_info
                       rep:StackRep [False, False, False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaag: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto caaaw; else goto caaat;
       caaaw: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caaat: // global
           _sa84g::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caaar_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa84g::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _caaar() //  [R1]
         { info_tbl: [(caaar,
                       label: block_caaar_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaar: // global
           _sa84i::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.093918678 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer_closure" {
     GHC.IO.Handle.Internals.flushBuffer_closure:
         const GHC.IO.Handle.Internals.flushBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer_entry() //  [R2]
         { info_tbl: [(caab2,
                       label: GHC.IO.Handle.Internals.flushBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caab2: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.094617301 UTC

[section ""cstring" . lvl21_ra7PB_bytes" {
     lvl21_ra7PB_bytes:
         I8[] [71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,56,56,49,58,55,45,51,48,124,74,117,115,116,32,100,101,99,111,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.095326969 UTC

[section ""data" . lvl22_ra7PC_closure" {
     lvl22_ra7PC_closure:
         const lvl22_ra7PC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ra7PC_entry() //  [R1]
         { info_tbl: [(caabb,
                       label: lvl22_ra7PC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caabb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caabc; else goto caabd;
       caabc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caabd: // global
           (_caab8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caab8::I64 == 0) goto caaba; else goto caab9;
       caaba: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caab9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caab8::I64;
           R2 = lvl21_ra7PB_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.101065956 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_2_closure" {
     GHC.IO.Handle.Internals.hLookAhead_2_closure:
         const GHC.IO.Handle.Internals.hLookAhead_2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_2_entry() //  [R2, R3]
         { info_tbl: [(caabl,
                       label: GHC.IO.Handle.Internals.hLookAhead_2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caabl: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caabp; else goto caabq;
       caabp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caabq: // global
           I64[Sp - 16] = block_caabi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaadQ; else goto caabj;
       uaadQ: // global
           call _caabi(R1) args: 0, res: 0, upd: 0;
       caabj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caabi() //  [R1]
         { info_tbl: [(caabi,
                       label: block_caabi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caabi: // global
           I64[Sp - 48] = block_caabo_info;
           _sa862::P64 = R1;
           _sa864::P64 = P64[R1 + 15];
           _sa866::P64 = P64[R1 + 31];
           _sa868::P64 = P64[R1 + 47];
           _sa86a::P64 = P64[R1 + 63];
           _sa86e::P64 = P64[R1 + 95];
           R1 = P64[_sa868::P64 + 8];
           P64[Sp - 40] = _sa864::P64;
           P64[Sp - 32] = _sa866::P64;
           P64[Sp - 24] = _sa868::P64;
           P64[Sp - 16] = _sa86a::P64;
           P64[Sp - 8] = _sa86e::P64;
           P64[Sp] = _sa862::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uaadP; else goto caabs;
       uaadP: // global
           call _caabo(R1) args: 0, res: 0, upd: 0;
       caabs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caabo() //  [R1]
         { info_tbl: [(caabo,
                       label: block_caabo_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caabo: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto caadA; else goto caadp;
       caadA: // global
           _sa866::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caads_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa866::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       caadp: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sa86t() args: 0, res: 0, upd: 0;
     }
 },
 _caads() //  [R1]
         { info_tbl: [(caads,
                       label: block_caads_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caads: // global
           I64[Sp] = block_caadu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaae1; else goto caadv;
       uaae1: // global
           call _caadu(R1) args: 0, res: 0, upd: 0;
       caadv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caadu() //  [R1]
         { info_tbl: [(caadu,
                       label: block_caadu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caadu: // global
           I64[Sp - 8] = block_caadz_info;
           _sa87O::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa87O::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaae2; else goto caadD;
       uaae2: // global
           call _caadz(R1) args: 0, res: 0, upd: 0;
       caadD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caadz() //  [R1]
         { info_tbl: [(caadz,
                       label: block_caadz_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caadz: // global
           if (I64[R1 + 7] == 0) goto caadL; else goto caadK;
       caadL: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caadK: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _sa86t() args: 0, res: 0, upd: 0;
     }
 },
 _sa86t() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa86t: // global
           I64[Sp - 8] = block_caabC_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaae4; else goto caabE;
       uaae4: // global
           call _caabC(R1) args: 0, res: 0, upd: 0;
       caabE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caabC() //  [R1]
         { info_tbl: [(caabC,
                       label: block_caabC_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caabC: // global
           if (R1 & 7 == 1) goto caac3; else goto caacW;
       caac3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caac6; else goto caac5;
       caac6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caac5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sa86v::P64 = P64[Sp + 8];
           P64[Hp] = _sa86v::P64;
           _sa860::P64 = P64[Sp + 48];
           _sa86a::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa86a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa86a::P64);
           I64[Sp + 8] = block_caabM_info;
           R3 = _sa860::P64;
           R2 = _sa86v::P64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       caacW: // global
           I64[Sp] = block_caacu_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaadS; else goto caacv;
       uaadS: // global
           call _caacu(R1) args: 0, res: 0, upd: 0;
       caacv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caabM() //  [R1]
         { info_tbl: [(caabM,
                       label: block_caabM_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caabM: // global
           I64[Sp] = block_caabO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaadT; else goto caabP;
       uaadT: // global
           call _caabO(R1) args: 0, res: 0, upd: 0;
       caabP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caabO() //  [R1]
         { info_tbl: [(caabO,
                       label: block_caabO_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caabO: // global
           _sa868::P64 = P64[Sp + 8];
           _sa86E::P64 = P64[R1 + 15];
           _sa86F::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sa868::P64 + 8] = _sa86E::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa868::P64);
           I64[Sp + 16] = block_caabW_info;
           R1 = _sa86F::P64;
           P64[Sp + 24] = _sa86E::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaadU; else goto caabX;
       uaadU: // global
           call _caabW(R1) args: 0, res: 0, upd: 0;
       caabX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caabW() //  [R1]
         { info_tbl: [(caabW,
                       label: block_caabW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caabW: // global
           I64[Sp - 8] = block_caac1_info;
           _sa86H::P64 = R1;
           _sa86N::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sa86N::I64;
           P64[Sp + 24] = _sa86H::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaadV; else goto caaca;
       uaadV: // global
           call _caac1(R1) args: 0, res: 0, upd: 0;
       caaca: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caac1() //  [R1]
         { info_tbl: [(caac1,
                       label: block_caac1_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caac1: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto caacm; else goto caaci;
       caacm: // global
           _sa86E::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caacl_info;
           _sa86O::P64 = R1;
           R1 = _sa86E::P64;
           P64[Sp + 32] = _sa86O::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaadW; else goto caacn;
       uaadW: // global
           call _caacl(R1) args: 0, res: 0, upd: 0;
       caacn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caaci: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caacl() //  [R1]
         { info_tbl: [(caacl,
                       label: block_caacl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caacl: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 _caacu() //  [R1]
         { info_tbl: [(caacu,
                       label: block_caacu_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caacu: // global
           I64[Sp - 8] = block_caacz_info;
           _sa875::P64 = P64[R1 + 7];
           _sa876::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sa876::P64;
           P64[Sp + 32] = _sa875::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caacz() //  [R1]
         { info_tbl: [(caacz,
                       label: block_caacz_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caacz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caad0; else goto caacZ;
       caad0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caacZ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa86v::P64 = P64[Sp + 16];
           P64[Hp] = _sa86v::P64;
           _sa860::P64 = P64[Sp + 56];
           _sa86a::P64 = P64[Sp + 32];
           _sa875::P64 = P64[Sp + 40];
           _sa876::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa86a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa86a::P64);
           I64[Sp + 16] = block_caacF_info;
           R5 = _sa860::P64;
           R4 = _sa86v::P64;
           R3 = _sa876::P64;
           R2 = _sa875::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caacF() //  [R1]
         { info_tbl: [(caacF,
                       label: block_caacF_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caacF: // global
           I64[Sp] = block_caacH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaadX; else goto caacI;
       uaadX: // global
           call _caacH(R1) args: 0, res: 0, upd: 0;
       caacI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caacH() //  [R1]
         { info_tbl: [(caacH,
                       label: block_caacH_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caacH: // global
           _sa868::P64 = P64[Sp + 8];
           _sa87j::P64 = P64[R1 + 7];
           _sa87k::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa868::P64 + 8] = _sa87j::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa868::P64);
           I64[Sp + 16] = block_caacP_info;
           R1 = _sa87k::P64;
           P64[Sp + 24] = _sa87j::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaadY; else goto caacQ;
       uaadY: // global
           call _caacP(R1) args: 0, res: 0, upd: 0;
       caacQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caacP() //  [R1]
         { info_tbl: [(caacP,
                       label: block_caacP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caacP: // global
           I64[Sp - 8] = block_caacU_info;
           _sa87m::P64 = R1;
           _sa87s::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sa87s::I64;
           P64[Sp + 24] = _sa87m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaadZ; else goto caad4;
       uaadZ: // global
           call _caacU(R1) args: 0, res: 0, upd: 0;
       caad4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caacU() //  [R1]
         { info_tbl: [(caacU,
                       label: block_caacU_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caacU: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto caadg; else goto caadc;
       caadg: // global
           _sa87j::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caadf_info;
           _sa87t::P64 = R1;
           R1 = _sa87j::P64;
           P64[Sp + 32] = _sa87t::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaae0; else goto caadh;
       uaae0: // global
           call _caadf(R1) args: 0, res: 0, upd: 0;
       caadh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caadc: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caadf() //  [R1]
         { info_tbl: [(caadf,
                       label: block_caadf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caadf: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Internals.$wreadTextDevice'_closure" {
     GHC.IO.Handle.Internals.$wreadTextDevice'_closure:
         const GHC.IO.Handle.Internals.$wreadTextDevice'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caae6: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaahj_srtd" {
     uaahj_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 7516192769;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(caaed,
                       label: GHC.IO.Handle.Internals.$wreadTextDevice'_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaed: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caaeD; else goto uaagW;
       caaeD: // global
           R1 = GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       uaagW: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _caae7() args: 0, res: 0, upd: 0;
     }
 },
 _caae7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caae7: // global
           _sa87T::P64 = P64[Sp];
           I64[Sp] = block_caaea_info;
           R1 = _sa87T::P64;
           if (R1 & 7 != 0) goto uaah0; else goto caaeb;
       uaah0: // global
           call _caaea(R1) args: 0, res: 0, upd: 0;
       caaeb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaahk_srtd" {
     uaahk_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caaea() //  [R1]
         { info_tbl: [(caaea,
                       label: block_caaea_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaea: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caaeH; else goto caaeG;
       caaeH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaeG: // global
           _sa87U::I64 = I64[Sp + 8];
           _sa87V::P64 = P64[Sp + 16];
           _sa87W::P64 = P64[Sp + 24];
           _sa87X::I64 = I64[Sp + 32];
           _sa87Y::I64 = I64[Sp + 40];
           _sa884::P64 = P64[R1 + 15];
           _sa886::P64 = P64[R1 + 31];
           _sa888::P64 = P64[R1 + 47];
           _sa88a::P64 = P64[R1 + 63];
           _sa88e::P64 = P64[R1 + 95];
           _sa88j::I64 = I64[Sp + 48] - _sa87Y::I64;
           (_sa88p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_sa87U::I64, _sa87U::I64 + _sa87Y::I64, _sa88j::I64);
           call MO_Touch(_sa87V::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa87V::P64;
           P64[Hp - 32] = _sa87W::P64;
           I64[Hp - 24] = _sa87U::I64;
           I64[Hp - 16] = _sa87X::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sa88j::I64;
           I64[Sp + 16] = block_caaev_info;
           R2 = _sa884::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa886::P64;
           P64[Sp + 8] = Hp - 47;
           P64[Sp + 24] = _sa88e::P64;
           P64[Sp + 32] = _sa88a::P64;
           P64[Sp + 40] = _sa888::P64;
           P64[Sp + 48] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaahl_srtd" {
     uaahl_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caaev() //  [R1]
         { info_tbl: [(caaev,
                       label: block_caaev_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaev: // global
           I64[Sp] = block_caaex_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaah2; else goto caaey;
       uaah2: // global
           call _caaex(R1) args: 0, res: 0, upd: 0;
       caaey: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaahm_srtd" {
     uaahm_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caaex() //  [R1]
         { info_tbl: [(caaex,
                       label: block_caaex_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaex: // global
           I64[Sp - 8] = block_caaeC_info;
           _sa88x::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa88x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaah3; else goto caaeK;
       uaah3: // global
           call _caaeC(R1) args: 0, res: 0, upd: 0;
       caaeK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaahn_srtd" {
     uaahn_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caaeC() //  [R1]
         { info_tbl: [(caaeC,
                       label: block_caaeC_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaeC: // global
           if (I64[R1 + 7] == 0) goto caafX; else goto caaeT;
       caafX: // global
           _sa88x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caafW_info;
           R1 = _sa88x::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaah5; else goto caafY;
       uaah5: // global
           call _caafW(R1) args: 0, res: 0, upd: 0;
       caafY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caaeT: // global
           I64[Sp] = block_caaeR_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto uaah4; else goto caaeU;
       uaah4: // global
           call _caaeR(R1) args: 0, res: 0, upd: 0;
       caaeU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaaho_srtd" {
     uaaho_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caafW() //  [R1]
         { info_tbl: [(caafW,
                       label: block_caafW_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caafW: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto caagT; else goto caag8;
       caagT: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caag8: // global
           _sa88e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caag6_info;
           _sa89i::P64 = R1;
           R1 = _sa88e::P64;
           P64[Sp + 16] = _sa89i::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaahd; else goto caag9;
       uaahd: // global
           call _caag6(R1) args: 0, res: 0, upd: 0;
       caag9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caag6() //  [R1]
         { info_tbl: [(caag6,
                       label: block_caag6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caag6: // global
           if (R1 & 7 == 1) goto uaagZ; else goto caagE;
       uaagZ: // global
           Sp = Sp + 40;
           call _caagf() args: 0, res: 0, upd: 0;
       caagE: // global
           I64[Sp] = block_caagi_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaahe; else goto caagj;
       uaahe: // global
           call _caagi(R1) args: 0, res: 0, upd: 0;
       caagj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caagi() //  [R1]
         { info_tbl: [(caagi,
                       label: block_caagi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caagi: // global
           _sa89i::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caagn_info;
           R3 = P64[Sp + 32];
           R2 = _sa89i::P64;
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caagn() //  [R1]
         { info_tbl: [(caagn,
                       label: block_caagn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caagn: // global
           I64[Sp] = block_caagp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaahg; else goto caagq;
       uaahg: // global
           call _caagp(R1) args: 0, res: 0, upd: 0;
       caagq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caagp() //  [R1]
         { info_tbl: [(caagp,
                       label: block_caagp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caagp: // global
           _sa888::P64 = P64[Sp + 8];
           _sa89D::P64 = P64[R1 + 7];
           _sa89E::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa888::P64 + 8] = _sa89D::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa888::P64);
           I64[Sp + 8] = block_caagx_info;
           R1 = _sa89E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaahh; else goto caagy;
       uaahh: // global
           call _caagx(R1) args: 0, res: 0, upd: 0;
       caagy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caagx() //  [R1]
         { info_tbl: [(caagx,
                       label: block_caagx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caagx: // global
           I64[Sp - 8] = block_caagC_info;
           _sa89G::P64 = R1;
           _sa89M::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           I64[Sp] = _sa89M::I64;
           P64[Sp + 16] = _sa89G::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaahi; else goto caagJ;
       uaahi: // global
           call _caagC(R1) args: 0, res: 0, upd: 0;
       caagJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caagC() //  [R1]
         { info_tbl: [(caagC,
                       label: block_caagC_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caagC: // global
           _sa89G::P64 = P64[Sp + 24];
           if (I64[Sp + 8] == I64[R1 + 47]) goto caagS; else goto caagR;
       caagS: // global
           R3 = _sa89G::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       caagR: // global
           R1 = _sa89G::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaahp_srtd" {
     uaahp_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caaeR() //  [R1]
         { info_tbl: [(caaeR,
                       label: block_caaeR_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaeR: // global
           if (R1 & 7 == 1) goto uaagX; else goto caafv;
       uaagX: // global
           Sp = Sp + 56;
           call _caagf() args: 0, res: 0, upd: 0;
       caafv: // global
           I64[Sp] = block_caaf3_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaah6; else goto caaf4;
       uaah6: // global
           call _caaf3(R1) args: 0, res: 0, upd: 0;
       caaf4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caagf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caagf: // global
           R1 = lvl22_ra7PC_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaahq_srtd" {
     uaahq_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caaf3() //  [R1]
         { info_tbl: [(caaf3,
                       label: block_caaf3_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaf3: // global
           I64[Sp - 8] = block_caaf8_info;
           _sa88F::P64 = P64[R1 + 7];
           _sa88G::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sa88G::P64;
           P64[Sp + 16] = _sa88F::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaahr_srtd" {
     uaahr_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caaf8() //  [R1]
         { info_tbl: [(caaf8,
                       label: block_caaf8_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaf8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caafz; else goto caafy;
       caafz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caafy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa88x::P64 = P64[Sp + 16];
           P64[Hp] = _sa88x::P64;
           _sa880::P64 = P64[Sp + 56];
           _sa88a::P64 = P64[Sp + 32];
           _sa88F::P64 = P64[Sp + 24];
           _sa88G::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa88a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa88a::P64);
           I64[Sp + 32] = block_caafe_info;
           R5 = _sa880::P64;
           R4 = _sa88x::P64;
           R3 = _sa88G::P64;
           R2 = _sa88F::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaahs_srtd" {
     uaahs_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caafe() //  [R1]
         { info_tbl: [(caafe,
                       label: block_caafe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caafe: // global
           I64[Sp] = block_caafg_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaah8; else goto caafh;
       uaah8: // global
           call _caafg(R1) args: 0, res: 0, upd: 0;
       caafh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaaht_srtd" {
     uaaht_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caafg() //  [R1]
         { info_tbl: [(caafg,
                       label: block_caafg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caafg: // global
           _sa880::P64 = P64[Sp + 24];
           _sa888::P64 = P64[Sp + 8];
           _sa88T::P64 = P64[R1 + 7];
           _sa88U::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa888::P64 + 8] = _sa88T::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa888::P64);
           I64[Sp] = block_caafo_info;
           R1 = _sa880::P64;
           P64[Sp + 8] = _sa88U::P64;
           P64[Sp + 24] = _sa88T::P64;
           if (R1 & 7 != 0) goto uaah9; else goto caafp;
       uaah9: // global
           call _caafo(R1) args: 0, res: 0, upd: 0;
       caafp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaahu_srtd" {
     uaahu_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caafo() //  [R1]
         { info_tbl: [(caafo,
                       label: block_caafo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caafo: // global
           I64[Sp] = block_caaft_info;
           _sa892::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sa892::I64;
           if (R1 & 7 != 0) goto uaaha; else goto caafD;
       uaaha: // global
           call _caaft(R1) args: 0, res: 0, upd: 0;
       caafD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaahv_srtd" {
     uaahv_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caaft() //  [R1]
         { info_tbl: [(caaft,
                       label: block_caaft_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaft: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto caafP; else goto caafL;
       caafP: // global
           I64[Sp + 8] = block_caafO_info;
           _sa893::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sa893::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaahb; else goto caafQ;
       uaahb: // global
           call _caafO(R1) args: 0, res: 0, upd: 0;
       caafQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caafL: // global
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaahw_srtd" {
     uaahw_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _caafO() //  [R1]
         { info_tbl: [(caafO,
                       label: block_caafO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caafO: // global
           P64[Sp - 40] = P64[Sp + 8];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 8] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 40;
           call _caae7() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.113134778 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDevice_closure" {
     GHC.IO.Handle.Internals.readTextDevice_closure:
         const GHC.IO.Handle.Internals.readTextDevice_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDevice_entry() //  [R2, R3]
         { info_tbl: [(caahB,
                       label: GHC.IO.Handle.Internals.readTextDevice_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caahB: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.114855645 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_1_closure" {
     GHC.IO.Handle.Internals.hLookAhead_1_closure:
         const GHC.IO.Handle.Internals.hLookAhead_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_1_entry() //  [R2]
         { info_tbl: [(caahL,
                       label: GHC.IO.Handle.Internals.hLookAhead_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caahL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caahP; else goto caahQ;
       caahP: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caahQ: // global
           I64[Sp - 8] = block_caahI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaaim; else goto caahJ;
       uaaim: // global
           call _caahI(R1) args: 0, res: 0, upd: 0;
       caahJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caahI() //  [R1]
         { info_tbl: [(caahI,
                       label: block_caahI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caahI: // global
           I64[Sp - 16] = block_caahO_info;
           _sa89X::P64 = R1;
           _sa8a6::P64 = P64[R1 + 71];
           R1 = P64[_sa8a6::P64 + 8];
           P64[Sp - 8] = _sa8a6::P64;
           P64[Sp] = _sa89X::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaail; else goto caahS;
       uaail: // global
           call _caahO(R1) args: 0, res: 0, upd: 0;
       caahS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caahO() //  [R1]
         { info_tbl: [(caahO,
                       label: block_caahO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caahO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caahY; else goto caahX;
       caahY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caahX: // global
           _sa8aj::P64 = P64[R1 + 7];
           _sa8ai::I64 = I64[R1 + 23];
           _sa8am::I64 = I64[R1 + 39];
           if (_sa8am::I64 == I64[R1 + 47]) goto caaih; else goto caai8;
       caaih: // global
           Hp = Hp - 16;
           I64[Sp - 16] = block_caaia_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = _sa8am::I64;
           P64[Sp] = _sa8aj::P64;
           I64[Sp + 16] = _sa8ai::I64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       caai8: // global
           _sa8a6::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8a6::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8a6::P64);
           _sa8as::I64 = %MO_UU_Conv_W32_W64(I32[_sa8ai::I64 + (_sa8am::I64 << 2)]);
           call MO_Touch(_sa8aj::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sa8as::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaia() //  [R1]
         { info_tbl: [(caaia,
                       label: block_caaia_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaia: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caaik; else goto caaij;
       caaik: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaij: // global
           _sa8a6::P64 = P64[Sp + 24];
           _sa8ai::I64 = I64[Sp + 32];
           _sa8aj::P64 = P64[Sp + 16];
           _sa8am::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8a6::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8a6::P64);
           _sa8aB::I64 = %MO_UU_Conv_W32_W64(I32[_sa8ai::I64 + (_sa8am::I64 << 2)]);
           call MO_Touch(_sa8aj::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sa8aB::I64;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.116910619 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead__closure" {
     GHC.IO.Handle.Internals.hLookAhead__closure:
         const GHC.IO.Handle.Internals.hLookAhead__info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead__entry() //  [R2]
         { info_tbl: [(caair,
                       label: GHC.IO.Handle.Internals.hLookAhead__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caair: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.117826061 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help2_closure" {
     GHC.IO.Handle.Internals.hClose_help2_closure:
         const GHC.IO.Handle.Internals.hClose_help2_info;
 },
 GHC.IO.Handle.Internals.hClose_help2_entry() //  [R2]
         { info_tbl: [(caaiz,
                       label: GHC.IO.Handle.Internals.hClose_help2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaiz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caaiD; else goto caaiC;
       caaiD: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaiC: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.12212356 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help1_closure" {
     GHC.IO.Handle.Internals.hClose_help1_closure:
         const GHC.IO.Handle.Internals.hClose_help1_info;
         const 0;
 },
 sat_sa8bs_entry() //  [R1]
         { info_tbl: [(caaj0,
                       label: sat_sa8bs_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaj0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caaj1; else goto caaj2;
       caaj1: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaj2: // global
           I64[Sp - 32] = block_caaiX_info;
           _sa8aL::P64 = P64[R1 + 7];
           _sa8aN::P64 = P64[R1 + 15];
           _sa8aP::P64 = P64[R1 + 23];
           R1 = P64[_sa8aP::P64 + 8];
           P64[Sp - 24] = _sa8aL::P64;
           P64[Sp - 16] = _sa8aN::P64;
           P64[Sp - 8] = _sa8aP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaajE; else goto caaiY;
       uaajE: // global
           call _caaiX(R1) args: 0, res: 0, upd: 0;
       caaiY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaiX() //  [R1]
         { info_tbl: [(caaiX,
                       label: block_caaiX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaiX: // global
           I64[Sp] = block_caaj5_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaajD; else goto caaj7;
       uaajD: // global
           call _caaj5(R1) args: 0, res: 0, upd: 0;
       caaj7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaj5() //  [R1]
         { info_tbl: [(caaj5,
                       label: block_caaj5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaj5: // global
           if (R1 & 7 == 1) goto uaajB; else goto caaji;
       uaajB: // global
           Sp = Sp + 32;
           call _caajw() args: 0, res: 0, upd: 0;
       caaji: // global
           _sa8bf::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_caajg_info;
           R1 = _sa8bf::P64;
           if (R1 & 7 != 0) goto uaajF; else goto caajj;
       uaajF: // global
           call _caajg(R1) args: 0, res: 0, upd: 0;
       caajj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caajg() //  [R1]
         { info_tbl: [(caajg,
                       label: block_caajg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caajg: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uaajC; else goto caajt;
       uaajC: // global
           Sp = Sp + 32;
           call _caajw() args: 0, res: 0, upd: 0;
       caajt: // global
           _sa8aN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caajr_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa8aN::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _caajw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caajw: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caajr() //  [R1]
         { info_tbl: [(caajr,
                       label: block_caajr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caajr: // global
           _sa8aP::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8aP::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aP::P64);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8bI_entry() //  [R1]
         { info_tbl: [(caakj,
                       label: sat_sa8bI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caakj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caakk; else goto caakl;
       caakk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caakl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caakc_info;
           _sa8by::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8by::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaaks; else goto caakd;
       uaaks: // global
           call _caakc(R1) args: 0, res: 0, upd: 0;
       caakd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caakc() //  [R1]
         { info_tbl: [(caakc,
                       label: block_caakc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caakc: // global
           if (R1 & 7 == 1) goto caakg; else goto caakh;
       caakg: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caakh: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8bX_entry() //  [R1]
         { info_tbl: [(caakN,
                       label: sat_sa8bX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caakN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caakO; else goto caakP;
       caakO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caakP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caakG_info;
           _sa8by::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8by::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaakW; else goto caakH;
       uaakW: // global
           call _caakG(R1) args: 0, res: 0, upd: 0;
       caakH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caakG() //  [R1]
         { info_tbl: [(caakG,
                       label: block_caakG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caakG: // global
           if (R1 & 7 == 1) goto caakK; else goto caakL;
       caakK: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caakL: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8cf_entry() //  [R1]
         { info_tbl: [(caal9,
                       label: sat_sa8cf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caal9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caala; else goto caalb;
       caala: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caalb: // global
           I64[Sp - 8] = block_caal7_info;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.IO.Device.close_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _caal7() //  []
         { info_tbl: [(caal7,
                       label: block_caal7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caal7: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.hClose_help1_entry() //  [R2]
         { info_tbl: [(caald,
                       label: GHC.IO.Handle.Internals.hClose_help1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caald: // global
           if ((Sp + -144) < SpLim) (likely: False) goto caale; else goto caalf;
       caale: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caalf: // global
           I64[Sp - 8] = block_caaiI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaamu; else goto caaiJ;
       uaamu: // global
           call _caaiI(R1) args: 0, res: 0, upd: 0;
       caaiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaiI() //  [R1]
         { info_tbl: [(caaiI,
                       label: block_caaiI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaiI: // global
           I64[Sp - 128] = block_caaiN_info;
           _sa8aJ::P64 = R1;
           _sa8aK::P64 = P64[R1 + 7];
           _sa8aL::P64 = P64[R1 + 15];
           _sa8aM::P64 = P64[R1 + 23];
           _sa8aN::P64 = P64[R1 + 31];
           _sa8aP::P64 = P64[R1 + 47];
           _sa8aQ::P64 = P64[R1 + 55];
           _sa8aR::P64 = P64[R1 + 63];
           _sa8aS::P64 = P64[R1 + 71];
           _sa8aT::P64 = P64[R1 + 79];
           _sa8aU::P64 = P64[R1 + 87];
           _sa8aV::P64 = P64[R1 + 95];
           _sa8aW::P64 = P64[R1 + 103];
           _sa8aX::P64 = P64[R1 + 111];
           _sa8aY::P64 = P64[R1 + 119];
           _sa8aZ::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sa8aK::P64;
           P64[Sp - 112] = _sa8aL::P64;
           P64[Sp - 104] = _sa8aM::P64;
           P64[Sp - 96] = _sa8aN::P64;
           P64[Sp - 88] = _sa8aP::P64;
           P64[Sp - 80] = _sa8aQ::P64;
           P64[Sp - 72] = _sa8aR::P64;
           P64[Sp - 64] = _sa8aS::P64;
           P64[Sp - 56] = _sa8aT::P64;
           P64[Sp - 48] = _sa8aU::P64;
           P64[Sp - 40] = _sa8aV::P64;
           P64[Sp - 32] = _sa8aW::P64;
           P64[Sp - 24] = _sa8aX::P64;
           P64[Sp - 16] = _sa8aY::P64;
           P64[Sp - 8] = _sa8aZ::P64;
           P64[Sp] = _sa8aJ::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto uaamq; else goto caaiO;
       uaamq: // global
           call _caaiN(R1) args: 0, res: 0, upd: 0;
       caaiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaiN() //  [R1]
         { info_tbl: [(caaiN,
                       label: block_caaiN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaiN: // global
           if (R1 & 7 == 1) goto caame; else goto caali;
       caame: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caamh; else goto caamg;
       caamh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caamg: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caali: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caall; else goto caalk;
       caall: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caalk: // global
           I64[Hp - 24] = sat_sa8bs_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_caajI_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caajI() //  [R1]
         { info_tbl: [(caajI,
                       label: block_caajI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caajI: // global
           I64[Sp] = block_caakX_info;
           _sa8bv::P64 = R1;
           R1 = P64[Sp + 120];
           P64[Sp + 128] = _sa8bv::P64;
           if (R1 & 7 != 0) goto uaamr; else goto caakY;
       uaamr: // global
           call _caakX(R1) args: 0, res: 0, upd: 0;
       caakY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caakX() //  [R1]
         { info_tbl: [(caakX,
                       label: block_caakX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caakX: // global
           if (R1 & 7 == 1) goto caam1; else goto caama;
       caam1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caam4; else goto caam3;
       caam4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caam3: // global
           I64[Hp - 16] = sat_sa8cf_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_caalZ_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       caama: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _sa8bw() args: 0, res: 0, upd: 0;
     }
 },
 _caalZ() //  [R1]
         { info_tbl: [(caalZ,
                       label: block_caalZ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caalZ: // global
           P64[Sp] = R1;
           call _sa8bw() args: 0, res: 0, upd: 0;
     }
 },
 _sa8bw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8bw: // global
           _sa8aP::P64 = P64[Sp + 40];
           _sa8aS::P64 = P64[Sp + 64];
           _sa8aT::P64 = P64[Sp + 72];
           _sa8aV::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sa8aT::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aT::P64);
           call MO_WriteBarrier();
           P64[_sa8aS::P64 + 8] = GHC.IO.Handle.Internals.noCharBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aS::P64);
           call MO_WriteBarrier();
           P64[_sa8aP::P64 + 8] = GHC.IO.Handle.Internals.noByteBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aP::P64);
           I64[Sp - 8] = block_caaln_info;
           R1 = _sa8aV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaamz; else goto caalF;
       uaamz: // global
           call _caaln(R1) args: 0, res: 0, upd: 0;
       caalF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaln() //  [R1]
         { info_tbl: [(caaln,
                       label: block_caaln_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaln: // global
           if (R1 & 7 == 1) goto uaamo; else goto caalV;
       uaamo: // global
           Sp = Sp + 8;
           call _sa8bC() args: 0, res: 0, upd: 0;
       caalV: // global
           I64[Sp] = block_caalO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaamv; else goto caalP;
       uaamv: // global
           call _caalO(R1) args: 0, res: 0, upd: 0;
       caalP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caalO() //  [R1]
         { info_tbl: [(caalO,
                       label: block_caalO_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caalO: // global
           I64[Sp] = block_caalT_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caalT() //  []
         { info_tbl: [(caalT,
                       label: block_caalT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caalT: // global
           Sp = Sp + 8;
           call _sa8bC() args: 0, res: 0, upd: 0;
     }
 },
 _sa8bC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8bC: // global
           I64[Sp - 8] = block_caak3_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaamA; else goto caak4;
       uaamA: // global
           call _caak3(R1) args: 0, res: 0, upd: 0;
       caak4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caak3() //  [R1]
         { info_tbl: [(caak3,
                       label: block_caak3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caak3: // global
           if (R1 & 7 == 1) goto caalt; else goto caalA;
       caalt: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto caalw; else goto caalv;
       caalw: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caalv: // global
           I64[Hp - 184] = sat_sa8bI_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = GHC.Base.Nothing_closure+1;
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caalA: // global
           I64[Sp] = block_caakv_info;
           _sa8bE::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 88] = _sa8bE::P64;
           if (R1 & 7 != 0) goto uaams; else goto caakw;
       uaams: // global
           call _caakv(R1) args: 0, res: 0, upd: 0;
       caakw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caakv() //  [R1]
         { info_tbl: [(caakv,
                       label: block_caakv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caakv: // global
           I64[Sp] = block_caakA_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caakA() //  [R1]
         { info_tbl: [(caakA,
                       label: block_caakA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caakA: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto caalE; else goto caalD;
       caalE: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caalD: // global
           I64[Hp - 184] = sat_sa8bX_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.129907193 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help_closure" {
     GHC.IO.Handle.Internals.hClose_help_closure:
         const GHC.IO.Handle.Internals.hClose_help_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hClose_help_entry() //  [R2]
         { info_tbl: [(caamF,
                       label: GHC.IO.Handle.Internals.hClose_help_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caamF: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.131015049 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer1_closure" {
     GHC.IO.Handle.Internals.handleFinalizer1_closure:
         const GHC.IO.Handle.Internals.handleFinalizer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer1_entry() //  [R2, R3]
         { info_tbl: [(caamP,
                       label: GHC.IO.Handle.Internals.handleFinalizer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caamP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caan2; else goto caan3;
       caan2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.handleFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caan3: // global
           I64[Sp - 8] = block_caamM_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaana; else goto caamN;
       uaana: // global
           call _caamM(R1) args: 0, res: 0, upd: 0;
       caamN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caamM() //  [R1]
         { info_tbl: [(caamM,
                       label: block_caamM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caamM: // global
           I64[Sp - 8] = block_caamS_info;
           _sa8cp::P64 = P64[R1 + 7];
           R1 = _sa8cp::P64;
           P64[Sp] = _sa8cp::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caamS() //  [R1]
         { info_tbl: [(caamS,
                       label: block_caamS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caamS: // global
           I64[Sp] = block_caamU_info;
           R2 = R1;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caamU() //  [R1]
         { info_tbl: [(caamU,
                       label: block_caamU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caamU: // global
           I64[Sp] = block_caamW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaanb; else goto caamX;
       uaanb: // global
           call _caamW(R1) args: 0, res: 0, upd: 0;
       caamX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caamW() //  [R1]
         { info_tbl: [(caamW,
                       label: block_caamW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caamW: // global
           _sa8cp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caan1_info;
           R2 = P64[R1 + 7];
           R1 = _sa8cp::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caan1() //  []
         { info_tbl: [(caan1,
                       label: block_caan1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caan1: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.132723593 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer_closure" {
     GHC.IO.Handle.Internals.handleFinalizer_closure:
         const GHC.IO.Handle.Internals.handleFinalizer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer_entry() //  [R2, R3]
         { info_tbl: [(caang,
                       label: GHC.IO.Handle.Internals.handleFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caang: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.handleFinalizer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.133519911 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle4_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.13481817 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle1_closure" {
     GHC.IO.Handle.Internals.mkFileHandle1_closure:
         const GHC.IO.Handle.Internals.mkFileHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caank: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sa8cK_entry() //  [R1]
         { info_tbl: [(caanB,
                       label: sat_sa8cK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caanB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caanC; else goto caanD;
       caanC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caanD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caans_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaanS; else goto caant;
       uaanS: // global
           call _caans(R1) args: 0, res: 0, upd: 0;
       caant: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caans() //  [R1]
         { info_tbl: [(caans,
                       label: block_caans_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caans: // global
           _caanA::P64 = R1 & 7;
           if (_caanA::P64 < 3) goto uaanQ; else goto uaanR;
       uaanQ: // global
           if (_caanA::P64 < 2) goto caanw; else goto caanx;
       caanw: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caanx: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaanR: // global
           if (_caanA::P64 < 4) goto caany; else goto caanz;
       caany: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caanz: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(caanT,
                       label: GHC.IO.Handle.Internals.mkFileHandle1_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caanT: // global
           _sa8cE::P64 = R6;
           _sa8cD::P64 = R5;
           _sa8cC::P64 = R4;
           _sa8cB::P64 = R3;
           _sa8cA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto caanU; else goto caanV;
       caanV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caanX; else goto caanW;
       caanX: // global
           HpAlloc = 24;
           goto caanU;
       caanU: // global
           R1 = GHC.IO.Handle.Internals.mkFileHandle1_closure;
           P64[Sp - 40] = _sa8cA::P64;
           P64[Sp - 32] = _sa8cB::P64;
           P64[Sp - 24] = _sa8cC::P64;
           P64[Sp - 16] = _sa8cD::P64;
           P64[Sp - 8] = _sa8cE::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caanW: // global
           I64[Hp - 16] = sat_sa8cK_info;
           P64[Hp] = P64[Sp];
           R6 = _sa8cE::P64;
           R5 = _sa8cD::P64;
           R4 = _sa8cC::P64;
           R3 = _sa8cB::P64;
           R2 = _sa8cA::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = GHC.Types.True_closure+2;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 8] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.137046784 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle_closure" {
     GHC.IO.Handle.Internals.mkFileHandle_closure:
         const GHC.IO.Handle.Internals.mkFileHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caanZ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(caao3,
                       label: GHC.IO.Handle.Internals.mkFileHandle_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caao3: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.138094987 UTC

[section ""cstring" . lvl23_ra7PD_bytes" {
     lvl23_ra7PD_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,54,58,51,45,51,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.138838484 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle3_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle3_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle3_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle3_entry() //  []
         { info_tbl: [(caaoc,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaoc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caaod; else goto caaoe;
       caaod: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaoe: // global
           I64[Sp - 8] = block_caaoa_info;
           R2 = lvl23_ra7PD_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaoa() //  [R1]
         { info_tbl: [(caaoa,
                       label: block_caaoa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaoa: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.139775794 UTC

[section ""cstring" . lvl24_ra7PE_bytes" {
     lvl24_ra7PE_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,48,58,51,45,51,53]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.140528912 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle2_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle2_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle2_entry() //  []
         { info_tbl: [(caaoo,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaoo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caaop; else goto caaoq;
       caaop: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaoq: // global
           I64[Sp - 8] = block_caaom_info;
           R2 = lvl24_ra7PE_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaom() //  [R1]
         { info_tbl: [(caaom,
                       label: block_caaom_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaom: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.142501329 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle1_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle1_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaov: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(caaoI,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle1_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaoI: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caaoJ; else goto caaoK;
       caaoJ: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       caaoK: // global
           I64[Sp - 48] = block_caaoz_info;
           _sa8cT::P64 = R6;
           R6 = R6;
           _sa8cS::P64 = R5;
           R5 = R5;
           _sa8cR::P64 = R4;
           R4 = R4;
           _sa8cQ::P64 = R3;
           R3 = R3;
           _sa8cP::P64 = R2;
           R2 = R2;
           P64[Sp - 96] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 88] = GHC.Types.True_closure+2;
           P64[Sp - 80] = P64[Sp];
           P64[Sp - 72] = P64[Sp + 8];
           P64[Sp - 64] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp - 56] = GHC.Base.Nothing_closure+1;
           P64[Sp - 40] = _sa8cP::P64;
           P64[Sp - 32] = _sa8cQ::P64;
           P64[Sp - 24] = _sa8cR::P64;
           P64[Sp - 16] = _sa8cS::P64;
           P64[Sp - 8] = _sa8cT::P64;
           Sp = Sp - 96;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
     }
 },
 _caaoz() //  [R1]
         { info_tbl: [(caaoz,
                       label: block_caaoz_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaoz: // global
           I64[Sp] = block_caaoB_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaapf; else goto caaoC;
       uaapf: // global
           call _caaoB(R1) args: 0, res: 0, upd: 0;
       caaoC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaoB() //  [R1]
         { info_tbl: [(caaoB,
                       label: block_caaoB_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaoB: // global
           if (R1 & 7 == 1) goto caaoF; else goto caaoG;
       caaoF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caaoV; else goto caaoU;
       caaoV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaoU: // global
           _sa8d2::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = _sa8d2::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           _sa8cS::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_caaoQ_info;
           R6 = P64[Sp + 40];
           R5 = _sa8cS::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp - 16] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 8] = P64[Sp + 56];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = Hp - 6;
           P64[Sp + 56] = _sa8d2::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
       caaoG: // global
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.mkDuplexHandle2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _caaoQ() //  [R1]
         { info_tbl: [(caaoQ,
                       label: block_caaoQ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaoQ: // global
           I64[Sp] = block_caaoS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaapg; else goto caaoX;
       uaapg: // global
           call _caaoS(R1) args: 0, res: 0, upd: 0;
       caaoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaoS() //  [R1]
         { info_tbl: [(caaoS,
                       label: block_caaoS_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaoS: // global
           if (R1 & 7 == 1) goto caap3; else goto caapa;
       caap3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caap6; else goto caap5;
       caap6: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caap5: // global
           _sa8da::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sa8da::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caapa: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle3_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.148625954 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caapi: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(caapm,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caapm: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.150556393 UTC

[section ""data" . $wlvl_ra7PF_closure" {
     $wlvl_ra7PF_closure:
         const $wlvl_ra7PF_info;
         const 0;
 },
 sat_sa8dy_entry() //  [R1]
         { info_tbl: [(caapI,
                       label: sat_sa8dy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caapI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caapJ; else goto caapK;
       caapJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caapK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caapB_info;
           _sa8dn::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8dn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaaqb; else goto caapC;
       uaaqb: // global
           call _caapB(R1) args: 0, res: 0, upd: 0;
       caapC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caapB() //  [R1]
         { info_tbl: [(caapB,
                       label: block_caapB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caapB: // global
           if (R1 & 7 == 1) goto caapF; else goto caapG;
       caapF: // global
           _sa8dn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caapN_info;
           R1 = _sa8dn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaaqa; else goto caapP;
       uaaqa: // global
           call _caapN(R1) args: 0, res: 0, upd: 0;
       caapP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caapG: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _caapN() //  [R1]
         { info_tbl: [(caapN,
                       label: block_caapN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caapN: // global
           if (R1 & 7 == 1) goto caapV; else goto caaq2;
       caapV: // global
           Hp = Hp + 16;
           _sa8dr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caaq5; else goto caapX;
       caapX: // global
           _sa8ds::P64 = P64[_sa8dr::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa8ds::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caaq2: // global
           Hp = Hp + 16;
           _sa8dr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caaq5; else goto caaq4;
       caaq5: // global
           HpAlloc = 16;
           R1 = _sa8dr::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caaq4: // global
           _sa8du::P64 = P64[_sa8dr::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa8du::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8dA_entry() //  [R1]
         { info_tbl: [(caaqe,
                       label: sat_sa8dA_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqe: // global
           _sa8dA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaqf; else goto caaqg;
       caaqg: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caaqi; else goto caaqh;
       caaqi: // global
           HpAlloc = 104;
           goto caaqf;
       caaqf: // global
           R1 = _sa8dA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaqh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa8dA::P64;
           _sa8di::P64 = P64[_sa8dA::P64 + 16];
           _sa8dj::P64 = P64[_sa8dA::P64 + 24];
           _sa8dk::P64 = P64[_sa8dA::P64 + 32];
           _sa8dl::P64 = P64[_sa8dA::P64 + 40];
           _sa8dm::P64 = P64[_sa8dA::P64 + 48];
           _sa8dn::P64 = P64[_sa8dA::P64 + 56];
           I64[Hp - 96] = sat_sa8dy_info;
           P64[Hp - 80] = _sa8dl::P64;
           P64[Hp - 72] = _sa8dn::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa8dn::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sa8di::P64;
           P64[Hp - 24] = _sa8dm::P64;
           P64[Hp - 16] = _sa8dj::P64;
           P64[Hp - 8] = _sa8dk::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_ra7PF_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caaqj,
                       label: $wlvl_ra7PF_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caaqn; else goto caaqm;
       caaqn: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_ra7PF_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caaqm: // global
           I64[Hp - 56] = sat_sa8dA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 56;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.154165546 UTC

[section ""data" . GHC.IO.Handle.Internals.$wdo_operation_closure" {
     GHC.IO.Handle.Internals.$wdo_operation_closure:
         const GHC.IO.Handle.Internals.$wdo_operation_info;
         const 0;
 },
 sat_sa8e5_entry() //  [R1, R2]
         { info_tbl: [(caaqG,
                       label: sat_sa8e5_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqG: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caaqK; else goto caaqL;
       caaqK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaqL: // global
           I64[Sp - 48] = block_caaqB_info;
           _sa8dK::P64 = R2;
           R2 = P64[R1 + 38];
           _sa8dB::P64 = P64[R1 + 6];
           _sa8dC::P64 = P64[R1 + 14];
           _sa8dD::P64 = P64[R1 + 22];
           _sa8dE::P64 = P64[R1 + 30];
           R1 = _sa8dE::P64;
           P64[Sp - 40] = _sa8dB::P64;
           P64[Sp - 32] = _sa8dC::P64;
           P64[Sp - 24] = _sa8dD::P64;
           P64[Sp - 16] = _sa8dE::P64;
           P64[Sp - 8] = _sa8dK::P64;
           Sp = Sp - 48;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaqB() //  []
         { info_tbl: [(caaqB,
                       label: block_caaqB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqB: // global
           I64[Sp] = block_caaqD_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto uaart; else goto caaqE;
       uaart: // global
           call _caaqD(R1) args: 0, res: 0, upd: 0;
       caaqE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaqD() //  [R1]
         { info_tbl: [(caaqD,
                       label: block_caaqD_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqD: // global
           I64[Sp - 16] = block_caaqJ_info;
           _sa8dO::P64 = P64[R1 + 7];
           R2 = _sa8dO::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sa8dO::P64;
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaqJ() //  [R1]
         { info_tbl: [(caaqJ,
                       label: block_caaqJ_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqJ: // global
           I64[Sp] = block_caaqR_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaqR() //  [R1]
         { info_tbl: [(caaqR,
                       label: block_caaqR_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqR: // global
           if (R1 & 7 == 1) goto caaqZ; else goto caarm;
       caaqZ: // global
           _sa8dO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caaqW_info;
           R2 = _sa8dO::P64;
           Sp = Sp + 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       caarm: // global
           I64[Sp + 16] = block_caark_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaqW() //  [R1]
         { info_tbl: [(caaqW,
                       label: block_caaqW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqW: // global
           I64[Sp] = block_caar3_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _caar3() //  [R1]
         { info_tbl: [(caar3,
                       label: block_caar3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caar3: // global
           _sa8dN::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto caara; else goto caarf;
       caara: // global
           R1 = _sa8dN::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caarf: // global
           I64[Sp] = block_caard_info;
           R2 = _sa8dN::P64;
           R1 = CurrentTSO;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caard() //  []
         { info_tbl: [(caard,
                       label: block_caard_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caard: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _caark() //  [R1]
         { info_tbl: [(caark,
                       label: block_caark_info
                       rep:StackRep [False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caark: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 47];
           R4 = P64[R1 + 39];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 15];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 40;
           call $wlvl_ra7PF_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wdo_operation_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caaru,
                       label: GHC.IO.Handle.Internals.$wdo_operation_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaru: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caarv; else goto caarw;
       caarv: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wdo_operation_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caarw: // global
           I64[Sp - 40] = block_caaqs_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaqs() //  [R1]
         { info_tbl: [(caaqs,
                       label: block_caaqs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqs: // global
           I64[Sp - 8] = block_caaqu_info;
           R2 = R1;
           _sa8dI::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _sa8dI::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaqu() //  [R1]
         { info_tbl: [(caaqu,
                       label: block_caaqu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaqu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caarA; else goto caarz;
       caarA: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caarz: // global
           I64[Hp - 40] = sat_sa8e5_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 38;
           R1 = R1;
           Sp = Sp + 48;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.157497154 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_1_closure" {
     GHC.IO.Handle.Internals.withHandle_1_closure:
         const GHC.IO.Handle.Internals.withHandle_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caarI,
                       label: GHC.IO.Handle.Internals.withHandle_1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caarI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caarJ; else goto caarK;
       caarJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caarK: // global
           I64[Sp - 32] = block_caarF_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaarO; else goto caarG;
       uaarO: // global
           call _caarF(R1) args: 0, res: 0, upd: 0;
       caarG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caarF() //  [R1]
         { info_tbl: [(caarF,
                       label: block_caarF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caarF: // global
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.15920782 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle__'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle__'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle__'_info;
         const 0;
 },
 sat_sa8ev_entry() //  [R1]
         { info_tbl: [(caas7,
                       label: sat_sa8ev_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caas7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caas8; else goto caas9;
       caas8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caas9: // global
           I64[Sp - 16] = block_caas3_info;
           _sa8ef::P64 = P64[R1 + 23];
           R5 = _sa8ef::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8ef::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caas3() //  [R1]
         { info_tbl: [(caas3,
                       label: block_caas3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caas3: // global
           _sa8ef::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caas5_info;
           R2 = R1;
           R1 = _sa8ef::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caas5() //  []
         { info_tbl: [(caas5,
                       label: block_caas5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caas5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwithHandle__'_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(caasf,
                       label: GHC.IO.Handle.Internals.$wwithHandle__'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caasf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caasg; else goto caash;
       caasg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle__'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caash: // global
           I64[Sp - 40] = block_caarT_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caarT() //  [R1]
         { info_tbl: [(caarT,
                       label: block_caarT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caarT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caask; else goto caasj;
       caask: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caasj: // global
           _sa8ed::P64 = P64[Sp + 8];
           _sa8ee::P64 = P64[Sp + 16];
           _sa8ef::P64 = P64[Sp + 24];
           _sa8eg::P64 = P64[Sp + 32];
           if (R1 == 0) goto caase; else goto caasd;
       caase: // global
           I64[Hp - 32] = sat_sa8ev_info;
           P64[Hp - 24] = _sa8ed::P64;
           P64[Hp - 16] = _sa8ee::P64;
           P64[Hp - 8] = _sa8ef::P64;
           P64[Hp] = _sa8eg::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caasd: // global
           Hp = Hp - 40;
           I64[Sp + 16] = block_caasl_info;
           R5 = _sa8ef::P64;
           R4 = _sa8eg::P64;
           R3 = _sa8ee::P64;
           R2 = _sa8ed::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caasl() //  [R1]
         { info_tbl: [(caasl,
                       label: block_caasl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caasl: // global
           I64[Sp + 16] = block_caasn_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caasn() //  []
         { info_tbl: [(caasn,
                       label: block_caasn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caasn: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.161489511 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'1_closure" {
     GHC.IO.Handle.Internals.withHandle__'1_closure:
         const GHC.IO.Handle.Internals.withHandle__'1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caasy,
                       label: GHC.IO.Handle.Internals.withHandle__'1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caasy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caasz; else goto caasA;
       caasz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle__'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caasA: // global
           I64[Sp - 32] = block_caasv_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaasE; else goto caasw;
       uaasE: // global
           call _caasv(R1) args: 0, res: 0, upd: 0;
       caasw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caasv() //  [R1]
         { info_tbl: [(caasv,
                       label: block_caasv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caasv: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.162679437 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'_closure" {
     GHC.IO.Handle.Internals.withHandle__'_closure:
         const GHC.IO.Handle.Internals.withHandle__'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caasJ,
                       label: GHC.IO.Handle.Internals.withHandle__'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caasJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle__'1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.165112567 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles__1_closure" {
     GHC.IO.Handle.Internals.withAllHandles__1_closure:
         const GHC.IO.Handle.Internals.withAllHandles__1_info;
         const 0;
 },
 sat_sa8eX_entry() //  [R1]
         { info_tbl: [(caat9,
                       label: sat_sa8eX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caat9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caata; else goto caatb;
       caata: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caatb: // global
           I64[Sp - 16] = block_caat5_info;
           _sa8eJ::P64 = P64[R1 + 31];
           R5 = _sa8eJ::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8eJ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caat5() //  [R1]
         { info_tbl: [(caat5,
                       label: block_caat5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caat5: // global
           _sa8eJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caat7_info;
           R2 = R1;
           R1 = _sa8eJ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caat7() //  []
         { info_tbl: [(caat7,
                       label: block_caat7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caat7: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8fj_entry() //  [R1]
         { info_tbl: [(caatB,
                       label: sat_sa8fj_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caatB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caatC; else goto caatD;
       caatC: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caatD: // global
           I64[Sp - 16] = block_caatx_info;
           _sa8f0::P64 = P64[R1 + 31];
           R5 = _sa8f0::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8f0::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caatx() //  [R1]
         { info_tbl: [(caatx,
                       label: block_caatx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caatx: // global
           _sa8f0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caatz_info;
           R2 = R1;
           R1 = _sa8f0::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caatz() //  []
         { info_tbl: [(caatz,
                       label: block_caatz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caatz: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8fu_entry() //  [R1]
         { info_tbl: [(caatS,
                       label: sat_sa8fu_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caatS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caatT; else goto caatU;
       caatT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caatU: // global
           I64[Sp - 16] = block_caatO_info;
           _sa8eZ::P64 = P64[R1 + 31];
           R5 = _sa8eZ::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8eZ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caatO() //  [R1]
         { info_tbl: [(caatO,
                       label: block_caatO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caatO: // global
           _sa8eZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caatQ_info;
           R2 = R1;
           R1 = _sa8eZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caatQ() //  []
         { info_tbl: [(caatQ,
                       label: block_caatQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caatQ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.withAllHandles__1_entry() //  [R2, R3, R4]
         { info_tbl: [(caau1,
                       label: GHC.IO.Handle.Internals.withAllHandles__1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caau1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caau2; else goto caau3;
       caau2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withAllHandles__1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caau3: // global
           I64[Sp - 24] = block_caasQ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaauK; else goto caasR;
       uaauK: // global
           call _caasQ(R1) args: 0, res: 0, upd: 0;
       caasR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caasQ() //  [R1]
         { info_tbl: [(caasQ,
                       label: block_caasQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caasQ: // global
           if (R1 & 7 == 1) goto caatY; else goto caatZ;
       caatY: // global
           I64[Sp - 16] = block_caasV_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caatZ: // global
           I64[Sp - 24] = block_caatg_info;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caasV() //  [R1]
         { info_tbl: [(caasV,
                       label: block_caasV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caasV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caau7; else goto caau6;
       caau7: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caau6: // global
           _sa8eD::P64 = P64[Sp + 24];
           _sa8eF::P64 = P64[Sp + 32];
           _sa8eH::P64 = P64[Sp + 16];
           _sa8eJ::P64 = P64[Sp + 8];
           if (R1 == 0) goto caaug; else goto caauc;
       caaug: // global
           I64[Hp - 32] = sat_sa8eX_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8eJ::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caauc: // global
           Hp = Hp - 40;
           I64[Sp] = block_caau8_info;
           R5 = _sa8eJ::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caau8() //  [R1]
         { info_tbl: [(caau8,
                       label: block_caau8_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caau8: // global
           I64[Sp + 32] = block_caaur_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caatg() //  [R1]
         { info_tbl: [(caatg,
                       label: block_caatg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caatg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caauk; else goto caauj;
       caauk: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caauj: // global
           _sa8eD::P64 = P64[Sp + 32];
           _sa8eF::P64 = P64[Sp + 40];
           _sa8eH::P64 = P64[Sp + 24];
           _sa8eZ::P64 = P64[Sp + 8];
           if (R1 == 0) goto caauH; else goto caauC;
       caauH: // global
           I64[Hp - 32] = sat_sa8fu_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8eZ::P64;
           I64[Sp + 8] = block_caauG_info;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       caauC: // global
           Hp = Hp - 40;
           I64[Sp] = block_caauy_info;
           R5 = _sa8eZ::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caauG() //  []
         { info_tbl: [(caauG,
                       label: block_caauG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caauG: // global
           call _sa8f4() args: 0, res: 0, upd: 0;
     }
 },
 _caauy() //  [R1]
         { info_tbl: [(caauy,
                       label: block_caauy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caauy: // global
           _sa8eZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_sa8f4_info;
           R2 = R1;
           R1 = _sa8eZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _sa8f4() //  []
         { info_tbl: [(sa8f4,
                       label: block_sa8f4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8f4: // global
           I64[Sp] = block_caatn_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caatn() //  [R1]
         { info_tbl: [(caatn,
                       label: block_caatn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caatn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caauo; else goto caaun;
       caauo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caaun: // global
           _sa8eD::P64 = P64[Sp + 24];
           _sa8eF::P64 = P64[Sp + 32];
           _sa8eH::P64 = P64[Sp + 16];
           _sa8f0::P64 = P64[Sp + 8];
           if (R1 == 0) goto caaux; else goto caaut;
       caaux: // global
           I64[Hp - 32] = sat_sa8fj_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8f0::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caaut: // global
           Hp = Hp - 40;
           I64[Sp] = block_caaup_info;
           R5 = _sa8f0::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaup() //  [R1]
         { info_tbl: [(caaup,
                       label: block_caaup_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaup: // global
           I64[Sp + 32] = block_caaur_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaur() //  []
         { info_tbl: [(caaur,
                       label: block_caaur_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaur: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.169980589 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles___closure" {
     GHC.IO.Handle.Internals.withAllHandles___closure:
         const GHC.IO.Handle.Internals.withAllHandles___info;
         const 0;
 },
 GHC.IO.Handle.Internals.withAllHandles___entry() //  [R2, R3, R4]
         { info_tbl: [(caauQ,
                       label: GHC.IO.Handle.Internals.withAllHandles___info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caauQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.171410369 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle'_info;
         const 0;
 },
 io_sa8fG_entry() //  [R1]
         { info_tbl: [(caav9,
                       label: io_sa8fG_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caav9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caavd; else goto caave;
       caavd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caave: // global
           I64[Sp - 16] = block_caav4_info;
           _sa8fA::P64 = P64[R1 + 23];
           R5 = _sa8fA::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8fA::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caav4() //  [R1]
         { info_tbl: [(caav4,
                       label: block_caav4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caav4: // global
           I64[Sp] = block_caav6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaavj; else goto caav7;
       uaavj: // global
           call _caav6(R1) args: 0, res: 0, upd: 0;
       caav7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caav6() //  [R1]
         { info_tbl: [(caav6,
                       label: block_caav6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caav6: // global
           I64[Sp] = block_caavc_info;
           R2 = P64[R1 + 7];
           _sa8fN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8fN::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caavc() //  []
         { info_tbl: [(caavc,
                       label: block_caavc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caavc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwithHandle'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caavo,
                       label: GHC.IO.Handle.Internals.$wwithHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caavo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caavp; else goto caavq;
       caavp: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caavq: // global
           I64[Sp - 40] = block_caauX_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caauX() //  [R1]
         { info_tbl: [(caauX,
                       label: block_caauX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caauX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caavt; else goto caavs;
       caavt: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caavs: // global
           I64[Hp - 32] = io_sa8fG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           _caauZ::P64 = Hp - 31;
           if (R1 == 0) goto caavn; else goto caavm;
       caavn: // global
           R1 = _caauZ::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caavm: // global
           R1 = _caauZ::P64;
           Sp = Sp + 40;
           call io_sa8fG_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.173551191 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle1_closure" {
     GHC.IO.Handle.Internals.withHandle1_closure:
         const GHC.IO.Handle.Internals.withHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caavB,
                       label: GHC.IO.Handle.Internals.withHandle1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caavB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caavC; else goto caavD;
       caavC: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caavD: // global
           I64[Sp - 32] = block_caavy_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaavH; else goto caavz;
       uaavH: // global
           call _caavy(R1) args: 0, res: 0, upd: 0;
       caavz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caavy() //  [R1]
         { info_tbl: [(caavy,
                       label: block_caavy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caavy: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.174802314 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle'_closure" {
     GHC.IO.Handle.Internals.withHandle'_closure:
         const GHC.IO.Handle.Internals.withHandle'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caavM,
                       label: GHC.IO.Handle.Internals.withHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caavM: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.176145343 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'1_closure" {
     GHC.IO.Handle.Internals.withHandle_'1_closure:
         const GHC.IO.Handle.Internals.withHandle_'1_info;
         const 0;
 },
 sat_sa8ga_entry() //  [R1, R2]
         { info_tbl: [(caaw6,
                       label: sat_sa8ga_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaw6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaw7; else goto caaw8;
       caaw7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaw8: // global
           I64[Sp - 16] = block_caaw3_info;
           _sa8g4::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8g4::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaw3() //  [R1]
         { info_tbl: [(caaw3,
                       label: block_caaw3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaw3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caawb; else goto caawa;
       caawb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caawa: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.withHandle_'1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caawc,
                       label: GHC.IO.Handle.Internals.withHandle_'1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caawc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caawd; else goto caawe;
       caawd: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caawe: // global
           I64[Sp - 32] = block_caavT_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaawi; else goto caavU;
       uaawi: // global
           call _caavT(R1) args: 0, res: 0, upd: 0;
       caavU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caavT() //  [R1]
         { info_tbl: [(caavT,
                       label: block_caavT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caavT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caawh; else goto caawg;
       caawh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caawg: // global
           _sa8g3::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sa8ga_info;
           P64[Hp] = P64[Sp + 24];
           R5 = Hp - 6;
           R4 = _sa8g3::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.177955578 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'_closure" {
     GHC.IO.Handle.Internals.withHandle_'_closure:
         const GHC.IO.Handle.Internals.withHandle_'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caawn,
                       label: GHC.IO.Handle.Internals.withHandle_'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caawn: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle_'1_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.180439503 UTC

[section ""data" . withHandle_2_ra7PG_closure" {
     withHandle_2_ra7PG_closure:
         const withHandle_2_ra7PG_info;
         const 0;
 },
 sat_sa8gt_entry() //  [R1, R2]
         { info_tbl: [(caawO,
                       label: sat_sa8gt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caawO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caawP; else goto caawQ;
       caawP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caawQ: // global
           I64[Sp - 16] = block_caawL_info;
           _sa8gn::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8gn::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caawL() //  [R1]
         { info_tbl: [(caawL,
                       label: block_caawL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caawL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caawT; else goto caawS;
       caawT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caawS: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8gl_entry() //  [R1]
         { info_tbl: [(caawZ,
                       label: io_sa8gl_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caawZ: // global
           _sa8gl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caax3; else goto caax4;
       caax4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caax6; else goto caax5;
       caax6: // global
           HpAlloc = 16;
           goto caax3;
       caax3: // global
           R1 = _sa8gl::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caax5: // global
           _sa8gb::P64 = P64[_sa8gl::P64 + 7];
           _sa8gd::P64 = P64[_sa8gl::P64 + 15];
           _sa8gf::P64 = P64[_sa8gl::P64 + 23];
           _sa8gh::P64 = P64[_sa8gl::P64 + 31];
           I64[Hp - 8] = sat_sa8gt_info;
           P64[Hp] = _sa8gd::P64;
           I64[Sp - 16] = block_caawU_info;
           R5 = _sa8gh::P64;
           R4 = Hp - 6;
           R3 = _sa8gf::P64;
           R2 = _sa8gb::P64;
           P64[Sp - 8] = _sa8gh::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caawU() //  [R1]
         { info_tbl: [(caawU,
                       label: block_caawU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caawU: // global
           I64[Sp] = block_caawW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaxb; else goto caawX;
       uaaxb: // global
           call _caawW(R1) args: 0, res: 0, upd: 0;
       caawX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caawW() //  [R1]
         { info_tbl: [(caawW,
                       label: block_caawW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caawW: // global
           I64[Sp] = block_caax2_info;
           R2 = P64[R1 + 7];
           _sa8gz::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8gz::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caax2() //  []
         { info_tbl: [(caax2,
                       label: block_caax2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caax2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8gQ_entry() //  [R1, R2]
         { info_tbl: [(caaxt,
                       label: sat_sa8gQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaxt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaxu; else goto caaxv;
       caaxu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaxv: // global
           I64[Sp - 16] = block_caaxq_info;
           _sa8gK::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8gK::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaxq() //  [R1]
         { info_tbl: [(caaxq,
                       label: block_caaxq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaxq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaxy; else goto caaxx;
       caaxy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaxx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8gI_entry() //  [R1]
         { info_tbl: [(caaxE,
                       label: io_sa8gI_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaxE: // global
           _sa8gI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaxI; else goto caaxJ;
       caaxJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caaxL; else goto caaxK;
       caaxL: // global
           HpAlloc = 16;
           goto caaxI;
       caaxI: // global
           R1 = _sa8gI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaxK: // global
           _sa8gb::P64 = P64[_sa8gI::P64 + 7];
           _sa8gd::P64 = P64[_sa8gI::P64 + 15];
           _sa8gf::P64 = P64[_sa8gI::P64 + 23];
           _sa8gD::P64 = P64[_sa8gI::P64 + 31];
           I64[Hp - 8] = sat_sa8gQ_info;
           P64[Hp] = _sa8gd::P64;
           I64[Sp - 16] = block_caaxz_info;
           R5 = _sa8gD::P64;
           R4 = Hp - 6;
           R3 = _sa8gf::P64;
           R2 = _sa8gb::P64;
           P64[Sp - 8] = _sa8gD::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaxz() //  [R1]
         { info_tbl: [(caaxz,
                       label: block_caaxz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaxz: // global
           I64[Sp] = block_caaxB_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaxQ; else goto caaxC;
       uaaxQ: // global
           call _caaxB(R1) args: 0, res: 0, upd: 0;
       caaxC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaxB() //  [R1]
         { info_tbl: [(caaxB,
                       label: block_caaxB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaxB: // global
           I64[Sp] = block_caaxH_info;
           R2 = P64[R1 + 7];
           _sa8gW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8gW::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaxH() //  []
         { info_tbl: [(caaxH,
                       label: block_caaxH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaxH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 withHandle_2_ra7PG_entry() //  [R2, R3, R4]
         { info_tbl: [(caaxV,
                       label: withHandle_2_ra7PG_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaxV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caaxW; else goto caaxX;
       caaxW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle_2_ra7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaxX: // global
           I64[Sp - 24] = block_caawu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaye; else goto caawv;
       uaaye: // global
           call _caawu(R1) args: 0, res: 0, upd: 0;
       caawv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caawu() //  [R1]
         { info_tbl: [(caawu,
                       label: block_caawu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caawu: // global
           if (R1 & 7 == 1) goto caaxS; else goto caaxT;
       caaxS: // global
           I64[Sp - 16] = block_caawz_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caaxT: // global
           I64[Sp - 16] = block_caaxe_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caawz() //  [R1]
         { info_tbl: [(caawz,
                       label: block_caawz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caawz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caay1; else goto caay0;
       caay1: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caay0: // global
           I64[Hp - 32] = io_sa8gl_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caawB::P64 = Hp - 31;
           if (R1 == 0) goto caay5; else goto caay4;
       caay5: // global
           R1 = _caawB::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caay4: // global
           R1 = _caawB::P64;
           Sp = Sp + 40;
           call io_sa8gl_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaxe() //  [R1]
         { info_tbl: [(caaxe,
                       label: block_caaxe_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaxe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caay9; else goto caay8;
       caay9: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caay8: // global
           I64[Hp - 32] = io_sa8gI_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caaxg::P64 = Hp - 31;
           if (R1 == 0) goto caayd; else goto caayc;
       caayd: // global
           R1 = _caaxg::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caayc: // global
           R1 = _caaxg::P64;
           Sp = Sp + 40;
           call io_sa8gI_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.185036672 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__closure" {
     GHC.IO.Handle.Internals.withHandle__closure:
         const GHC.IO.Handle.Internals.withHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__entry() //  [R2, R3, R4]
         { info_tbl: [(caayj,
                       label: GHC.IO.Handle.Internals.withHandle__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caayj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle_2_ra7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.187497931 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_1_info;
         const 0;
 },
 sat_sa8hh_entry() //  [R1, R2]
         { info_tbl: [(caayK,
                       label: sat_sa8hh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caayK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caayL; else goto caayM;
       caayL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caayM: // global
           I64[Sp - 16] = block_caayH_info;
           R3 = R2;
           _sa8hb::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sa8hb::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caayH() //  [R1]
         { info_tbl: [(caayH,
                       label: block_caayH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caayH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caayP; else goto caayO;
       caayP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caayO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8h9_entry() //  [R1]
         { info_tbl: [(caayV,
                       label: io_sa8h9_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caayV: // global
           _sa8h9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caayZ; else goto caaz0;
       caaz0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caaz2; else goto caaz1;
       caaz2: // global
           HpAlloc = 16;
           goto caayZ;
       caayZ: // global
           R1 = _sa8h9::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaz1: // global
           _sa8gZ::P64 = P64[_sa8h9::P64 + 7];
           _sa8h1::P64 = P64[_sa8h9::P64 + 15];
           _sa8h3::P64 = P64[_sa8h9::P64 + 23];
           _sa8h5::P64 = P64[_sa8h9::P64 + 31];
           I64[Hp - 8] = sat_sa8hh_info;
           P64[Hp] = _sa8h1::P64;
           I64[Sp - 16] = block_caayQ_info;
           R5 = _sa8h5::P64;
           R4 = Hp - 6;
           R3 = _sa8h3::P64;
           R2 = _sa8gZ::P64;
           P64[Sp - 8] = _sa8h5::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caayQ() //  [R1]
         { info_tbl: [(caayQ,
                       label: block_caayQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caayQ: // global
           I64[Sp] = block_caayS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaz7; else goto caayT;
       uaaz7: // global
           call _caayS(R1) args: 0, res: 0, upd: 0;
       caayT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caayS() //  [R1]
         { info_tbl: [(caayS,
                       label: block_caayS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caayS: // global
           I64[Sp] = block_caayY_info;
           R2 = P64[R1 + 7];
           _sa8hn::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8hn::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caayY() //  []
         { info_tbl: [(caayY,
                       label: block_caayY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caayY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8hE_entry() //  [R1, R2]
         { info_tbl: [(caazp,
                       label: sat_sa8hE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caazp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caazq; else goto caazr;
       caazq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caazr: // global
           I64[Sp - 16] = block_caazm_info;
           R3 = R2;
           _sa8hy::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sa8hy::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caazm() //  [R1]
         { info_tbl: [(caazm,
                       label: block_caazm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caazm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caazu; else goto caazt;
       caazu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caazt: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8hw_entry() //  [R1]
         { info_tbl: [(caazA,
                       label: io_sa8hw_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caazA: // global
           _sa8hw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caazE; else goto caazF;
       caazF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caazH; else goto caazG;
       caazH: // global
           HpAlloc = 16;
           goto caazE;
       caazE: // global
           R1 = _sa8hw::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caazG: // global
           _sa8gZ::P64 = P64[_sa8hw::P64 + 7];
           _sa8h1::P64 = P64[_sa8hw::P64 + 15];
           _sa8h3::P64 = P64[_sa8hw::P64 + 23];
           _sa8hr::P64 = P64[_sa8hw::P64 + 31];
           I64[Hp - 8] = sat_sa8hE_info;
           P64[Hp] = _sa8h1::P64;
           I64[Sp - 16] = block_caazv_info;
           R5 = _sa8hr::P64;
           R4 = Hp - 6;
           R3 = _sa8h3::P64;
           R2 = _sa8gZ::P64;
           P64[Sp - 8] = _sa8hr::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caazv() //  [R1]
         { info_tbl: [(caazv,
                       label: block_caazv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caazv: // global
           I64[Sp] = block_caazx_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaazM; else goto caazy;
       uaazM: // global
           call _caazx(R1) args: 0, res: 0, upd: 0;
       caazy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caazx() //  [R1]
         { info_tbl: [(caazx,
                       label: block_caazx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caazx: // global
           I64[Sp] = block_caazD_info;
           R2 = P64[R1 + 7];
           _sa8hK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8hK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caazD() //  []
         { info_tbl: [(caazD,
                       label: block_caazD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caazD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle_1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(caazR,
                       label: GHC.IO.Handle.Internals.wantReadableHandle_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caazR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caazS; else goto caazT;
       caazS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caazT: // global
           I64[Sp - 24] = block_caayq_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaAa; else goto caayr;
       uaaAa: // global
           call _caayq(R1) args: 0, res: 0, upd: 0;
       caayr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caayq() //  [R1]
         { info_tbl: [(caayq,
                       label: block_caayq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caayq: // global
           if (R1 & 7 == 1) goto caazO; else goto caazP;
       caazO: // global
           I64[Sp - 16] = block_caayv_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caazP: // global
           I64[Sp - 16] = block_caaza_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caayv() //  [R1]
         { info_tbl: [(caayv,
                       label: block_caayv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caayv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caazX; else goto caazW;
       caazX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caazW: // global
           I64[Hp - 32] = io_sa8h9_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caayx::P64 = Hp - 31;
           if (R1 == 0) goto caaA1; else goto caaA0;
       caaA1: // global
           R1 = _caayx::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caaA0: // global
           R1 = _caayx::P64;
           Sp = Sp + 40;
           call io_sa8h9_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaza() //  [R1]
         { info_tbl: [(caaza,
                       label: block_caaza_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaza: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caaA5; else goto caaA4;
       caaA5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caaA4: // global
           I64[Hp - 32] = io_sa8hw_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caazc::P64 = Hp - 31;
           if (R1 == 0) goto caaA9; else goto caaA8;
       caaA9: // global
           R1 = _caazc::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caaA8: // global
           R1 = _caazc::P64;
           Sp = Sp + 40;
           call io_sa8hw_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.192051744 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle__closure" {
     GHC.IO.Handle.Internals.wantReadableHandle__closure:
         const GHC.IO.Handle.Internals.wantReadableHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle__entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(caaAf,
                       label: GHC.IO.Handle.Internals.wantReadableHandle__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaAf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.193141475 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle2_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle2_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle2_info;
         const 0;
 },
 sat_sa8hS_entry() //  [R1]
         { info_tbl: [(caaAs,
                       label: sat_sa8hS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaAs: // global
           _sa8hS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaAt; else goto caaAu;
       caaAu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caaAw; else goto caaAv;
       caaAw: // global
           HpAlloc = 72;
           goto caaAt;
       caaAt: // global
           R1 = _sa8hS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaAv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa8hS::P64;
           _sa8hN::P64 = P64[_sa8hS::P64 + 16];
           _sa8hO::P64 = P64[_sa8hS::P64 + 24];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa8hO::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = _sa8hN::P64;
           P64[Hp - 16] = GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.wantSeekableHandle2_entry() //  [R2, R3]
         { info_tbl: [(caaAx,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaAx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caaAB; else goto caaAA;
       caaAB: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caaAA: // global
           I64[Hp - 24] = sat_sa8hS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.196014722 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle1_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle1_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle1_info;
         const 0;
 },
 sat_sa8iB_entry() //  [R1, R2]
         { info_tbl: [(caaB0,
                       label: sat_sa8iB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaB0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caaB1; else goto caaB2;
       caaB1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaB2: // global
           I64[Sp - 16] = block_caaAX_info;
           _sa8hV::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sa8hV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaaBS; else goto caaAY;
       uaaBS: // global
           call _caaAX(R1) args: 0, res: 0, upd: 0;
       caaAY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaAX() //  [R1]
         { info_tbl: [(caaAX,
                       label: block_caaAX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaAX: // global
           I64[Sp - 24] = block_caaB5_info;
           _sa8i7::P64 = R1;
           _sa8i8::P64 = P64[R1 + 7];
           _sa8ib::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sa8i8::P64;
           P64[Sp - 8] = _sa8ib::P64;
           P64[Sp] = _sa8i7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaBR; else goto caaB7;
       uaaBR: // global
           call _caaB5(R1) args: 0, res: 0, upd: 0;
       caaB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaB5() //  [R1]
         { info_tbl: [(caaB5,
                       label: block_caaB5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaB5: // global
           _caaBL::P64 = R1 & 7;
           if (_caaBL::P64 < 3) goto uaaBN; else goto uaaBO;
       uaaBN: // global
           if (_caaBL::P64 < 2) goto caaBC; else goto caaBG;
       caaBC: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caaBG: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uaaBO: // global
           if (_caaBL::P64 != 5) goto caaBg; else goto uaaBP;
       caaBg: // global
           _sa8ib::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caaBb_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sa8ib::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
       uaaBP: // global
           Sp = Sp + 40;
           call _caaBK() args: 0, res: 0, upd: 0;
     }
 },
 _caaBb() //  [R1]
         { info_tbl: [(caaBb,
                       label: block_caaBb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaBb: // global
           I64[Sp] = block_caaBd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaBU; else goto caaBi;
       uaaBU: // global
           call _caaBd(R1) args: 0, res: 0, upd: 0;
       caaBi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaBd() //  [R1]
         { info_tbl: [(caaBd,
                       label: block_caaBd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaBd: // global
           if (R1 & 7 == 1) goto uaaBQ; else goto caaBv;
       uaaBQ: // global
           Sp = Sp + 24;
           call _caaBK() args: 0, res: 0, upd: 0;
       caaBv: // global
           I64[Sp] = block_caaBr_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaBr() //  [R1]
         { info_tbl: [(caaBr,
                       label: block_caaBr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaBr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaBy; else goto caaBx;
       caaBy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaBx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaBK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaBK: // global
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8i3_entry() //  [R1]
         { info_tbl: [(caaC1,
                       label: io_sa8i3_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaC1: // global
           _sa8i3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaC5; else goto caaC6;
       caaC6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caaC8; else goto caaC7;
       caaC8: // global
           HpAlloc = 16;
           goto caaC5;
       caaC5: // global
           R1 = _sa8i3::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaC7: // global
           _sa8hT::P64 = P64[_sa8i3::P64 + 7];
           _sa8hV::P64 = P64[_sa8i3::P64 + 15];
           _sa8hX::P64 = P64[_sa8i3::P64 + 23];
           _sa8hZ::P64 = P64[_sa8i3::P64 + 31];
           I64[Hp - 8] = sat_sa8iB_info;
           P64[Hp] = _sa8hV::P64;
           I64[Sp - 16] = block_caaBW_info;
           R5 = _sa8hZ::P64;
           R4 = Hp - 6;
           R3 = _sa8hX::P64;
           R2 = _sa8hT::P64;
           P64[Sp - 8] = _sa8hZ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaBW() //  [R1]
         { info_tbl: [(caaBW,
                       label: block_caaBW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaBW: // global
           I64[Sp] = block_caaBY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaCd; else goto caaBZ;
       uaaCd: // global
           call _caaBY(R1) args: 0, res: 0, upd: 0;
       caaBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaBY() //  [R1]
         { info_tbl: [(caaBY,
                       label: block_caaBY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaBY: // global
           I64[Sp] = block_caaC4_info;
           R2 = P64[R1 + 7];
           _sa8iH::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8iH::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaC4() //  []
         { info_tbl: [(caaC4,
                       label: block_caaC4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaC4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantSeekableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(caaCi,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaCi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caaCj; else goto caaCk;
       caaCj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaCk: // global
           I64[Sp - 24] = block_caaAG_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaCw; else goto caaAH;
       uaaCw: // global
           call _caaAG(R1) args: 0, res: 0, upd: 0;
       caaAH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaAG() //  [R1]
         { info_tbl: [(caaAG,
                       label: block_caaAG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaAG: // global
           if (R1 & 7 == 1) goto caaCf; else goto caaCg;
       caaCf: // global
           I64[Sp - 16] = block_caaAL_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caaCg: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.wantSeekableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _caaAL() //  [R1]
         { info_tbl: [(caaAL,
                       label: block_caaAL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaAL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caaCo; else goto caaCn;
       caaCo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caaCn: // global
           I64[Hp - 32] = io_sa8i3_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caaAN::P64 = Hp - 31;
           if (R1 == 0) goto caaCs; else goto caaCr;
       caaCs: // global
           R1 = _caaAN::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caaCr: // global
           R1 = _caaAN::P64;
           Sp = Sp + 40;
           call io_sa8i3_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.200028591 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(caaCB,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaCB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.204544991 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwantWritableHandle'_closure" {
     GHC.IO.Handle.Internals.$wwantWritableHandle'_closure:
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_info;
         const 0;
 },
 sat_sa8jT_entry() //  [R1]
         { info_tbl: [(caaDu,
                       label: sat_sa8jT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaDu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaDy; else goto caaDz;
       caaDy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaDz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caaDr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaDD; else goto caaDs;
       uaaDD: // global
           call _caaDr(R1) args: 0, res: 0, upd: 0;
       caaDs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caaDr() //  [R1]
         { info_tbl: [(caaDr,
                       label: block_caaDr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaDr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caaDC; else goto caaDB;
       caaDC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caaDB: // global
           _sa8jO::P64 = P64[R1 + 7];
           _sa8jN::I64 = I64[R1 + 23];
           _sa8jQ::I64 = I64[R1 + 31];
           _sa8jR::I64 = I64[R1 + 39];
           _sa8jS::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8jO::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sa8jN::I64;
           I64[Hp - 16] = _sa8jQ::I64;
           I64[Hp - 8] = _sa8jR::I64;
           I64[Hp] = _sa8jS::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8ko_entry() //  [R1]
         { info_tbl: [(caaDY,
                       label: sat_sa8ko_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaDY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaE2; else goto caaE3;
       caaE2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaE3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caaDV_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaE7; else goto caaDW;
       uaaE7: // global
           call _caaDV(R1) args: 0, res: 0, upd: 0;
       caaDW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caaDV() //  [R1]
         { info_tbl: [(caaDV,
                       label: block_caaDV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaDV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caaE6; else goto caaE5;
       caaE6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caaE5: // global
           _sa8kj::P64 = P64[R1 + 7];
           _sa8kk::P64 = P64[R1 + 15];
           _sa8ki::I64 = I64[R1 + 23];
           _sa8kl::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8kj::P64;
           P64[Hp - 32] = _sa8kk::P64;
           I64[Hp - 24] = _sa8ki::I64;
           I64[Hp - 16] = _sa8kl::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8kH_entry() //  [R1]
         { info_tbl: [(caaEu,
                       label: sat_sa8kH_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaEu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caaEB; else goto caaEC;
       caaEB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaEC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caaEr_info;
           _sa8kx::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa8kx::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaaEG; else goto caaEs;
       uaaEG: // global
           call _caaEr(R1) args: 0, res: 0, upd: 0;
       caaEs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caaEr() //  [R1]
         { info_tbl: [(caaEr,
                       label: block_caaEr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaEr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caaEF; else goto caaEE;
       caaEF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caaEE: // global
           _sa8kB::P64 = P64[R1 + 7];
           _sa8kC::P64 = P64[R1 + 15];
           _sa8kA::I64 = I64[R1 + 23];
           _sa8kD::I64 = I64[R1 + 31];
           _sa8kF::I64 = I64[R1 + 47];
           _sa8kG::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8kB::P64;
           P64[Hp - 32] = _sa8kC::P64;
           I64[Hp - 24] = _sa8kA::I64;
           I64[Hp - 16] = _sa8kD::I64;
           I64[Hp - 8] = _sa8kG::I64;
           I64[Hp] = _sa8kF::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uaaH6_srtd" {
     uaaH6_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 sat_sa8l6_entry() //  [R1, R2]
         { info_tbl: [(caaEH,
                       label: sat_sa8l6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaEH: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caaEI; else goto caaEJ;
       caaEI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaEJ: // global
           I64[Sp - 16] = block_caaCN_info;
           _sa8iQ::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sa8iQ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaaGY; else goto caaCO;
       uaaGY: // global
           call _caaCN(R1) args: 0, res: 0, upd: 0;
       caaCO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaaH7_srtd" {
     uaaH7_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 _caaCN() //  [R1]
         { info_tbl: [(caaCN,
                       label: block_caaCN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaCN: // global
           I64[Sp - 56] = block_caaCS_info;
           _sa8iU::P64 = R1;
           _sa8iW::P64 = P64[R1 + 15];
           _sa8iY::P64 = P64[R1 + 31];
           _sa8j0::P64 = P64[R1 + 47];
           _sa8j2::P64 = P64[R1 + 63];
           _sa8j3::P64 = P64[R1 + 71];
           _sa8j6::P64 = P64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 48] = _sa8iW::P64;
           P64[Sp - 40] = _sa8iY::P64;
           P64[Sp - 32] = _sa8j0::P64;
           P64[Sp - 24] = _sa8j2::P64;
           P64[Sp - 16] = _sa8j3::P64;
           P64[Sp - 8] = _sa8j6::P64;
           P64[Sp] = _sa8iU::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaaGL; else goto caaCT;
       uaaGL: // global
           call _caaCS(R1) args: 0, res: 0, upd: 0;
       caaCT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaaH8_srtd" {
     uaaH8_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 _caaCS() //  [R1]
         { info_tbl: [(caaCS,
                       label: block_caaCS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaCS: // global
           _caaGp::P64 = R1 & 7;
           if (_caaGp::P64 < 4) goto uaaGD; else goto uaaGF;
       uaaGD: // global
           if (_caaGp::P64 < 3) goto uaaGE; else goto caaF3;
       uaaGE: // global
           if (_caaGp::P64 < 2) goto caaEX; else goto caaF0;
       caaEX: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caaF0: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caaF3: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uaaGF: // global
           if (_caaGp::P64 < 6) goto caaER; else goto caaF5;
       caaER: // global
           I64[Sp + 48] = block_caaEM_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       caaF5: // global
           _sa8jl::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_caaD1_info;
           R1 = _sa8jl::P64;
           if (R1 & 7 != 0) goto uaaGM; else goto caaD2;
       uaaGM: // global
           call _caaD1(R1) args: 0, res: 0, upd: 0;
       caaD2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaEM() //  [R1]
         { info_tbl: [(caaEM,
                       label: block_caaEM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaEM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaEU; else goto caaET;
       caaEU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaET: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaD1() //  [R1]
         { info_tbl: [(caaD1,
                       label: block_caaD1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaD1: // global
           I64[Sp] = block_caaD6_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaaGN; else goto caaD7;
       uaaGN: // global
           call _caaD6(R1) args: 0, res: 0, upd: 0;
       caaD7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaD6() //  [R1]
         { info_tbl: [(caaD6,
                       label: block_caaD6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaD6: // global
           if (R1 & 7 == 1) goto caaF9; else goto caaGl;
       caaF9: // global
           _sa8jw::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_caaDb_info;
           R1 = _sa8jw::P64;
           if (R1 & 7 != 0) goto uaaGO; else goto caaDc;
       uaaGO: // global
           call _caaDb(R1) args: 0, res: 0, upd: 0;
       caaDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caaGl: // global
           I64[Sp + 48] = block_caaGh_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaDb() //  [R1]
         { info_tbl: [(caaDb,
                       label: block_caaDb_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaDb: // global
           I64[Sp - 16] = block_caaDE_info;
           _sa8jC::I64 = I64[R1 + 39];
           _sa8jD::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa8jD::I64;
           I64[Sp] = _sa8jC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaaGP; else goto caaDF;
       uaaGP: // global
           call _caaDE(R1) args: 0, res: 0, upd: 0;
       caaDF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaDE() //  [R1]
         { info_tbl: [(caaDE,
                       label: block_caaDE_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaDE: // global
           if (R1 & 7 == 1) goto caaGa; else goto uaaGG;
       caaGa: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto uaaGH; else goto caaFw;
       uaaGH: // global
           Sp = Sp + 24;
           goto uaaGS;
       caaFw: // global
           _sa8ka::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp + 16] = block_caaDM_info;
           R1 = _sa8ka::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaaGQ; else goto caaDN;
       uaaGQ: // global
           call _caaDM(R1) args: 0, res: 0, upd: 0;
       caaDN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaaGG: // global
           Sp = Sp + 24;
           goto uaaGS;
       uaaGS: // global
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 _caaDM() //  [R1]
         { info_tbl: [(caaDM,
                       label: block_caaDM_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaDM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaFz; else goto caaFy;
       caaFz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaFy: // global
           _sa8j3::P64 = P64[Sp + 40];
           _sa8kc::P64 = P64[R1 + 7];
           _sa8kd::P64 = P64[R1 + 15];
           _sa8kg::P64 = P64[_sa8j3::P64 + 8];
           I64[Hp - 16] = sat_sa8ko_info;
           P64[Hp] = _sa8kg::P64;
           call MO_WriteBarrier();
           P64[_sa8j3::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j3::P64);
           I64[Sp - 8] = block_caaEb_info;
           R1 = _sa8kg::P64;
           P64[Sp] = _sa8kd::P64;
           P64[Sp + 32] = _sa8kc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaaGT; else goto caaEc;
       uaaGT: // global
           call _caaEb(R1) args: 0, res: 0, upd: 0;
       caaEc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaEb() //  [R1]
         { info_tbl: [(caaEb,
                       label: block_caaEb_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaEb: // global
           _sa8kx::I64 = I64[R1 + 39];
           if (_sa8kx::I64 != 0) goto caaFC; else goto caaG7;
       caaFC: // global
           I64[Sp - 24] = block_caaEi_info;
           _sa8ks::P64 = P64[R1 + 7];
           _sa8kt::P64 = P64[R1 + 15];
           _sa8kr::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           P64[Sp - 16] = _sa8kt::P64;
           I64[Sp - 8] = _sa8kx::I64;
           P64[Sp] = _sa8ks::P64;
           I64[Sp + 56] = _sa8kr::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaGU; else goto caaEj;
       uaaGU: // global
           call _caaEi(R1) args: 0, res: 0, upd: 0;
       caaEj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caaG7: // global
           _sa8j0::P64 = P64[Sp + 32];
           _sa8kd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = _sa8kd::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 16;
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 _caaEi() //  [R1]
         { info_tbl: [(caaEi,
                       label: block_caaEi_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaEi: // global
           if (R1 & 7 == 1) goto caaFE; else goto caaFW;
       caaFE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caaFH; else goto caaFG;
       caaFH: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaFG: // global
           I64[Hp - 24] = sat_sa8kH_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sa8j0::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 40;
           call _sa8jE() args: 0, res: 0, upd: 0;
       caaFW: // global
           I64[Sp] = block_caaFK_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaaGW; else goto caaFL;
       uaaGW: // global
           call _caaFK(R1) args: 0, res: 0, upd: 0;
       caaFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaFK() //  [R1]
         { info_tbl: [(caaFK,
                       label: block_caaFK_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaFK: // global
           I64[Sp - 8] = block_caaFP_info;
           R2 = P64[Sp + 64];
           _sa8kL::P64 = P64[R1 + 7];
           _sa8kM::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa8kM::P64;
           P64[Sp + 64] = _sa8kL::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaFP() //  [R1]
         { info_tbl: [(caaFP,
                       label: block_caaFP_info
                       rep:StackRep [False, False, True, False, False, False, False,
                                     False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaFP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caaG0; else goto caaFZ;
       caaG0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaFZ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sa8kd::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_caaFS_info;
           R5 = Hp - 47;
           R4 = _sa8kd::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 72];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaFS() //  [R1]
         { info_tbl: [(caaFS,
                       label: block_caaFS_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaFS: // global
           I64[Sp] = block_caaFU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaGZ; else goto caaG2;
       uaaGZ: // global
           call _caaFU(R1) args: 0, res: 0, upd: 0;
       caaG2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaFU() //  [R1]
         { info_tbl: [(caaFU,
                       label: block_caaFU_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaFU: // global
           _sa8j0::P64 = P64[Sp + 24];
           _sa8kY::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = _sa8kY::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 8;
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 _sa8jE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8jE: // global
           I64[Sp - 8] = block_caaDl_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaDl() //  [R1]
         { info_tbl: [(caaDl,
                       label: block_caaDl_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaDl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaFp; else goto caaFo;
       caaFp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaFo: // global
           _sa8j3::P64 = P64[Sp + 40];
           _sa8jL::P64 = P64[_sa8j3::P64 + 8];
           I64[Hp - 16] = sat_sa8jT_info;
           P64[Hp] = _sa8jL::P64;
           _sa8iW::P64 = P64[Sp + 8];
           _sa8iY::P64 = P64[Sp + 16];
           _sa8j0::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa8j3::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j3::P64);
           I64[Sp + 16] = block_caaFe_info;
           R2 = _sa8iW::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa8iY::P64;
           P64[Sp + 8] = P64[_sa8j0::P64 + 8];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.emptyWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _caaFe() //  [R1]
         { info_tbl: [(caaFe,
                       label: block_caaFe_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaFe: // global
           _sa8iQ::P64 = P64[Sp + 48];
           _sa8iU::P64 = P64[Sp + 40];
           _sa8j0::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           I64[Sp + 32] = block_caaFj_info;
           R2 = _sa8iU::P64;
           R1 = _sa8iQ::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaFj() //  [R1]
         { info_tbl: [(caaFj,
                       label: block_caaFj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaFj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaFt; else goto caaFs;
       caaFt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaFs: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaGh() //  [R1]
         { info_tbl: [(caaGh,
                       label: block_caaGh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaGh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaGo; else goto caaGn;
       caaGo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaGn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaaH9_srtd" {
     uaaH9_srtd:
         const Sa8nI_srt+104;
         const 62;
         const 3891391553024819201;
 },
 GHC.IO.Handle.Internals.$wwantWritableHandle'_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(caaH1,
                       label: GHC.IO.Handle.Internals.$wwantWritableHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaH1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caaH5; else goto caaH4;
       caaH5: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaH4: // global
           I64[Hp - 8] = sat_sa8l6_info;
           P64[Hp] = R5;
           R5 = Hp - 6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.213774804 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle1_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle1_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(caaHl,
                       label: GHC.IO.Handle.Internals.wantWritableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaHl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaHm; else goto caaHn;
       caaHm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantWritableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaHn: // global
           I64[Sp - 24] = block_caaHe_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaHu; else goto caaHf;
       uaaHu: // global
           call _caaHe(R1) args: 0, res: 0, upd: 0;
       caaHf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaHe() //  [R1]
         { info_tbl: [(caaHe,
                       label: block_caaHe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaHe: // global
           _sa8l7::P64 = P64[Sp + 8];
           _sa8l9::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto caaHi; else goto caaHj;
       caaHi: // global
           R5 = _sa8l9::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = _sa8l7::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       caaHj: // global
           R5 = _sa8l9::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = _sa8l7::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.21511659 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(caaHz,
                       label: GHC.IO.Handle.Internals.wantWritableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaHz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.217054104 UTC

[section ""data" . withHandle2_ra7PH_closure" {
     withHandle2_ra7PH_closure:
         const withHandle2_ra7PH_info;
         const 0;
 },
 io_sa8lr_entry() //  [R1]
         { info_tbl: [(caaHX,
                       label: io_sa8lr_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaHX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaI1; else goto caaI2;
       caaI1: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaI2: // global
           I64[Sp - 16] = block_caaHS_info;
           _sa8ln::P64 = P64[R1 + 31];
           R5 = _sa8ln::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8ln::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaHS() //  [R1]
         { info_tbl: [(caaHS,
                       label: block_caaHS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaHS: // global
           I64[Sp] = block_caaHU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaI7; else goto caaHV;
       uaaI7: // global
           call _caaHU(R1) args: 0, res: 0, upd: 0;
       caaHV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaHU() //  [R1]
         { info_tbl: [(caaHU,
                       label: block_caaHU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaHU: // global
           I64[Sp] = block_caaI0_info;
           R2 = P64[R1 + 7];
           _sa8ly::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8ly::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaI0() //  []
         { info_tbl: [(caaI0,
                       label: block_caaI0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaI0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8lH_entry() //  [R1]
         { info_tbl: [(caaIm,
                       label: io_sa8lH_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaIm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaIq; else goto caaIr;
       caaIq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaIr: // global
           I64[Sp - 16] = block_caaIh_info;
           _sa8lC::P64 = P64[R1 + 31];
           R5 = _sa8lC::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8lC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaIh() //  [R1]
         { info_tbl: [(caaIh,
                       label: block_caaIh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaIh: // global
           I64[Sp] = block_caaIj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaIw; else goto caaIk;
       uaaIw: // global
           call _caaIj(R1) args: 0, res: 0, upd: 0;
       caaIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaIj() //  [R1]
         { info_tbl: [(caaIj,
                       label: block_caaIj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaIj: // global
           I64[Sp] = block_caaIp_info;
           R2 = P64[R1 + 7];
           _sa8lO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8lO::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaIp() //  []
         { info_tbl: [(caaIp,
                       label: block_caaIp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaIp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 withHandle2_ra7PH_entry() //  [R2, R3, R4]
         { info_tbl: [(caaIB,
                       label: withHandle2_ra7PH_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaIB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caaIC; else goto caaID;
       caaIC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle2_ra7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaID: // global
           I64[Sp - 24] = block_caaHG_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaIU; else goto caaHH;
       uaaIU: // global
           call _caaHG(R1) args: 0, res: 0, upd: 0;
       caaHH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaHG() //  [R1]
         { info_tbl: [(caaHG,
                       label: block_caaHG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaHG: // global
           if (R1 & 7 == 1) goto caaIy; else goto caaIz;
       caaIy: // global
           I64[Sp - 16] = block_caaHL_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caaIz: // global
           I64[Sp - 16] = block_caaIa_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caaHL() //  [R1]
         { info_tbl: [(caaHL,
                       label: block_caaHL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaHL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caaIH; else goto caaIG;
       caaIH: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caaIG: // global
           I64[Hp - 32] = io_sa8lr_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caaHN::P64 = Hp - 31;
           if (R1 == 0) goto caaIL; else goto caaIK;
       caaIL: // global
           R1 = _caaHN::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caaIK: // global
           R1 = _caaHN::P64;
           Sp = Sp + 40;
           call io_sa8lr_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaIa() //  [R1]
         { info_tbl: [(caaIa,
                       label: block_caaIa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaIa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caaIP; else goto caaIO;
       caaIP: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caaIO: // global
           I64[Hp - 32] = io_sa8lH_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caaIc::P64 = Hp - 31;
           if (R1 == 0) goto caaIT; else goto caaIS;
       caaIT: // global
           R1 = _caaIc::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caaIS: // global
           R1 = _caaIc::P64;
           Sp = Sp + 40;
           call io_sa8lH_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.22040636 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_closure" {
     GHC.IO.Handle.Internals.withHandle_closure:
         const GHC.IO.Handle.Internals.withHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(caaIZ,
                       label: GHC.IO.Handle.Internals.withHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaIZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle2_ra7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.222608633 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle1_info;
         const 0;
 },
 sat_sa8m3_entry() //  [R1, R2]
         { info_tbl: [(caaJn,
                       label: sat_sa8m3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJn: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8m1_entry() //  [R1]
         { info_tbl: [(caaJv,
                       label: io_sa8m1_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJv: // global
           _sa8m1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaJz; else goto caaJA;
       caaJA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caaJC; else goto caaJB;
       caaJC: // global
           HpAlloc = 16;
           goto caaJz;
       caaJz: // global
           R1 = _sa8m1::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaJB: // global
           _sa8lR::P64 = P64[_sa8m1::P64 + 7];
           _sa8lT::P64 = P64[_sa8m1::P64 + 15];
           _sa8lV::P64 = P64[_sa8m1::P64 + 23];
           _sa8lX::P64 = P64[_sa8m1::P64 + 31];
           I64[Hp - 8] = sat_sa8m3_info;
           P64[Hp] = _sa8lT::P64;
           I64[Sp - 16] = block_caaJq_info;
           R5 = _sa8lX::P64;
           R4 = Hp - 6;
           R3 = _sa8lV::P64;
           R2 = _sa8lR::P64;
           P64[Sp - 8] = _sa8lX::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaJq() //  [R1]
         { info_tbl: [(caaJq,
                       label: block_caaJq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJq: // global
           I64[Sp] = block_caaJs_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaJH; else goto caaJt;
       uaaJH: // global
           call _caaJs(R1) args: 0, res: 0, upd: 0;
       caaJt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaJs() //  [R1]
         { info_tbl: [(caaJs,
                       label: block_caaJs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJs: // global
           I64[Sp] = block_caaJy_info;
           R2 = P64[R1 + 7];
           _sa8m9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8m9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaJy() //  []
         { info_tbl: [(caaJy,
                       label: block_caaJy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8mk_entry() //  [R1, R2]
         { info_tbl: [(caaJW,
                       label: sat_sa8mk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJW: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8mi_entry() //  [R1]
         { info_tbl: [(caaK4,
                       label: io_sa8mi_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaK4: // global
           _sa8mi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaK8; else goto caaK9;
       caaK9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caaKb; else goto caaKa;
       caaKb: // global
           HpAlloc = 16;
           goto caaK8;
       caaK8: // global
           R1 = _sa8mi::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaKa: // global
           _sa8lR::P64 = P64[_sa8mi::P64 + 7];
           _sa8lT::P64 = P64[_sa8mi::P64 + 15];
           _sa8lV::P64 = P64[_sa8mi::P64 + 23];
           _sa8md::P64 = P64[_sa8mi::P64 + 31];
           I64[Hp - 8] = sat_sa8mk_info;
           P64[Hp] = _sa8lT::P64;
           I64[Sp - 16] = block_caaJZ_info;
           R5 = _sa8md::P64;
           R4 = Hp - 6;
           R3 = _sa8lV::P64;
           R2 = _sa8lR::P64;
           P64[Sp - 8] = _sa8md::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caaJZ() //  [R1]
         { info_tbl: [(caaJZ,
                       label: block_caaJZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJZ: // global
           I64[Sp] = block_caaK1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaKg; else goto caaK2;
       uaaKg: // global
           call _caaK1(R1) args: 0, res: 0, upd: 0;
       caaK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaK1() //  [R1]
         { info_tbl: [(caaK1,
                       label: block_caaK1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaK1: // global
           I64[Sp] = block_caaK7_info;
           R2 = P64[R1 + 7];
           _sa8mq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8mq::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaK7() //  []
         { info_tbl: [(caaK7,
                       label: block_caaK7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaK7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(caaKl,
                       label: GHC.IO.Handle.Internals.wantReadableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaKl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caaKm; else goto caaKn;
       caaKm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaKn: // global
           I64[Sp - 24] = block_caaJ6_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaKE; else goto caaJ7;
       uaaKE: // global
           call _caaJ6(R1) args: 0, res: 0, upd: 0;
       caaJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaJ6() //  [R1]
         { info_tbl: [(caaJ6,
                       label: block_caaJ6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJ6: // global
           if (R1 & 7 == 1) goto caaKi; else goto caaKj;
       caaKi: // global
           I64[Sp - 16] = block_caaJb_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caaKj: // global
           I64[Sp - 16] = block_caaJK_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caaJb() //  [R1]
         { info_tbl: [(caaJb,
                       label: block_caaJb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caaKr; else goto caaKq;
       caaKr: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caaKq: // global
           I64[Hp - 32] = io_sa8m1_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caaJd::P64 = Hp - 31;
           if (R1 == 0) goto caaKv; else goto caaKu;
       caaKv: // global
           R1 = _caaJd::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caaKu: // global
           R1 = _caaJd::P64;
           Sp = Sp + 40;
           call io_sa8m1_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaJK() //  [R1]
         { info_tbl: [(caaJK,
                       label: block_caaJK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaJK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caaKz; else goto caaKy;
       caaKz: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caaKy: // global
           I64[Hp - 32] = io_sa8mi_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caaJM::P64 = Hp - 31;
           if (R1 == 0) goto caaKD; else goto caaKC;
       caaKD: // global
           R1 = _caaJM::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caaKC: // global
           R1 = _caaJM::P64;
           Sp = Sp + 40;
           call io_sa8mi_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.226608338 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(caaKJ,
                       label: GHC.IO.Handle.Internals.wantReadableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaKJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.227337965 UTC

[section ""relreadonly" . Sa8nI_srt" {
     Sa8nI_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle12_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const ioe_closedHandle2_ra7Pb_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle8_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const ioe_semiclosedHandle2_ra7Pc_closure;
         const GHC.IO.Handle.Internals.hLookAhead_3_closure;
         const ioe_EOF2_ra7Pd_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle4_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle3_closure;
         const ioe_notReadable2_ra7Pe_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle3_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle2_closure;
         const ioe_notWritable2_ra7Pf_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle4_closure;
         const GHC.IO.Handle.Internals.flushBuffer4_closure;
         const lvl1_ra7Ph_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const lvl6_ra7Pm_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf1_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.Err.error_closure;
         const lvl19_ra7Pz_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer1_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer3_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
         const lvl22_ra7PC_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.noCharBuffer_closure;
         const GHC.IO.Handle.Internals.noByteBuffer_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkFileHandle1_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const $wlvl_ra7PF_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.Internals.withHandle_1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.Internals.withHandle__'1_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.withHandle1_closure;
         const GHC.IO.Handle.Internals.withHandle_'1_closure;
         const withHandle_2_ra7PG_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const withHandle2_ra7PH_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.228620292 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:07.230748152 UTC

[section ""data" . GHC.IO.Handle.Internals.augmentIOError_closure" {
     GHC.IO.Handle.Internals.augmentIOError_closure:
         const GHC.IO.Handle.Internals.augmentIOError_info;
 },
 sat_sa7Q2_entry() //  [R1]
         { info_tbl: [(caaL6,
                       label: sat_sa7Q2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaL6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caaL7; else goto caaL8;
       caaL7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaL8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caaKZ_info;
           _sa7PL::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sa7PL::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaaLz; else goto caaL0;
       uaaLz: // global
           call _caaKZ(R1) args: 0, res: 0, upd: 0;
       caaL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caaKZ() //  [R1]
         { info_tbl: [(caaKZ,
                       label: block_caaKZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaKZ: // global
           if (R1 & 7 == 1) goto caaL3; else goto caaL4;
       caaL3: // global
           _sa7PL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caaLb_info;
           R1 = _sa7PL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaaLy; else goto caaLd;
       uaaLy: // global
           call _caaLb(R1) args: 0, res: 0, upd: 0;
       caaLd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caaL4: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _caaLb() //  [R1]
         { info_tbl: [(caaLb,
                       label: block_caaLb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaLb: // global
           if (R1 & 7 == 1) goto caaLj; else goto caaLq;
       caaLj: // global
           Hp = Hp + 16;
           _sa7PV::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caaLt; else goto caaLl;
       caaLl: // global
           _sa7PW::P64 = P64[_sa7PV::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa7PW::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caaLq: // global
           Hp = Hp + 16;
           _sa7PV::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caaLt; else goto caaLs;
       caaLt: // global
           HpAlloc = 16;
           R1 = _sa7PV::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caaLs: // global
           _sa7PY::P64 = P64[_sa7PV::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa7PY::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.augmentIOError_entry() //  [R2, R3, R4]
         { info_tbl: [(caaLA,
                       label: GHC.IO.Handle.Internals.augmentIOError_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaLA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaLD; else goto caaLE;
       caaLD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.augmentIOError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaLE: // global
           I64[Sp - 24] = block_caaKQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaLI; else goto caaKR;
       uaaLI: // global
           call _caaKQ(R1) args: 0, res: 0, upd: 0;
       caaKR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaKQ() //  [R1]
         { info_tbl: [(caaKQ,
                       label: block_caaKQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaKQ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caaLH; else goto caaLG;
       caaLH: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaLG: // global
           _sa7PO::P64 = P64[R1 + 15];
           _sa7PQ::P64 = P64[R1 + 31];
           _sa7PR::P64 = P64[R1 + 39];
           _sa7PS::P64 = P64[R1 + 47];
           I64[Hp - 96] = sat_sa7Q2_info;
           _sa7PL::P64 = P64[Sp + 16];
           P64[Hp - 80] = _sa7PL::P64;
           P64[Hp - 72] = _sa7PS::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa7PL::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sa7PO::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sa7PQ::P64;
           P64[Hp - 8] = _sa7PR::P64;
           P64[Hp] = Hp - 96;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.246878486 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle14_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle14_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.248810183 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle13_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle13_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle13_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle13_entry() //  [R1]
         { info_tbl: [(caaMn,
                       label: GHC.IO.Handle.Internals.wantReadableHandle13_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaMn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaMo; else goto caaMp;
       caaMo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaMp: // global
           (_caaMk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaMk::I64 == 0) goto caaMm; else goto caaMl;
       caaMm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaMl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaMk::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle14_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.252833687 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle12_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle12_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle13_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.254805961 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle11_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle11_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle11_entry() //  [R1]
         { info_tbl: [(caaME,
                       label: GHC.IO.Handle.Internals.wantReadableHandle11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaME: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaMF; else goto caaMG;
       caaMF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaMG: // global
           (_caaMB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaMB::I64 == 0) goto caaMD; else goto caaMC;
       caaMD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaMC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaMB::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle12_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.258812026 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle1_entry() //  []
         { info_tbl: [(caaMS,
                       label: GHC.IO.Handle.Internals.ioe_closedHandle1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaMS: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.262193352 UTC

[section ""data" . ioe_closedHandle2_ra7Pb_closure" {
     ioe_closedHandle2_ra7Pb_closure:
         const ioe_closedHandle2_ra7Pb_info;
         const 0;
 },
 ioe_closedHandle2_ra7Pb_entry() //  []
         { info_tbl: [(caaN3,
                       label: ioe_closedHandle2_ra7Pb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaN3: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.26580428 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle_entry() //  []
         { info_tbl: [(caaNe,
                       label: GHC.IO.Handle.Internals.ioe_closedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaNe: // global
           call ioe_closedHandle2_ra7Pb_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.270326681 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle10_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle10_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.272206005 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle9_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle9_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle9_entry() //  [R1]
         { info_tbl: [(caaNs,
                       label: GHC.IO.Handle.Internals.wantReadableHandle9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaNs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaNt; else goto caaNu;
       caaNt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaNu: // global
           (_caaNp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaNp::I64 == 0) goto caaNr; else goto caaNq;
       caaNr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaNq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaNp::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.276560999 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle8_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle9_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.278516852 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle7_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle7_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle7_entry() //  [R1]
         { info_tbl: [(caaNJ,
                       label: GHC.IO.Handle.Internals.wantReadableHandle7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaNJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaNK; else goto caaNL;
       caaNK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaNL: // global
           (_caaNG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaNG::I64 == 0) goto caaNI; else goto caaNH;
       caaNI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaNH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaNG::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.282678518 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() //  []
         { info_tbl: [(caaNX,
                       label: GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaNX: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.285937567 UTC

[section ""data" . ioe_semiclosedHandle2_ra7Pc_closure" {
     ioe_semiclosedHandle2_ra7Pc_closure:
         const ioe_semiclosedHandle2_ra7Pc_info;
         const 0;
 },
 ioe_semiclosedHandle2_ra7Pc_entry() //  []
         { info_tbl: [(caaO8,
                       label: ioe_semiclosedHandle2_ra7Pc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaO8: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.289155524 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle_entry() //  []
         { info_tbl: [(caaOj,
                       label: GHC.IO.Handle.Internals.ioe_semiclosedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaOj: // global
           call ioe_semiclosedHandle2_ra7Pc_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.292292448 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_4_closure" {
     GHC.IO.Handle.Internals.hLookAhead_4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.294558153 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_3_closure" {
     GHC.IO.Handle.Internals.hLookAhead_3_closure:
         const GHC.IO.Handle.Internals.hLookAhead_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_3_entry() //  [R1]
         { info_tbl: [(caaOx,
                       label: GHC.IO.Handle.Internals.hLookAhead_3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaOx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaOy; else goto caaOz;
       caaOy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaOz: // global
           (_caaOu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaOu::I64 == 0) goto caaOw; else goto caaOv;
       caaOw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaOv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaOu::I64;
           R2 = GHC.IO.Handle.Internals.hLookAhead_4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.298527509 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF1_closure" {
     GHC.IO.Handle.Internals.ioe_EOF1_closure:
         const GHC.IO.Handle.Internals.ioe_EOF1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF1_entry() //  []
         { info_tbl: [(caaOL,
                       label: GHC.IO.Handle.Internals.ioe_EOF1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaOL: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.302333444 UTC

[section ""data" . ioe_EOF2_ra7Pd_closure" {
     ioe_EOF2_ra7Pd_closure:
         const ioe_EOF2_ra7Pd_info;
         const 0;
 },
 ioe_EOF2_ra7Pd_entry() //  []
         { info_tbl: [(caaOW,
                       label: ioe_EOF2_ra7Pd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaOW: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.305956639 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF_closure" {
     GHC.IO.Handle.Internals.ioe_EOF_closure:
         const GHC.IO.Handle.Internals.ioe_EOF_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF_entry() //  []
         { info_tbl: [(caaP7,
                       label: GHC.IO.Handle.Internals.ioe_EOF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaP7: // global
           call ioe_EOF2_ra7Pd_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.309045641 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,114,101,97,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.310958373 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle5_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle5_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle5_entry() //  [R1]
         { info_tbl: [(caaPl,
                       label: GHC.IO.Handle.Internals.wantReadableHandle5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaPl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaPm; else goto caaPn;
       caaPm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaPn: // global
           (_caaPi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaPi::I64 == 0) goto caaPk; else goto caaPj;
       caaPk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaPj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaPi::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.314878023 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle4_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.316873759 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle3_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle3_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle3_entry() //  [R1]
         { info_tbl: [(caaPC,
                       label: GHC.IO.Handle.Internals.wantReadableHandle3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaPC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaPD; else goto caaPE;
       caaPD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaPE: // global
           (_caaPz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaPz::I64 == 0) goto caaPB; else goto caaPA;
       caaPB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaPA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaPz::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.321113643 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable1_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable1_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable1_entry() //  []
         { info_tbl: [(caaPQ,
                       label: GHC.IO.Handle.Internals.ioe_notReadable1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaPQ: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.32443155 UTC

[section ""data" . ioe_notReadable2_ra7Pe_closure" {
     ioe_notReadable2_ra7Pe_closure:
         const ioe_notReadable2_ra7Pe_info;
         const 0;
 },
 ioe_notReadable2_ra7Pe_entry() //  []
         { info_tbl: [(caaQ1,
                       label: ioe_notReadable2_ra7Pe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaQ1: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.32758728 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable_entry() //  []
         { info_tbl: [(caaQc,
                       label: GHC.IO.Handle.Internals.ioe_notReadable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaQc: // global
           call ioe_notReadable2_ra7Pe_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.330592473 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantWritableHandle5_bytes" {
     GHC.IO.Handle.Internals.wantWritableHandle5_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,119,114,105,116,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.332919805 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle4_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle4_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle4_entry() //  [R1]
         { info_tbl: [(caaQq,
                       label: GHC.IO.Handle.Internals.wantWritableHandle4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaQq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaQr; else goto caaQs;
       caaQr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaQs: // global
           (_caaQn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaQn::I64 == 0) goto caaQp; else goto caaQo;
       caaQp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaQo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaQn::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.337233161 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle3_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantWritableHandle4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.339218178 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle2_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle2_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle2_entry() //  [R1]
         { info_tbl: [(caaQH,
                       label: GHC.IO.Handle.Internals.wantWritableHandle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaQH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaQI; else goto caaQJ;
       caaQI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaQJ: // global
           (_caaQE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaQE::I64 == 0) goto caaQG; else goto caaQF;
       caaQG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaQF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaQE::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.343104249 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable1_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable1_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable1_entry() //  []
         { info_tbl: [(caaQV,
                       label: GHC.IO.Handle.Internals.ioe_notWritable1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaQV: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.346968303 UTC

[section ""data" . ioe_notWritable2_ra7Pf_closure" {
     ioe_notWritable2_ra7Pf_closure:
         const ioe_notWritable2_ra7Pf_info;
         const 0;
 },
 ioe_notWritable2_ra7Pf_entry() //  []
         { info_tbl: [(caaR6,
                       label: ioe_notWritable2_ra7Pf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaR6: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.35012763 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable_entry() //  []
         { info_tbl: [(caaRh,
                       label: GHC.IO.Handle.Internals.ioe_notWritable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaRh: // global
           call ioe_notWritable2_ra7Pf_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.353267376 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantSeekableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantSeekableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.355131817 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle5_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle5_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle5_entry() //  [R1]
         { info_tbl: [(caaRv,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaRv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaRw; else goto caaRx;
       caaRw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaRx: // global
           (_caaRs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaRs::I64 == 0) goto caaRu; else goto caaRt;
       caaRu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaRt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaRs::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.359376291 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle4_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.361369455 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle3_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle3_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle3_entry() //  [R1]
         { info_tbl: [(caaRM,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaRM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaRN; else goto caaRO;
       caaRN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaRO: // global
           (_caaRJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaRJ::I64 == 0) goto caaRL; else goto caaRK;
       caaRL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaRK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaRJ::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.365849776 UTC

[section ""cstring" . GHC.IO.Handle.Internals.flushBuffer6_bytes" {
     GHC.IO.Handle.Internals.flushBuffer6_bytes:
         I8[] [99,97,110,110,111,116,32,102,108,117,115,104,32,116,104,101,32,114,101,97,100,32,98,117,102,102,101,114,58,32,117,110,100,101,114,108,121,105,110,103,32,100,101,118,105,99,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.367644304 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer5_closure" {
     GHC.IO.Handle.Internals.flushBuffer5_closure:
         const GHC.IO.Handle.Internals.flushBuffer5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer5_entry() //  [R1]
         { info_tbl: [(caaS3,
                       label: GHC.IO.Handle.Internals.flushBuffer5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaS3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaS4; else goto caaS5;
       caaS4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaS5: // global
           (_caaS0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaS0::I64 == 0) goto caaS2; else goto caaS1;
       caaS2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaS1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaS0::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.371842172 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer4_closure" {
     GHC.IO.Handle.Internals.flushBuffer4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.flushBuffer5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.37385815 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer3_closure" {
     GHC.IO.Handle.Internals.flushBuffer3_closure:
         const GHC.IO.Handle.Internals.flushBuffer3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer3_entry() //  [R1]
         { info_tbl: [(caaSk,
                       label: GHC.IO.Handle.Internals.flushBuffer3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaSk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaSl; else goto caaSm;
       caaSl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaSm: // global
           (_caaSh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaSh::I64 == 0) goto caaSj; else goto caaSi;
       caaSj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaSi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaSh::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.377730621 UTC

[section ""cstring" . lvl_ra7Pg_bytes" {
     lvl_ra7Pg_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.379605291 UTC

[section ""data" . lvl1_ra7Ph_closure" {
     lvl1_ra7Ph_closure:
         const lvl1_ra7Ph_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra7Ph_entry() //  [R1]
         { info_tbl: [(caaSB,
                       label: lvl1_ra7Ph_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaSB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaSC; else goto caaSD;
       caaSC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaSD: // global
           (_caaSy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaSy::I64 == 0) goto caaSA; else goto caaSz;
       caaSA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaSz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaSy::I64;
           R2 = lvl_ra7Pg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.383799355 UTC

[section ""cstring" . lvl2_ra7Pi_bytes" {
     lvl2_ra7Pi_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.386140975 UTC

[section ""data" . GHC.IO.Handle.Internals.$wioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.$wioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.$wioe_bufsiz_info;
         const 0;
 },
 sat_sa7Qi_entry() //  [R1]
         { info_tbl: [(caaT5,
                       label: sat_sa7Qi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaT5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaT6; else goto caaT7;
       caaT6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaT7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caaT2_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _caaT2() //  [R1, R2]
         { info_tbl: [(caaT2,
                       label: block_caaT2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaT2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaTa; else goto caaT9;
       caaTa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caaT9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Qj_entry() //  [R1]
         { info_tbl: [(caaTb,
                       label: sat_sa7Qj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaTb: // global
           _sa7Qj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaTc; else goto caaTd;
       caaTd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaTf; else goto caaTe;
       caaTf: // global
           HpAlloc = 24;
           goto caaTc;
       caaTc: // global
           R1 = _sa7Qj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaTe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Qj::P64;
           _sa7Qd::I64 = I64[_sa7Qj::P64 + 16];
           I64[Hp - 16] = sat_sa7Qi_info;
           I64[Hp] = _sa7Qd::I64;
           R3 = Hp - 16;
           R2 = lvl2_ra7Pi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Ql_entry() //  [R1]
         { info_tbl: [(caaTh,
                       label: sat_sa7Ql_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaTh: // global
           _sa7Ql::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaTi; else goto caaTj;
       caaTj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caaTl; else goto caaTk;
       caaTl: // global
           HpAlloc = 80;
           goto caaTi;
       caaTi: // global
           R1 = _sa7Ql::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaTk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Ql::P64;
           _sa7Qd::I64 = I64[_sa7Ql::P64 + 16];
           I64[Hp - 72] = sat_sa7Qj_info;
           I64[Hp - 56] = _sa7Qd::I64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = lvl1_ra7Ph_closure;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.$wioe_bufsiz_entry() //  [R2]
         { info_tbl: [(caaTm,
                       label: GHC.IO.Handle.Internals.$wioe_bufsiz_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaTm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaTq; else goto caaTp;
       caaTq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaTp: // global
           I64[Hp - 16] = sat_sa7Ql_info;
           I64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.398962536 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz1_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz1_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz1_entry() //  [R2]
         { info_tbl: [(caaTT,
                       label: GHC.IO.Handle.Internals.ioe_bufsiz1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaTT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caaTU; else goto caaTV;
       caaTU: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaTV: // global
           I64[Sp - 8] = block_caaTQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaaTZ; else goto caaTR;
       uaaTZ: // global
           call _caaTQ(R1) args: 0, res: 0, upd: 0;
       caaTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaTQ() //  [R1]
         { info_tbl: [(caaTQ,
                       label: block_caaTQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaTQ: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.404096707 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz_entry() //  [R2]
         { info_tbl: [(caaUd,
                       label: GHC.IO.Handle.Internals.ioe_bufsiz_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaUd: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.ioe_bufsiz1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.408308339 UTC

[section ""data" . GHC.IO.Handle.Internals.$wstreamEncode_closure" {
     GHC.IO.Handle.Internals.$wstreamEncode_closure:
         const GHC.IO.Handle.Internals.$wstreamEncode_info;
 },
 GHC.IO.Handle.Internals.$wstreamEncode_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caaUq,
                       label: GHC.IO.Handle.Internals.$wstreamEncode_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaUq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caaUr; else goto caaUs;
       caaUr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wstreamEncode_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaUs: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _caaUu() args: 0, res: 0, upd: 0;
     }
 },
 _caaUu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaUu: // global
           I64[Sp - 8] = block_caaUw_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaUw() //  [R1]
         { info_tbl: [(caaUw,
                       label: block_caaUw_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaUw: // global
           I64[Sp] = block_caaUy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaVu; else goto caaUB;
       uaaVu: // global
           call _caaUy(R1) args: 0, res: 0, upd: 0;
       caaUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaUy() //  [R1]
         { info_tbl: [(caaUy,
                       label: block_caaUy_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaUy: // global
           I64[Sp - 8] = block_caaUF_info;
           _sa7QE::P64 = P64[R1 + 15];
           _sa7QF::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa7QF::P64;
           P64[Sp + 32] = _sa7QE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaaVv; else goto caaUH;
       uaaVv: // global
           call _caaUF(R1) args: 0, res: 0, upd: 0;
       caaUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaUF() //  [R1]
         { info_tbl: [(caaUF,
                       label: block_caaUF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaUF: // global
           if (R1 & 7 == 3) goto caaV0; else goto caaUN;
       caaV0: // global
           I64[Sp] = block_caaUT_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto uaaVw; else goto caaUU;
       uaaVw: // global
           call _caaUT(R1) args: 0, res: 0, upd: 0;
       caaUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caaUN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaUQ; else goto caaUP;
       caaUQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaUP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaUT() //  [R1]
         { info_tbl: [(caaUT,
                       label: block_caaUT_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaUT: // global
           I64[Sp] = block_caaUY_info;
           _sa7QN::I64 = I64[R1 + 39];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sa7QN::I64;
           if (R1 & 7 != 0) goto uaaVx; else goto caaV2;
       uaaVx: // global
           call _caaUY(R1) args: 0, res: 0, upd: 0;
       caaV2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaUY() //  [R1]
         { info_tbl: [(caaUY,
                       label: block_caaUY_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaUY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaV8; else goto caaV7;
       caaV8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaV7: // global
           _sa7QF::P64 = P64[Sp + 8];
           if (I64[Sp + 40] == I64[R1 + 39]) goto caaVj; else goto caaVe;
       caaVj: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caaVg_info;
           R3 = _sa7QF::P64;
           R2 = R1;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caaVe: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sa7QF::P64;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caaVg() //  [R1]
         { info_tbl: [(caaVg,
                       label: block_caaVg_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaVg: // global
           I64[Sp] = block_caaVi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaVy; else goto caaVl;
       uaaVy: // global
           call _caaVi(R1) args: 0, res: 0, upd: 0;
       caaVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaVi() //  [R1]
         { info_tbl: [(caaVi,
                       label: block_caaVi_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaVi: // global
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 8;
           call _caaUu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.426007893 UTC

[section ""data" . GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure" {
     GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure:
         const GHC.Types.I#_con_info;
         const 2048;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.428065257 UTC

[section ""data" . GHC.IO.Handle.Internals.initBufferState_closure" {
     GHC.IO.Handle.Internals.initBufferState_closure:
         const GHC.IO.Handle.Internals.initBufferState_info;
 },
 GHC.IO.Handle.Internals.initBufferState_entry() //  [R2]
         { info_tbl: [(caaWs,
                       label: GHC.IO.Handle.Internals.initBufferState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaWs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caaWt; else goto caaWu;
       caaWt: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.initBufferState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaWu: // global
           I64[Sp - 8] = block_caaWl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaaWB; else goto caaWm;
       uaaWB: // global
           call _caaWl(R1) args: 0, res: 0, upd: 0;
       caaWm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaWl() //  [R1]
         { info_tbl: [(caaWl,
                       label: block_caaWl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaWl: // global
           if (R1 & 7 == 3) goto caaWq; else goto caaWp;
       caaWq: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caaWp: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.434726962 UTC

[section ""data" . lvl3_ra7Pj_closure" {
     lvl3_ra7Pj_closure:
         const lvl3_ra7Pj_info;
 },
 lvl3_ra7Pj_entry() //  []
         { info_tbl: [(caaX2,
                       label: lvl3_ra7Pj_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaX2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaX5; else goto caaX6;
       caaX5: // global
           R1 = lvl3_ra7Pj_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaX6: // global
           I64[Sp - 8] = block_caaWT_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caaWT() //  []
         { info_tbl: [(caaWT,
                       label: block_caaWT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaWT: // global
           I64[Sp] = block_caaWV_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaWV() //  [R1]
         { info_tbl: [(caaWV,
                       label: block_caaWV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaWV: // global
           I64[Sp - 8] = block_caaWX_info;
           _sa7Ra::P64 = R1;
           R1 = 4;
           P64[Sp] = _sa7Ra::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaWX() //  [R1]
         { info_tbl: [(caaWX,
                       label: block_caaWX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaWX: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caaXb; else goto caaXa;
       caaXb: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaXa: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.443256173 UTC

[section ""data" . GHC.IO.Handle.Internals.noCharBuffer_closure" {
     GHC.IO.Handle.Internals.noCharBuffer_closure:
         const GHC.IO.Handle.Internals.noCharBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noCharBuffer_entry() //  [R1]
         { info_tbl: [(caaXC,
                       label: GHC.IO.Handle.Internals.noCharBuffer_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaXC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaXD; else goto caaXE;
       caaXD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaXE: // global
           (_caaXx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaXx::I64 == 0) goto caaXz; else goto caaXy;
       caaXz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaXy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaXx::I64;
           I64[Sp - 24] = block_caaXA_info;
           Sp = Sp - 24;
           call lvl3_ra7Pj_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caaXA() //  [R1]
         { info_tbl: [(caaXA,
                       label: block_caaXA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaXA: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.449144397 UTC

[section ""data" . lvl4_ra7Pk_closure" {
     lvl4_ra7Pk_closure:
         const lvl4_ra7Pk_info;
 },
 lvl4_ra7Pk_entry() //  []
         { info_tbl: [(caaY5,
                       label: lvl4_ra7Pk_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaY5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaY8; else goto caaY9;
       caaY8: // global
           R1 = lvl4_ra7Pk_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaY9: // global
           I64[Sp - 8] = block_caaXW_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _caaXW() //  []
         { info_tbl: [(caaXW,
                       label: block_caaXW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaXW: // global
           I64[Sp] = block_caaXY_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaXY() //  [R1]
         { info_tbl: [(caaXY,
                       label: block_caaXY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaXY: // global
           I64[Sp - 8] = block_caaY0_info;
           _sa7Ro::P64 = R1;
           R1 = 1;
           P64[Sp] = _sa7Ro::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaY0() //  [R1]
         { info_tbl: [(caaY0,
                       label: block_caaY0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaY0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caaYe; else goto caaYd;
       caaYe: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaYd: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.457898587 UTC

[section ""data" . GHC.IO.Handle.Internals.noByteBuffer_closure" {
     GHC.IO.Handle.Internals.noByteBuffer_closure:
         const GHC.IO.Handle.Internals.noByteBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noByteBuffer_entry() //  [R1]
         { info_tbl: [(caaYF,
                       label: GHC.IO.Handle.Internals.noByteBuffer_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaYF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaYG; else goto caaYH;
       caaYG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaYH: // global
           (_caaYA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaYA::I64 == 0) goto caaYC; else goto caaYB;
       caaYC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaYB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaYA::I64;
           I64[Sp - 24] = block_caaYD_info;
           Sp = Sp - 24;
           call lvl4_ra7Pk_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caaYD() //  [R1]
         { info_tbl: [(caaYD,
                       label: block_caaYD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaYD: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.462970621 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule4_bytes" {
     GHC.IO.Handle.Internals.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.464647978 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule3_closure" {
     GHC.IO.Handle.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.46677635 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule2_bytes" {
     GHC.IO.Handle.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.468491964 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule1_closure" {
     GHC.IO.Handle.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.47054271 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule_closure" {
     GHC.IO.Handle.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Internals.$trModule3_closure+1;
         const GHC.IO.Handle.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.472166794 UTC

[section ""cstring" . lvl5_ra7Pl_bytes" {
     lvl5_ra7Pl_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,102,105,110,97,108,105,122,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.474103348 UTC

[section ""data" . lvl6_ra7Pm_closure" {
     lvl6_ra7Pm_closure:
         const lvl6_ra7Pm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra7Pm_entry() //  [R1]
         { info_tbl: [(caaZ7,
                       label: lvl6_ra7Pm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaZ7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaZ8; else goto caaZ9;
       caaZ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaZ9: // global
           (_caaZ4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaZ4::I64 == 0) goto caaZ6; else goto caaZ5;
       caaZ6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaZ5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaZ4::I64;
           R2 = lvl5_ra7Pl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.478066397 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_finalizedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_finalizedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_finalizedHandle_entry() //  [R2]
         { info_tbl: [(caaZn,
                       label: GHC.IO.Handle.Internals.ioe_finalizedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaZn: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caaZr; else goto caaZq;
       caaZr: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaZq: // global
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = lvl6_ra7Pm_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.48517431 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs1_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs1_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs1_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs1_entry() //  [R2]
         { info_tbl: [(caaZE,
                       label: GHC.IO.Handle.Internals.closeTextCodecs1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaZE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaZF; else goto caaZG;
       caaZF: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.closeTextCodecs1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaZG: // global
           I64[Sp - 8] = block_caaZB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab0L; else goto caaZC;
       uab0L: // global
           call _caaZB(R1) args: 0, res: 0, upd: 0;
       caaZC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaZB() //  [R1]
         { info_tbl: [(caaZB,
                       label: block_caaZB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaZB: // global
           I64[Sp - 8] = block_caaZJ_info;
           _sa7RO::P64 = P64[R1 + 87];
           R1 = P64[R1 + 95];
           P64[Sp] = _sa7RO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab0K; else goto caaZL;
       uab0K: // global
           call _caaZJ(R1) args: 0, res: 0, upd: 0;
       caaZL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaZJ() //  [R1]
         { info_tbl: [(caaZJ,
                       label: block_caaZJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaZJ: // global
           if (R1 & 7 == 1) goto caaZS; else goto cab0e;
       caaZS: // global
           _sa7RO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caaZP_info;
           R1 = _sa7RO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uab0M; else goto caaZT;
       uab0M: // global
           call _caaZP(R1) args: 0, res: 0, upd: 0;
       caaZT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cab0e: // global
           I64[Sp] = block_cab0c_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab0N; else goto cab0f;
       uab0N: // global
           call _cab0c(R1) args: 0, res: 0, upd: 0;
       cab0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaZP() //  [R1]
         { info_tbl: [(caaZP,
                       label: block_caaZP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaZP: // global
           if (R1 & 7 == 1) goto uab0J; else goto cab04;
       uab0J: // global
           Sp = Sp + 8;
           call _cab0u() args: 0, res: 0, upd: 0;
       cab04: // global
           I64[Sp] = block_cab02_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab0O; else goto cab05;
       uab0O: // global
           call _cab02(R1) args: 0, res: 0, upd: 0;
       cab05: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab02() //  [R1]
         { info_tbl: [(cab02,
                       label: block_cab02_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab02: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cab0c() //  [R1]
         { info_tbl: [(cab0c,
                       label: block_cab0c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab0c: // global
           I64[Sp] = block_cab0j_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab0j() //  []
         { info_tbl: [(cab0j,
                       label: block_cab0j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab0j: // global
           _sa7RO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cab0l_info;
           R1 = _sa7RO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uab0Q; else goto cab0o;
       uab0Q: // global
           call _cab0l(R1) args: 0, res: 0, upd: 0;
       cab0o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab0l() //  [R1]
         { info_tbl: [(cab0l,
                       label: block_cab0l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab0l: // global
           if (R1 & 7 == 1) goto uab0I; else goto cab0z;
       uab0I: // global
           Sp = Sp + 8;
           call _cab0u() args: 0, res: 0, upd: 0;
       cab0z: // global
           I64[Sp] = block_cab0x_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab0R; else goto cab0A;
       uab0R: // global
           call _cab0x(R1) args: 0, res: 0, upd: 0;
       cab0A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab0u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab0u: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cab0x() //  [R1]
         { info_tbl: [(cab0x,
                       label: block_cab0x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab0x: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.504093318 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs_entry() //  [R2]
         { info_tbl: [(cab1G,
                       label: GHC.IO.Handle.Internals.closeTextCodecs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab1G: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.closeTextCodecs1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.508976655 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding1_closure" {
     GHC.IO.Handle.Internals.openTextEncoding1_closure:
         const GHC.IO.Handle.Internals.openTextEncoding1_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding1_entry() //  [R2, R3, R4]
         { info_tbl: [(cab1Y,
                       label: GHC.IO.Handle.Internals.openTextEncoding1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab1Y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cab1Z; else goto cab20;
       cab1Z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.openTextEncoding1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cab20: // global
           I64[Sp - 24] = block_cab1R_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uab3w; else goto cab1S;
       uab3w: // global
           call _cab1R(R1) args: 0, res: 0, upd: 0;
       cab1S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab1R() //  [R1]
         { info_tbl: [(cab1R,
                       label: block_cab1R_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab1R: // global
           if (R1 & 7 == 1) goto cab1V; else goto cab1W;
       cab1V: // global
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cab1W: // global
           I64[Sp] = block_cab26_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab3v; else goto cab28;
       uab3v: // global
           call _cab26(R1) args: 0, res: 0, upd: 0;
       cab28: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab26() //  [R1]
         { info_tbl: [(cab26,
                       label: block_cab26_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab26: // global
           I64[Sp - 16] = block_cab2e_info;
           _sa7St::P64 = P64[R1 + 15];
           _sa7Su::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _sa7Su::P64;
           P64[Sp] = _sa7St::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uab3x; else goto cab2W;
       uab3x: // global
           call _cab2e(R1) args: 0, res: 0, upd: 0;
       cab2W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab2e() //  [R1]
         { info_tbl: [(cab2e,
                       label: block_cab2e_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab2e: // global
           _sa7St::P64 = P64[Sp + 16];
           _cab3l::P64 = R1 & 7;
           if (_cab3l::P64 != 3) goto uab3p; else goto cab37;
       uab3p: // global
           if (_cab3l::P64 != 6) goto cab32; else goto cab3g;
       cab32: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
       cab3g: // global
           I64[Sp] = block_cab3e_info;
           R1 = _sa7St::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cab37: // global
           I64[Sp] = block_cab35_info;
           R1 = _sa7St::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab3e() //  [R1]
         { info_tbl: [(cab3e,
                       label: block_cab3e_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab3e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab3k; else goto cab3j;
       cab3k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab3j: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
     }
 },
 _cab35() //  [R1]
         { info_tbl: [(cab35,
                       label: block_cab35_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab35: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab3b; else goto cab3a;
       cab3b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab3a: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
     }
 },
 _sa7Sv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa7Sv: // global
           I64[Sp - 8] = block_cab2j_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab3B; else goto cab2l;
       uab3B: // global
           call _cab2j(R1) args: 0, res: 0, upd: 0;
       cab2l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab2j() //  [R1]
         { info_tbl: [(cab2j,
                       label: block_cab2j_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab2j: // global
           _sa7Su::P64 = P64[Sp + 8];
           _cab3o::P64 = R1 & 7;
           if (_cab3o::P64 < 5) goto uab3q; else goto uab3r;
       uab3q: // global
           if (_cab3o::P64 < 4) goto cab2r; else goto cab2y;
       cab2r: // global
           R3 = P64[Sp + 16];
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cab2y: // global
           I64[Sp + 8] = block_cab2u_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       uab3r: // global
           if (_cab3o::P64 < 6) goto cab2I; else goto cab2S;
       cab2I: // global
           I64[Sp + 8] = block_cab2E_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cab2S: // global
           I64[Sp + 8] = block_cab2O_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab2u() //  [R1]
         { info_tbl: [(cab2u,
                       label: block_cab2u_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab2u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab2B; else goto cab2A;
       cab2B: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab2A: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cab2E() //  [R1]
         { info_tbl: [(cab2E,
                       label: block_cab2E_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab2E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab2L; else goto cab2K;
       cab2L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab2K: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cab2O() //  [R1]
         { info_tbl: [(cab2O,
                       label: block_cab2O_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab2O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab2V; else goto cab2U;
       cab2V: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab2U: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.531671577 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding_closure" {
     GHC.IO.Handle.Internals.openTextEncoding_closure:
         const GHC.IO.Handle.Internals.openTextEncoding_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding_entry() //  [R2, R3, R4]
         { info_tbl: [(cab4o,
                       label: GHC.IO.Handle.Internals.openTextEncoding_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab4o: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.openTextEncoding1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.535786227 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry() //  [R2]
         { info_tbl: [(cab4C,
                       label: GHC.IO.Handle.Internals.flushByteWriteBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab4C: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cab4G; else goto cab4H;
       cab4G: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cab4H: // global
           I64[Sp - 8] = block_cab4z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab51; else goto cab4A;
       uab51: // global
           call _cab4z(R1) args: 0, res: 0, upd: 0;
       cab4A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab4z() //  [R1]
         { info_tbl: [(cab4z,
                       label: block_cab4z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab4z: // global
           I64[Sp - 24] = block_cab4F_info;
           _sa7SY::P64 = P64[R1 + 15];
           _sa7T0::P64 = P64[R1 + 31];
           _sa7T2::P64 = P64[R1 + 47];
           R1 = P64[_sa7T2::P64 + 8];
           P64[Sp - 16] = _sa7T0::P64;
           P64[Sp - 8] = _sa7T2::P64;
           P64[Sp] = _sa7SY::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uab50; else goto cab4J;
       uab50: // global
           call _cab4F(R1) args: 0, res: 0, upd: 0;
       cab4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab4F() //  [R1]
         { info_tbl: [(cab4F,
                       label: block_cab4F_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab4F: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cab4W; else goto cab4T;
       cab4W: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cab4T: // global
           _sa7T0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cab4R_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7T0::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cab4R() //  [R1]
         { info_tbl: [(cab4R,
                       label: block_cab4R_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab4R: // global
           _sa7T2::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7T2::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7T2::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.546322719 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer_entry() //  [R2]
         { info_tbl: [(cab5q,
                       label: GHC.IO.Handle.Internals.flushByteWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab5q: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.550350846 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer1_entry() //  [R2]
         { info_tbl: [(cab5E,
                       label: GHC.IO.Handle.Internals.flushWriteBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab5E: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cab5I; else goto cab5J;
       cab5I: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cab5J: // global
           I64[Sp - 8] = block_cab5B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab6o; else goto cab5C;
       uab6o: // global
           call _cab5B(R1) args: 0, res: 0, upd: 0;
       cab5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab5B() //  [R1]
         { info_tbl: [(cab5B,
                       label: block_cab5B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab5B: // global
           I64[Sp - 24] = block_cab5H_info;
           _sa7Tw::P64 = P64[R1 + 15];
           _sa7Ty::P64 = P64[R1 + 31];
           _sa7TA::P64 = P64[R1 + 47];
           R1 = P64[_sa7TA::P64 + 8];
           P64[Sp - 16] = _sa7Ty::P64;
           P64[Sp - 8] = _sa7TA::P64;
           P64[Sp] = _sa7Tw::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uab6n; else goto cab5L;
       uab6n: // global
           call _cab5H(R1) args: 0, res: 0, upd: 0;
       cab5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab5H() //  [R1]
         { info_tbl: [(cab5H,
                       label: block_cab5H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab5H: // global
           I64[Sp] = block_cab5P_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uab6p; else goto cab5R;
       uab6p: // global
           call _cab5P(R1) args: 0, res: 0, upd: 0;
       cab5R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab5P() //  [R1]
         { info_tbl: [(cab5P,
                       label: block_cab5P_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab5P: // global
           if (R1 & 7 == 1) goto uab6l; else goto cab62;
       uab6l: // global
           Sp = Sp + 32;
           call _cab6g() args: 0, res: 0, upd: 0;
       cab62: // global
           _sa7TY::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cab60_info;
           R1 = _sa7TY::P64;
           if (R1 & 7 != 0) goto uab6q; else goto cab63;
       uab6q: // global
           call _cab60(R1) args: 0, res: 0, upd: 0;
       cab63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab60() //  [R1]
         { info_tbl: [(cab60,
                       label: block_cab60_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab60: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uab6m; else goto cab6d;
       uab6m: // global
           Sp = Sp + 32;
           call _cab6g() args: 0, res: 0, upd: 0;
       cab6d: // global
           _sa7Ty::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cab6b_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7Ty::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cab6g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab6g: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cab6b() //  [R1]
         { info_tbl: [(cab6b,
                       label: block_cab6b_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab6b: // global
           _sa7TA::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7TA::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7TA::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.563835168 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer_entry() //  [R2]
         { info_tbl: [(cab74,
                       label: GHC.IO.Handle.Internals.flushWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab74: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.567159453 UTC

[section ""cstring" . lvl7_ra7Pn_bytes" {
     lvl7_ra7Pn_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.568994987 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf2_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf2_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf2_entry() //  [R1]
         { info_tbl: [(cab7k,
                       label: GHC.IO.Handle.Internals.decodeByteBuf2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab7k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cab7l; else goto cab7m;
       cab7l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cab7m: // global
           (_cab7f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cab7f::I64 == 0) goto cab7h; else goto cab7g;
       cab7h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cab7g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cab7f::I64;
           I64[Sp - 24] = block_cab7i_info;
           R2 = lvl7_ra7Pn_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cab7i() //  [R1]
         { info_tbl: [(cab7i,
                       label: block_cab7i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab7i: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.575415412 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf1_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf1_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf1_entry() //  [R2, R3]
         { info_tbl: [(cab7H,
                       label: GHC.IO.Handle.Internals.decodeByteBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab7H: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cab7I; else goto cab7J;
       cab7I: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.decodeByteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cab7J: // global
           I64[Sp - 16] = block_cab7E_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uab8K; else goto cab7F;
       uab8K: // global
           call _cab7E(R1) args: 0, res: 0, upd: 0;
       cab7F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab7E() //  [R1]
         { info_tbl: [(cab7E,
                       label: block_cab7E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab7E: // global
           I64[Sp - 24] = block_cab7M_info;
           _sa7Ul::P64 = P64[R1 + 47];
           _sa7Un::P64 = P64[R1 + 63];
           R1 = P64[R1 + 95];
           P64[Sp - 16] = _sa7Un::P64;
           P64[Sp - 8] = P64[_sa7Ul::P64 + 8];
           P64[Sp] = _sa7Ul::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uab8J; else goto cab7O;
       uab8J: // global
           call _cab7M(R1) args: 0, res: 0, upd: 0;
       cab7O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab7M() //  [R1]
         { info_tbl: [(cab7M,
                       label: block_cab7M_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab7M: // global
           if (R1 & 7 == 1) goto cab80; else goto cab8r;
       cab80: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cab83; else goto cab82;
       cab83: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab82: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sa7Uy::P64 = P64[Sp + 16];
           P64[Hp] = _sa7Uy::P64;
           _sa7Ud::P64 = P64[Sp + 32];
           _sa7Un::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Un::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Un::P64);
           I64[Sp + 16] = block_cab7W_info;
           R3 = _sa7Ud::P64;
           R2 = _sa7Uy::P64;
           Sp = Sp + 16;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cab8r: // global
           I64[Sp] = block_cab8c_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab8L; else goto cab8d;
       uab8L: // global
           call _cab8c(R1) args: 0, res: 0, upd: 0;
       cab8d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab7W() //  [R1]
         { info_tbl: [(cab7W,
                       label: block_cab7W_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab7W: // global
           I64[Sp] = block_cab7Y_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uab8M; else goto cab85;
       uab8M: // global
           call _cab7Y(R1) args: 0, res: 0, upd: 0;
       cab85: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab7Y() //  [R1]
         { info_tbl: [(cab7Y,
                       label: block_cab7Y_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab7Y: // global
           _sa7Ul::P64 = P64[Sp + 8];
           _sa7UH::P64 = P64[R1 + 15];
           _sa7UI::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sa7Ul::P64 + 8] = _sa7UH::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Ul::P64);
           R1 = _sa7UI::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cab8c() //  [R1]
         { info_tbl: [(cab8c,
                       label: block_cab8c_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab8c: // global
           I64[Sp - 16] = block_cab8h_info;
           _sa7UM::P64 = P64[R1 + 7];
           _sa7UN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sa7UN::P64;
           P64[Sp] = _sa7UM::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab8h() //  [R1]
         { info_tbl: [(cab8h,
                       label: block_cab8h_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab8h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cab8v; else goto cab8u;
       cab8v: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab8u: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa7Uy::P64 = P64[Sp + 32];
           P64[Hp] = _sa7Uy::P64;
           _sa7Ud::P64 = P64[Sp + 48];
           _sa7Un::P64 = P64[Sp + 24];
           _sa7UM::P64 = P64[Sp + 16];
           _sa7UN::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Un::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Un::P64);
           I64[Sp + 32] = block_cab8n_info;
           R5 = _sa7Ud::P64;
           R4 = _sa7Uy::P64;
           R3 = _sa7UN::P64;
           R2 = _sa7UM::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cab8n() //  [R1]
         { info_tbl: [(cab8n,
                       label: block_cab8n_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab8n: // global
           I64[Sp] = block_cab8p_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uab8N; else goto cab8x;
       uab8N: // global
           call _cab8p(R1) args: 0, res: 0, upd: 0;
       cab8x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab8p() //  [R1]
         { info_tbl: [(cab8p,
                       label: block_cab8p_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab8p: // global
           _sa7Ul::P64 = P64[Sp + 8];
           _sa7V0::P64 = P64[R1 + 7];
           _sa7V1::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa7Ul::P64 + 8] = _sa7V0::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Ul::P64);
           R1 = _sa7V1::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.595737234 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf_entry() //  [R2, R3]
         { info_tbl: [(cab9B,
                       label: GHC.IO.Handle.Internals.decodeByteBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab9B: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.59997641 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cab9P,
                       label: GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab9P: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cab9T; else goto cab9U;
       cab9T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cab9U: // global
           I64[Sp - 16] = block_cab9M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabay; else goto cab9N;
       uabay: // global
           call _cab9M(R1) args: 0, res: 0, upd: 0;
       cab9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab9M() //  [R1]
         { info_tbl: [(cab9M,
                       label: block_cab9M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab9M: // global
           I64[Sp - 32] = block_cab9S_info;
           _sa7V6::P64 = R1;
           _sa7V8::P64 = P64[R1 + 15];
           _sa7Va::P64 = P64[R1 + 31];
           _sa7Vc::P64 = P64[R1 + 47];
           R1 = P64[_sa7Vc::P64 + 8];
           P64[Sp - 24] = _sa7V8::P64;
           P64[Sp - 16] = _sa7Va::P64;
           P64[Sp - 8] = _sa7Vc::P64;
           P64[Sp] = _sa7V6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabax; else goto cab9W;
       uabax: // global
           call _cab9S(R1) args: 0, res: 0, upd: 0;
       cab9W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab9S() //  [R1]
         { info_tbl: [(cab9S,
                       label: block_cab9S_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab9S: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabaa; else goto caba4;
       cabaa: // global
           _sa7Va::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caba7_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa7Va::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
       caba4: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _caba7() //  [R1]
         { info_tbl: [(caba7,
                       label: block_caba7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caba7: // global
           I64[Sp] = block_caba9_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabaz; else goto cabac;
       uabaz: // global
           call _caba9(R1) args: 0, res: 0, upd: 0;
       cabac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caba9() //  [R1]
         { info_tbl: [(caba9,
                       label: block_caba9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caba9: // global
           I64[Sp - 8] = block_cabag_info;
           _sa7VD::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa7VD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabaA; else goto cabai;
       uabaA: // global
           call _cabag(R1) args: 0, res: 0, upd: 0;
       cabai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabag() //  [R1]
         { info_tbl: [(cabag,
                       label: block_cabag_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabag: // global
           if (R1 & 7 == 1) goto cabao; else goto cabas;
       cabao: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabas: // global
           _sa7V4::P64 = P64[Sp + 32];
           _sa7V6::P64 = P64[Sp + 24];
           _sa7Vc::P64 = P64[Sp + 16];
           _sa7VD::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Vc::P64 + 8] = _sa7VD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Vc::P64);
           R3 = _sa7V4::P64;
           R2 = _sa7V6::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.613755973 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cabb7,
                       label: GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabb7: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.621697252 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle2_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle2_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle2_info;
         const 0;
 },
 sat_sa7WE_entry() //  [R1]
         { info_tbl: [(cabc5,
                       label: sat_sa7WE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabc5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabc9; else goto cabca;
       cabc9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabca: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabc2_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabce; else goto cabc3;
       uabce: // global
           call _cabc2(R1) args: 0, res: 0, upd: 0;
       cabc3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabc2() //  [R1]
         { info_tbl: [(cabc2,
                       label: block_cabc2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabc2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabcd; else goto cabcc;
       cabcd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabcc: // global
           _sa7Wz::P64 = P64[R1 + 7];
           _sa7Wy::I64 = I64[R1 + 23];
           _sa7WB::I64 = I64[R1 + 31];
           _sa7WC::I64 = I64[R1 + 39];
           _sa7WD::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Wz::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Wy::I64;
           I64[Hp - 16] = _sa7WB::I64;
           I64[Hp - 8] = _sa7WC::I64;
           I64[Hp] = _sa7WD::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7WQ_entry() //  [R1]
         { info_tbl: [(cabcp,
                       label: sat_sa7WQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabcp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabct; else goto cabcu;
       cabct: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabcu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabcm_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabcy; else goto cabcn;
       uabcy: // global
           call _cabcm(R1) args: 0, res: 0, upd: 0;
       cabcn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabcm() //  [R1]
         { info_tbl: [(cabcm,
                       label: block_cabcm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabcm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabcx; else goto cabcw;
       cabcx: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabcw: // global
           _sa7WL::P64 = P64[R1 + 7];
           _sa7WK::I64 = I64[R1 + 23];
           _sa7WN::I64 = I64[R1 + 31];
           _sa7WO::I64 = I64[R1 + 39];
           _sa7WP::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7WL::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7WK::I64;
           I64[Hp - 16] = _sa7WN::I64;
           I64[Hp - 8] = _sa7WO::I64;
           I64[Hp] = _sa7WP::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7X2_entry() //  [R1]
         { info_tbl: [(cabcH,
                       label: sat_sa7X2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabcH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabcL; else goto cabcM;
       cabcL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabcM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabcE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabcQ; else goto cabcF;
       uabcQ: // global
           call _cabcE(R1) args: 0, res: 0, upd: 0;
       cabcF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabcE() //  [R1]
         { info_tbl: [(cabcE,
                       label: block_cabcE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabcE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabcP; else goto cabcO;
       cabcP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabcO: // global
           _sa7WX::P64 = P64[R1 + 7];
           _sa7WW::I64 = I64[R1 + 23];
           _sa7WZ::I64 = I64[R1 + 31];
           _sa7X0::I64 = I64[R1 + 39];
           _sa7X1::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7WX::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7WW::I64;
           I64[Hp - 16] = _sa7WZ::I64;
           I64[Hp - 8] = _sa7X0::I64;
           I64[Hp] = _sa7X1::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Xe_entry() //  [R1]
         { info_tbl: [(cabd1,
                       label: sat_sa7Xe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabd1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabd5; else goto cabd6;
       cabd5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabd6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabcY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabda; else goto cabcZ;
       uabda: // global
           call _cabcY(R1) args: 0, res: 0, upd: 0;
       cabcZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabcY() //  [R1]
         { info_tbl: [(cabcY,
                       label: block_cabcY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabcY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabd9; else goto cabd8;
       cabd9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabd8: // global
           _sa7X9::P64 = P64[R1 + 7];
           _sa7X8::I64 = I64[R1 + 23];
           _sa7Xb::I64 = I64[R1 + 31];
           _sa7Xc::I64 = I64[R1 + 39];
           _sa7Xd::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7X9::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7X8::I64;
           I64[Hp - 16] = _sa7Xb::I64;
           I64[Hp - 8] = _sa7Xc::I64;
           I64[Hp] = _sa7Xd::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Xq_entry() //  [R1]
         { info_tbl: [(cabdj,
                       label: sat_sa7Xq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabdj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabdn; else goto cabdo;
       cabdn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabdo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabdg_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabds; else goto cabdh;
       uabds: // global
           call _cabdg(R1) args: 0, res: 0, upd: 0;
       cabdh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabdg() //  [R1]
         { info_tbl: [(cabdg,
                       label: block_cabdg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabdg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabdr; else goto cabdq;
       cabdr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabdq: // global
           _sa7Xl::P64 = P64[R1 + 7];
           _sa7Xk::I64 = I64[R1 + 23];
           _sa7Xn::I64 = I64[R1 + 31];
           _sa7Xo::I64 = I64[R1 + 39];
           _sa7Xp::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Xl::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Xk::I64;
           I64[Hp - 16] = _sa7Xn::I64;
           I64[Hp - 8] = _sa7Xo::I64;
           I64[Hp] = _sa7Xp::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7XC_entry() //  [R1]
         { info_tbl: [(cabdD,
                       label: sat_sa7XC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabdD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabdH; else goto cabdI;
       cabdH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabdI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabdA_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabdM; else goto cabdB;
       uabdM: // global
           call _cabdA(R1) args: 0, res: 0, upd: 0;
       cabdB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabdA() //  [R1]
         { info_tbl: [(cabdA,
                       label: block_cabdA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabdA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabdL; else goto cabdK;
       cabdL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabdK: // global
           _sa7Xx::P64 = P64[R1 + 7];
           _sa7Xw::I64 = I64[R1 + 23];
           _sa7Xz::I64 = I64[R1 + 31];
           _sa7XA::I64 = I64[R1 + 39];
           _sa7XB::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Xx::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Xw::I64;
           I64[Hp - 16] = _sa7Xz::I64;
           I64[Hp - 8] = _sa7XA::I64;
           I64[Hp] = _sa7XB::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle2_entry() //  [R2, R3]
         { info_tbl: [(cabdN,
                       label: GHC.IO.Handle.Internals.wantReadableHandle2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabdN: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cabdO; else goto cabdP;
       cabdO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cabdP: // global
           I64[Sp - 16] = block_cabbi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabeN; else goto cabbj;
       uabeN: // global
           call _cabbi(R1) args: 0, res: 0, upd: 0;
       cabbj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabbi() //  [R1]
         { info_tbl: [(cabbi,
                       label: block_cabbi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabbi: // global
           I64[Sp - 40] = block_cabbn_info;
           _sa7VL::P64 = R1;
           _sa7VN::P64 = P64[R1 + 15];
           _sa7VP::P64 = P64[R1 + 31];
           _sa7VR::P64 = P64[R1 + 47];
           _sa7VU::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sa7VN::P64;
           P64[Sp - 24] = _sa7VP::P64;
           P64[Sp - 16] = _sa7VR::P64;
           P64[Sp - 8] = _sa7VU::P64;
           P64[Sp] = _sa7VL::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uabeH; else goto cabbo;
       uabeH: // global
           call _cabbn(R1) args: 0, res: 0, upd: 0;
       cabbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabbn() //  [R1]
         { info_tbl: [(cabbn,
                       label: block_cabbn_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabbn: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto cabdU;
               case 2 : goto cabdX;
               case 3 : goto uabeF;
               case 4, 5 : goto cabe6;
               case 6 : goto cabe8;
           }
       cabe8: // global
           _sa7W5::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cabbx_info;
           R1 = _sa7W5::P64;
           if (R1 & 7 != 0) goto uabeI; else goto cabby;
       uabeI: // global
           call _cabbx(R1) args: 0, res: 0, upd: 0;
       cabby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabe6: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uabeF: // global
           Sp = Sp + 40;
           call _cabed() args: 0, res: 0, upd: 0;
       cabdX: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabdU: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cabbx() //  [R1]
         { info_tbl: [(cabbx,
                       label: block_cabbx_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabbx: // global
           I64[Sp - 16] = block_cabbC_info;
           _sa7Wb::I64 = I64[R1 + 39];
           _sa7Wc::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa7Wc::I64;
           I64[Sp] = _sa7Wb::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabeK; else goto cabbD;
       uabeK: // global
           call _cabbC(R1) args: 0, res: 0, upd: 0;
       cabbD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabbC() //  [R1]
         { info_tbl: [(cabbC,
                       label: block_cabbC_info
                       rep:StackRep [True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabbC: // global
           if (R1 & 7 == 1) goto uabeG; else goto cabee;
       uabeG: // global
           Sp = Sp + 56;
           call _cabed() args: 0, res: 0, upd: 0;
       cabee: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cabeh; else goto cabeg;
       cabeh: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabeg: // global
           _sa7VR::P64 = P64[Sp + 40];
           if (I64[Sp + 16] == I64[Sp + 8]) goto cabet; else goto cabej;
       cabet: // global
           _sa7VU::P64 = P64[Sp + 48];
           _sa7Xi::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7Xq_info;
           P64[Hp - 24] = _sa7Xi::P64;
           _sa7VI::P64 = P64[Sp + 64];
           _sa7VL::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7Xu::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7XC_info;
           P64[Hp] = _sa7Xu::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 72;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cabej: // global
           _sa7Wh::P64 = P64[_sa7VR::P64 + 8];
           Hp = Hp - 48;
           I64[Sp + 16] = block_cabbL_info;
           R1 = _sa7Wh::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabeL; else goto cabbM;
       uabeL: // global
           call _cabbL(R1) args: 0, res: 0, upd: 0;
       cabbM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabbL() //  [R1]
         { info_tbl: [(cabbL,
                       label: block_cabbL_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabbL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cabem; else goto cabel;
       cabem: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabel: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabes; else goto cabeo;
       cabes: // global
           _sa7VU::P64 = P64[Sp + 32];
           _sa7WU::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7X2_info;
           P64[Hp - 24] = _sa7WU::P64;
           _sa7VI::P64 = P64[Sp + 48];
           _sa7VL::P64 = P64[Sp + 40];
           _sa7VR::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7X6::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7Xe_info;
           P64[Hp] = _sa7X6::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cabeo: // global
           Hp = Hp - 48;
           _sa7VP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabbT_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa7VP::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cabbT() //  [R1]
         { info_tbl: [(cabbT,
                       label: block_cabbT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabbT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caber; else goto cabeq;
       caber: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabeq: // global
           _sa7VI::P64 = P64[Sp + 32];
           _sa7VL::P64 = P64[Sp + 24];
           _sa7VR::P64 = P64[Sp + 8];
           _sa7VU::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           _sa7Ww::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7WE_info;
           P64[Hp - 24] = _sa7Ww::P64;
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7WI::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7WQ_info;
           P64[Hp] = _sa7WI::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cabed() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabed: // global
           R2 = P64[Sp];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.66648585 UTC

[section ""data" . lvl8_ra7Po_closure" {
     lvl8_ra7Po_closure:
         const GHC.IO.Handle.Types.BlockBuffering_con_info;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.674624584 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle5_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle5_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle5_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabgx: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 56, res: 0, upd: 8;
     }
 },
 buf_state_sa7XU_entry() //  [R1]
         { info_tbl: [(cabi8,
                       label: buf_state_sa7XU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabi8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabi9; else goto cabia;
       cabi9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabi1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabih; else goto cabi2;
       uabih: // global
           call _cabi1(R1) args: 0, res: 0, upd: 0;
       cabi2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabi1() //  [R1]
         { info_tbl: [(cabi1,
                       label: block_cabi1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabi1: // global
           if (R1 & 7 == 3) goto cabi6; else goto cabi5;
       cabi6: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cabi5: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yk_entry() //  [R1]
         { info_tbl: [(cabiE,
                       label: sat_sa7Yk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabiE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabiF; else goto cabiG;
       cabiF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabiG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.outputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yj_entry() //  [R1]
         { info_tbl: [(cabiL,
                       label: sat_sa7Yj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabiL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabiM; else goto cabiN;
       cabiM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabiN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.inputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yl_entry() //  [R1]
         { info_tbl: [(cabiO,
                       label: sat_sa7Yl_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabiO: // global
           if ((Sp + -136) < SpLim) (likely: False) goto cabiQ; else goto cabiR;
       cabiQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabiR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_cabit_info;
           _sa7XE::P64 = P64[R1 + 16];
           _sa7XF::P64 = P64[R1 + 24];
           _sa7XG::P64 = P64[R1 + 32];
           _sa7XJ::P64 = P64[R1 + 48];
           _sa7XL::P64 = P64[R1 + 56];
           _sa7XM::P64 = P64[R1 + 64];
           _sa7XO::P64 = P64[R1 + 72];
           _sa7XR::P64 = P64[R1 + 80];
           _sa7XS::P64 = P64[R1 + 88];
           _sa7Y1::P64 = P64[R1 + 96];
           _sa7Y5::P64 = P64[R1 + 104];
           _sa7Y8::P64 = P64[R1 + 112];
           _sa7Y9::P64 = P64[R1 + 120];
           _sa7Yc::P64 = P64[R1 + 128];
           R1 = P64[R1 + 40];
           P64[Sp - 128] = _sa7XE::P64;
           P64[Sp - 120] = _sa7XF::P64;
           P64[Sp - 112] = _sa7XG::P64;
           P64[Sp - 104] = _sa7XJ::P64;
           P64[Sp - 96] = _sa7XL::P64;
           P64[Sp - 88] = _sa7XM::P64;
           P64[Sp - 80] = _sa7XO::P64;
           P64[Sp - 72] = _sa7XR::P64;
           P64[Sp - 64] = _sa7XS::P64;
           P64[Sp - 56] = _sa7Y1::P64;
           P64[Sp - 48] = _sa7Y5::P64;
           P64[Sp - 40] = _sa7Y8::P64;
           P64[Sp - 32] = _sa7Y9::P64;
           P64[Sp - 24] = _sa7Yc::P64;
           Sp = Sp - 136;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabit() //  [R1]
         { info_tbl: [(cabit,
                       label: block_cabit_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabit: // global
           I64[Sp] = block_cabiv_info;
           _sa7Yg::P64 = R1;
           R1 = P64[Sp + 96];
           P64[Sp + 96] = _sa7Yg::P64;
           if (R1 & 7 != 0) goto uabiW; else goto cabiw;
       uabiW: // global
           call _cabiv(R1) args: 0, res: 0, upd: 0;
       cabiw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabiv() //  [R1]
         { info_tbl: [(cabiv,
                       label: block_cabiv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabiv: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cabiV; else goto cabiU;
       cabiV: // global
           HpAlloc = 184;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabiU: // global
           _sa7Yi::P64 = P64[R1 + 7];
           I64[Hp - 176] = sat_sa7Yk_info;
           _sa7XM::P64 = P64[Sp + 48];
           P64[Hp - 160] = _sa7XM::P64;
           I64[Hp - 152] = sat_sa7Yj_info;
           P64[Hp - 136] = _sa7XM::P64;
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = _sa7Yi::P64;
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = Hp - 152;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 127;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Yr_entry() //  [R1]
         { info_tbl: [(cabja,
                       label: sat_sa7Yr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabja: // global
           _sa7Yr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cabjb; else goto cabjc;
       cabjc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabje; else goto cabjd;
       cabje: // global
           HpAlloc = 16;
           goto cabjb;
       cabjb: // global
           R1 = _sa7Yr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabjd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Yr::P64;
           _sa7XI::P64 = P64[_sa7Yr::P64 + 16];
           _sa7Yf::P64 = P64[_sa7Yr::P64 + 24];
           _sa7Yp::P64 = P64[_sa7Yr::P64 + 32];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _sa7Yf::P64;
           R3 = Hp - 7;
           R2 = _sa7XI::P64;
           R1 = _sa7Yp::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa7Z1_entry() //  [R1]
         { info_tbl: [(cabjo,
                       label: sat_sa7Z1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabjo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabjp; else goto cabjq;
       cabjp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabjq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabjh_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabjx; else goto cabji;
       uabjx: // global
           call _cabjh(R1) args: 0, res: 0, upd: 0;
       cabji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabjh() //  [R1]
         { info_tbl: [(cabjh,
                       label: block_cabjh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabjh: // global
           if (R1 & 7 == 1) goto cabjl; else goto cabjm;
       cabjl: // global
           R1 = lvl8_ra7Po_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cabjm: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cabjC,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle5_info
                       rep:HeapRep static {
                             Fun {arity: 12
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabjC: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cabjD; else goto cabjE;
       cabjD: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 96, res: 0, upd: 8;
       cabjE: // global
           I64[Sp - 48] = block_cabhq_info;
           R1 = P64[Sp + 16];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uablO; else goto cabhr;
       uablO: // global
           call _cabhq(R1) args: 0, res: 0, upd: 0;
       cabhr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabhq() //  [R1]
         { info_tbl: [(cabhq,
                       label: block_cabhq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabhq: // global
           if (R1 & 7 == 1) goto cabjz; else goto cabjA;
       cabjz: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _cabgE() args: 0, res: 0, upd: 0;
       cabjA: // global
           I64[Sp] = block_cabhw_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uablG; else goto cabhx;
       uablG: // global
           call _cabhw(R1) args: 0, res: 0, upd: 0;
       cabhx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabhw() //  [R1]
         { info_tbl: [(cabhw,
                       label: block_cabhw_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabhw: // global
           I64[Sp - 16] = block_cabkx_info;
           _sa7Z6::P64 = P64[R1 + 15];
           _sa7Z7::P64 = P64[R1 + 23];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _sa7Z7::P64;
           P64[Sp] = _sa7Z6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uablI; else goto cabkT;
       uablI: // global
           call _cabkx(R1) args: 0, res: 0, upd: 0;
       cabkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabkx() //  [R1]
         { info_tbl: [(cabkx,
                       label: block_cabkx_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabkx: // global
           _sa7Z6::P64 = P64[Sp + 16];
           _cabli::P64 = R1 & 7;
           if (_cabli::P64 != 3) goto uablq; else goto cabl4;
       uablq: // global
           if (_cabli::P64 != 6) goto cabkZ; else goto cabld;
       cabkZ: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
       cabld: // global
           I64[Sp] = block_cablb_info;
           R1 = _sa7Z6::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cabl4: // global
           I64[Sp] = block_cabl2_info;
           R1 = _sa7Z6::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cablb() //  [R1]
         { info_tbl: [(cablb,
                       label: block_cablb_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cablb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cablh; else goto cablg;
       cablh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cablg: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
     }
 },
 _cabl2() //  [R1]
         { info_tbl: [(cabl2,
                       label: block_cabl2_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabl2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabl8; else goto cabl7;
       cabl8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabl7: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
     }
 },
 _sa7Z8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa7Z8: // global
           I64[Sp - 8] = block_cabhG_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uablS; else goto cabhH;
       uablS: // global
           call _cabhG(R1) args: 0, res: 0, upd: 0;
       cabhH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabhG() //  [R1]
         { info_tbl: [(cabhG,
                       label: block_cabhG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabhG: // global
           _sa7Z7::P64 = P64[Sp + 8];
           _cabll::P64 = R1 & 7;
           if (_cabll::P64 < 5) goto uablo; else goto uablp;
       uablo: // global
           if (_cabll::P64 < 4) goto cabkD; else goto cabkF;
       cabkD: // global
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _cabgE() args: 0, res: 0, upd: 0;
       cabkF: // global
           I64[Sp + 8] = block_cabhM_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       uablp: // global
           if (_cabll::P64 < 6) goto cabkK; else goto cabkP;
       cabkK: // global
           I64[Sp + 8] = block_cabhR_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cabkP: // global
           I64[Sp + 8] = block_cabhW_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabhM() //  [R1]
         { info_tbl: [(cabhM,
                       label: block_cabhM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabhM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabkI; else goto cabkH;
       cabkI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabkH: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _cabgE() args: 0, res: 0, upd: 0;
     }
 },
 _cabhR() //  [R1]
         { info_tbl: [(cabhR,
                       label: block_cabhR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabhR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabkN; else goto cabkM;
       cabkN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabkM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _cabgE() args: 0, res: 0, upd: 0;
     }
 },
 _cabhW() //  [R1]
         { info_tbl: [(cabhW,
                       label: block_cabhW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabhW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabkS; else goto cabkR;
       cabkS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabkR: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _cabgE() args: 0, res: 0, upd: 0;
     }
 },
 _cabgE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabgE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabjH; else goto cabjG;
       cabjH: // global
           HpAlloc = 24;
           _sa7XR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabgD_info;
           R2 = P64[Sp];
           R1 = _sa7XR::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cabjG: // global
           I64[Hp - 16] = buf_state_sa7XU_info;
           P64[Hp] = P64[Sp + 56];
           I64[Sp - 16] = block_cabgI_info;
           R2 = P64[Sp + 24];
           I64[Sp - 40] = stg_ap_ppv_info;
           P64[Sp - 32] = P64[Sp + 40];
           _cabgG::P64 = Hp - 16;
           P64[Sp - 24] = _cabgG::P64;
           P64[Sp - 8] = _cabgG::P64;
           Sp = Sp - 40;
           call GHC.IO.BufferedIO.newBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cabgD() //  [R1, R2]
         { info_tbl: [(cabgD,
                       label: block_cabgD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabgD: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cabgE() args: 0, res: 0, upd: 0;
     }
 },
 _cabgI() //  [R1]
         { info_tbl: [(cabgI,
                       label: block_cabgI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabgI: // global
           I64[Sp - 8] = block_cabgK_info;
           _sa7XY::P64 = R1;
           R1 = R1;
           P64[Sp] = _sa7XY::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabgK() //  [R1]
         { info_tbl: [(cabgK,
                       label: block_cabgK_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabgK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabjL; else goto cabjK;
       cabjL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabjK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cabgN_info;
           _sa7Y1::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _sa7Y1::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabgN() //  [R1]
         { info_tbl: [(cabgN,
                       label: block_cabgN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabgN: // global
           I64[Sp] = block_cabgR_info;
           _sa7Y5::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _sa7Y5::P64;
           if (R1 & 7 != 0) goto uablD; else goto cabgS;
       uablD: // global
           call _cabgR(R1) args: 0, res: 0, upd: 0;
       cabgS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabgR() //  [R1]
         { info_tbl: [(cabgR,
                       label: block_cabgR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabgR: // global
           if (R1 & 7 == 1) goto cabkc; else goto cabkl;
       cabkc: // global
           I64[Sp] = block_cabgW_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cabkl: // global
           I64[Sp] = block_cabha_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabgW() //  [R1]
         { info_tbl: [(cabgW,
                       label: block_cabgW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabgW: // global
           I64[Sp - 8] = block_cabgY_info;
           _sa7Yz::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sa7Yz::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabgY() //  [R1]
         { info_tbl: [(cabgY,
                       label: block_cabgY_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabgY: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cabkg; else goto cabkf;
       cabkg: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabkf: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_cabh5_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabh5() //  [R1]
         { info_tbl: [(cabh5,
                       label: block_cabh5_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabh5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabkj; else goto cabki;
       cabkj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabki: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 7;
           P64[Sp] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           call _sa7Y6() args: 0, res: 0, upd: 0;
     }
 },
 _cabha() //  [R1]
         { info_tbl: [(cabha,
                       label: block_cabha_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabha: // global
           I64[Sp - 8] = block_cabhc_info;
           _sa7YM::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sa7YM::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabhc() //  [R1]
         { info_tbl: [(cabhc,
                       label: block_cabhc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabhc: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cabkp; else goto cabko;
       cabkp: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabko: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_cabhj_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabhj() //  [R1]
         { info_tbl: [(cabhj,
                       label: block_cabhj_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabhj: // global
           I64[Sp] = block_cabhl_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 64];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cabhl() //  [R1]
         { info_tbl: [(cabhl,
                       label: block_cabhl_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabhl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cabkt; else goto cabks;
       cabkt: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabks: // global
           I64[Hp - 32] = sat_sa7Z1_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = Hp - 32;
           P64[Sp + 16] = Hp - 7;
           call _sa7Y6() args: 0, res: 0, upd: 0;
     }
 },
 _sa7Y6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa7Y6: // global
           I64[Sp - 8] = block_cabil_info;
           R1 = GHC.IO.Handle.Types.BufferListNil_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabil() //  [R1]
         { info_tbl: [(cabil,
                       label: block_cabil_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabil: // global
           I64[Sp - 8] = block_cabin_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cabin() //  [R1]
         { info_tbl: [(cabin,
                       label: block_cabin_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabin: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cabjR; else goto cabjQ;
       cabjR: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabjQ: // global
           I64[Hp - 128] = sat_sa7Yl_info;
           P64[Hp - 112] = P64[Sp + 56];
           P64[Hp - 104] = P64[Sp + 64];
           P64[Hp - 96] = P64[Sp + 72];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 112];
           P64[Hp - 64] = P64[Sp + 120];
           P64[Hp - 56] = P64[Sp + 136];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 104];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 80] = block_cabiX_info;
           R2 = Hp - 128;
           _sa7Yf::P64 = R1;
           R1 = R1;
           P64[Sp + 136] = _sa7Yf::P64;
           Sp = Sp + 80;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabiX() //  []
         { info_tbl: [(cabiX,
                       label: block_cabiX_info
                       rep:StackRep [False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabiX: // global
           I64[Sp] = block_cabiZ_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uablN; else goto cabj0;
       uablN: // global
           call _cabiZ(R1) args: 0, res: 0, upd: 0;
       cabj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabiZ() //  [R1]
         { info_tbl: [(cabiZ,
                       label: block_cabiZ_info
                       rep:StackRep [False, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabiZ: // global
           _sa7XI::P64 = P64[Sp + 8];
           _sa7Yf::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cabjW; else goto cabk3;
       cabjW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabjZ; else goto cabjY;
       cabjZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabjY: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = _sa7XI::P64;
           P64[Hp] = _sa7Yf::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabk3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cabk6; else goto cabk5;
       cabk6: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabk5: // global
           _sa7Yp::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_sa7Yr_info;
           P64[Hp - 16] = _sa7XI::P64;
           P64[Hp - 8] = _sa7Yf::P64;
           P64[Hp] = _sa7Yp::P64;
           I64[Sp] = block_cabk0_info;
           R3 = Hp - 32;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _sa7Yf::P64;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabk0() //  [R1]
         { info_tbl: [(cabk0,
                       label: block_cabk0_info
                       rep:StackRep [False, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabk0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabk9; else goto cabk8;
       cabk9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabk8: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.753840771 UTC

[section ""data" . GHC.IO.Handle.Internals.mkHandle_closure" {
     GHC.IO.Handle.Internals.mkHandle_closure:
         const GHC.IO.Handle.Internals.mkHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabph: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkHandle_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 56, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkHandle_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cabpl,
                       label: GHC.IO.Handle.Internals.mkHandle_info
                       rep:HeapRep static {
                             Fun {arity: 12
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabpl: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.759361753 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO1_closure" {
     GHC.IO.Handle.Internals.debugIO1_closure:
         const GHC.IO.Handle.Internals.debugIO1_info;
 },
 GHC.IO.Handle.Internals.debugIO1_entry() //  []
         { info_tbl: [(cabpy,
                       label: GHC.IO.Handle.Internals.debugIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabpy: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.762753636 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO_closure" {
     GHC.IO.Handle.Internals.debugIO_closure:
         const GHC.IO.Handle.Internals.debugIO_info;
 },
 GHC.IO.Handle.Internals.debugIO_entry() //  [R2]
         { info_tbl: [(cabpK,
                       label: GHC.IO.Handle.Internals.debugIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabpK: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.debugIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.769902602 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwriteCharBuffer_closure" {
     GHC.IO.Handle.Internals.$wwriteCharBuffer_closure:
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_info;
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabpS: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cabpZ,
                       label: GHC.IO.Handle.Internals.$wwriteCharBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabpZ: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cabq0; else goto uabt5;
       cabq0: // global
           R1 = GHC.IO.Handle.Internals.$wwriteCharBuffer_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       uabt5: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cabpT() args: 0, res: 0, upd: 0;
     }
 },
 _cabpT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabpT: // global
           _sa7Zz::P64 = P64[Sp];
           I64[Sp] = block_cabpW_info;
           R1 = _sa7Zz::P64;
           if (R1 & 7 != 0) goto uabtl; else goto cabpX;
       uabtl: // global
           call _cabpW(R1) args: 0, res: 0, upd: 0;
       cabpX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabpW() //  [R1]
         { info_tbl: [(cabpW,
                       label: block_cabpW_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabpW: // global
           I64[Sp - 48] = block_cabq6_info;
           _sa7ZH::P64 = R1;
           _sa7ZJ::P64 = P64[R1 + 15];
           _sa7ZL::P64 = P64[R1 + 31];
           _sa7ZN::P64 = P64[R1 + 47];
           _sa7ZO::P64 = P64[R1 + 55];
           R1 = P64[R1 + 87];
           P64[Sp - 40] = _sa7ZJ::P64;
           P64[Sp - 32] = _sa7ZL::P64;
           P64[Sp - 24] = _sa7ZN::P64;
           P64[Sp - 16] = _sa7ZO::P64;
           P64[Sp - 8] = P64[_sa7ZN::P64 + 8];
           P64[Sp] = _sa7ZH::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uabtm; else goto cabsa;
       uabtm: // global
           call _cabq6(R1) args: 0, res: 0, upd: 0;
       cabsa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabq6() //  [R1]
         { info_tbl: [(cabq6,
                       label: block_cabq6_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabq6: // global
           if (R1 & 7 == 1) goto cabso; else goto cabsQ;
       cabso: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabsr; else goto cabsq;
       cabsr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabsq: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_cabsf_info;
           R3 = P64[Sp + 40];
           R2 = Hp - 47;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cabsQ: // global
           I64[Sp] = block_cabsB_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabto; else goto cabsC;
       uabto: // global
           call _cabsB(R1) args: 0, res: 0, upd: 0;
       cabsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabsf() //  [R1]
         { info_tbl: [(cabsf,
                       label: block_cabsf_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabsf: // global
           I64[Sp] = block_cabsh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabtH; else goto cabsi;
       uabtH: // global
           call _cabsh(R1) args: 0, res: 0, upd: 0;
       cabsi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabsh() //  [R1]
         { info_tbl: [(cabsh,
                       label: block_cabsh_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabsh: // global
           I64[Sp] = block_cabsm_info;
           _sa80U::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp + 96] = _sa80U::P64;
           if (R1 & 7 != 0) goto uabtI; else goto cabsu;
       uabtI: // global
           call _cabsm(R1) args: 0, res: 0, upd: 0;
       cabsu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabsm() //  [R1]
         { info_tbl: [(cabsm,
                       label: block_cabsm_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabsm: // global
           P64[Sp + 96] = P64[Sp + 96];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 72] = P64[R1 + 7];
           P64[Sp + 64] = P64[R1 + 15];
           I64[Sp + 56] = I64[R1 + 31];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 8;
           call _cabq8() args: 0, res: 0, upd: 0;
     }
 },
 _cabsB() //  [R1]
         { info_tbl: [(cabsB,
                       label: block_cabsB_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabsB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabsT; else goto cabsS;
       cabsT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabsS: // global
           _sa815::P64 = P64[R1 + 7];
           _sa816::P64 = P64[R1 + 15];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_cabsH_info;
           R5 = P64[Sp + 40];
           R4 = Hp - 47;
           R3 = _sa816::P64;
           R2 = _sa815::P64;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cabsH() //  [R1]
         { info_tbl: [(cabsH,
                       label: block_cabsH_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabsH: // global
           I64[Sp] = block_cabsJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabtK; else goto cabsK;
       uabtK: // global
           call _cabsJ(R1) args: 0, res: 0, upd: 0;
       cabsK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabsJ() //  [R1]
         { info_tbl: [(cabsJ,
                       label: block_cabsJ_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabsJ: // global
           I64[Sp] = block_cabsO_info;
           _sa81f::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _sa81f::P64;
           if (R1 & 7 != 0) goto uabtL; else goto cabsW;
       uabtL: // global
           call _cabsO(R1) args: 0, res: 0, upd: 0;
       cabsW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabsO() //  [R1]
         { info_tbl: [(cabsO,
                       label: block_cabsO_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabsO: // global
           I64[Sp] = I64[R1 + 47];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp + 56] = I64[R1 + 31];
           P64[Sp + 64] = P64[R1 + 15];
           P64[Sp + 72] = P64[R1 + 7];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 96] = P64[Sp + 96];
           Sp = Sp - 8;
           call _cabq8() args: 0, res: 0, upd: 0;
     }
 },
 _cabq8() //  []
         { info_tbl: [(cabq8,
                       label: block_cabq8_info
                       rep:StackRep [True, False, False, False, False, True, False, True,
                                     False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabq8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabqd; else goto cabqc;
       cabqd: // global
           HpAlloc = 56;
           I64[Sp] = block_cabq8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cabqc: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 88];
           _sa807::I64 = I64[Sp + 64];
           I64[Hp - 16] = _sa807::I64;
           I64[Hp - 8] = I64[Sp + 48];
           _sa809::I64 = I64[Sp + 8];
           I64[Hp] = _sa809::I64;
           _cabqe::P64 = Hp - 47;
           if (_sa807::I64 == _sa809::I64) goto uabt8; else goto cabqH;
       uabt8: // global
           P64[Sp + 96] = _cabqe::P64;
           Sp = Sp + 16;
           call _sa80b() args: 0, res: 0, upd: 0;
       cabqH: // global
           I64[Sp] = block_cabqF_info;
           R1 = P64[Sp + 104];
           P64[Sp + 88] = _cabqe::P64;
           if (R1 & 7 != 0) goto uabtp; else goto cabqI;
       uabtp: // global
           call _cabqF(R1) args: 0, res: 0, upd: 0;
       cabqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabqF() //  [R1]
         { info_tbl: [(cabqF,
                       label: block_cabqF_info
                       rep:StackRep [True, False, False, False, False, True, False, True,
                                     True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabqF: // global
           _sa7ZO::P64 = P64[Sp + 40];
           _sa80r::P64 = P64[R1 + 7];
           _sa80s::P64 = P64[R1 + 15];
           _sa80q::I64 = I64[R1 + 23];
           _sa80t::I64 = I64[R1 + 31];
           _sa80u::I64 = I64[R1 + 39];
           _sa80v::I64 = I64[R1 + 47];
           if (_sa80u::I64 == _sa80v::I64) goto sa80w; else goto cabs7;
       cabs7: // global
           if (_sa80u::I64 != I64[Sp + 96]) goto sa80w; else goto uabt9;
       sa80w: // global
           I64[Sp - 8] = block_cabqS_info;
           R1 = _sa7ZO::P64;
           I64[Sp] = _sa80v::I64;
           I64[Sp + 40] = _sa80u::I64;
           I64[Sp + 64] = _sa80t::I64;
           P64[Sp + 72] = _sa80s::P64;
           P64[Sp + 80] = _sa80r::P64;
           I64[Sp + 96] = _sa80q::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabtu; else goto cabqU;
       uabtu: // global
           call _cabqS(R1) args: 0, res: 0, upd: 0;
       cabqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uabt9: // global
           P64[Sp + 96] = P64[Sp + 88];
           Sp = Sp + 16;
           call _sa80b() args: 0, res: 0, upd: 0;
     }
 },
 _cabqS() //  [R1]
         { info_tbl: [(cabqS,
                       label: block_cabqS_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabqS: // global
           _cabt2::P64 = R1 & 7;
           if (_cabt2::P64 < 3) goto uabt4; else goto cabrh;
       uabt4: // global
           _cabqe::P64 = P64[Sp + 96];
           if (_cabt2::P64 < 2) goto uabta; else goto cabrc;
       uabta: // global
           P64[Sp + 104] = _cabqe::P64;
           Sp = Sp + 24;
           call _sa80b() args: 0, res: 0, upd: 0;
       cabrc: // global
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _cabqe::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto uabtb; else goto uabtc;
       uabtb: // global
           Sp = Sp + 120;
           call _cabrU() args: 0, res: 0, upd: 0;
       uabtc: // global
           Sp = Sp + 8;
           call _cabrT() args: 0, res: 0, upd: 0;
       cabrh: // global
           I64[Sp] = block_cabrf_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto uabtw; else goto cabri;
       uabtw: // global
           call _cabrf(R1) args: 0, res: 0, upd: 0;
       cabri: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabrf() //  [R1]
         { info_tbl: [(cabrf,
                       label: block_cabrf_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabrf: // global
           if (R1 & 7 == 1) goto cabrw; else goto cabrB;
       cabrw: // global
           _cabqe::P64 = P64[Sp + 96];
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _cabqe::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto uabtg; else goto uabth;
       uabtg: // global
           Sp = Sp + 120;
           call _cabrU() args: 0, res: 0, upd: 0;
       uabth: // global
           Sp = Sp + 8;
           call _cabrT() args: 0, res: 0, upd: 0;
       cabrB: // global
           I64[Sp] = block_cabrz_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabtA; else goto cabrC;
       uabtA: // global
           call _cabrz(R1) args: 0, res: 0, upd: 0;
       cabrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabrz() //  [R1]
         { info_tbl: [(cabrz,
                       label: block_cabrz_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabrz: // global
           _cabqe::P64 = P64[Sp + 96];
           if (%MO_S_Lt_W64(I64[Sp + 16] - I64[Sp + 56],
                            I64[R1 + 7])) goto cabrW; else goto uabtd;
       cabrW: // global
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _cabqe::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto uabte; else goto uabtf;
       uabte: // global
           Sp = Sp + 120;
           call _cabrU() args: 0, res: 0, upd: 0;
       uabtf: // global
           Sp = Sp + 8;
           call _cabrT() args: 0, res: 0, upd: 0;
       uabtd: // global
           P64[Sp + 104] = _cabqe::P64;
           Sp = Sp + 24;
           call _sa80b() args: 0, res: 0, upd: 0;
     }
 },
 _cabrT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabrT: // global
           P64[Sp + 56] = P64[Sp + 56];
           _sa7ZD::I64 = I64[Sp + 64];
           I64[Sp + 64] = I64[Sp + 96];
           _sa7ZC::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sa7ZC::P64;
           I64[Sp + 88] = _sa7ZD::I64;
           I64[Sp + 96] = I64[Sp + 40];
           I64[Sp + 104] = I64[Sp];
           Sp = Sp + 56;
           call _cabpT() args: 0, res: 0, upd: 0;
     }
 },
 _sa80b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa80b: // global
           _sa7ZL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabqk_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7ZL::P64;
           P64[Sp] = P64[Sp + 80];
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cabqk() //  [R1]
         { info_tbl: [(cabqk,
                       label: block_cabqk_info
                       rep:StackRep [False, True, True, False, True, True, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabqk: // global
           _sa7ZN::P64 = P64[Sp + 8];
           _sa803::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           I64[Sp + 24] = block_cabqp_info;
           R1 = _sa803::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uabtr; else goto cabqs;
       uabtr: // global
           call _cabqp(R1) args: 0, res: 0, upd: 0;
       cabqs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabqp() //  [R1]
         { info_tbl: [(cabqp,
                       label: block_cabqp_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabqp: // global
           _sa80l::I64 = I64[R1 + 39];
           _sa80m::I64 = I64[R1 + 47];
           if (_sa80l::I64 == _sa80m::I64) goto uabtj; else goto cabqA;
       uabtj: // global
           Sp = Sp + 64;
           call _cabrU() args: 0, res: 0, upd: 0;
       cabqA: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 40] = I64[R1 + 31];
           I64[Sp + 48] = _sa80l::I64;
           I64[Sp + 56] = _sa80m::I64;
           Sp = Sp + 8;
           call _cabpT() args: 0, res: 0, upd: 0;
     }
 },
 _cabrU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabrU: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.813532044 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer1_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer1_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer1_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer1_entry() //  [R2, R3]
         { info_tbl: [(cabw0,
                       label: GHC.IO.Handle.Internals.writeCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabw0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabw1; else goto cabw2;
       cabw1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.writeCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cabw2: // global
           I64[Sp - 16] = block_cabvX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabw6; else goto cabvY;
       uabw6: // global
           call _cabvX(R1) args: 0, res: 0, upd: 0;
       cabvY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabvX() //  [R1]
         { info_tbl: [(cabvX,
                       label: block_cabvX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabvX: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.819560423 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer_entry() //  [R2, R3]
         { info_tbl: [(cabwm,
                       label: GHC.IO.Handle.Internals.writeCharBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabwm: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.writeCharBuffer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.82505724 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer3_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer3_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer3_info;
 },
 sat_sa82j_entry() //  [R1]
         { info_tbl: [(cabx1,
                       label: sat_sa82j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabx1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabx5; else goto cabx6;
       cabx5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabx6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabwY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabxa; else goto cabwZ;
       uabxa: // global
           call _cabwY(R1) args: 0, res: 0, upd: 0;
       cabwZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabwY() //  [R1]
         { info_tbl: [(cabwY,
                       label: block_cabwY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabwY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabx9; else goto cabx8;
       cabx9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabx8: // global
           _sa82e::P64 = P64[R1 + 7];
           _sa82f::P64 = P64[R1 + 15];
           _sa82d::I64 = I64[R1 + 23];
           _sa82g::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa82e::P64;
           P64[Hp - 32] = _sa82f::P64;
           I64[Hp - 24] = _sa82d::I64;
           I64[Hp - 16] = _sa82g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa82C_entry() //  [R1]
         { info_tbl: [(cabxx,
                       label: sat_sa82C_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabxx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabxE; else goto cabxF;
       cabxE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabxF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cabxu_info;
           _sa82s::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa82s::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabxJ; else goto cabxv;
       uabxJ: // global
           call _cabxu(R1) args: 0, res: 0, upd: 0;
       cabxv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabxu() //  [R1]
         { info_tbl: [(cabxu,
                       label: block_cabxu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabxu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabxI; else goto cabxH;
       cabxI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabxH: // global
           _sa82w::P64 = P64[R1 + 7];
           _sa82x::P64 = P64[R1 + 15];
           _sa82v::I64 = I64[R1 + 23];
           _sa82y::I64 = I64[R1 + 31];
           _sa82A::I64 = I64[R1 + 47];
           _sa82B::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa82w::P64;
           P64[Hp - 32] = _sa82x::P64;
           I64[Hp - 24] = _sa82v::I64;
           I64[Hp - 16] = _sa82y::I64;
           I64[Hp - 8] = _sa82B::I64;
           I64[Hp] = _sa82A::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushCharBuffer3_entry() //  [R2]
         { info_tbl: [(cabxK,
                       label: GHC.IO.Handle.Internals.flushCharBuffer3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabxK: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cabxL; else goto cabxM;
       cabxL: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabxM: // global
           I64[Sp - 8] = block_cabwx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabyS; else goto cabwy;
       uabyS: // global
           call _cabwx(R1) args: 0, res: 0, upd: 0;
       cabwy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabwx() //  [R1]
         { info_tbl: [(cabwx,
                       label: block_cabwx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabwx: // global
           I64[Sp - 32] = block_cabwC_info;
           _sa81G::P64 = P64[R1 + 47];
           _sa81I::P64 = P64[R1 + 63];
           _sa81J::P64 = P64[R1 + 71];
           _sa81M::P64 = P64[R1 + 95];
           R1 = P64[_sa81J::P64 + 8];
           P64[Sp - 24] = _sa81I::P64;
           P64[Sp - 16] = _sa81J::P64;
           P64[Sp - 8] = _sa81M::P64;
           P64[Sp] = _sa81G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabyM; else goto cabwD;
       uabyM: // global
           call _cabwC(R1) args: 0, res: 0, upd: 0;
       cabwD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabwC() //  [R1]
         { info_tbl: [(cabwC,
                       label: block_cabwC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabwC: // global
           I64[Sp - 16] = block_cabwH_info;
           _sa81Z::I64 = I64[R1 + 39];
           _sa820::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa820::I64;
           I64[Sp] = _sa81Z::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabyN; else goto cabwI;
       uabyN: // global
           call _cabwH(R1) args: 0, res: 0, upd: 0;
       cabwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabwH() //  [R1]
         { info_tbl: [(cabwH,
                       label: block_cabwH_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabwH: // global
           if (R1 & 7 != 1) goto cabyz; else goto cabyv;
       cabyv: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cabyz; else goto cabxR;
       cabyz: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabxR: // global
           _sa825::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_cabwP_info;
           R1 = _sa825::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uabyO; else goto cabwQ;
       uabyO: // global
           call _cabwP(R1) args: 0, res: 0, upd: 0;
       cabwQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabwP() //  [R1]
         { info_tbl: [(cabwP,
                       label: block_cabwP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabwP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabxU; else goto cabxT;
       cabxU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabxT: // global
           _sa81J::P64 = P64[Sp + 8];
           _sa827::P64 = P64[R1 + 7];
           _sa828::P64 = P64[R1 + 15];
           _sa82b::P64 = P64[_sa81J::P64 + 8];
           I64[Hp - 16] = sat_sa82j_info;
           P64[Hp] = _sa82b::P64;
           call MO_WriteBarrier();
           P64[_sa81J::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81J::P64);
           I64[Sp - 8] = block_cabxe_info;
           R1 = _sa82b::P64;
           P64[Sp] = _sa828::P64;
           P64[Sp + 8] = _sa827::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabyP; else goto cabxf;
       uabyP: // global
           call _cabxe(R1) args: 0, res: 0, upd: 0;
       cabxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabxe() //  [R1]
         { info_tbl: [(cabxe,
                       label: block_cabxe_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabxe: // global
           _sa82s::I64 = I64[R1 + 39];
           if (_sa82s::I64 != 0) goto cabxX; else goto cabys;
       cabxX: // global
           I64[Sp - 24] = block_cabxl_info;
           _sa82n::P64 = P64[R1 + 7];
           _sa82o::P64 = P64[R1 + 15];
           _sa82m::I64 = I64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 16] = _sa82o::P64;
           I64[Sp - 8] = _sa82s::I64;
           P64[Sp] = _sa82n::P64;
           I64[Sp + 24] = _sa82m::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabyQ; else goto cabxm;
       uabyQ: // global
           call _cabxl(R1) args: 0, res: 0, upd: 0;
       cabxm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabys: // global
           _sa81G::P64 = P64[Sp + 32];
           _sa828::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = _sa828::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cabxl() //  [R1]
         { info_tbl: [(cabxl,
                       label: block_cabxl_info
                       rep:StackRep [False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabxl: // global
           if (R1 & 7 == 1) goto cabxZ; else goto cabyh;
       cabxZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caby2; else goto caby1;
       caby2: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caby1: // global
           I64[Hp - 24] = sat_sa82C_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sa81G::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabyh: // global
           I64[Sp] = block_caby5_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabyR; else goto caby6;
       uabyR: // global
           call _caby5(R1) args: 0, res: 0, upd: 0;
       caby6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caby5() //  [R1]
         { info_tbl: [(caby5,
                       label: block_caby5_info
                       rep:StackRep [False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caby5: // global
           I64[Sp - 8] = block_cabya_info;
           R2 = P64[Sp + 40];
           _sa82G::P64 = P64[R1 + 7];
           _sa82H::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa82H::P64;
           P64[Sp + 40] = _sa82G::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabya() //  [R1]
         { info_tbl: [(cabya,
                       label: block_cabya_info
                       rep:StackRep [False, False, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabya: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabyl; else goto cabyk;
       cabyl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabyk: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 56] = block_cabyd_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 48];
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cabyd() //  [R1]
         { info_tbl: [(cabyd,
                       label: block_cabyd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabyd: // global
           I64[Sp] = block_cabyf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabyT; else goto cabyn;
       uabyT: // global
           call _cabyf(R1) args: 0, res: 0, upd: 0;
       cabyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabyf() //  [R1]
         { info_tbl: [(cabyf,
                       label: block_cabyf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabyf: // global
           _sa81G::P64 = P64[Sp + 8];
           _sa82T::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = _sa82T::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.858673142 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharReadBuffer_info;
 },
 GHC.IO.Handle.Internals.flushCharReadBuffer_entry() //  [R2]
         { info_tbl: [(cabAk,
                       label: GHC.IO.Handle.Internals.flushCharReadBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabAk: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.862027856 UTC

[section ""cstring" . lvl9_ra7Pp_bytes" {
     lvl9_ra7Pp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.863930066 UTC

[section ""data" . lvl10_ra7Pq_closure" {
     lvl10_ra7Pq_closure:
         const lvl10_ra7Pq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ra7Pq_entry() //  [R1]
         { info_tbl: [(cabAy,
                       label: lvl10_ra7Pq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabAy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabAz; else goto cabAA;
       cabAz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabAA: // global
           (_cabAv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabAv::I64 == 0) goto cabAx; else goto cabAw;
       cabAx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabAw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabAv::I64;
           R2 = lvl9_ra7Pp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.86843522 UTC

[section ""data" . lvl11_ra7Pr_closure" {
     lvl11_ra7Pr_closure:
         const lvl11_ra7Pr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_ra7Pr_entry() //  [R1]
         { info_tbl: [(cabAO,
                       label: lvl11_ra7Pr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabAO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabAP; else goto cabAQ;
       cabAP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabAQ: // global
           (_cabAL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabAL::I64 == 0) goto cabAN; else goto cabAM;
       cabAN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabAM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabAL::I64;
           R2 = GHC.IO.Handle.Internals.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.872486807 UTC

[section ""data" . lvl12_ra7Ps_closure" {
     lvl12_ra7Ps_closure:
         const lvl12_ra7Ps_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ra7Ps_entry() //  [R1]
         { info_tbl: [(cabB4,
                       label: lvl12_ra7Ps_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabB4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabB5; else goto cabB6;
       cabB5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabB6: // global
           (_cabB1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabB1::I64 == 0) goto cabB3; else goto cabB2;
       cabB3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabB2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabB1::I64;
           R2 = GHC.IO.Handle.Internals.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.87642397 UTC

[section ""cstring" . lvl13_ra7Pt_bytes" {
     lvl13_ra7Pt_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.878397435 UTC

[section ""data" . lvl14_ra7Pu_closure" {
     lvl14_ra7Pu_closure:
         const lvl14_ra7Pu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ra7Pu_entry() //  [R1]
         { info_tbl: [(cabBl,
                       label: lvl14_ra7Pu_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabBl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabBm; else goto cabBn;
       cabBm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabBn: // global
           (_cabBi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabBi::I64 == 0) goto cabBk; else goto cabBj;
       cabBk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabBj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabBi::I64;
           R2 = lvl13_ra7Pt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.882868526 UTC

[section ""data" . lvl15_ra7Pv_closure" {
     lvl15_ra7Pv_closure:
         const GHC.Types.I#_con_info;
         const 487;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.884554065 UTC

[section ""data" . lvl16_ra7Pw_closure" {
     lvl16_ra7Pw_closure:
         const GHC.Types.I#_con_info;
         const 12;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.886219445 UTC

[section ""data" . lvl17_ra7Px_closure" {
     lvl17_ra7Px_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.887981117 UTC

[section ""data" . lvl18_ra7Py_closure" {
     lvl18_ra7Py_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl11_ra7Pr_closure;
         const lvl12_ra7Ps_closure;
         const lvl14_ra7Pu_closure;
         const lvl15_ra7Pv_closure+1;
         const lvl16_ra7Pw_closure+1;
         const lvl15_ra7Pv_closure+1;
         const lvl17_ra7Px_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.890402675 UTC

[section ""data" . lvl19_ra7Pz_closure" {
     lvl19_ra7Pz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl10_ra7Pq_closure;
         const lvl18_ra7Py_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.892163308 UTC

[section ""cstring" . lvl20_ra7PA_bytes" {
     lvl20_ra7PA_bytes:
         I8[] [105,110,116,101,114,110,97,108,32,73,79,32,108,105,98,114,97,114,121,32,101,114,114,111,114,58,32,67,104,97,114,32,98,117,102,102,101,114,32,110,111,110,45,101,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.894287047 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer2_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer2_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer2_entry() //  [R1]
         { info_tbl: [(cabBJ,
                       label: GHC.IO.Handle.Internals.flushCharBuffer2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabBJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabBK; else goto cabBL;
       cabBK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabBL: // global
           (_cabBE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabBE::I64 == 0) goto cabBG; else goto cabBF;
       cabBG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabBF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabBE::I64;
           I64[Sp - 24] = block_cabBH_info;
           R2 = lvl20_ra7PA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cabBH() //  [R1]
         { info_tbl: [(cabBH,
                       label: block_cabBH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabBH: // global
           R3 = R1;
           R2 = lvl19_ra7Pz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.900484819 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer1_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer1_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer1_entry() //  [R2]
         { info_tbl: [(cabC6,
                       label: GHC.IO.Handle.Internals.flushCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabC6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabCa; else goto cabCb;
       cabCa: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabCb: // global
           I64[Sp - 8] = block_cabC3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabCB; else goto cabC4;
       uabCB: // global
           call _cabC3(R1) args: 0, res: 0, upd: 0;
       cabC4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabC3() //  [R1]
         { info_tbl: [(cabC3,
                       label: block_cabC3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabC3: // global
           _sa83j::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_cabC9_info;
           _sa830::P64 = R1;
           R1 = _sa83j::P64;
           P64[Sp] = _sa830::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabCA; else goto cabCd;
       uabCA: // global
           call _cabC9(R1) args: 0, res: 0, upd: 0;
       cabCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabC9() //  [R1]
         { info_tbl: [(cabC9,
                       label: block_cabC9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabC9: // global
           I64[Sp - 16] = block_cabCh_info;
           _sa83p::I64 = I64[R1 + 39];
           _sa83q::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa83q::I64;
           I64[Sp] = _sa83p::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabCC; else goto cabCj;
       uabCC: // global
           call _cabCh(R1) args: 0, res: 0, upd: 0;
       cabCj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabCh() //  [R1]
         { info_tbl: [(cabCh,
                       label: block_cabCh_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabCh: // global
           if (R1 & 7 == 1) goto cabCp; else goto cabCy;
       cabCp: // global
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
       cabCy: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cabCx; else goto cabCw;
       cabCx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabCw: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.910444513 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer_entry() //  [R2]
         { info_tbl: [(cabD3,
                       label: GHC.IO.Handle.Internals.flushCharBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabD3: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.915651413 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer2_closure" {
     GHC.IO.Handle.Internals.flushBuffer2_closure:
         const GHC.IO.Handle.Internals.flushBuffer2_info;
         const 0;
 },
 sat_sa844_entry() //  [R1]
         { info_tbl: [(cabDF,
                       label: sat_sa844_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabDF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabDG; else goto cabDH;
       cabDG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabDH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -(I64[R1 + 24] - I64[R1 + 16]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushBuffer2_entry() //  [R2]
         { info_tbl: [(cabDK,
                       label: GHC.IO.Handle.Internals.flushBuffer2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabDK: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cabDL; else goto cabDM;
       cabDL: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabDM: // global
           I64[Sp - 8] = block_cabDe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabEd; else goto cabDf;
       uabEd: // global
           call _cabDe(R1) args: 0, res: 0, upd: 0;
       cabDf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabDe() //  [R1]
         { info_tbl: [(cabDe,
                       label: block_cabDe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabDe: // global
           I64[Sp - 24] = block_cabDj_info;
           _sa83x::P64 = P64[R1 + 7];
           _sa83A::P64 = P64[R1 + 31];
           _sa83C::P64 = P64[R1 + 47];
           R1 = P64[_sa83C::P64 + 8];
           P64[Sp - 16] = _sa83A::P64;
           P64[Sp - 8] = _sa83C::P64;
           P64[Sp] = _sa83x::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabEb; else goto cabDk;
       uabEb: // global
           call _cabDj(R1) args: 0, res: 0, upd: 0;
       cabDk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabDj() //  [R1]
         { info_tbl: [(cabDj,
                       label: block_cabDj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabDj: // global
           _sa83V::I64 = I64[R1 + 39];
           _sa83W::I64 = I64[R1 + 47];
           if (_sa83V::I64 == _sa83W::I64) goto cabE5; else goto cabDQ;
       cabE5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabDQ: // global
           I64[Sp - 48] = block_cabDr_info;
           R2 = P64[Sp + 24];
           I64[Sp - 64] = stg_ap_pv_info;
           P64[Sp - 56] = P64[Sp + 8];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sa83V::I64;
           I64[Sp - 8] = _sa83W::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cabDr() //  [R1]
         { info_tbl: [(cabDr,
                       label: block_cabDr_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabDr: // global
           I64[Sp] = block_cabDt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabEc; else goto cabDu;
       uabEc: // global
           call _cabDt(R1) args: 0, res: 0, upd: 0;
       cabDu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabDt() //  [R1]
         { info_tbl: [(cabDt,
                       label: block_cabDt_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabDt: // global
           if (R1 & 7 == 1) goto cabDV; else goto cabDX;
       cabDV: // global
           R1 = GHC.IO.Handle.Internals.flushBuffer3_closure;
           Sp = Sp + 80;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabDX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cabE0; else goto cabDZ;
       cabE0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabDZ: // global
           I64[Hp - 24] = sat_sa844_info;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 40];
           I64[Sp] = block_cabDW_info;
           R2 = P64[Sp + 72];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 16] = GHC.IO.Device.RelativeSeek_closure+2;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _cabDW() //  [R1]
         { info_tbl: [(cabDW,
                       label: block_cabDW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabDW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabE4; else goto cabE3;
       cabE4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabE3: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sa83C::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sa83C::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa83C::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.931889662 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteReadBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushByteReadBuffer_entry() //  [R2]
         { info_tbl: [(cabF4,
                       label: GHC.IO.Handle.Internals.flushByteReadBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabF4: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.938081267 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer1_closure" {
     GHC.IO.Handle.Internals.flushBuffer1_closure:
         const GHC.IO.Handle.Internals.flushBuffer1_info;
         const 0;
 },
 sat_sa856_entry() //  [R1]
         { info_tbl: [(cabFT,
                       label: sat_sa856_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabFT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabFX; else goto cabFY;
       cabFX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabFY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabFQ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabG2; else goto cabFR;
       uabG2: // global
           call _cabFQ(R1) args: 0, res: 0, upd: 0;
       cabFR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabFQ() //  [R1]
         { info_tbl: [(cabFQ,
                       label: block_cabFQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabFQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabG1; else goto cabG0;
       cabG1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabG0: // global
           _sa851::P64 = P64[R1 + 7];
           _sa852::P64 = P64[R1 + 15];
           _sa850::I64 = I64[R1 + 23];
           _sa853::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa851::P64;
           P64[Hp - 32] = _sa852::P64;
           I64[Hp - 24] = _sa850::I64;
           I64[Hp - 16] = _sa853::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa85p_entry() //  [R1]
         { info_tbl: [(cabGp,
                       label: sat_sa85p_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabGp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabGw; else goto cabGx;
       cabGw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabGx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cabGm_info;
           _sa85f::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa85f::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabGB; else goto cabGn;
       uabGB: // global
           call _cabGm(R1) args: 0, res: 0, upd: 0;
       cabGn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabGm() //  [R1]
         { info_tbl: [(cabGm,
                       label: block_cabGm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabGm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabGA; else goto cabGz;
       cabGA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabGz: // global
           _sa85j::P64 = P64[R1 + 7];
           _sa85k::P64 = P64[R1 + 15];
           _sa85i::I64 = I64[R1 + 23];
           _sa85l::I64 = I64[R1 + 31];
           _sa85n::I64 = I64[R1 + 47];
           _sa85o::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa85j::P64;
           P64[Hp - 32] = _sa85k::P64;
           I64[Hp - 24] = _sa85i::I64;
           I64[Hp - 16] = _sa85l::I64;
           I64[Hp - 8] = _sa85o::I64;
           I64[Hp] = _sa85n::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushBuffer1_entry() //  [R2]
         { info_tbl: [(cabGC,
                       label: GHC.IO.Handle.Internals.flushBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabGC: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cabGD; else goto cabGE;
       cabGD: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabGE: // global
           I64[Sp - 8] = block_cabFf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabIe; else goto cabFg;
       uabIe: // global
           call _cabFf(R1) args: 0, res: 0, upd: 0;
       cabFg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabFf() //  [R1]
         { info_tbl: [(cabFf,
                       label: block_cabFf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabFf: // global
           I64[Sp - 56] = block_cabFk_info;
           _sa84c::P64 = R1;
           _sa84e::P64 = P64[R1 + 15];
           _sa84g::P64 = P64[R1 + 31];
           _sa84i::P64 = P64[R1 + 47];
           _sa84k::P64 = P64[R1 + 63];
           _sa84l::P64 = P64[R1 + 71];
           _sa84o::P64 = P64[R1 + 95];
           R1 = P64[_sa84l::P64 + 8];
           P64[Sp - 48] = _sa84e::P64;
           P64[Sp - 40] = _sa84g::P64;
           P64[Sp - 32] = _sa84i::P64;
           P64[Sp - 24] = _sa84k::P64;
           P64[Sp - 16] = _sa84l::P64;
           P64[Sp - 8] = _sa84o::P64;
           P64[Sp] = _sa84c::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uabI5; else goto cabFl;
       uabI5: // global
           call _cabFk(R1) args: 0, res: 0, upd: 0;
       cabFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabFk() //  [R1]
         { info_tbl: [(cabFk,
                       label: block_cabFk_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabFk: // global
           I64[Sp] = block_cabFp_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uabI6; else goto cabFq;
       uabI6: // global
           call _cabFp(R1) args: 0, res: 0, upd: 0;
       cabFq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabFp() //  [R1]
         { info_tbl: [(cabFp,
                       label: block_cabFp_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabFp: // global
           if (R1 & 7 == 1) goto cabGJ; else goto cabHA;
       cabGJ: // global
           _sa84G::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_cabFu_info;
           R1 = _sa84G::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabI7; else goto cabFv;
       uabI7: // global
           call _cabFu(R1) args: 0, res: 0, upd: 0;
       cabFv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabHA: // global
           _sa85M::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cabHy_info;
           R1 = _sa85M::P64;
           if (R1 & 7 != 0) goto uabI8; else goto cabHB;
       uabI8: // global
           call _cabHy(R1) args: 0, res: 0, upd: 0;
       cabHB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabFu() //  [R1]
         { info_tbl: [(cabFu,
                       label: block_cabFu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabFu: // global
           I64[Sp - 16] = block_cabFz_info;
           _sa84M::I64 = I64[R1 + 39];
           _sa84N::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa84N::I64;
           I64[Sp] = _sa84M::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabI9; else goto cabFA;
       uabI9: // global
           call _cabFz(R1) args: 0, res: 0, upd: 0;
       cabFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabFz() //  [R1]
         { info_tbl: [(cabFz,
                       label: block_cabFz_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabFz: // global
           _sa84c::P64 = P64[Sp + 56];
           if (R1 & 7 != 1) goto cabHv; else goto cabHr;
       cabHr: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cabHv; else goto cabGN;
       cabHv: // global
           R2 = _sa84c::P64;
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       cabGN: // global
           _sa84S::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cabFH_info;
           R1 = _sa84S::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabIa; else goto cabFI;
       uabIa: // global
           call _cabFH(R1) args: 0, res: 0, upd: 0;
       cabFI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabFH() //  [R1]
         { info_tbl: [(cabFH,
                       label: block_cabFH_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabFH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabGQ; else goto cabGP;
       cabGQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabGP: // global
           _sa84l::P64 = P64[Sp + 24];
           _sa84U::P64 = P64[R1 + 7];
           _sa84V::P64 = P64[R1 + 15];
           _sa84Y::P64 = P64[_sa84l::P64 + 8];
           I64[Hp - 16] = sat_sa856_info;
           P64[Hp] = _sa84Y::P64;
           call MO_WriteBarrier();
           P64[_sa84l::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84l::P64);
           I64[Sp] = block_cabG6_info;
           R1 = _sa84Y::P64;
           P64[Sp + 16] = _sa84V::P64;
           P64[Sp + 24] = _sa84U::P64;
           if (R1 & 7 != 0) goto uabIb; else goto cabG7;
       uabIb: // global
           call _cabG6(R1) args: 0, res: 0, upd: 0;
       cabG7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabG6() //  [R1]
         { info_tbl: [(cabG6,
                       label: block_cabG6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabG6: // global
           _sa85f::I64 = I64[R1 + 39];
           if (_sa85f::I64 != 0) goto cabGT; else goto cabHo;
       cabGT: // global
           I64[Sp - 24] = block_cabGd_info;
           _sa85a::P64 = P64[R1 + 7];
           _sa85b::P64 = P64[R1 + 15];
           _sa859::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sa85b::P64;
           I64[Sp - 8] = _sa85f::I64;
           P64[Sp] = _sa85a::P64;
           I64[Sp + 32] = _sa859::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabIc; else goto cabGe;
       uabIc: // global
           call _cabGd(R1) args: 0, res: 0, upd: 0;
       cabGe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabHo: // global
           _sa84c::P64 = P64[Sp + 40];
           _sa84i::P64 = P64[Sp + 8];
           _sa84V::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = _sa84V::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cabGd() //  [R1]
         { info_tbl: [(cabGd,
                       label: block_cabGd_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabGd: // global
           if (R1 & 7 == 1) goto cabGV; else goto cabHd;
       cabGV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cabGY; else goto cabGX;
       cabGY: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabGX: // global
           I64[Hp - 24] = sat_sa85p_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sa84c::P64 = P64[Sp + 64];
           _sa84i::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       cabHd: // global
           I64[Sp] = block_cabH1_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabId; else goto cabH2;
       uabId: // global
           call _cabH1(R1) args: 0, res: 0, upd: 0;
       cabH2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabH1() //  [R1]
         { info_tbl: [(cabH1,
                       label: block_cabH1_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabH1: // global
           I64[Sp - 8] = block_cabH6_info;
           R2 = P64[Sp + 48];
           _sa85t::P64 = P64[R1 + 7];
           _sa85u::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa85u::P64;
           P64[Sp + 48] = _sa85t::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabH6() //  [R1]
         { info_tbl: [(cabH6,
                       label: block_cabH6_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabH6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabHh; else goto cabHg;
       cabHh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabHg: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cabH9_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cabH9() //  [R1]
         { info_tbl: [(cabH9,
                       label: block_cabH9_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabH9: // global
           I64[Sp] = block_cabHb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabIf; else goto cabHj;
       uabIf: // global
           call _cabHb(R1) args: 0, res: 0, upd: 0;
       cabHj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabHb() //  [R1]
         { info_tbl: [(cabHb,
                       label: block_cabHb_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabHb: // global
           _sa84c::P64 = P64[Sp + 40];
           _sa84i::P64 = P64[Sp + 8];
           _sa85G::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = _sa85G::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cabHy() //  [R1]
         { info_tbl: [(cabHy,
                       label: block_cabHy_info
                       rep:StackRep [False, False, False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabHy: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabHO; else goto cabHL;
       cabHO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabHL: // global
           _sa84g::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabHJ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa84g::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cabHJ() //  [R1]
         { info_tbl: [(cabHJ,
                       label: block_cabHJ_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabHJ: // global
           _sa84i::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.978961198 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer_closure" {
     GHC.IO.Handle.Internals.flushBuffer_closure:
         const GHC.IO.Handle.Internals.flushBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer_entry() //  [R2]
         { info_tbl: [(cabJZ,
                       label: GHC.IO.Handle.Internals.flushBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabJZ: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.982188691 UTC

[section ""cstring" . lvl21_ra7PB_bytes" {
     lvl21_ra7PB_bytes:
         I8[] [71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,56,56,49,58,55,45,51,48,124,74,117,115,116,32,100,101,99,111,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.984077359 UTC

[section ""data" . lvl22_ra7PC_closure" {
     lvl22_ra7PC_closure:
         const lvl22_ra7PC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ra7PC_entry() //  [R1]
         { info_tbl: [(cabKd,
                       label: lvl22_ra7PC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabKd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabKe; else goto cabKf;
       cabKe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabKf: // global
           (_cabKa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabKa::I64 == 0) goto cabKc; else goto cabKb;
       cabKc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabKb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabKa::I64;
           R2 = lvl21_ra7PB_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:07.993266475 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_2_closure" {
     GHC.IO.Handle.Internals.hLookAhead_2_closure:
         const GHC.IO.Handle.Internals.hLookAhead_2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_2_entry() //  [R2, R3]
         { info_tbl: [(cabKu,
                       label: GHC.IO.Handle.Internals.hLookAhead_2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabKu: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cabKy; else goto cabKz;
       cabKy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cabKz: // global
           I64[Sp - 16] = block_cabKr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabMZ; else goto cabKs;
       uabMZ: // global
           call _cabKr(R1) args: 0, res: 0, upd: 0;
       cabKs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabKr() //  [R1]
         { info_tbl: [(cabKr,
                       label: block_cabKr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabKr: // global
           I64[Sp - 48] = block_cabKx_info;
           _sa862::P64 = R1;
           _sa864::P64 = P64[R1 + 15];
           _sa866::P64 = P64[R1 + 31];
           _sa868::P64 = P64[R1 + 47];
           _sa86a::P64 = P64[R1 + 63];
           _sa86e::P64 = P64[R1 + 95];
           R1 = P64[_sa868::P64 + 8];
           P64[Sp - 40] = _sa864::P64;
           P64[Sp - 32] = _sa866::P64;
           P64[Sp - 24] = _sa868::P64;
           P64[Sp - 16] = _sa86a::P64;
           P64[Sp - 8] = _sa86e::P64;
           P64[Sp] = _sa862::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uabMY; else goto cabKB;
       uabMY: // global
           call _cabKx(R1) args: 0, res: 0, upd: 0;
       cabKB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabKx() //  [R1]
         { info_tbl: [(cabKx,
                       label: block_cabKx_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabKx: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabMJ; else goto cabMy;
       cabMJ: // global
           _sa866::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabMB_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa866::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cabMy: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sa86t() args: 0, res: 0, upd: 0;
     }
 },
 _cabMB() //  [R1]
         { info_tbl: [(cabMB,
                       label: block_cabMB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabMB: // global
           I64[Sp] = block_cabMD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabNa; else goto cabME;
       uabNa: // global
           call _cabMD(R1) args: 0, res: 0, upd: 0;
       cabME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabMD() //  [R1]
         { info_tbl: [(cabMD,
                       label: block_cabMD_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabMD: // global
           I64[Sp - 8] = block_cabMI_info;
           _sa87O::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa87O::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabNb; else goto cabMM;
       uabNb: // global
           call _cabMI(R1) args: 0, res: 0, upd: 0;
       cabMM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabMI() //  [R1]
         { info_tbl: [(cabMI,
                       label: block_cabMI_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabMI: // global
           if (I64[R1 + 7] == 0) goto cabMU; else goto cabMT;
       cabMU: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabMT: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _sa86t() args: 0, res: 0, upd: 0;
     }
 },
 _sa86t() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa86t: // global
           I64[Sp - 8] = block_cabKL_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabNd; else goto cabKN;
       uabNd: // global
           call _cabKL(R1) args: 0, res: 0, upd: 0;
       cabKN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabKL() //  [R1]
         { info_tbl: [(cabKL,
                       label: block_cabKL_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabKL: // global
           if (R1 & 7 == 1) goto cabLc; else goto cabM5;
       cabLc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabLf; else goto cabLe;
       cabLf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabLe: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sa86v::P64 = P64[Sp + 8];
           P64[Hp] = _sa86v::P64;
           _sa860::P64 = P64[Sp + 48];
           _sa86a::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa86a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa86a::P64);
           I64[Sp + 8] = block_cabKV_info;
           R3 = _sa860::P64;
           R2 = _sa86v::P64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cabM5: // global
           I64[Sp] = block_cabLD_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabN1; else goto cabLE;
       uabN1: // global
           call _cabLD(R1) args: 0, res: 0, upd: 0;
       cabLE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabKV() //  [R1]
         { info_tbl: [(cabKV,
                       label: block_cabKV_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabKV: // global
           I64[Sp] = block_cabKX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabN2; else goto cabKY;
       uabN2: // global
           call _cabKX(R1) args: 0, res: 0, upd: 0;
       cabKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabKX() //  [R1]
         { info_tbl: [(cabKX,
                       label: block_cabKX_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabKX: // global
           _sa868::P64 = P64[Sp + 8];
           _sa86E::P64 = P64[R1 + 15];
           _sa86F::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sa868::P64 + 8] = _sa86E::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa868::P64);
           I64[Sp + 16] = block_cabL5_info;
           R1 = _sa86F::P64;
           P64[Sp + 24] = _sa86E::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabN3; else goto cabL6;
       uabN3: // global
           call _cabL5(R1) args: 0, res: 0, upd: 0;
       cabL6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabL5() //  [R1]
         { info_tbl: [(cabL5,
                       label: block_cabL5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabL5: // global
           I64[Sp - 8] = block_cabLa_info;
           _sa86H::P64 = R1;
           _sa86N::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sa86N::I64;
           P64[Sp + 24] = _sa86H::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabN4; else goto cabLj;
       uabN4: // global
           call _cabLa(R1) args: 0, res: 0, upd: 0;
       cabLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabLa() //  [R1]
         { info_tbl: [(cabLa,
                       label: block_cabLa_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabLa: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto cabLv; else goto cabLr;
       cabLv: // global
           _sa86E::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabLu_info;
           _sa86O::P64 = R1;
           R1 = _sa86E::P64;
           P64[Sp + 32] = _sa86O::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabN5; else goto cabLw;
       uabN5: // global
           call _cabLu(R1) args: 0, res: 0, upd: 0;
       cabLw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabLr: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cabLu() //  [R1]
         { info_tbl: [(cabLu,
                       label: block_cabLu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabLu: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 _cabLD() //  [R1]
         { info_tbl: [(cabLD,
                       label: block_cabLD_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabLD: // global
           I64[Sp - 8] = block_cabLI_info;
           _sa875::P64 = P64[R1 + 7];
           _sa876::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sa876::P64;
           P64[Sp + 32] = _sa875::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabLI() //  [R1]
         { info_tbl: [(cabLI,
                       label: block_cabLI_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabLI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabM9; else goto cabM8;
       cabM9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabM8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa86v::P64 = P64[Sp + 16];
           P64[Hp] = _sa86v::P64;
           _sa860::P64 = P64[Sp + 56];
           _sa86a::P64 = P64[Sp + 32];
           _sa875::P64 = P64[Sp + 40];
           _sa876::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa86a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa86a::P64);
           I64[Sp + 16] = block_cabLO_info;
           R5 = _sa860::P64;
           R4 = _sa86v::P64;
           R3 = _sa876::P64;
           R2 = _sa875::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cabLO() //  [R1]
         { info_tbl: [(cabLO,
                       label: block_cabLO_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabLO: // global
           I64[Sp] = block_cabLQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabN6; else goto cabLR;
       uabN6: // global
           call _cabLQ(R1) args: 0, res: 0, upd: 0;
       cabLR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabLQ() //  [R1]
         { info_tbl: [(cabLQ,
                       label: block_cabLQ_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabLQ: // global
           _sa868::P64 = P64[Sp + 8];
           _sa87j::P64 = P64[R1 + 7];
           _sa87k::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa868::P64 + 8] = _sa87j::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa868::P64);
           I64[Sp + 16] = block_cabLY_info;
           R1 = _sa87k::P64;
           P64[Sp + 24] = _sa87j::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabN7; else goto cabLZ;
       uabN7: // global
           call _cabLY(R1) args: 0, res: 0, upd: 0;
       cabLZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabLY() //  [R1]
         { info_tbl: [(cabLY,
                       label: block_cabLY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabLY: // global
           I64[Sp - 8] = block_cabM3_info;
           _sa87m::P64 = R1;
           _sa87s::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sa87s::I64;
           P64[Sp + 24] = _sa87m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabN8; else goto cabMd;
       uabN8: // global
           call _cabM3(R1) args: 0, res: 0, upd: 0;
       cabMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabM3() //  [R1]
         { info_tbl: [(cabM3,
                       label: block_cabM3_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabM3: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto cabMp; else goto cabMl;
       cabMp: // global
           _sa87j::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabMo_info;
           _sa87t::P64 = R1;
           R1 = _sa87j::P64;
           P64[Sp + 32] = _sa87t::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabN9; else goto cabMq;
       uabN9: // global
           call _cabMo(R1) args: 0, res: 0, upd: 0;
       cabMq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabMl: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cabMo() //  [R1]
         { info_tbl: [(cabMo,
                       label: block_cabMo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabMo: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Internals.$wreadTextDevice'_closure" {
     GHC.IO.Handle.Internals.$wreadTextDevice'_closure:
         const GHC.IO.Handle.Internals.$wreadTextDevice'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabNf: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uabQs_srtd" {
     uabQs_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 7516192769;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cabNm,
                       label: GHC.IO.Handle.Internals.$wreadTextDevice'_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabNm: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cabNM; else goto uabQ5;
       cabNM: // global
           R1 = GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       uabQ5: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cabNg() args: 0, res: 0, upd: 0;
     }
 },
 _cabNg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabNg: // global
           _sa87T::P64 = P64[Sp];
           I64[Sp] = block_cabNj_info;
           R1 = _sa87T::P64;
           if (R1 & 7 != 0) goto uabQ9; else goto cabNk;
       uabQ9: // global
           call _cabNj(R1) args: 0, res: 0, upd: 0;
       cabNk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQt_srtd" {
     uabQt_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabNj() //  [R1]
         { info_tbl: [(cabNj,
                       label: block_cabNj_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabNj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabNQ; else goto cabNP;
       cabNQ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabNP: // global
           _sa87U::I64 = I64[Sp + 8];
           _sa87V::P64 = P64[Sp + 16];
           _sa87W::P64 = P64[Sp + 24];
           _sa87X::I64 = I64[Sp + 32];
           _sa87Y::I64 = I64[Sp + 40];
           _sa884::P64 = P64[R1 + 15];
           _sa886::P64 = P64[R1 + 31];
           _sa888::P64 = P64[R1 + 47];
           _sa88a::P64 = P64[R1 + 63];
           _sa88e::P64 = P64[R1 + 95];
           _sa88j::I64 = I64[Sp + 48] - _sa87Y::I64;
           (_sa88p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_sa87U::I64, _sa87U::I64 + _sa87Y::I64, _sa88j::I64);
           call MO_Touch(_sa87V::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa87V::P64;
           P64[Hp - 32] = _sa87W::P64;
           I64[Hp - 24] = _sa87U::I64;
           I64[Hp - 16] = _sa87X::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sa88j::I64;
           I64[Sp + 16] = block_cabNE_info;
           R2 = _sa884::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa886::P64;
           P64[Sp + 8] = Hp - 47;
           P64[Sp + 24] = _sa88e::P64;
           P64[Sp + 32] = _sa88a::P64;
           P64[Sp + 40] = _sa888::P64;
           P64[Sp + 48] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQu_srtd" {
     uabQu_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabNE() //  [R1]
         { info_tbl: [(cabNE,
                       label: block_cabNE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabNE: // global
           I64[Sp] = block_cabNG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabQb; else goto cabNH;
       uabQb: // global
           call _cabNG(R1) args: 0, res: 0, upd: 0;
       cabNH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQv_srtd" {
     uabQv_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabNG() //  [R1]
         { info_tbl: [(cabNG,
                       label: block_cabNG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabNG: // global
           I64[Sp - 8] = block_cabNL_info;
           _sa88x::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa88x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabQc; else goto cabNT;
       uabQc: // global
           call _cabNL(R1) args: 0, res: 0, upd: 0;
       cabNT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQw_srtd" {
     uabQw_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabNL() //  [R1]
         { info_tbl: [(cabNL,
                       label: block_cabNL_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabNL: // global
           if (I64[R1 + 7] == 0) goto cabP6; else goto cabO2;
       cabP6: // global
           _sa88x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabP5_info;
           R1 = _sa88x::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uabQe; else goto cabP7;
       uabQe: // global
           call _cabP5(R1) args: 0, res: 0, upd: 0;
       cabP7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabO2: // global
           I64[Sp] = block_cabO0_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto uabQd; else goto cabO3;
       uabQd: // global
           call _cabO0(R1) args: 0, res: 0, upd: 0;
       cabO3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQx_srtd" {
     uabQx_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabP5() //  [R1]
         { info_tbl: [(cabP5,
                       label: block_cabP5_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabP5: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabQ2; else goto cabPh;
       cabQ2: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabPh: // global
           _sa88e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabPf_info;
           _sa89i::P64 = R1;
           R1 = _sa88e::P64;
           P64[Sp + 16] = _sa89i::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uabQm; else goto cabPi;
       uabQm: // global
           call _cabPf(R1) args: 0, res: 0, upd: 0;
       cabPi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabPf() //  [R1]
         { info_tbl: [(cabPf,
                       label: block_cabPf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabPf: // global
           if (R1 & 7 == 1) goto uabQ8; else goto cabPN;
       uabQ8: // global
           Sp = Sp + 40;
           call _cabPo() args: 0, res: 0, upd: 0;
       cabPN: // global
           I64[Sp] = block_cabPr_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabQn; else goto cabPs;
       uabQn: // global
           call _cabPr(R1) args: 0, res: 0, upd: 0;
       cabPs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabPr() //  [R1]
         { info_tbl: [(cabPr,
                       label: block_cabPr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabPr: // global
           _sa89i::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabPw_info;
           R3 = P64[Sp + 32];
           R2 = _sa89i::P64;
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabPw() //  [R1]
         { info_tbl: [(cabPw,
                       label: block_cabPw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabPw: // global
           I64[Sp] = block_cabPy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabQp; else goto cabPz;
       uabQp: // global
           call _cabPy(R1) args: 0, res: 0, upd: 0;
       cabPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabPy() //  [R1]
         { info_tbl: [(cabPy,
                       label: block_cabPy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabPy: // global
           _sa888::P64 = P64[Sp + 8];
           _sa89D::P64 = P64[R1 + 7];
           _sa89E::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa888::P64 + 8] = _sa89D::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa888::P64);
           I64[Sp + 8] = block_cabPG_info;
           R1 = _sa89E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uabQq; else goto cabPH;
       uabQq: // global
           call _cabPG(R1) args: 0, res: 0, upd: 0;
       cabPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabPG() //  [R1]
         { info_tbl: [(cabPG,
                       label: block_cabPG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabPG: // global
           I64[Sp - 8] = block_cabPL_info;
           _sa89G::P64 = R1;
           _sa89M::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           I64[Sp] = _sa89M::I64;
           P64[Sp + 16] = _sa89G::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabQr; else goto cabPS;
       uabQr: // global
           call _cabPL(R1) args: 0, res: 0, upd: 0;
       cabPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabPL() //  [R1]
         { info_tbl: [(cabPL,
                       label: block_cabPL_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabPL: // global
           _sa89G::P64 = P64[Sp + 24];
           if (I64[Sp + 8] == I64[R1 + 47]) goto cabQ1; else goto cabQ0;
       cabQ1: // global
           R3 = _sa89G::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       cabQ0: // global
           R1 = _sa89G::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uabQy_srtd" {
     uabQy_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabO0() //  [R1]
         { info_tbl: [(cabO0,
                       label: block_cabO0_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabO0: // global
           if (R1 & 7 == 1) goto uabQ6; else goto cabOE;
       uabQ6: // global
           Sp = Sp + 56;
           call _cabPo() args: 0, res: 0, upd: 0;
       cabOE: // global
           I64[Sp] = block_cabOc_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabQf; else goto cabOd;
       uabQf: // global
           call _cabOc(R1) args: 0, res: 0, upd: 0;
       cabOd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabPo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabPo: // global
           R1 = lvl22_ra7PC_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uabQz_srtd" {
     uabQz_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOc() //  [R1]
         { info_tbl: [(cabOc,
                       label: block_cabOc_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabOc: // global
           I64[Sp - 8] = block_cabOh_info;
           _sa88F::P64 = P64[R1 + 7];
           _sa88G::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sa88G::P64;
           P64[Sp + 16] = _sa88F::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQA_srtd" {
     uabQA_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOh() //  [R1]
         { info_tbl: [(cabOh,
                       label: block_cabOh_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabOh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabOI; else goto cabOH;
       cabOI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabOH: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa88x::P64 = P64[Sp + 16];
           P64[Hp] = _sa88x::P64;
           _sa880::P64 = P64[Sp + 56];
           _sa88a::P64 = P64[Sp + 32];
           _sa88F::P64 = P64[Sp + 24];
           _sa88G::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa88a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa88a::P64);
           I64[Sp + 32] = block_cabOn_info;
           R5 = _sa880::P64;
           R4 = _sa88x::P64;
           R3 = _sa88G::P64;
           R2 = _sa88F::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQB_srtd" {
     uabQB_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOn() //  [R1]
         { info_tbl: [(cabOn,
                       label: block_cabOn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabOn: // global
           I64[Sp] = block_cabOp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabQh; else goto cabOq;
       uabQh: // global
           call _cabOp(R1) args: 0, res: 0, upd: 0;
       cabOq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQC_srtd" {
     uabQC_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOp() //  [R1]
         { info_tbl: [(cabOp,
                       label: block_cabOp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabOp: // global
           _sa880::P64 = P64[Sp + 24];
           _sa888::P64 = P64[Sp + 8];
           _sa88T::P64 = P64[R1 + 7];
           _sa88U::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa888::P64 + 8] = _sa88T::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa888::P64);
           I64[Sp] = block_cabOx_info;
           R1 = _sa880::P64;
           P64[Sp + 8] = _sa88U::P64;
           P64[Sp + 24] = _sa88T::P64;
           if (R1 & 7 != 0) goto uabQi; else goto cabOy;
       uabQi: // global
           call _cabOx(R1) args: 0, res: 0, upd: 0;
       cabOy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQD_srtd" {
     uabQD_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOx() //  [R1]
         { info_tbl: [(cabOx,
                       label: block_cabOx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabOx: // global
           I64[Sp] = block_cabOC_info;
           _sa892::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sa892::I64;
           if (R1 & 7 != 0) goto uabQj; else goto cabOM;
       uabQj: // global
           call _cabOC(R1) args: 0, res: 0, upd: 0;
       cabOM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQE_srtd" {
     uabQE_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOC() //  [R1]
         { info_tbl: [(cabOC,
                       label: block_cabOC_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabOC: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto cabOY; else goto cabOU;
       cabOY: // global
           I64[Sp + 8] = block_cabOX_info;
           _sa893::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sa893::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uabQk; else goto cabOZ;
       uabQk: // global
           call _cabOX(R1) args: 0, res: 0, upd: 0;
       cabOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabOU: // global
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uabQF_srtd" {
     uabQF_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOX() //  [R1]
         { info_tbl: [(cabOX,
                       label: block_cabOX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabOX: // global
           P64[Sp - 40] = P64[Sp + 8];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 8] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 40;
           call _cabNg() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.084799706 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDevice_closure" {
     GHC.IO.Handle.Internals.readTextDevice_closure:
         const GHC.IO.Handle.Internals.readTextDevice_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDevice_entry() //  [R2, R3]
         { info_tbl: [(cabUf,
                       label: GHC.IO.Handle.Internals.readTextDevice_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabUf: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.089311511 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_1_closure" {
     GHC.IO.Handle.Internals.hLookAhead_1_closure:
         const GHC.IO.Handle.Internals.hLookAhead_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_1_entry() //  [R2]
         { info_tbl: [(cabUt,
                       label: GHC.IO.Handle.Internals.hLookAhead_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabUt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cabUx; else goto cabUy;
       cabUx: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabUy: // global
           I64[Sp - 8] = block_cabUq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabV4; else goto cabUr;
       uabV4: // global
           call _cabUq(R1) args: 0, res: 0, upd: 0;
       cabUr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabUq() //  [R1]
         { info_tbl: [(cabUq,
                       label: block_cabUq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabUq: // global
           I64[Sp - 16] = block_cabUw_info;
           _sa89X::P64 = R1;
           _sa8a6::P64 = P64[R1 + 71];
           R1 = P64[_sa8a6::P64 + 8];
           P64[Sp - 8] = _sa8a6::P64;
           P64[Sp] = _sa89X::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabV3; else goto cabUA;
       uabV3: // global
           call _cabUw(R1) args: 0, res: 0, upd: 0;
       cabUA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabUw() //  [R1]
         { info_tbl: [(cabUw,
                       label: block_cabUw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabUw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabUG; else goto cabUF;
       cabUG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabUF: // global
           _sa8aj::P64 = P64[R1 + 7];
           _sa8ai::I64 = I64[R1 + 23];
           _sa8am::I64 = I64[R1 + 39];
           if (_sa8am::I64 == I64[R1 + 47]) goto cabUZ; else goto cabUQ;
       cabUZ: // global
           Hp = Hp - 16;
           I64[Sp - 16] = block_cabUS_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = _sa8am::I64;
           P64[Sp] = _sa8aj::P64;
           I64[Sp + 16] = _sa8ai::I64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cabUQ: // global
           _sa8a6::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8a6::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8a6::P64);
           _sa8as::I64 = %MO_UU_Conv_W32_W64(I32[_sa8ai::I64 + (_sa8am::I64 << 2)]);
           call MO_Touch(_sa8aj::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sa8as::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cabUS() //  [R1]
         { info_tbl: [(cabUS,
                       label: block_cabUS_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabUS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabV2; else goto cabV1;
       cabV2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabV1: // global
           _sa8a6::P64 = P64[Sp + 24];
           _sa8ai::I64 = I64[Sp + 32];
           _sa8aj::P64 = P64[Sp + 16];
           _sa8am::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8a6::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8a6::P64);
           _sa8aB::I64 = %MO_UU_Conv_W32_W64(I32[_sa8ai::I64 + (_sa8am::I64 << 2)]);
           call MO_Touch(_sa8aj::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sa8aB::I64;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.100119744 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead__closure" {
     GHC.IO.Handle.Internals.hLookAhead__closure:
         const GHC.IO.Handle.Internals.hLookAhead__info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead__entry() //  [R2]
         { info_tbl: [(cabVt,
                       label: GHC.IO.Handle.Internals.hLookAhead__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabVt: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.10359816 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help2_closure" {
     GHC.IO.Handle.Internals.hClose_help2_closure:
         const GHC.IO.Handle.Internals.hClose_help2_info;
 },
 GHC.IO.Handle.Internals.hClose_help2_entry() //  [R2]
         { info_tbl: [(cabVF,
                       label: GHC.IO.Handle.Internals.hClose_help2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabVF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabVJ; else goto cabVI;
       cabVJ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabVI: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.110942105 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help1_closure" {
     GHC.IO.Handle.Internals.hClose_help1_closure:
         const GHC.IO.Handle.Internals.hClose_help1_info;
         const 0;
 },
 sat_sa8bs_entry() //  [R1]
         { info_tbl: [(cabWb,
                       label: sat_sa8bs_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabWb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cabWc; else goto cabWd;
       cabWc: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cabWd: // global
           I64[Sp - 32] = block_cabW8_info;
           _sa8aL::P64 = P64[R1 + 7];
           _sa8aN::P64 = P64[R1 + 15];
           _sa8aP::P64 = P64[R1 + 23];
           R1 = P64[_sa8aP::P64 + 8];
           P64[Sp - 24] = _sa8aL::P64;
           P64[Sp - 16] = _sa8aN::P64;
           P64[Sp - 8] = _sa8aP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabWP; else goto cabW9;
       uabWP: // global
           call _cabW8(R1) args: 0, res: 0, upd: 0;
       cabW9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabW8() //  [R1]
         { info_tbl: [(cabW8,
                       label: block_cabW8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabW8: // global
           I64[Sp] = block_cabWg_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uabWO; else goto cabWi;
       uabWO: // global
           call _cabWg(R1) args: 0, res: 0, upd: 0;
       cabWi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabWg() //  [R1]
         { info_tbl: [(cabWg,
                       label: block_cabWg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabWg: // global
           if (R1 & 7 == 1) goto uabWM; else goto cabWt;
       uabWM: // global
           Sp = Sp + 32;
           call _cabWH() args: 0, res: 0, upd: 0;
       cabWt: // global
           _sa8bf::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cabWr_info;
           R1 = _sa8bf::P64;
           if (R1 & 7 != 0) goto uabWQ; else goto cabWu;
       uabWQ: // global
           call _cabWr(R1) args: 0, res: 0, upd: 0;
       cabWu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabWr() //  [R1]
         { info_tbl: [(cabWr,
                       label: block_cabWr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabWr: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uabWN; else goto cabWE;
       uabWN: // global
           Sp = Sp + 32;
           call _cabWH() args: 0, res: 0, upd: 0;
       cabWE: // global
           _sa8aN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabWC_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa8aN::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cabWH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabWH: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cabWC() //  [R1]
         { info_tbl: [(cabWC,
                       label: block_cabWC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabWC: // global
           _sa8aP::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8aP::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aP::P64);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8bI_entry() //  [R1]
         { info_tbl: [(cabXu,
                       label: sat_sa8bI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabXu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabXv; else goto cabXw;
       cabXv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabXw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cabXn_info;
           _sa8by::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8by::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabXD; else goto cabXo;
       uabXD: // global
           call _cabXn(R1) args: 0, res: 0, upd: 0;
       cabXo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabXn() //  [R1]
         { info_tbl: [(cabXn,
                       label: block_cabXn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabXn: // global
           if (R1 & 7 == 1) goto cabXr; else goto cabXs;
       cabXr: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cabXs: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8bX_entry() //  [R1]
         { info_tbl: [(cabXY,
                       label: sat_sa8bX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabXY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabXZ; else goto cabY0;
       cabXZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabY0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cabXR_info;
           _sa8by::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8by::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabY7; else goto cabXS;
       uabY7: // global
           call _cabXR(R1) args: 0, res: 0, upd: 0;
       cabXS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cabXR() //  [R1]
         { info_tbl: [(cabXR,
                       label: block_cabXR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabXR: // global
           if (R1 & 7 == 1) goto cabXV; else goto cabXW;
       cabXV: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cabXW: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8cf_entry() //  [R1]
         { info_tbl: [(cabYk,
                       label: sat_sa8cf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabYk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabYl; else goto cabYm;
       cabYl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cabYm: // global
           I64[Sp - 8] = block_cabYi_info;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.IO.Device.close_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cabYi() //  []
         { info_tbl: [(cabYi,
                       label: block_cabYi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabYi: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.hClose_help1_entry() //  [R2]
         { info_tbl: [(cabYo,
                       label: GHC.IO.Handle.Internals.hClose_help1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabYo: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cabYp; else goto cabYq;
       cabYp: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabYq: // global
           I64[Sp - 8] = block_cabVT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabZF; else goto cabVU;
       uabZF: // global
           call _cabVT(R1) args: 0, res: 0, upd: 0;
       cabVU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabVT() //  [R1]
         { info_tbl: [(cabVT,
                       label: block_cabVT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabVT: // global
           I64[Sp - 128] = block_cabVY_info;
           _sa8aJ::P64 = R1;
           _sa8aK::P64 = P64[R1 + 7];
           _sa8aL::P64 = P64[R1 + 15];
           _sa8aM::P64 = P64[R1 + 23];
           _sa8aN::P64 = P64[R1 + 31];
           _sa8aP::P64 = P64[R1 + 47];
           _sa8aQ::P64 = P64[R1 + 55];
           _sa8aR::P64 = P64[R1 + 63];
           _sa8aS::P64 = P64[R1 + 71];
           _sa8aT::P64 = P64[R1 + 79];
           _sa8aU::P64 = P64[R1 + 87];
           _sa8aV::P64 = P64[R1 + 95];
           _sa8aW::P64 = P64[R1 + 103];
           _sa8aX::P64 = P64[R1 + 111];
           _sa8aY::P64 = P64[R1 + 119];
           _sa8aZ::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sa8aK::P64;
           P64[Sp - 112] = _sa8aL::P64;
           P64[Sp - 104] = _sa8aM::P64;
           P64[Sp - 96] = _sa8aN::P64;
           P64[Sp - 88] = _sa8aP::P64;
           P64[Sp - 80] = _sa8aQ::P64;
           P64[Sp - 72] = _sa8aR::P64;
           P64[Sp - 64] = _sa8aS::P64;
           P64[Sp - 56] = _sa8aT::P64;
           P64[Sp - 48] = _sa8aU::P64;
           P64[Sp - 40] = _sa8aV::P64;
           P64[Sp - 32] = _sa8aW::P64;
           P64[Sp - 24] = _sa8aX::P64;
           P64[Sp - 16] = _sa8aY::P64;
           P64[Sp - 8] = _sa8aZ::P64;
           P64[Sp] = _sa8aJ::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto uabZB; else goto cabVZ;
       uabZB: // global
           call _cabVY(R1) args: 0, res: 0, upd: 0;
       cabVZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabVY() //  [R1]
         { info_tbl: [(cabVY,
                       label: block_cabVY_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabVY: // global
           if (R1 & 7 == 1) goto cabZp; else goto cabYt;
       cabZp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabZs; else goto cabZr;
       cabZs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabZr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabYt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cabYw; else goto cabYv;
       cabYw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabYv: // global
           I64[Hp - 24] = sat_sa8bs_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cabWT_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabWT() //  [R1]
         { info_tbl: [(cabWT,
                       label: block_cabWT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabWT: // global
           I64[Sp] = block_cabY8_info;
           _sa8bv::P64 = R1;
           R1 = P64[Sp + 120];
           P64[Sp + 128] = _sa8bv::P64;
           if (R1 & 7 != 0) goto uabZC; else goto cabY9;
       uabZC: // global
           call _cabY8(R1) args: 0, res: 0, upd: 0;
       cabY9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabY8() //  [R1]
         { info_tbl: [(cabY8,
                       label: block_cabY8_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabY8: // global
           if (R1 & 7 == 1) goto cabZc; else goto cabZl;
       cabZc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabZf; else goto cabZe;
       cabZf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabZe: // global
           I64[Hp - 16] = sat_sa8cf_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cabZa_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cabZl: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _sa8bw() args: 0, res: 0, upd: 0;
     }
 },
 _cabZa() //  [R1]
         { info_tbl: [(cabZa,
                       label: block_cabZa_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabZa: // global
           P64[Sp] = R1;
           call _sa8bw() args: 0, res: 0, upd: 0;
     }
 },
 _sa8bw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8bw: // global
           _sa8aP::P64 = P64[Sp + 40];
           _sa8aS::P64 = P64[Sp + 64];
           _sa8aT::P64 = P64[Sp + 72];
           _sa8aV::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sa8aT::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aT::P64);
           call MO_WriteBarrier();
           P64[_sa8aS::P64 + 8] = GHC.IO.Handle.Internals.noCharBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aS::P64);
           call MO_WriteBarrier();
           P64[_sa8aP::P64 + 8] = GHC.IO.Handle.Internals.noByteBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aP::P64);
           I64[Sp - 8] = block_cabYy_info;
           R1 = _sa8aV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabZK; else goto cabYQ;
       uabZK: // global
           call _cabYy(R1) args: 0, res: 0, upd: 0;
       cabYQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabYy() //  [R1]
         { info_tbl: [(cabYy,
                       label: block_cabYy_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabYy: // global
           if (R1 & 7 == 1) goto uabZz; else goto cabZ6;
       uabZz: // global
           Sp = Sp + 8;
           call _sa8bC() args: 0, res: 0, upd: 0;
       cabZ6: // global
           I64[Sp] = block_cabYZ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabZG; else goto cabZ0;
       uabZG: // global
           call _cabYZ(R1) args: 0, res: 0, upd: 0;
       cabZ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabYZ() //  [R1]
         { info_tbl: [(cabYZ,
                       label: block_cabYZ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabYZ: // global
           I64[Sp] = block_cabZ4_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabZ4() //  []
         { info_tbl: [(cabZ4,
                       label: block_cabZ4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabZ4: // global
           Sp = Sp + 8;
           call _sa8bC() args: 0, res: 0, upd: 0;
     }
 },
 _sa8bC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8bC: // global
           I64[Sp - 8] = block_cabXe_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabZL; else goto cabXf;
       uabZL: // global
           call _cabXe(R1) args: 0, res: 0, upd: 0;
       cabXf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabXe() //  [R1]
         { info_tbl: [(cabXe,
                       label: block_cabXe_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabXe: // global
           if (R1 & 7 == 1) goto cabYE; else goto cabYL;
       cabYE: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto cabYH; else goto cabYG;
       cabYH: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabYG: // global
           I64[Hp - 184] = sat_sa8bI_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = GHC.Base.Nothing_closure+1;
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabYL: // global
           I64[Sp] = block_cabXG_info;
           _sa8bE::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 88] = _sa8bE::P64;
           if (R1 & 7 != 0) goto uabZD; else goto cabXH;
       uabZD: // global
           call _cabXG(R1) args: 0, res: 0, upd: 0;
       cabXH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabXG() //  [R1]
         { info_tbl: [(cabXG,
                       label: block_cabXG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabXG: // global
           I64[Sp] = block_cabXL_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabXL() //  [R1]
         { info_tbl: [(cabXL,
                       label: block_cabXL_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabXL: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto cabYP; else goto cabYO;
       cabYP: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabYO: // global
           I64[Hp - 184] = sat_sa8bX_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.162387201 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help_closure" {
     GHC.IO.Handle.Internals.hClose_help_closure:
         const GHC.IO.Handle.Internals.hClose_help_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hClose_help_entry() //  [R2]
         { info_tbl: [(cac2B,
                       label: GHC.IO.Handle.Internals.hClose_help_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac2B: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.166137268 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer1_closure" {
     GHC.IO.Handle.Internals.handleFinalizer1_closure:
         const GHC.IO.Handle.Internals.handleFinalizer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer1_entry() //  [R2, R3]
         { info_tbl: [(cac2P,
                       label: GHC.IO.Handle.Internals.handleFinalizer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac2P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cac32; else goto cac33;
       cac32: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.handleFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cac33: // global
           I64[Sp - 8] = block_cac2M_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uac3a; else goto cac2N;
       uac3a: // global
           call _cac2M(R1) args: 0, res: 0, upd: 0;
       cac2N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac2M() //  [R1]
         { info_tbl: [(cac2M,
                       label: block_cac2M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac2M: // global
           I64[Sp - 8] = block_cac2S_info;
           _sa8cp::P64 = P64[R1 + 7];
           R1 = _sa8cp::P64;
           P64[Sp] = _sa8cp::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac2S() //  [R1]
         { info_tbl: [(cac2S,
                       label: block_cac2S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac2S: // global
           I64[Sp] = block_cac2U_info;
           R2 = R1;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cac2U() //  [R1]
         { info_tbl: [(cac2U,
                       label: block_cac2U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac2U: // global
           I64[Sp] = block_cac2W_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uac3b; else goto cac2X;
       uac3b: // global
           call _cac2W(R1) args: 0, res: 0, upd: 0;
       cac2X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac2W() //  [R1]
         { info_tbl: [(cac2W,
                       label: block_cac2W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac2W: // global
           _sa8cp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cac31_info;
           R2 = P64[R1 + 7];
           R1 = _sa8cp::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac31() //  []
         { info_tbl: [(cac31,
                       label: block_cac31_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac31: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.17803294 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer_closure" {
     GHC.IO.Handle.Internals.handleFinalizer_closure:
         const GHC.IO.Handle.Internals.handleFinalizer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer_entry() //  [R2, R3]
         { info_tbl: [(cac3D,
                       label: GHC.IO.Handle.Internals.handleFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac3D: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.handleFinalizer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.181338843 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle4_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.183726287 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle1_closure" {
     GHC.IO.Handle.Internals.mkFileHandle1_closure:
         const GHC.IO.Handle.Internals.mkFileHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac3M: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sa8cK_entry() //  [R1]
         { info_tbl: [(cac43,
                       label: sat_sa8cK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac43: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cac44; else goto cac45;
       cac44: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cac45: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cac3U_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uac4k; else goto cac3V;
       uac4k: // global
           call _cac3U(R1) args: 0, res: 0, upd: 0;
       cac3V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cac3U() //  [R1]
         { info_tbl: [(cac3U,
                       label: block_cac3U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac3U: // global
           _cac42::P64 = R1 & 7;
           if (_cac42::P64 < 3) goto uac4i; else goto uac4j;
       uac4i: // global
           if (_cac42::P64 < 2) goto cac3Y; else goto cac3Z;
       cac3Y: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cac3Z: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uac4j: // global
           if (_cac42::P64 < 4) goto cac40; else goto cac41;
       cac40: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cac41: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(cac4l,
                       label: GHC.IO.Handle.Internals.mkFileHandle1_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac4l: // global
           _sa8cE::P64 = R6;
           _sa8cD::P64 = R5;
           _sa8cC::P64 = R4;
           _sa8cB::P64 = R3;
           _sa8cA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cac4m; else goto cac4n;
       cac4n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cac4p; else goto cac4o;
       cac4p: // global
           HpAlloc = 24;
           goto cac4m;
       cac4m: // global
           R1 = GHC.IO.Handle.Internals.mkFileHandle1_closure;
           P64[Sp - 40] = _sa8cA::P64;
           P64[Sp - 32] = _sa8cB::P64;
           P64[Sp - 24] = _sa8cC::P64;
           P64[Sp - 16] = _sa8cD::P64;
           P64[Sp - 8] = _sa8cE::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cac4o: // global
           I64[Hp - 16] = sat_sa8cK_info;
           P64[Hp] = P64[Sp];
           R6 = _sa8cE::P64;
           R5 = _sa8cD::P64;
           R4 = _sa8cC::P64;
           R3 = _sa8cB::P64;
           R2 = _sa8cA::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = GHC.Types.True_closure+2;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 8] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.194270815 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle_closure" {
     GHC.IO.Handle.Internals.mkFileHandle_closure:
         const GHC.IO.Handle.Internals.mkFileHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac4P: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cac4T,
                       label: GHC.IO.Handle.Internals.mkFileHandle_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac4T: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.199640786 UTC

[section ""cstring" . lvl23_ra7PD_bytes" {
     lvl23_ra7PD_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,54,58,51,45,51,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.201483498 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle3_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle3_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle3_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle3_entry() //  []
         { info_tbl: [(cac59,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac59: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cac5a; else goto cac5b;
       cac5a: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cac5b: // global
           I64[Sp - 8] = block_cac57_info;
           R2 = lvl23_ra7PD_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cac57() //  [R1]
         { info_tbl: [(cac57,
                       label: block_cac57_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac57: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.206390799 UTC

[section ""cstring" . lvl24_ra7PE_bytes" {
     lvl24_ra7PE_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,48,58,51,45,51,53]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.208194323 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle2_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle2_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle2_entry() //  []
         { info_tbl: [(cac5u,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac5u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cac5v; else goto cac5w;
       cac5v: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cac5w: // global
           I64[Sp - 8] = block_cac5s_info;
           R2 = lvl24_ra7PE_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cac5s() //  [R1]
         { info_tbl: [(cac5s,
                       label: block_cac5s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac5s: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.214330785 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle1_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle1_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac5J: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cac5W,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle1_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac5W: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cac5X; else goto cac5Y;
       cac5X: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cac5Y: // global
           I64[Sp - 48] = block_cac5N_info;
           _sa8cT::P64 = R6;
           R6 = R6;
           _sa8cS::P64 = R5;
           R5 = R5;
           _sa8cR::P64 = R4;
           R4 = R4;
           _sa8cQ::P64 = R3;
           R3 = R3;
           _sa8cP::P64 = R2;
           R2 = R2;
           P64[Sp - 96] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 88] = GHC.Types.True_closure+2;
           P64[Sp - 80] = P64[Sp];
           P64[Sp - 72] = P64[Sp + 8];
           P64[Sp - 64] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp - 56] = GHC.Base.Nothing_closure+1;
           P64[Sp - 40] = _sa8cP::P64;
           P64[Sp - 32] = _sa8cQ::P64;
           P64[Sp - 24] = _sa8cR::P64;
           P64[Sp - 16] = _sa8cS::P64;
           P64[Sp - 8] = _sa8cT::P64;
           Sp = Sp - 96;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
     }
 },
 _cac5N() //  [R1]
         { info_tbl: [(cac5N,
                       label: block_cac5N_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac5N: // global
           I64[Sp] = block_cac5P_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uac6t; else goto cac5Q;
       uac6t: // global
           call _cac5P(R1) args: 0, res: 0, upd: 0;
       cac5Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac5P() //  [R1]
         { info_tbl: [(cac5P,
                       label: block_cac5P_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac5P: // global
           if (R1 & 7 == 1) goto cac5T; else goto cac5U;
       cac5T: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cac69; else goto cac68;
       cac69: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cac68: // global
           _sa8d2::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = _sa8d2::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           _sa8cS::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cac64_info;
           R6 = P64[Sp + 40];
           R5 = _sa8cS::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp - 16] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 8] = P64[Sp + 56];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = Hp - 6;
           P64[Sp + 56] = _sa8d2::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
       cac5U: // global
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.mkDuplexHandle2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cac64() //  [R1]
         { info_tbl: [(cac64,
                       label: block_cac64_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac64: // global
           I64[Sp] = block_cac66_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uac6u; else goto cac6b;
       uac6u: // global
           call _cac66(R1) args: 0, res: 0, upd: 0;
       cac6b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac66() //  [R1]
         { info_tbl: [(cac66,
                       label: block_cac66_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac66: // global
           if (R1 & 7 == 1) goto cac6h; else goto cac6o;
       cac6h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cac6k; else goto cac6j;
       cac6k: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cac6j: // global
           _sa8da::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sa8da::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cac6o: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle3_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.228308978 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac74: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cac78,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac78: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.233759917 UTC

[section ""data" . $wlvl_ra7PF_closure" {
     $wlvl_ra7PF_closure:
         const $wlvl_ra7PF_info;
         const 0;
 },
 sat_sa8dy_entry() //  [R1]
         { info_tbl: [(cac7A,
                       label: sat_sa8dy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac7A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cac7B; else goto cac7C;
       cac7B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cac7C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cac7t_info;
           _sa8dn::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8dn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uac83; else goto cac7u;
       uac83: // global
           call _cac7t(R1) args: 0, res: 0, upd: 0;
       cac7u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cac7t() //  [R1]
         { info_tbl: [(cac7t,
                       label: block_cac7t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac7t: // global
           if (R1 & 7 == 1) goto cac7x; else goto cac7y;
       cac7x: // global
           _sa8dn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cac7F_info;
           R1 = _sa8dn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uac82; else goto cac7H;
       uac82: // global
           call _cac7F(R1) args: 0, res: 0, upd: 0;
       cac7H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cac7y: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cac7F() //  [R1]
         { info_tbl: [(cac7F,
                       label: block_cac7F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac7F: // global
           if (R1 & 7 == 1) goto cac7N; else goto cac7U;
       cac7N: // global
           Hp = Hp + 16;
           _sa8dr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cac7X; else goto cac7P;
       cac7P: // global
           _sa8ds::P64 = P64[_sa8dr::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa8ds::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cac7U: // global
           Hp = Hp + 16;
           _sa8dr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cac7X; else goto cac7W;
       cac7X: // global
           HpAlloc = 16;
           R1 = _sa8dr::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cac7W: // global
           _sa8du::P64 = P64[_sa8dr::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa8du::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8dA_entry() //  [R1]
         { info_tbl: [(cac86,
                       label: sat_sa8dA_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac86: // global
           _sa8dA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cac87; else goto cac88;
       cac88: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cac8a; else goto cac89;
       cac8a: // global
           HpAlloc = 104;
           goto cac87;
       cac87: // global
           R1 = _sa8dA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cac89: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa8dA::P64;
           _sa8di::P64 = P64[_sa8dA::P64 + 16];
           _sa8dj::P64 = P64[_sa8dA::P64 + 24];
           _sa8dk::P64 = P64[_sa8dA::P64 + 32];
           _sa8dl::P64 = P64[_sa8dA::P64 + 40];
           _sa8dm::P64 = P64[_sa8dA::P64 + 48];
           _sa8dn::P64 = P64[_sa8dA::P64 + 56];
           I64[Hp - 96] = sat_sa8dy_info;
           P64[Hp - 80] = _sa8dl::P64;
           P64[Hp - 72] = _sa8dn::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa8dn::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sa8di::P64;
           P64[Hp - 24] = _sa8dm::P64;
           P64[Hp - 16] = _sa8dj::P64;
           P64[Hp - 8] = _sa8dk::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_ra7PF_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cac8b,
                       label: $wlvl_ra7PF_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac8b: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cac8f; else goto cac8e;
       cac8f: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_ra7PF_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cac8e: // global
           I64[Hp - 56] = sat_sa8dA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 56;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.2483489 UTC

[section ""data" . GHC.IO.Handle.Internals.$wdo_operation_closure" {
     GHC.IO.Handle.Internals.$wdo_operation_closure:
         const GHC.IO.Handle.Internals.$wdo_operation_info;
         const 0;
 },
 sat_sa8e5_entry() //  [R1, R2]
         { info_tbl: [(cac93,
                       label: sat_sa8e5_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac93: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cac97; else goto cac98;
       cac97: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cac98: // global
           I64[Sp - 48] = block_cac8Y_info;
           _sa8dK::P64 = R2;
           R2 = P64[R1 + 38];
           _sa8dB::P64 = P64[R1 + 6];
           _sa8dC::P64 = P64[R1 + 14];
           _sa8dD::P64 = P64[R1 + 22];
           _sa8dE::P64 = P64[R1 + 30];
           R1 = _sa8dE::P64;
           P64[Sp - 40] = _sa8dB::P64;
           P64[Sp - 32] = _sa8dC::P64;
           P64[Sp - 24] = _sa8dD::P64;
           P64[Sp - 16] = _sa8dE::P64;
           P64[Sp - 8] = _sa8dK::P64;
           Sp = Sp - 48;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac8Y() //  []
         { info_tbl: [(cac8Y,
                       label: block_cac8Y_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac8Y: // global
           I64[Sp] = block_cac90_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto uac9Q; else goto cac91;
       uac9Q: // global
           call _cac90(R1) args: 0, res: 0, upd: 0;
       cac91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac90() //  [R1]
         { info_tbl: [(cac90,
                       label: block_cac90_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac90: // global
           I64[Sp - 16] = block_cac96_info;
           _sa8dO::P64 = P64[R1 + 7];
           R2 = _sa8dO::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sa8dO::P64;
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cac96() //  [R1]
         { info_tbl: [(cac96,
                       label: block_cac96_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac96: // global
           I64[Sp] = block_cac9e_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cac9e() //  [R1]
         { info_tbl: [(cac9e,
                       label: block_cac9e_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac9e: // global
           if (R1 & 7 == 1) goto cac9m; else goto cac9J;
       cac9m: // global
           _sa8dO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cac9j_info;
           R2 = _sa8dO::P64;
           Sp = Sp + 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       cac9J: // global
           I64[Sp + 16] = block_cac9H_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac9j() //  [R1]
         { info_tbl: [(cac9j,
                       label: block_cac9j_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac9j: // global
           I64[Sp] = block_cac9q_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cac9q() //  [R1]
         { info_tbl: [(cac9q,
                       label: block_cac9q_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac9q: // global
           _sa8dN::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cac9x; else goto cac9C;
       cac9x: // global
           R1 = _sa8dN::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cac9C: // global
           I64[Sp] = block_cac9A_info;
           R2 = _sa8dN::P64;
           R1 = CurrentTSO;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac9A() //  []
         { info_tbl: [(cac9A,
                       label: block_cac9A_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac9A: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cac9H() //  [R1]
         { info_tbl: [(cac9H,
                       label: block_cac9H_info
                       rep:StackRep [False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac9H: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 47];
           R4 = P64[R1 + 39];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 15];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 40;
           call $wlvl_ra7PF_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wdo_operation_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cac9R,
                       label: GHC.IO.Handle.Internals.$wdo_operation_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac9R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cac9S; else goto cac9T;
       cac9S: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wdo_operation_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cac9T: // global
           I64[Sp - 40] = block_cac8P_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac8P() //  [R1]
         { info_tbl: [(cac8P,
                       label: block_cac8P_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac8P: // global
           I64[Sp - 8] = block_cac8R_info;
           R2 = R1;
           _sa8dI::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _sa8dI::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac8R() //  [R1]
         { info_tbl: [(cac8R,
                       label: block_cac8R_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac8R: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cac9X; else goto cac9W;
       cac9X: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cac9W: // global
           I64[Hp - 40] = sat_sa8e5_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 38;
           R1 = R1;
           Sp = Sp + 48;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.27195704 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_1_closure" {
     GHC.IO.Handle.Internals.withHandle_1_closure:
         const GHC.IO.Handle.Internals.withHandle_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cacaU,
                       label: GHC.IO.Handle.Internals.withHandle_1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacaU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cacaV; else goto cacaW;
       cacaV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacaW: // global
           I64[Sp - 32] = block_cacaR_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uacb0; else goto cacaS;
       uacb0: // global
           call _cacaR(R1) args: 0, res: 0, upd: 0;
       cacaS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacaR() //  [R1]
         { info_tbl: [(cacaR,
                       label: block_cacaR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacaR: // global
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.278961634 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle__'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle__'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle__'_info;
         const 0;
 },
 sat_sa8ev_entry() //  [R1]
         { info_tbl: [(cacbs,
                       label: sat_sa8ev_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacbs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacbt; else goto cacbu;
       cacbt: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacbu: // global
           I64[Sp - 16] = block_cacbo_info;
           _sa8ef::P64 = P64[R1 + 23];
           R5 = _sa8ef::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8ef::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacbo() //  [R1]
         { info_tbl: [(cacbo,
                       label: block_cacbo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacbo: // global
           _sa8ef::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cacbq_info;
           R2 = R1;
           R1 = _sa8ef::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacbq() //  []
         { info_tbl: [(cacbq,
                       label: block_cacbq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacbq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwithHandle__'_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cacbA,
                       label: GHC.IO.Handle.Internals.$wwithHandle__'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacbA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacbB; else goto cacbC;
       cacbB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle__'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacbC: // global
           I64[Sp - 40] = block_cacbe_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cacbe() //  [R1]
         { info_tbl: [(cacbe,
                       label: block_cacbe_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacbe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacbF; else goto cacbE;
       cacbF: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacbE: // global
           _sa8ed::P64 = P64[Sp + 8];
           _sa8ee::P64 = P64[Sp + 16];
           _sa8ef::P64 = P64[Sp + 24];
           _sa8eg::P64 = P64[Sp + 32];
           if (R1 == 0) goto cacbz; else goto cacby;
       cacbz: // global
           I64[Hp - 32] = sat_sa8ev_info;
           P64[Hp - 24] = _sa8ed::P64;
           P64[Hp - 16] = _sa8ee::P64;
           P64[Hp - 8] = _sa8ef::P64;
           P64[Hp] = _sa8eg::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacby: // global
           Hp = Hp - 40;
           I64[Sp + 16] = block_cacbG_info;
           R5 = _sa8ef::P64;
           R4 = _sa8eg::P64;
           R3 = _sa8ee::P64;
           R2 = _sa8ed::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacbG() //  [R1]
         { info_tbl: [(cacbG,
                       label: block_cacbG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacbG: // global
           I64[Sp + 16] = block_cacbI_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacbI() //  []
         { info_tbl: [(cacbI,
                       label: block_cacbI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacbI: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.293366879 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'1_closure" {
     GHC.IO.Handle.Internals.withHandle__'1_closure:
         const GHC.IO.Handle.Internals.withHandle__'1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caccj,
                       label: GHC.IO.Handle.Internals.withHandle__'1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caccj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cacck; else goto caccl;
       cacck: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle__'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caccl: // global
           I64[Sp - 32] = block_caccg_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaccp; else goto cacch;
       uaccp: // global
           call _caccg(R1) args: 0, res: 0, upd: 0;
       cacch: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caccg() //  [R1]
         { info_tbl: [(caccg,
                       label: block_caccg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caccg: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.299246509 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'_closure" {
     GHC.IO.Handle.Internals.withHandle__'_closure:
         const GHC.IO.Handle.Internals.withHandle__'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caccD,
                       label: GHC.IO.Handle.Internals.withHandle__'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caccD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle__'1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.30427611 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles__1_closure" {
     GHC.IO.Handle.Internals.withAllHandles__1_closure:
         const GHC.IO.Handle.Internals.withAllHandles__1_info;
         const 0;
 },
 sat_sa8eX_entry() //  [R1]
         { info_tbl: [(cacd7,
                       label: sat_sa8eX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacd7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacd8; else goto cacd9;
       cacd8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacd9: // global
           I64[Sp - 16] = block_cacd3_info;
           _sa8eJ::P64 = P64[R1 + 31];
           R5 = _sa8eJ::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8eJ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacd3() //  [R1]
         { info_tbl: [(cacd3,
                       label: block_cacd3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacd3: // global
           _sa8eJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cacd5_info;
           R2 = R1;
           R1 = _sa8eJ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacd5() //  []
         { info_tbl: [(cacd5,
                       label: block_cacd5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacd5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8fj_entry() //  [R1]
         { info_tbl: [(cacdz,
                       label: sat_sa8fj_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacdz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacdA; else goto cacdB;
       cacdA: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacdB: // global
           I64[Sp - 16] = block_cacdv_info;
           _sa8f0::P64 = P64[R1 + 31];
           R5 = _sa8f0::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8f0::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacdv() //  [R1]
         { info_tbl: [(cacdv,
                       label: block_cacdv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacdv: // global
           _sa8f0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cacdx_info;
           R2 = R1;
           R1 = _sa8f0::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacdx() //  []
         { info_tbl: [(cacdx,
                       label: block_cacdx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacdx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8fu_entry() //  [R1]
         { info_tbl: [(cacdQ,
                       label: sat_sa8fu_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacdQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacdR; else goto cacdS;
       cacdR: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacdS: // global
           I64[Sp - 16] = block_cacdM_info;
           _sa8eZ::P64 = P64[R1 + 31];
           R5 = _sa8eZ::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8eZ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacdM() //  [R1]
         { info_tbl: [(cacdM,
                       label: block_cacdM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacdM: // global
           _sa8eZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cacdO_info;
           R2 = R1;
           R1 = _sa8eZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacdO() //  []
         { info_tbl: [(cacdO,
                       label: block_cacdO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacdO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.withAllHandles__1_entry() //  [R2, R3, R4]
         { info_tbl: [(cacdZ,
                       label: GHC.IO.Handle.Internals.withAllHandles__1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacdZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cace0; else goto cace1;
       cace0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withAllHandles__1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cace1: // global
           I64[Sp - 24] = block_caccO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaceI; else goto caccP;
       uaceI: // global
           call _caccO(R1) args: 0, res: 0, upd: 0;
       caccP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caccO() //  [R1]
         { info_tbl: [(caccO,
                       label: block_caccO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caccO: // global
           if (R1 & 7 == 1) goto cacdW; else goto cacdX;
       cacdW: // global
           I64[Sp - 16] = block_caccT_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacdX: // global
           I64[Sp - 24] = block_cacde_info;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caccT() //  [R1]
         { info_tbl: [(caccT,
                       label: block_caccT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caccT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cace5; else goto cace4;
       cace5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cace4: // global
           _sa8eD::P64 = P64[Sp + 24];
           _sa8eF::P64 = P64[Sp + 32];
           _sa8eH::P64 = P64[Sp + 16];
           _sa8eJ::P64 = P64[Sp + 8];
           if (R1 == 0) goto cacee; else goto cacea;
       cacee: // global
           I64[Hp - 32] = sat_sa8eX_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8eJ::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacea: // global
           Hp = Hp - 40;
           I64[Sp] = block_cace6_info;
           R5 = _sa8eJ::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cace6() //  [R1]
         { info_tbl: [(cace6,
                       label: block_cace6_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cace6: // global
           I64[Sp + 32] = block_cacep_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacde() //  [R1]
         { info_tbl: [(cacde,
                       label: block_cacde_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacde: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacei; else goto caceh;
       cacei: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caceh: // global
           _sa8eD::P64 = P64[Sp + 32];
           _sa8eF::P64 = P64[Sp + 40];
           _sa8eH::P64 = P64[Sp + 24];
           _sa8eZ::P64 = P64[Sp + 8];
           if (R1 == 0) goto caceF; else goto caceA;
       caceF: // global
           I64[Hp - 32] = sat_sa8fu_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8eZ::P64;
           I64[Sp + 8] = block_caceE_info;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       caceA: // global
           Hp = Hp - 40;
           I64[Sp] = block_cacew_info;
           R5 = _sa8eZ::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caceE() //  []
         { info_tbl: [(caceE,
                       label: block_caceE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caceE: // global
           call _sa8f4() args: 0, res: 0, upd: 0;
     }
 },
 _cacew() //  [R1]
         { info_tbl: [(cacew,
                       label: block_cacew_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacew: // global
           _sa8eZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_sa8f4_info;
           R2 = R1;
           R1 = _sa8eZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _sa8f4() //  []
         { info_tbl: [(sa8f4,
                       label: block_sa8f4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8f4: // global
           I64[Sp] = block_cacdl_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cacdl() //  [R1]
         { info_tbl: [(cacdl,
                       label: block_cacdl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacdl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacem; else goto cacel;
       cacem: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacel: // global
           _sa8eD::P64 = P64[Sp + 24];
           _sa8eF::P64 = P64[Sp + 32];
           _sa8eH::P64 = P64[Sp + 16];
           _sa8f0::P64 = P64[Sp + 8];
           if (R1 == 0) goto cacev; else goto cacer;
       cacev: // global
           I64[Hp - 32] = sat_sa8fj_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8f0::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacer: // global
           Hp = Hp - 40;
           I64[Sp] = block_cacen_info;
           R5 = _sa8f0::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacen() //  [R1]
         { info_tbl: [(cacen,
                       label: block_cacen_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacen: // global
           I64[Sp + 32] = block_cacep_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacep() //  []
         { info_tbl: [(cacep,
                       label: block_cacep_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacep: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.341816717 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles___closure" {
     GHC.IO.Handle.Internals.withAllHandles___closure:
         const GHC.IO.Handle.Internals.withAllHandles___info;
         const 0;
 },
 GHC.IO.Handle.Internals.withAllHandles___entry() //  [R2, R3, R4]
         { info_tbl: [(cacg1,
                       label: GHC.IO.Handle.Internals.withAllHandles___info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacg1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.345873345 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle'_info;
         const 0;
 },
 io_sa8fG_entry() //  [R1]
         { info_tbl: [(cacgo,
                       label: io_sa8fG_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacgo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacgs; else goto cacgt;
       cacgs: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacgt: // global
           I64[Sp - 16] = block_cacgj_info;
           _sa8fA::P64 = P64[R1 + 23];
           R5 = _sa8fA::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8fA::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacgj() //  [R1]
         { info_tbl: [(cacgj,
                       label: block_cacgj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacgj: // global
           I64[Sp] = block_cacgl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacgy; else goto cacgm;
       uacgy: // global
           call _cacgl(R1) args: 0, res: 0, upd: 0;
       cacgm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacgl() //  [R1]
         { info_tbl: [(cacgl,
                       label: block_cacgl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacgl: // global
           I64[Sp] = block_cacgr_info;
           R2 = P64[R1 + 7];
           _sa8fN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8fN::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacgr() //  []
         { info_tbl: [(cacgr,
                       label: block_cacgr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacgr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwithHandle'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cacgD,
                       label: GHC.IO.Handle.Internals.$wwithHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacgD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacgE; else goto cacgF;
       cacgE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacgF: // global
           I64[Sp - 40] = block_cacgc_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cacgc() //  [R1]
         { info_tbl: [(cacgc,
                       label: block_cacgc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacgc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacgI; else goto cacgH;
       cacgI: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacgH: // global
           I64[Hp - 32] = io_sa8fG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           _cacge::P64 = Hp - 31;
           if (R1 == 0) goto cacgC; else goto cacgB;
       cacgC: // global
           R1 = _cacge::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacgB: // global
           R1 = _cacge::P64;
           Sp = Sp + 40;
           call io_sa8fG_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.359630612 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle1_closure" {
     GHC.IO.Handle.Internals.withHandle1_closure:
         const GHC.IO.Handle.Internals.withHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cachh,
                       label: GHC.IO.Handle.Internals.withHandle1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cachh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cachi; else goto cachj;
       cachi: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cachj: // global
           I64[Sp - 32] = block_cache_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uachn; else goto cachf;
       uachn: // global
           call _cache(R1) args: 0, res: 0, upd: 0;
       cachf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cache() //  [R1]
         { info_tbl: [(cache,
                       label: block_cache_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cache: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.365640049 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle'_closure" {
     GHC.IO.Handle.Internals.withHandle'_closure:
         const GHC.IO.Handle.Internals.withHandle'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cachB,
                       label: GHC.IO.Handle.Internals.withHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cachB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.369655301 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'1_closure" {
     GHC.IO.Handle.Internals.withHandle_'1_closure:
         const GHC.IO.Handle.Internals.withHandle_'1_info;
         const 0;
 },
 sat_sa8ga_entry() //  [R1, R2]
         { info_tbl: [(cachZ,
                       label: sat_sa8ga_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cachZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caci0; else goto caci1;
       caci0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caci1: // global
           I64[Sp - 16] = block_cachW_info;
           _sa8g4::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8g4::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cachW() //  [R1]
         { info_tbl: [(cachW,
                       label: block_cachW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cachW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caci4; else goto caci3;
       caci4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caci3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.withHandle_'1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caci5,
                       label: GHC.IO.Handle.Internals.withHandle_'1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caci5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caci6; else goto caci7;
       caci6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caci7: // global
           I64[Sp - 32] = block_cachM_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uacib; else goto cachN;
       uacib: // global
           call _cachM(R1) args: 0, res: 0, upd: 0;
       cachN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cachM() //  [R1]
         { info_tbl: [(cachM,
                       label: block_cachM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cachM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacia; else goto caci9;
       cacia: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caci9: // global
           _sa8g3::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sa8ga_info;
           P64[Hp] = P64[Sp + 24];
           R5 = Hp - 6;
           R4 = _sa8g3::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.379281284 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'_closure" {
     GHC.IO.Handle.Internals.withHandle_'_closure:
         const GHC.IO.Handle.Internals.withHandle_'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caciz,
                       label: GHC.IO.Handle.Internals.withHandle_'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caciz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle_'1_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.384876776 UTC

[section ""data" . withHandle_2_ra7PG_closure" {
     withHandle_2_ra7PG_closure:
         const withHandle_2_ra7PG_info;
         const 0;
 },
 sat_sa8gt_entry() //  [R1, R2]
         { info_tbl: [(cacj4,
                       label: sat_sa8gt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacj4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacj5; else goto cacj6;
       cacj5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacj6: // global
           I64[Sp - 16] = block_cacj1_info;
           _sa8gn::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8gn::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacj1() //  [R1]
         { info_tbl: [(cacj1,
                       label: block_cacj1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacj1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacj9; else goto cacj8;
       cacj9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacj8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8gl_entry() //  [R1]
         { info_tbl: [(cacjf,
                       label: io_sa8gl_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacjf: // global
           _sa8gl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacjj; else goto cacjk;
       cacjk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacjm; else goto cacjl;
       cacjm: // global
           HpAlloc = 16;
           goto cacjj;
       cacjj: // global
           R1 = _sa8gl::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacjl: // global
           _sa8gb::P64 = P64[_sa8gl::P64 + 7];
           _sa8gd::P64 = P64[_sa8gl::P64 + 15];
           _sa8gf::P64 = P64[_sa8gl::P64 + 23];
           _sa8gh::P64 = P64[_sa8gl::P64 + 31];
           I64[Hp - 8] = sat_sa8gt_info;
           P64[Hp] = _sa8gd::P64;
           I64[Sp - 16] = block_cacja_info;
           R5 = _sa8gh::P64;
           R4 = Hp - 6;
           R3 = _sa8gf::P64;
           R2 = _sa8gb::P64;
           P64[Sp - 8] = _sa8gh::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacja() //  [R1]
         { info_tbl: [(cacja,
                       label: block_cacja_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacja: // global
           I64[Sp] = block_cacjc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacjr; else goto cacjd;
       uacjr: // global
           call _cacjc(R1) args: 0, res: 0, upd: 0;
       cacjd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacjc() //  [R1]
         { info_tbl: [(cacjc,
                       label: block_cacjc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacjc: // global
           I64[Sp] = block_cacji_info;
           R2 = P64[R1 + 7];
           _sa8gz::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8gz::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacji() //  []
         { info_tbl: [(cacji,
                       label: block_cacji_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacji: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8gQ_entry() //  [R1, R2]
         { info_tbl: [(cacjJ,
                       label: sat_sa8gQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacjJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacjK; else goto cacjL;
       cacjK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacjL: // global
           I64[Sp - 16] = block_cacjG_info;
           _sa8gK::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8gK::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacjG() //  [R1]
         { info_tbl: [(cacjG,
                       label: block_cacjG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacjG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacjO; else goto cacjN;
       cacjO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacjN: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8gI_entry() //  [R1]
         { info_tbl: [(cacjU,
                       label: io_sa8gI_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacjU: // global
           _sa8gI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacjY; else goto cacjZ;
       cacjZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cack1; else goto cack0;
       cack1: // global
           HpAlloc = 16;
           goto cacjY;
       cacjY: // global
           R1 = _sa8gI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cack0: // global
           _sa8gb::P64 = P64[_sa8gI::P64 + 7];
           _sa8gd::P64 = P64[_sa8gI::P64 + 15];
           _sa8gf::P64 = P64[_sa8gI::P64 + 23];
           _sa8gD::P64 = P64[_sa8gI::P64 + 31];
           I64[Hp - 8] = sat_sa8gQ_info;
           P64[Hp] = _sa8gd::P64;
           I64[Sp - 16] = block_cacjP_info;
           R5 = _sa8gD::P64;
           R4 = Hp - 6;
           R3 = _sa8gf::P64;
           R2 = _sa8gb::P64;
           P64[Sp - 8] = _sa8gD::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacjP() //  [R1]
         { info_tbl: [(cacjP,
                       label: block_cacjP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacjP: // global
           I64[Sp] = block_cacjR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uack6; else goto cacjS;
       uack6: // global
           call _cacjR(R1) args: 0, res: 0, upd: 0;
       cacjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacjR() //  [R1]
         { info_tbl: [(cacjR,
                       label: block_cacjR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacjR: // global
           I64[Sp] = block_cacjX_info;
           R2 = P64[R1 + 7];
           _sa8gW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8gW::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacjX() //  []
         { info_tbl: [(cacjX,
                       label: block_cacjX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacjX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 withHandle_2_ra7PG_entry() //  [R2, R3, R4]
         { info_tbl: [(cackb,
                       label: withHandle_2_ra7PG_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cackb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cackc; else goto cackd;
       cackc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle_2_ra7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cackd: // global
           I64[Sp - 24] = block_caciK_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacku; else goto caciL;
       uacku: // global
           call _caciK(R1) args: 0, res: 0, upd: 0;
       caciL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caciK() //  [R1]
         { info_tbl: [(caciK,
                       label: block_caciK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caciK: // global
           if (R1 & 7 == 1) goto cack8; else goto cack9;
       cack8: // global
           I64[Sp - 16] = block_caciP_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cack9: // global
           I64[Sp - 16] = block_cacju_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caciP() //  [R1]
         { info_tbl: [(caciP,
                       label: block_caciP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caciP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cackh; else goto cackg;
       cackh: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cackg: // global
           I64[Hp - 32] = io_sa8gl_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caciR::P64 = Hp - 31;
           if (R1 == 0) goto cackl; else goto cackk;
       cackl: // global
           R1 = _caciR::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cackk: // global
           R1 = _caciR::P64;
           Sp = Sp + 40;
           call io_sa8gl_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cacju() //  [R1]
         { info_tbl: [(cacju,
                       label: block_cacju_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacju: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cackp; else goto cacko;
       cackp: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacko: // global
           I64[Hp - 32] = io_sa8gI_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacjw::P64 = Hp - 31;
           if (R1 == 0) goto cackt; else goto cacks;
       cackt: // global
           R1 = _cacjw::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacks: // global
           R1 = _cacjw::P64;
           Sp = Sp + 40;
           call io_sa8gI_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.417169373 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__closure" {
     GHC.IO.Handle.Internals.withHandle__closure:
         const GHC.IO.Handle.Internals.withHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__entry() //  [R2, R3, R4]
         { info_tbl: [(caclM,
                       label: GHC.IO.Handle.Internals.withHandle__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caclM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle_2_ra7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.422699164 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_1_info;
         const 0;
 },
 sat_sa8hh_entry() //  [R1, R2]
         { info_tbl: [(cacmh,
                       label: sat_sa8hh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacmh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacmi; else goto cacmj;
       cacmi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacmj: // global
           I64[Sp - 16] = block_cacme_info;
           R3 = R2;
           _sa8hb::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sa8hb::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacme() //  [R1]
         { info_tbl: [(cacme,
                       label: block_cacme_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacme: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacmm; else goto cacml;
       cacmm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacml: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8h9_entry() //  [R1]
         { info_tbl: [(cacms,
                       label: io_sa8h9_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacms: // global
           _sa8h9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacmw; else goto cacmx;
       cacmx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacmz; else goto cacmy;
       cacmz: // global
           HpAlloc = 16;
           goto cacmw;
       cacmw: // global
           R1 = _sa8h9::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacmy: // global
           _sa8gZ::P64 = P64[_sa8h9::P64 + 7];
           _sa8h1::P64 = P64[_sa8h9::P64 + 15];
           _sa8h3::P64 = P64[_sa8h9::P64 + 23];
           _sa8h5::P64 = P64[_sa8h9::P64 + 31];
           I64[Hp - 8] = sat_sa8hh_info;
           P64[Hp] = _sa8h1::P64;
           I64[Sp - 16] = block_cacmn_info;
           R5 = _sa8h5::P64;
           R4 = Hp - 6;
           R3 = _sa8h3::P64;
           R2 = _sa8gZ::P64;
           P64[Sp - 8] = _sa8h5::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacmn() //  [R1]
         { info_tbl: [(cacmn,
                       label: block_cacmn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacmn: // global
           I64[Sp] = block_cacmp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacmE; else goto cacmq;
       uacmE: // global
           call _cacmp(R1) args: 0, res: 0, upd: 0;
       cacmq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacmp() //  [R1]
         { info_tbl: [(cacmp,
                       label: block_cacmp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacmp: // global
           I64[Sp] = block_cacmv_info;
           R2 = P64[R1 + 7];
           _sa8hn::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8hn::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacmv() //  []
         { info_tbl: [(cacmv,
                       label: block_cacmv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacmv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8hE_entry() //  [R1, R2]
         { info_tbl: [(cacmW,
                       label: sat_sa8hE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacmW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacmX; else goto cacmY;
       cacmX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacmY: // global
           I64[Sp - 16] = block_cacmT_info;
           R3 = R2;
           _sa8hy::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sa8hy::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacmT() //  [R1]
         { info_tbl: [(cacmT,
                       label: block_cacmT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacmT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacn1; else goto cacn0;
       cacn1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacn0: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8hw_entry() //  [R1]
         { info_tbl: [(cacn7,
                       label: io_sa8hw_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacn7: // global
           _sa8hw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacnb; else goto cacnc;
       cacnc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacne; else goto cacnd;
       cacne: // global
           HpAlloc = 16;
           goto cacnb;
       cacnb: // global
           R1 = _sa8hw::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacnd: // global
           _sa8gZ::P64 = P64[_sa8hw::P64 + 7];
           _sa8h1::P64 = P64[_sa8hw::P64 + 15];
           _sa8h3::P64 = P64[_sa8hw::P64 + 23];
           _sa8hr::P64 = P64[_sa8hw::P64 + 31];
           I64[Hp - 8] = sat_sa8hE_info;
           P64[Hp] = _sa8h1::P64;
           I64[Sp - 16] = block_cacn2_info;
           R5 = _sa8hr::P64;
           R4 = Hp - 6;
           R3 = _sa8h3::P64;
           R2 = _sa8gZ::P64;
           P64[Sp - 8] = _sa8hr::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacn2() //  [R1]
         { info_tbl: [(cacn2,
                       label: block_cacn2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacn2: // global
           I64[Sp] = block_cacn4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacnj; else goto cacn5;
       uacnj: // global
           call _cacn4(R1) args: 0, res: 0, upd: 0;
       cacn5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacn4() //  [R1]
         { info_tbl: [(cacn4,
                       label: block_cacn4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacn4: // global
           I64[Sp] = block_cacna_info;
           R2 = P64[R1 + 7];
           _sa8hK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8hK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacna() //  []
         { info_tbl: [(cacna,
                       label: block_cacna_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacna: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle_1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cacno,
                       label: GHC.IO.Handle.Internals.wantReadableHandle_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacno: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacnp; else goto cacnq;
       cacnp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacnq: // global
           I64[Sp - 24] = block_caclX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacnH; else goto caclY;
       uacnH: // global
           call _caclX(R1) args: 0, res: 0, upd: 0;
       caclY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caclX() //  [R1]
         { info_tbl: [(caclX,
                       label: block_caclX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caclX: // global
           if (R1 & 7 == 1) goto cacnl; else goto cacnm;
       cacnl: // global
           I64[Sp - 16] = block_cacm2_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacnm: // global
           I64[Sp - 16] = block_cacmH_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cacm2() //  [R1]
         { info_tbl: [(cacm2,
                       label: block_cacm2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacm2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacnu; else goto cacnt;
       cacnu: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacnt: // global
           I64[Hp - 32] = io_sa8h9_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacm4::P64 = Hp - 31;
           if (R1 == 0) goto cacny; else goto cacnx;
       cacny: // global
           R1 = _cacm4::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacnx: // global
           R1 = _cacm4::P64;
           Sp = Sp + 40;
           call io_sa8h9_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cacmH() //  [R1]
         { info_tbl: [(cacmH,
                       label: block_cacmH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacmH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacnC; else goto cacnB;
       cacnC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacnB: // global
           I64[Hp - 32] = io_sa8hw_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacmJ::P64 = Hp - 31;
           if (R1 == 0) goto cacnG; else goto cacnF;
       cacnG: // global
           R1 = _cacmJ::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacnF: // global
           R1 = _cacmJ::P64;
           Sp = Sp + 40;
           call io_sa8hw_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.454613671 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle__closure" {
     GHC.IO.Handle.Internals.wantReadableHandle__closure:
         const GHC.IO.Handle.Internals.wantReadableHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle__entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cacoZ,
                       label: GHC.IO.Handle.Internals.wantReadableHandle__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacoZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.45866368 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle2_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle2_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle2_info;
         const 0;
 },
 sat_sa8hS_entry() //  [R1]
         { info_tbl: [(cacpg,
                       label: sat_sa8hS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacpg: // global
           _sa8hS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacph; else goto cacpi;
       cacpi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cacpk; else goto cacpj;
       cacpk: // global
           HpAlloc = 72;
           goto cacph;
       cacph: // global
           R1 = _sa8hS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cacpj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa8hS::P64;
           _sa8hN::P64 = P64[_sa8hS::P64 + 16];
           _sa8hO::P64 = P64[_sa8hS::P64 + 24];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa8hO::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = _sa8hN::P64;
           P64[Hp - 16] = GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.wantSeekableHandle2_entry() //  [R2, R3]
         { info_tbl: [(cacpl,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacpl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cacpp; else goto cacpo;
       cacpp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cacpo: // global
           I64[Hp - 24] = sat_sa8hS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.46626394 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle1_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle1_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle1_info;
         const 0;
 },
 sat_sa8iB_entry() //  [R1, R2]
         { info_tbl: [(cacpX,
                       label: sat_sa8iB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacpX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacpY; else goto cacpZ;
       cacpY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacpZ: // global
           I64[Sp - 16] = block_cacpU_info;
           _sa8hV::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sa8hV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uacqP; else goto cacpV;
       uacqP: // global
           call _cacpU(R1) args: 0, res: 0, upd: 0;
       cacpV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacpU() //  [R1]
         { info_tbl: [(cacpU,
                       label: block_cacpU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacpU: // global
           I64[Sp - 24] = block_cacq2_info;
           _sa8i7::P64 = R1;
           _sa8i8::P64 = P64[R1 + 7];
           _sa8ib::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sa8i8::P64;
           P64[Sp - 8] = _sa8ib::P64;
           P64[Sp] = _sa8i7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacqO; else goto cacq4;
       uacqO: // global
           call _cacq2(R1) args: 0, res: 0, upd: 0;
       cacq4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacq2() //  [R1]
         { info_tbl: [(cacq2,
                       label: block_cacq2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacq2: // global
           _cacqI::P64 = R1 & 7;
           if (_cacqI::P64 < 3) goto uacqK; else goto uacqL;
       uacqK: // global
           if (_cacqI::P64 < 2) goto cacqz; else goto cacqD;
       cacqz: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cacqD: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uacqL: // global
           if (_cacqI::P64 != 5) goto cacqd; else goto uacqM;
       cacqd: // global
           _sa8ib::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cacq8_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sa8ib::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
       uacqM: // global
           Sp = Sp + 40;
           call _cacqH() args: 0, res: 0, upd: 0;
     }
 },
 _cacq8() //  [R1]
         { info_tbl: [(cacq8,
                       label: block_cacq8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacq8: // global
           I64[Sp] = block_cacqa_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacqR; else goto cacqf;
       uacqR: // global
           call _cacqa(R1) args: 0, res: 0, upd: 0;
       cacqf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacqa() //  [R1]
         { info_tbl: [(cacqa,
                       label: block_cacqa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacqa: // global
           if (R1 & 7 == 1) goto uacqN; else goto cacqs;
       uacqN: // global
           Sp = Sp + 24;
           call _cacqH() args: 0, res: 0, upd: 0;
       cacqs: // global
           I64[Sp] = block_cacqo_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacqo() //  [R1]
         { info_tbl: [(cacqo,
                       label: block_cacqo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacqo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacqv; else goto cacqu;
       cacqv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacqu: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cacqH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacqH: // global
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8i3_entry() //  [R1]
         { info_tbl: [(cacqY,
                       label: io_sa8i3_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacqY: // global
           _sa8i3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacr2; else goto cacr3;
       cacr3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacr5; else goto cacr4;
       cacr5: // global
           HpAlloc = 16;
           goto cacr2;
       cacr2: // global
           R1 = _sa8i3::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacr4: // global
           _sa8hT::P64 = P64[_sa8i3::P64 + 7];
           _sa8hV::P64 = P64[_sa8i3::P64 + 15];
           _sa8hX::P64 = P64[_sa8i3::P64 + 23];
           _sa8hZ::P64 = P64[_sa8i3::P64 + 31];
           I64[Hp - 8] = sat_sa8iB_info;
           P64[Hp] = _sa8hV::P64;
           I64[Sp - 16] = block_cacqT_info;
           R5 = _sa8hZ::P64;
           R4 = Hp - 6;
           R3 = _sa8hX::P64;
           R2 = _sa8hT::P64;
           P64[Sp - 8] = _sa8hZ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacqT() //  [R1]
         { info_tbl: [(cacqT,
                       label: block_cacqT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacqT: // global
           I64[Sp] = block_cacqV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacra; else goto cacqW;
       uacra: // global
           call _cacqV(R1) args: 0, res: 0, upd: 0;
       cacqW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacqV() //  [R1]
         { info_tbl: [(cacqV,
                       label: block_cacqV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacqV: // global
           I64[Sp] = block_cacr1_info;
           R2 = P64[R1 + 7];
           _sa8iH::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8iH::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacr1() //  []
         { info_tbl: [(cacr1,
                       label: block_cacr1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacr1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantSeekableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cacrf,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacrf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacrg; else goto cacrh;
       cacrg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacrh: // global
           I64[Sp - 24] = block_cacpD_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacrt; else goto cacpE;
       uacrt: // global
           call _cacpD(R1) args: 0, res: 0, upd: 0;
       cacpE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacpD() //  [R1]
         { info_tbl: [(cacpD,
                       label: block_cacpD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacpD: // global
           if (R1 & 7 == 1) goto cacrc; else goto cacrd;
       cacrc: // global
           I64[Sp - 16] = block_cacpI_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacrd: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.wantSeekableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _cacpI() //  [R1]
         { info_tbl: [(cacpI,
                       label: block_cacpI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacpI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacrl; else goto cacrk;
       cacrl: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacrk: // global
           I64[Hp - 32] = io_sa8i3_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacpK::P64 = Hp - 31;
           if (R1 == 0) goto cacrp; else goto cacro;
       cacrp: // global
           R1 = _cacpK::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacro: // global
           R1 = _cacpK::P64;
           Sp = Sp + 40;
           call io_sa8i3_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.493806466 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(cacsz,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacsz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.500964149 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwantWritableHandle'_closure" {
     GHC.IO.Handle.Internals.$wwantWritableHandle'_closure:
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_info;
         const 0;
 },
 sat_sa8jT_entry() //  [R1]
         { info_tbl: [(cactw,
                       label: sat_sa8jT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cactw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cactA; else goto cactB;
       cactA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cactB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cactt_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uactF; else goto cactu;
       uactF: // global
           call _cactt(R1) args: 0, res: 0, upd: 0;
       cactu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cactt() //  [R1]
         { info_tbl: [(cactt,
                       label: block_cactt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cactt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cactE; else goto cactD;
       cactE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cactD: // global
           _sa8jO::P64 = P64[R1 + 7];
           _sa8jN::I64 = I64[R1 + 23];
           _sa8jQ::I64 = I64[R1 + 31];
           _sa8jR::I64 = I64[R1 + 39];
           _sa8jS::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8jO::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sa8jN::I64;
           I64[Hp - 16] = _sa8jQ::I64;
           I64[Hp - 8] = _sa8jR::I64;
           I64[Hp] = _sa8jS::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8ko_entry() //  [R1]
         { info_tbl: [(cacu0,
                       label: sat_sa8ko_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacu0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cacu4; else goto cacu5;
       cacu4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cacu5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cactX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacu9; else goto cactY;
       uacu9: // global
           call _cactX(R1) args: 0, res: 0, upd: 0;
       cactY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cactX() //  [R1]
         { info_tbl: [(cactX,
                       label: block_cactX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cactX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cacu8; else goto cacu7;
       cacu8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cacu7: // global
           _sa8kj::P64 = P64[R1 + 7];
           _sa8kk::P64 = P64[R1 + 15];
           _sa8ki::I64 = I64[R1 + 23];
           _sa8kl::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8kj::P64;
           P64[Hp - 32] = _sa8kk::P64;
           I64[Hp - 24] = _sa8ki::I64;
           I64[Hp - 16] = _sa8kl::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa8kH_entry() //  [R1]
         { info_tbl: [(cacuw,
                       label: sat_sa8kH_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacuw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cacuD; else goto cacuE;
       cacuD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cacuE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cacut_info;
           _sa8kx::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa8kx::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uacuI; else goto cacuu;
       uacuI: // global
           call _cacut(R1) args: 0, res: 0, upd: 0;
       cacuu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cacut() //  [R1]
         { info_tbl: [(cacut,
                       label: block_cacut_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacut: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cacuH; else goto cacuG;
       cacuH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cacuG: // global
           _sa8kB::P64 = P64[R1 + 7];
           _sa8kC::P64 = P64[R1 + 15];
           _sa8kA::I64 = I64[R1 + 23];
           _sa8kD::I64 = I64[R1 + 31];
           _sa8kF::I64 = I64[R1 + 47];
           _sa8kG::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8kB::P64;
           P64[Hp - 32] = _sa8kC::P64;
           I64[Hp - 24] = _sa8kA::I64;
           I64[Hp - 16] = _sa8kD::I64;
           I64[Hp - 8] = _sa8kG::I64;
           I64[Hp] = _sa8kF::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uacx8_srtd" {
     uacx8_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 sat_sa8l6_entry() //  [R1, R2]
         { info_tbl: [(cacuJ,
                       label: sat_sa8l6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacuJ: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cacuK; else goto cacuL;
       cacuK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacuL: // global
           I64[Sp - 16] = block_cacsP_info;
           _sa8iQ::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sa8iQ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uacx0; else goto cacsQ;
       uacx0: // global
           call _cacsP(R1) args: 0, res: 0, upd: 0;
       cacsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uacx9_srtd" {
     uacx9_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 _cacsP() //  [R1]
         { info_tbl: [(cacsP,
                       label: block_cacsP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacsP: // global
           I64[Sp - 56] = block_cacsU_info;
           _sa8iU::P64 = R1;
           _sa8iW::P64 = P64[R1 + 15];
           _sa8iY::P64 = P64[R1 + 31];
           _sa8j0::P64 = P64[R1 + 47];
           _sa8j2::P64 = P64[R1 + 63];
           _sa8j3::P64 = P64[R1 + 71];
           _sa8j6::P64 = P64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 48] = _sa8iW::P64;
           P64[Sp - 40] = _sa8iY::P64;
           P64[Sp - 32] = _sa8j0::P64;
           P64[Sp - 24] = _sa8j2::P64;
           P64[Sp - 16] = _sa8j3::P64;
           P64[Sp - 8] = _sa8j6::P64;
           P64[Sp] = _sa8iU::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uacwN; else goto cacsV;
       uacwN: // global
           call _cacsU(R1) args: 0, res: 0, upd: 0;
       cacsV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uacxa_srtd" {
     uacxa_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 _cacsU() //  [R1]
         { info_tbl: [(cacsU,
                       label: block_cacsU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacsU: // global
           _cacwr::P64 = R1 & 7;
           if (_cacwr::P64 < 4) goto uacwF; else goto uacwH;
       uacwF: // global
           if (_cacwr::P64 < 3) goto uacwG; else goto cacv5;
       uacwG: // global
           if (_cacwr::P64 < 2) goto cacuZ; else goto cacv2;
       cacuZ: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cacv2: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cacv5: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uacwH: // global
           if (_cacwr::P64 < 6) goto cacuT; else goto cacv7;
       cacuT: // global
           I64[Sp + 48] = block_cacuO_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       cacv7: // global
           _sa8jl::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cact3_info;
           R1 = _sa8jl::P64;
           if (R1 & 7 != 0) goto uacwO; else goto cact4;
       uacwO: // global
           call _cact3(R1) args: 0, res: 0, upd: 0;
       cact4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacuO() //  [R1]
         { info_tbl: [(cacuO,
                       label: block_cacuO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacuO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacuW; else goto cacuV;
       cacuW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacuV: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cact3() //  [R1]
         { info_tbl: [(cact3,
                       label: block_cact3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cact3: // global
           I64[Sp] = block_cact8_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uacwP; else goto cact9;
       uacwP: // global
           call _cact8(R1) args: 0, res: 0, upd: 0;
       cact9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cact8() //  [R1]
         { info_tbl: [(cact8,
                       label: block_cact8_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cact8: // global
           if (R1 & 7 == 1) goto cacvb; else goto cacwn;
       cacvb: // global
           _sa8jw::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cactd_info;
           R1 = _sa8jw::P64;
           if (R1 & 7 != 0) goto uacwQ; else goto cacte;
       uacwQ: // global
           call _cactd(R1) args: 0, res: 0, upd: 0;
       cacte: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cacwn: // global
           I64[Sp + 48] = block_cacwj_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cactd() //  [R1]
         { info_tbl: [(cactd,
                       label: block_cactd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cactd: // global
           I64[Sp - 16] = block_cactG_info;
           _sa8jC::I64 = I64[R1 + 39];
           _sa8jD::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa8jD::I64;
           I64[Sp] = _sa8jC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uacwR; else goto cactH;
       uacwR: // global
           call _cactG(R1) args: 0, res: 0, upd: 0;
       cactH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cactG() //  [R1]
         { info_tbl: [(cactG,
                       label: block_cactG_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cactG: // global
           if (R1 & 7 == 1) goto cacwc; else goto uacwI;
       cacwc: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto uacwJ; else goto cacvy;
       uacwJ: // global
           Sp = Sp + 24;
           goto uacwU;
       cacvy: // global
           _sa8ka::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp + 16] = block_cactO_info;
           R1 = _sa8ka::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uacwS; else goto cactP;
       uacwS: // global
           call _cactO(R1) args: 0, res: 0, upd: 0;
       cactP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uacwI: // global
           Sp = Sp + 24;
           goto uacwU;
       uacwU: // global
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 _cactO() //  [R1]
         { info_tbl: [(cactO,
                       label: block_cactO_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cactO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacvB; else goto cacvA;
       cacvB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacvA: // global
           _sa8j3::P64 = P64[Sp + 40];
           _sa8kc::P64 = P64[R1 + 7];
           _sa8kd::P64 = P64[R1 + 15];
           _sa8kg::P64 = P64[_sa8j3::P64 + 8];
           I64[Hp - 16] = sat_sa8ko_info;
           P64[Hp] = _sa8kg::P64;
           call MO_WriteBarrier();
           P64[_sa8j3::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j3::P64);
           I64[Sp - 8] = block_cacud_info;
           R1 = _sa8kg::P64;
           P64[Sp] = _sa8kd::P64;
           P64[Sp + 32] = _sa8kc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uacwV; else goto cacue;
       uacwV: // global
           call _cacud(R1) args: 0, res: 0, upd: 0;
       cacue: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacud() //  [R1]
         { info_tbl: [(cacud,
                       label: block_cacud_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacud: // global
           _sa8kx::I64 = I64[R1 + 39];
           if (_sa8kx::I64 != 0) goto cacvE; else goto cacw9;
       cacvE: // global
           I64[Sp - 24] = block_cacuk_info;
           _sa8ks::P64 = P64[R1 + 7];
           _sa8kt::P64 = P64[R1 + 15];
           _sa8kr::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           P64[Sp - 16] = _sa8kt::P64;
           I64[Sp - 8] = _sa8kx::I64;
           P64[Sp] = _sa8ks::P64;
           I64[Sp + 56] = _sa8kr::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacwW; else goto cacul;
       uacwW: // global
           call _cacuk(R1) args: 0, res: 0, upd: 0;
       cacul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cacw9: // global
           _sa8j0::P64 = P64[Sp + 32];
           _sa8kd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = _sa8kd::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 16;
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 _cacuk() //  [R1]
         { info_tbl: [(cacuk,
                       label: block_cacuk_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacuk: // global
           if (R1 & 7 == 1) goto cacvG; else goto cacvY;
       cacvG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cacvJ; else goto cacvI;
       cacvJ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacvI: // global
           I64[Hp - 24] = sat_sa8kH_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sa8j0::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 40;
           call _sa8jE() args: 0, res: 0, upd: 0;
       cacvY: // global
           I64[Sp] = block_cacvM_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uacwY; else goto cacvN;
       uacwY: // global
           call _cacvM(R1) args: 0, res: 0, upd: 0;
       cacvN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacvM() //  [R1]
         { info_tbl: [(cacvM,
                       label: block_cacvM_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacvM: // global
           I64[Sp - 8] = block_cacvR_info;
           R2 = P64[Sp + 64];
           _sa8kL::P64 = P64[R1 + 7];
           _sa8kM::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa8kM::P64;
           P64[Sp + 64] = _sa8kL::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacvR() //  [R1]
         { info_tbl: [(cacvR,
                       label: block_cacvR_info
                       rep:StackRep [False, False, True, False, False, False, False,
                                     False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacvR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cacw2; else goto cacw1;
       cacw2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacw1: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sa8kd::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cacvU_info;
           R5 = Hp - 47;
           R4 = _sa8kd::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 72];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacvU() //  [R1]
         { info_tbl: [(cacvU,
                       label: block_cacvU_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacvU: // global
           I64[Sp] = block_cacvW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacx1; else goto cacw4;
       uacx1: // global
           call _cacvW(R1) args: 0, res: 0, upd: 0;
       cacw4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacvW() //  [R1]
         { info_tbl: [(cacvW,
                       label: block_cacvW_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacvW: // global
           _sa8j0::P64 = P64[Sp + 24];
           _sa8kY::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = _sa8kY::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 8;
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 _sa8jE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sa8jE: // global
           I64[Sp - 8] = block_cactn_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cactn() //  [R1]
         { info_tbl: [(cactn,
                       label: block_cactn_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cactn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacvr; else goto cacvq;
       cacvr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacvq: // global
           _sa8j3::P64 = P64[Sp + 40];
           _sa8jL::P64 = P64[_sa8j3::P64 + 8];
           I64[Hp - 16] = sat_sa8jT_info;
           P64[Hp] = _sa8jL::P64;
           _sa8iW::P64 = P64[Sp + 8];
           _sa8iY::P64 = P64[Sp + 16];
           _sa8j0::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa8j3::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j3::P64);
           I64[Sp + 16] = block_cacvg_info;
           R2 = _sa8iW::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa8iY::P64;
           P64[Sp + 8] = P64[_sa8j0::P64 + 8];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.emptyWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cacvg() //  [R1]
         { info_tbl: [(cacvg,
                       label: block_cacvg_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacvg: // global
           _sa8iQ::P64 = P64[Sp + 48];
           _sa8iU::P64 = P64[Sp + 40];
           _sa8j0::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           I64[Sp + 32] = block_cacvl_info;
           R2 = _sa8iU::P64;
           R1 = _sa8iQ::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacvl() //  [R1]
         { info_tbl: [(cacvl,
                       label: block_cacvl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacvl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacvv; else goto cacvu;
       cacvv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacvu: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cacwj() //  [R1]
         { info_tbl: [(cacwj,
                       label: block_cacwj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacwj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacwq; else goto cacwp;
       cacwq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacwp: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uacxb_srtd" {
     uacxb_srtd:
         const Sa8nI_srt+104;
         const 62;
         const 3891391553024819201;
 },
 GHC.IO.Handle.Internals.$wwantWritableHandle'_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cacx3,
                       label: GHC.IO.Handle.Internals.$wwantWritableHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacx3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacx7; else goto cacx6;
       cacx7: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacx6: // global
           I64[Hp - 8] = sat_sa8l6_info;
           P64[Hp] = R5;
           R5 = Hp - 6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.560565587 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle1_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle1_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(caczD,
                       label: GHC.IO.Handle.Internals.wantWritableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caczD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caczE; else goto caczF;
       caczE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantWritableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caczF: // global
           I64[Sp - 24] = block_caczw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaczM; else goto caczx;
       uaczM: // global
           call _caczw(R1) args: 0, res: 0, upd: 0;
       caczx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caczw() //  [R1]
         { info_tbl: [(caczw,
                       label: block_caczw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caczw: // global
           _sa8l7::P64 = P64[Sp + 8];
           _sa8l9::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto caczA; else goto caczB;
       caczA: // global
           R5 = _sa8l9::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = _sa8l7::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       caczB: // global
           R5 = _sa8l9::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = _sa8l7::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.567069407 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(cacA2,
                       label: GHC.IO.Handle.Internals.wantWritableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacA2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.571465544 UTC

[section ""data" . withHandle2_ra7PH_closure" {
     withHandle2_ra7PH_closure:
         const withHandle2_ra7PH_info;
         const 0;
 },
 io_sa8lr_entry() //  [R1]
         { info_tbl: [(cacAu,
                       label: io_sa8lr_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacAy; else goto cacAz;
       cacAy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacAz: // global
           I64[Sp - 16] = block_cacAp_info;
           _sa8ln::P64 = P64[R1 + 31];
           R5 = _sa8ln::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8ln::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacAp() //  [R1]
         { info_tbl: [(cacAp,
                       label: block_cacAp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAp: // global
           I64[Sp] = block_cacAr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacAE; else goto cacAs;
       uacAE: // global
           call _cacAr(R1) args: 0, res: 0, upd: 0;
       cacAs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacAr() //  [R1]
         { info_tbl: [(cacAr,
                       label: block_cacAr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAr: // global
           I64[Sp] = block_cacAx_info;
           R2 = P64[R1 + 7];
           _sa8ly::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8ly::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacAx() //  []
         { info_tbl: [(cacAx,
                       label: block_cacAx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8lH_entry() //  [R1]
         { info_tbl: [(cacAT,
                       label: io_sa8lH_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacAX; else goto cacAY;
       cacAX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacAY: // global
           I64[Sp - 16] = block_cacAO_info;
           _sa8lC::P64 = P64[R1 + 31];
           R5 = _sa8lC::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8lC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacAO() //  [R1]
         { info_tbl: [(cacAO,
                       label: block_cacAO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAO: // global
           I64[Sp] = block_cacAQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacB3; else goto cacAR;
       uacB3: // global
           call _cacAQ(R1) args: 0, res: 0, upd: 0;
       cacAR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacAQ() //  [R1]
         { info_tbl: [(cacAQ,
                       label: block_cacAQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAQ: // global
           I64[Sp] = block_cacAW_info;
           R2 = P64[R1 + 7];
           _sa8lO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8lO::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacAW() //  []
         { info_tbl: [(cacAW,
                       label: block_cacAW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 withHandle2_ra7PH_entry() //  [R2, R3, R4]
         { info_tbl: [(cacB8,
                       label: withHandle2_ra7PH_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacB8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacB9; else goto cacBa;
       cacB9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle2_ra7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacBa: // global
           I64[Sp - 24] = block_cacAd_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacBr; else goto cacAe;
       uacBr: // global
           call _cacAd(R1) args: 0, res: 0, upd: 0;
       cacAe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacAd() //  [R1]
         { info_tbl: [(cacAd,
                       label: block_cacAd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAd: // global
           if (R1 & 7 == 1) goto cacB5; else goto cacB6;
       cacB5: // global
           I64[Sp - 16] = block_cacAi_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacB6: // global
           I64[Sp - 16] = block_cacAH_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cacAi() //  [R1]
         { info_tbl: [(cacAi,
                       label: block_cacAi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacBe; else goto cacBd;
       cacBe: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacBd: // global
           I64[Hp - 32] = io_sa8lr_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacAk::P64 = Hp - 31;
           if (R1 == 0) goto cacBi; else goto cacBh;
       cacBi: // global
           R1 = _cacAk::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacBh: // global
           R1 = _cacAk::P64;
           Sp = Sp + 40;
           call io_sa8lr_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cacAH() //  [R1]
         { info_tbl: [(cacAH,
                       label: block_cacAH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacAH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacBm; else goto cacBl;
       cacBm: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacBl: // global
           I64[Hp - 32] = io_sa8lH_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacAJ::P64 = Hp - 31;
           if (R1 == 0) goto cacBq; else goto cacBp;
       cacBq: // global
           R1 = _cacAJ::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacBp: // global
           R1 = _cacAJ::P64;
           Sp = Sp + 40;
           call io_sa8lH_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.595516813 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_closure" {
     GHC.IO.Handle.Internals.withHandle_closure:
         const GHC.IO.Handle.Internals.withHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(cacCr,
                       label: GHC.IO.Handle.Internals.withHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacCr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle2_ra7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.600412358 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle1_info;
         const 0;
 },
 sat_sa8m3_entry() //  [R1, R2]
         { info_tbl: [(cacCT,
                       label: sat_sa8m3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacCT: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8m1_entry() //  [R1]
         { info_tbl: [(cacD1,
                       label: io_sa8m1_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacD1: // global
           _sa8m1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacD5; else goto cacD6;
       cacD6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacD8; else goto cacD7;
       cacD8: // global
           HpAlloc = 16;
           goto cacD5;
       cacD5: // global
           R1 = _sa8m1::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacD7: // global
           _sa8lR::P64 = P64[_sa8m1::P64 + 7];
           _sa8lT::P64 = P64[_sa8m1::P64 + 15];
           _sa8lV::P64 = P64[_sa8m1::P64 + 23];
           _sa8lX::P64 = P64[_sa8m1::P64 + 31];
           I64[Hp - 8] = sat_sa8m3_info;
           P64[Hp] = _sa8lT::P64;
           I64[Sp - 16] = block_cacCW_info;
           R5 = _sa8lX::P64;
           R4 = Hp - 6;
           R3 = _sa8lV::P64;
           R2 = _sa8lR::P64;
           P64[Sp - 8] = _sa8lX::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacCW() //  [R1]
         { info_tbl: [(cacCW,
                       label: block_cacCW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacCW: // global
           I64[Sp] = block_cacCY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacDd; else goto cacCZ;
       uacDd: // global
           call _cacCY(R1) args: 0, res: 0, upd: 0;
       cacCZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacCY() //  [R1]
         { info_tbl: [(cacCY,
                       label: block_cacCY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacCY: // global
           I64[Sp] = block_cacD4_info;
           R2 = P64[R1 + 7];
           _sa8m9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8m9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacD4() //  []
         { info_tbl: [(cacD4,
                       label: block_cacD4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacD4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa8mk_entry() //  [R1, R2]
         { info_tbl: [(cacDs,
                       label: sat_sa8mk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacDs: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8mi_entry() //  [R1]
         { info_tbl: [(cacDA,
                       label: io_sa8mi_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacDA: // global
           _sa8mi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacDE; else goto cacDF;
       cacDF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacDH; else goto cacDG;
       cacDH: // global
           HpAlloc = 16;
           goto cacDE;
       cacDE: // global
           R1 = _sa8mi::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacDG: // global
           _sa8lR::P64 = P64[_sa8mi::P64 + 7];
           _sa8lT::P64 = P64[_sa8mi::P64 + 15];
           _sa8lV::P64 = P64[_sa8mi::P64 + 23];
           _sa8md::P64 = P64[_sa8mi::P64 + 31];
           I64[Hp - 8] = sat_sa8mk_info;
           P64[Hp] = _sa8lT::P64;
           I64[Sp - 16] = block_cacDv_info;
           R5 = _sa8md::P64;
           R4 = Hp - 6;
           R3 = _sa8lV::P64;
           R2 = _sa8lR::P64;
           P64[Sp - 8] = _sa8md::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cacDv() //  [R1]
         { info_tbl: [(cacDv,
                       label: block_cacDv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacDv: // global
           I64[Sp] = block_cacDx_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacDM; else goto cacDy;
       uacDM: // global
           call _cacDx(R1) args: 0, res: 0, upd: 0;
       cacDy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacDx() //  [R1]
         { info_tbl: [(cacDx,
                       label: block_cacDx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacDx: // global
           I64[Sp] = block_cacDD_info;
           R2 = P64[R1 + 7];
           _sa8mq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8mq::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacDD() //  []
         { info_tbl: [(cacDD,
                       label: block_cacDD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacDD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cacDR,
                       label: GHC.IO.Handle.Internals.wantReadableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacDR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacDS; else goto cacDT;
       cacDS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacDT: // global
           I64[Sp - 24] = block_cacCC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacEa; else goto cacCD;
       uacEa: // global
           call _cacCC(R1) args: 0, res: 0, upd: 0;
       cacCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacCC() //  [R1]
         { info_tbl: [(cacCC,
                       label: block_cacCC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacCC: // global
           if (R1 & 7 == 1) goto cacDO; else goto cacDP;
       cacDO: // global
           I64[Sp - 16] = block_cacCH_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacDP: // global
           I64[Sp - 16] = block_cacDg_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cacCH() //  [R1]
         { info_tbl: [(cacCH,
                       label: block_cacCH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacCH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacDX; else goto cacDW;
       cacDX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacDW: // global
           I64[Hp - 32] = io_sa8m1_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacCJ::P64 = Hp - 31;
           if (R1 == 0) goto cacE1; else goto cacE0;
       cacE1: // global
           R1 = _cacCJ::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacE0: // global
           R1 = _cacCJ::P64;
           Sp = Sp + 40;
           call io_sa8m1_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cacDg() //  [R1]
         { info_tbl: [(cacDg,
                       label: block_cacDg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacDg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacE5; else goto cacE4;
       cacE5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacE4: // global
           I64[Hp - 32] = io_sa8mi_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacDi::P64 = Hp - 31;
           if (R1 == 0) goto cacE9; else goto cacE8;
       cacE9: // global
           R1 = _cacDi::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacE8: // global
           R1 = _cacDi::P64;
           Sp = Sp + 40;
           call io_sa8mi_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.627922705 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(cacFg,
                       label: GHC.IO.Handle.Internals.wantReadableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacFg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:08.632030625 UTC

[section ""relreadonly" . Sa8nI_srt" {
     Sa8nI_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle12_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const ioe_closedHandle2_ra7Pb_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle8_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const ioe_semiclosedHandle2_ra7Pc_closure;
         const GHC.IO.Handle.Internals.hLookAhead_3_closure;
         const ioe_EOF2_ra7Pd_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle4_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle3_closure;
         const ioe_notReadable2_ra7Pe_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle3_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle2_closure;
         const ioe_notWritable2_ra7Pf_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle4_closure;
         const GHC.IO.Handle.Internals.flushBuffer4_closure;
         const lvl1_ra7Ph_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const lvl6_ra7Pm_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf1_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.Err.error_closure;
         const lvl19_ra7Pz_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer1_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer3_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
         const lvl22_ra7PC_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.noCharBuffer_closure;
         const GHC.IO.Handle.Internals.noByteBuffer_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkFileHandle1_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const $wlvl_ra7PF_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.Internals.withHandle_1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.Internals.withHandle__'1_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.withHandle1_closure;
         const GHC.IO.Handle.Internals.withHandle_'1_closure;
         const withHandle_2_ra7PG_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const withHandle2_ra7PH_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.228115258 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:15.230289975 UTC

[section ""data" . GHC.IO.Handle.Internals.augmentIOError_closure" {
     GHC.IO.Handle.Internals.augmentIOError_closure:
         const GHC.IO.Handle.Internals.augmentIOError_info;
 },
 sat_sacFH_entry() //  [R1]
         { info_tbl: [(cadcs,
                       label: sat_sacFH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadcs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cadct; else goto cadcu;
       cadct: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadcu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cadcl_info;
           _sacFq::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sacFq::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uadcV; else goto cadcm;
       uadcV: // global
           call _cadcl(R1) args: 0, res: 0, upd: 0;
       cadcm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadcl() //  [R1]
         { info_tbl: [(cadcl,
                       label: block_cadcl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadcl: // global
           if (R1 & 7 == 1) goto cadcp; else goto cadcq;
       cadcp: // global
           _sacFq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadcx_info;
           R1 = _sacFq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uadcU; else goto cadcz;
       uadcU: // global
           call _cadcx(R1) args: 0, res: 0, upd: 0;
       cadcz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cadcq: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cadcx() //  [R1]
         { info_tbl: [(cadcx,
                       label: block_cadcx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadcx: // global
           if (R1 & 7 == 1) goto cadcF; else goto cadcM;
       cadcF: // global
           Hp = Hp + 16;
           _sacFA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cadcP; else goto cadcH;
       cadcH: // global
           _sacFB::P64 = P64[_sacFA::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sacFB::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cadcM: // global
           Hp = Hp + 16;
           _sacFA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cadcP; else goto cadcO;
       cadcP: // global
           HpAlloc = 16;
           R1 = _sacFA::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadcO: // global
           _sacFD::P64 = P64[_sacFA::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sacFD::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.augmentIOError_entry() //  [R2, R3, R4]
         { info_tbl: [(cadcW,
                       label: GHC.IO.Handle.Internals.augmentIOError_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadcW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadcZ; else goto cadd0;
       cadcZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.augmentIOError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cadd0: // global
           I64[Sp - 24] = block_cadcc_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadd4; else goto cadcd;
       uadd4: // global
           call _cadcc(R1) args: 0, res: 0, upd: 0;
       cadcd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadcc() //  [R1]
         { info_tbl: [(cadcc,
                       label: block_cadcc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadcc: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cadd3; else goto cadd2;
       cadd3: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadd2: // global
           _sacFt::P64 = P64[R1 + 15];
           _sacFv::P64 = P64[R1 + 31];
           _sacFw::P64 = P64[R1 + 39];
           _sacFx::P64 = P64[R1 + 47];
           I64[Hp - 96] = sat_sacFH_info;
           _sacFq::P64 = P64[Sp + 16];
           P64[Hp - 80] = _sacFq::P64;
           P64[Hp - 72] = _sacFx::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sacFq::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sacFt::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sacFv::P64;
           P64[Hp - 8] = _sacFw::P64;
           P64[Hp] = Hp - 96;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.242821343 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle14_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle14_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.244776898 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle13_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle13_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle13_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle13_entry() //  [R1]
         { info_tbl: [(caddS,
                       label: GHC.IO.Handle.Internals.wantReadableHandle13_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caddS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caddT; else goto caddU;
       caddT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caddU: // global
           (_caddP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caddP::I64 == 0) goto caddR; else goto caddQ;
       caddR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caddQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caddP::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle14_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.248776425 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle12_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle12_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle13_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.25081842 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle11_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle11_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle11_entry() //  [R1]
         { info_tbl: [(cadea,
                       label: GHC.IO.Handle.Internals.wantReadableHandle11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadea: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadeb; else goto cadec;
       cadeb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadec: // global
           (_cade7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cade7::I64 == 0) goto cade9; else goto cade8;
       cade9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cade8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cade7::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle12_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.254752058 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle1_entry() //  []
         { info_tbl: [(cadeq,
                       label: GHC.IO.Handle.Internals.ioe_closedHandle1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadeq: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.258159229 UTC

[section ""data" . ioe_closedHandle2_ra7Pb_closure" {
     ioe_closedHandle2_ra7Pb_closure:
         const ioe_closedHandle2_ra7Pb_info;
         const 0;
 },
 ioe_closedHandle2_ra7Pb_entry() //  []
         { info_tbl: [(cadeB,
                       label: ioe_closedHandle2_ra7Pb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadeB: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.261539387 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle_entry() //  []
         { info_tbl: [(cadeM,
                       label: GHC.IO.Handle.Internals.ioe_closedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadeM: // global
           call ioe_closedHandle2_ra7Pb_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.265964368 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle10_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle10_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.267770492 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle9_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle9_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle9_entry() //  [R1]
         { info_tbl: [(cadf0,
                       label: GHC.IO.Handle.Internals.wantReadableHandle9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadf0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadf1; else goto cadf2;
       cadf1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadf2: // global
           (_cadeX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadeX::I64 == 0) goto cadeZ; else goto cadeY;
       cadeZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadeY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadeX::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.271807371 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle8_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle9_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.273806997 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle7_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle7_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle7_entry() //  [R1]
         { info_tbl: [(cadfi,
                       label: GHC.IO.Handle.Internals.wantReadableHandle7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadfi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadfj; else goto cadfk;
       cadfj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadfk: // global
           (_cadff::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadff::I64 == 0) goto cadfh; else goto cadfg;
       cadfh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadfg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadff::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.278230249 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() //  []
         { info_tbl: [(cadfx,
                       label: GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadfx: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.281570485 UTC

[section ""data" . ioe_semiclosedHandle2_ra7Pc_closure" {
     ioe_semiclosedHandle2_ra7Pc_closure:
         const ioe_semiclosedHandle2_ra7Pc_info;
         const 0;
 },
 ioe_semiclosedHandle2_ra7Pc_entry() //  []
         { info_tbl: [(cadfI,
                       label: ioe_semiclosedHandle2_ra7Pc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadfI: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.284867978 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle_entry() //  []
         { info_tbl: [(cadfT,
                       label: GHC.IO.Handle.Internals.ioe_semiclosedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadfT: // global
           call ioe_semiclosedHandle2_ra7Pc_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.2880545 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_4_closure" {
     GHC.IO.Handle.Internals.hLookAhead_4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.290464572 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_3_closure" {
     GHC.IO.Handle.Internals.hLookAhead_3_closure:
         const GHC.IO.Handle.Internals.hLookAhead_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_3_entry() //  [R1]
         { info_tbl: [(cadg7,
                       label: GHC.IO.Handle.Internals.hLookAhead_3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadg7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadg8; else goto cadg9;
       cadg8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadg9: // global
           (_cadg4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadg4::I64 == 0) goto cadg6; else goto cadg5;
       cadg6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadg5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadg4::I64;
           R2 = GHC.IO.Handle.Internals.hLookAhead_4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.295064691 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF1_closure" {
     GHC.IO.Handle.Internals.ioe_EOF1_closure:
         const GHC.IO.Handle.Internals.ioe_EOF1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF1_entry() //  []
         { info_tbl: [(cadgm,
                       label: GHC.IO.Handle.Internals.ioe_EOF1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadgm: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.298464867 UTC

[section ""data" . ioe_EOF2_ra7Pd_closure" {
     ioe_EOF2_ra7Pd_closure:
         const ioe_EOF2_ra7Pd_info;
         const 0;
 },
 ioe_EOF2_ra7Pd_entry() //  []
         { info_tbl: [(cadgx,
                       label: ioe_EOF2_ra7Pd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadgx: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.302153016 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF_closure" {
     GHC.IO.Handle.Internals.ioe_EOF_closure:
         const GHC.IO.Handle.Internals.ioe_EOF_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF_entry() //  []
         { info_tbl: [(cadgI,
                       label: GHC.IO.Handle.Internals.ioe_EOF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadgI: // global
           call ioe_EOF2_ra7Pd_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.305234448 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,114,101,97,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.307111997 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle5_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle5_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle5_entry() //  [R1]
         { info_tbl: [(cadgW,
                       label: GHC.IO.Handle.Internals.wantReadableHandle5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadgW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadgX; else goto cadgY;
       cadgX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadgY: // global
           (_cadgT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadgT::I64 == 0) goto cadgV; else goto cadgU;
       cadgV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadgU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadgT::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.31150797 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle4_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.313582554 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle3_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle3_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle3_entry() //  [R1]
         { info_tbl: [(cadhe,
                       label: GHC.IO.Handle.Internals.wantReadableHandle3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadhe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadhf; else goto cadhg;
       cadhf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadhg: // global
           (_cadhb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadhb::I64 == 0) goto cadhd; else goto cadhc;
       cadhd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadhc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadhb::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.317697863 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable1_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable1_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable1_entry() //  []
         { info_tbl: [(cadht,
                       label: GHC.IO.Handle.Internals.ioe_notReadable1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadht: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.321020742 UTC

[section ""data" . ioe_notReadable2_ra7Pe_closure" {
     ioe_notReadable2_ra7Pe_closure:
         const ioe_notReadable2_ra7Pe_info;
         const 0;
 },
 ioe_notReadable2_ra7Pe_entry() //  []
         { info_tbl: [(cadhE,
                       label: ioe_notReadable2_ra7Pe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadhE: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.324284729 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable_entry() //  []
         { info_tbl: [(cadhP,
                       label: GHC.IO.Handle.Internals.ioe_notReadable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadhP: // global
           call ioe_notReadable2_ra7Pe_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.32806309 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantWritableHandle5_bytes" {
     GHC.IO.Handle.Internals.wantWritableHandle5_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,119,114,105,116,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.330384008 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle4_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle4_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle4_entry() //  [R1]
         { info_tbl: [(cadi3,
                       label: GHC.IO.Handle.Internals.wantWritableHandle4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadi3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadi4; else goto cadi5;
       cadi4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadi5: // global
           (_cadi0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadi0::I64 == 0) goto cadi2; else goto cadi1;
       cadi2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadi1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadi0::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.334376055 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle3_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantWritableHandle4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.336353671 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle2_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle2_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle2_entry() //  [R1]
         { info_tbl: [(cadil,
                       label: GHC.IO.Handle.Internals.wantWritableHandle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadil: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadim; else goto cadin;
       cadim: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadin: // global
           (_cadii::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadii::I64 == 0) goto cadik; else goto cadij;
       cadik: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadij: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadii::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.340507384 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable1_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable1_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable1_entry() //  []
         { info_tbl: [(cadiA,
                       label: GHC.IO.Handle.Internals.ioe_notWritable1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadiA: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.344885761 UTC

[section ""data" . ioe_notWritable2_ra7Pf_closure" {
     ioe_notWritable2_ra7Pf_closure:
         const ioe_notWritable2_ra7Pf_info;
         const 0;
 },
 ioe_notWritable2_ra7Pf_entry() //  []
         { info_tbl: [(cadiL,
                       label: ioe_notWritable2_ra7Pf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadiL: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.348242218 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable_entry() //  []
         { info_tbl: [(cadiW,
                       label: GHC.IO.Handle.Internals.ioe_notWritable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadiW: // global
           call ioe_notWritable2_ra7Pf_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.351385943 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantSeekableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantSeekableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.353444681 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle5_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle5_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle5_entry() //  [R1]
         { info_tbl: [(cadja,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadja: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadjb; else goto cadjc;
       cadjb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadjc: // global
           (_cadj7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadj7::I64 == 0) goto cadj9; else goto cadj8;
       cadj9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadj8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadj7::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.358007939 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle4_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.360155318 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle3_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle3_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle3_entry() //  [R1]
         { info_tbl: [(cadjs,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadjs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadjt; else goto cadju;
       cadjt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadju: // global
           (_cadjp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadjp::I64 == 0) goto cadjr; else goto cadjq;
       cadjr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadjq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadjp::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.364170302 UTC

[section ""cstring" . GHC.IO.Handle.Internals.flushBuffer6_bytes" {
     GHC.IO.Handle.Internals.flushBuffer6_bytes:
         I8[] [99,97,110,110,111,116,32,102,108,117,115,104,32,116,104,101,32,114,101,97,100,32,98,117,102,102,101,114,58,32,117,110,100,101,114,108,121,105,110,103,32,100,101,118,105,99,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.366168536 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer5_closure" {
     GHC.IO.Handle.Internals.flushBuffer5_closure:
         const GHC.IO.Handle.Internals.flushBuffer5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer5_entry() //  [R1]
         { info_tbl: [(cadjK,
                       label: GHC.IO.Handle.Internals.flushBuffer5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadjK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadjL; else goto cadjM;
       cadjL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadjM: // global
           (_cadjH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadjH::I64 == 0) goto cadjJ; else goto cadjI;
       cadjJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadjI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadjH::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.370693497 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer4_closure" {
     GHC.IO.Handle.Internals.flushBuffer4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.flushBuffer5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.372732503 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer3_closure" {
     GHC.IO.Handle.Internals.flushBuffer3_closure:
         const GHC.IO.Handle.Internals.flushBuffer3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer3_entry() //  [R1]
         { info_tbl: [(cadk2,
                       label: GHC.IO.Handle.Internals.flushBuffer3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadk2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadk3; else goto cadk4;
       cadk3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadk4: // global
           (_cadjZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadjZ::I64 == 0) goto cadk1; else goto cadk0;
       cadk1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadk0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadjZ::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.376706699 UTC

[section ""cstring" . lvl_ra7Pg_bytes" {
     lvl_ra7Pg_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.378950494 UTC

[section ""data" . lvl1_ra7Ph_closure" {
     lvl1_ra7Ph_closure:
         const lvl1_ra7Ph_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra7Ph_entry() //  [R1]
         { info_tbl: [(cadkk,
                       label: lvl1_ra7Ph_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadkk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadkl; else goto cadkm;
       cadkl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadkm: // global
           (_cadkh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadkh::I64 == 0) goto cadkj; else goto cadki;
       cadkj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadki: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadkh::I64;
           R2 = lvl_ra7Pg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.382760525 UTC

[section ""cstring" . lvl2_ra7Pi_bytes" {
     lvl2_ra7Pi_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.385137755 UTC

[section ""data" . GHC.IO.Handle.Internals.$wioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.$wioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.$wioe_bufsiz_info;
         const 0;
 },
 sat_sacFX_entry() //  [R1]
         { info_tbl: [(cadkP,
                       label: sat_sacFX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadkP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadkQ; else goto cadkR;
       cadkQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadkR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadkM_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cadkM() //  [R1, R2]
         { info_tbl: [(cadkM,
                       label: block_cadkM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadkM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadkU; else goto cadkT;
       cadkU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cadkT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacFY_entry() //  [R1]
         { info_tbl: [(cadkV,
                       label: sat_sacFY_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadkV: // global
           _sacFY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cadkW; else goto cadkX;
       cadkX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadkZ; else goto cadkY;
       cadkZ: // global
           HpAlloc = 24;
           goto cadkW;
       cadkW: // global
           R1 = _sacFY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadkY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sacFY::P64;
           _sacFS::I64 = I64[_sacFY::P64 + 16];
           I64[Hp - 16] = sat_sacFX_info;
           I64[Hp] = _sacFS::I64;
           R3 = Hp - 16;
           R2 = lvl2_ra7Pi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacG0_entry() //  [R1]
         { info_tbl: [(cadl1,
                       label: sat_sacG0_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadl1: // global
           _sacG0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cadl2; else goto cadl3;
       cadl3: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadl5; else goto cadl4;
       cadl5: // global
           HpAlloc = 80;
           goto cadl2;
       cadl2: // global
           R1 = _sacG0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadl4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sacG0::P64;
           _sacFS::I64 = I64[_sacG0::P64 + 16];
           I64[Hp - 72] = sat_sacFY_info;
           I64[Hp - 56] = _sacFS::I64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = lvl1_ra7Ph_closure;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.$wioe_bufsiz_entry() //  [R2]
         { info_tbl: [(cadl6,
                       label: GHC.IO.Handle.Internals.$wioe_bufsiz_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadl6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadla; else goto cadl9;
       cadla: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadl9: // global
           I64[Hp - 16] = sat_sacG0_info;
           I64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.398835024 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz1_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz1_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz1_entry() //  [R2]
         { info_tbl: [(cadlW,
                       label: GHC.IO.Handle.Internals.ioe_bufsiz1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadlW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cadlX; else goto cadlY;
       cadlX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadlY: // global
           I64[Sp - 8] = block_cadlT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadm2; else goto cadlU;
       uadm2: // global
           call _cadlT(R1) args: 0, res: 0, upd: 0;
       cadlU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadlT() //  [R1]
         { info_tbl: [(cadlT,
                       label: block_cadlT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadlT: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.404150829 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz_entry() //  [R2]
         { info_tbl: [(cadmh,
                       label: GHC.IO.Handle.Internals.ioe_bufsiz_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadmh: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.ioe_bufsiz1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.40878075 UTC

[section ""data" . GHC.IO.Handle.Internals.$wstreamEncode_closure" {
     GHC.IO.Handle.Internals.$wstreamEncode_closure:
         const GHC.IO.Handle.Internals.$wstreamEncode_info;
 },
 GHC.IO.Handle.Internals.$wstreamEncode_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cadmu,
                       label: GHC.IO.Handle.Internals.$wstreamEncode_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadmu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cadmv; else goto cadmw;
       cadmv: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wstreamEncode_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cadmw: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _cadmy() args: 0, res: 0, upd: 0;
     }
 },
 _cadmy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadmy: // global
           I64[Sp - 8] = block_cadmA_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadmA() //  [R1]
         { info_tbl: [(cadmA,
                       label: block_cadmA_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadmA: // global
           I64[Sp] = block_cadmC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadny; else goto cadmF;
       uadny: // global
           call _cadmC(R1) args: 0, res: 0, upd: 0;
       cadmF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadmC() //  [R1]
         { info_tbl: [(cadmC,
                       label: block_cadmC_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadmC: // global
           I64[Sp - 8] = block_cadmJ_info;
           _sacGj::P64 = P64[R1 + 15];
           _sacGk::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp] = _sacGk::P64;
           P64[Sp + 32] = _sacGj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadnz; else goto cadmL;
       uadnz: // global
           call _cadmJ(R1) args: 0, res: 0, upd: 0;
       cadmL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadmJ() //  [R1]
         { info_tbl: [(cadmJ,
                       label: block_cadmJ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadmJ: // global
           if (R1 & 7 == 3) goto cadn4; else goto cadmR;
       cadn4: // global
           I64[Sp] = block_cadmX_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto uadnA; else goto cadmY;
       uadnA: // global
           call _cadmX(R1) args: 0, res: 0, upd: 0;
       cadmY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cadmR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadmU; else goto cadmT;
       cadmU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadmT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadmX() //  [R1]
         { info_tbl: [(cadmX,
                       label: block_cadmX_info
                       rep:StackRep [False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadmX: // global
           I64[Sp] = block_cadn2_info;
           _sacGs::I64 = I64[R1 + 39];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sacGs::I64;
           if (R1 & 7 != 0) goto uadnB; else goto cadn6;
       uadnB: // global
           call _cadn2(R1) args: 0, res: 0, upd: 0;
       cadn6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadn2() //  [R1]
         { info_tbl: [(cadn2,
                       label: block_cadn2_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadn2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadnc; else goto cadnb;
       cadnc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadnb: // global
           _sacGk::P64 = P64[Sp + 8];
           if (I64[Sp + 40] == I64[R1 + 39]) goto cadnn; else goto cadni;
       cadnn: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_cadnk_info;
           R3 = _sacGk::P64;
           R2 = R1;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       cadni: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sacGk::P64;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadnk() //  [R1]
         { info_tbl: [(cadnk,
                       label: block_cadnk_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadnk: // global
           I64[Sp] = block_cadnm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadnC; else goto cadnp;
       uadnC: // global
           call _cadnm(R1) args: 0, res: 0, upd: 0;
       cadnp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadnm() //  [R1]
         { info_tbl: [(cadnm,
                       label: block_cadnm_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadnm: // global
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 8;
           call _cadmy() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.426863268 UTC

[section ""data" . GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure" {
     GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure:
         const GHC.Types.I#_con_info;
         const 2048;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.42897778 UTC

[section ""data" . GHC.IO.Handle.Internals.initBufferState_closure" {
     GHC.IO.Handle.Internals.initBufferState_closure:
         const GHC.IO.Handle.Internals.initBufferState_info;
 },
 GHC.IO.Handle.Internals.initBufferState_entry() //  [R2]
         { info_tbl: [(cadoF,
                       label: GHC.IO.Handle.Internals.initBufferState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadoF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cadoG; else goto cadoH;
       cadoG: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.initBufferState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadoH: // global
           I64[Sp - 8] = block_cadoy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadoO; else goto cadoz;
       uadoO: // global
           call _cadoy(R1) args: 0, res: 0, upd: 0;
       cadoz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadoy() //  [R1]
         { info_tbl: [(cadoy,
                       label: block_cadoy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadoy: // global
           if (R1 & 7 == 3) goto cadoD; else goto cadoC;
       cadoD: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cadoC: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.435400843 UTC

[section ""data" . lvl3_ra7Pj_closure" {
     lvl3_ra7Pj_closure:
         const lvl3_ra7Pj_info;
 },
 lvl3_ra7Pj_entry() //  []
         { info_tbl: [(cadpi,
                       label: lvl3_ra7Pj_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadpi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadpl; else goto cadpm;
       cadpl: // global
           R1 = lvl3_ra7Pj_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cadpm: // global
           I64[Sp - 8] = block_cadp9_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cadp9() //  []
         { info_tbl: [(cadp9,
                       label: block_cadp9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadp9: // global
           I64[Sp] = block_cadpb_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadpb() //  [R1]
         { info_tbl: [(cadpb,
                       label: block_cadpb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadpb: // global
           I64[Sp - 8] = block_cadpd_info;
           _sacGP::P64 = R1;
           R1 = 4;
           P64[Sp] = _sacGP::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadpd() //  [R1]
         { info_tbl: [(cadpd,
                       label: block_cadpd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadpd: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadpr; else goto cadpq;
       cadpr: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadpq: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.444752007 UTC

[section ""data" . GHC.IO.Handle.Internals.noCharBuffer_closure" {
     GHC.IO.Handle.Internals.noCharBuffer_closure:
         const GHC.IO.Handle.Internals.noCharBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noCharBuffer_entry() //  [R1]
         { info_tbl: [(cadq0,
                       label: GHC.IO.Handle.Internals.noCharBuffer_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadq0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadq1; else goto cadq2;
       cadq1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadq2: // global
           (_cadpV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadpV::I64 == 0) goto cadpX; else goto cadpW;
       cadpX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadpW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadpV::I64;
           I64[Sp - 24] = block_cadpY_info;
           Sp = Sp - 24;
           call lvl3_ra7Pj_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cadpY() //  [R1]
         { info_tbl: [(cadpY,
                       label: block_cadpY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadpY: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.450544749 UTC

[section ""data" . lvl4_ra7Pk_closure" {
     lvl4_ra7Pk_closure:
         const lvl4_ra7Pk_info;
 },
 lvl4_ra7Pk_entry() //  []
         { info_tbl: [(cadqv,
                       label: lvl4_ra7Pk_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadqv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadqy; else goto cadqz;
       cadqy: // global
           R1 = lvl4_ra7Pk_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cadqz: // global
           I64[Sp - 8] = block_cadqm_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cadqm() //  []
         { info_tbl: [(cadqm,
                       label: block_cadqm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadqm: // global
           I64[Sp] = block_cadqo_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadqo() //  [R1]
         { info_tbl: [(cadqo,
                       label: block_cadqo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadqo: // global
           I64[Sp - 8] = block_cadqq_info;
           _sacH3::P64 = R1;
           R1 = 1;
           P64[Sp] = _sacH3::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadqq() //  [R1]
         { info_tbl: [(cadqq,
                       label: block_cadqq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadqq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadqE; else goto cadqD;
       cadqE: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadqD: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.45978544 UTC

[section ""data" . GHC.IO.Handle.Internals.noByteBuffer_closure" {
     GHC.IO.Handle.Internals.noByteBuffer_closure:
         const GHC.IO.Handle.Internals.noByteBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noByteBuffer_entry() //  [R1]
         { info_tbl: [(cadrd,
                       label: GHC.IO.Handle.Internals.noByteBuffer_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadrd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadre; else goto cadrf;
       cadre: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadrf: // global
           (_cadr8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadr8::I64 == 0) goto cadra; else goto cadr9;
       cadra: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadr9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadr8::I64;
           I64[Sp - 24] = block_cadrb_info;
           Sp = Sp - 24;
           call lvl4_ra7Pk_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cadrb() //  [R1]
         { info_tbl: [(cadrb,
                       label: block_cadrb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadrb: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.465133846 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule4_bytes" {
     GHC.IO.Handle.Internals.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.467335913 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule3_closure" {
     GHC.IO.Handle.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.469016263 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule2_bytes" {
     GHC.IO.Handle.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.47110377 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule1_closure" {
     GHC.IO.Handle.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.472763716 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule_closure" {
     GHC.IO.Handle.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Internals.$trModule3_closure+1;
         const GHC.IO.Handle.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.474508048 UTC

[section ""cstring" . lvl5_ra7Pl_bytes" {
     lvl5_ra7Pl_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,102,105,110,97,108,105,122,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.47643318 UTC

[section ""data" . lvl6_ra7Pm_closure" {
     lvl6_ra7Pm_closure:
         const lvl6_ra7Pm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra7Pm_entry() //  [R1]
         { info_tbl: [(cadrH,
                       label: lvl6_ra7Pm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadrH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadrI; else goto cadrJ;
       cadrI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadrJ: // global
           (_cadrE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadrE::I64 == 0) goto cadrG; else goto cadrF;
       cadrG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadrF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadrE::I64;
           R2 = lvl5_ra7Pl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.480602707 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_finalizedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_finalizedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_finalizedHandle_entry() //  [R2]
         { info_tbl: [(cadrY,
                       label: GHC.IO.Handle.Internals.ioe_finalizedHandle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadrY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cads2; else goto cads1;
       cads2: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cads1: // global
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = lvl6_ra7Pm_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.485708834 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs1_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs1_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs1_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs1_entry() //  [R2]
         { info_tbl: [(cadsq,
                       label: GHC.IO.Handle.Internals.closeTextCodecs1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadsq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadsr; else goto cadss;
       cadsr: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.closeTextCodecs1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadss: // global
           I64[Sp - 8] = block_cadsn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadtx; else goto cadso;
       uadtx: // global
           call _cadsn(R1) args: 0, res: 0, upd: 0;
       cadso: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadsn() //  [R1]
         { info_tbl: [(cadsn,
                       label: block_cadsn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadsn: // global
           I64[Sp - 8] = block_cadsv_info;
           _sacHt::P64 = P64[R1 + 87];
           R1 = P64[R1 + 95];
           P64[Sp] = _sacHt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadtw; else goto cadsx;
       uadtw: // global
           call _cadsv(R1) args: 0, res: 0, upd: 0;
       cadsx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadsv() //  [R1]
         { info_tbl: [(cadsv,
                       label: block_cadsv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadsv: // global
           if (R1 & 7 == 1) goto cadsE; else goto cadt0;
       cadsE: // global
           _sacHt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadsB_info;
           R1 = _sacHt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uadty; else goto cadsF;
       uadty: // global
           call _cadsB(R1) args: 0, res: 0, upd: 0;
       cadsF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cadt0: // global
           I64[Sp] = block_cadsY_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadtz; else goto cadt1;
       uadtz: // global
           call _cadsY(R1) args: 0, res: 0, upd: 0;
       cadt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadsB() //  [R1]
         { info_tbl: [(cadsB,
                       label: block_cadsB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadsB: // global
           if (R1 & 7 == 1) goto uadtv; else goto cadsQ;
       uadtv: // global
           Sp = Sp + 8;
           call _cadtg() args: 0, res: 0, upd: 0;
       cadsQ: // global
           I64[Sp] = block_cadsO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadtA; else goto cadsR;
       uadtA: // global
           call _cadsO(R1) args: 0, res: 0, upd: 0;
       cadsR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadsO() //  [R1]
         { info_tbl: [(cadsO,
                       label: block_cadsO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadsO: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadsY() //  [R1]
         { info_tbl: [(cadsY,
                       label: block_cadsY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadsY: // global
           I64[Sp] = block_cadt5_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadt5() //  []
         { info_tbl: [(cadt5,
                       label: block_cadt5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadt5: // global
           _sacHt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadt7_info;
           R1 = _sacHt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uadtC; else goto cadta;
       uadtC: // global
           call _cadt7(R1) args: 0, res: 0, upd: 0;
       cadta: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadt7() //  [R1]
         { info_tbl: [(cadt7,
                       label: block_cadt7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadt7: // global
           if (R1 & 7 == 1) goto uadtu; else goto cadtl;
       uadtu: // global
           Sp = Sp + 8;
           call _cadtg() args: 0, res: 0, upd: 0;
       cadtl: // global
           I64[Sp] = block_cadtj_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadtD; else goto cadtm;
       uadtD: // global
           call _cadtj(R1) args: 0, res: 0, upd: 0;
       cadtm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadtg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadtg: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadtj() //  [R1]
         { info_tbl: [(cadtj,
                       label: block_cadtj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadtj: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.504605407 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs_entry() //  [R2]
         { info_tbl: [(caduB,
                       label: GHC.IO.Handle.Internals.closeTextCodecs_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caduB: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.closeTextCodecs1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.509321374 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding1_closure" {
     GHC.IO.Handle.Internals.openTextEncoding1_closure:
         const GHC.IO.Handle.Internals.openTextEncoding1_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding1_entry() //  [R2, R3, R4]
         { info_tbl: [(caduT,
                       label: GHC.IO.Handle.Internals.openTextEncoding1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caduT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caduU; else goto caduV;
       caduU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.openTextEncoding1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caduV: // global
           I64[Sp - 24] = block_caduM_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadwr; else goto caduN;
       uadwr: // global
           call _caduM(R1) args: 0, res: 0, upd: 0;
       caduN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caduM() //  [R1]
         { info_tbl: [(caduM,
                       label: block_caduM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caduM: // global
           if (R1 & 7 == 1) goto caduQ; else goto caduR;
       caduQ: // global
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       caduR: // global
           I64[Sp] = block_cadv1_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadwq; else goto cadv3;
       uadwq: // global
           call _cadv1(R1) args: 0, res: 0, upd: 0;
       cadv3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadv1() //  [R1]
         { info_tbl: [(cadv1,
                       label: block_cadv1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadv1: // global
           I64[Sp - 16] = block_cadv9_info;
           _sacI8::P64 = P64[R1 + 15];
           _sacI9::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _sacI9::P64;
           P64[Sp] = _sacI8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadws; else goto cadvR;
       uadws: // global
           call _cadv9(R1) args: 0, res: 0, upd: 0;
       cadvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadv9() //  [R1]
         { info_tbl: [(cadv9,
                       label: block_cadv9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadv9: // global
           _sacI8::P64 = P64[Sp + 16];
           _cadwg::P64 = R1 & 7;
           if (_cadwg::P64 != 3) goto uadwk; else goto cadw2;
       uadwk: // global
           if (_cadwg::P64 != 6) goto cadvX; else goto cadwb;
       cadvX: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sacIa() args: 0, res: 0, upd: 0;
       cadwb: // global
           I64[Sp] = block_cadw9_info;
           R1 = _sacI8::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cadw2: // global
           I64[Sp] = block_cadw0_info;
           R1 = _sacI8::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadw9() //  [R1]
         { info_tbl: [(cadw9,
                       label: block_cadw9_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadw9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadwf; else goto cadwe;
       cadwf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadwe: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sacIa() args: 0, res: 0, upd: 0;
     }
 },
 _cadw0() //  [R1]
         { info_tbl: [(cadw0,
                       label: block_cadw0_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadw0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadw6; else goto cadw5;
       cadw6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadw5: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sacIa() args: 0, res: 0, upd: 0;
     }
 },
 _sacIa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sacIa: // global
           I64[Sp - 8] = block_cadve_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadww; else goto cadvg;
       uadww: // global
           call _cadve(R1) args: 0, res: 0, upd: 0;
       cadvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadve() //  [R1]
         { info_tbl: [(cadve,
                       label: block_cadve_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadve: // global
           _sacI9::P64 = P64[Sp + 8];
           _cadwj::P64 = R1 & 7;
           if (_cadwj::P64 < 5) goto uadwl; else goto uadwm;
       uadwl: // global
           if (_cadwj::P64 < 4) goto cadvm; else goto cadvt;
       cadvm: // global
           R3 = P64[Sp + 16];
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cadvt: // global
           I64[Sp + 8] = block_cadvp_info;
           R1 = _sacI9::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       uadwm: // global
           if (_cadwj::P64 < 6) goto cadvD; else goto cadvN;
       cadvD: // global
           I64[Sp + 8] = block_cadvz_info;
           R1 = _sacI9::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cadvN: // global
           I64[Sp + 8] = block_cadvJ_info;
           R1 = _sacI9::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadvp() //  [R1]
         { info_tbl: [(cadvp,
                       label: block_cadvp_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadvp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadvw; else goto cadvv;
       cadvw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadvv: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadvz() //  [R1]
         { info_tbl: [(cadvz,
                       label: block_cadvz_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadvz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadvG; else goto cadvF;
       cadvG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadvF: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadvJ() //  [R1]
         { info_tbl: [(cadvJ,
                       label: block_cadvJ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadvJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadvQ; else goto cadvP;
       cadvQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadvP: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.532264397 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding_closure" {
     GHC.IO.Handle.Internals.openTextEncoding_closure:
         const GHC.IO.Handle.Internals.openTextEncoding_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding_entry() //  [R2, R3, R4]
         { info_tbl: [(cadxC,
                       label: GHC.IO.Handle.Internals.openTextEncoding_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadxC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.openTextEncoding1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.536245555 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry() //  [R2]
         { info_tbl: [(cadxQ,
                       label: GHC.IO.Handle.Internals.flushByteWriteBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadxQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cadxU; else goto cadxV;
       cadxU: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadxV: // global
           I64[Sp - 8] = block_cadxN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadyf; else goto cadxO;
       uadyf: // global
           call _cadxN(R1) args: 0, res: 0, upd: 0;
       cadxO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadxN() //  [R1]
         { info_tbl: [(cadxN,
                       label: block_cadxN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadxN: // global
           I64[Sp - 24] = block_cadxT_info;
           _sacID::P64 = P64[R1 + 15];
           _sacIF::P64 = P64[R1 + 31];
           _sacIH::P64 = P64[R1 + 47];
           R1 = P64[_sacIH::P64 + 8];
           P64[Sp - 16] = _sacIF::P64;
           P64[Sp - 8] = _sacIH::P64;
           P64[Sp] = _sacID::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadye; else goto cadxX;
       uadye: // global
           call _cadxT(R1) args: 0, res: 0, upd: 0;
       cadxX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadxT() //  [R1]
         { info_tbl: [(cadxT,
                       label: block_cadxT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadxT: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cadya; else goto cady7;
       cadya: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cady7: // global
           _sacIF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cady5_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sacIF::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cady5() //  [R1]
         { info_tbl: [(cady5,
                       label: block_cady5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cady5: // global
           _sacIH::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacIH::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacIH::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.546648689 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer_entry() //  [R2]
         { info_tbl: [(cadyK,
                       label: GHC.IO.Handle.Internals.flushByteWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadyK: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.550670113 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer1_entry() //  [R2]
         { info_tbl: [(cadyY,
                       label: GHC.IO.Handle.Internals.flushWriteBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadyY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cadz2; else goto cadz3;
       cadz2: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadz3: // global
           I64[Sp - 8] = block_cadyV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadzI; else goto cadyW;
       uadzI: // global
           call _cadyV(R1) args: 0, res: 0, upd: 0;
       cadyW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadyV() //  [R1]
         { info_tbl: [(cadyV,
                       label: block_cadyV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadyV: // global
           I64[Sp - 24] = block_cadz1_info;
           _sacJb::P64 = P64[R1 + 15];
           _sacJd::P64 = P64[R1 + 31];
           _sacJf::P64 = P64[R1 + 47];
           R1 = P64[_sacJf::P64 + 8];
           P64[Sp - 16] = _sacJd::P64;
           P64[Sp - 8] = _sacJf::P64;
           P64[Sp] = _sacJb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadzH; else goto cadz5;
       uadzH: // global
           call _cadz1(R1) args: 0, res: 0, upd: 0;
       cadz5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadz1() //  [R1]
         { info_tbl: [(cadz1,
                       label: block_cadz1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadz1: // global
           I64[Sp] = block_cadz9_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uadzJ; else goto cadzb;
       uadzJ: // global
           call _cadz9(R1) args: 0, res: 0, upd: 0;
       cadzb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadz9() //  [R1]
         { info_tbl: [(cadz9,
                       label: block_cadz9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadz9: // global
           if (R1 & 7 == 1) goto uadzF; else goto cadzm;
       uadzF: // global
           Sp = Sp + 32;
           call _cadzA() args: 0, res: 0, upd: 0;
       cadzm: // global
           _sacJD::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cadzk_info;
           R1 = _sacJD::P64;
           if (R1 & 7 != 0) goto uadzK; else goto cadzn;
       uadzK: // global
           call _cadzk(R1) args: 0, res: 0, upd: 0;
       cadzn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadzk() //  [R1]
         { info_tbl: [(cadzk,
                       label: block_cadzk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadzk: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uadzG; else goto cadzx;
       uadzG: // global
           Sp = Sp + 32;
           call _cadzA() args: 0, res: 0, upd: 0;
       cadzx: // global
           _sacJd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadzv_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sacJd::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cadzA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadzA: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadzv() //  [R1]
         { info_tbl: [(cadzv,
                       label: block_cadzv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadzv: // global
           _sacJf::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacJf::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacJf::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.564894858 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer_entry() //  [R2]
         { info_tbl: [(cadAw,
                       label: GHC.IO.Handle.Internals.flushWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadAw: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.568055839 UTC

[section ""cstring" . lvl7_ra7Pn_bytes" {
     lvl7_ra7Pn_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.570035258 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf2_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf2_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf2_entry() //  [R1]
         { info_tbl: [(cadAM,
                       label: GHC.IO.Handle.Internals.decodeByteBuf2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadAM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadAN; else goto cadAO;
       cadAN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadAO: // global
           (_cadAH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadAH::I64 == 0) goto cadAJ; else goto cadAI;
       cadAJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadAI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadAH::I64;
           I64[Sp - 24] = block_cadAK_info;
           R2 = lvl7_ra7Pn_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cadAK() //  [R1]
         { info_tbl: [(cadAK,
                       label: block_cadAK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadAK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.577398146 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf1_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf1_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf1_entry() //  [R2, R3]
         { info_tbl: [(cadBb,
                       label: GHC.IO.Handle.Internals.decodeByteBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadBb: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cadBc; else goto cadBd;
       cadBc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.decodeByteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cadBd: // global
           I64[Sp - 16] = block_cadB8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadCe; else goto cadB9;
       uadCe: // global
           call _cadB8(R1) args: 0, res: 0, upd: 0;
       cadB9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadB8() //  [R1]
         { info_tbl: [(cadB8,
                       label: block_cadB8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadB8: // global
           I64[Sp - 24] = block_cadBg_info;
           _sacK0::P64 = P64[R1 + 47];
           _sacK2::P64 = P64[R1 + 63];
           R1 = P64[R1 + 95];
           P64[Sp - 16] = _sacK2::P64;
           P64[Sp - 8] = P64[_sacK0::P64 + 8];
           P64[Sp] = _sacK0::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadCd; else goto cadBi;
       uadCd: // global
           call _cadBg(R1) args: 0, res: 0, upd: 0;
       cadBi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadBg() //  [R1]
         { info_tbl: [(cadBg,
                       label: block_cadBg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadBg: // global
           if (R1 & 7 == 1) goto cadBu; else goto cadBV;
       cadBu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadBx; else goto cadBw;
       cadBx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadBw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sacKd::P64 = P64[Sp + 16];
           P64[Hp] = _sacKd::P64;
           _sacJS::P64 = P64[Sp + 32];
           _sacK2::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacK2::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacK2::P64);
           I64[Sp + 16] = block_cadBq_info;
           R3 = _sacJS::P64;
           R2 = _sacKd::P64;
           Sp = Sp + 16;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cadBV: // global
           I64[Sp] = block_cadBG_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadCf; else goto cadBH;
       uadCf: // global
           call _cadBG(R1) args: 0, res: 0, upd: 0;
       cadBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadBq() //  [R1]
         { info_tbl: [(cadBq,
                       label: block_cadBq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadBq: // global
           I64[Sp] = block_cadBs_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadCg; else goto cadBz;
       uadCg: // global
           call _cadBs(R1) args: 0, res: 0, upd: 0;
       cadBz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadBs() //  [R1]
         { info_tbl: [(cadBs,
                       label: block_cadBs_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadBs: // global
           _sacK0::P64 = P64[Sp + 8];
           _sacKm::P64 = P64[R1 + 15];
           _sacKn::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sacK0::P64 + 8] = _sacKm::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacK0::P64);
           R1 = _sacKn::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadBG() //  [R1]
         { info_tbl: [(cadBG,
                       label: block_cadBG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadBG: // global
           I64[Sp - 16] = block_cadBL_info;
           _sacKr::P64 = P64[R1 + 7];
           _sacKs::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sacKs::P64;
           P64[Sp] = _sacKr::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadBL() //  [R1]
         { info_tbl: [(cadBL,
                       label: block_cadBL_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadBL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadBZ; else goto cadBY;
       cadBZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadBY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sacKd::P64 = P64[Sp + 32];
           P64[Hp] = _sacKd::P64;
           _sacJS::P64 = P64[Sp + 48];
           _sacK2::P64 = P64[Sp + 24];
           _sacKr::P64 = P64[Sp + 16];
           _sacKs::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacK2::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacK2::P64);
           I64[Sp + 32] = block_cadBR_info;
           R5 = _sacJS::P64;
           R4 = _sacKd::P64;
           R3 = _sacKs::P64;
           R2 = _sacKr::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cadBR() //  [R1]
         { info_tbl: [(cadBR,
                       label: block_cadBR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadBR: // global
           I64[Sp] = block_cadBT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadCh; else goto cadC1;
       uadCh: // global
           call _cadBT(R1) args: 0, res: 0, upd: 0;
       cadC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadBT() //  [R1]
         { info_tbl: [(cadBT,
                       label: block_cadBT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadBT: // global
           _sacK0::P64 = P64[Sp + 8];
           _sacKF::P64 = P64[R1 + 7];
           _sacKG::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sacK0::P64 + 8] = _sacKF::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacK0::P64);
           R1 = _sacKG::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.597625684 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf_entry() //  [R2, R3]
         { info_tbl: [(cadDg,
                       label: GHC.IO.Handle.Internals.decodeByteBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadDg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.601817546 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cadDu,
                       label: GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadDu: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cadDy; else goto cadDz;
       cadDy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cadDz: // global
           I64[Sp - 16] = block_cadDr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadEd; else goto cadDs;
       uadEd: // global
           call _cadDr(R1) args: 0, res: 0, upd: 0;
       cadDs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadDr() //  [R1]
         { info_tbl: [(cadDr,
                       label: block_cadDr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadDr: // global
           I64[Sp - 32] = block_cadDx_info;
           _sacKL::P64 = R1;
           _sacKN::P64 = P64[R1 + 15];
           _sacKP::P64 = P64[R1 + 31];
           _sacKR::P64 = P64[R1 + 47];
           R1 = P64[_sacKR::P64 + 8];
           P64[Sp - 24] = _sacKN::P64;
           P64[Sp - 16] = _sacKP::P64;
           P64[Sp - 8] = _sacKR::P64;
           P64[Sp] = _sacKL::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uadEc; else goto cadDB;
       uadEc: // global
           call _cadDx(R1) args: 0, res: 0, upd: 0;
       cadDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadDx() //  [R1]
         { info_tbl: [(cadDx,
                       label: block_cadDx_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadDx: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cadDP; else goto cadDJ;
       cadDP: // global
           _sacKP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cadDM_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacKP::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
       cadDJ: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cadDM() //  [R1]
         { info_tbl: [(cadDM,
                       label: block_cadDM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadDM: // global
           I64[Sp] = block_cadDO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadEe; else goto cadDR;
       uadEe: // global
           call _cadDO(R1) args: 0, res: 0, upd: 0;
       cadDR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadDO() //  [R1]
         { info_tbl: [(cadDO,
                       label: block_cadDO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadDO: // global
           I64[Sp - 8] = block_cadDV_info;
           _sacLi::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sacLi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadEf; else goto cadDX;
       uadEf: // global
           call _cadDV(R1) args: 0, res: 0, upd: 0;
       cadDX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadDV() //  [R1]
         { info_tbl: [(cadDV,
                       label: block_cadDV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadDV: // global
           if (R1 & 7 == 1) goto cadE3; else goto cadE7;
       cadE3: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cadE7: // global
           _sacKJ::P64 = P64[Sp + 32];
           _sacKL::P64 = P64[Sp + 24];
           _sacKR::P64 = P64[Sp + 16];
           _sacLi::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacKR::P64 + 8] = _sacLi::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacKR::P64);
           R3 = _sacKJ::P64;
           R2 = _sacKL::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.616523336 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cadES,
                       label: GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadES: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.623405921 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle2_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle2_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle2_info;
         const 0;
 },
 sat_sacMj_entry() //  [R1]
         { info_tbl: [(cadFQ,
                       label: sat_sacMj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadFQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadFU; else goto cadFV;
       cadFU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadFV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadFN_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadFZ; else goto cadFO;
       uadFZ: // global
           call _cadFN(R1) args: 0, res: 0, upd: 0;
       cadFO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadFN() //  [R1]
         { info_tbl: [(cadFN,
                       label: block_cadFN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadFN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadFY; else goto cadFX;
       cadFY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadFX: // global
           _sacMe::P64 = P64[R1 + 7];
           _sacMd::I64 = I64[R1 + 23];
           _sacMg::I64 = I64[R1 + 31];
           _sacMh::I64 = I64[R1 + 39];
           _sacMi::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacMe::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMd::I64;
           I64[Hp - 16] = _sacMg::I64;
           I64[Hp - 8] = _sacMh::I64;
           I64[Hp] = _sacMi::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacMv_entry() //  [R1]
         { info_tbl: [(cadGa,
                       label: sat_sacMv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadGa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadGe; else goto cadGf;
       cadGe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadGf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadG7_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadGj; else goto cadG8;
       uadGj: // global
           call _cadG7(R1) args: 0, res: 0, upd: 0;
       cadG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadG7() //  [R1]
         { info_tbl: [(cadG7,
                       label: block_cadG7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadG7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadGi; else goto cadGh;
       cadGi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadGh: // global
           _sacMq::P64 = P64[R1 + 7];
           _sacMp::I64 = I64[R1 + 23];
           _sacMs::I64 = I64[R1 + 31];
           _sacMt::I64 = I64[R1 + 39];
           _sacMu::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacMq::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMp::I64;
           I64[Hp - 16] = _sacMs::I64;
           I64[Hp - 8] = _sacMt::I64;
           I64[Hp] = _sacMu::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacMH_entry() //  [R1]
         { info_tbl: [(cadGs,
                       label: sat_sacMH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadGs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadGw; else goto cadGx;
       cadGw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadGx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadGp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadGB; else goto cadGq;
       uadGB: // global
           call _cadGp(R1) args: 0, res: 0, upd: 0;
       cadGq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadGp() //  [R1]
         { info_tbl: [(cadGp,
                       label: block_cadGp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadGp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadGA; else goto cadGz;
       cadGA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadGz: // global
           _sacMC::P64 = P64[R1 + 7];
           _sacMB::I64 = I64[R1 + 23];
           _sacME::I64 = I64[R1 + 31];
           _sacMF::I64 = I64[R1 + 39];
           _sacMG::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacMC::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMB::I64;
           I64[Hp - 16] = _sacME::I64;
           I64[Hp - 8] = _sacMF::I64;
           I64[Hp] = _sacMG::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacMT_entry() //  [R1]
         { info_tbl: [(cadGM,
                       label: sat_sacMT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadGM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadGQ; else goto cadGR;
       cadGQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadGR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadGJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadGV; else goto cadGK;
       uadGV: // global
           call _cadGJ(R1) args: 0, res: 0, upd: 0;
       cadGK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadGJ() //  [R1]
         { info_tbl: [(cadGJ,
                       label: block_cadGJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadGJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadGU; else goto cadGT;
       cadGU: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadGT: // global
           _sacMO::P64 = P64[R1 + 7];
           _sacMN::I64 = I64[R1 + 23];
           _sacMQ::I64 = I64[R1 + 31];
           _sacMR::I64 = I64[R1 + 39];
           _sacMS::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacMO::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMN::I64;
           I64[Hp - 16] = _sacMQ::I64;
           I64[Hp - 8] = _sacMR::I64;
           I64[Hp] = _sacMS::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacN5_entry() //  [R1]
         { info_tbl: [(cadH4,
                       label: sat_sacN5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadH4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadH8; else goto cadH9;
       cadH8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadH9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadH1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadHd; else goto cadH2;
       uadHd: // global
           call _cadH1(R1) args: 0, res: 0, upd: 0;
       cadH2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadH1() //  [R1]
         { info_tbl: [(cadH1,
                       label: block_cadH1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadH1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadHc; else goto cadHb;
       cadHc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadHb: // global
           _sacN0::P64 = P64[R1 + 7];
           _sacMZ::I64 = I64[R1 + 23];
           _sacN2::I64 = I64[R1 + 31];
           _sacN3::I64 = I64[R1 + 39];
           _sacN4::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacN0::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMZ::I64;
           I64[Hp - 16] = _sacN2::I64;
           I64[Hp - 8] = _sacN3::I64;
           I64[Hp] = _sacN4::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacNh_entry() //  [R1]
         { info_tbl: [(cadHo,
                       label: sat_sacNh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadHo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadHs; else goto cadHt;
       cadHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadHt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadHl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadHx; else goto cadHm;
       uadHx: // global
           call _cadHl(R1) args: 0, res: 0, upd: 0;
       cadHm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadHl() //  [R1]
         { info_tbl: [(cadHl,
                       label: block_cadHl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadHl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadHw; else goto cadHv;
       cadHw: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadHv: // global
           _sacNc::P64 = P64[R1 + 7];
           _sacNb::I64 = I64[R1 + 23];
           _sacNe::I64 = I64[R1 + 31];
           _sacNf::I64 = I64[R1 + 39];
           _sacNg::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacNc::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacNb::I64;
           I64[Hp - 16] = _sacNe::I64;
           I64[Hp - 8] = _sacNf::I64;
           I64[Hp] = _sacNg::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle2_entry() //  [R2, R3]
         { info_tbl: [(cadHy,
                       label: GHC.IO.Handle.Internals.wantReadableHandle2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadHy: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cadHz; else goto cadHA;
       cadHz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cadHA: // global
           I64[Sp - 16] = block_cadF3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadIy; else goto cadF4;
       uadIy: // global
           call _cadF3(R1) args: 0, res: 0, upd: 0;
       cadF4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadF3() //  [R1]
         { info_tbl: [(cadF3,
                       label: block_cadF3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadF3: // global
           I64[Sp - 40] = block_cadF8_info;
           _sacLq::P64 = R1;
           _sacLs::P64 = P64[R1 + 15];
           _sacLu::P64 = P64[R1 + 31];
           _sacLw::P64 = P64[R1 + 47];
           _sacLz::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sacLs::P64;
           P64[Sp - 24] = _sacLu::P64;
           P64[Sp - 16] = _sacLw::P64;
           P64[Sp - 8] = _sacLz::P64;
           P64[Sp] = _sacLq::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uadIs; else goto cadF9;
       uadIs: // global
           call _cadF8(R1) args: 0, res: 0, upd: 0;
       cadF9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadF8() //  [R1]
         { info_tbl: [(cadF8,
                       label: block_cadF8_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadF8: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto cadHF;
               case 2 : goto cadHI;
               case 3 : goto uadIq;
               case 4, 5 : goto cadHR;
               case 6 : goto cadHT;
           }
       cadHT: // global
           _sacLK::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cadFi_info;
           R1 = _sacLK::P64;
           if (R1 & 7 != 0) goto uadIt; else goto cadFj;
       uadIt: // global
           call _cadFi(R1) args: 0, res: 0, upd: 0;
       cadFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cadHR: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uadIq: // global
           Sp = Sp + 40;
           call _cadHY() args: 0, res: 0, upd: 0;
       cadHI: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cadHF: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadFi() //  [R1]
         { info_tbl: [(cadFi,
                       label: block_cadFi_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadFi: // global
           I64[Sp - 16] = block_cadFn_info;
           _sacLQ::I64 = I64[R1 + 39];
           _sacLR::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sacLR::I64;
           I64[Sp] = _sacLQ::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadIv; else goto cadFo;
       uadIv: // global
           call _cadFn(R1) args: 0, res: 0, upd: 0;
       cadFo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadFn() //  [R1]
         { info_tbl: [(cadFn,
                       label: block_cadFn_info
                       rep:StackRep [True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadFn: // global
           if (R1 & 7 == 1) goto uadIr; else goto cadHZ;
       uadIr: // global
           Sp = Sp + 56;
           call _cadHY() args: 0, res: 0, upd: 0;
       cadHZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cadI2; else goto cadI1;
       cadI2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadI1: // global
           _sacLw::P64 = P64[Sp + 40];
           if (I64[Sp + 16] == I64[Sp + 8]) goto cadIe; else goto cadI4;
       cadIe: // global
           _sacLz::P64 = P64[Sp + 48];
           _sacMX::P64 = P64[_sacLz::P64 + 8];
           I64[Hp - 40] = sat_sacN5_info;
           P64[Hp - 24] = _sacMX::P64;
           _sacLn::P64 = P64[Sp + 64];
           _sacLq::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sacLz::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLz::P64);
           _sacN9::P64 = P64[_sacLw::P64 + 8];
           I64[Hp - 16] = sat_sacNh_info;
           P64[Hp] = _sacN9::P64;
           call MO_WriteBarrier();
           P64[_sacLw::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLw::P64);
           R2 = _sacLq::P64;
           R1 = _sacLn::P64;
           Sp = Sp + 72;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cadI4: // global
           _sacLW::P64 = P64[_sacLw::P64 + 8];
           Hp = Hp - 48;
           I64[Sp + 16] = block_cadFw_info;
           R1 = _sacLW::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uadIw; else goto cadFx;
       uadIw: // global
           call _cadFw(R1) args: 0, res: 0, upd: 0;
       cadFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadFw() //  [R1]
         { info_tbl: [(cadFw,
                       label: block_cadFw_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadFw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cadI7; else goto cadI6;
       cadI7: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadI6: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cadId; else goto cadI9;
       cadId: // global
           _sacLz::P64 = P64[Sp + 32];
           _sacMz::P64 = P64[_sacLz::P64 + 8];
           I64[Hp - 40] = sat_sacMH_info;
           P64[Hp - 24] = _sacMz::P64;
           _sacLn::P64 = P64[Sp + 48];
           _sacLq::P64 = P64[Sp + 40];
           _sacLw::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sacLz::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLz::P64);
           _sacML::P64 = P64[_sacLw::P64 + 8];
           I64[Hp - 16] = sat_sacMT_info;
           P64[Hp] = _sacML::P64;
           call MO_WriteBarrier();
           P64[_sacLw::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLw::P64);
           R2 = _sacLq::P64;
           R1 = _sacLn::P64;
           Sp = Sp + 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cadI9: // global
           Hp = Hp - 48;
           _sacLu::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cadFE_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacLu::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cadFE() //  [R1]
         { info_tbl: [(cadFE,
                       label: block_cadFE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadFE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cadIc; else goto cadIb;
       cadIc: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadIb: // global
           _sacLn::P64 = P64[Sp + 32];
           _sacLq::P64 = P64[Sp + 24];
           _sacLw::P64 = P64[Sp + 8];
           _sacLz::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sacLw::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLw::P64);
           _sacMb::P64 = P64[_sacLz::P64 + 8];
           I64[Hp - 40] = sat_sacMj_info;
           P64[Hp - 24] = _sacMb::P64;
           call MO_WriteBarrier();
           P64[_sacLz::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLz::P64);
           _sacMn::P64 = P64[_sacLw::P64 + 8];
           I64[Hp - 16] = sat_sacMv_info;
           P64[Hp] = _sacMn::P64;
           call MO_WriteBarrier();
           P64[_sacLw::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLw::P64);
           R2 = _sacLq::P64;
           R1 = _sacLn::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadHY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadHY: // global
           R2 = P64[Sp];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.669197673 UTC

[section ""data" . lvl8_ra7Po_closure" {
     lvl8_ra7Po_closure:
         const GHC.IO.Handle.Types.BlockBuffering_con_info;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.676753017 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle5_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle5_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle5_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadL1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 56, res: 0, upd: 8;
     }
 },
 buf_state_sacNz_entry() //  [R1]
         { info_tbl: [(cadMC,
                       label: buf_state_sacNz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadMD; else goto cadME;
       cadMD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadME: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadMv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadML; else goto cadMw;
       uadML: // global
           call _cadMv(R1) args: 0, res: 0, upd: 0;
       cadMw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadMv() //  [R1]
         { info_tbl: [(cadMv,
                       label: block_cadMv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMv: // global
           if (R1 & 7 == 3) goto cadMA; else goto cadMz;
       cadMA: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cadMz: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacNZ_entry() //  [R1]
         { info_tbl: [(cadN8,
                       label: sat_sacNZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadN8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadN9; else goto cadNa;
       cadN9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.outputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacNY_entry() //  [R1]
         { info_tbl: [(cadNf,
                       label: sat_sacNY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadNf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadNg; else goto cadNh;
       cadNg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.inputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacO0_entry() //  [R1]
         { info_tbl: [(cadNi,
                       label: sat_sacO0_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadNi: // global
           if ((Sp + -136) < SpLim) (likely: False) goto cadNk; else goto cadNl;
       cadNk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_cadMX_info;
           _sacNj::P64 = P64[R1 + 16];
           _sacNk::P64 = P64[R1 + 24];
           _sacNl::P64 = P64[R1 + 32];
           _sacNo::P64 = P64[R1 + 48];
           _sacNq::P64 = P64[R1 + 56];
           _sacNr::P64 = P64[R1 + 64];
           _sacNt::P64 = P64[R1 + 72];
           _sacNw::P64 = P64[R1 + 80];
           _sacNx::P64 = P64[R1 + 88];
           _sacNG::P64 = P64[R1 + 96];
           _sacNK::P64 = P64[R1 + 104];
           _sacNN::P64 = P64[R1 + 112];
           _sacNO::P64 = P64[R1 + 120];
           _sacNR::P64 = P64[R1 + 128];
           R1 = P64[R1 + 40];
           P64[Sp - 128] = _sacNj::P64;
           P64[Sp - 120] = _sacNk::P64;
           P64[Sp - 112] = _sacNl::P64;
           P64[Sp - 104] = _sacNo::P64;
           P64[Sp - 96] = _sacNq::P64;
           P64[Sp - 88] = _sacNr::P64;
           P64[Sp - 80] = _sacNt::P64;
           P64[Sp - 72] = _sacNw::P64;
           P64[Sp - 64] = _sacNx::P64;
           P64[Sp - 56] = _sacNG::P64;
           P64[Sp - 48] = _sacNK::P64;
           P64[Sp - 40] = _sacNN::P64;
           P64[Sp - 32] = _sacNO::P64;
           P64[Sp - 24] = _sacNR::P64;
           Sp = Sp - 136;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadMX() //  [R1]
         { info_tbl: [(cadMX,
                       label: block_cadMX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMX: // global
           I64[Sp] = block_cadMZ_info;
           _sacNV::P64 = R1;
           R1 = P64[Sp + 96];
           P64[Sp + 96] = _sacNV::P64;
           if (R1 & 7 != 0) goto uadNq; else goto cadN0;
       uadNq: // global
           call _cadMZ(R1) args: 0, res: 0, upd: 0;
       cadN0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadMZ() //  [R1]
         { info_tbl: [(cadMZ,
                       label: block_cadMZ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMZ: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cadNp; else goto cadNo;
       cadNp: // global
           HpAlloc = 184;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadNo: // global
           _sacNX::P64 = P64[R1 + 7];
           I64[Hp - 176] = sat_sacNZ_info;
           _sacNr::P64 = P64[Sp + 48];
           P64[Hp - 160] = _sacNr::P64;
           I64[Hp - 152] = sat_sacNY_info;
           P64[Hp - 136] = _sacNr::P64;
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = _sacNX::P64;
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = Hp - 152;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 127;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacO6_entry() //  [R1]
         { info_tbl: [(cadNE,
                       label: sat_sacO6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadNE: // global
           _sacO6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cadNF; else goto cadNG;
       cadNG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadNI; else goto cadNH;
       cadNI: // global
           HpAlloc = 16;
           goto cadNF;
       cadNF: // global
           R1 = _sacO6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sacO6::P64;
           _sacNn::P64 = P64[_sacO6::P64 + 16];
           _sacNU::P64 = P64[_sacO6::P64 + 24];
           _sacO4::P64 = P64[_sacO6::P64 + 32];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _sacNU::P64;
           R3 = Hp - 7;
           R2 = _sacNn::P64;
           R1 = _sacO4::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacOG_entry() //  [R1]
         { info_tbl: [(cadNS,
                       label: sat_sacOG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadNS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadNT; else goto cadNU;
       cadNT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadNL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadO1; else goto cadNM;
       uadO1: // global
           call _cadNL(R1) args: 0, res: 0, upd: 0;
       cadNM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cadNL() //  [R1]
         { info_tbl: [(cadNL,
                       label: block_cadNL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadNL: // global
           if (R1 & 7 == 1) goto cadNP; else goto cadNQ;
       cadNP: // global
           R1 = lvl8_ra7Po_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cadNQ: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(cadO6,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle5_info
                       rep:HeapRep static {
                             Fun {arity: 12
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadO6: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cadO7; else goto cadO8;
       cadO7: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 96, res: 0, upd: 8;
       cadO8: // global
           I64[Sp - 48] = block_cadLU_info;
           R1 = P64[Sp + 16];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uadQi; else goto cadLV;
       uadQi: // global
           call _cadLU(R1) args: 0, res: 0, upd: 0;
       cadLV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadLU() //  [R1]
         { info_tbl: [(cadLU,
                       label: block_cadLU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLU: // global
           if (R1 & 7 == 1) goto cadO3; else goto cadO4;
       cadO3: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _cadL8() args: 0, res: 0, upd: 0;
       cadO4: // global
           I64[Sp] = block_cadM0_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadQa; else goto cadM1;
       uadQa: // global
           call _cadM0(R1) args: 0, res: 0, upd: 0;
       cadM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadM0() //  [R1]
         { info_tbl: [(cadM0,
                       label: block_cadM0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadM0: // global
           I64[Sp - 16] = block_cadP1_info;
           _sacOL::P64 = P64[R1 + 15];
           _sacOM::P64 = P64[R1 + 23];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _sacOM::P64;
           P64[Sp] = _sacOL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadQc; else goto cadPn;
       uadQc: // global
           call _cadP1(R1) args: 0, res: 0, upd: 0;
       cadPn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadP1() //  [R1]
         { info_tbl: [(cadP1,
                       label: block_cadP1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadP1: // global
           _sacOL::P64 = P64[Sp + 16];
           _cadPM::P64 = R1 & 7;
           if (_cadPM::P64 != 3) goto uadPU; else goto cadPy;
       uadPU: // global
           if (_cadPM::P64 != 6) goto cadPt; else goto cadPH;
       cadPt: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sacON() args: 0, res: 0, upd: 0;
       cadPH: // global
           I64[Sp] = block_cadPF_info;
           R1 = _sacOL::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cadPy: // global
           I64[Sp] = block_cadPw_info;
           R1 = _sacOL::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadPF() //  [R1]
         { info_tbl: [(cadPF,
                       label: block_cadPF_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadPF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPL; else goto cadPK;
       cadPL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPK: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sacON() args: 0, res: 0, upd: 0;
     }
 },
 _cadPw() //  [R1]
         { info_tbl: [(cadPw,
                       label: block_cadPw_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadPw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPC; else goto cadPB;
       cadPC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPB: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sacON() args: 0, res: 0, upd: 0;
     }
 },
 _sacON() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sacON: // global
           I64[Sp - 8] = block_cadMa_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadQm; else goto cadMb;
       uadQm: // global
           call _cadMa(R1) args: 0, res: 0, upd: 0;
       cadMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadMa() //  [R1]
         { info_tbl: [(cadMa,
                       label: block_cadMa_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMa: // global
           _sacOM::P64 = P64[Sp + 8];
           _cadPP::P64 = R1 & 7;
           if (_cadPP::P64 < 5) goto uadPS; else goto uadPT;
       uadPS: // global
           if (_cadPP::P64 < 4) goto cadP7; else goto cadP9;
       cadP7: // global
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _cadL8() args: 0, res: 0, upd: 0;
       cadP9: // global
           I64[Sp + 8] = block_cadMg_info;
           R1 = _sacOM::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       uadPT: // global
           if (_cadPP::P64 < 6) goto cadPe; else goto cadPj;
       cadPe: // global
           I64[Sp + 8] = block_cadMl_info;
           R1 = _sacOM::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cadPj: // global
           I64[Sp + 8] = block_cadMq_info;
           R1 = _sacOM::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadMg() //  [R1]
         { info_tbl: [(cadMg,
                       label: block_cadMg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPc; else goto cadPb;
       cadPc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPb: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sacNx::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sacNx::P64;
           call _cadL8() args: 0, res: 0, upd: 0;
     }
 },
 _cadMl() //  [R1]
         { info_tbl: [(cadMl,
                       label: block_cadMl_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPh; else goto cadPg;
       cadPh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPg: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sacNx::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sacNx::P64;
           call _cadL8() args: 0, res: 0, upd: 0;
     }
 },
 _cadMq() //  [R1]
         { info_tbl: [(cadMq,
                       label: block_cadMq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPm; else goto cadPl;
       cadPm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPl: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sacNx::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sacNx::P64;
           call _cadL8() args: 0, res: 0, upd: 0;
     }
 },
 _cadL8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadL8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadOb; else goto cadOa;
       cadOb: // global
           HpAlloc = 24;
           _sacNw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadL7_info;
           R2 = P64[Sp];
           R1 = _sacNw::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cadOa: // global
           I64[Hp - 16] = buf_state_sacNz_info;
           P64[Hp] = P64[Sp + 56];
           I64[Sp - 16] = block_cadLc_info;
           R2 = P64[Sp + 24];
           I64[Sp - 40] = stg_ap_ppv_info;
           P64[Sp - 32] = P64[Sp + 40];
           _cadLa::P64 = Hp - 16;
           P64[Sp - 24] = _cadLa::P64;
           P64[Sp - 8] = _cadLa::P64;
           Sp = Sp - 40;
           call GHC.IO.BufferedIO.newBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cadL7() //  [R1, R2]
         { info_tbl: [(cadL7,
                       label: block_cadL7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadL7: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cadL8() args: 0, res: 0, upd: 0;
     }
 },
 _cadLc() //  [R1]
         { info_tbl: [(cadLc,
                       label: block_cadLc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLc: // global
           I64[Sp - 8] = block_cadLe_info;
           _sacND::P64 = R1;
           R1 = R1;
           P64[Sp] = _sacND::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadLe() //  [R1]
         { info_tbl: [(cadLe,
                       label: block_cadLe_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadOf; else goto cadOe;
       cadOf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOe: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cadLh_info;
           _sacNG::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _sacNG::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadLh() //  [R1]
         { info_tbl: [(cadLh,
                       label: block_cadLh_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLh: // global
           I64[Sp] = block_cadLl_info;
           _sacNK::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _sacNK::P64;
           if (R1 & 7 != 0) goto uadQ7; else goto cadLm;
       uadQ7: // global
           call _cadLl(R1) args: 0, res: 0, upd: 0;
       cadLm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadLl() //  [R1]
         { info_tbl: [(cadLl,
                       label: block_cadLl_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLl: // global
           if (R1 & 7 == 1) goto cadOG; else goto cadOP;
       cadOG: // global
           I64[Sp] = block_cadLq_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cadOP: // global
           I64[Sp] = block_cadLE_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadLq() //  [R1]
         { info_tbl: [(cadLq,
                       label: block_cadLq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLq: // global
           I64[Sp - 8] = block_cadLs_info;
           _sacOe::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sacOe::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadLs() //  [R1]
         { info_tbl: [(cadLs,
                       label: block_cadLs_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLs: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadOK; else goto cadOJ;
       cadOK: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOJ: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_cadLz_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadLz() //  [R1]
         { info_tbl: [(cadLz,
                       label: block_cadLz_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadON; else goto cadOM;
       cadON: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOM: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 7;
           P64[Sp] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           call _sacNL() args: 0, res: 0, upd: 0;
     }
 },
 _cadLE() //  [R1]
         { info_tbl: [(cadLE,
                       label: block_cadLE_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLE: // global
           I64[Sp - 8] = block_cadLG_info;
           _sacOr::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sacOr::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadLG() //  [R1]
         { info_tbl: [(cadLG,
                       label: block_cadLG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadOT; else goto cadOS;
       cadOT: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOS: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_cadLN_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadLN() //  [R1]
         { info_tbl: [(cadLN,
                       label: block_cadLN_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLN: // global
           I64[Sp] = block_cadLP_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 64];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cadLP() //  [R1]
         { info_tbl: [(cadLP,
                       label: block_cadLP_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadLP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cadOX; else goto cadOW;
       cadOX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOW: // global
           I64[Hp - 32] = sat_sacOG_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = Hp - 32;
           P64[Sp + 16] = Hp - 7;
           call _sacNL() args: 0, res: 0, upd: 0;
     }
 },
 _sacNL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sacNL: // global
           I64[Sp - 8] = block_cadMP_info;
           R1 = GHC.IO.Handle.Types.BufferListNil_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadMP() //  [R1]
         { info_tbl: [(cadMP,
                       label: block_cadMP_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMP: // global
           I64[Sp - 8] = block_cadMR_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cadMR() //  [R1]
         { info_tbl: [(cadMR,
                       label: block_cadMR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadMR: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cadOl; else goto cadOk;
       cadOl: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOk: // global
           I64[Hp - 128] = sat_sacO0_info;
           P64[Hp - 112] = P64[Sp + 56];
           P64[Hp - 104] = P64[Sp + 64];
           P64[Hp - 96] = P64[Sp + 72];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 112];
           P64[Hp - 64] = P64[Sp + 120];
           P64[Hp - 56] = P64[Sp + 136];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 104];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 80] = block_cadNr_info;
           R2 = Hp - 128;
           _sacNU::P64 = R1;
           R1 = R1;
           P64[Sp + 136] = _sacNU::P64;
           Sp = Sp + 80;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadNr() //  []
         { info_tbl: [(cadNr,
                       label: block_cadNr_info
                       rep:StackRep [False, True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadNr: // global
           I64[Sp] = block_cadNt_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uadQh; else goto cadNu;
       uadQh: // global
           call _cadNt(R1) args: 0, res: 0, upd: 0;
       cadNu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadNt() //  [R1]
         { info_tbl: [(cadNt,
                       label: block_cadNt_info
                       rep:StackRep [False, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadNt: // global
           _sacNn::P64 = P64[Sp + 8];
           _sacNU::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cadOq; else goto cadOx;
       cadOq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadOt; else goto cadOs;
       cadOt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOs: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = _sacNn::P64;
           P64[Hp] = _sacNU::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cadOx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cadOA; else goto cadOz;
       cadOA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOz: // global
           _sacO4::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_sacO6_info;
           P64[Hp - 16] = _sacNn::P64;
           P64[Hp - 8] = _sacNU::P64;
           P64[Hp] = _sacO4::P64;
           I64[Sp] = block_cadOu_info;
           R3 = Hp - 32;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _sacNU::P64;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadOu() //  [R1]
         { info_tbl: [(cadOu,
                       label: block_cadOu_info
                       rep:StackRep [False, True, True, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadOu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadOD; else goto cadOC;
       cadOD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOC: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.758235849 UTC

[section ""data" . GHC.IO.Handle.Internals.mkHandle_closure" {
     GHC.IO.Handle.Internals.mkHandle_closure:
         const GHC.IO.Handle.Internals.mkHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadV1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkHandle_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 56, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkHandle_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cadV5,
                       label: GHC.IO.Handle.Internals.mkHandle_info
                       rep:HeapRep static {
                             Fun {arity: 12
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadV5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.762794435 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO1_closure" {
     GHC.IO.Handle.Internals.debugIO1_closure:
         const GHC.IO.Handle.Internals.debugIO1_info;
 },
 GHC.IO.Handle.Internals.debugIO1_entry() //  []
         { info_tbl: [(cadVi,
                       label: GHC.IO.Handle.Internals.debugIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadVi: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.766622417 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO_closure" {
     GHC.IO.Handle.Internals.debugIO_closure:
         const GHC.IO.Handle.Internals.debugIO_info;
 },
 GHC.IO.Handle.Internals.debugIO_entry() //  [R2]
         { info_tbl: [(cadVv,
                       label: GHC.IO.Handle.Internals.debugIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadVv: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.debugIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.773425273 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwriteCharBuffer_closure" {
     GHC.IO.Handle.Internals.$wwriteCharBuffer_closure:
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_info;
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadVD: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cadVK,
                       label: GHC.IO.Handle.Internals.$wwriteCharBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadVK: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cadVL; else goto uadYQ;
       cadVL: // global
           R1 = GHC.IO.Handle.Internals.$wwriteCharBuffer_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       uadYQ: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cadVE() args: 0, res: 0, upd: 0;
     }
 },
 _cadVE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadVE: // global
           _sacPe::P64 = P64[Sp];
           I64[Sp] = block_cadVH_info;
           R1 = _sacPe::P64;
           if (R1 & 7 != 0) goto uadZ6; else goto cadVI;
       uadZ6: // global
           call _cadVH(R1) args: 0, res: 0, upd: 0;
       cadVI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadVH() //  [R1]
         { info_tbl: [(cadVH,
                       label: block_cadVH_info
                       rep:StackRep [True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadVH: // global
           I64[Sp - 48] = block_cadVR_info;
           _sacPm::P64 = R1;
           _sacPo::P64 = P64[R1 + 15];
           _sacPq::P64 = P64[R1 + 31];
           _sacPs::P64 = P64[R1 + 47];
           _sacPt::P64 = P64[R1 + 55];
           R1 = P64[R1 + 87];
           P64[Sp - 40] = _sacPo::P64;
           P64[Sp - 32] = _sacPq::P64;
           P64[Sp - 24] = _sacPs::P64;
           P64[Sp - 16] = _sacPt::P64;
           P64[Sp - 8] = P64[_sacPs::P64 + 8];
           P64[Sp] = _sacPm::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uadZ7; else goto cadXV;
       uadZ7: // global
           call _cadVR(R1) args: 0, res: 0, upd: 0;
       cadXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadVR() //  [R1]
         { info_tbl: [(cadVR,
                       label: block_cadVR_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadVR: // global
           if (R1 & 7 == 1) goto cadY9; else goto cadYB;
       cadY9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadYc; else goto cadYb;
       cadYc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadYb: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_cadY0_info;
           R3 = P64[Sp + 40];
           R2 = Hp - 47;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cadYB: // global
           I64[Sp] = block_cadYm_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadZ9; else goto cadYn;
       uadZ9: // global
           call _cadYm(R1) args: 0, res: 0, upd: 0;
       cadYn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadY0() //  [R1]
         { info_tbl: [(cadY0,
                       label: block_cadY0_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadY0: // global
           I64[Sp] = block_cadY2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadZs; else goto cadY3;
       uadZs: // global
           call _cadY2(R1) args: 0, res: 0, upd: 0;
       cadY3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadY2() //  [R1]
         { info_tbl: [(cadY2,
                       label: block_cadY2_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadY2: // global
           I64[Sp] = block_cadY7_info;
           _sacQz::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp + 96] = _sacQz::P64;
           if (R1 & 7 != 0) goto uadZt; else goto cadYf;
       uadZt: // global
           call _cadY7(R1) args: 0, res: 0, upd: 0;
       cadYf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadY7() //  [R1]
         { info_tbl: [(cadY7,
                       label: block_cadY7_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadY7: // global
           P64[Sp + 96] = P64[Sp + 96];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 72] = P64[R1 + 7];
           P64[Sp + 64] = P64[R1 + 15];
           I64[Sp + 56] = I64[R1 + 31];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 8;
           call _cadVT() args: 0, res: 0, upd: 0;
     }
 },
 _cadYm() //  [R1]
         { info_tbl: [(cadYm,
                       label: block_cadYm_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadYm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadYE; else goto cadYD;
       cadYE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadYD: // global
           _sacQK::P64 = P64[R1 + 7];
           _sacQL::P64 = P64[R1 + 15];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_cadYs_info;
           R5 = P64[Sp + 40];
           R4 = Hp - 47;
           R3 = _sacQL::P64;
           R2 = _sacQK::P64;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cadYs() //  [R1]
         { info_tbl: [(cadYs,
                       label: block_cadYs_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadYs: // global
           I64[Sp] = block_cadYu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadZv; else goto cadYv;
       uadZv: // global
           call _cadYu(R1) args: 0, res: 0, upd: 0;
       cadYv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadYu() //  [R1]
         { info_tbl: [(cadYu,
                       label: block_cadYu_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadYu: // global
           I64[Sp] = block_cadYz_info;
           _sacQU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _sacQU::P64;
           if (R1 & 7 != 0) goto uadZw; else goto cadYH;
       uadZw: // global
           call _cadYz(R1) args: 0, res: 0, upd: 0;
       cadYH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadYz() //  [R1]
         { info_tbl: [(cadYz,
                       label: block_cadYz_info
                       rep:StackRep [False, False, False, False, True, False, True, True,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadYz: // global
           I64[Sp] = I64[R1 + 47];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp + 56] = I64[R1 + 31];
           P64[Sp + 64] = P64[R1 + 15];
           P64[Sp + 72] = P64[R1 + 7];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 96] = P64[Sp + 96];
           Sp = Sp - 8;
           call _cadVT() args: 0, res: 0, upd: 0;
     }
 },
 _cadVT() //  []
         { info_tbl: [(cadVT,
                       label: block_cadVT_info
                       rep:StackRep [True, False, False, False, False, True, False, True,
                                     False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadVT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadVY; else goto cadVX;
       cadVY: // global
           HpAlloc = 56;
           I64[Sp] = block_cadVT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cadVX: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 88];
           _sacPM::I64 = I64[Sp + 64];
           I64[Hp - 16] = _sacPM::I64;
           I64[Hp - 8] = I64[Sp + 48];
           _sacPO::I64 = I64[Sp + 8];
           I64[Hp] = _sacPO::I64;
           _cadVZ::P64 = Hp - 47;
           if (_sacPM::I64 == _sacPO::I64) goto uadYT; else goto cadWs;
       uadYT: // global
           P64[Sp + 96] = _cadVZ::P64;
           Sp = Sp + 16;
           call _sacPQ() args: 0, res: 0, upd: 0;
       cadWs: // global
           I64[Sp] = block_cadWq_info;
           R1 = P64[Sp + 104];
           P64[Sp + 88] = _cadVZ::P64;
           if (R1 & 7 != 0) goto uadZa; else goto cadWt;
       uadZa: // global
           call _cadWq(R1) args: 0, res: 0, upd: 0;
       cadWt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadWq() //  [R1]
         { info_tbl: [(cadWq,
                       label: block_cadWq_info
                       rep:StackRep [True, False, False, False, False, True, False, True,
                                     True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadWq: // global
           _sacPt::P64 = P64[Sp + 40];
           _sacQ6::P64 = P64[R1 + 7];
           _sacQ7::P64 = P64[R1 + 15];
           _sacQ5::I64 = I64[R1 + 23];
           _sacQ8::I64 = I64[R1 + 31];
           _sacQ9::I64 = I64[R1 + 39];
           _sacQa::I64 = I64[R1 + 47];
           if (_sacQ9::I64 == _sacQa::I64) goto sacQb; else goto cadXS;
       cadXS: // global
           if (_sacQ9::I64 != I64[Sp + 96]) goto sacQb; else goto uadYU;
       sacQb: // global
           I64[Sp - 8] = block_cadWD_info;
           R1 = _sacPt::P64;
           I64[Sp] = _sacQa::I64;
           I64[Sp + 40] = _sacQ9::I64;
           I64[Sp + 64] = _sacQ8::I64;
           P64[Sp + 72] = _sacQ7::P64;
           P64[Sp + 80] = _sacQ6::P64;
           I64[Sp + 96] = _sacQ5::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadZf; else goto cadWF;
       uadZf: // global
           call _cadWD(R1) args: 0, res: 0, upd: 0;
       cadWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uadYU: // global
           P64[Sp + 96] = P64[Sp + 88];
           Sp = Sp + 16;
           call _sacPQ() args: 0, res: 0, upd: 0;
     }
 },
 _cadWD() //  [R1]
         { info_tbl: [(cadWD,
                       label: block_cadWD_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadWD: // global
           _cadYN::P64 = R1 & 7;
           if (_cadYN::P64 < 3) goto uadYP; else goto cadX2;
       uadYP: // global
           _cadVZ::P64 = P64[Sp + 96];
           if (_cadYN::P64 < 2) goto uadYV; else goto cadWX;
       uadYV: // global
           P64[Sp + 104] = _cadVZ::P64;
           Sp = Sp + 24;
           call _sacPQ() args: 0, res: 0, upd: 0;
       cadWX: // global
           _sacPs::P64 = P64[Sp + 40];
           _sacQ9::I64 = I64[Sp + 48];
           _sacQa::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacPs::P64 + 8] = _cadVZ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacPs::P64);
           if (_sacQ9::I64 == _sacQa::I64) goto uadYW; else goto uadYX;
       uadYW: // global
           Sp = Sp + 120;
           call _cadXF() args: 0, res: 0, upd: 0;
       uadYX: // global
           Sp = Sp + 8;
           call _cadXE() args: 0, res: 0, upd: 0;
       cadX2: // global
           I64[Sp] = block_cadX0_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto uadZh; else goto cadX3;
       uadZh: // global
           call _cadX0(R1) args: 0, res: 0, upd: 0;
       cadX3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadX0() //  [R1]
         { info_tbl: [(cadX0,
                       label: block_cadX0_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadX0: // global
           if (R1 & 7 == 1) goto cadXh; else goto cadXm;
       cadXh: // global
           _cadVZ::P64 = P64[Sp + 96];
           _sacPs::P64 = P64[Sp + 40];
           _sacQ9::I64 = I64[Sp + 48];
           _sacQa::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacPs::P64 + 8] = _cadVZ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacPs::P64);
           if (_sacQ9::I64 == _sacQa::I64) goto uadZ1; else goto uadZ2;
       uadZ1: // global
           Sp = Sp + 120;
           call _cadXF() args: 0, res: 0, upd: 0;
       uadZ2: // global
           Sp = Sp + 8;
           call _cadXE() args: 0, res: 0, upd: 0;
       cadXm: // global
           I64[Sp] = block_cadXk_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadZl; else goto cadXn;
       uadZl: // global
           call _cadXk(R1) args: 0, res: 0, upd: 0;
       cadXn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadXk() //  [R1]
         { info_tbl: [(cadXk,
                       label: block_cadXk_info
                       rep:StackRep [True, True, False, False, False, True, True, False,
                                     True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadXk: // global
           _cadVZ::P64 = P64[Sp + 96];
           if (%MO_S_Lt_W64(I64[Sp + 16] - I64[Sp + 56],
                            I64[R1 + 7])) goto cadXH; else goto uadYY;
       cadXH: // global
           _sacPs::P64 = P64[Sp + 40];
           _sacQ9::I64 = I64[Sp + 48];
           _sacQa::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacPs::P64 + 8] = _cadVZ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacPs::P64);
           if (_sacQ9::I64 == _sacQa::I64) goto uadYZ; else goto uadZ0;
       uadYZ: // global
           Sp = Sp + 120;
           call _cadXF() args: 0, res: 0, upd: 0;
       uadZ0: // global
           Sp = Sp + 8;
           call _cadXE() args: 0, res: 0, upd: 0;
       uadYY: // global
           P64[Sp + 104] = _cadVZ::P64;
           Sp = Sp + 24;
           call _sacPQ() args: 0, res: 0, upd: 0;
     }
 },
 _cadXE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadXE: // global
           P64[Sp + 56] = P64[Sp + 56];
           _sacPi::I64 = I64[Sp + 64];
           I64[Sp + 64] = I64[Sp + 96];
           _sacPh::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sacPh::P64;
           I64[Sp + 88] = _sacPi::I64;
           I64[Sp + 96] = I64[Sp + 40];
           I64[Sp + 104] = I64[Sp];
           Sp = Sp + 56;
           call _cadVE() args: 0, res: 0, upd: 0;
     }
 },
 _sacPQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sacPQ: // global
           _sacPq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadW5_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sacPq::P64;
           P64[Sp] = P64[Sp + 80];
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cadW5() //  [R1]
         { info_tbl: [(cadW5,
                       label: block_cadW5_info
                       rep:StackRep [False, True, True, False, True, True, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadW5: // global
           _sacPs::P64 = P64[Sp + 8];
           _sacPI::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sacPs::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacPs::P64);
           I64[Sp + 24] = block_cadWa_info;
           R1 = _sacPI::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uadZc; else goto cadWd;
       uadZc: // global
           call _cadWa(R1) args: 0, res: 0, upd: 0;
       cadWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadWa() //  [R1]
         { info_tbl: [(cadWa,
                       label: block_cadWa_info
                       rep:StackRep [False, True, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadWa: // global
           _sacQ0::I64 = I64[R1 + 39];
           _sacQ1::I64 = I64[R1 + 47];
           if (_sacQ0::I64 == _sacQ1::I64) goto uadZ4; else goto cadWl;
       uadZ4: // global
           Sp = Sp + 64;
           call _cadXF() args: 0, res: 0, upd: 0;
       cadWl: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 40] = I64[R1 + 31];
           I64[Sp + 48] = _sacQ0::I64;
           I64[Sp + 56] = _sacQ1::I64;
           Sp = Sp + 8;
           call _cadVE() args: 0, res: 0, upd: 0;
     }
 },
 _cadXF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadXF: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.817779626 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer1_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer1_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer1_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer1_entry() //  [R2, R3]
         { info_tbl: [(cae26,
                       label: GHC.IO.Handle.Internals.writeCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae26: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae27; else goto cae28;
       cae27: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.writeCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cae28: // global
           I64[Sp - 16] = block_cae23_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uae2c; else goto cae24;
       uae2c: // global
           call _cae23(R1) args: 0, res: 0, upd: 0;
       cae24: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae23() //  [R1]
         { info_tbl: [(cae23,
                       label: block_cae23_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae23: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.823508595 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer_entry() //  [R2, R3]
         { info_tbl: [(cae2t,
                       label: GHC.IO.Handle.Internals.writeCharBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae2t: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.writeCharBuffer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.828985291 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer3_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer3_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer3_info;
 },
 sat_sacRY_entry() //  [R1]
         { info_tbl: [(cae38,
                       label: sat_sacRY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae38: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cae3c; else goto cae3d;
       cae3c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae3d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cae35_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uae3h; else goto cae36;
       uae3h: // global
           call _cae35(R1) args: 0, res: 0, upd: 0;
       cae36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cae35() //  [R1]
         { info_tbl: [(cae35,
                       label: block_cae35_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae35: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cae3g; else goto cae3f;
       cae3g: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cae3f: // global
           _sacRT::P64 = P64[R1 + 7];
           _sacRU::P64 = P64[R1 + 15];
           _sacRS::I64 = I64[R1 + 23];
           _sacRV::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacRT::P64;
           P64[Hp - 32] = _sacRU::P64;
           I64[Hp - 24] = _sacRS::I64;
           I64[Hp - 16] = _sacRV::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacSh_entry() //  [R1]
         { info_tbl: [(cae3E,
                       label: sat_sacSh_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae3E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cae3L; else goto cae3M;
       cae3L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae3M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cae3B_info;
           _sacS7::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sacS7::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uae3Q; else goto cae3C;
       uae3Q: // global
           call _cae3B(R1) args: 0, res: 0, upd: 0;
       cae3C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cae3B() //  [R1]
         { info_tbl: [(cae3B,
                       label: block_cae3B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae3B: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cae3P; else goto cae3O;
       cae3P: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cae3O: // global
           _sacSb::P64 = P64[R1 + 7];
           _sacSc::P64 = P64[R1 + 15];
           _sacSa::I64 = I64[R1 + 23];
           _sacSd::I64 = I64[R1 + 31];
           _sacSf::I64 = I64[R1 + 47];
           _sacSg::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacSb::P64;
           P64[Hp - 32] = _sacSc::P64;
           I64[Hp - 24] = _sacSa::I64;
           I64[Hp - 16] = _sacSd::I64;
           I64[Hp - 8] = _sacSg::I64;
           I64[Hp] = _sacSf::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushCharBuffer3_entry() //  [R2]
         { info_tbl: [(cae3R,
                       label: GHC.IO.Handle.Internals.flushCharBuffer3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae3R: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cae3S; else goto cae3T;
       cae3S: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cae3T: // global
           I64[Sp - 8] = block_cae2E_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uae4Z; else goto cae2F;
       uae4Z: // global
           call _cae2E(R1) args: 0, res: 0, upd: 0;
       cae2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae2E() //  [R1]
         { info_tbl: [(cae2E,
                       label: block_cae2E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae2E: // global
           I64[Sp - 32] = block_cae2J_info;
           _sacRl::P64 = P64[R1 + 47];
           _sacRn::P64 = P64[R1 + 63];
           _sacRo::P64 = P64[R1 + 71];
           _sacRr::P64 = P64[R1 + 95];
           R1 = P64[_sacRo::P64 + 8];
           P64[Sp - 24] = _sacRn::P64;
           P64[Sp - 16] = _sacRo::P64;
           P64[Sp - 8] = _sacRr::P64;
           P64[Sp] = _sacRl::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uae4T; else goto cae2K;
       uae4T: // global
           call _cae2J(R1) args: 0, res: 0, upd: 0;
       cae2K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae2J() //  [R1]
         { info_tbl: [(cae2J,
                       label: block_cae2J_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae2J: // global
           I64[Sp - 16] = block_cae2O_info;
           _sacRE::I64 = I64[R1 + 39];
           _sacRF::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sacRF::I64;
           I64[Sp] = _sacRE::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uae4U; else goto cae2P;
       uae4U: // global
           call _cae2O(R1) args: 0, res: 0, upd: 0;
       cae2P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae2O() //  [R1]
         { info_tbl: [(cae2O,
                       label: block_cae2O_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae2O: // global
           if (R1 & 7 != 1) goto cae4G; else goto cae4C;
       cae4C: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cae4G; else goto cae3Y;
       cae4G: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cae3Y: // global
           _sacRK::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_cae2W_info;
           R1 = _sacRK::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uae4V; else goto cae2X;
       uae4V: // global
           call _cae2W(R1) args: 0, res: 0, upd: 0;
       cae2X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae2W() //  [R1]
         { info_tbl: [(cae2W,
                       label: block_cae2W_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae2W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cae41; else goto cae40;
       cae41: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cae40: // global
           _sacRo::P64 = P64[Sp + 8];
           _sacRM::P64 = P64[R1 + 7];
           _sacRN::P64 = P64[R1 + 15];
           _sacRQ::P64 = P64[_sacRo::P64 + 8];
           I64[Hp - 16] = sat_sacRY_info;
           P64[Hp] = _sacRQ::P64;
           call MO_WriteBarrier();
           P64[_sacRo::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacRo::P64);
           I64[Sp - 8] = block_cae3l_info;
           R1 = _sacRQ::P64;
           P64[Sp] = _sacRN::P64;
           P64[Sp + 8] = _sacRM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uae4W; else goto cae3m;
       uae4W: // global
           call _cae3l(R1) args: 0, res: 0, upd: 0;
       cae3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae3l() //  [R1]
         { info_tbl: [(cae3l,
                       label: block_cae3l_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae3l: // global
           _sacS7::I64 = I64[R1 + 39];
           if (_sacS7::I64 != 0) goto cae44; else goto cae4z;
       cae44: // global
           I64[Sp - 24] = block_cae3s_info;
           _sacS2::P64 = P64[R1 + 7];
           _sacS3::P64 = P64[R1 + 15];
           _sacS1::I64 = I64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 16] = _sacS3::P64;
           I64[Sp - 8] = _sacS7::I64;
           P64[Sp] = _sacS2::P64;
           I64[Sp + 24] = _sacS1::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uae4X; else goto cae3t;
       uae4X: // global
           call _cae3s(R1) args: 0, res: 0, upd: 0;
       cae3t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cae4z: // global
           _sacRl::P64 = P64[Sp + 32];
           _sacRN::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacRl::P64 + 8] = _sacRN::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacRl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cae3s() //  [R1]
         { info_tbl: [(cae3s,
                       label: block_cae3s_info
                       rep:StackRep [False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae3s: // global
           if (R1 & 7 == 1) goto cae46; else goto cae4o;
       cae46: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cae49; else goto cae48;
       cae49: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cae48: // global
           I64[Hp - 24] = sat_sacSh_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sacRl::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sacRl::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacRl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cae4o: // global
           I64[Sp] = block_cae4c_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uae4Y; else goto cae4d;
       uae4Y: // global
           call _cae4c(R1) args: 0, res: 0, upd: 0;
       cae4d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae4c() //  [R1]
         { info_tbl: [(cae4c,
                       label: block_cae4c_info
                       rep:StackRep [False, True, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae4c: // global
           I64[Sp - 8] = block_cae4h_info;
           R2 = P64[Sp + 40];
           _sacSl::P64 = P64[R1 + 7];
           _sacSm::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sacSm::P64;
           P64[Sp + 40] = _sacSl::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae4h() //  [R1]
         { info_tbl: [(cae4h,
                       label: block_cae4h_info
                       rep:StackRep [False, False, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae4h: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cae4s; else goto cae4r;
       cae4s: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cae4r: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 56] = block_cae4k_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 48];
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cae4k() //  [R1]
         { info_tbl: [(cae4k,
                       label: block_cae4k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae4k: // global
           I64[Sp] = block_cae4m_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uae50; else goto cae4u;
       uae50: // global
           call _cae4m(R1) args: 0, res: 0, upd: 0;
       cae4u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae4m() //  [R1]
         { info_tbl: [(cae4m,
                       label: block_cae4m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae4m: // global
           _sacRl::P64 = P64[Sp + 8];
           _sacSy::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sacRl::P64 + 8] = _sacSy::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacRl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.863257411 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharReadBuffer_info;
 },
 GHC.IO.Handle.Internals.flushCharReadBuffer_entry() //  [R2]
         { info_tbl: [(cae6O,
                       label: GHC.IO.Handle.Internals.flushCharReadBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae6O: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.866935839 UTC

[section ""cstring" . lvl9_ra7Pp_bytes" {
     lvl9_ra7Pp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.868869494 UTC

[section ""data" . lvl10_ra7Pq_closure" {
     lvl10_ra7Pq_closure:
         const lvl10_ra7Pq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ra7Pq_entry() //  [R1]
         { info_tbl: [(cae72,
                       label: lvl10_ra7Pq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae72: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae73; else goto cae74;
       cae73: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae74: // global
           (_cae6Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae6Z::I64 == 0) goto cae71; else goto cae70;
       cae71: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae70: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae6Z::I64;
           R2 = lvl9_ra7Pp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.872902502 UTC

[section ""data" . lvl11_ra7Pr_closure" {
     lvl11_ra7Pr_closure:
         const lvl11_ra7Pr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_ra7Pr_entry() //  [R1]
         { info_tbl: [(cae7j,
                       label: lvl11_ra7Pr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae7j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae7k; else goto cae7l;
       cae7k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae7l: // global
           (_cae7g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae7g::I64 == 0) goto cae7i; else goto cae7h;
       cae7i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae7h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae7g::I64;
           R2 = GHC.IO.Handle.Internals.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.876913498 UTC

[section ""data" . lvl12_ra7Ps_closure" {
     lvl12_ra7Ps_closure:
         const lvl12_ra7Ps_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ra7Ps_entry() //  [R1]
         { info_tbl: [(cae7A,
                       label: lvl12_ra7Ps_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae7A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae7B; else goto cae7C;
       cae7B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae7C: // global
           (_cae7x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae7x::I64 == 0) goto cae7z; else goto cae7y;
       cae7z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae7y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae7x::I64;
           R2 = GHC.IO.Handle.Internals.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.881755826 UTC

[section ""cstring" . lvl13_ra7Pt_bytes" {
     lvl13_ra7Pt_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.883581152 UTC

[section ""data" . lvl14_ra7Pu_closure" {
     lvl14_ra7Pu_closure:
         const lvl14_ra7Pu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ra7Pu_entry() //  [R1]
         { info_tbl: [(cae7S,
                       label: lvl14_ra7Pu_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae7S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae7T; else goto cae7U;
       cae7T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae7U: // global
           (_cae7P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae7P::I64 == 0) goto cae7R; else goto cae7Q;
       cae7R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae7Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae7P::I64;
           R2 = lvl13_ra7Pt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.887399508 UTC

[section ""data" . lvl15_ra7Pv_closure" {
     lvl15_ra7Pv_closure:
         const GHC.Types.I#_con_info;
         const 487;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.889046712 UTC

[section ""data" . lvl16_ra7Pw_closure" {
     lvl16_ra7Pw_closure:
         const GHC.Types.I#_con_info;
         const 12;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.890744705 UTC

[section ""data" . lvl17_ra7Px_closure" {
     lvl17_ra7Px_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.892468688 UTC

[section ""data" . lvl18_ra7Py_closure" {
     lvl18_ra7Py_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl11_ra7Pr_closure;
         const lvl12_ra7Ps_closure;
         const lvl14_ra7Pu_closure;
         const lvl15_ra7Pv_closure+1;
         const lvl16_ra7Pw_closure+1;
         const lvl15_ra7Pv_closure+1;
         const lvl17_ra7Px_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.894646549 UTC

[section ""data" . lvl19_ra7Pz_closure" {
     lvl19_ra7Pz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl10_ra7Pq_closure;
         const lvl18_ra7Py_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.896372822 UTC

[section ""cstring" . lvl20_ra7PA_bytes" {
     lvl20_ra7PA_bytes:
         I8[] [105,110,116,101,114,110,97,108,32,73,79,32,108,105,98,114,97,114,121,32,101,114,114,111,114,58,32,67,104,97,114,32,98,117,102,102,101,114,32,110,111,110,45,101,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.898476709 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer2_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer2_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer2_entry() //  [R1]
         { info_tbl: [(cae8h,
                       label: GHC.IO.Handle.Internals.flushCharBuffer2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae8h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cae8i; else goto cae8j;
       cae8i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae8j: // global
           (_cae8c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae8c::I64 == 0) goto cae8e; else goto cae8d;
       cae8e: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae8d: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae8c::I64;
           I64[Sp - 24] = block_cae8f_info;
           R2 = lvl20_ra7PA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cae8f() //  [R1]
         { info_tbl: [(cae8f,
                       label: block_cae8f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae8f: // global
           R3 = R1;
           R2 = lvl19_ra7Pz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.904687312 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer1_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer1_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer1_entry() //  [R2]
         { info_tbl: [(cae8G,
                       label: GHC.IO.Handle.Internals.flushCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae8G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cae8K; else goto cae8L;
       cae8K: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cae8L: // global
           I64[Sp - 8] = block_cae8D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uae9b; else goto cae8E;
       uae9b: // global
           call _cae8D(R1) args: 0, res: 0, upd: 0;
       cae8E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae8D() //  [R1]
         { info_tbl: [(cae8D,
                       label: block_cae8D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae8D: // global
           _sacSY::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_cae8J_info;
           _sacSF::P64 = R1;
           R1 = _sacSY::P64;
           P64[Sp] = _sacSF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uae9a; else goto cae8N;
       uae9a: // global
           call _cae8J(R1) args: 0, res: 0, upd: 0;
       cae8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae8J() //  [R1]
         { info_tbl: [(cae8J,
                       label: block_cae8J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae8J: // global
           I64[Sp - 16] = block_cae8R_info;
           _sacT4::I64 = I64[R1 + 39];
           _sacT5::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sacT5::I64;
           I64[Sp] = _sacT4::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uae9c; else goto cae8T;
       uae9c: // global
           call _cae8R(R1) args: 0, res: 0, upd: 0;
       cae8T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae8R() //  [R1]
         { info_tbl: [(cae8R,
                       label: block_cae8R_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae8R: // global
           if (R1 & 7 == 1) goto cae8Z; else goto cae98;
       cae8Z: // global
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
       cae98: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cae97; else goto cae96;
       cae97: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cae96: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.914994534 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer_entry() //  [R2]
         { info_tbl: [(cae9H,
                       label: GHC.IO.Handle.Internals.flushCharBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae9H: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.919754108 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer2_closure" {
     GHC.IO.Handle.Internals.flushBuffer2_closure:
         const GHC.IO.Handle.Internals.flushBuffer2_info;
         const 0;
 },
 sat_sacTJ_entry() //  [R1]
         { info_tbl: [(caeaj,
                       label: sat_sacTJ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeaj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeak; else goto caeal;
       caeak: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeal: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -(I64[R1 + 24] - I64[R1 + 16]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushBuffer2_entry() //  [R2]
         { info_tbl: [(caeao,
                       label: GHC.IO.Handle.Internals.flushBuffer2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeao: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caeap; else goto caeaq;
       caeap: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeaq: // global
           I64[Sp - 8] = block_cae9S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaeaR; else goto cae9T;
       uaeaR: // global
           call _cae9S(R1) args: 0, res: 0, upd: 0;
       cae9T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae9S() //  [R1]
         { info_tbl: [(cae9S,
                       label: block_cae9S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae9S: // global
           I64[Sp - 24] = block_cae9X_info;
           _sacTc::P64 = P64[R1 + 7];
           _sacTf::P64 = P64[R1 + 31];
           _sacTh::P64 = P64[R1 + 47];
           R1 = P64[_sacTh::P64 + 8];
           P64[Sp - 16] = _sacTf::P64;
           P64[Sp - 8] = _sacTh::P64;
           P64[Sp] = _sacTc::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeaP; else goto cae9Y;
       uaeaP: // global
           call _cae9X(R1) args: 0, res: 0, upd: 0;
       cae9Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae9X() //  [R1]
         { info_tbl: [(cae9X,
                       label: block_cae9X_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae9X: // global
           _sacTA::I64 = I64[R1 + 39];
           _sacTB::I64 = I64[R1 + 47];
           if (_sacTA::I64 == _sacTB::I64) goto caeaJ; else goto caeau;
       caeaJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caeau: // global
           I64[Sp - 48] = block_caea5_info;
           R2 = P64[Sp + 24];
           I64[Sp - 64] = stg_ap_pv_info;
           P64[Sp - 56] = P64[Sp + 8];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sacTA::I64;
           I64[Sp - 8] = _sacTB::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _caea5() //  [R1]
         { info_tbl: [(caea5,
                       label: block_caea5_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caea5: // global
           I64[Sp] = block_caea7_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeaQ; else goto caea8;
       uaeaQ: // global
           call _caea7(R1) args: 0, res: 0, upd: 0;
       caea8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caea7() //  [R1]
         { info_tbl: [(caea7,
                       label: block_caea7_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caea7: // global
           if (R1 & 7 == 1) goto caeaz; else goto caeaB;
       caeaz: // global
           R1 = GHC.IO.Handle.Internals.flushBuffer3_closure;
           Sp = Sp + 80;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caeaB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caeaE; else goto caeaD;
       caeaE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeaD: // global
           I64[Hp - 24] = sat_sacTJ_info;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 40];
           I64[Sp] = block_caeaA_info;
           R2 = P64[Sp + 72];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 16] = GHC.IO.Device.RelativeSeek_closure+2;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _caeaA() //  [R1]
         { info_tbl: [(caeaA,
                       label: block_caeaA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeaA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caeaI; else goto caeaH;
       caeaI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeaH: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sacTh::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sacTh::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTh::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.93600876 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteReadBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushByteReadBuffer_entry() //  [R2]
         { info_tbl: [(caebW,
                       label: GHC.IO.Handle.Internals.flushByteReadBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caebW: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.941932769 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer1_closure" {
     GHC.IO.Handle.Internals.flushBuffer1_closure:
         const GHC.IO.Handle.Internals.flushBuffer1_info;
         const 0;
 },
 sat_sacUL_entry() //  [R1]
         { info_tbl: [(caecL,
                       label: sat_sacUL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caecL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caecP; else goto caecQ;
       caecP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caecQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caecI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaecU; else goto caecJ;
       uaecU: // global
           call _caecI(R1) args: 0, res: 0, upd: 0;
       caecJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caecI() //  [R1]
         { info_tbl: [(caecI,
                       label: block_caecI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caecI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caecT; else goto caecS;
       caecT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caecS: // global
           _sacUG::P64 = P64[R1 + 7];
           _sacUH::P64 = P64[R1 + 15];
           _sacUF::I64 = I64[R1 + 23];
           _sacUI::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacUG::P64;
           P64[Hp - 32] = _sacUH::P64;
           I64[Hp - 24] = _sacUF::I64;
           I64[Hp - 16] = _sacUI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sacV4_entry() //  [R1]
         { info_tbl: [(caedh,
                       label: sat_sacV4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caedh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caedo; else goto caedp;
       caedo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caedp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caede_info;
           _sacUU::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sacUU::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaedt; else goto caedf;
       uaedt: // global
           call _caede(R1) args: 0, res: 0, upd: 0;
       caedf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caede() //  [R1]
         { info_tbl: [(caede,
                       label: block_caede_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caede: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caeds; else goto caedr;
       caeds: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caedr: // global
           _sacUY::P64 = P64[R1 + 7];
           _sacUZ::P64 = P64[R1 + 15];
           _sacUX::I64 = I64[R1 + 23];
           _sacV0::I64 = I64[R1 + 31];
           _sacV2::I64 = I64[R1 + 47];
           _sacV3::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacUY::P64;
           P64[Hp - 32] = _sacUZ::P64;
           I64[Hp - 24] = _sacUX::I64;
           I64[Hp - 16] = _sacV0::I64;
           I64[Hp - 8] = _sacV3::I64;
           I64[Hp] = _sacV2::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.flushBuffer1_entry() //  [R2]
         { info_tbl: [(caedu,
                       label: GHC.IO.Handle.Internals.flushBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caedu: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caedv; else goto caedw;
       caedv: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caedw: // global
           I64[Sp - 8] = block_caec7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaef6; else goto caec8;
       uaef6: // global
           call _caec7(R1) args: 0, res: 0, upd: 0;
       caec8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caec7() //  [R1]
         { info_tbl: [(caec7,
                       label: block_caec7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caec7: // global
           I64[Sp - 56] = block_caecc_info;
           _sacTR::P64 = R1;
           _sacTT::P64 = P64[R1 + 15];
           _sacTV::P64 = P64[R1 + 31];
           _sacTX::P64 = P64[R1 + 47];
           _sacTZ::P64 = P64[R1 + 63];
           _sacU0::P64 = P64[R1 + 71];
           _sacU3::P64 = P64[R1 + 95];
           R1 = P64[_sacU0::P64 + 8];
           P64[Sp - 48] = _sacTT::P64;
           P64[Sp - 40] = _sacTV::P64;
           P64[Sp - 32] = _sacTX::P64;
           P64[Sp - 24] = _sacTZ::P64;
           P64[Sp - 16] = _sacU0::P64;
           P64[Sp - 8] = _sacU3::P64;
           P64[Sp] = _sacTR::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaeeX; else goto caecd;
       uaeeX: // global
           call _caecc(R1) args: 0, res: 0, upd: 0;
       caecd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caecc() //  [R1]
         { info_tbl: [(caecc,
                       label: block_caecc_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caecc: // global
           I64[Sp] = block_caech_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaeeY; else goto caeci;
       uaeeY: // global
           call _caech(R1) args: 0, res: 0, upd: 0;
       caeci: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caech() //  [R1]
         { info_tbl: [(caech,
                       label: block_caech_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caech: // global
           if (R1 & 7 == 1) goto caedB; else goto caees;
       caedB: // global
           _sacUl::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_caecm_info;
           R1 = _sacUl::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaeeZ; else goto caecn;
       uaeeZ: // global
           call _caecm(R1) args: 0, res: 0, upd: 0;
       caecn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caees: // global
           _sacVr::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_caeeq_info;
           R1 = _sacVr::P64;
           if (R1 & 7 != 0) goto uaef0; else goto caeet;
       uaef0: // global
           call _caeeq(R1) args: 0, res: 0, upd: 0;
       caeet: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caecm() //  [R1]
         { info_tbl: [(caecm,
                       label: block_caecm_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caecm: // global
           I64[Sp - 16] = block_caecr_info;
           _sacUr::I64 = I64[R1 + 39];
           _sacUs::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sacUs::I64;
           I64[Sp] = _sacUr::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaef1; else goto caecs;
       uaef1: // global
           call _caecr(R1) args: 0, res: 0, upd: 0;
       caecs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caecr() //  [R1]
         { info_tbl: [(caecr,
                       label: block_caecr_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caecr: // global
           _sacTR::P64 = P64[Sp + 56];
           if (R1 & 7 != 1) goto caeen; else goto caeej;
       caeej: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto caeen; else goto caedF;
       caeen: // global
           R2 = _sacTR::P64;
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       caedF: // global
           _sacUx::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_caecz_info;
           R1 = _sacUx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaef2; else goto caecA;
       uaef2: // global
           call _caecz(R1) args: 0, res: 0, upd: 0;
       caecA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caecz() //  [R1]
         { info_tbl: [(caecz,
                       label: block_caecz_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caecz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caedI; else goto caedH;
       caedI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caedH: // global
           _sacU0::P64 = P64[Sp + 24];
           _sacUz::P64 = P64[R1 + 7];
           _sacUA::P64 = P64[R1 + 15];
           _sacUD::P64 = P64[_sacU0::P64 + 8];
           I64[Hp - 16] = sat_sacUL_info;
           P64[Hp] = _sacUD::P64;
           call MO_WriteBarrier();
           P64[_sacU0::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacU0::P64);
           I64[Sp] = block_caecY_info;
           R1 = _sacUD::P64;
           P64[Sp + 16] = _sacUA::P64;
           P64[Sp + 24] = _sacUz::P64;
           if (R1 & 7 != 0) goto uaef3; else goto caecZ;
       uaef3: // global
           call _caecY(R1) args: 0, res: 0, upd: 0;
       caecZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caecY() //  [R1]
         { info_tbl: [(caecY,
                       label: block_caecY_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caecY: // global
           _sacUU::I64 = I64[R1 + 39];
           if (_sacUU::I64 != 0) goto caedL; else goto caeeg;
       caedL: // global
           I64[Sp - 24] = block_caed5_info;
           _sacUP::P64 = P64[R1 + 7];
           _sacUQ::P64 = P64[R1 + 15];
           _sacUO::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sacUQ::P64;
           I64[Sp - 8] = _sacUU::I64;
           P64[Sp] = _sacUP::P64;
           I64[Sp + 32] = _sacUO::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaef4; else goto caed6;
       uaef4: // global
           call _caed5(R1) args: 0, res: 0, upd: 0;
       caed6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caeeg: // global
           _sacTR::P64 = P64[Sp + 40];
           _sacTX::P64 = P64[Sp + 8];
           _sacUA::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sacTX::P64 + 8] = _sacUA::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTX::P64);
           R2 = _sacTR::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caed5() //  [R1]
         { info_tbl: [(caed5,
                       label: block_caed5_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caed5: // global
           if (R1 & 7 == 1) goto caedN; else goto caee5;
       caedN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caedQ; else goto caedP;
       caedQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caedP: // global
           I64[Hp - 24] = sat_sacV4_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sacTR::P64 = P64[Sp + 64];
           _sacTX::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sacTX::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTX::P64);
           R2 = _sacTR::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       caee5: // global
           I64[Sp] = block_caedT_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaef5; else goto caedU;
       uaef5: // global
           call _caedT(R1) args: 0, res: 0, upd: 0;
       caedU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caedT() //  [R1]
         { info_tbl: [(caedT,
                       label: block_caedT_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caedT: // global
           I64[Sp - 8] = block_caedY_info;
           R2 = P64[Sp + 48];
           _sacV8::P64 = P64[R1 + 7];
           _sacV9::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sacV9::P64;
           P64[Sp + 48] = _sacV8::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caedY() //  [R1]
         { info_tbl: [(caedY,
                       label: block_caedY_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caedY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caee9; else goto caee8;
       caee9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caee8: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_caee1_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caee1() //  [R1]
         { info_tbl: [(caee1,
                       label: block_caee1_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caee1: // global
           I64[Sp] = block_caee3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaef7; else goto caeeb;
       uaef7: // global
           call _caee3(R1) args: 0, res: 0, upd: 0;
       caeeb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caee3() //  [R1]
         { info_tbl: [(caee3,
                       label: block_caee3_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caee3: // global
           _sacTR::P64 = P64[Sp + 40];
           _sacTX::P64 = P64[Sp + 8];
           _sacVl::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sacTX::P64 + 8] = _sacVl::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTX::P64);
           R2 = _sacTR::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caeeq() //  [R1]
         { info_tbl: [(caeeq,
                       label: block_caeeq_info
                       rep:StackRep [False, False, False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeeq: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto caeeG; else goto caeeD;
       caeeG: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caeeD: // global
           _sacTV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caeeB_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacTV::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _caeeB() //  [R1]
         { info_tbl: [(caeeB,
                       label: block_caeeB_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeeB: // global
           _sacTX::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacTX::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTX::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.984049157 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer_closure" {
     GHC.IO.Handle.Internals.flushBuffer_closure:
         const GHC.IO.Handle.Internals.flushBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer_entry() //  [R2]
         { info_tbl: [(caehh,
                       label: GHC.IO.Handle.Internals.flushBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caehh: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.987293795 UTC

[section ""cstring" . lvl21_ra7PB_bytes" {
     lvl21_ra7PB_bytes:
         I8[] [71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,56,56,49,58,55,45,51,48,124,74,117,115,116,32,100,101,99,111,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.989142528 UTC

[section ""data" . lvl22_ra7PC_closure" {
     lvl22_ra7PC_closure:
         const lvl22_ra7PC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ra7PC_entry() //  [R1]
         { info_tbl: [(caehv,
                       label: lvl22_ra7PC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caehv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caehw; else goto caehx;
       caehw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caehx: // global
           (_caehs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caehs::I64 == 0) goto caehu; else goto caeht;
       caehu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caeht: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caehs::I64;
           R2 = lvl21_ra7PB_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:15.998253912 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_2_closure" {
     GHC.IO.Handle.Internals.hLookAhead_2_closure:
         const GHC.IO.Handle.Internals.hLookAhead_2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_2_entry() //  [R2, R3]
         { info_tbl: [(caehN,
                       label: GHC.IO.Handle.Internals.hLookAhead_2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caehN: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caehR; else goto caehS;
       caehR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caehS: // global
           I64[Sp - 16] = block_caehK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaeki; else goto caehL;
       uaeki: // global
           call _caehK(R1) args: 0, res: 0, upd: 0;
       caehL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caehK() //  [R1]
         { info_tbl: [(caehK,
                       label: block_caehK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caehK: // global
           I64[Sp - 48] = block_caehQ_info;
           _sacVH::P64 = R1;
           _sacVJ::P64 = P64[R1 + 15];
           _sacVL::P64 = P64[R1 + 31];
           _sacVN::P64 = P64[R1 + 47];
           _sacVP::P64 = P64[R1 + 63];
           _sacVT::P64 = P64[R1 + 95];
           R1 = P64[_sacVN::P64 + 8];
           P64[Sp - 40] = _sacVJ::P64;
           P64[Sp - 32] = _sacVL::P64;
           P64[Sp - 24] = _sacVN::P64;
           P64[Sp - 16] = _sacVP::P64;
           P64[Sp - 8] = _sacVT::P64;
           P64[Sp] = _sacVH::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uaekh; else goto caehU;
       uaekh: // global
           call _caehQ(R1) args: 0, res: 0, upd: 0;
       caehU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caehQ() //  [R1]
         { info_tbl: [(caehQ,
                       label: block_caehQ_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caehQ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto caek2; else goto caejR;
       caek2: // global
           _sacVL::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caejU_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacVL::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       caejR: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sacW8() args: 0, res: 0, upd: 0;
     }
 },
 _caejU() //  [R1]
         { info_tbl: [(caejU,
                       label: block_caejU_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caejU: // global
           I64[Sp] = block_caejW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaekt; else goto caejX;
       uaekt: // global
           call _caejW(R1) args: 0, res: 0, upd: 0;
       caejX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caejW() //  [R1]
         { info_tbl: [(caejW,
                       label: block_caejW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caejW: // global
           I64[Sp - 8] = block_caek1_info;
           _sacXt::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sacXt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaeku; else goto caek5;
       uaeku: // global
           call _caek1(R1) args: 0, res: 0, upd: 0;
       caek5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caek1() //  [R1]
         { info_tbl: [(caek1,
                       label: block_caek1_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caek1: // global
           if (I64[R1 + 7] == 0) goto caekd; else goto caekc;
       caekd: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caekc: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _sacW8() args: 0, res: 0, upd: 0;
     }
 },
 _sacW8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sacW8: // global
           I64[Sp - 8] = block_caei4_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaekw; else goto caei6;
       uaekw: // global
           call _caei4(R1) args: 0, res: 0, upd: 0;
       caei6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caei4() //  [R1]
         { info_tbl: [(caei4,
                       label: block_caei4_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caei4: // global
           if (R1 & 7 == 1) goto caeiv; else goto caejo;
       caeiv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeiy; else goto caeix;
       caeiy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeix: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sacWa::P64 = P64[Sp + 8];
           P64[Hp] = _sacWa::P64;
           _sacVF::P64 = P64[Sp + 48];
           _sacVP::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sacVP::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacVP::P64);
           I64[Sp + 8] = block_caeie_info;
           R3 = _sacVF::P64;
           R2 = _sacWa::P64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       caejo: // global
           I64[Sp] = block_caeiW_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaekk; else goto caeiX;
       uaekk: // global
           call _caeiW(R1) args: 0, res: 0, upd: 0;
       caeiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeie() //  [R1]
         { info_tbl: [(caeie,
                       label: block_caeie_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeie: // global
           I64[Sp] = block_caeig_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaekl; else goto caeih;
       uaekl: // global
           call _caeig(R1) args: 0, res: 0, upd: 0;
       caeih: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeig() //  [R1]
         { info_tbl: [(caeig,
                       label: block_caeig_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeig: // global
           _sacVN::P64 = P64[Sp + 8];
           _sacWj::P64 = P64[R1 + 15];
           _sacWk::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sacVN::P64 + 8] = _sacWj::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacVN::P64);
           I64[Sp + 16] = block_caeio_info;
           R1 = _sacWk::P64;
           P64[Sp + 24] = _sacWj::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaekm; else goto caeip;
       uaekm: // global
           call _caeio(R1) args: 0, res: 0, upd: 0;
       caeip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeio() //  [R1]
         { info_tbl: [(caeio,
                       label: block_caeio_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeio: // global
           I64[Sp - 8] = block_caeit_info;
           _sacWm::P64 = R1;
           _sacWs::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sacWs::I64;
           P64[Sp + 24] = _sacWm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaekn; else goto caeiC;
       uaekn: // global
           call _caeit(R1) args: 0, res: 0, upd: 0;
       caeiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeit() //  [R1]
         { info_tbl: [(caeit,
                       label: block_caeit_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeit: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto caeiO; else goto caeiK;
       caeiO: // global
           _sacWj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caeiN_info;
           _sacWt::P64 = R1;
           R1 = _sacWj::P64;
           P64[Sp + 32] = _sacWt::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaeko; else goto caeiP;
       uaeko: // global
           call _caeiN(R1) args: 0, res: 0, upd: 0;
       caeiP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caeiK: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caeiN() //  [R1]
         { info_tbl: [(caeiN,
                       label: block_caeiN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeiN: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 _caeiW() //  [R1]
         { info_tbl: [(caeiW,
                       label: block_caeiW_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeiW: // global
           I64[Sp - 8] = block_caej1_info;
           _sacWK::P64 = P64[R1 + 7];
           _sacWL::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sacWL::P64;
           P64[Sp + 32] = _sacWK::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caej1() //  [R1]
         { info_tbl: [(caej1,
                       label: block_caej1_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caej1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caejs; else goto caejr;
       caejs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caejr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sacWa::P64 = P64[Sp + 16];
           P64[Hp] = _sacWa::P64;
           _sacVF::P64 = P64[Sp + 56];
           _sacVP::P64 = P64[Sp + 32];
           _sacWK::P64 = P64[Sp + 40];
           _sacWL::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacVP::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacVP::P64);
           I64[Sp + 16] = block_caej7_info;
           R5 = _sacVF::P64;
           R4 = _sacWa::P64;
           R3 = _sacWL::P64;
           R2 = _sacWK::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caej7() //  [R1]
         { info_tbl: [(caej7,
                       label: block_caej7_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caej7: // global
           I64[Sp] = block_caej9_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaekp; else goto caeja;
       uaekp: // global
           call _caej9(R1) args: 0, res: 0, upd: 0;
       caeja: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caej9() //  [R1]
         { info_tbl: [(caej9,
                       label: block_caej9_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caej9: // global
           _sacVN::P64 = P64[Sp + 8];
           _sacWY::P64 = P64[R1 + 7];
           _sacWZ::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sacVN::P64 + 8] = _sacWY::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacVN::P64);
           I64[Sp + 16] = block_caejh_info;
           R1 = _sacWZ::P64;
           P64[Sp + 24] = _sacWY::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaekq; else goto caeji;
       uaekq: // global
           call _caejh(R1) args: 0, res: 0, upd: 0;
       caeji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caejh() //  [R1]
         { info_tbl: [(caejh,
                       label: block_caejh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caejh: // global
           I64[Sp - 8] = block_caejm_info;
           _sacX1::P64 = R1;
           _sacX7::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sacX7::I64;
           P64[Sp + 24] = _sacX1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaekr; else goto caejw;
       uaekr: // global
           call _caejm(R1) args: 0, res: 0, upd: 0;
       caejw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caejm() //  [R1]
         { info_tbl: [(caejm,
                       label: block_caejm_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caejm: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto caejI; else goto caejE;
       caejI: // global
           _sacWY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caejH_info;
           _sacX8::P64 = R1;
           R1 = _sacWY::P64;
           P64[Sp + 32] = _sacX8::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaeks; else goto caejJ;
       uaeks: // global
           call _caejH(R1) args: 0, res: 0, upd: 0;
       caejJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caejE: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caejH() //  [R1]
         { info_tbl: [(caejH,
                       label: block_caejH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caejH: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Internals.$wreadTextDevice'_closure" {
     GHC.IO.Handle.Internals.$wreadTextDevice'_closure:
         const GHC.IO.Handle.Internals.$wreadTextDevice'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeky: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaenL_srtd" {
     uaenL_srtd:
         const Saded_srt+56;
         const 33;
         const 7516192769;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(caekF,
                       label: GHC.IO.Handle.Internals.$wreadTextDevice'_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caekF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cael5; else goto uaeno;
       cael5: // global
           R1 = GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       uaeno: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _caekz() args: 0, res: 0, upd: 0;
     }
 },
 _caekz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caekz: // global
           _sacXy::P64 = P64[Sp];
           I64[Sp] = block_caekC_info;
           R1 = _sacXy::P64;
           if (R1 & 7 != 0) goto uaens; else goto caekD;
       uaens: // global
           call _caekC(R1) args: 0, res: 0, upd: 0;
       caekD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenM_srtd" {
     uaenM_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caekC() //  [R1]
         { info_tbl: [(caekC,
                       label: block_caekC_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caekC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cael9; else goto cael8;
       cael9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cael8: // global
           _sacXz::I64 = I64[Sp + 8];
           _sacXA::P64 = P64[Sp + 16];
           _sacXB::P64 = P64[Sp + 24];
           _sacXC::I64 = I64[Sp + 32];
           _sacXD::I64 = I64[Sp + 40];
           _sacXJ::P64 = P64[R1 + 15];
           _sacXL::P64 = P64[R1 + 31];
           _sacXN::P64 = P64[R1 + 47];
           _sacXP::P64 = P64[R1 + 63];
           _sacXT::P64 = P64[R1 + 95];
           _sacXY::I64 = I64[Sp + 48] - _sacXD::I64;
           (_sacY4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_sacXz::I64, _sacXz::I64 + _sacXD::I64, _sacXY::I64);
           call MO_Touch(_sacXA::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacXA::P64;
           P64[Hp - 32] = _sacXB::P64;
           I64[Hp - 24] = _sacXz::I64;
           I64[Hp - 16] = _sacXC::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sacXY::I64;
           I64[Sp + 16] = block_caekX_info;
           R2 = _sacXJ::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacXL::P64;
           P64[Sp + 8] = Hp - 47;
           P64[Sp + 24] = _sacXT::P64;
           P64[Sp + 32] = _sacXP::P64;
           P64[Sp + 40] = _sacXN::P64;
           P64[Sp + 48] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenN_srtd" {
     uaenN_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caekX() //  [R1]
         { info_tbl: [(caekX,
                       label: block_caekX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caekX: // global
           I64[Sp] = block_caekZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaenu; else goto cael0;
       uaenu: // global
           call _caekZ(R1) args: 0, res: 0, upd: 0;
       cael0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenO_srtd" {
     uaenO_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caekZ() //  [R1]
         { info_tbl: [(caekZ,
                       label: block_caekZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caekZ: // global
           I64[Sp - 8] = block_cael4_info;
           _sacYc::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sacYc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaenv; else goto caelc;
       uaenv: // global
           call _cael4(R1) args: 0, res: 0, upd: 0;
       caelc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenP_srtd" {
     uaenP_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _cael4() //  [R1]
         { info_tbl: [(cael4,
                       label: block_cael4_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cael4: // global
           if (I64[R1 + 7] == 0) goto caemp; else goto caell;
       caemp: // global
           _sacYc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caemo_info;
           R1 = _sacYc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaenx; else goto caemq;
       uaenx: // global
           call _caemo(R1) args: 0, res: 0, upd: 0;
       caemq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caell: // global
           I64[Sp] = block_caelj_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto uaenw; else goto caelm;
       uaenw: // global
           call _caelj(R1) args: 0, res: 0, upd: 0;
       caelm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenQ_srtd" {
     uaenQ_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caemo() //  [R1]
         { info_tbl: [(caemo,
                       label: block_caemo_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caemo: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto caenl; else goto caemA;
       caenl: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caemA: // global
           _sacXT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caemy_info;
           _sacYX::P64 = R1;
           R1 = _sacXT::P64;
           P64[Sp + 16] = _sacYX::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaenF; else goto caemB;
       uaenF: // global
           call _caemy(R1) args: 0, res: 0, upd: 0;
       caemB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caemy() //  [R1]
         { info_tbl: [(caemy,
                       label: block_caemy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caemy: // global
           if (R1 & 7 == 1) goto uaenr; else goto caen6;
       uaenr: // global
           Sp = Sp + 40;
           call _caemH() args: 0, res: 0, upd: 0;
       caen6: // global
           I64[Sp] = block_caemK_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaenG; else goto caemL;
       uaenG: // global
           call _caemK(R1) args: 0, res: 0, upd: 0;
       caemL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caemK() //  [R1]
         { info_tbl: [(caemK,
                       label: block_caemK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caemK: // global
           _sacYX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caemP_info;
           R3 = P64[Sp + 32];
           R2 = _sacYX::P64;
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caemP() //  [R1]
         { info_tbl: [(caemP,
                       label: block_caemP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caemP: // global
           I64[Sp] = block_caemR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaenI; else goto caemS;
       uaenI: // global
           call _caemR(R1) args: 0, res: 0, upd: 0;
       caemS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caemR() //  [R1]
         { info_tbl: [(caemR,
                       label: block_caemR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caemR: // global
           _sacXN::P64 = P64[Sp + 8];
           _sacZi::P64 = P64[R1 + 7];
           _sacZj::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sacXN::P64 + 8] = _sacZi::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacXN::P64);
           I64[Sp + 8] = block_caemZ_info;
           R1 = _sacZj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaenJ; else goto caen0;
       uaenJ: // global
           call _caemZ(R1) args: 0, res: 0, upd: 0;
       caen0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caemZ() //  [R1]
         { info_tbl: [(caemZ,
                       label: block_caemZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caemZ: // global
           I64[Sp - 8] = block_caen4_info;
           _sacZl::P64 = R1;
           _sacZr::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           I64[Sp] = _sacZr::I64;
           P64[Sp + 16] = _sacZl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaenK; else goto caenb;
       uaenK: // global
           call _caen4(R1) args: 0, res: 0, upd: 0;
       caenb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caen4() //  [R1]
         { info_tbl: [(caen4,
                       label: block_caen4_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caen4: // global
           _sacZl::P64 = P64[Sp + 24];
           if (I64[Sp + 8] == I64[R1 + 47]) goto caenk; else goto caenj;
       caenk: // global
           R3 = _sacZl::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       caenj: // global
           R1 = _sacZl::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaenR_srtd" {
     uaenR_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelj() //  [R1]
         { info_tbl: [(caelj,
                       label: block_caelj_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caelj: // global
           if (R1 & 7 == 1) goto uaenp; else goto caelX;
       uaenp: // global
           Sp = Sp + 56;
           call _caemH() args: 0, res: 0, upd: 0;
       caelX: // global
           I64[Sp] = block_caelv_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaeny; else goto caelw;
       uaeny: // global
           call _caelv(R1) args: 0, res: 0, upd: 0;
       caelw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caemH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caemH: // global
           R1 = lvl22_ra7PC_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaenS_srtd" {
     uaenS_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelv() //  [R1]
         { info_tbl: [(caelv,
                       label: block_caelv_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caelv: // global
           I64[Sp - 8] = block_caelA_info;
           _sacYk::P64 = P64[R1 + 7];
           _sacYl::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sacYl::P64;
           P64[Sp + 16] = _sacYk::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenT_srtd" {
     uaenT_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelA() //  [R1]
         { info_tbl: [(caelA,
                       label: block_caelA_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caelA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caem1; else goto caem0;
       caem1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caem0: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sacYc::P64 = P64[Sp + 16];
           P64[Hp] = _sacYc::P64;
           _sacXF::P64 = P64[Sp + 56];
           _sacXP::P64 = P64[Sp + 32];
           _sacYk::P64 = P64[Sp + 24];
           _sacYl::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacXP::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacXP::P64);
           I64[Sp + 32] = block_caelG_info;
           R5 = _sacXF::P64;
           R4 = _sacYc::P64;
           R3 = _sacYl::P64;
           R2 = _sacYk::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenU_srtd" {
     uaenU_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelG() //  [R1]
         { info_tbl: [(caelG,
                       label: block_caelG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caelG: // global
           I64[Sp] = block_caelI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaenA; else goto caelJ;
       uaenA: // global
           call _caelI(R1) args: 0, res: 0, upd: 0;
       caelJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenV_srtd" {
     uaenV_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelI() //  [R1]
         { info_tbl: [(caelI,
                       label: block_caelI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caelI: // global
           _sacXF::P64 = P64[Sp + 24];
           _sacXN::P64 = P64[Sp + 8];
           _sacYy::P64 = P64[R1 + 7];
           _sacYz::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sacXN::P64 + 8] = _sacYy::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacXN::P64);
           I64[Sp] = block_caelQ_info;
           R1 = _sacXF::P64;
           P64[Sp + 8] = _sacYz::P64;
           P64[Sp + 24] = _sacYy::P64;
           if (R1 & 7 != 0) goto uaenB; else goto caelR;
       uaenB: // global
           call _caelQ(R1) args: 0, res: 0, upd: 0;
       caelR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenW_srtd" {
     uaenW_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelQ() //  [R1]
         { info_tbl: [(caelQ,
                       label: block_caelQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caelQ: // global
           I64[Sp] = block_caelV_info;
           _sacYH::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sacYH::I64;
           if (R1 & 7 != 0) goto uaenC; else goto caem5;
       uaenC: // global
           call _caelV(R1) args: 0, res: 0, upd: 0;
       caem5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenX_srtd" {
     uaenX_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelV() //  [R1]
         { info_tbl: [(caelV,
                       label: block_caelV_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caelV: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto caemh; else goto caemd;
       caemh: // global
           I64[Sp + 8] = block_caemg_info;
           _sacYI::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sacYI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaenD; else goto caemi;
       uaenD: // global
           call _caemg(R1) args: 0, res: 0, upd: 0;
       caemi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caemd: // global
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaenY_srtd" {
     uaenY_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caemg() //  [R1]
         { info_tbl: [(caemg,
                       label: block_caemg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caemg: // global
           P64[Sp - 40] = P64[Sp + 8];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 8] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 40;
           call _caekz() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.092156065 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDevice_closure" {
     GHC.IO.Handle.Internals.readTextDevice_closure:
         const GHC.IO.Handle.Internals.readTextDevice_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDevice_entry() //  [R2, R3]
         { info_tbl: [(caesg,
                       label: GHC.IO.Handle.Internals.readTextDevice_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caesg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.096300946 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_1_closure" {
     GHC.IO.Handle.Internals.hLookAhead_1_closure:
         const GHC.IO.Handle.Internals.hLookAhead_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_1_entry() //  [R2]
         { info_tbl: [(caesu,
                       label: GHC.IO.Handle.Internals.hLookAhead_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caesu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caesy; else goto caesz;
       caesy: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caesz: // global
           I64[Sp - 8] = block_caesr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaet5; else goto caess;
       uaet5: // global
           call _caesr(R1) args: 0, res: 0, upd: 0;
       caess: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caesr() //  [R1]
         { info_tbl: [(caesr,
                       label: block_caesr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caesr: // global
           I64[Sp - 16] = block_caesx_info;
           _sacZC::P64 = R1;
           _sacZL::P64 = P64[R1 + 71];
           R1 = P64[_sacZL::P64 + 8];
           P64[Sp - 8] = _sacZL::P64;
           P64[Sp] = _sacZC::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaet4; else goto caesB;
       uaet4: // global
           call _caesx(R1) args: 0, res: 0, upd: 0;
       caesB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caesx() //  [R1]
         { info_tbl: [(caesx,
                       label: block_caesx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caesx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caesH; else goto caesG;
       caesH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caesG: // global
           _sacZY::P64 = P64[R1 + 7];
           _sacZX::I64 = I64[R1 + 23];
           _sad01::I64 = I64[R1 + 39];
           if (_sad01::I64 == I64[R1 + 47]) goto caet0; else goto caesR;
       caet0: // global
           Hp = Hp - 16;
           I64[Sp - 16] = block_caesT_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = _sad01::I64;
           P64[Sp] = _sacZY::P64;
           I64[Sp + 16] = _sacZX::I64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       caesR: // global
           _sacZL::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacZL::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacZL::P64);
           _sad07::I64 = %MO_UU_Conv_W32_W64(I32[_sacZX::I64 + (_sad01::I64 << 2)]);
           call MO_Touch(_sacZY::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sad07::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caesT() //  [R1]
         { info_tbl: [(caesT,
                       label: block_caesT_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caesT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caet3; else goto caet2;
       caet3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caet2: // global
           _sacZL::P64 = P64[Sp + 24];
           _sacZX::I64 = I64[Sp + 32];
           _sacZY::P64 = P64[Sp + 16];
           _sad01::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacZL::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacZL::P64);
           _sad0g::I64 = %MO_UU_Conv_W32_W64(I32[_sacZX::I64 + (_sad01::I64 << 2)]);
           call MO_Touch(_sacZY::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sad0g::I64;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.107479718 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead__closure" {
     GHC.IO.Handle.Internals.hLookAhead__closure:
         const GHC.IO.Handle.Internals.hLookAhead__info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead__entry() //  [R2]
         { info_tbl: [(caetz,
                       label: GHC.IO.Handle.Internals.hLookAhead__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caetz: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.110864514 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help2_closure" {
     GHC.IO.Handle.Internals.hClose_help2_closure:
         const GHC.IO.Handle.Internals.hClose_help2_info;
 },
 GHC.IO.Handle.Internals.hClose_help2_entry() //  [R2]
         { info_tbl: [(caetL,
                       label: GHC.IO.Handle.Internals.hClose_help2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caetL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caetP; else goto caetO;
       caetP: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caetO: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.11856257 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help1_closure" {
     GHC.IO.Handle.Internals.hClose_help1_closure:
         const GHC.IO.Handle.Internals.hClose_help1_info;
         const 0;
 },
 sat_sad17_entry() //  [R1]
         { info_tbl: [(caeui,
                       label: sat_sad17_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeui: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeuj; else goto caeuk;
       caeuj: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeuk: // global
           I64[Sp - 32] = block_caeuf_info;
           _sad0q::P64 = P64[R1 + 7];
           _sad0s::P64 = P64[R1 + 15];
           _sad0u::P64 = P64[R1 + 23];
           R1 = P64[_sad0u::P64 + 8];
           P64[Sp - 24] = _sad0q::P64;
           P64[Sp - 16] = _sad0s::P64;
           P64[Sp - 8] = _sad0u::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeuW; else goto caeug;
       uaeuW: // global
           call _caeuf(R1) args: 0, res: 0, upd: 0;
       caeug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeuf() //  [R1]
         { info_tbl: [(caeuf,
                       label: block_caeuf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeuf: // global
           I64[Sp] = block_caeun_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaeuV; else goto caeup;
       uaeuV: // global
           call _caeun(R1) args: 0, res: 0, upd: 0;
       caeup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeun() //  [R1]
         { info_tbl: [(caeun,
                       label: block_caeun_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeun: // global
           if (R1 & 7 == 1) goto uaeuT; else goto caeuA;
       uaeuT: // global
           Sp = Sp + 32;
           call _caeuO() args: 0, res: 0, upd: 0;
       caeuA: // global
           _sad0U::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_caeuy_info;
           R1 = _sad0U::P64;
           if (R1 & 7 != 0) goto uaeuX; else goto caeuB;
       uaeuX: // global
           call _caeuy(R1) args: 0, res: 0, upd: 0;
       caeuB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeuy() //  [R1]
         { info_tbl: [(caeuy,
                       label: block_caeuy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeuy: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uaeuU; else goto caeuL;
       uaeuU: // global
           Sp = Sp + 32;
           call _caeuO() args: 0, res: 0, upd: 0;
       caeuL: // global
           _sad0s::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caeuJ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sad0s::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _caeuO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeuO: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caeuJ() //  [R1]
         { info_tbl: [(caeuJ,
                       label: block_caeuJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeuJ: // global
           _sad0u::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sad0u::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad0u::P64);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sad1n_entry() //  [R1]
         { info_tbl: [(caevB,
                       label: sat_sad1n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caevB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caevC; else goto caevD;
       caevC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caevD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caevu_info;
           _sad1d::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sad1d::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaevK; else goto caevv;
       uaevK: // global
           call _caevu(R1) args: 0, res: 0, upd: 0;
       caevv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caevu() //  [R1]
         { info_tbl: [(caevu,
                       label: block_caevu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caevu: // global
           if (R1 & 7 == 1) goto caevy; else goto caevz;
       caevy: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caevz: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sad1C_entry() //  [R1]
         { info_tbl: [(caew5,
                       label: sat_sad1C_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caew5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caew6; else goto caew7;
       caew6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caew7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caevY_info;
           _sad1d::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sad1d::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaewe; else goto caevZ;
       uaewe: // global
           call _caevY(R1) args: 0, res: 0, upd: 0;
       caevZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caevY() //  [R1]
         { info_tbl: [(caevY,
                       label: block_caevY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caevY: // global
           if (R1 & 7 == 1) goto caew2; else goto caew3;
       caew2: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caew3: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sad1U_entry() //  [R1]
         { info_tbl: [(caewr,
                       label: sat_sad1U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caewr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caews; else goto caewt;
       caews: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caewt: // global
           I64[Sp - 8] = block_caewp_info;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.IO.Device.close_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _caewp() //  []
         { info_tbl: [(caewp,
                       label: block_caewp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caewp: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.hClose_help1_entry() //  [R2]
         { info_tbl: [(caewv,
                       label: GHC.IO.Handle.Internals.hClose_help1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caewv: // global
           if ((Sp + -144) < SpLim) (likely: False) goto caeww; else goto caewx;
       caeww: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caewx: // global
           I64[Sp - 8] = block_caeu0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaexM; else goto caeu1;
       uaexM: // global
           call _caeu0(R1) args: 0, res: 0, upd: 0;
       caeu1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeu0() //  [R1]
         { info_tbl: [(caeu0,
                       label: block_caeu0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeu0: // global
           I64[Sp - 128] = block_caeu5_info;
           _sad0o::P64 = R1;
           _sad0p::P64 = P64[R1 + 7];
           _sad0q::P64 = P64[R1 + 15];
           _sad0r::P64 = P64[R1 + 23];
           _sad0s::P64 = P64[R1 + 31];
           _sad0u::P64 = P64[R1 + 47];
           _sad0v::P64 = P64[R1 + 55];
           _sad0w::P64 = P64[R1 + 63];
           _sad0x::P64 = P64[R1 + 71];
           _sad0y::P64 = P64[R1 + 79];
           _sad0z::P64 = P64[R1 + 87];
           _sad0A::P64 = P64[R1 + 95];
           _sad0B::P64 = P64[R1 + 103];
           _sad0C::P64 = P64[R1 + 111];
           _sad0D::P64 = P64[R1 + 119];
           _sad0E::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sad0p::P64;
           P64[Sp - 112] = _sad0q::P64;
           P64[Sp - 104] = _sad0r::P64;
           P64[Sp - 96] = _sad0s::P64;
           P64[Sp - 88] = _sad0u::P64;
           P64[Sp - 80] = _sad0v::P64;
           P64[Sp - 72] = _sad0w::P64;
           P64[Sp - 64] = _sad0x::P64;
           P64[Sp - 56] = _sad0y::P64;
           P64[Sp - 48] = _sad0z::P64;
           P64[Sp - 40] = _sad0A::P64;
           P64[Sp - 32] = _sad0B::P64;
           P64[Sp - 24] = _sad0C::P64;
           P64[Sp - 16] = _sad0D::P64;
           P64[Sp - 8] = _sad0E::P64;
           P64[Sp] = _sad0o::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto uaexI; else goto caeu6;
       uaexI: // global
           call _caeu5(R1) args: 0, res: 0, upd: 0;
       caeu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeu5() //  [R1]
         { info_tbl: [(caeu5,
                       label: block_caeu5_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeu5: // global
           if (R1 & 7 == 1) goto caexw; else goto caewA;
       caexw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caexz; else goto caexy;
       caexz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caexy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caewA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caewD; else goto caewC;
       caewD: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caewC: // global
           I64[Hp - 24] = sat_sad17_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_caev0_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caev0() //  [R1]
         { info_tbl: [(caev0,
                       label: block_caev0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caev0: // global
           I64[Sp] = block_caewf_info;
           _sad1a::P64 = R1;
           R1 = P64[Sp + 120];
           P64[Sp + 128] = _sad1a::P64;
           if (R1 & 7 != 0) goto uaexJ; else goto caewg;
       uaexJ: // global
           call _caewf(R1) args: 0, res: 0, upd: 0;
       caewg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caewf() //  [R1]
         { info_tbl: [(caewf,
                       label: block_caewf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caewf: // global
           if (R1 & 7 == 1) goto caexj; else goto caexs;
       caexj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caexm; else goto caexl;
       caexm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caexl: // global
           I64[Hp - 16] = sat_sad1U_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_caexh_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       caexs: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _sad1b() args: 0, res: 0, upd: 0;
     }
 },
 _caexh() //  [R1]
         { info_tbl: [(caexh,
                       label: block_caexh_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caexh: // global
           P64[Sp] = R1;
           call _sad1b() args: 0, res: 0, upd: 0;
     }
 },
 _sad1b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sad1b: // global
           _sad0u::P64 = P64[Sp + 40];
           _sad0x::P64 = P64[Sp + 64];
           _sad0y::P64 = P64[Sp + 72];
           _sad0A::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sad0y::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad0y::P64);
           call MO_WriteBarrier();
           P64[_sad0x::P64 + 8] = GHC.IO.Handle.Internals.noCharBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad0x::P64);
           call MO_WriteBarrier();
           P64[_sad0u::P64 + 8] = GHC.IO.Handle.Internals.noByteBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad0u::P64);
           I64[Sp - 8] = block_caewF_info;
           R1 = _sad0A::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaexR; else goto caewX;
       uaexR: // global
           call _caewF(R1) args: 0, res: 0, upd: 0;
       caewX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caewF() //  [R1]
         { info_tbl: [(caewF,
                       label: block_caewF_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caewF: // global
           if (R1 & 7 == 1) goto uaexG; else goto caexd;
       uaexG: // global
           Sp = Sp + 8;
           call _sad1h() args: 0, res: 0, upd: 0;
       caexd: // global
           I64[Sp] = block_caex6_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaexN; else goto caex7;
       uaexN: // global
           call _caex6(R1) args: 0, res: 0, upd: 0;
       caex7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caex6() //  [R1]
         { info_tbl: [(caex6,
                       label: block_caex6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caex6: // global
           I64[Sp] = block_caexb_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caexb() //  []
         { info_tbl: [(caexb,
                       label: block_caexb_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caexb: // global
           Sp = Sp + 8;
           call _sad1h() args: 0, res: 0, upd: 0;
     }
 },
 _sad1h() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sad1h: // global
           I64[Sp - 8] = block_caevl_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaexS; else goto caevm;
       uaexS: // global
           call _caevl(R1) args: 0, res: 0, upd: 0;
       caevm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caevl() //  [R1]
         { info_tbl: [(caevl,
                       label: block_caevl_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caevl: // global
           if (R1 & 7 == 1) goto caewL; else goto caewS;
       caewL: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto caewO; else goto caewN;
       caewO: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caewN: // global
           I64[Hp - 184] = sat_sad1n_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = GHC.Base.Nothing_closure+1;
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caewS: // global
           I64[Sp] = block_caevN_info;
           _sad1j::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 88] = _sad1j::P64;
           if (R1 & 7 != 0) goto uaexK; else goto caevO;
       uaexK: // global
           call _caevN(R1) args: 0, res: 0, upd: 0;
       caevO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caevN() //  [R1]
         { info_tbl: [(caevN,
                       label: block_caevN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caevN: // global
           I64[Sp] = block_caevS_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caevS() //  [R1]
         { info_tbl: [(caevS,
                       label: block_caevS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caevS: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto caewW; else goto caewV;
       caewW: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caewV: // global
           I64[Hp - 184] = sat_sad1C_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.171249046 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help_closure" {
     GHC.IO.Handle.Internals.hClose_help_closure:
         const GHC.IO.Handle.Internals.hClose_help_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hClose_help_entry() //  [R2]
         { info_tbl: [(caeBu,
                       label: GHC.IO.Handle.Internals.hClose_help_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeBu: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.175161311 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer1_closure" {
     GHC.IO.Handle.Internals.handleFinalizer1_closure:
         const GHC.IO.Handle.Internals.handleFinalizer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer1_entry() //  [R2, R3]
         { info_tbl: [(caeBI,
                       label: GHC.IO.Handle.Internals.handleFinalizer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeBI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeBV; else goto caeBW;
       caeBV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.handleFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caeBW: // global
           I64[Sp - 8] = block_caeBF_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaeC3; else goto caeBG;
       uaeC3: // global
           call _caeBF(R1) args: 0, res: 0, upd: 0;
       caeBG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeBF() //  [R1]
         { info_tbl: [(caeBF,
                       label: block_caeBF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeBF: // global
           I64[Sp - 8] = block_caeBL_info;
           _sad24::P64 = P64[R1 + 7];
           R1 = _sad24::P64;
           P64[Sp] = _sad24::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeBL() //  [R1]
         { info_tbl: [(caeBL,
                       label: block_caeBL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeBL: // global
           I64[Sp] = block_caeBN_info;
           R2 = R1;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeBN() //  [R1]
         { info_tbl: [(caeBN,
                       label: block_caeBN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeBN: // global
           I64[Sp] = block_caeBP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeC4; else goto caeBQ;
       uaeC4: // global
           call _caeBP(R1) args: 0, res: 0, upd: 0;
       caeBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeBP() //  [R1]
         { info_tbl: [(caeBP,
                       label: block_caeBP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeBP: // global
           _sad24::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeBU_info;
           R2 = P64[R1 + 7];
           R1 = _sad24::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeBU() //  []
         { info_tbl: [(caeBU,
                       label: block_caeBU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeBU: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.187157647 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer_closure" {
     GHC.IO.Handle.Internals.handleFinalizer_closure:
         const GHC.IO.Handle.Internals.handleFinalizer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer_entry() //  [R2, R3]
         { info_tbl: [(caeCC,
                       label: GHC.IO.Handle.Internals.handleFinalizer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeCC: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.handleFinalizer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.190398903 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle4_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.192846354 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle1_closure" {
     GHC.IO.Handle.Internals.mkFileHandle1_closure:
         const GHC.IO.Handle.Internals.mkFileHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeCL: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sad2p_entry() //  [R1]
         { info_tbl: [(caeD2,
                       label: sat_sad2p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeD2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caeD3; else goto caeD4;
       caeD3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeD4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caeCT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeDj; else goto caeCU;
       uaeDj: // global
           call _caeCT(R1) args: 0, res: 0, upd: 0;
       caeCU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caeCT() //  [R1]
         { info_tbl: [(caeCT,
                       label: block_caeCT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeCT: // global
           _caeD1::P64 = R1 & 7;
           if (_caeD1::P64 < 3) goto uaeDh; else goto uaeDi;
       uaeDh: // global
           if (_caeD1::P64 < 2) goto caeCX; else goto caeCY;
       caeCX: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caeCY: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaeDi: // global
           if (_caeD1::P64 < 4) goto caeCZ; else goto caeD0;
       caeCZ: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caeD0: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { info_tbl: [(caeDk,
                       label: GHC.IO.Handle.Internals.mkFileHandle1_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeDk: // global
           _sad2j::P64 = R6;
           _sad2i::P64 = R5;
           _sad2h::P64 = R4;
           _sad2g::P64 = R3;
           _sad2f::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto caeDl; else goto caeDm;
       caeDm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeDo; else goto caeDn;
       caeDo: // global
           HpAlloc = 24;
           goto caeDl;
       caeDl: // global
           R1 = GHC.IO.Handle.Internals.mkFileHandle1_closure;
           P64[Sp - 40] = _sad2f::P64;
           P64[Sp - 32] = _sad2g::P64;
           P64[Sp - 24] = _sad2h::P64;
           P64[Sp - 16] = _sad2i::P64;
           P64[Sp - 8] = _sad2j::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caeDn: // global
           I64[Hp - 16] = sat_sad2p_info;
           P64[Hp] = P64[Sp];
           R6 = _sad2j::P64;
           R5 = _sad2i::P64;
           R4 = _sad2h::P64;
           R3 = _sad2g::P64;
           R2 = _sad2f::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = GHC.Types.True_closure+2;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 8] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.203909682 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle_closure" {
     GHC.IO.Handle.Internals.mkFileHandle_closure:
         const GHC.IO.Handle.Internals.mkFileHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeE0: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(caeE4,
                       label: GHC.IO.Handle.Internals.mkFileHandle_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeE4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.20850326 UTC

[section ""cstring" . lvl23_ra7PD_bytes" {
     lvl23_ra7PD_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,54,58,51,45,51,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.210715401 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle3_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle3_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle3_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle3_entry() //  []
         { info_tbl: [(caeEk,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeEk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caeEl; else goto caeEm;
       caeEl: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeEm: // global
           I64[Sp - 8] = block_caeEi_info;
           R2 = lvl23_ra7PD_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeEi() //  [R1]
         { info_tbl: [(caeEi,
                       label: block_caeEi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeEi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.215756761 UTC

[section ""cstring" . lvl24_ra7PE_bytes" {
     lvl24_ra7PE_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,48,58,51,45,51,53]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.21769293 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle2_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle2_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle2_entry() //  []
         { info_tbl: [(caeEG,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeEG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caeEH; else goto caeEI;
       caeEH: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeEI: // global
           I64[Sp - 8] = block_caeEE_info;
           R2 = lvl24_ra7PE_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeEE() //  [R1]
         { info_tbl: [(caeEE,
                       label: block_caeEE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeEE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.223860828 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle1_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle1_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeEW: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { info_tbl: [(caeF9,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle1_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeF9: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caeFa; else goto caeFb;
       caeFa: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       caeFb: // global
           I64[Sp - 48] = block_caeF0_info;
           _sad2y::P64 = R6;
           R6 = R6;
           _sad2x::P64 = R5;
           R5 = R5;
           _sad2w::P64 = R4;
           R4 = R4;
           _sad2v::P64 = R3;
           R3 = R3;
           _sad2u::P64 = R2;
           R2 = R2;
           P64[Sp - 96] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 88] = GHC.Types.True_closure+2;
           P64[Sp - 80] = P64[Sp];
           P64[Sp - 72] = P64[Sp + 8];
           P64[Sp - 64] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp - 56] = GHC.Base.Nothing_closure+1;
           P64[Sp - 40] = _sad2u::P64;
           P64[Sp - 32] = _sad2v::P64;
           P64[Sp - 24] = _sad2w::P64;
           P64[Sp - 16] = _sad2x::P64;
           P64[Sp - 8] = _sad2y::P64;
           Sp = Sp - 96;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
     }
 },
 _caeF0() //  [R1]
         { info_tbl: [(caeF0,
                       label: block_caeF0_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeF0: // global
           I64[Sp] = block_caeF2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeFG; else goto caeF3;
       uaeFG: // global
           call _caeF2(R1) args: 0, res: 0, upd: 0;
       caeF3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeF2() //  [R1]
         { info_tbl: [(caeF2,
                       label: block_caeF2_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeF2: // global
           if (R1 & 7 == 1) goto caeF6; else goto caeF7;
       caeF6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caeFm; else goto caeFl;
       caeFm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeFl: // global
           _sad2H::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = _sad2H::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           _sad2x::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_caeFh_info;
           R6 = P64[Sp + 40];
           R5 = _sad2x::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp - 16] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 8] = P64[Sp + 56];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = Hp - 6;
           P64[Sp + 56] = _sad2H::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
       caeF7: // global
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.mkDuplexHandle2_entry() args: 8, res: 0, upd: 8;
     }
 },
 _caeFh() //  [R1]
         { info_tbl: [(caeFh,
                       label: block_caeFh_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeFh: // global
           I64[Sp] = block_caeFj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeFH; else goto caeFo;
       uaeFH: // global
           call _caeFj(R1) args: 0, res: 0, upd: 0;
       caeFo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeFj() //  [R1]
         { info_tbl: [(caeFj,
                       label: block_caeFj_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeFj: // global
           if (R1 & 7 == 1) goto caeFu; else goto caeFB;
       caeFu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caeFx; else goto caeFw;
       caeFx: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeFw: // global
           _sad2P::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sad2P::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caeFB: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle3_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.238241996 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeGB: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(caeGF,
                       label: GHC.IO.Handle.Internals.mkDuplexHandle_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeGF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.244335001 UTC

[section ""data" . $wlvl_ra7PF_closure" {
     $wlvl_ra7PF_closure:
         const $wlvl_ra7PF_info;
         const 0;
 },
 sat_sad3d_entry() //  [R1]
         { info_tbl: [(caeH7,
                       label: sat_sad3d_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeH7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeH8; else goto caeH9;
       caeH8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeH9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caeH0_info;
           _sad32::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sad32::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeHA; else goto caeH1;
       uaeHA: // global
           call _caeH0(R1) args: 0, res: 0, upd: 0;
       caeH1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caeH0() //  [R1]
         { info_tbl: [(caeH0,
                       label: block_caeH0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeH0: // global
           if (R1 & 7 == 1) goto caeH4; else goto caeH5;
       caeH4: // global
           _sad32::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeHc_info;
           R1 = _sad32::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaeHz; else goto caeHe;
       uaeHz: // global
           call _caeHc(R1) args: 0, res: 0, upd: 0;
       caeHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caeH5: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _caeHc() //  [R1]
         { info_tbl: [(caeHc,
                       label: block_caeHc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeHc: // global
           if (R1 & 7 == 1) goto caeHk; else goto caeHr;
       caeHk: // global
           Hp = Hp + 16;
           _sad36::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caeHu; else goto caeHm;
       caeHm: // global
           _sad37::P64 = P64[_sad36::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sad37::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caeHr: // global
           Hp = Hp + 16;
           _sad36::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caeHu; else goto caeHt;
       caeHu: // global
           HpAlloc = 16;
           R1 = _sad36::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caeHt: // global
           _sad39::P64 = P64[_sad36::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sad39::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sad3f_entry() //  [R1]
         { info_tbl: [(caeHD,
                       label: sat_sad3f_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeHD: // global
           _sad3f::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeHE; else goto caeHF;
       caeHF: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caeHH; else goto caeHG;
       caeHH: // global
           HpAlloc = 104;
           goto caeHE;
       caeHE: // global
           R1 = _sad3f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeHG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sad3f::P64;
           _sad2X::P64 = P64[_sad3f::P64 + 16];
           _sad2Y::P64 = P64[_sad3f::P64 + 24];
           _sad2Z::P64 = P64[_sad3f::P64 + 32];
           _sad30::P64 = P64[_sad3f::P64 + 40];
           _sad31::P64 = P64[_sad3f::P64 + 48];
           _sad32::P64 = P64[_sad3f::P64 + 56];
           I64[Hp - 96] = sat_sad3d_info;
           P64[Hp - 80] = _sad30::P64;
           P64[Hp - 72] = _sad32::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sad32::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sad2X::P64;
           P64[Hp - 24] = _sad31::P64;
           P64[Hp - 16] = _sad2Y::P64;
           P64[Hp - 8] = _sad2Z::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_ra7PF_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caeHI,
                       label: $wlvl_ra7PF_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeHI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caeHM; else goto caeHL;
       caeHM: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_ra7PF_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caeHL: // global
           I64[Hp - 56] = sat_sad3f_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 56;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.258489735 UTC

[section ""data" . GHC.IO.Handle.Internals.$wdo_operation_closure" {
     GHC.IO.Handle.Internals.$wdo_operation_closure:
         const GHC.IO.Handle.Internals.$wdo_operation_info;
         const 0;
 },
 sat_sad3K_entry() //  [R1, R2]
         { info_tbl: [(caeIK,
                       label: sat_sad3K_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeIK: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caeIO; else goto caeIP;
       caeIO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeIP: // global
           I64[Sp - 48] = block_caeIF_info;
           _sad3p::P64 = R2;
           R2 = P64[R1 + 38];
           _sad3g::P64 = P64[R1 + 6];
           _sad3h::P64 = P64[R1 + 14];
           _sad3i::P64 = P64[R1 + 22];
           _sad3j::P64 = P64[R1 + 30];
           R1 = _sad3j::P64;
           P64[Sp - 40] = _sad3g::P64;
           P64[Sp - 32] = _sad3h::P64;
           P64[Sp - 24] = _sad3i::P64;
           P64[Sp - 16] = _sad3j::P64;
           P64[Sp - 8] = _sad3p::P64;
           Sp = Sp - 48;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeIF() //  []
         { info_tbl: [(caeIF,
                       label: block_caeIF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeIF: // global
           I64[Sp] = block_caeIH_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto uaeJx; else goto caeII;
       uaeJx: // global
           call _caeIH(R1) args: 0, res: 0, upd: 0;
       caeII: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeIH() //  [R1]
         { info_tbl: [(caeIH,
                       label: block_caeIH_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeIH: // global
           I64[Sp - 16] = block_caeIN_info;
           _sad3t::P64 = P64[R1 + 7];
           R2 = _sad3t::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sad3t::P64;
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeIN() //  [R1]
         { info_tbl: [(caeIN,
                       label: block_caeIN_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeIN: // global
           I64[Sp] = block_caeIV_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeIV() //  [R1]
         { info_tbl: [(caeIV,
                       label: block_caeIV_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeIV: // global
           if (R1 & 7 == 1) goto caeJ3; else goto caeJq;
       caeJ3: // global
           _sad3t::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caeJ0_info;
           R2 = _sad3t::P64;
           Sp = Sp + 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       caeJq: // global
           I64[Sp + 16] = block_caeJo_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeJ0() //  [R1]
         { info_tbl: [(caeJ0,
                       label: block_caeJ0_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeJ0: // global
           I64[Sp] = block_caeJ7_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeJ7() //  [R1]
         { info_tbl: [(caeJ7,
                       label: block_caeJ7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeJ7: // global
           _sad3s::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto caeJe; else goto caeJj;
       caeJe: // global
           R1 = _sad3s::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caeJj: // global
           I64[Sp] = block_caeJh_info;
           R2 = _sad3s::P64;
           R1 = CurrentTSO;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeJh() //  []
         { info_tbl: [(caeJh,
                       label: block_caeJh_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeJh: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _caeJo() //  [R1]
         { info_tbl: [(caeJo,
                       label: block_caeJo_info
                       rep:StackRep [False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeJo: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 47];
           R4 = P64[R1 + 39];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 15];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 40;
           call $wlvl_ra7PF_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wdo_operation_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caeJy,
                       label: GHC.IO.Handle.Internals.$wdo_operation_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeJy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caeJz; else goto caeJA;
       caeJz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wdo_operation_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeJA: // global
           I64[Sp - 40] = block_caeIw_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeIw() //  [R1]
         { info_tbl: [(caeIw,
                       label: block_caeIw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeIw: // global
           I64[Sp - 8] = block_caeIy_info;
           R2 = R1;
           _sad3n::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _sad3n::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeIy() //  [R1]
         { info_tbl: [(caeIy,
                       label: block_caeIy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeIy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caeJE; else goto caeJD;
       caeJE: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeJD: // global
           I64[Hp - 40] = sat_sad3K_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 38;
           R1 = R1;
           Sp = Sp + 48;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.282967009 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_1_closure" {
     GHC.IO.Handle.Internals.withHandle_1_closure:
         const GHC.IO.Handle.Internals.withHandle_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caeKM,
                       label: GHC.IO.Handle.Internals.withHandle_1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeKM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeKN; else goto caeKO;
       caeKN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeKO: // global
           I64[Sp - 32] = block_caeKJ_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeKS; else goto caeKK;
       uaeKS: // global
           call _caeKJ(R1) args: 0, res: 0, upd: 0;
       caeKK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeKJ() //  [R1]
         { info_tbl: [(caeKJ,
                       label: block_caeKJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeKJ: // global
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.289360395 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle__'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle__'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle__'_info;
         const 0;
 },
 sat_sad4a_entry() //  [R1]
         { info_tbl: [(caeLl,
                       label: sat_sad4a_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeLl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeLm; else goto caeLn;
       caeLm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeLn: // global
           I64[Sp - 16] = block_caeLh_info;
           _sad3U::P64 = P64[R1 + 23];
           R5 = _sad3U::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad3U::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeLh() //  [R1]
         { info_tbl: [(caeLh,
                       label: block_caeLh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeLh: // global
           _sad3U::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeLj_info;
           R2 = R1;
           R1 = _sad3U::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeLj() //  []
         { info_tbl: [(caeLj,
                       label: block_caeLj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeLj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwithHandle__'_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(caeLt,
                       label: GHC.IO.Handle.Internals.$wwithHandle__'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeLt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeLu; else goto caeLv;
       caeLu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle__'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeLv: // global
           I64[Sp - 40] = block_caeL7_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caeL7() //  [R1]
         { info_tbl: [(caeL7,
                       label: block_caeL7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeL7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeLy; else goto caeLx;
       caeLy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeLx: // global
           _sad3S::P64 = P64[Sp + 8];
           _sad3T::P64 = P64[Sp + 16];
           _sad3U::P64 = P64[Sp + 24];
           _sad3V::P64 = P64[Sp + 32];
           if (R1 == 0) goto caeLs; else goto caeLr;
       caeLs: // global
           I64[Hp - 32] = sat_sad4a_info;
           P64[Hp - 24] = _sad3S::P64;
           P64[Hp - 16] = _sad3T::P64;
           P64[Hp - 8] = _sad3U::P64;
           P64[Hp] = _sad3V::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeLr: // global
           Hp = Hp - 40;
           I64[Sp + 16] = block_caeLz_info;
           R5 = _sad3U::P64;
           R4 = _sad3V::P64;
           R3 = _sad3T::P64;
           R2 = _sad3S::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeLz() //  [R1]
         { info_tbl: [(caeLz,
                       label: block_caeLz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeLz: // global
           I64[Sp + 16] = block_caeLB_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeLB() //  []
         { info_tbl: [(caeLB,
                       label: block_caeLB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeLB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.30387466 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'1_closure" {
     GHC.IO.Handle.Internals.withHandle__'1_closure:
         const GHC.IO.Handle.Internals.withHandle__'1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caeMk,
                       label: GHC.IO.Handle.Internals.withHandle__'1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeMk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeMl; else goto caeMm;
       caeMl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle__'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeMm: // global
           I64[Sp - 32] = block_caeMh_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeMq; else goto caeMi;
       uaeMq: // global
           call _caeMh(R1) args: 0, res: 0, upd: 0;
       caeMi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeMh() //  [R1]
         { info_tbl: [(caeMh,
                       label: block_caeMh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeMh: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.309840241 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'_closure" {
     GHC.IO.Handle.Internals.withHandle__'_closure:
         const GHC.IO.Handle.Internals.withHandle__'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caeMF,
                       label: GHC.IO.Handle.Internals.withHandle__'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeMF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle__'1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.314975435 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles__1_closure" {
     GHC.IO.Handle.Internals.withAllHandles__1_closure:
         const GHC.IO.Handle.Internals.withAllHandles__1_info;
         const 0;
 },
 sat_sad4C_entry() //  [R1]
         { info_tbl: [(caeN9,
                       label: sat_sad4C_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeN9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeNa; else goto caeNb;
       caeNa: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeNb: // global
           I64[Sp - 16] = block_caeN5_info;
           _sad4o::P64 = P64[R1 + 31];
           R5 = _sad4o::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad4o::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeN5() //  [R1]
         { info_tbl: [(caeN5,
                       label: block_caeN5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeN5: // global
           _sad4o::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeN7_info;
           R2 = R1;
           R1 = _sad4o::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeN7() //  []
         { info_tbl: [(caeN7,
                       label: block_caeN7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeN7: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sad4Y_entry() //  [R1]
         { info_tbl: [(caeNB,
                       label: sat_sad4Y_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeNB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeNC; else goto caeND;
       caeNC: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeND: // global
           I64[Sp - 16] = block_caeNx_info;
           _sad4F::P64 = P64[R1 + 31];
           R5 = _sad4F::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad4F::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeNx() //  [R1]
         { info_tbl: [(caeNx,
                       label: block_caeNx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeNx: // global
           _sad4F::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeNz_info;
           R2 = R1;
           R1 = _sad4F::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeNz() //  []
         { info_tbl: [(caeNz,
                       label: block_caeNz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeNz: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sad59_entry() //  [R1]
         { info_tbl: [(caeNS,
                       label: sat_sad59_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeNS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeNT; else goto caeNU;
       caeNT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeNU: // global
           I64[Sp - 16] = block_caeNO_info;
           _sad4E::P64 = P64[R1 + 31];
           R5 = _sad4E::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad4E::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeNO() //  [R1]
         { info_tbl: [(caeNO,
                       label: block_caeNO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeNO: // global
           _sad4E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeNQ_info;
           R2 = R1;
           R1 = _sad4E::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeNQ() //  []
         { info_tbl: [(caeNQ,
                       label: block_caeNQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeNQ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.withAllHandles__1_entry() //  [R2, R3, R4]
         { info_tbl: [(caeO1,
                       label: GHC.IO.Handle.Internals.withAllHandles__1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeO1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caeO2; else goto caeO3;
       caeO2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withAllHandles__1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeO3: // global
           I64[Sp - 24] = block_caeMQ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeOK; else goto caeMR;
       uaeOK: // global
           call _caeMQ(R1) args: 0, res: 0, upd: 0;
       caeMR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeMQ() //  [R1]
         { info_tbl: [(caeMQ,
                       label: block_caeMQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeMQ: // global
           if (R1 & 7 == 1) goto caeNY; else goto caeNZ;
       caeNY: // global
           I64[Sp - 16] = block_caeMV_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caeNZ: // global
           I64[Sp - 24] = block_caeNg_info;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caeMV() //  [R1]
         { info_tbl: [(caeMV,
                       label: block_caeMV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeMV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeO7; else goto caeO6;
       caeO7: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeO6: // global
           _sad4i::P64 = P64[Sp + 24];
           _sad4k::P64 = P64[Sp + 32];
           _sad4m::P64 = P64[Sp + 16];
           _sad4o::P64 = P64[Sp + 8];
           if (R1 == 0) goto caeOg; else goto caeOc;
       caeOg: // global
           I64[Hp - 32] = sat_sad4C_info;
           P64[Hp - 24] = _sad4i::P64;
           P64[Hp - 16] = _sad4k::P64;
           P64[Hp - 8] = _sad4m::P64;
           P64[Hp] = _sad4o::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeOc: // global
           Hp = Hp - 40;
           I64[Sp] = block_caeO8_info;
           R5 = _sad4o::P64;
           R4 = _sad4k::P64;
           R3 = _sad4m::P64;
           R2 = _sad4i::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeO8() //  [R1]
         { info_tbl: [(caeO8,
                       label: block_caeO8_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeO8: // global
           I64[Sp + 32] = block_caeOr_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeNg() //  [R1]
         { info_tbl: [(caeNg,
                       label: block_caeNg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeNg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeOk; else goto caeOj;
       caeOk: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeOj: // global
           _sad4i::P64 = P64[Sp + 32];
           _sad4k::P64 = P64[Sp + 40];
           _sad4m::P64 = P64[Sp + 24];
           _sad4E::P64 = P64[Sp + 8];
           if (R1 == 0) goto caeOH; else goto caeOC;
       caeOH: // global
           I64[Hp - 32] = sat_sad59_info;
           P64[Hp - 24] = _sad4i::P64;
           P64[Hp - 16] = _sad4k::P64;
           P64[Hp - 8] = _sad4m::P64;
           P64[Hp] = _sad4E::P64;
           I64[Sp + 8] = block_caeOG_info;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       caeOC: // global
           Hp = Hp - 40;
           I64[Sp] = block_caeOy_info;
           R5 = _sad4E::P64;
           R4 = _sad4k::P64;
           R3 = _sad4m::P64;
           R2 = _sad4i::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeOG() //  []
         { info_tbl: [(caeOG,
                       label: block_caeOG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeOG: // global
           call _sad4J() args: 0, res: 0, upd: 0;
     }
 },
 _caeOy() //  [R1]
         { info_tbl: [(caeOy,
                       label: block_caeOy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeOy: // global
           _sad4E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_sad4J_info;
           R2 = R1;
           R1 = _sad4E::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _sad4J() //  []
         { info_tbl: [(sad4J,
                       label: block_sad4J_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sad4J: // global
           I64[Sp] = block_caeNn_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caeNn() //  [R1]
         { info_tbl: [(caeNn,
                       label: block_caeNn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeNn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeOo; else goto caeOn;
       caeOo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeOn: // global
           _sad4i::P64 = P64[Sp + 24];
           _sad4k::P64 = P64[Sp + 32];
           _sad4m::P64 = P64[Sp + 16];
           _sad4F::P64 = P64[Sp + 8];
           if (R1 == 0) goto caeOx; else goto caeOt;
       caeOx: // global
           I64[Hp - 32] = sat_sad4Y_info;
           P64[Hp - 24] = _sad4i::P64;
           P64[Hp - 16] = _sad4k::P64;
           P64[Hp - 8] = _sad4m::P64;
           P64[Hp] = _sad4F::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeOt: // global
           Hp = Hp - 40;
           I64[Sp] = block_caeOp_info;
           R5 = _sad4F::P64;
           R4 = _sad4k::P64;
           R3 = _sad4m::P64;
           R2 = _sad4i::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeOp() //  [R1]
         { info_tbl: [(caeOp,
                       label: block_caeOp_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeOp: // global
           I64[Sp + 32] = block_caeOr_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeOr() //  []
         { info_tbl: [(caeOr,
                       label: block_caeOr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeOr: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.352781754 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles___closure" {
     GHC.IO.Handle.Internals.withAllHandles___closure:
         const GHC.IO.Handle.Internals.withAllHandles___info;
         const 0;
 },
 GHC.IO.Handle.Internals.withAllHandles___entry() //  [R2, R3, R4]
         { info_tbl: [(caeQr,
                       label: GHC.IO.Handle.Internals.withAllHandles___info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeQr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.357818757 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle'_info;
         const 0;
 },
 io_sad5l_entry() //  [R1]
         { info_tbl: [(caeQO,
                       label: io_sad5l_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeQO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeQS; else goto caeQT;
       caeQS: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeQT: // global
           I64[Sp - 16] = block_caeQJ_info;
           _sad5f::P64 = P64[R1 + 23];
           R5 = _sad5f::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad5f::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeQJ() //  [R1]
         { info_tbl: [(caeQJ,
                       label: block_caeQJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeQJ: // global
           I64[Sp] = block_caeQL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeQY; else goto caeQM;
       uaeQY: // global
           call _caeQL(R1) args: 0, res: 0, upd: 0;
       caeQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeQL() //  [R1]
         { info_tbl: [(caeQL,
                       label: block_caeQL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeQL: // global
           I64[Sp] = block_caeQR_info;
           R2 = P64[R1 + 7];
           _sad5s::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad5s::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeQR() //  []
         { info_tbl: [(caeQR,
                       label: block_caeQR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeQR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwithHandle'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caeR3,
                       label: GHC.IO.Handle.Internals.$wwithHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeR3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeR4; else goto caeR5;
       caeR4: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeR5: // global
           I64[Sp - 40] = block_caeQC_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caeQC() //  [R1]
         { info_tbl: [(caeQC,
                       label: block_caeQC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeQC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeR8; else goto caeR7;
       caeR8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeR7: // global
           I64[Hp - 32] = io_sad5l_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           _caeQE::P64 = Hp - 31;
           if (R1 == 0) goto caeR2; else goto caeR1;
       caeR2: // global
           R1 = _caeQE::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeR1: // global
           R1 = _caeQE::P64;
           Sp = Sp + 40;
           call io_sad5l_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.37093135 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle1_closure" {
     GHC.IO.Handle.Internals.withHandle1_closure:
         const GHC.IO.Handle.Internals.withHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caeRM,
                       label: GHC.IO.Handle.Internals.withHandle1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeRM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeRN; else goto caeRO;
       caeRN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeRO: // global
           I64[Sp - 32] = block_caeRJ_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeRS; else goto caeRK;
       uaeRS: // global
           call _caeRJ(R1) args: 0, res: 0, upd: 0;
       caeRK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeRJ() //  [R1]
         { info_tbl: [(caeRJ,
                       label: block_caeRJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeRJ: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.376544269 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle'_closure" {
     GHC.IO.Handle.Internals.withHandle'_closure:
         const GHC.IO.Handle.Internals.withHandle'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caeS7,
                       label: GHC.IO.Handle.Internals.withHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeS7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.380784688 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'1_closure" {
     GHC.IO.Handle.Internals.withHandle_'1_closure:
         const GHC.IO.Handle.Internals.withHandle_'1_info;
         const 0;
 },
 sat_sad5P_entry() //  [R1, R2]
         { info_tbl: [(caeSv,
                       label: sat_sad5P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeSv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeSw; else goto caeSx;
       caeSw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeSx: // global
           I64[Sp - 16] = block_caeSs_info;
           _sad5J::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sad5J::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeSs() //  [R1]
         { info_tbl: [(caeSs,
                       label: block_caeSs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeSs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeSA; else goto caeSz;
       caeSA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeSz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.withHandle_'1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caeSB,
                       label: GHC.IO.Handle.Internals.withHandle_'1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeSB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeSC; else goto caeSD;
       caeSC: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeSD: // global
           I64[Sp - 32] = block_caeSi_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeSH; else goto caeSj;
       uaeSH: // global
           call _caeSi(R1) args: 0, res: 0, upd: 0;
       caeSj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeSi() //  [R1]
         { info_tbl: [(caeSi,
                       label: block_caeSi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeSi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeSG; else goto caeSF;
       caeSG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeSF: // global
           _sad5I::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sad5P_info;
           P64[Hp] = P64[Sp + 24];
           R5 = Hp - 6;
           R4 = _sad5I::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.390899472 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'_closure" {
     GHC.IO.Handle.Internals.withHandle_'_closure:
         const GHC.IO.Handle.Internals.withHandle_'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caeT9,
                       label: GHC.IO.Handle.Internals.withHandle_'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeT9: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle_'1_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.396895452 UTC

[section ""data" . withHandle_2_ra7PG_closure" {
     withHandle_2_ra7PG_closure:
         const withHandle_2_ra7PG_info;
         const 0;
 },
 sat_sad68_entry() //  [R1, R2]
         { info_tbl: [(caeTE,
                       label: sat_sad68_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeTE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeTF; else goto caeTG;
       caeTF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeTG: // global
           I64[Sp - 16] = block_caeTB_info;
           _sad62::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sad62::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeTB() //  [R1]
         { info_tbl: [(caeTB,
                       label: block_caeTB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeTB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeTJ; else goto caeTI;
       caeTJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeTI: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sad60_entry() //  [R1]
         { info_tbl: [(caeTP,
                       label: io_sad60_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeTP: // global
           _sad60::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeTT; else goto caeTU;
       caeTU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeTW; else goto caeTV;
       caeTW: // global
           HpAlloc = 16;
           goto caeTT;
       caeTT: // global
           R1 = _sad60::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeTV: // global
           _sad5Q::P64 = P64[_sad60::P64 + 7];
           _sad5S::P64 = P64[_sad60::P64 + 15];
           _sad5U::P64 = P64[_sad60::P64 + 23];
           _sad5W::P64 = P64[_sad60::P64 + 31];
           I64[Hp - 8] = sat_sad68_info;
           P64[Hp] = _sad5S::P64;
           I64[Sp - 16] = block_caeTK_info;
           R5 = _sad5W::P64;
           R4 = Hp - 6;
           R3 = _sad5U::P64;
           R2 = _sad5Q::P64;
           P64[Sp - 8] = _sad5W::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeTK() //  [R1]
         { info_tbl: [(caeTK,
                       label: block_caeTK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeTK: // global
           I64[Sp] = block_caeTM_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeU1; else goto caeTN;
       uaeU1: // global
           call _caeTM(R1) args: 0, res: 0, upd: 0;
       caeTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeTM() //  [R1]
         { info_tbl: [(caeTM,
                       label: block_caeTM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeTM: // global
           I64[Sp] = block_caeTS_info;
           R2 = P64[R1 + 7];
           _sad6e::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad6e::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeTS() //  []
         { info_tbl: [(caeTS,
                       label: block_caeTS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeTS: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sad6v_entry() //  [R1, R2]
         { info_tbl: [(caeUj,
                       label: sat_sad6v_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeUj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeUk; else goto caeUl;
       caeUk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeUl: // global
           I64[Sp - 16] = block_caeUg_info;
           _sad6p::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sad6p::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeUg() //  [R1]
         { info_tbl: [(caeUg,
                       label: block_caeUg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeUg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeUo; else goto caeUn;
       caeUo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeUn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sad6n_entry() //  [R1]
         { info_tbl: [(caeUu,
                       label: io_sad6n_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeUu: // global
           _sad6n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeUy; else goto caeUz;
       caeUz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeUB; else goto caeUA;
       caeUB: // global
           HpAlloc = 16;
           goto caeUy;
       caeUy: // global
           R1 = _sad6n::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeUA: // global
           _sad5Q::P64 = P64[_sad6n::P64 + 7];
           _sad5S::P64 = P64[_sad6n::P64 + 15];
           _sad5U::P64 = P64[_sad6n::P64 + 23];
           _sad6i::P64 = P64[_sad6n::P64 + 31];
           I64[Hp - 8] = sat_sad6v_info;
           P64[Hp] = _sad5S::P64;
           I64[Sp - 16] = block_caeUp_info;
           R5 = _sad6i::P64;
           R4 = Hp - 6;
           R3 = _sad5U::P64;
           R2 = _sad5Q::P64;
           P64[Sp - 8] = _sad6i::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeUp() //  [R1]
         { info_tbl: [(caeUp,
                       label: block_caeUp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeUp: // global
           I64[Sp] = block_caeUr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeUG; else goto caeUs;
       uaeUG: // global
           call _caeUr(R1) args: 0, res: 0, upd: 0;
       caeUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeUr() //  [R1]
         { info_tbl: [(caeUr,
                       label: block_caeUr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeUr: // global
           I64[Sp] = block_caeUx_info;
           R2 = P64[R1 + 7];
           _sad6B::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad6B::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeUx() //  []
         { info_tbl: [(caeUx,
                       label: block_caeUx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeUx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 withHandle_2_ra7PG_entry() //  [R2, R3, R4]
         { info_tbl: [(caeUL,
                       label: withHandle_2_ra7PG_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeUL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeUM; else goto caeUN;
       caeUM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle_2_ra7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeUN: // global
           I64[Sp - 24] = block_caeTk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeV4; else goto caeTl;
       uaeV4: // global
           call _caeTk(R1) args: 0, res: 0, upd: 0;
       caeTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeTk() //  [R1]
         { info_tbl: [(caeTk,
                       label: block_caeTk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeTk: // global
           if (R1 & 7 == 1) goto caeUI; else goto caeUJ;
       caeUI: // global
           I64[Sp - 16] = block_caeTp_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caeUJ: // global
           I64[Sp - 16] = block_caeU4_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caeTp() //  [R1]
         { info_tbl: [(caeTp,
                       label: block_caeTp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeTp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeUR; else goto caeUQ;
       caeUR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeUQ: // global
           I64[Hp - 32] = io_sad60_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caeTr::P64 = Hp - 31;
           if (R1 == 0) goto caeUV; else goto caeUU;
       caeUV: // global
           R1 = _caeTr::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeUU: // global
           R1 = _caeTr::P64;
           Sp = Sp + 40;
           call io_sad60_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caeU4() //  [R1]
         { info_tbl: [(caeU4,
                       label: block_caeU4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeU4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeUZ; else goto caeUY;
       caeUZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeUY: // global
           I64[Hp - 32] = io_sad6n_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caeU6::P64 = Hp - 31;
           if (R1 == 0) goto caeV3; else goto caeV2;
       caeV3: // global
           R1 = _caeU6::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeV2: // global
           R1 = _caeU6::P64;
           Sp = Sp + 40;
           call io_sad6n_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.429084558 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__closure" {
     GHC.IO.Handle.Internals.withHandle__closure:
         const GHC.IO.Handle.Internals.withHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__entry() //  [R2, R3, R4]
         { info_tbl: [(caeWD,
                       label: GHC.IO.Handle.Internals.withHandle__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeWD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle_2_ra7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.43435779 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_1_info;
         const 0;
 },
 sat_sad6W_entry() //  [R1, R2]
         { info_tbl: [(caeX8,
                       label: sat_sad6W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeX8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeX9; else goto caeXa;
       caeX9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeXa: // global
           I64[Sp - 16] = block_caeX5_info;
           R3 = R2;
           _sad6Q::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sad6Q::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeX5() //  [R1]
         { info_tbl: [(caeX5,
                       label: block_caeX5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeX5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeXd; else goto caeXc;
       caeXd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeXc: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sad6O_entry() //  [R1]
         { info_tbl: [(caeXj,
                       label: io_sad6O_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXj: // global
           _sad6O::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeXn; else goto caeXo;
       caeXo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeXq; else goto caeXp;
       caeXq: // global
           HpAlloc = 16;
           goto caeXn;
       caeXn: // global
           R1 = _sad6O::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeXp: // global
           _sad6E::P64 = P64[_sad6O::P64 + 7];
           _sad6G::P64 = P64[_sad6O::P64 + 15];
           _sad6I::P64 = P64[_sad6O::P64 + 23];
           _sad6K::P64 = P64[_sad6O::P64 + 31];
           I64[Hp - 8] = sat_sad6W_info;
           P64[Hp] = _sad6G::P64;
           I64[Sp - 16] = block_caeXe_info;
           R5 = _sad6K::P64;
           R4 = Hp - 6;
           R3 = _sad6I::P64;
           R2 = _sad6E::P64;
           P64[Sp - 8] = _sad6K::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeXe() //  [R1]
         { info_tbl: [(caeXe,
                       label: block_caeXe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXe: // global
           I64[Sp] = block_caeXg_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeXv; else goto caeXh;
       uaeXv: // global
           call _caeXg(R1) args: 0, res: 0, upd: 0;
       caeXh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeXg() //  [R1]
         { info_tbl: [(caeXg,
                       label: block_caeXg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXg: // global
           I64[Sp] = block_caeXm_info;
           R2 = P64[R1 + 7];
           _sad72::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad72::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeXm() //  []
         { info_tbl: [(caeXm,
                       label: block_caeXm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sad7j_entry() //  [R1, R2]
         { info_tbl: [(caeXN,
                       label: sat_sad7j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeXO; else goto caeXP;
       caeXO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeXP: // global
           I64[Sp - 16] = block_caeXK_info;
           R3 = R2;
           _sad7d::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sad7d::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeXK() //  [R1]
         { info_tbl: [(caeXK,
                       label: block_caeXK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeXS; else goto caeXR;
       caeXS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeXR: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sad7b_entry() //  [R1]
         { info_tbl: [(caeXY,
                       label: io_sad7b_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXY: // global
           _sad7b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeY2; else goto caeY3;
       caeY3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeY5; else goto caeY4;
       caeY5: // global
           HpAlloc = 16;
           goto caeY2;
       caeY2: // global
           R1 = _sad7b::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeY4: // global
           _sad6E::P64 = P64[_sad7b::P64 + 7];
           _sad6G::P64 = P64[_sad7b::P64 + 15];
           _sad6I::P64 = P64[_sad7b::P64 + 23];
           _sad76::P64 = P64[_sad7b::P64 + 31];
           I64[Hp - 8] = sat_sad7j_info;
           P64[Hp] = _sad6G::P64;
           I64[Sp - 16] = block_caeXT_info;
           R5 = _sad76::P64;
           R4 = Hp - 6;
           R3 = _sad6I::P64;
           R2 = _sad6E::P64;
           P64[Sp - 8] = _sad76::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caeXT() //  [R1]
         { info_tbl: [(caeXT,
                       label: block_caeXT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXT: // global
           I64[Sp] = block_caeXV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeYa; else goto caeXW;
       uaeYa: // global
           call _caeXV(R1) args: 0, res: 0, upd: 0;
       caeXW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeXV() //  [R1]
         { info_tbl: [(caeXV,
                       label: block_caeXV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXV: // global
           I64[Sp] = block_caeY1_info;
           R2 = P64[R1 + 7];
           _sad7p::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad7p::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeY1() //  []
         { info_tbl: [(caeY1,
                       label: block_caeY1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeY1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle_1_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(caeYf,
                       label: GHC.IO.Handle.Internals.wantReadableHandle_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeYf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeYg; else goto caeYh;
       caeYg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeYh: // global
           I64[Sp - 24] = block_caeWO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeYy; else goto caeWP;
       uaeYy: // global
           call _caeWO(R1) args: 0, res: 0, upd: 0;
       caeWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeWO() //  [R1]
         { info_tbl: [(caeWO,
                       label: block_caeWO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeWO: // global
           if (R1 & 7 == 1) goto caeYc; else goto caeYd;
       caeYc: // global
           I64[Sp - 16] = block_caeWT_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caeYd: // global
           I64[Sp - 16] = block_caeXy_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caeWT() //  [R1]
         { info_tbl: [(caeWT,
                       label: block_caeWT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeWT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeYl; else goto caeYk;
       caeYl: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeYk: // global
           I64[Hp - 32] = io_sad6O_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caeWV::P64 = Hp - 31;
           if (R1 == 0) goto caeYp; else goto caeYo;
       caeYp: // global
           R1 = _caeWV::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeYo: // global
           R1 = _caeWV::P64;
           Sp = Sp + 40;
           call io_sad6O_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caeXy() //  [R1]
         { info_tbl: [(caeXy,
                       label: block_caeXy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeXy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeYt; else goto caeYs;
       caeYt: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeYs: // global
           I64[Hp - 32] = io_sad7b_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caeXA::P64 = Hp - 31;
           if (R1 == 0) goto caeYx; else goto caeYw;
       caeYx: // global
           R1 = _caeXA::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeYw: // global
           R1 = _caeXA::P64;
           Sp = Sp + 40;
           call io_sad7b_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.467473056 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle__closure" {
     GHC.IO.Handle.Internals.wantReadableHandle__closure:
         const GHC.IO.Handle.Internals.wantReadableHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle__entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(caf07,
                       label: GHC.IO.Handle.Internals.wantReadableHandle__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf07: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.471299264 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle2_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle2_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle2_info;
         const 0;
 },
 sat_sad7x_entry() //  [R1]
         { info_tbl: [(caf0o,
                       label: sat_sad7x_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf0o: // global
           _sad7x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caf0p; else goto caf0q;
       caf0q: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caf0s; else goto caf0r;
       caf0s: // global
           HpAlloc = 72;
           goto caf0p;
       caf0p: // global
           R1 = _sad7x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caf0r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sad7x::P64;
           _sad7s::P64 = P64[_sad7x::P64 + 16];
           _sad7t::P64 = P64[_sad7x::P64 + 24];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sad7t::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = _sad7s::P64;
           P64[Hp - 16] = GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Internals.wantSeekableHandle2_entry() //  [R2, R3]
         { info_tbl: [(caf0t,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf0t: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caf0x; else goto caf0w;
       caf0x: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caf0w: // global
           I64[Hp - 24] = sat_sad7x_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.479832261 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle1_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle1_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle1_info;
         const 0;
 },
 sat_sad8g_entry() //  [R1, R2]
         { info_tbl: [(caf1g,
                       label: sat_sad8g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf1g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caf1h; else goto caf1i;
       caf1h: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caf1i: // global
           I64[Sp - 16] = block_caf1d_info;
           _sad7A::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sad7A::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaf28; else goto caf1e;
       uaf28: // global
           call _caf1d(R1) args: 0, res: 0, upd: 0;
       caf1e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf1d() //  [R1]
         { info_tbl: [(caf1d,
                       label: block_caf1d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf1d: // global
           I64[Sp - 24] = block_caf1l_info;
           _sad7M::P64 = R1;
           _sad7N::P64 = P64[R1 + 7];
           _sad7Q::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sad7N::P64;
           P64[Sp - 8] = _sad7Q::P64;
           P64[Sp] = _sad7M::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf27; else goto caf1n;
       uaf27: // global
           call _caf1l(R1) args: 0, res: 0, upd: 0;
       caf1n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf1l() //  [R1]
         { info_tbl: [(caf1l,
                       label: block_caf1l_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf1l: // global
           _caf21::P64 = R1 & 7;
           if (_caf21::P64 < 3) goto uaf23; else goto uaf24;
       uaf23: // global
           if (_caf21::P64 < 2) goto caf1S; else goto caf1W;
       caf1S: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caf1W: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uaf24: // global
           if (_caf21::P64 != 5) goto caf1w; else goto uaf25;
       caf1w: // global
           _sad7Q::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caf1r_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sad7Q::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
       uaf25: // global
           Sp = Sp + 40;
           call _caf20() args: 0, res: 0, upd: 0;
     }
 },
 _caf1r() //  [R1]
         { info_tbl: [(caf1r,
                       label: block_caf1r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf1r: // global
           I64[Sp] = block_caf1t_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaf2a; else goto caf1y;
       uaf2a: // global
           call _caf1t(R1) args: 0, res: 0, upd: 0;
       caf1y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf1t() //  [R1]
         { info_tbl: [(caf1t,
                       label: block_caf1t_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf1t: // global
           if (R1 & 7 == 1) goto uaf26; else goto caf1L;
       uaf26: // global
           Sp = Sp + 24;
           call _caf20() args: 0, res: 0, upd: 0;
       caf1L: // global
           I64[Sp] = block_caf1H_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf1H() //  [R1]
         { info_tbl: [(caf1H,
                       label: block_caf1H_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf1H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf1O; else goto caf1N;
       caf1O: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf1N: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caf20() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf20: // global
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sad7I_entry() //  [R1]
         { info_tbl: [(caf2h,
                       label: io_sad7I_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf2h: // global
           _sad7I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caf2l; else goto caf2m;
       caf2m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caf2o; else goto caf2n;
       caf2o: // global
           HpAlloc = 16;
           goto caf2l;
       caf2l: // global
           R1 = _sad7I::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caf2n: // global
           _sad7y::P64 = P64[_sad7I::P64 + 7];
           _sad7A::P64 = P64[_sad7I::P64 + 15];
           _sad7C::P64 = P64[_sad7I::P64 + 23];
           _sad7E::P64 = P64[_sad7I::P64 + 31];
           I64[Hp - 8] = sat_sad8g_info;
           P64[Hp] = _sad7A::P64;
           I64[Sp - 16] = block_caf2c_info;
           R5 = _sad7E::P64;
           R4 = Hp - 6;
           R3 = _sad7C::P64;
           R2 = _sad7y::P64;
           P64[Sp - 8] = _sad7E::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caf2c() //  [R1]
         { info_tbl: [(caf2c,
                       label: block_caf2c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf2c: // global
           I64[Sp] = block_caf2e_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaf2t; else goto caf2f;
       uaf2t: // global
           call _caf2e(R1) args: 0, res: 0, upd: 0;
       caf2f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf2e() //  [R1]
         { info_tbl: [(caf2e,
                       label: block_caf2e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf2e: // global
           I64[Sp] = block_caf2k_info;
           R2 = P64[R1 + 7];
           _sad8m::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad8m::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf2k() //  []
         { info_tbl: [(caf2k,
                       label: block_caf2k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf2k: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantSeekableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(caf2y,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf2y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caf2z; else goto caf2A;
       caf2z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caf2A: // global
           I64[Sp - 24] = block_caf0W_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf2M; else goto caf0X;
       uaf2M: // global
           call _caf0W(R1) args: 0, res: 0, upd: 0;
       caf0X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf0W() //  [R1]
         { info_tbl: [(caf0W,
                       label: block_caf0W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf0W: // global
           if (R1 & 7 == 1) goto caf2v; else goto caf2w;
       caf2v: // global
           I64[Sp - 16] = block_caf11_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caf2w: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.wantSeekableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _caf11() //  [R1]
         { info_tbl: [(caf11,
                       label: block_caf11_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf11: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caf2E; else goto caf2D;
       caf2E: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caf2D: // global
           I64[Hp - 32] = io_sad7I_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caf13::P64 = Hp - 31;
           if (R1 == 0) goto caf2I; else goto caf2H;
       caf2I: // global
           R1 = _caf13::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caf2H: // global
           R1 = _caf13::P64;
           Sp = Sp + 40;
           call io_sad7I_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.507462011 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(caf46,
                       label: GHC.IO.Handle.Internals.wantSeekableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf46: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.514727026 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwantWritableHandle'_closure" {
     GHC.IO.Handle.Internals.$wwantWritableHandle'_closure:
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_info;
         const 0;
 },
 sat_sad9y_entry() //  [R1]
         { info_tbl: [(caf53,
                       label: sat_sad9y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf53: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caf57; else goto caf58;
       caf57: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caf58: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caf50_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf5c; else goto caf51;
       uaf5c: // global
           call _caf50(R1) args: 0, res: 0, upd: 0;
       caf51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caf50() //  [R1]
         { info_tbl: [(caf50,
                       label: block_caf50_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf50: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caf5b; else goto caf5a;
       caf5b: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caf5a: // global
           _sad9t::P64 = P64[R1 + 7];
           _sad9s::I64 = I64[R1 + 23];
           _sad9v::I64 = I64[R1 + 31];
           _sad9w::I64 = I64[R1 + 39];
           _sad9x::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sad9t::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sad9s::I64;
           I64[Hp - 16] = _sad9v::I64;
           I64[Hp - 8] = _sad9w::I64;
           I64[Hp] = _sad9x::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sada3_entry() //  [R1]
         { info_tbl: [(caf5x,
                       label: sat_sada3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf5x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caf5B; else goto caf5C;
       caf5B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caf5C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caf5u_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf5G; else goto caf5v;
       uaf5G: // global
           call _caf5u(R1) args: 0, res: 0, upd: 0;
       caf5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caf5u() //  [R1]
         { info_tbl: [(caf5u,
                       label: block_caf5u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf5u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caf5F; else goto caf5E;
       caf5F: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caf5E: // global
           _sad9Y::P64 = P64[R1 + 7];
           _sad9Z::P64 = P64[R1 + 15];
           _sad9X::I64 = I64[R1 + 23];
           _sada0::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sad9Y::P64;
           P64[Hp - 32] = _sad9Z::P64;
           I64[Hp - 24] = _sad9X::I64;
           I64[Hp - 16] = _sada0::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sadam_entry() //  [R1]
         { info_tbl: [(caf63,
                       label: sat_sadam_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf63: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caf6a; else goto caf6b;
       caf6a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caf6b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caf60_info;
           _sadac::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sadac::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaf6f; else goto caf61;
       uaf6f: // global
           call _caf60(R1) args: 0, res: 0, upd: 0;
       caf61: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caf60() //  [R1]
         { info_tbl: [(caf60,
                       label: block_caf60_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf60: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caf6e; else goto caf6d;
       caf6e: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caf6d: // global
           _sadag::P64 = P64[R1 + 7];
           _sadah::P64 = P64[R1 + 15];
           _sadaf::I64 = I64[R1 + 23];
           _sadai::I64 = I64[R1 + 31];
           _sadak::I64 = I64[R1 + 47];
           _sadal::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sadag::P64;
           P64[Hp - 32] = _sadah::P64;
           I64[Hp - 24] = _sadaf::I64;
           I64[Hp - 16] = _sadai::I64;
           I64[Hp - 8] = _sadal::I64;
           I64[Hp] = _sadak::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uaf8F_srtd" {
     uaf8F_srtd:
         const Saded_srt+104;
         const 59;
         const 432345564228616193;
 },
 sat_sadaL_entry() //  [R1, R2]
         { info_tbl: [(caf6g,
                       label: sat_sadaL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf6g: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caf6h; else goto caf6i;
       caf6h: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caf6i: // global
           I64[Sp - 16] = block_caf4m_info;
           _sad8v::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sad8v::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaf8x; else goto caf4n;
       uaf8x: // global
           call _caf4m(R1) args: 0, res: 0, upd: 0;
       caf4n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaf8G_srtd" {
     uaf8G_srtd:
         const Saded_srt+104;
         const 59;
         const 432345564228616193;
 },
 _caf4m() //  [R1]
         { info_tbl: [(caf4m,
                       label: block_caf4m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf4m: // global
           I64[Sp - 56] = block_caf4r_info;
           _sad8z::P64 = R1;
           _sad8B::P64 = P64[R1 + 15];
           _sad8D::P64 = P64[R1 + 31];
           _sad8F::P64 = P64[R1 + 47];
           _sad8H::P64 = P64[R1 + 63];
           _sad8I::P64 = P64[R1 + 71];
           _sad8L::P64 = P64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 48] = _sad8B::P64;
           P64[Sp - 40] = _sad8D::P64;
           P64[Sp - 32] = _sad8F::P64;
           P64[Sp - 24] = _sad8H::P64;
           P64[Sp - 16] = _sad8I::P64;
           P64[Sp - 8] = _sad8L::P64;
           P64[Sp] = _sad8z::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaf8k; else goto caf4s;
       uaf8k: // global
           call _caf4r(R1) args: 0, res: 0, upd: 0;
       caf4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaf8H_srtd" {
     uaf8H_srtd:
         const Saded_srt+104;
         const 59;
         const 432345564228616193;
 },
 _caf4r() //  [R1]
         { info_tbl: [(caf4r,
                       label: block_caf4r_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf4r: // global
           _caf7Y::P64 = R1 & 7;
           if (_caf7Y::P64 < 4) goto uaf8c; else goto uaf8e;
       uaf8c: // global
           if (_caf7Y::P64 < 3) goto uaf8d; else goto caf6C;
       uaf8d: // global
           if (_caf7Y::P64 < 2) goto caf6w; else goto caf6z;
       caf6w: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caf6z: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caf6C: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uaf8e: // global
           if (_caf7Y::P64 < 6) goto caf6q; else goto caf6E;
       caf6q: // global
           I64[Sp + 48] = block_caf6l_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       caf6E: // global
           _sad90::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_caf4A_info;
           R1 = _sad90::P64;
           if (R1 & 7 != 0) goto uaf8l; else goto caf4B;
       uaf8l: // global
           call _caf4A(R1) args: 0, res: 0, upd: 0;
       caf4B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf6l() //  [R1]
         { info_tbl: [(caf6l,
                       label: block_caf6l_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf6l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf6t; else goto caf6s;
       caf6t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf6s: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caf4A() //  [R1]
         { info_tbl: [(caf4A,
                       label: block_caf4A_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf4A: // global
           I64[Sp] = block_caf4F_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaf8m; else goto caf4G;
       uaf8m: // global
           call _caf4F(R1) args: 0, res: 0, upd: 0;
       caf4G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf4F() //  [R1]
         { info_tbl: [(caf4F,
                       label: block_caf4F_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf4F: // global
           if (R1 & 7 == 1) goto caf6I; else goto caf7U;
       caf6I: // global
           _sad9b::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_caf4K_info;
           R1 = _sad9b::P64;
           if (R1 & 7 != 0) goto uaf8n; else goto caf4L;
       uaf8n: // global
           call _caf4K(R1) args: 0, res: 0, upd: 0;
       caf4L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caf7U: // global
           I64[Sp + 48] = block_caf7Q_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf4K() //  [R1]
         { info_tbl: [(caf4K,
                       label: block_caf4K_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf4K: // global
           I64[Sp - 16] = block_caf5d_info;
           _sad9h::I64 = I64[R1 + 39];
           _sad9i::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sad9i::I64;
           I64[Sp] = _sad9h::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaf8o; else goto caf5e;
       uaf8o: // global
           call _caf5d(R1) args: 0, res: 0, upd: 0;
       caf5e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf5d() //  [R1]
         { info_tbl: [(caf5d,
                       label: block_caf5d_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf5d: // global
           if (R1 & 7 == 1) goto caf7J; else goto uaf8f;
       caf7J: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto uaf8g; else goto caf75;
       uaf8g: // global
           Sp = Sp + 24;
           goto uaf8r;
       caf75: // global
           _sad9P::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp + 16] = block_caf5l_info;
           R1 = _sad9P::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaf8p; else goto caf5m;
       uaf8p: // global
           call _caf5l(R1) args: 0, res: 0, upd: 0;
       caf5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaf8f: // global
           Sp = Sp + 24;
           goto uaf8r;
       uaf8r: // global
           call _sad9j() args: 0, res: 0, upd: 0;
     }
 },
 _caf5l() //  [R1]
         { info_tbl: [(caf5l,
                       label: block_caf5l_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf5l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf78; else goto caf77;
       caf78: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf77: // global
           _sad8I::P64 = P64[Sp + 40];
           _sad9R::P64 = P64[R1 + 7];
           _sad9S::P64 = P64[R1 + 15];
           _sad9V::P64 = P64[_sad8I::P64 + 8];
           I64[Hp - 16] = sat_sada3_info;
           P64[Hp] = _sad9V::P64;
           call MO_WriteBarrier();
           P64[_sad8I::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8I::P64);
           I64[Sp - 8] = block_caf5K_info;
           R1 = _sad9V::P64;
           P64[Sp] = _sad9S::P64;
           P64[Sp + 32] = _sad9R::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaf8s; else goto caf5L;
       uaf8s: // global
           call _caf5K(R1) args: 0, res: 0, upd: 0;
       caf5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf5K() //  [R1]
         { info_tbl: [(caf5K,
                       label: block_caf5K_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf5K: // global
           _sadac::I64 = I64[R1 + 39];
           if (_sadac::I64 != 0) goto caf7b; else goto caf7G;
       caf7b: // global
           I64[Sp - 24] = block_caf5R_info;
           _sada7::P64 = P64[R1 + 7];
           _sada8::P64 = P64[R1 + 15];
           _sada6::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           P64[Sp - 16] = _sada8::P64;
           I64[Sp - 8] = _sadac::I64;
           P64[Sp] = _sada7::P64;
           I64[Sp + 56] = _sada6::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf8t; else goto caf5S;
       uaf8t: // global
           call _caf5R(R1) args: 0, res: 0, upd: 0;
       caf5S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caf7G: // global
           _sad8F::P64 = P64[Sp + 32];
           _sad9S::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sad8F::P64 + 8] = _sad9S::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8F::P64);
           Sp = Sp + 16;
           call _sad9j() args: 0, res: 0, upd: 0;
     }
 },
 _caf5R() //  [R1]
         { info_tbl: [(caf5R,
                       label: block_caf5R_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf5R: // global
           if (R1 & 7 == 1) goto caf7d; else goto caf7v;
       caf7d: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caf7g; else goto caf7f;
       caf7g: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf7f: // global
           I64[Hp - 24] = sat_sadam_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sad8F::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sad8F::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8F::P64);
           Sp = Sp + 40;
           call _sad9j() args: 0, res: 0, upd: 0;
       caf7v: // global
           I64[Sp] = block_caf7j_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaf8v; else goto caf7k;
       uaf8v: // global
           call _caf7j(R1) args: 0, res: 0, upd: 0;
       caf7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf7j() //  [R1]
         { info_tbl: [(caf7j,
                       label: block_caf7j_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf7j: // global
           I64[Sp - 8] = block_caf7o_info;
           R2 = P64[Sp + 64];
           _sadaq::P64 = P64[R1 + 7];
           _sadar::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sadar::P64;
           P64[Sp + 64] = _sadaq::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf7o() //  [R1]
         { info_tbl: [(caf7o,
                       label: block_caf7o_info
                       rep:StackRep [False, False, True, False, False, False, False,
                                     False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf7o: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caf7z; else goto caf7y;
       caf7z: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf7y: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sad9S::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_caf7r_info;
           R5 = Hp - 47;
           R4 = _sad9S::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 72];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caf7r() //  [R1]
         { info_tbl: [(caf7r,
                       label: block_caf7r_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf7r: // global
           I64[Sp] = block_caf7t_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaf8y; else goto caf7B;
       uaf8y: // global
           call _caf7t(R1) args: 0, res: 0, upd: 0;
       caf7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf7t() //  [R1]
         { info_tbl: [(caf7t,
                       label: block_caf7t_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf7t: // global
           _sad8F::P64 = P64[Sp + 24];
           _sadaD::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sad8F::P64 + 8] = _sadaD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8F::P64);
           Sp = Sp + 8;
           call _sad9j() args: 0, res: 0, upd: 0;
     }
 },
 _sad9j() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sad9j: // global
           I64[Sp - 8] = block_caf4U_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caf4U() //  [R1]
         { info_tbl: [(caf4U,
                       label: block_caf4U_info
                       rep:StackRep [False, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf4U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf6Y; else goto caf6X;
       caf6Y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf6X: // global
           _sad8I::P64 = P64[Sp + 40];
           _sad9q::P64 = P64[_sad8I::P64 + 8];
           I64[Hp - 16] = sat_sad9y_info;
           P64[Hp] = _sad9q::P64;
           _sad8B::P64 = P64[Sp + 8];
           _sad8D::P64 = P64[Sp + 16];
           _sad8F::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sad8I::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8I::P64);
           I64[Sp + 16] = block_caf6N_info;
           R2 = _sad8B::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sad8D::P64;
           P64[Sp + 8] = P64[_sad8F::P64 + 8];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.emptyWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _caf6N() //  [R1]
         { info_tbl: [(caf6N,
                       label: block_caf6N_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf6N: // global
           _sad8v::P64 = P64[Sp + 48];
           _sad8z::P64 = P64[Sp + 40];
           _sad8F::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sad8F::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8F::P64);
           I64[Sp + 32] = block_caf6S_info;
           R2 = _sad8z::P64;
           R1 = _sad8v::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caf6S() //  [R1]
         { info_tbl: [(caf6S,
                       label: block_caf6S_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf6S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf72; else goto caf71;
       caf72: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf71: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caf7Q() //  [R1]
         { info_tbl: [(caf7Q,
                       label: block_caf7Q_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf7Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf7X; else goto caf7W;
       caf7X: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf7W: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaf8I_srtd" {
     uaf8I_srtd:
         const Saded_srt+104;
         const 62;
         const 3891391553024819201;
 },
 GHC.IO.Handle.Internals.$wwantWritableHandle'_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(caf8A,
                       label: GHC.IO.Handle.Internals.$wwantWritableHandle'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf8A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caf8E; else goto caf8D;
       caf8E: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caf8D: // global
           I64[Hp - 8] = sat_sadaL_info;
           P64[Hp] = R5;
           R5 = Hp - 6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.576979062 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle1_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle1_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cafbM,
                       label: GHC.IO.Handle.Internals.wantWritableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafbM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cafbN; else goto cafbO;
       cafbN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantWritableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cafbO: // global
           I64[Sp - 24] = block_cafbF_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafbV; else goto cafbG;
       uafbV: // global
           call _cafbF(R1) args: 0, res: 0, upd: 0;
       cafbG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafbF() //  [R1]
         { info_tbl: [(cafbF,
                       label: block_cafbF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafbF: // global
           _sadaM::P64 = P64[Sp + 8];
           _sadaO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cafbJ; else goto cafbK;
       cafbJ: // global
           R5 = _sadaO::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = _sadaM::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cafbK: // global
           R5 = _sadaO::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = _sadaM::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.583177135 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(cafcc,
                       label: GHC.IO.Handle.Internals.wantWritableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafcc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.588296347 UTC

[section ""data" . withHandle2_ra7PH_closure" {
     withHandle2_ra7PH_closure:
         const withHandle2_ra7PH_info;
         const 0;
 },
 io_sadb6_entry() //  [R1]
         { info_tbl: [(cafcE,
                       label: io_sadb6_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafcE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cafcI; else goto cafcJ;
       cafcI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cafcJ: // global
           I64[Sp - 16] = block_cafcz_info;
           _sadb2::P64 = P64[R1 + 31];
           R5 = _sadb2::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sadb2::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cafcz() //  [R1]
         { info_tbl: [(cafcz,
                       label: block_cafcz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafcz: // global
           I64[Sp] = block_cafcB_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uafcO; else goto cafcC;
       uafcO: // global
           call _cafcB(R1) args: 0, res: 0, upd: 0;
       cafcC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafcB() //  [R1]
         { info_tbl: [(cafcB,
                       label: block_cafcB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafcB: // global
           I64[Sp] = block_cafcH_info;
           R2 = P64[R1 + 7];
           _sadbd::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sadbd::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafcH() //  []
         { info_tbl: [(cafcH,
                       label: block_cafcH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafcH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sadbm_entry() //  [R1]
         { info_tbl: [(cafd3,
                       label: io_sadbm_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafd3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cafd7; else goto cafd8;
       cafd7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cafd8: // global
           I64[Sp - 16] = block_cafcY_info;
           _sadbh::P64 = P64[R1 + 31];
           R5 = _sadbh::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sadbh::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cafcY() //  [R1]
         { info_tbl: [(cafcY,
                       label: block_cafcY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafcY: // global
           I64[Sp] = block_cafd0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uafdd; else goto cafd1;
       uafdd: // global
           call _cafd0(R1) args: 0, res: 0, upd: 0;
       cafd1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafd0() //  [R1]
         { info_tbl: [(cafd0,
                       label: block_cafd0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafd0: // global
           I64[Sp] = block_cafd6_info;
           R2 = P64[R1 + 7];
           _sadbt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sadbt::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafd6() //  []
         { info_tbl: [(cafd6,
                       label: block_cafd6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafd6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 withHandle2_ra7PH_entry() //  [R2, R3, R4]
         { info_tbl: [(cafdi,
                       label: withHandle2_ra7PH_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafdi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cafdj; else goto cafdk;
       cafdj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle2_ra7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cafdk: // global
           I64[Sp - 24] = block_cafcn_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafdB; else goto cafco;
       uafdB: // global
           call _cafcn(R1) args: 0, res: 0, upd: 0;
       cafco: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafcn() //  [R1]
         { info_tbl: [(cafcn,
                       label: block_cafcn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafcn: // global
           if (R1 & 7 == 1) goto cafdf; else goto cafdg;
       cafdf: // global
           I64[Sp - 16] = block_cafcs_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cafdg: // global
           I64[Sp - 16] = block_cafcR_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cafcs() //  [R1]
         { info_tbl: [(cafcs,
                       label: block_cafcs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafcs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafdo; else goto cafdn;
       cafdo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cafdn: // global
           I64[Hp - 32] = io_sadb6_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cafcu::P64 = Hp - 31;
           if (R1 == 0) goto cafds; else goto cafdr;
       cafds: // global
           R1 = _cafcu::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cafdr: // global
           R1 = _cafcu::P64;
           Sp = Sp + 40;
           call io_sadb6_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cafcR() //  [R1]
         { info_tbl: [(cafcR,
                       label: block_cafcR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafcR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafdw; else goto cafdv;
       cafdw: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cafdv: // global
           I64[Hp - 32] = io_sadbm_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cafcT::P64 = Hp - 31;
           if (R1 == 0) goto cafdA; else goto cafdz;
       cafdA: // global
           R1 = _cafcT::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cafdz: // global
           R1 = _cafcT::P64;
           Sp = Sp + 40;
           call io_sadbm_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.613057858 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_closure" {
     GHC.IO.Handle.Internals.withHandle_closure:
         const GHC.IO.Handle.Internals.withHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(cafeM,
                       label: GHC.IO.Handle.Internals.withHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafeM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle2_ra7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.618322903 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle1_info;
         const 0;
 },
 sat_sadbI_entry() //  [R1, R2]
         { info_tbl: [(caffe,
                       label: sat_sadbI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffe: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 io_sadbG_entry() //  [R1]
         { info_tbl: [(caffm,
                       label: io_sadbG_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffm: // global
           _sadbG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caffq; else goto caffr;
       caffr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cafft; else goto caffs;
       cafft: // global
           HpAlloc = 16;
           goto caffq;
       caffq: // global
           R1 = _sadbG::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caffs: // global
           _sadbw::P64 = P64[_sadbG::P64 + 7];
           _sadby::P64 = P64[_sadbG::P64 + 15];
           _sadbA::P64 = P64[_sadbG::P64 + 23];
           _sadbC::P64 = P64[_sadbG::P64 + 31];
           I64[Hp - 8] = sat_sadbI_info;
           P64[Hp] = _sadby::P64;
           I64[Sp - 16] = block_caffh_info;
           R5 = _sadbC::P64;
           R4 = Hp - 6;
           R3 = _sadbA::P64;
           R2 = _sadbw::P64;
           P64[Sp - 8] = _sadbC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caffh() //  [R1]
         { info_tbl: [(caffh,
                       label: block_caffh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffh: // global
           I64[Sp] = block_caffj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaffy; else goto caffk;
       uaffy: // global
           call _caffj(R1) args: 0, res: 0, upd: 0;
       caffk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caffj() //  [R1]
         { info_tbl: [(caffj,
                       label: block_caffj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffj: // global
           I64[Sp] = block_caffp_info;
           R2 = P64[R1 + 7];
           _sadbO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sadbO::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caffp() //  []
         { info_tbl: [(caffp,
                       label: block_caffp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sadbZ_entry() //  [R1, R2]
         { info_tbl: [(caffN,
                       label: sat_sadbZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffN: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 io_sadbX_entry() //  [R1]
         { info_tbl: [(caffV,
                       label: io_sadbX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffV: // global
           _sadbX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caffZ; else goto cafg0;
       cafg0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cafg2; else goto cafg1;
       cafg2: // global
           HpAlloc = 16;
           goto caffZ;
       caffZ: // global
           R1 = _sadbX::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cafg1: // global
           _sadbw::P64 = P64[_sadbX::P64 + 7];
           _sadby::P64 = P64[_sadbX::P64 + 15];
           _sadbA::P64 = P64[_sadbX::P64 + 23];
           _sadbS::P64 = P64[_sadbX::P64 + 31];
           I64[Hp - 8] = sat_sadbZ_info;
           P64[Hp] = _sadby::P64;
           I64[Sp - 16] = block_caffQ_info;
           R5 = _sadbS::P64;
           R4 = Hp - 6;
           R3 = _sadbA::P64;
           R2 = _sadbw::P64;
           P64[Sp - 8] = _sadbS::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caffQ() //  [R1]
         { info_tbl: [(caffQ,
                       label: block_caffQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffQ: // global
           I64[Sp] = block_caffS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uafg7; else goto caffT;
       uafg7: // global
           call _caffS(R1) args: 0, res: 0, upd: 0;
       caffT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caffS() //  [R1]
         { info_tbl: [(caffS,
                       label: block_caffS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffS: // global
           I64[Sp] = block_caffY_info;
           R2 = P64[R1 + 7];
           _sadc5::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sadc5::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caffY() //  []
         { info_tbl: [(caffY,
                       label: block_caffY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.wantReadableHandle1_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cafgc,
                       label: GHC.IO.Handle.Internals.wantReadableHandle1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafgc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cafgd; else goto cafge;
       cafgd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cafge: // global
           I64[Sp - 24] = block_cafeX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafgv; else goto cafeY;
       uafgv: // global
           call _cafeX(R1) args: 0, res: 0, upd: 0;
       cafeY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafeX() //  [R1]
         { info_tbl: [(cafeX,
                       label: block_cafeX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafeX: // global
           if (R1 & 7 == 1) goto cafg9; else goto cafga;
       cafg9: // global
           I64[Sp - 16] = block_caff2_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cafga: // global
           I64[Sp - 16] = block_caffB_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _caff2() //  [R1]
         { info_tbl: [(caff2,
                       label: block_caff2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caff2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafgi; else goto cafgh;
       cafgi: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cafgh: // global
           I64[Hp - 32] = io_sadbG_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caff4::P64 = Hp - 31;
           if (R1 == 0) goto cafgm; else goto cafgl;
       cafgm: // global
           R1 = _caff4::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cafgl: // global
           R1 = _caff4::P64;
           Sp = Sp + 40;
           call io_sadbG_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caffB() //  [R1]
         { info_tbl: [(caffB,
                       label: block_caffB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caffB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafgq; else goto cafgp;
       cafgq: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cafgp: // global
           I64[Hp - 32] = io_sadbX_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caffD::P64 = Hp - 31;
           if (R1 == 0) goto cafgu; else goto cafgt;
       cafgu: // global
           R1 = _caffD::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cafgt: // global
           R1 = _caffD::P64;
           Sp = Sp + 40;
           call io_sadbX_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.647822553 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(cafhO,
                       label: GHC.IO.Handle.Internals.wantReadableHandle_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafhO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.651295904 UTC

[section ""relreadonly" . Saded_srt" {
     Saded_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle12_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const ioe_closedHandle2_ra7Pb_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle8_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const ioe_semiclosedHandle2_ra7Pc_closure;
         const GHC.IO.Handle.Internals.hLookAhead_3_closure;
         const ioe_EOF2_ra7Pd_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle4_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle3_closure;
         const ioe_notReadable2_ra7Pe_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle3_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle2_closure;
         const ioe_notWritable2_ra7Pf_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle4_closure;
         const GHC.IO.Handle.Internals.flushBuffer4_closure;
         const lvl1_ra7Ph_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const lvl6_ra7Pm_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf1_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.Err.error_closure;
         const lvl19_ra7Pz_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer1_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer3_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
         const lvl22_ra7PC_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.noCharBuffer_closure;
         const GHC.IO.Handle.Internals.noByteBuffer_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkFileHandle1_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const $wlvl_ra7PF_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.Internals.withHandle_1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.Internals.withHandle__'1_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.withHandle1_closure;
         const GHC.IO.Handle.Internals.withHandle_'1_closure;
         const withHandle_2_ra7PG_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const withHandle2_ra7PH_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
 }]

