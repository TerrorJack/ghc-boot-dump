
==================== Output Cmm ====================
2018-03-16 16:06:14.104579775 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:14.105142697 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes:
         I8[] [70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.106130519 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_entry() //  [R1]
         { info_tbl: [(cbipg,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbipg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiph; else goto cbipi;
       cbiph: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbipi: // global
           (_cbipd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbipd::I64 == 0) goto cbipf; else goto cbipe;
       cbipf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbipe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbipd::I64;
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.107332923 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { info_tbl: [(cbipq,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbipq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbipr; else goto cbips;
       cbipr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbips: // global
           I64[Sp - 16] = block_cbipn_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubipw; else goto cbipo;
       ubipw: // global
           call _cbipn() args: 0, res: 0, upd: 0;
       cbipo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbipn() //  []
         { info_tbl: [(cbipn,
                       label: block_cbipn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbipn: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.108573965 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_entry() //  [R2]
         { info_tbl: [(cbipF,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbipF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbipG; else goto cbipH;
       cbipG: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbipH: // global
           I64[Sp - 8] = block_cbipC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubipL; else goto cbipD;
       ubipL: // global
           call _cbipC() args: 0, res: 0, upd: 0;
       cbipD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbipC() //  []
         { info_tbl: [(cbipC,
                       label: block_cbipC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbipC: // global
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.109738596 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbipT,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbipT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbipU; else goto cbipV;
       cbipU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbipV: // global
           I64[Sp - 16] = block_cbipQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubipZ; else goto cbipR;
       ubipZ: // global
           call _cbipQ() args: 0, res: 0, upd: 0;
       cbipR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbipQ() //  []
         { info_tbl: [(cbipQ,
                       label: block_cbipQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbipQ: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.110868098 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_entry() //  [R2,
                                                                          R3]
         { info_tbl: [(cbiq4,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiq4: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.111650727 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.112222609 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule4_bytes" {
     GHC.IO.Handle.Lock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.112765267 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule3_closure" {
     GHC.IO.Handle.Lock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.113342177 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule2_bytes" {
     GHC.IO.Handle.Lock.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.113935742 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule1_closure" {
     GHC.IO.Handle.Lock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.114477765 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule_closure" {
     GHC.IO.Handle.Lock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Lock.$trModule3_closure+1;
         const GHC.IO.Handle.Lock.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.115047826 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.115613505 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
         const GHC.Types.krep$*_closure;
         const 2716065848555532007;
         const 12251424812302631774;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.116234515 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.116809732 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes:
         I8[] [39,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.117506974 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.118071566 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure+1;
         const 13975601321420314475;
         const 8398323512000399582;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.119152303 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_entry() //  [R1]
         { info_tbl: [(cbiqi,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiqi: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbiqj; else goto cbiqk;
       cbiqj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiqk: // global
           (_cbiqa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiqa::I64 == 0) goto cbiqc; else goto cbiqb;
       cbiqc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiqb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiqa::I64;
           I64[Sp - 24] = block_cbiqd_info;
           R6 = 0;
           R5 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
           R4 = GHC.IO.Handle.Lock.$trModule_closure+1;
           R3 = 12251424812302631774;
           R2 = 2716065848555532007;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbiqd() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbiqd,
                       label: block_cbiqd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiqd: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbiqe() args: 0, res: 0, upd: 0;
     }
 },
 _cbiqe() //  []
         { info_tbl: [(cbiqe,
                       label: block_cbiqe_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiqe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbiqn; else goto cbiqm;
       cbiqn: // global
           HpAlloc = 48;
           I64[Sp] = block_cbiqe_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbiqm: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.121076637 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_entry() //  [R2]
         { info_tbl: [(cbiqx,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiqx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiqB; else goto cbiqC;
       cbiqB: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiqC: // global
           I64[Sp - 8] = block_cbiqu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiqX; else goto cbiqv;
       ubiqX: // global
           call _cbiqu(R1) args: 0, res: 0, upd: 0;
       cbiqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiqu() //  [R1]
         { info_tbl: [(cbiqu,
                       label: block_cbiqu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiqu: // global
           I64[Sp - 8] = block_cbiqA_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiqA() //  [R1]
         { info_tbl: [(cbiqA,
                       label: block_cbiqA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiqA: // global
           I64[Sp] = block_cbiqH_info;
           R3 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiqH() //  [R1]
         { info_tbl: [(cbiqH,
                       label: block_cbiqH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiqH: // global
           if (R1 & 7 == 1) goto cbiqO; else goto cbiqS;
       cbiqO: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiqS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbiqV; else goto cbiqU;
       cbiqV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbiqU: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.122734024 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_entry() //  [R2]
         { info_tbl: [(cbir3,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbir3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbir7; else goto cbir6;
       cbir7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbir6: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.123674084 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tcLockMode2_bytes" {
     GHC.IO.Handle.Lock.$tcLockMode2_bytes:
         I8[] [76,111,99,107,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.124260772 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode1_closure" {
     GHC.IO.Handle.Lock.$tcLockMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.124845958 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode_closure" {
     GHC.IO.Handle.Lock.$tcLockMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tcLockMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18068849831825836849;
         const 1974453150269185476;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.125486207 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.126063122 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'SharedLock2_bytes" {
     GHC.IO.Handle.Lock.$tc'SharedLock2_bytes:
         I8[] [39,83,104,97,114,101,100,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.126637792 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock1_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'SharedLock2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.127209034 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'SharedLock1_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 9660990538910196995;
         const 16983901031857135990;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.127840258 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes:
         I8[] [39,69,120,99,108,117,115,105,118,101,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.128418461 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.129028692 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 8544818512469904331;
         const 16785548070058023905;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.130953657 UTC

[section ""cstring" . lvl_rbimF_bytes" {
     lvl_rbimF_bytes:
         I8[] [102,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.131709588 UTC

[section ""data" . lvl1_rbimG_closure" {
     lvl1_rbimG_closure:
         const lvl1_rbimG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbimG_entry() //  [R1]
         { info_tbl: [(cbire,
                       label: lvl1_rbimG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbire: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbirf; else goto cbirg;
       cbirf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbirg: // global
           (_cbirb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbirb::I64 == 0) goto cbird; else goto cbirc;
       cbird: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbirc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbirb::I64;
           R2 = lvl_rbimF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.132738961 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock2_closure" {
     GHC.IO.Handle.Lock.hUnlock2_closure:
         const GHC.IO.Handle.Lock.hUnlock2_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock2_entry() //  [R2]
         { info_tbl: [(cbirn,
                       label: GHC.IO.Handle.Lock.hUnlock2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbirn: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_rbimG_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.134282977 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock1_closure" {
     GHC.IO.Handle.Lock.hUnlock1_closure:
         const GHC.IO.Handle.Lock.hUnlock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock1_entry() //  [R2]
         { info_tbl: [(cbirB,
                       label: GHC.IO.Handle.Lock.hUnlock1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbirB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbirC; else goto cbirD;
       cbirC: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hUnlock1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbirD: // global
           I64[Sp - 8] = block_cbiru_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubisG; else goto cbirv;
       ubisG: // global
           call _cbiru(R1) args: 0, res: 0, upd: 0;
       cbirv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiru() //  [R1]
         { info_tbl: [(cbiru,
                       label: block_cbiru_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiru: // global
           if (R1 & 7 == 1) goto cbiry; else goto cbirz;
       cbiry: // global
           I64[Sp - 8] = block_cbirG_info;
           _sbina::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbina::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbirz: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbirG() //  [R1]
         { info_tbl: [(cbirG,
                       label: block_cbirG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbirG: // global
           I64[Sp] = block_cbirI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubisH; else goto cbirJ;
       ubisH: // global
           call _cbirI(R1) args: 0, res: 0, upd: 0;
       cbirJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbirI() //  [R1]
         { info_tbl: [(cbirI,
                       label: block_cbirI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbirI: // global
           I64[Sp - 8] = block_cbirN_info;
           _sbinj::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbinj::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbirN() //  [R1]
         { info_tbl: [(cbirN,
                       label: block_cbirN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbirN: // global
           I64[Sp] = block_cbirU_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbirU() //  [R1]
         { info_tbl: [(cbirU,
                       label: block_cbirU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbirU: // global
           if (R1 & 7 == 1) goto cbis1; else goto cbis5;
       cbis1: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbis5: // global
           I64[Sp + 16] = block_cbis9_info;
           _cbis7::I64 = I64[Sp + 8];
           Sp = Sp + 16;
           _ubisy::P64 = CurrentTSO;
           I64[I64[_ubisy::P64 + 24] + 16] = Sp;
           _ubisz::I64 = CurrentNursery;
           P64[_ubisz::I64 + 8] = Hp + 8;
           I64[_ubisy::P64 + 104] = I64[_ubisy::P64 + 104] - ((Hp + 8) - I64[_ubisz::I64]);
           (_ubisw::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbinF::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_cbis7::I64, 8);
           (_ubisx::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubisw::I64);
           BaseReg = _ubisx::I64;
           _ubisA::P64 = CurrentTSO;
           _ubisB::P64 = I64[_ubisA::P64 + 24];
           Sp = I64[_ubisB::P64 + 16];
           SpLim = _ubisB::P64 + 192;
           HpAlloc = 0;
           _ubisC::I64 = CurrentNursery;
           _ubisD::I64 = I64[_ubisC::I64 + 8];
           Hp = _ubisD::I64 - 8;
           _ubisE::I64 = I64[_ubisC::I64];
           HpLim = _ubisE::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubisC::I64 + 48]) << 12) - 1);
           I64[_ubisA::P64 + 104] = I64[_ubisA::P64 + 104] + (_ubisD::I64 - _ubisE::I64);
           R1 = _sbinF::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbis9() //  [R1]
         { info_tbl: [(cbis9,
                       label: block_cbis9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbis9: // global
           if (%MO_SS_Conv_W64_W32(R1) == (-1) :: W32) goto cbisn; else goto cbish;
       cbisn: // global
           (_sbinK::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sbinK::I64;
           Sp = Sp + 8;
           call GHC.IO.Handle.Lock.hUnlock2_entry(R2) args: 8, res: 0, upd: 8;
       cbish: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.136695445 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock_closure" {
     GHC.IO.Handle.Lock.hUnlock_closure:
         const GHC.IO.Handle.Lock.hUnlock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock_entry() //  [R2]
         { info_tbl: [(cbisM,
                       label: GHC.IO.Handle.Lock.hUnlock_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbisM: // global
           R2 = R2;
           call GHC.IO.Handle.Lock.hUnlock1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.137922943 UTC

[section ""data" . GHC.IO.Handle.Lock.$wlvl_closure" {
     GHC.IO.Handle.Lock.$wlvl_closure:
         const GHC.IO.Handle.Lock.$wlvl_info;
         const 0;
 },
 sat_sbinV_entry() //  [R1]
         { info_tbl: [(cbit2,
                       label: sat_sbinV_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbit2: // global
           _sbinV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbit3; else goto cbit4;
       cbit4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbit6; else goto cbit5;
       cbit6: // global
           HpAlloc = 16;
           goto cbit3;
       cbit3: // global
           R1 = _sbinV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbit5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbinV::P64;
           _sbinR::P64 = P64[_sbinV::P64 + 16];
           _sbinS::P64 = P64[_sbinV::P64 + 24];
           _sbinQ::I64 = I64[_sbinV::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbinS::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sbinQ::I64;
           R2 = _sbinR::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbinW_entry() //  [R1]
         { info_tbl: [(cbit7,
                       label: sat_sbinW_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbit7: // global
           _sbinW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbit8; else goto cbit9;
       cbit9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbitb; else goto cbita;
       cbitb: // global
           HpAlloc = 40;
           goto cbit8;
       cbit8: // global
           R1 = _sbinW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbita: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbinW::P64;
           _sbinR::P64 = P64[_sbinW::P64 + 16];
           _sbinS::P64 = P64[_sbinW::P64 + 24];
           _sbinQ::I64 = I64[_sbinW::P64 + 32];
           I64[Hp - 32] = sat_sbinV_info;
           P64[Hp - 16] = _sbinR::P64;
           P64[Hp - 8] = _sbinS::P64;
           I64[Hp] = _sbinQ::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Lock.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(cbitc,
                       label: GHC.IO.Handle.Lock.$wlvl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbitc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbitg; else goto cbitf;
       cbitg: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbitf: // global
           I64[Hp - 32] = sat_sbinW_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.141154135 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock4_closure" {
     GHC.IO.Handle.Lock.hLock4_closure:
         const GHC.IO.Handle.Lock.hLock4_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbits,
                       label: GHC.IO.Handle.Lock.hLock4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbits: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbitt; else goto cbitu;
       cbitt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbitu: // global
           I64[Sp - 32] = block_cbitl_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubiwC; else goto cbitm;
       ubiwC: // global
           call _cbitl(R1) args: 0, res: 0, upd: 0;
       cbitm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbitl() //  [R1]
         { info_tbl: [(cbitl,
                       label: block_cbitl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbitl: // global
           if (R1 & 7 == 1) goto cbitp; else goto cbitq;
       cbitp: // global
           I64[Sp - 8] = block_cbitx_info;
           _sbio2::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbio2::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbitq: // global
           R2 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbitx() //  [R1]
         { info_tbl: [(cbitx,
                       label: block_cbitx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbitx: // global
           I64[Sp] = block_cbitz_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubiwD; else goto cbitA;
       ubiwD: // global
           call _cbitz(R1) args: 0, res: 0, upd: 0;
       cbitA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbitz() //  [R1]
         { info_tbl: [(cbitz,
                       label: block_cbitz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbitz: // global
           I64[Sp - 8] = block_cbitE_info;
           _sbiob::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbiob::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbitE() //  [R1]
         { info_tbl: [(cbitE,
                       label: block_cbitE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbitE: // global
           I64[Sp] = block_cbitL_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbitL() //  [R1]
         { info_tbl: [(cbitL,
                       label: block_cbitL_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbitL: // global
           if (R1 & 7 == 1) goto cbitS; else goto ubiwp;
       cbitS: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       ubiwp: // global
           Sp = Sp + 8;
           call _cbiub() args: 0, res: 0, upd: 0;
     }
 },
 _cbiub() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiub: // global
           I64[Sp - 8] = block_cbiuf_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiwF; else goto cbiw3;
       ubiwF: // global
           call _cbiuf(R1) args: 0, res: 0, upd: 0;
       cbiw3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiuf() //  [R1]
         { info_tbl: [(cbiuf,
                       label: block_cbiuf_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiuf: // global
           _sbio0::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbiw9; else goto cbiwd;
       cbiw9: // global
           _sbioD::I64 = 1;
           goto sbioC;
       cbiwd: // global
           _sbioD::I64 = 2;
           goto sbioC;
       sbioC: // global
           I64[Sp - 8] = block_cbium_info;
           R1 = _sbio0::P64;
           I64[Sp] = _sbioD::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiwG; else goto cbivS;
       ubiwG: // global
           call _cbium(R1) args: 0, res: 0, upd: 0;
       cbivS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbium() //  [R1]
         { info_tbl: [(cbium,
                       label: block_cbium_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbium: // global
           _sbioq::I64 = I64[Sp + 16];
           _sbioD::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbivY; else goto cbiw2;
       cbivY: // global
           _sbioF::I64 = 4;
           goto sbioE;
       cbiw2: // global
           _sbioF::I64 = 0;
           goto sbioE;
       sbioE: // global
           I64[Sp + 8] = block_cbiuH_info;
           Sp = Sp + 8;
           _ubiwu::P64 = CurrentTSO;
           I64[I64[_ubiwu::P64 + 24] + 16] = Sp;
           _ubiwv::I64 = CurrentNursery;
           P64[_ubiwv::I64 + 8] = Hp + 8;
           I64[_ubiwu::P64 + 104] = I64[_ubiwu::P64 + 104] - ((Hp + 8) - I64[_ubiwv::I64]);
           (_ubiws::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbioN::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_sbioq::I64, _sbioD::I64 | _sbioF::I64);
           (_ubiwt::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubiws::I64);
           BaseReg = _ubiwt::I64;
           _ubiww::P64 = CurrentTSO;
           _ubiwx::P64 = I64[_ubiww::P64 + 24];
           Sp = I64[_ubiwx::P64 + 16];
           SpLim = _ubiwx::P64 + 192;
           HpAlloc = 0;
           _ubiwy::I64 = CurrentNursery;
           _ubiwz::I64 = I64[_ubiwy::I64 + 8];
           Hp = _ubiwz::I64 - 8;
           _ubiwA::I64 = I64[_ubiwy::I64];
           HpLim = _ubiwA::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubiwy::I64 + 48]) << 12) - 1);
           I64[_ubiww::P64 + 104] = I64[_ubiww::P64 + 104] + (_ubiwz::I64 - _ubiwA::I64);
           R1 = _sbioN::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiuH() //  [R1]
         { info_tbl: [(cbiuH,
                       label: block_cbiuH_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiuH: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cbivO; else goto cbiuT;
       cbivO: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiuT: // global
           _sbio0::P64 = P64[Sp + 40];
           (_sbioS::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_cbiuR_info;
           R1 = _sbio0::P64;
           I64[Sp] = _sbioS::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiwH; else goto cbiuV;
       ubiwH: // global
           call _cbiuR(R1) args: 0, res: 0, upd: 0;
       cbiuV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiuR() //  [R1]
         { info_tbl: [(cbiuR,
                       label: block_cbiuR_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiuR: // global
           _sbinY::P64 = P64[Sp + 32];
           _sbio2::P64 = P64[Sp + 24];
           _sbioS::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbivs; else goto cbivL;
       cbivs: // global
           _sbioU::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbioS::I64));
           if (%MO_S_Ge_W64(_sbioU::I64, 14)) goto cbiv5; else goto ubiwm;
       ubiwm: // global
           if (%MO_S_Lt_W64(_sbioU::I64, 11)) goto ubiwn; else goto ubiwo;
       ubiwn: // global
           if (_sbioU::I64 != 4) goto cbiv5; else goto ubiwr;
       ubiwr: // global
           Sp = Sp + 16;
           goto ubiwJ;
       ubiwo: // global
           if (_sbioU::I64 == 12) goto cbiv5; else goto cbivn;
       cbiv5: // global
           R4 = _sbio2::P64;
           R3 = _sbinY::P64;
           R2 = _sbioU::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       cbivn: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbivL: // global
           _sbioV::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbioS::I64));
           if (_sbioV::I64 != 4) goto cbivB; else goto ubiwq;
       cbivB: // global
           R4 = _sbio2::P64;
           R3 = _sbinY::P64;
           R2 = _sbioV::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       ubiwq: // global
           Sp = Sp + 16;
           goto ubiwJ;
       ubiwJ: // global
           call _cbiub() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.145292498 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hTryLock3_bytes" {
     GHC.IO.Handle.Lock.hTryLock3_bytes:
         I8[] [104,84,114,121,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.146036444 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock2_closure" {
     GHC.IO.Handle.Lock.hTryLock2_closure:
         const GHC.IO.Handle.Lock.hTryLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock2_entry() //  [R1]
         { info_tbl: [(cbiwQ,
                       label: GHC.IO.Handle.Lock.hTryLock2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiwQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiwR; else goto cbiwS;
       cbiwR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiwS: // global
           (_cbiwN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiwN::I64 == 0) goto cbiwP; else goto cbiwO;
       cbiwP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiwO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiwN::I64;
           R2 = GHC.IO.Handle.Lock.hTryLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.147046471 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock1_closure" {
     GHC.IO.Handle.Lock.hTryLock1_closure:
         const GHC.IO.Handle.Lock.hTryLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock1_entry() //  [R2, R3]
         { info_tbl: [(cbiwX,
                       label: GHC.IO.Handle.Lock.hTryLock1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiwX: // global
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hTryLock2_closure;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.147898787 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock_closure" {
     GHC.IO.Handle.Lock.hTryLock_closure:
         const GHC.IO.Handle.Lock.hTryLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock_entry() //  [R2, R3]
         { info_tbl: [(cbix4,
                       label: GHC.IO.Handle.Lock.hTryLock_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbix4: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hTryLock1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.148643346 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hLock3_bytes" {
     GHC.IO.Handle.Lock.hLock3_bytes:
         I8[] [104,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.149373413 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock2_closure" {
     GHC.IO.Handle.Lock.hLock2_closure:
         const GHC.IO.Handle.Lock.hLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock2_entry() //  [R1]
         { info_tbl: [(cbixd,
                       label: GHC.IO.Handle.Lock.hLock2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbixe; else goto cbixf;
       cbixe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbixf: // global
           (_cbixa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbixa::I64 == 0) goto cbixc; else goto cbixb;
       cbixc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbixb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbixa::I64;
           R2 = GHC.IO.Handle.Lock.hLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.150470514 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock1_closure" {
     GHC.IO.Handle.Lock.hLock1_closure:
         const GHC.IO.Handle.Lock.hLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock1_entry() //  [R2, R3]
         { info_tbl: [(cbixm,
                       label: GHC.IO.Handle.Lock.hLock1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbixn; else goto cbixo;
       cbixn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbixo: // global
           I64[Sp - 8] = block_cbixk_info;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hLock2_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbixk() //  []
         { info_tbl: [(cbixk,
                       label: block_cbixk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixk: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.151557654 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock_closure" {
     GHC.IO.Handle.Lock.hLock_closure:
         const GHC.IO.Handle.Lock.hLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock_entry() //  [R2, R3]
         { info_tbl: [(cbixu,
                       label: GHC.IO.Handle.Lock.hLock_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixu: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.15227428 UTC

[section ""data" . GHC.IO.Handle.Lock.SharedLock_closure" {
     GHC.IO.Handle.Lock.SharedLock_closure:
         const GHC.IO.Handle.Lock.SharedLock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.152818724 UTC

[section ""data" . GHC.IO.Handle.Lock.ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.ExclusiveLock_closure:
         const GHC.IO.Handle.Lock.ExclusiveLock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.153563115 UTC

[section ""data" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.154082409 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.LockMode_closure_tbl" {
     GHC.IO.Handle.Lock.LockMode_closure_tbl:
         const GHC.IO.Handle.Lock.SharedLock_closure+1;
         const GHC.IO.Handle.Lock.ExclusiveLock_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.154681356 UTC

[GHC.IO.Handle.Lock.SharedLock_con_entry() //  [R1]
         { info_tbl: [(cbixx,
                       label: GHC.IO.Handle.Lock.SharedLock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,83,104,97,114,101,100,76,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixx: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.155437386 UTC

[GHC.IO.Handle.Lock.ExclusiveLock_con_entry() //  [R1]
         { info_tbl: [(cbixy,
                       label: GHC.IO.Handle.Lock.ExclusiveLock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,69,120,99,108,117,115,105,118,101,76,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixy: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.156113342 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.156754915 UTC

[GHC.IO.Handle.Lock.FileLockingNotSupported_con_entry() //  [R1]
         { info_tbl: [(cbixz,
                       label: GHC.IO.Handle.Lock.FileLockingNotSupported_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixz: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.157459916 UTC

[section ""relreadonly" . Sbipx_srt" {
     Sbipx_srt:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_rbimG_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const GHC.IO.Handle.Lock.hUnlock1_closure;
         const GHC.IO.Handle.Lock.hUnlock2_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Lock.$wlvl_closure;
         const GHC.IO.Handle.Lock.hLock4_closure;
         const GHC.IO.Handle.Lock.hTryLock2_closure;
         const GHC.IO.Handle.Lock.hTryLock1_closure;
         const GHC.IO.Handle.Lock.hLock1_closure;
         const GHC.IO.Handle.Lock.hLock2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.158172169 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:14.158667723 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes:
         I8[] [70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.159426706 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_entry() //  [R1]
         { info_tbl: [(cbixG,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbixH; else goto cbixI;
       cbixH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbixI: // global
           (_cbixD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbixD::I64 == 0) goto cbixF; else goto cbixE;
       cbixF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbixE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbixD::I64;
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.160585284 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { info_tbl: [(cbixQ,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbixR; else goto cbixS;
       cbixR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbixS: // global
           I64[Sp - 16] = block_cbixN_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubixW; else goto cbixO;
       ubixW: // global
           call _cbixN() args: 0, res: 0, upd: 0;
       cbixO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbixN() //  []
         { info_tbl: [(cbixN,
                       label: block_cbixN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbixN: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.161850622 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_entry() //  [R2]
         { info_tbl: [(cbiy4,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiy4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbiy5; else goto cbiy6;
       cbiy5: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiy6: // global
           I64[Sp - 8] = block_cbiy1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiya; else goto cbiy2;
       ubiya: // global
           call _cbiy1() args: 0, res: 0, upd: 0;
       cbiy2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiy1() //  []
         { info_tbl: [(cbiy1,
                       label: block_cbiy1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiy1: // global
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.16302485 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbiyi,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiyi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiyj; else goto cbiyk;
       cbiyj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiyk: // global
           I64[Sp - 16] = block_cbiyf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubiyo; else goto cbiyg;
       ubiyo: // global
           call _cbiyf() args: 0, res: 0, upd: 0;
       cbiyg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiyf() //  []
         { info_tbl: [(cbiyf,
                       label: block_cbiyf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiyf: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.164129378 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_entry() //  [R2,
                                                                          R3]
         { info_tbl: [(cbiyt,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiyt: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.164912642 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.165783282 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule4_bytes" {
     GHC.IO.Handle.Lock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.166321354 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule3_closure" {
     GHC.IO.Handle.Lock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.166853899 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule2_bytes" {
     GHC.IO.Handle.Lock.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.167397372 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule1_closure" {
     GHC.IO.Handle.Lock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.16796158 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule_closure" {
     GHC.IO.Handle.Lock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Lock.$trModule3_closure+1;
         const GHC.IO.Handle.Lock.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.168578582 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.169231915 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
         const GHC.Types.krep$*_closure;
         const 2716065848555532007;
         const 12251424812302631774;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.169842629 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.170463497 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes:
         I8[] [39,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.17110941 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.172941185 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure+1;
         const 13975601321420314475;
         const 8398323512000399582;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.174082017 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_entry() //  [R1]
         { info_tbl: [(cbiyH,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiyH: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbiyI; else goto cbiyJ;
       cbiyI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiyJ: // global
           (_cbiyz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiyz::I64 == 0) goto cbiyB; else goto cbiyA;
       cbiyB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiyA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiyz::I64;
           I64[Sp - 24] = block_cbiyC_info;
           R6 = 0;
           R5 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
           R4 = GHC.IO.Handle.Lock.$trModule_closure+1;
           R3 = 12251424812302631774;
           R2 = 2716065848555532007;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbiyC() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbiyC,
                       label: block_cbiyC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiyC: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbiyD() args: 0, res: 0, upd: 0;
     }
 },
 _cbiyD() //  []
         { info_tbl: [(cbiyD,
                       label: block_cbiyD_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiyD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbiyM; else goto cbiyL;
       cbiyM: // global
           HpAlloc = 48;
           I64[Sp] = block_cbiyD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbiyL: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.175946027 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_entry() //  [R2]
         { info_tbl: [(cbiyW,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiyW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiz0; else goto cbiz1;
       cbiz0: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiz1: // global
           I64[Sp - 8] = block_cbiyT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubizm; else goto cbiyU;
       ubizm: // global
           call _cbiyT(R1) args: 0, res: 0, upd: 0;
       cbiyU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiyT() //  [R1]
         { info_tbl: [(cbiyT,
                       label: block_cbiyT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiyT: // global
           I64[Sp - 8] = block_cbiyZ_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiyZ() //  [R1]
         { info_tbl: [(cbiyZ,
                       label: block_cbiyZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiyZ: // global
           I64[Sp] = block_cbiz6_info;
           R3 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiz6() //  [R1]
         { info_tbl: [(cbiz6,
                       label: block_cbiz6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiz6: // global
           if (R1 & 7 == 1) goto cbizd; else goto cbizh;
       cbizd: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbizh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbizk; else goto cbizj;
       cbizk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbizj: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.177916851 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_entry() //  [R2]
         { info_tbl: [(cbizs,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbizs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbizw; else goto cbizv;
       cbizw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbizv: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.178840666 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tcLockMode2_bytes" {
     GHC.IO.Handle.Lock.$tcLockMode2_bytes:
         I8[] [76,111,99,107,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.179369716 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode1_closure" {
     GHC.IO.Handle.Lock.$tcLockMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.179940082 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode_closure" {
     GHC.IO.Handle.Lock.$tcLockMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tcLockMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18068849831825836849;
         const 1974453150269185476;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.180546708 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.181100748 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'SharedLock2_bytes" {
     GHC.IO.Handle.Lock.$tc'SharedLock2_bytes:
         I8[] [39,83,104,97,114,101,100,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.181661495 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock1_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'SharedLock2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.182209617 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'SharedLock1_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 9660990538910196995;
         const 16983901031857135990;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.182804733 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes:
         I8[] [39,69,120,99,108,117,115,105,118,101,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.183369989 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.183884694 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 8544818512469904331;
         const 16785548070058023905;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.184493313 UTC

[section ""cstring" . lvl_rbimF_bytes" {
     lvl_rbimF_bytes:
         I8[] [102,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.185316309 UTC

[section ""data" . lvl1_rbimG_closure" {
     lvl1_rbimG_closure:
         const lvl1_rbimG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbimG_entry() //  [R1]
         { info_tbl: [(cbizD,
                       label: lvl1_rbimG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbizD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbizE; else goto cbizF;
       cbizE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbizF: // global
           (_cbizA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbizA::I64 == 0) goto cbizC; else goto cbizB;
       cbizC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbizB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbizA::I64;
           R2 = lvl_rbimF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.18638285 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock2_closure" {
     GHC.IO.Handle.Lock.hUnlock2_closure:
         const GHC.IO.Handle.Lock.hUnlock2_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock2_entry() //  [R2]
         { info_tbl: [(cbizM,
                       label: GHC.IO.Handle.Lock.hUnlock2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbizM: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_rbimG_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.187955062 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock1_closure" {
     GHC.IO.Handle.Lock.hUnlock1_closure:
         const GHC.IO.Handle.Lock.hUnlock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock1_entry() //  [R2]
         { info_tbl: [(cbiA0,
                       label: GHC.IO.Handle.Lock.hUnlock1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiA0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbiA1; else goto cbiA2;
       cbiA1: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hUnlock1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiA2: // global
           I64[Sp - 8] = block_cbizT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiB5; else goto cbizU;
       ubiB5: // global
           call _cbizT(R1) args: 0, res: 0, upd: 0;
       cbizU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbizT() //  [R1]
         { info_tbl: [(cbizT,
                       label: block_cbizT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbizT: // global
           if (R1 & 7 == 1) goto cbizX; else goto cbizY;
       cbizX: // global
           I64[Sp - 8] = block_cbiA5_info;
           _sbina::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbina::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbizY: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbiA5() //  [R1]
         { info_tbl: [(cbiA5,
                       label: block_cbiA5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiA5: // global
           I64[Sp] = block_cbiA7_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubiB6; else goto cbiA8;
       ubiB6: // global
           call _cbiA7(R1) args: 0, res: 0, upd: 0;
       cbiA8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiA7() //  [R1]
         { info_tbl: [(cbiA7,
                       label: block_cbiA7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiA7: // global
           I64[Sp - 8] = block_cbiAc_info;
           _sbinj::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbinj::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiAc() //  [R1]
         { info_tbl: [(cbiAc,
                       label: block_cbiAc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiAc: // global
           I64[Sp] = block_cbiAj_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiAj() //  [R1]
         { info_tbl: [(cbiAj,
                       label: block_cbiAj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiAj: // global
           if (R1 & 7 == 1) goto cbiAq; else goto cbiAu;
       cbiAq: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbiAu: // global
           I64[Sp + 16] = block_cbiAy_info;
           _cbiAw::I64 = I64[Sp + 8];
           Sp = Sp + 16;
           _ubiAX::P64 = CurrentTSO;
           I64[I64[_ubiAX::P64 + 24] + 16] = Sp;
           _ubiAY::I64 = CurrentNursery;
           P64[_ubiAY::I64 + 8] = Hp + 8;
           I64[_ubiAX::P64 + 104] = I64[_ubiAX::P64 + 104] - ((Hp + 8) - I64[_ubiAY::I64]);
           (_ubiAV::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbinF::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_cbiAw::I64, 8);
           (_ubiAW::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubiAV::I64);
           BaseReg = _ubiAW::I64;
           _ubiAZ::P64 = CurrentTSO;
           _ubiB0::P64 = I64[_ubiAZ::P64 + 24];
           Sp = I64[_ubiB0::P64 + 16];
           SpLim = _ubiB0::P64 + 192;
           HpAlloc = 0;
           _ubiB1::I64 = CurrentNursery;
           _ubiB2::I64 = I64[_ubiB1::I64 + 8];
           Hp = _ubiB2::I64 - 8;
           _ubiB3::I64 = I64[_ubiB1::I64];
           HpLim = _ubiB3::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubiB1::I64 + 48]) << 12) - 1);
           I64[_ubiAZ::P64 + 104] = I64[_ubiAZ::P64 + 104] + (_ubiB2::I64 - _ubiB3::I64);
           R1 = _sbinF::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiAy() //  [R1]
         { info_tbl: [(cbiAy,
                       label: block_cbiAy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiAy: // global
           if (%MO_SS_Conv_W64_W32(R1) == (-1) :: W32) goto cbiAM; else goto cbiAG;
       cbiAM: // global
           (_sbinK::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sbinK::I64;
           Sp = Sp + 8;
           call GHC.IO.Handle.Lock.hUnlock2_entry(R2) args: 8, res: 0, upd: 8;
       cbiAG: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.190826434 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock_closure" {
     GHC.IO.Handle.Lock.hUnlock_closure:
         const GHC.IO.Handle.Lock.hUnlock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock_entry() //  [R2]
         { info_tbl: [(cbiBb,
                       label: GHC.IO.Handle.Lock.hUnlock_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiBb: // global
           R2 = R2;
           call GHC.IO.Handle.Lock.hUnlock1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.192025488 UTC

[section ""data" . GHC.IO.Handle.Lock.$wlvl_closure" {
     GHC.IO.Handle.Lock.$wlvl_closure:
         const GHC.IO.Handle.Lock.$wlvl_info;
         const 0;
 },
 sat_sbinV_entry() //  [R1]
         { info_tbl: [(cbiBr,
                       label: sat_sbinV_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiBr: // global
           _sbinV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbiBs; else goto cbiBt;
       cbiBt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbiBv; else goto cbiBu;
       cbiBv: // global
           HpAlloc = 16;
           goto cbiBs;
       cbiBs: // global
           R1 = _sbinV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiBu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbinV::P64;
           _sbinR::P64 = P64[_sbinV::P64 + 16];
           _sbinS::P64 = P64[_sbinV::P64 + 24];
           _sbinQ::I64 = I64[_sbinV::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbinS::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sbinQ::I64;
           R2 = _sbinR::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbinW_entry() //  [R1]
         { info_tbl: [(cbiBw,
                       label: sat_sbinW_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiBw: // global
           _sbinW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbiBx; else goto cbiBy;
       cbiBy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbiBA; else goto cbiBz;
       cbiBA: // global
           HpAlloc = 40;
           goto cbiBx;
       cbiBx: // global
           R1 = _sbinW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiBz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbinW::P64;
           _sbinR::P64 = P64[_sbinW::P64 + 16];
           _sbinS::P64 = P64[_sbinW::P64 + 24];
           _sbinQ::I64 = I64[_sbinW::P64 + 32];
           I64[Hp - 32] = sat_sbinV_info;
           P64[Hp - 16] = _sbinR::P64;
           P64[Hp - 8] = _sbinS::P64;
           I64[Hp] = _sbinQ::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Lock.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(cbiBB,
                       label: GHC.IO.Handle.Lock.$wlvl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiBB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbiBF; else goto cbiBE;
       cbiBF: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiBE: // global
           I64[Hp - 32] = sat_sbinW_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.195363879 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock4_closure" {
     GHC.IO.Handle.Lock.hLock4_closure:
         const GHC.IO.Handle.Lock.hLock4_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbiBR,
                       label: GHC.IO.Handle.Lock.hLock4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiBR: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbiBS; else goto cbiBT;
       cbiBS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiBT: // global
           I64[Sp - 32] = block_cbiBK_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubiF1; else goto cbiBL;
       ubiF1: // global
           call _cbiBK(R1) args: 0, res: 0, upd: 0;
       cbiBL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiBK() //  [R1]
         { info_tbl: [(cbiBK,
                       label: block_cbiBK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiBK: // global
           if (R1 & 7 == 1) goto cbiBO; else goto cbiBP;
       cbiBO: // global
           I64[Sp - 8] = block_cbiBW_info;
           _sbio2::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbio2::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbiBP: // global
           R2 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbiBW() //  [R1]
         { info_tbl: [(cbiBW,
                       label: block_cbiBW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiBW: // global
           I64[Sp] = block_cbiBY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubiF2; else goto cbiBZ;
       ubiF2: // global
           call _cbiBY(R1) args: 0, res: 0, upd: 0;
       cbiBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiBY() //  [R1]
         { info_tbl: [(cbiBY,
                       label: block_cbiBY_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiBY: // global
           I64[Sp - 8] = block_cbiC3_info;
           _sbiob::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbiob::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiC3() //  [R1]
         { info_tbl: [(cbiC3,
                       label: block_cbiC3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiC3: // global
           I64[Sp] = block_cbiCa_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiCa() //  [R1]
         { info_tbl: [(cbiCa,
                       label: block_cbiCa_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiCa: // global
           if (R1 & 7 == 1) goto cbiCh; else goto ubiEO;
       cbiCh: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       ubiEO: // global
           Sp = Sp + 8;
           call _cbiCA() args: 0, res: 0, upd: 0;
     }
 },
 _cbiCA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiCA: // global
           I64[Sp - 8] = block_cbiCE_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiF4; else goto cbiEs;
       ubiF4: // global
           call _cbiCE(R1) args: 0, res: 0, upd: 0;
       cbiEs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiCE() //  [R1]
         { info_tbl: [(cbiCE,
                       label: block_cbiCE_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiCE: // global
           _sbio0::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbiEy; else goto cbiEC;
       cbiEy: // global
           _sbioD::I64 = 1;
           goto sbioC;
       cbiEC: // global
           _sbioD::I64 = 2;
           goto sbioC;
       sbioC: // global
           I64[Sp - 8] = block_cbiCL_info;
           R1 = _sbio0::P64;
           I64[Sp] = _sbioD::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiF5; else goto cbiEh;
       ubiF5: // global
           call _cbiCL(R1) args: 0, res: 0, upd: 0;
       cbiEh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiCL() //  [R1]
         { info_tbl: [(cbiCL,
                       label: block_cbiCL_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiCL: // global
           _sbioq::I64 = I64[Sp + 16];
           _sbioD::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbiEn; else goto cbiEr;
       cbiEn: // global
           _sbioF::I64 = 4;
           goto sbioE;
       cbiEr: // global
           _sbioF::I64 = 0;
           goto sbioE;
       sbioE: // global
           I64[Sp + 8] = block_cbiD6_info;
           Sp = Sp + 8;
           _ubiET::P64 = CurrentTSO;
           I64[I64[_ubiET::P64 + 24] + 16] = Sp;
           _ubiEU::I64 = CurrentNursery;
           P64[_ubiEU::I64 + 8] = Hp + 8;
           I64[_ubiET::P64 + 104] = I64[_ubiET::P64 + 104] - ((Hp + 8) - I64[_ubiEU::I64]);
           (_ubiER::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbioN::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_sbioq::I64, _sbioD::I64 | _sbioF::I64);
           (_ubiES::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubiER::I64);
           BaseReg = _ubiES::I64;
           _ubiEV::P64 = CurrentTSO;
           _ubiEW::P64 = I64[_ubiEV::P64 + 24];
           Sp = I64[_ubiEW::P64 + 16];
           SpLim = _ubiEW::P64 + 192;
           HpAlloc = 0;
           _ubiEX::I64 = CurrentNursery;
           _ubiEY::I64 = I64[_ubiEX::I64 + 8];
           Hp = _ubiEY::I64 - 8;
           _ubiEZ::I64 = I64[_ubiEX::I64];
           HpLim = _ubiEZ::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubiEX::I64 + 48]) << 12) - 1);
           I64[_ubiEV::P64 + 104] = I64[_ubiEV::P64 + 104] + (_ubiEY::I64 - _ubiEZ::I64);
           R1 = _sbioN::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiD6() //  [R1]
         { info_tbl: [(cbiD6,
                       label: block_cbiD6_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiD6: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cbiEd; else goto cbiDi;
       cbiEd: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiDi: // global
           _sbio0::P64 = P64[Sp + 40];
           (_sbioS::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_cbiDg_info;
           R1 = _sbio0::P64;
           I64[Sp] = _sbioS::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiF6; else goto cbiDk;
       ubiF6: // global
           call _cbiDg(R1) args: 0, res: 0, upd: 0;
       cbiDk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiDg() //  [R1]
         { info_tbl: [(cbiDg,
                       label: block_cbiDg_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiDg: // global
           _sbinY::P64 = P64[Sp + 32];
           _sbio2::P64 = P64[Sp + 24];
           _sbioS::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbiDR; else goto cbiEa;
       cbiDR: // global
           _sbioU::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbioS::I64));
           if (%MO_S_Ge_W64(_sbioU::I64, 14)) goto cbiDu; else goto ubiEL;
       ubiEL: // global
           if (%MO_S_Lt_W64(_sbioU::I64, 11)) goto ubiEM; else goto ubiEN;
       ubiEM: // global
           if (_sbioU::I64 != 4) goto cbiDu; else goto ubiEQ;
       ubiEQ: // global
           Sp = Sp + 16;
           goto ubiF8;
       ubiEN: // global
           if (_sbioU::I64 == 12) goto cbiDu; else goto cbiDM;
       cbiDu: // global
           R4 = _sbio2::P64;
           R3 = _sbinY::P64;
           R2 = _sbioU::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       cbiDM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiEa: // global
           _sbioV::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbioS::I64));
           if (_sbioV::I64 != 4) goto cbiE0; else goto ubiEP;
       cbiE0: // global
           R4 = _sbio2::P64;
           R3 = _sbinY::P64;
           R2 = _sbioV::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       ubiEP: // global
           Sp = Sp + 16;
           goto ubiF8;
       ubiF8: // global
           call _cbiCA() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.199193848 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hTryLock3_bytes" {
     GHC.IO.Handle.Lock.hTryLock3_bytes:
         I8[] [104,84,114,121,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.199920513 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock2_closure" {
     GHC.IO.Handle.Lock.hTryLock2_closure:
         const GHC.IO.Handle.Lock.hTryLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock2_entry() //  [R1]
         { info_tbl: [(cbiFf,
                       label: GHC.IO.Handle.Lock.hTryLock2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiFf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiFg; else goto cbiFh;
       cbiFg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiFh: // global
           (_cbiFc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiFc::I64 == 0) goto cbiFe; else goto cbiFd;
       cbiFe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiFd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiFc::I64;
           R2 = GHC.IO.Handle.Lock.hTryLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.200929597 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock1_closure" {
     GHC.IO.Handle.Lock.hTryLock1_closure:
         const GHC.IO.Handle.Lock.hTryLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock1_entry() //  [R2, R3]
         { info_tbl: [(cbiFm,
                       label: GHC.IO.Handle.Lock.hTryLock1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiFm: // global
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hTryLock2_closure;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.201846158 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock_closure" {
     GHC.IO.Handle.Lock.hTryLock_closure:
         const GHC.IO.Handle.Lock.hTryLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock_entry() //  [R2, R3]
         { info_tbl: [(cbiFt,
                       label: GHC.IO.Handle.Lock.hTryLock_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiFt: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hTryLock1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.202567729 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hLock3_bytes" {
     GHC.IO.Handle.Lock.hLock3_bytes:
         I8[] [104,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.20331463 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock2_closure" {
     GHC.IO.Handle.Lock.hLock2_closure:
         const GHC.IO.Handle.Lock.hLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock2_entry() //  [R1]
         { info_tbl: [(cbiFC,
                       label: GHC.IO.Handle.Lock.hLock2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiFC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiFD; else goto cbiFE;
       cbiFD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiFE: // global
           (_cbiFz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiFz::I64 == 0) goto cbiFB; else goto cbiFA;
       cbiFB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiFA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiFz::I64;
           R2 = GHC.IO.Handle.Lock.hLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.2043752 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock1_closure" {
     GHC.IO.Handle.Lock.hLock1_closure:
         const GHC.IO.Handle.Lock.hLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock1_entry() //  [R2, R3]
         { info_tbl: [(cbiFL,
                       label: GHC.IO.Handle.Lock.hLock1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiFL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbiFM; else goto cbiFN;
       cbiFM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiFN: // global
           I64[Sp - 8] = block_cbiFJ_info;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hLock2_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiFJ() //  []
         { info_tbl: [(cbiFJ,
                       label: block_cbiFJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiFJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.205826019 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock_closure" {
     GHC.IO.Handle.Lock.hLock_closure:
         const GHC.IO.Handle.Lock.hLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock_entry() //  [R2, R3]
         { info_tbl: [(cbiFT,
                       label: GHC.IO.Handle.Lock.hLock_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiFT: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.206551049 UTC

[section ""data" . GHC.IO.Handle.Lock.SharedLock_closure" {
     GHC.IO.Handle.Lock.SharedLock_closure:
         const GHC.IO.Handle.Lock.SharedLock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.20709977 UTC

[section ""data" . GHC.IO.Handle.Lock.ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.ExclusiveLock_closure:
         const GHC.IO.Handle.Lock.ExclusiveLock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.207648199 UTC

[section ""data" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.208175304 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.LockMode_closure_tbl" {
     GHC.IO.Handle.Lock.LockMode_closure_tbl:
         const GHC.IO.Handle.Lock.SharedLock_closure+1;
         const GHC.IO.Handle.Lock.ExclusiveLock_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.208789743 UTC

[GHC.IO.Handle.Lock.SharedLock_con_entry() //  [R1]
         { info_tbl: [(cbiFW,
                       label: GHC.IO.Handle.Lock.SharedLock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,83,104,97,114,101,100,76,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiFW: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.209556585 UTC

[GHC.IO.Handle.Lock.ExclusiveLock_con_entry() //  [R1]
         { info_tbl: [(cbiFY,
                       label: GHC.IO.Handle.Lock.ExclusiveLock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,69,120,99,108,117,115,105,118,101,76,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiFY: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.210230626 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.21081495 UTC

[GHC.IO.Handle.Lock.FileLockingNotSupported_con_entry() //  [R1]
         { info_tbl: [(cbiG0,
                       label: GHC.IO.Handle.Lock.FileLockingNotSupported_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiG0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.211526735 UTC

[section ""relreadonly" . Sbipx_srt" {
     Sbipx_srt:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_rbimG_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const GHC.IO.Handle.Lock.hUnlock1_closure;
         const GHC.IO.Handle.Lock.hUnlock2_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Lock.$wlvl_closure;
         const GHC.IO.Handle.Lock.hLock4_closure;
         const GHC.IO.Handle.Lock.hTryLock2_closure;
         const GHC.IO.Handle.Lock.hTryLock1_closure;
         const GHC.IO.Handle.Lock.hLock1_closure;
         const GHC.IO.Handle.Lock.hLock2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.212546567 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:14.213773387 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes:
         I8[] [70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.217166828 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_entry() //  [R1]
         { info_tbl: [(cbiG9,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiG9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiGa; else goto cbiGb;
       cbiGa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiGb: // global
           (_cbiG6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiG6::I64 == 0) goto cbiG8; else goto cbiG7;
       cbiG8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiG7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiG6::I64;
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.221674204 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { info_tbl: [(cbiGq,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiGq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiGr; else goto cbiGs;
       cbiGr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiGs: // global
           I64[Sp - 16] = block_cbiGn_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubiGw; else goto cbiGo;
       ubiGw: // global
           call _cbiGn() args: 0, res: 0, upd: 0;
       cbiGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiGn() //  []
         { info_tbl: [(cbiGn,
                       label: block_cbiGn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiGn: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.22723977 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_entry() //  [R2]
         { info_tbl: [(cbiGN,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiGN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbiGO; else goto cbiGP;
       cbiGO: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiGP: // global
           I64[Sp - 8] = block_cbiGK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiGT; else goto cbiGL;
       ubiGT: // global
           call _cbiGK() args: 0, res: 0, upd: 0;
       cbiGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiGK() //  []
         { info_tbl: [(cbiGK,
                       label: block_cbiGK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiGK: // global
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.233075722 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbiHb,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiHb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiHc; else goto cbiHd;
       cbiHc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiHd: // global
           I64[Sp - 16] = block_cbiH8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubiHh; else goto cbiH9;
       ubiHh: // global
           call _cbiH8() args: 0, res: 0, upd: 0;
       cbiH9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiH8() //  []
         { info_tbl: [(cbiH8,
                       label: block_cbiH8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiH8: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.238504311 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_entry() //  [R2,
                                                                          R3]
         { info_tbl: [(cbiHv,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiHv: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.242268491 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.244066252 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule4_bytes" {
     GHC.IO.Handle.Lock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.245762423 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule3_closure" {
     GHC.IO.Handle.Lock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.247463943 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule2_bytes" {
     GHC.IO.Handle.Lock.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.249909387 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule1_closure" {
     GHC.IO.Handle.Lock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.251525054 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule_closure" {
     GHC.IO.Handle.Lock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Lock.$trModule3_closure+1;
         const GHC.IO.Handle.Lock.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.253668052 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.255348774 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
         const GHC.Types.krep$*_closure;
         const 2716065848555532007;
         const 12251424812302631774;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.257257616 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.259015288 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes:
         I8[] [39,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.260643653 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.26247541 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure+1;
         const 13975601321420314475;
         const 8398323512000399582;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.264895729 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_entry() //  [R1]
         { info_tbl: [(cbiHZ,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiHZ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbiI0; else goto cbiI1;
       cbiI0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiI1: // global
           (_cbiHR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiHR::I64 == 0) goto cbiHT; else goto cbiHS;
       cbiHT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiHS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiHR::I64;
           I64[Sp - 24] = block_cbiHU_info;
           R6 = 0;
           R5 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
           R4 = GHC.IO.Handle.Lock.$trModule_closure+1;
           R3 = 12251424812302631774;
           R2 = 2716065848555532007;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbiHU() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbiHU,
                       label: block_cbiHU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiHU: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbiHV() args: 0, res: 0, upd: 0;
     }
 },
 _cbiHV() //  []
         { info_tbl: [(cbiHV,
                       label: block_cbiHV_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiHV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbiI4; else goto cbiI3;
       cbiI4: // global
           HpAlloc = 48;
           I64[Sp] = block_cbiHV_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbiI3: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.273883735 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_entry() //  [R2]
         { info_tbl: [(cbiIx,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiIx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiIB; else goto cbiIC;
       cbiIB: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiIC: // global
           I64[Sp - 8] = block_cbiIu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiIX; else goto cbiIv;
       ubiIX: // global
           call _cbiIu(R1) args: 0, res: 0, upd: 0;
       cbiIv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiIu() //  [R1]
         { info_tbl: [(cbiIu,
                       label: block_cbiIu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiIu: // global
           I64[Sp - 8] = block_cbiIA_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiIA() //  [R1]
         { info_tbl: [(cbiIA,
                       label: block_cbiIA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiIA: // global
           I64[Sp] = block_cbiIH_info;
           R3 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiIH() //  [R1]
         { info_tbl: [(cbiIH,
                       label: block_cbiIH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiIH: // global
           if (R1 & 7 == 1) goto cbiIO; else goto cbiIS;
       cbiIO: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiIS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbiIV; else goto cbiIU;
       cbiIV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbiIU: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.284041009 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_entry() //  [R2]
         { info_tbl: [(cbiJo,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiJo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbiJs; else goto cbiJr;
       cbiJs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiJr: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.288302978 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tcLockMode2_bytes" {
     GHC.IO.Handle.Lock.$tcLockMode2_bytes:
         I8[] [76,111,99,107,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.29023312 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode1_closure" {
     GHC.IO.Handle.Lock.$tcLockMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.291959034 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode_closure" {
     GHC.IO.Handle.Lock.$tcLockMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tcLockMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18068849831825836849;
         const 1974453150269185476;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.293782384 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.295473077 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'SharedLock2_bytes" {
     GHC.IO.Handle.Lock.$tc'SharedLock2_bytes:
         I8[] [39,83,104,97,114,101,100,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.297085035 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock1_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'SharedLock2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.298806377 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'SharedLock1_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 9660990538910196995;
         const 16983901031857135990;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.300617818 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes:
         I8[] [39,69,120,99,108,117,115,105,118,101,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.302677039 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.304399716 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 8544818512469904331;
         const 16785548070058023905;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.30627626 UTC

[section ""cstring" . lvl_rbimF_bytes" {
     lvl_rbimF_bytes:
         I8[] [102,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.308271218 UTC

[section ""data" . lvl1_rbimG_closure" {
     lvl1_rbimG_closure:
         const lvl1_rbimG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbimG_entry() //  [R1]
         { info_tbl: [(cbiJQ,
                       label: lvl1_rbimG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiJQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiJR; else goto cbiJS;
       cbiJR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiJS: // global
           (_cbiJN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiJN::I64 == 0) goto cbiJP; else goto cbiJO;
       cbiJP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiJO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiJN::I64;
           R2 = lvl_rbimF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.312839102 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock2_closure" {
     GHC.IO.Handle.Lock.hUnlock2_closure:
         const GHC.IO.Handle.Lock.hUnlock2_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock2_entry() //  [R2]
         { info_tbl: [(cbiK6,
                       label: GHC.IO.Handle.Lock.hUnlock2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiK6: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_rbimG_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.31756147 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock1_closure" {
     GHC.IO.Handle.Lock.hUnlock1_closure:
         const GHC.IO.Handle.Lock.hUnlock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock1_entry() //  [R2]
         { info_tbl: [(cbiKo,
                       label: GHC.IO.Handle.Lock.hUnlock1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiKo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbiKp; else goto cbiKq;
       cbiKp: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hUnlock1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiKq: // global
           I64[Sp - 8] = block_cbiKh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiLt; else goto cbiKi;
       ubiLt: // global
           call _cbiKh(R1) args: 0, res: 0, upd: 0;
       cbiKi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiKh() //  [R1]
         { info_tbl: [(cbiKh,
                       label: block_cbiKh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiKh: // global
           if (R1 & 7 == 1) goto cbiKl; else goto cbiKm;
       cbiKl: // global
           I64[Sp - 8] = block_cbiKt_info;
           _sbina::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbina::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbiKm: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbiKt() //  [R1]
         { info_tbl: [(cbiKt,
                       label: block_cbiKt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiKt: // global
           I64[Sp] = block_cbiKv_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubiLu; else goto cbiKw;
       ubiLu: // global
           call _cbiKv(R1) args: 0, res: 0, upd: 0;
       cbiKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiKv() //  [R1]
         { info_tbl: [(cbiKv,
                       label: block_cbiKv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiKv: // global
           I64[Sp - 8] = block_cbiKA_info;
           _sbinj::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbinj::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiKA() //  [R1]
         { info_tbl: [(cbiKA,
                       label: block_cbiKA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiKA: // global
           I64[Sp] = block_cbiKH_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiKH() //  [R1]
         { info_tbl: [(cbiKH,
                       label: block_cbiKH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiKH: // global
           if (R1 & 7 == 1) goto cbiKO; else goto cbiKS;
       cbiKO: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbiKS: // global
           I64[Sp + 16] = block_cbiKW_info;
           _cbiKU::I64 = I64[Sp + 8];
           Sp = Sp + 16;
           _ubiLl::P64 = CurrentTSO;
           I64[I64[_ubiLl::P64 + 24] + 16] = Sp;
           _ubiLm::I64 = CurrentNursery;
           P64[_ubiLm::I64 + 8] = Hp + 8;
           I64[_ubiLl::P64 + 104] = I64[_ubiLl::P64 + 104] - ((Hp + 8) - I64[_ubiLm::I64]);
           (_ubiLj::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbinF::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_cbiKU::I64, 8);
           (_ubiLk::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubiLj::I64);
           BaseReg = _ubiLk::I64;
           _ubiLn::P64 = CurrentTSO;
           _ubiLo::P64 = I64[_ubiLn::P64 + 24];
           Sp = I64[_ubiLo::P64 + 16];
           SpLim = _ubiLo::P64 + 192;
           HpAlloc = 0;
           _ubiLp::I64 = CurrentNursery;
           _ubiLq::I64 = I64[_ubiLp::I64 + 8];
           Hp = _ubiLq::I64 - 8;
           _ubiLr::I64 = I64[_ubiLp::I64];
           HpLim = _ubiLr::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubiLp::I64 + 48]) << 12) - 1);
           I64[_ubiLn::P64 + 104] = I64[_ubiLn::P64 + 104] + (_ubiLq::I64 - _ubiLr::I64);
           R1 = _sbinF::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiKW() //  [R1]
         { info_tbl: [(cbiKW,
                       label: block_cbiKW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiKW: // global
           if (%MO_SS_Conv_W64_W32(R1) == (-1) :: W32) goto cbiLa; else goto cbiL4;
       cbiLa: // global
           (_sbinK::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sbinK::I64;
           Sp = Sp + 8;
           call GHC.IO.Handle.Lock.hUnlock2_entry(R2) args: 8, res: 0, upd: 8;
       cbiL4: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.332952744 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock_closure" {
     GHC.IO.Handle.Lock.hUnlock_closure:
         const GHC.IO.Handle.Lock.hUnlock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock_entry() //  [R2]
         { info_tbl: [(cbiMj,
                       label: GHC.IO.Handle.Lock.hUnlock_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiMj: // global
           R2 = R2;
           call GHC.IO.Handle.Lock.hUnlock1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.336753493 UTC

[section ""data" . GHC.IO.Handle.Lock.$wlvl_closure" {
     GHC.IO.Handle.Lock.$wlvl_closure:
         const GHC.IO.Handle.Lock.$wlvl_info;
         const 0;
 },
 sat_sbinV_entry() //  [R1]
         { info_tbl: [(cbiMD,
                       label: sat_sbinV_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiMD: // global
           _sbinV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbiME; else goto cbiMF;
       cbiMF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbiMH; else goto cbiMG;
       cbiMH: // global
           HpAlloc = 16;
           goto cbiME;
       cbiME: // global
           R1 = _sbinV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiMG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbinV::P64;
           _sbinR::P64 = P64[_sbinV::P64 + 16];
           _sbinS::P64 = P64[_sbinV::P64 + 24];
           _sbinQ::I64 = I64[_sbinV::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbinS::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sbinQ::I64;
           R2 = _sbinR::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbinW_entry() //  [R1]
         { info_tbl: [(cbiMI,
                       label: sat_sbinW_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiMI: // global
           _sbinW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbiMJ; else goto cbiMK;
       cbiMK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbiMM; else goto cbiML;
       cbiMM: // global
           HpAlloc = 40;
           goto cbiMJ;
       cbiMJ: // global
           R1 = _sbinW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiML: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbinW::P64;
           _sbinR::P64 = P64[_sbinW::P64 + 16];
           _sbinS::P64 = P64[_sbinW::P64 + 24];
           _sbinQ::I64 = I64[_sbinW::P64 + 32];
           I64[Hp - 32] = sat_sbinV_info;
           P64[Hp - 16] = _sbinR::P64;
           P64[Hp - 8] = _sbinS::P64;
           I64[Hp] = _sbinQ::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Lock.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(cbiMN,
                       label: GHC.IO.Handle.Lock.$wlvl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiMN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbiMR; else goto cbiMQ;
       cbiMR: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiMQ: // global
           I64[Hp - 32] = sat_sbinW_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.347130965 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock4_closure" {
     GHC.IO.Handle.Lock.hLock4_closure:
         const GHC.IO.Handle.Lock.hLock4_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbiNf,
                       label: GHC.IO.Handle.Lock.hLock4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiNf: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbiNg; else goto cbiNh;
       cbiNg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiNh: // global
           I64[Sp - 32] = block_cbiN8_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubiQp; else goto cbiN9;
       ubiQp: // global
           call _cbiN8(R1) args: 0, res: 0, upd: 0;
       cbiN9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiN8() //  [R1]
         { info_tbl: [(cbiN8,
                       label: block_cbiN8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiN8: // global
           if (R1 & 7 == 1) goto cbiNc; else goto cbiNd;
       cbiNc: // global
           I64[Sp - 8] = block_cbiNk_info;
           _sbio2::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbio2::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbiNd: // global
           R2 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbiNk() //  [R1]
         { info_tbl: [(cbiNk,
                       label: block_cbiNk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiNk: // global
           I64[Sp] = block_cbiNm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubiQq; else goto cbiNn;
       ubiQq: // global
           call _cbiNm(R1) args: 0, res: 0, upd: 0;
       cbiNn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiNm() //  [R1]
         { info_tbl: [(cbiNm,
                       label: block_cbiNm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiNm: // global
           I64[Sp - 8] = block_cbiNr_info;
           _sbiob::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbiob::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiNr() //  [R1]
         { info_tbl: [(cbiNr,
                       label: block_cbiNr_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiNr: // global
           I64[Sp] = block_cbiNy_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiNy() //  [R1]
         { info_tbl: [(cbiNy,
                       label: block_cbiNy_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiNy: // global
           if (R1 & 7 == 1) goto cbiNF; else goto ubiQc;
       cbiNF: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       ubiQc: // global
           Sp = Sp + 8;
           call _cbiNY() args: 0, res: 0, upd: 0;
     }
 },
 _cbiNY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiNY: // global
           I64[Sp - 8] = block_cbiO2_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiQs; else goto cbiPQ;
       ubiQs: // global
           call _cbiO2(R1) args: 0, res: 0, upd: 0;
       cbiPQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiO2() //  [R1]
         { info_tbl: [(cbiO2,
                       label: block_cbiO2_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiO2: // global
           _sbio0::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbiPW; else goto cbiQ0;
       cbiPW: // global
           _sbioD::I64 = 1;
           goto sbioC;
       cbiQ0: // global
           _sbioD::I64 = 2;
           goto sbioC;
       sbioC: // global
           I64[Sp - 8] = block_cbiO9_info;
           R1 = _sbio0::P64;
           I64[Sp] = _sbioD::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiQt; else goto cbiPF;
       ubiQt: // global
           call _cbiO9(R1) args: 0, res: 0, upd: 0;
       cbiPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiO9() //  [R1]
         { info_tbl: [(cbiO9,
                       label: block_cbiO9_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiO9: // global
           _sbioq::I64 = I64[Sp + 16];
           _sbioD::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbiPL; else goto cbiPP;
       cbiPL: // global
           _sbioF::I64 = 4;
           goto sbioE;
       cbiPP: // global
           _sbioF::I64 = 0;
           goto sbioE;
       sbioE: // global
           I64[Sp + 8] = block_cbiOu_info;
           Sp = Sp + 8;
           _ubiQh::P64 = CurrentTSO;
           I64[I64[_ubiQh::P64 + 24] + 16] = Sp;
           _ubiQi::I64 = CurrentNursery;
           P64[_ubiQi::I64 + 8] = Hp + 8;
           I64[_ubiQh::P64 + 104] = I64[_ubiQh::P64 + 104] - ((Hp + 8) - I64[_ubiQi::I64]);
           (_ubiQf::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbioN::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_sbioq::I64, _sbioD::I64 | _sbioF::I64);
           (_ubiQg::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubiQf::I64);
           BaseReg = _ubiQg::I64;
           _ubiQj::P64 = CurrentTSO;
           _ubiQk::P64 = I64[_ubiQj::P64 + 24];
           Sp = I64[_ubiQk::P64 + 16];
           SpLim = _ubiQk::P64 + 192;
           HpAlloc = 0;
           _ubiQl::I64 = CurrentNursery;
           _ubiQm::I64 = I64[_ubiQl::I64 + 8];
           Hp = _ubiQm::I64 - 8;
           _ubiQn::I64 = I64[_ubiQl::I64];
           HpLim = _ubiQn::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubiQl::I64 + 48]) << 12) - 1);
           I64[_ubiQj::P64 + 104] = I64[_ubiQj::P64 + 104] + (_ubiQm::I64 - _ubiQn::I64);
           R1 = _sbioN::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiOu() //  [R1]
         { info_tbl: [(cbiOu,
                       label: block_cbiOu_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiOu: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cbiPB; else goto cbiOG;
       cbiPB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiOG: // global
           _sbio0::P64 = P64[Sp + 40];
           (_sbioS::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_cbiOE_info;
           R1 = _sbio0::P64;
           I64[Sp] = _sbioS::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiQu; else goto cbiOI;
       ubiQu: // global
           call _cbiOE(R1) args: 0, res: 0, upd: 0;
       cbiOI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiOE() //  [R1]
         { info_tbl: [(cbiOE,
                       label: block_cbiOE_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiOE: // global
           _sbinY::P64 = P64[Sp + 32];
           _sbio2::P64 = P64[Sp + 24];
           _sbioS::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbiPf; else goto cbiPy;
       cbiPf: // global
           _sbioU::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbioS::I64));
           if (%MO_S_Ge_W64(_sbioU::I64, 14)) goto cbiOS; else goto ubiQ9;
       ubiQ9: // global
           if (%MO_S_Lt_W64(_sbioU::I64, 11)) goto ubiQa; else goto ubiQb;
       ubiQa: // global
           if (_sbioU::I64 != 4) goto cbiOS; else goto ubiQe;
       ubiQe: // global
           Sp = Sp + 16;
           goto ubiQw;
       ubiQb: // global
           if (_sbioU::I64 == 12) goto cbiOS; else goto cbiPa;
       cbiOS: // global
           R4 = _sbio2::P64;
           R3 = _sbinY::P64;
           R2 = _sbioU::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       cbiPa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiPy: // global
           _sbioV::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbioS::I64));
           if (_sbioV::I64 != 4) goto cbiPo; else goto ubiQd;
       cbiPo: // global
           R4 = _sbio2::P64;
           R3 = _sbinY::P64;
           R2 = _sbioV::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       ubiQd: // global
           Sp = Sp + 16;
           goto ubiQw;
       ubiQw: // global
           call _cbiNY() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.371753818 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hTryLock3_bytes" {
     GHC.IO.Handle.Lock.hTryLock3_bytes:
         I8[] [104,84,114,121,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.373985441 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock2_closure" {
     GHC.IO.Handle.Lock.hTryLock2_closure:
         const GHC.IO.Handle.Lock.hTryLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock2_entry() //  [R1]
         { info_tbl: [(cbiRL,
                       label: GHC.IO.Handle.Lock.hTryLock2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiRL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiRM; else goto cbiRN;
       cbiRM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiRN: // global
           (_cbiRI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiRI::I64 == 0) goto cbiRK; else goto cbiRJ;
       cbiRK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiRJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiRI::I64;
           R2 = GHC.IO.Handle.Lock.hTryLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.377978736 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock1_closure" {
     GHC.IO.Handle.Lock.hTryLock1_closure:
         const GHC.IO.Handle.Lock.hTryLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock1_entry() //  [R2, R3]
         { info_tbl: [(cbiRZ,
                       label: GHC.IO.Handle.Lock.hTryLock1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiRZ: // global
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hTryLock2_closure;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.381575838 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock_closure" {
     GHC.IO.Handle.Lock.hTryLock_closure:
         const GHC.IO.Handle.Lock.hTryLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock_entry() //  [R2, R3]
         { info_tbl: [(cbiSa,
                       label: GHC.IO.Handle.Lock.hTryLock_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiSa: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hTryLock1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.384969423 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hLock3_bytes" {
     GHC.IO.Handle.Lock.hLock3_bytes:
         I8[] [104,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.387415465 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock2_closure" {
     GHC.IO.Handle.Lock.hLock2_closure:
         const GHC.IO.Handle.Lock.hLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock2_entry() //  [R1]
         { info_tbl: [(cbiSo,
                       label: GHC.IO.Handle.Lock.hLock2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiSo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiSp; else goto cbiSq;
       cbiSp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiSq: // global
           (_cbiSl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiSl::I64 == 0) goto cbiSn; else goto cbiSm;
       cbiSn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiSm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiSl::I64;
           R2 = GHC.IO.Handle.Lock.hLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.391872117 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock1_closure" {
     GHC.IO.Handle.Lock.hLock1_closure:
         const GHC.IO.Handle.Lock.hLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock1_entry() //  [R2, R3]
         { info_tbl: [(cbiSE,
                       label: GHC.IO.Handle.Lock.hLock1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiSE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbiSF; else goto cbiSG;
       cbiSF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiSG: // global
           I64[Sp - 8] = block_cbiSC_info;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hLock2_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiSC() //  []
         { info_tbl: [(cbiSC,
                       label: block_cbiSC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiSC: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.397121088 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock_closure" {
     GHC.IO.Handle.Lock.hLock_closure:
         const GHC.IO.Handle.Lock.hLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock_entry() //  [R2, R3]
         { info_tbl: [(cbiSV,
                       label: GHC.IO.Handle.Lock.hLock_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiSV: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.400233356 UTC

[section ""data" . GHC.IO.Handle.Lock.SharedLock_closure" {
     GHC.IO.Handle.Lock.SharedLock_closure:
         const GHC.IO.Handle.Lock.SharedLock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.402366214 UTC

[section ""data" . GHC.IO.Handle.Lock.ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.ExclusiveLock_closure:
         const GHC.IO.Handle.Lock.ExclusiveLock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.403904815 UTC

[section ""data" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.405519885 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.LockMode_closure_tbl" {
     GHC.IO.Handle.Lock.LockMode_closure_tbl:
         const GHC.IO.Handle.Lock.SharedLock_closure+1;
         const GHC.IO.Handle.Lock.ExclusiveLock_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.407224622 UTC

[GHC.IO.Handle.Lock.SharedLock_con_entry() //  [R1]
         { info_tbl: [(cbiT6,
                       label: GHC.IO.Handle.Lock.SharedLock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,83,104,97,114,101,100,76,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiT6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.410862606 UTC

[GHC.IO.Handle.Lock.ExclusiveLock_con_entry() //  [R1]
         { info_tbl: [(cbiTc,
                       label: GHC.IO.Handle.Lock.ExclusiveLock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,69,120,99,108,117,115,105,118,101,76,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiTc: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.414125716 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.416399475 UTC

[GHC.IO.Handle.Lock.FileLockingNotSupported_con_entry() //  [R1]
         { info_tbl: [(cbiTj,
                       label: GHC.IO.Handle.Lock.FileLockingNotSupported_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiTj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.419630608 UTC

[section ""relreadonly" . Sbipx_srt" {
     Sbipx_srt:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_rbimG_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const GHC.IO.Handle.Lock.hUnlock1_closure;
         const GHC.IO.Handle.Lock.hUnlock2_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Lock.$wlvl_closure;
         const GHC.IO.Handle.Lock.hLock4_closure;
         const GHC.IO.Handle.Lock.hTryLock2_closure;
         const GHC.IO.Handle.Lock.hTryLock1_closure;
         const GHC.IO.Handle.Lock.hLock1_closure;
         const GHC.IO.Handle.Lock.hLock2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.76394159 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:14.76504689 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes:
         I8[] [70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.769833794 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_entry() //  [R1]
         { info_tbl: [(cbiVZ,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiVZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiW0; else goto cbiW1;
       cbiW0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiW1: // global
           (_cbiVW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiVW::I64 == 0) goto cbiVY; else goto cbiVX;
       cbiVY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiVX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiVW::I64;
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.774096585 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { info_tbl: [(cbiWh,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiWh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiWi; else goto cbiWj;
       cbiWi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiWj: // global
           I64[Sp - 16] = block_cbiWe_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubiWn; else goto cbiWf;
       ubiWn: // global
           call _cbiWe() args: 0, res: 0, upd: 0;
       cbiWf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiWe() //  []
         { info_tbl: [(cbiWe,
                       label: block_cbiWe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiWe: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.779593973 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_entry() //  [R2]
         { info_tbl: [(cbiWG,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiWG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbiWH; else goto cbiWI;
       cbiWH: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiWI: // global
           I64[Sp - 8] = block_cbiWD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiWM; else goto cbiWE;
       ubiWM: // global
           call _cbiWD() args: 0, res: 0, upd: 0;
       cbiWE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiWD() //  []
         { info_tbl: [(cbiWD,
                       label: block_cbiWD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiWD: // global
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.785051844 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbiX5,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiX5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiX6; else goto cbiX7;
       cbiX6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiX7: // global
           I64[Sp - 16] = block_cbiX2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubiXb; else goto cbiX3;
       ubiXb: // global
           call _cbiX2() args: 0, res: 0, upd: 0;
       cbiX3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiX2() //  []
         { info_tbl: [(cbiX2,
                       label: block_cbiX2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiX2: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.790557766 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_entry() //  [R2,
                                                                          R3]
         { info_tbl: [(cbiXq,
                       label: GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiXq: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.79444469 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.796249436 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule4_bytes" {
     GHC.IO.Handle.Lock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.798021482 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule3_closure" {
     GHC.IO.Handle.Lock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.800324739 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule2_bytes" {
     GHC.IO.Handle.Lock.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.802345292 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule1_closure" {
     GHC.IO.Handle.Lock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.803974413 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule_closure" {
     GHC.IO.Handle.Lock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Lock.$trModule3_closure+1;
         const GHC.IO.Handle.Lock.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.805736859 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.807474653 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
         const GHC.Types.krep$*_closure;
         const 2716065848555532007;
         const 12251424812302631774;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.809271196 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.810975656 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes:
         I8[] [39,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.812617366 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.814427563 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure+1;
         const 13975601321420314475;
         const 8398323512000399582;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.81686897 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_entry() //  [R1]
         { info_tbl: [(cbiXU,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiXU: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbiXV; else goto cbiXW;
       cbiXV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiXW: // global
           (_cbiXM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiXM::I64 == 0) goto cbiXO; else goto cbiXN;
       cbiXO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiXN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiXM::I64;
           I64[Sp - 24] = block_cbiXP_info;
           R6 = 0;
           R5 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
           R4 = GHC.IO.Handle.Lock.$trModule_closure+1;
           R3 = 12251424812302631774;
           R2 = 2716065848555532007;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbiXP() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbiXP,
                       label: block_cbiXP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiXP: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbiXQ() args: 0, res: 0, upd: 0;
     }
 },
 _cbiXQ() //  []
         { info_tbl: [(cbiXQ,
                       label: block_cbiXQ_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiXQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbiXZ; else goto cbiXY;
       cbiXZ: // global
           HpAlloc = 48;
           I64[Sp] = block_cbiXQ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbiXY: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.825882027 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_entry() //  [R2]
         { info_tbl: [(cbiYz,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiYz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiYD; else goto cbiYE;
       cbiYD: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiYE: // global
           I64[Sp - 8] = block_cbiYw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiYZ; else goto cbiYx;
       ubiYZ: // global
           call _cbiYw(R1) args: 0, res: 0, upd: 0;
       cbiYx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiYw() //  [R1]
         { info_tbl: [(cbiYw,
                       label: block_cbiYw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiYw: // global
           I64[Sp - 8] = block_cbiYC_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiYC() //  [R1]
         { info_tbl: [(cbiYC,
                       label: block_cbiYC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiYC: // global
           I64[Sp] = block_cbiYJ_info;
           R3 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbiYJ() //  [R1]
         { info_tbl: [(cbiYJ,
                       label: block_cbiYJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiYJ: // global
           if (R1 & 7 == 1) goto cbiYQ; else goto cbiYU;
       cbiYQ: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiYU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbiYX; else goto cbiYW;
       cbiYX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbiYW: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.836319331 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_entry() //  [R2]
         { info_tbl: [(cbiZv,
                       label: GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiZv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbiZz; else goto cbiZy;
       cbiZz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiZy: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.840980859 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tcLockMode2_bytes" {
     GHC.IO.Handle.Lock.$tcLockMode2_bytes:
         I8[] [76,111,99,107,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.842566756 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode1_closure" {
     GHC.IO.Handle.Lock.$tcLockMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.844238325 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode_closure" {
     GHC.IO.Handle.Lock.$tcLockMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tcLockMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18068849831825836849;
         const 1974453150269185476;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.846063398 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.847784307 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'SharedLock2_bytes" {
     GHC.IO.Handle.Lock.$tc'SharedLock2_bytes:
         I8[] [39,83,104,97,114,101,100,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.849756031 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock1_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'SharedLock2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.851477496 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'SharedLock1_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 9660990538910196995;
         const 16983901031857135990;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.853270439 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes:
         I8[] [39,69,120,99,108,117,115,105,118,101,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.854980211 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.856788496 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 8544818512469904331;
         const 16785548070058023905;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.858604851 UTC

[section ""cstring" . lvl_rbimF_bytes" {
     lvl_rbimF_bytes:
         I8[] [102,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.861222413 UTC

[section ""data" . lvl1_rbimG_closure" {
     lvl1_rbimG_closure:
         const lvl1_rbimG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbimG_entry() //  [R1]
         { info_tbl: [(cbiZZ,
                       label: lvl1_rbimG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiZZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbj00; else goto cbj01;
       cbj00: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj01: // global
           (_cbiZW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiZW::I64 == 0) goto cbiZY; else goto cbiZX;
       cbiZY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiZX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiZW::I64;
           R2 = lvl_rbimF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.86589869 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock2_closure" {
     GHC.IO.Handle.Lock.hUnlock2_closure:
         const GHC.IO.Handle.Lock.hUnlock2_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock2_entry() //  [R2]
         { info_tbl: [(cbj0g,
                       label: GHC.IO.Handle.Lock.hUnlock2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj0g: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_rbimG_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.870019228 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock1_closure" {
     GHC.IO.Handle.Lock.hUnlock1_closure:
         const GHC.IO.Handle.Lock.hUnlock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock1_entry() //  [R2]
         { info_tbl: [(cbj0y,
                       label: GHC.IO.Handle.Lock.hUnlock1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj0y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbj0z; else goto cbj0A;
       cbj0z: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hUnlock1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbj0A: // global
           I64[Sp - 8] = block_cbj0r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubj1D; else goto cbj0s;
       ubj1D: // global
           call _cbj0r(R1) args: 0, res: 0, upd: 0;
       cbj0s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj0r() //  [R1]
         { info_tbl: [(cbj0r,
                       label: block_cbj0r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj0r: // global
           if (R1 & 7 == 1) goto cbj0v; else goto cbj0w;
       cbj0v: // global
           I64[Sp - 8] = block_cbj0D_info;
           _sbiTS::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbiTS::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbj0w: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbj0D() //  [R1]
         { info_tbl: [(cbj0D,
                       label: block_cbj0D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj0D: // global
           I64[Sp] = block_cbj0F_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubj1E; else goto cbj0G;
       ubj1E: // global
           call _cbj0F(R1) args: 0, res: 0, upd: 0;
       cbj0G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj0F() //  [R1]
         { info_tbl: [(cbj0F,
                       label: block_cbj0F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj0F: // global
           I64[Sp - 8] = block_cbj0K_info;
           _sbiU1::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbiU1::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj0K() //  [R1]
         { info_tbl: [(cbj0K,
                       label: block_cbj0K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj0K: // global
           I64[Sp] = block_cbj0R_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbj0R() //  [R1]
         { info_tbl: [(cbj0R,
                       label: block_cbj0R_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj0R: // global
           if (R1 & 7 == 1) goto cbj0Y; else goto cbj12;
       cbj0Y: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbj12: // global
           I64[Sp + 16] = block_cbj16_info;
           _cbj14::I64 = I64[Sp + 8];
           Sp = Sp + 16;
           _ubj1v::P64 = CurrentTSO;
           I64[I64[_ubj1v::P64 + 24] + 16] = Sp;
           _ubj1w::I64 = CurrentNursery;
           P64[_ubj1w::I64 + 8] = Hp + 8;
           I64[_ubj1v::P64 + 104] = I64[_ubj1v::P64 + 104] - ((Hp + 8) - I64[_ubj1w::I64]);
           (_ubj1t::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbiUn::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_cbj14::I64, 8);
           (_ubj1u::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubj1t::I64);
           BaseReg = _ubj1u::I64;
           _ubj1x::P64 = CurrentTSO;
           _ubj1y::P64 = I64[_ubj1x::P64 + 24];
           Sp = I64[_ubj1y::P64 + 16];
           SpLim = _ubj1y::P64 + 192;
           HpAlloc = 0;
           _ubj1z::I64 = CurrentNursery;
           _ubj1A::I64 = I64[_ubj1z::I64 + 8];
           Hp = _ubj1A::I64 - 8;
           _ubj1B::I64 = I64[_ubj1z::I64];
           HpLim = _ubj1B::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubj1z::I64 + 48]) << 12) - 1);
           I64[_ubj1x::P64 + 104] = I64[_ubj1x::P64 + 104] + (_ubj1A::I64 - _ubj1B::I64);
           R1 = _sbiUn::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj16() //  [R1]
         { info_tbl: [(cbj16,
                       label: block_cbj16_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj16: // global
           if (%MO_SS_Conv_W64_W32(R1) == (-1) :: W32) goto cbj1k; else goto cbj1e;
       cbj1k: // global
           (_sbiUs::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sbiUs::I64;
           Sp = Sp + 8;
           call GHC.IO.Handle.Lock.hUnlock2_entry(R2) args: 8, res: 0, upd: 8;
       cbj1e: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.886101926 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock_closure" {
     GHC.IO.Handle.Lock.hUnlock_closure:
         const GHC.IO.Handle.Lock.hUnlock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock_entry() //  [R2]
         { info_tbl: [(cbj2A,
                       label: GHC.IO.Handle.Lock.hUnlock_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj2A: // global
           R2 = R2;
           call GHC.IO.Handle.Lock.hUnlock1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.890025562 UTC

[section ""data" . GHC.IO.Handle.Lock.$wlvl_closure" {
     GHC.IO.Handle.Lock.$wlvl_closure:
         const GHC.IO.Handle.Lock.$wlvl_info;
         const 0;
 },
 sat_sbiUD_entry() //  [R1]
         { info_tbl: [(cbj2U,
                       label: sat_sbiUD_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj2U: // global
           _sbiUD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbj2V; else goto cbj2W;
       cbj2W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbj2Y; else goto cbj2X;
       cbj2Y: // global
           HpAlloc = 16;
           goto cbj2V;
       cbj2V: // global
           R1 = _sbiUD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj2X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbiUD::P64;
           _sbiUz::P64 = P64[_sbiUD::P64 + 16];
           _sbiUA::P64 = P64[_sbiUD::P64 + 24];
           _sbiUy::I64 = I64[_sbiUD::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbiUA::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sbiUy::I64;
           R2 = _sbiUz::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbiUE_entry() //  [R1]
         { info_tbl: [(cbj2Z,
                       label: sat_sbiUE_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj2Z: // global
           _sbiUE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbj30; else goto cbj31;
       cbj31: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbj33; else goto cbj32;
       cbj33: // global
           HpAlloc = 40;
           goto cbj30;
       cbj30: // global
           R1 = _sbiUE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj32: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbiUE::P64;
           _sbiUz::P64 = P64[_sbiUE::P64 + 16];
           _sbiUA::P64 = P64[_sbiUE::P64 + 24];
           _sbiUy::I64 = I64[_sbiUE::P64 + 32];
           I64[Hp - 32] = sat_sbiUD_info;
           P64[Hp - 16] = _sbiUz::P64;
           P64[Hp - 8] = _sbiUA::P64;
           I64[Hp] = _sbiUy::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Lock.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(cbj34,
                       label: GHC.IO.Handle.Lock.$wlvl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj34: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbj38; else goto cbj37;
       cbj38: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbj37: // global
           I64[Hp - 32] = sat_sbiUE_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.901314385 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock4_closure" {
     GHC.IO.Handle.Lock.hLock4_closure:
         const GHC.IO.Handle.Lock.hLock4_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbj3C,
                       label: GHC.IO.Handle.Lock.hLock4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj3C: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbj3D; else goto cbj3E;
       cbj3D: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbj3E: // global
           I64[Sp - 32] = block_cbj3v_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubj6M; else goto cbj3w;
       ubj6M: // global
           call _cbj3v(R1) args: 0, res: 0, upd: 0;
       cbj3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj3v() //  [R1]
         { info_tbl: [(cbj3v,
                       label: block_cbj3v_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj3v: // global
           if (R1 & 7 == 1) goto cbj3z; else goto cbj3A;
       cbj3z: // global
           I64[Sp - 8] = block_cbj3H_info;
           _sbiUK::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbiUK::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbj3A: // global
           R2 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbj3H() //  [R1]
         { info_tbl: [(cbj3H,
                       label: block_cbj3H_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj3H: // global
           I64[Sp] = block_cbj3J_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubj6N; else goto cbj3K;
       ubj6N: // global
           call _cbj3J(R1) args: 0, res: 0, upd: 0;
       cbj3K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj3J() //  [R1]
         { info_tbl: [(cbj3J,
                       label: block_cbj3J_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj3J: // global
           I64[Sp - 8] = block_cbj3O_info;
           _sbiUT::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbiUT::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj3O() //  [R1]
         { info_tbl: [(cbj3O,
                       label: block_cbj3O_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj3O: // global
           I64[Sp] = block_cbj3V_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbj3V() //  [R1]
         { info_tbl: [(cbj3V,
                       label: block_cbj3V_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj3V: // global
           if (R1 & 7 == 1) goto cbj42; else goto ubj6z;
       cbj42: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       ubj6z: // global
           Sp = Sp + 8;
           call _cbj4l() args: 0, res: 0, upd: 0;
     }
 },
 _cbj4l() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj4l: // global
           I64[Sp - 8] = block_cbj4p_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubj6P; else goto cbj6d;
       ubj6P: // global
           call _cbj4p(R1) args: 0, res: 0, upd: 0;
       cbj6d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj4p() //  [R1]
         { info_tbl: [(cbj4p,
                       label: block_cbj4p_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj4p: // global
           _sbiUI::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbj6j; else goto cbj6n;
       cbj6j: // global
           _sbiVl::I64 = 1;
           goto sbiVk;
       cbj6n: // global
           _sbiVl::I64 = 2;
           goto sbiVk;
       sbiVk: // global
           I64[Sp - 8] = block_cbj4w_info;
           R1 = _sbiUI::P64;
           I64[Sp] = _sbiVl::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubj6Q; else goto cbj62;
       ubj6Q: // global
           call _cbj4w(R1) args: 0, res: 0, upd: 0;
       cbj62: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj4w() //  [R1]
         { info_tbl: [(cbj4w,
                       label: block_cbj4w_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj4w: // global
           _sbiV8::I64 = I64[Sp + 16];
           _sbiVl::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbj68; else goto cbj6c;
       cbj68: // global
           _sbiVn::I64 = 4;
           goto sbiVm;
       cbj6c: // global
           _sbiVn::I64 = 0;
           goto sbiVm;
       sbiVm: // global
           I64[Sp + 8] = block_cbj4R_info;
           Sp = Sp + 8;
           _ubj6E::P64 = CurrentTSO;
           I64[I64[_ubj6E::P64 + 24] + 16] = Sp;
           _ubj6F::I64 = CurrentNursery;
           P64[_ubj6F::I64 + 8] = Hp + 8;
           I64[_ubj6E::P64 + 104] = I64[_ubj6E::P64 + 104] - ((Hp + 8) - I64[_ubj6F::I64]);
           (_ubj6C::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbiVv::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_sbiV8::I64, _sbiVl::I64 | _sbiVn::I64);
           (_ubj6D::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubj6C::I64);
           BaseReg = _ubj6D::I64;
           _ubj6G::P64 = CurrentTSO;
           _ubj6H::P64 = I64[_ubj6G::P64 + 24];
           Sp = I64[_ubj6H::P64 + 16];
           SpLim = _ubj6H::P64 + 192;
           HpAlloc = 0;
           _ubj6I::I64 = CurrentNursery;
           _ubj6J::I64 = I64[_ubj6I::I64 + 8];
           Hp = _ubj6J::I64 - 8;
           _ubj6K::I64 = I64[_ubj6I::I64];
           HpLim = _ubj6K::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubj6I::I64 + 48]) << 12) - 1);
           I64[_ubj6G::P64 + 104] = I64[_ubj6G::P64 + 104] + (_ubj6J::I64 - _ubj6K::I64);
           R1 = _sbiVv::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj4R() //  [R1]
         { info_tbl: [(cbj4R,
                       label: block_cbj4R_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj4R: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cbj5Y; else goto cbj53;
       cbj5Y: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbj53: // global
           _sbiUI::P64 = P64[Sp + 40];
           (_sbiVA::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_cbj51_info;
           R1 = _sbiUI::P64;
           I64[Sp] = _sbiVA::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubj6R; else goto cbj55;
       ubj6R: // global
           call _cbj51(R1) args: 0, res: 0, upd: 0;
       cbj55: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj51() //  [R1]
         { info_tbl: [(cbj51,
                       label: block_cbj51_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj51: // global
           _sbiUG::P64 = P64[Sp + 32];
           _sbiUK::P64 = P64[Sp + 24];
           _sbiVA::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbj5C; else goto cbj5V;
       cbj5C: // global
           _sbiVC::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbiVA::I64));
           if (%MO_S_Ge_W64(_sbiVC::I64, 14)) goto cbj5f; else goto ubj6w;
       ubj6w: // global
           if (%MO_S_Lt_W64(_sbiVC::I64, 11)) goto ubj6x; else goto ubj6y;
       ubj6x: // global
           if (_sbiVC::I64 != 4) goto cbj5f; else goto ubj6B;
       ubj6B: // global
           Sp = Sp + 16;
           goto ubj6T;
       ubj6y: // global
           if (_sbiVC::I64 == 12) goto cbj5f; else goto cbj5x;
       cbj5f: // global
           R4 = _sbiUK::P64;
           R3 = _sbiUG::P64;
           R2 = _sbiVC::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       cbj5x: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbj5V: // global
           _sbiVD::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbiVA::I64));
           if (_sbiVD::I64 != 4) goto cbj5L; else goto ubj6A;
       cbj5L: // global
           R4 = _sbiUK::P64;
           R3 = _sbiUG::P64;
           R2 = _sbiVD::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       ubj6A: // global
           Sp = Sp + 16;
           goto ubj6T;
       ubj6T: // global
           call _cbj4l() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.92589014 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hTryLock3_bytes" {
     GHC.IO.Handle.Lock.hTryLock3_bytes:
         I8[] [104,84,114,121,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.927972342 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock2_closure" {
     GHC.IO.Handle.Lock.hTryLock2_closure:
         const GHC.IO.Handle.Lock.hTryLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock2_entry() //  [R1]
         { info_tbl: [(cbj8j,
                       label: GHC.IO.Handle.Lock.hTryLock2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj8j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbj8k; else goto cbj8l;
       cbj8k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj8l: // global
           (_cbj8g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbj8g::I64 == 0) goto cbj8i; else goto cbj8h;
       cbj8i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbj8h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbj8g::I64;
           R2 = GHC.IO.Handle.Lock.hTryLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.933145202 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock1_closure" {
     GHC.IO.Handle.Lock.hTryLock1_closure:
         const GHC.IO.Handle.Lock.hTryLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock1_entry() //  [R2, R3]
         { info_tbl: [(cbj8y,
                       label: GHC.IO.Handle.Lock.hTryLock1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj8y: // global
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hTryLock2_closure;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.936657403 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock_closure" {
     GHC.IO.Handle.Lock.hTryLock_closure:
         const GHC.IO.Handle.Lock.hTryLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock_entry() //  [R2, R3]
         { info_tbl: [(cbj8K,
                       label: GHC.IO.Handle.Lock.hTryLock_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj8K: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hTryLock1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.939748294 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hLock3_bytes" {
     GHC.IO.Handle.Lock.hLock3_bytes:
         I8[] [104,76,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.941966907 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock2_closure" {
     GHC.IO.Handle.Lock.hLock2_closure:
         const GHC.IO.Handle.Lock.hLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock2_entry() //  [R1]
         { info_tbl: [(cbj8Y,
                       label: GHC.IO.Handle.Lock.hLock2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj8Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbj8Z; else goto cbj90;
       cbj8Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj90: // global
           (_cbj8V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbj8V::I64 == 0) goto cbj8X; else goto cbj8W;
       cbj8X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbj8W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbj8V::I64;
           R2 = GHC.IO.Handle.Lock.hLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.946082134 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock1_closure" {
     GHC.IO.Handle.Lock.hLock1_closure:
         const GHC.IO.Handle.Lock.hLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock1_entry() //  [R2, R3]
         { info_tbl: [(cbj9f,
                       label: GHC.IO.Handle.Lock.hLock1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj9f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbj9g; else goto cbj9h;
       cbj9g: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbj9h: // global
           I64[Sp - 8] = block_cbj9d_info;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hLock2_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbj9d() //  []
         { info_tbl: [(cbj9d,
                       label: block_cbj9d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj9d: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.951440837 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock_closure" {
     GHC.IO.Handle.Lock.hLock_closure:
         const GHC.IO.Handle.Lock.hLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock_entry() //  [R2, R3]
         { info_tbl: [(cbj9z,
                       label: GHC.IO.Handle.Lock.hLock_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj9z: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.955035305 UTC

[section ""data" . GHC.IO.Handle.Lock.SharedLock_closure" {
     GHC.IO.Handle.Lock.SharedLock_closure:
         const GHC.IO.Handle.Lock.SharedLock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.956627542 UTC

[section ""data" . GHC.IO.Handle.Lock.ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.ExclusiveLock_closure:
         const GHC.IO.Handle.Lock.ExclusiveLock_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.958300536 UTC

[section ""data" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.959970146 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.LockMode_closure_tbl" {
     GHC.IO.Handle.Lock.LockMode_closure_tbl:
         const GHC.IO.Handle.Lock.SharedLock_closure+1;
         const GHC.IO.Handle.Lock.ExclusiveLock_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.962403105 UTC

[GHC.IO.Handle.Lock.SharedLock_con_entry() //  [R1]
         { info_tbl: [(cbj9K,
                       label: GHC.IO.Handle.Lock.SharedLock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,83,104,97,114,101,100,76,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj9K: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.965695061 UTC

[GHC.IO.Handle.Lock.ExclusiveLock_con_entry() //  [R1]
         { info_tbl: [(cbj9R,
                       label: GHC.IO.Handle.Lock.ExclusiveLock_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,69,120,99,108,117,115,105,118,101,76,111,99,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj9R: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.968738564 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_closure+1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.97040458 UTC

[GHC.IO.Handle.Lock.FileLockingNotSupported_con_entry() //  [R1]
         { info_tbl: [(cbj9Z,
                       label: GHC.IO.Handle.Lock.FileLockingNotSupported_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj9Z: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:14.973749094 UTC

[section ""relreadonly" . SbiWo_srt" {
     SbiWo_srt:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_rbimG_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const GHC.IO.Handle.Lock.hUnlock1_closure;
         const GHC.IO.Handle.Lock.hUnlock2_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Lock.$wlvl_closure;
         const GHC.IO.Handle.Lock.hLock4_closure;
         const GHC.IO.Handle.Lock.hTryLock2_closure;
         const GHC.IO.Handle.Lock.hTryLock1_closure;
         const GHC.IO.Handle.Lock.hLock1_closure;
         const GHC.IO.Handle.Lock.hLock2_closure;
 }]

