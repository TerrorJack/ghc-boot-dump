
==================== Output Cmm ====================
2018-03-16 16:06:11.950440984 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:11.951642759 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle12_closure" {
     GHC.IO.Handle.FD.fdToHandle12_closure:
         const GHC.IO.Handle.FD.fdToHandle12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle12_entry() //  [R1]
         { info_tbl: [(cbfJw,
                       label: GHC.IO.Handle.FD.fdToHandle12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfJw: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbfJx; else goto cbfJy;
       cbfJx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfJy: // global
           (_cbfJo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbfJo::I64 == 0) goto cbfJq; else goto cbfJp;
       cbfJq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbfJp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbfJo::I64;
           I64[Sp - 24] = block_cbfJr_info;
           R6 = 0;
           R5 = GHC.IO.FD.$tcFD1_closure;
           R4 = GHC.IO.FD.$trModule_closure;
           R3 = 15546290101957756376;
           R2 = 10838815552519039062;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbfJr() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbfJr,
                       label: block_cbfJr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfJr: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbfJs() args: 0, res: 0, upd: 0;
     }
 },
 _cbfJs() //  []
         { info_tbl: [(cbfJs,
                       label: block_cbfJs_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfJs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbfJB; else goto cbfJA;
       cbfJB: // global
           HpAlloc = 48;
           I64[Sp] = block_cbfJs_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbfJA: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.953118526 UTC

[section ""cstring" . GHC.IO.Handle.FD.$trModule4_bytes" {
     GHC.IO.Handle.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.953688833 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule3_closure" {
     GHC.IO.Handle.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.FD.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.954299793 UTC

[section ""cstring" . GHC.IO.Handle.FD.$trModule2_bytes" {
     GHC.IO.Handle.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.954848163 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule1_closure" {
     GHC.IO.Handle.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.FD.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.955401511 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule_closure" {
     GHC.IO.Handle.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.FD.$trModule3_closure+1;
         const GHC.IO.Handle.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.956004843 UTC

[section ""cstring" . lvl_rbfCu_bytes" {
     lvl_rbfCu_bytes:
         I8[] [104,97,110,100,108,101,84,111,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.956728711 UTC

[section ""data" . lvl1_rbfCv_closure" {
     lvl1_rbfCv_closure:
         const lvl1_rbfCv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbfCv_entry() //  [R1]
         { info_tbl: [(cbfJL,
                       label: lvl1_rbfCv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfJL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfJM; else goto cbfJN;
       cbfJM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfJN: // global
           (_cbfJI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbfJI::I64 == 0) goto cbfJK; else goto cbfJJ;
       cbfJK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbfJJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbfJI::I64;
           R2 = lvl_rbfCu_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.957611603 UTC

[section ""cstring" . lvl2_rbfCw_bytes" {
     lvl2_rbfCw_bytes:
         I8[] [110,111,116,32,97,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.958341115 UTC

[section ""data" . lvl3_rbfCx_closure" {
     lvl3_rbfCx_closure:
         const lvl3_rbfCx_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbfCx_entry() //  [R1]
         { info_tbl: [(cbfJU,
                       label: lvl3_rbfCx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfJU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfJV; else goto cbfJW;
       cbfJV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfJW: // global
           (_cbfJR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbfJR::I64 == 0) goto cbfJT; else goto cbfJS;
       cbfJT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbfJS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbfJR::I64;
           R2 = lvl2_rbfCw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.95953561 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd3_closure" {
     GHC.IO.Handle.FD.handleToFd3_closure:
         const GHC.IO.Handle.FD.handleToFd3_info;
         const 0;
 },
 sat_sbfCX_entry() //  [R1]
         { info_tbl: [(cbfK7,
                       label: sat_sbfCX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfK7: // global
           _sbfCX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbfK8; else goto cbfK9;
       cbfK9: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbfKb; else goto cbfKa;
       cbfKb: // global
           HpAlloc = 72;
           goto cbfK8;
       cbfK8: // global
           R1 = _sbfCX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfKa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfCX::P64;
           _sbfCT::P64 = P64[_sbfCX::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfCT::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InappropriateType_closure+1;
           P64[Hp - 24] = lvl1_rbfCv_closure;
           P64[Hp - 16] = lvl3_rbfCx_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.handleToFd3_entry() //  [R2]
         { info_tbl: [(cbfKc,
                       label: GHC.IO.Handle.FD.handleToFd3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfKc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbfKg; else goto cbfKf;
       cbfKg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbfKf: // global
           I64[Hp - 16] = sat_sbfCX_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.960760453 UTC

[section ""cstring" . lvl4_rbfCy_bytes" {
     lvl4_rbfCy_bytes:
         I8[] [110,111,116,32,97,32,102,105,108,101,32,104,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.961522926 UTC

[section ""data" . lvl5_rbfCz_closure" {
     lvl5_rbfCz_closure:
         const lvl5_rbfCz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rbfCz_entry() //  [R1]
         { info_tbl: [(cbfKn,
                       label: lvl5_rbfCz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfKo; else goto cbfKp;
       cbfKo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfKp: // global
           (_cbfKk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbfKk::I64 == 0) goto cbfKm; else goto cbfKl;
       cbfKm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbfKl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbfKk::I64;
           R2 = lvl4_rbfCy_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.962713615 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd2_closure" {
     GHC.IO.Handle.FD.handleToFd2_closure:
         const GHC.IO.Handle.FD.handleToFd2_info;
         const 0;
 },
 sat_sbfD2_entry() //  [R1]
         { info_tbl: [(cbfKA,
                       label: sat_sbfD2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfKA: // global
           _sbfD2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbfKB; else goto cbfKC;
       cbfKC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbfKE; else goto cbfKD;
       cbfKE: // global
           HpAlloc = 72;
           goto cbfKB;
       cbfKB: // global
           R1 = _sbfD2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfKD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfD2::P64;
           _sbfCY::P64 = P64[_sbfD2::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfCY::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InappropriateType_closure+1;
           P64[Hp - 24] = lvl1_rbfCv_closure;
           P64[Hp - 16] = lvl5_rbfCz_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.handleToFd2_entry() //  [R2]
         { info_tbl: [(cbfKF,
                       label: GHC.IO.Handle.FD.handleToFd2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfKF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbfKJ; else goto cbfKI;
       cbfKJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbfKI: // global
           I64[Hp - 16] = sat_sbfD2_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.964422636 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd1_closure" {
     GHC.IO.Handle.FD.handleToFd1_closure:
         const GHC.IO.Handle.FD.handleToFd1_info;
         const 0;
 },
 GHC.IO.Handle.FD.handleToFd1_entry() //  [R2]
         { info_tbl: [(cbfKV,
                       label: GHC.IO.Handle.FD.handleToFd1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfKV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbfKW; else goto cbfKX;
       cbfKW: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbfKX: // global
           I64[Sp - 8] = block_cbfKO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubfLp; else goto cbfKP;
       ubfLp: // global
           call _cbfKO(R1) args: 0, res: 0, upd: 0;
       cbfKP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfKO() //  [R1]
         { info_tbl: [(cbfKO,
                       label: block_cbfKO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfKO: // global
           if (R1 & 7 == 1) goto cbfKS; else goto cbfKT;
       cbfKS: // global
           I64[Sp - 8] = block_cbfL0_info;
           _sbfD5::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbfD5::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbfKT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbfL0() //  [R1]
         { info_tbl: [(cbfL0,
                       label: block_cbfL0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfL0: // global
           I64[Sp] = block_cbfL2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubfLq; else goto cbfL5;
       ubfLq: // global
           call _cbfL2(R1) args: 0, res: 0, upd: 0;
       cbfL5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfL2() //  [R1]
         { info_tbl: [(cbfL2,
                       label: block_cbfL2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfL2: // global
           I64[Sp - 8] = block_cbfL9_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[R1 + 23];
           P64[Sp] = P64[R1 + 31];
           Sp = Sp - 8;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfL9() //  [R1]
         { info_tbl: [(cbfL9,
                       label: block_cbfL9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfL9: // global
           if (R1 & 7 == 1) goto cbfLg; else goto cbfLk;
       cbfLg: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbfLk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.966114879 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd_closure" {
     GHC.IO.Handle.FD.handleToFd_closure:
         const GHC.IO.Handle.FD.handleToFd_info;
         const 0;
 },
 GHC.IO.Handle.FD.handleToFd_entry() //  [R2]
         { info_tbl: [(cbfLv,
                       label: GHC.IO.Handle.FD.handleToFd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfLv: // global
           R2 = R2;
           call GHC.IO.Handle.FD.handleToFd1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.96684215 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle11_bytes" {
     GHC.IO.Handle.FD.fdToHandle11_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.967518807 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle10_closure" {
     GHC.IO.Handle.FD.fdToHandle10_closure:
         const GHC.IO.Handle.FD.fdToHandle10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle10_entry() //  [R1]
         { info_tbl: [(cbfLE,
                       label: GHC.IO.Handle.FD.fdToHandle10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfLE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfLF; else goto cbfLG;
       cbfLF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfLG: // global
           (_cbfLB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbfLB::I64 == 0) goto cbfLD; else goto cbfLC;
       cbfLD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbfLC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbfLB::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.968366553 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle9_bytes" {
     GHC.IO.Handle.FD.fdToHandle9_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.969101495 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle8_closure" {
     GHC.IO.Handle.FD.fdToHandle8_closure:
         const GHC.IO.Handle.FD.fdToHandle8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle8_entry() //  [R1]
         { info_tbl: [(cbfLN,
                       label: GHC.IO.Handle.FD.fdToHandle8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfLN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfLO; else goto cbfLP;
       cbfLO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfLP: // global
           (_cbfLK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbfLK::I64 == 0) goto cbfLM; else goto cbfLL;
       cbfLM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbfLL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbfLK::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.969973182 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle7_closure" {
     GHC.IO.Handle.FD.fdToHandle7_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Handle.FD.fdToHandle10_closure;
         const GHC.IO.Handle.FD.fdToHandle8_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.970734582 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle6_closure" {
     GHC.IO.Handle.FD.fdToHandle6_closure:
         const GHC.IO.Handle.FD.fdToHandle6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle6_entry() //  [R1]
         { info_tbl: [(cbfLW,
                       label: GHC.IO.Handle.FD.fdToHandle6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfLW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfLX; else goto cbfLY;
       cbfLX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfLY: // global
           (_cbfLT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbfLT::I64 == 0) goto cbfLV; else goto cbfLU;
       cbfLV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbfLU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbfLT::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle7_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.9741263 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle5_closure" {
     GHC.IO.Handle.FD.fdToHandle5_closure:
         const GHC.IO.Handle.FD.fdToHandle5_info;
         const 0;
 },
 nl_sbfDG_entry() //  [R1]
         { info_tbl: [(cbfMf,
                       label: nl_sbfDG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfMf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbfMg; else goto cbfMh;
       cbfMg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfMh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbfMc_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubfMl; else goto cbfMd;
       ubfMl: // global
           call _cbfMc() args: 0, res: 0, upd: 0;
       cbfMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbfMc() //  []
         { info_tbl: [(cbfMc,
                       label: block_cbfMc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfMc: // global
           R1 = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfDL_entry() //  [R1]
         { info_tbl: [(cbfME,
                       label: sat_sbfDL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfME: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbfMF; else goto cbfMG;
       cbfMF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfMG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbfMv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubfMV; else goto cbfMw;
       ubfMV: // global
           call _cbfMv(R1) args: 0, res: 0, upd: 0;
       cbfMw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbfMv() //  [R1]
         { info_tbl: [(cbfMv,
                       label: block_cbfMv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfMv: // global
           _cbfMD::P64 = R1 & 7;
           if (_cbfMD::P64 < 3) goto ubfMT; else goto ubfMU;
       ubfMT: // global
           if (_cbfMD::P64 < 2) goto cbfMz; else goto cbfMA;
       cbfMz: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbfMA: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ubfMU: // global
           if (_cbfMD::P64 < 4) goto cbfMB; else goto cbfMC;
       cbfMB: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbfMC: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfE4_entry() //  [R1]
         { info_tbl: [(cbfNf,
                       label: sat_sbfE4_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfNf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbfNr; else goto cbfNq;
       cbfNr: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbfNq: // global
           (_sbfE1::I64) = call "capi" arg hints:  [‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC17ZCbaseZCSystemziPosixziInternalsZCfcntl(I64[R1 + 7], %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbfE1::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.fdToHandle5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbfNw,
                       label: GHC.IO.Handle.FD.fdToHandle5_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfNw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbfNx; else goto cbfNy;
       cbfNx: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbfNy: // global
           I64[Sp - 40] = block_cbfMW_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubfP6; else goto cbfMX;
       ubfP6: // global
           call _cbfMW(R1) args: 0, res: 0, upd: 0;
       cbfMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfMW() //  [R1]
         { info_tbl: [(cbfMW,
                       label: block_cbfMW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfMW: // global
           _sbfDw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbfNt; else goto cbfNu;
       cbfNt: // global
           P64[Sp + 8] = _sbfDw::P64;
           Sp = Sp + 8;
           call _cbfM6() args: 0, res: 0, upd: 0;
       cbfNu: // global
           I64[Sp + 8] = block_cbfN2_info;
           R1 = _sbfDw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubfP4; else goto cbfN3;
       ubfP4: // global
           call _cbfN2(R1) args: 0, res: 0, upd: 0;
       cbfN3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfN2() //  [R1]
         { info_tbl: [(cbfN2,
                       label: block_cbfN2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfN2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbfOf; else goto cbfOe;
       cbfOf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfOe: // global
           _sbfDQ::I64 = I64[R1 + 7];
           (_sbfDV::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_f_getfl();
           I64[Hp - 16] = sat_sbfE4_info;
           I64[Hp - 8] = _sbfDQ::I64;
           I64[Hp] = _sbfDV::I64;
           I64[Sp - 8] = block_cbfO9_info;
           R4 = Hp - 15;
           R3 = System.Posix.Internals.setNonBlockingFD3_closure;
           R2 = System.Posix.Internals.fdFileSize_pred_closure+1;
           I64[Sp] = _sbfDQ::I64;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfO9() //  [R1]
         { info_tbl: [(cbfO9,
                       label: block_cbfO9_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfO9: // global
           I64[Sp] = block_cbfOb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubfPa; else goto cbfOh;
       ubfPa: // global
           call _cbfOb(R1) args: 0, res: 0, upd: 0;
       cbfOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfOb() //  [R1]
         { info_tbl: [(cbfOb,
                       label: block_cbfOb_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfOb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbfOn; else goto cbfOm;
       cbfOn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfOm: // global
           _sbfDQ::I64 = I64[Sp + 8];
           _sbfE9::I64 = I64[R1 + 7];
           (_sbfEd::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           _sbfEe::I64 = _sbfE9::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbfEd::I64));
           if (_sbfE9::I64 == _sbfEe::I64) goto cbfOH; else goto cbfOI;
       cbfOH: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sbfDQ::I64;
           I64[Hp] = 1;
           P64[Sp + 8] = Hp - 15;
           Sp = Sp + 8;
           goto ubfPc;
       cbfOI: // global
           (_sbfEo::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_f_setfl();
           (_sbfEt::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC16ZCbaseZCSystemziPosixziInternalsZCfcntl(_sbfDQ::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbfEo::I64)), _sbfEe::I64);
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sbfDQ::I64;
           I64[Hp] = 1;
           P64[Sp + 8] = Hp - 15;
           Sp = Sp + 8;
           goto ubfPc;
       ubfPc: // global
           call _cbfM6() args: 0, res: 0, upd: 0;
     }
 },
 _cbfM6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfM6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbfNC; else goto cbfNB;
       cbfNC: // global
           HpAlloc = 24;
           _sbfDF::P64 = P64[Sp];
           I64[Sp] = block_cbfM5_info;
           R1 = _sbfDF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfNB: // global
           I64[Hp - 16] = nl_sbfDG_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp - 8] = block_cbfNz_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubfP3; else goto cbfNG;
       ubfP3: // global
           call _cbfNz(R1) args: 0, res: 0, upd: 0;
       cbfNG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfM5() //  [R1]
         { info_tbl: [(cbfM5,
                       label: block_cbfM5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfM5: // global
           P64[Sp] = R1;
           call _cbfM6() args: 0, res: 0, upd: 0;
     }
 },
 _cbfNz() //  [R1]
         { info_tbl: [(cbfNz,
                       label: block_cbfNz_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfNz: // global
           _cbfOV::P64 = R1 & 7;
           if (_cbfOV::P64 != 1) goto ubfOX; else goto cbfNQ;
       ubfOX: // global
           if (_cbfOV::P64 != 2) goto ubfP8; else goto cbfNV;
       ubfP8: // global
           call _cbfMp() args: 0, res: 0, upd: 0;
       cbfNV: // global
           I64[Sp] = block_cbfNT_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto ubfP7; else goto cbfNW;
       ubfP7: // global
           call _cbfNT(R1) args: 0, res: 0, upd: 0;
       cbfNW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbfNQ: // global
           R1 = GHC.IO.Handle.FD.fdToHandle6_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbfNT() //  [R1]
         { info_tbl: [(cbfNT,
                       label: block_cbfNT_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfNT: // global
           if (R1 & 7 == 4) goto cbfO6; else goto ubfP9;
       cbfO6: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp + 32] = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
       ubfP9: // global
           call _cbfMp() args: 0, res: 0, upd: 0;
     }
 },
 _cbfMp() //  []
         { info_tbl: [(cbfMp,
                       label: block_cbfMp_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfMp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbfNF; else goto cbfNE;
       cbfNF: // global
           HpAlloc = 24;
           I64[Sp] = block_cbfMp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbfNE: // global
           I64[Hp - 16] = sat_sbfDL_info;
           P64[Hp] = P64[Sp + 32];
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = GHC.Types.True_closure+2;
           _cbfM8::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = _cbfM8::P64;
           P64[Sp + 32] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
           P64[Sp + 40] = GHC.Base.Nothing_closure+1;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.979133721 UTC

[section ""data" . GHC.IO.Handle.FD.mkHandleFromFD_closure" {
     GHC.IO.Handle.FD.mkHandleFromFD_closure:
         const GHC.IO.Handle.FD.mkHandleFromFD_info;
         const 0;
 },
 GHC.IO.Handle.FD.mkHandleFromFD_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbfPh,
                       label: GHC.IO.Handle.FD.mkHandleFromFD_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfPh: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.979890267 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'2_closure" {
     GHC.IO.Handle.FD.fdToHandle'2_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.981824953 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'1_closure" {
     GHC.IO.Handle.FD.fdToHandle'1_closure:
         const GHC.IO.Handle.FD.fdToHandle'1_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle'1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbfPx,
                       label: GHC.IO.Handle.FD.fdToHandle'1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfPx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbfPy; else goto cbfPz;
       cbfPy: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbfPz: // global
           I64[Sp - 40] = block_cbfPq_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubfQV; else goto cbfPr;
       ubfQV: // global
           call _cbfPq(R1) args: 0, res: 0, upd: 0;
       cbfPr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfPq() //  [R1]
         { info_tbl: [(cbfPq,
                       label: block_cbfPq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfPq: // global
           if (R1 & 7 == 1) goto cbfPu; else goto cbfPv;
       cbfPu: // global
           _sbfEv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbfQ4_info;
           R5 = P64[Sp + 16];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[Sp + 32];
           R2 = _sbfEv::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       cbfPv: // global
           I64[Sp] = block_cbfQg_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubfQU; else goto cbfQi;
       ubfQU: // global
           call _cbfQg(R1) args: 0, res: 0, upd: 0;
       cbfQi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfQ4() //  [R1]
         { info_tbl: [(cbfQ4,
                       label: block_cbfQ4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfQ4: // global
           I64[Sp] = block_cbfQ6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubfQX; else goto cbfQ9;
       ubfQX: // global
           call _cbfQ6(R1) args: 0, res: 0, upd: 0;
       cbfQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfQ6() //  [R1]
         { info_tbl: [(cbfQ6,
                       label: block_cbfQ6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfQ6: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _sbfEC() args: 0, res: 0, upd: 0;
     }
 },
 _cbfQg() //  [R1]
         { info_tbl: [(cbfQg,
                       label: block_cbfQg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfQg: // global
           _sbfEv::P64 = P64[Sp + 8];
           _sbfEx::P64 = P64[Sp + 16];
           _sbfEz::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto cbfQI; else goto cbfQs;
       cbfQI: // global
           I64[Sp + 8] = block_cbfQE_info;
           R5 = _sbfEx::P64;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = _sbfEz::P64;
           R2 = _sbfEv::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       cbfQs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbfQv; else goto cbfQu;
       cbfQv: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfQu: // global
           I64[Hp - 40] = (,,)_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = GHC.IO.Handle.FD.fdToHandle'2_closure+1;
           P64[Hp - 16] = GHC.IO.Handle.FD.fdToHandle'2_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           I64[Sp + 8] = block_cbfQo_info;
           R5 = _sbfEx::P64;
           R4 = Hp - 6;
           R3 = _sbfEz::P64;
           R2 = _sbfEv::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfQE() //  [R1]
         { info_tbl: [(cbfQE,
                       label: block_cbfQE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfQE: // global
           I64[Sp] = block_cbfQG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubfR1; else goto cbfQK;
       ubfR1: // global
           call _cbfQG(R1) args: 0, res: 0, upd: 0;
       cbfQK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfQG() //  [R1]
         { info_tbl: [(cbfQG,
                       label: block_cbfQG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfQG: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _sbfEC() args: 0, res: 0, upd: 0;
     }
 },
 _cbfQo() //  [R1]
         { info_tbl: [(cbfQo,
                       label: block_cbfQo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfQo: // global
           I64[Sp] = block_cbfQq_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubfQZ; else goto cbfQx;
       ubfQZ: // global
           call _cbfQq(R1) args: 0, res: 0, upd: 0;
       cbfQx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfQq() //  [R1]
         { info_tbl: [(cbfQq,
                       label: block_cbfQq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfQq: // global
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call _sbfEC() args: 0, res: 0, upd: 0;
     }
 },
 _sbfEC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbfEC: // global
           I64[Sp - 8] = block_cbfPD_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubfR3; else goto cbfPF;
       ubfR3: // global
           call _cbfPD(R1) args: 0, res: 0, upd: 0;
       cbfPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfPD() //  [R1]
         { info_tbl: [(cbfPD,
                       label: block_cbfPD_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfPD: // global
           if (R1 & 7 == 1) goto cbfPT; else goto cbfQ1;
       cbfPT: // global
           I64[Sp] = block_cbfPJ_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubfQW; else goto cbfPK;
       ubfQW: // global
           call _cbfPJ(R1) args: 0, res: 0, upd: 0;
       cbfPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbfQ1: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 _cbfPJ() //  [R1]
         { info_tbl: [(cbfPJ,
                       label: block_cbfPJ_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfPJ: // global
           I64[Sp] = block_cbfPO_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfPO() //  [R1]
         { info_tbl: [(cbfPO,
                       label: block_cbfPO_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfPO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbfPX; else goto cbfPW;
       cbfPX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfPW: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 48] = Hp - 6;
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.985917163 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'_closure" {
     GHC.IO.Handle.FD.fdToHandle'_closure:
         const GHC.IO.Handle.FD.fdToHandle'_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbfR8,
                       label: GHC.IO.Handle.FD.fdToHandle'_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfR8: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle'1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.986658914 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle4_bytes" {
     GHC.IO.Handle.FD.fdToHandle4_bytes:
         I8[] [60,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.987176968 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle3_bytes" {
     GHC.IO.Handle.FD.fdToHandle3_bytes:
         I8[] [62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.987871932 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle2_closure" {
     GHC.IO.Handle.FD.fdToHandle2_closure:
         const GHC.IO.Handle.FD.fdToHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle2_entry() //  [R1]
         { info_tbl: [(cbfRh,
                       label: GHC.IO.Handle.FD.fdToHandle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfRh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfRi; else goto cbfRj;
       cbfRi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfRj: // global
           (_cbfRe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbfRe::I64 == 0) goto cbfRg; else goto cbfRf;
       cbfRg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbfRf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbfRe::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.989694745 UTC

[section ""data" . GHC.IO.Handle.FD.$wfdToHandle_closure" {
     GHC.IO.Handle.FD.$wfdToHandle_closure:
         const GHC.IO.Handle.FD.$wfdToHandle_info;
         const 0;
 },
 sat_sbfFu_entry() //  [R1]
         { info_tbl: [(cbfRJ,
                       label: sat_sbfFu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfRJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbfRP; else goto cbfRQ;
       cbfRP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfRQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbfRG_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubfRV; else goto cbfRH;
       ubfRV: // global
           call _cbfRG(R1) args: 0, res: 0, upd: 0;
       cbfRH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbfRG() //  [R1]
         { info_tbl: [(cbfRG,
                       label: block_cbfRG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfRG: // global
           I64[Sp] = block_cbfRM_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbfRM() //  [R1, R2]
         { info_tbl: [(cbfRM,
                       label: block_cbfRM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfRM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbfRU; else goto cbfRT;
       cbfRU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbfRT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.IO.Handle.FD.fdToHandle2_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfFv_entry() //  [R1]
         { info_tbl: [(cbfRW,
                       label: sat_sbfFv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfRW: // global
           _sbfFv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbfRX; else goto cbfRY;
       cbfRY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbfS0; else goto cbfRZ;
       cbfS0: // global
           HpAlloc = 24;
           goto cbfRX;
       cbfRX: // global
           R1 = _sbfFv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfRZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfFv::P64;
           _sbfFl::P64 = P64[_sbfFv::P64 + 16];
           I64[Hp - 16] = sat_sbfFu_info;
           P64[Hp] = _sbfFl::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.FD.fdToHandle4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.$wfdToHandle_entry() //  [R2]
         { info_tbl: [(cbfS1,
                       label: GHC.IO.Handle.FD.$wfdToHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfS1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfS2; else goto cbfS3;
       cbfS2: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.$wfdToHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbfS3: // global
           I64[Sp - 16] = block_cbfRo_info;
           _sbfFb::I64 = R2;
           R2 = R2;
           I64[Sp - 8] = _sbfFb::I64;
           Sp = Sp - 16;
           call System.Posix.Internals.$wfdGetMode_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfRo() //  [R1]
         { info_tbl: [(cbfRo,
                       label: block_cbfRo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfRo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbfS6; else goto cbfS5;
       cbfS6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfS5: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp] = block_cbfRr_info;
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = R1;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfRr() //  [R1]
         { info_tbl: [(cbfRr,
                       label: block_cbfRr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfRr: // global
           I64[Sp] = block_cbfRt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubfSb; else goto cbfRu;
       ubfSb: // global
           call _cbfRt(R1) args: 0, res: 0, upd: 0;
       cbfRu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfRt() //  [R1]
         { info_tbl: [(cbfRt,
                       label: block_cbfRt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfRt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbfSa; else goto cbfS9;
       cbfSa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfS9: // global
           _sbfFl::P64 = P64[R1 + 7];
           _sbfFm::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sbfFv_info;
           P64[Hp] = _sbfFl::P64;
           R6 = GHC.Types.False_closure+1;
           R5 = P64[Sp + 8];
           R4 = Hp - 16;
           R3 = _sbfFm::P64;
           R2 = _sbfFl::P64;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.992446813 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle1_closure" {
     GHC.IO.Handle.FD.fdToHandle1_closure:
         const GHC.IO.Handle.FD.fdToHandle1_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle1_entry() //  [R2]
         { info_tbl: [(cbfSj,
                       label: GHC.IO.Handle.FD.fdToHandle1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbfSk; else goto cbfSl;
       cbfSk: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbfSl: // global
           I64[Sp - 8] = block_cbfSg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubfSp; else goto cbfSh;
       ubfSp: // global
           call _cbfSg(R1) args: 0, res: 0, upd: 0;
       cbfSh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfSg() //  [R1]
         { info_tbl: [(cbfSg,
                       label: block_cbfSg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSg: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.$wfdToHandle_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.993542149 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle_closure" {
     GHC.IO.Handle.FD.fdToHandle_closure:
         const GHC.IO.Handle.FD.fdToHandle_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle_entry() //  [R2]
         { info_tbl: [(cbfSu,
                       label: GHC.IO.Handle.FD.fdToHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSu: // global
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.99543925 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile5_closure" {
     GHC.IO.Handle.FD.openBinaryFile5_closure:
         const GHC.IO.Handle.FD.openBinaryFile5_info;
         const 0;
 },
 sat_sbfFX_entry() //  [R1, R2]
         { info_tbl: [(cbfSV,
                       label: sat_sbfFX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfSZ; else goto cbfT0;
       cbfSZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbfT0: // global
           I64[Sp - 16] = block_cbfSS_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubfT4; else goto cbfST;
       ubfT4: // global
           call _cbfSS(R1) args: 0, res: 0, upd: 0;
       cbfST: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfSS() //  [R1]
         { info_tbl: [(cbfSS,
                       label: block_cbfSS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSS: // global
           I64[Sp] = block_cbfSY_info;
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfSY() //  []
         { info_tbl: [(cbfSY,
                       label: block_cbfSY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfFO_entry() //  [R1]
         { info_tbl: [(cbfTa,
                       label: sat_sbfFO_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfTa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbfTb; else goto cbfTc;
       cbfTb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbfTc: // global
           R6 = GHC.Types.False_closure+1;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 39];
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbfTd,
                       label: GHC.IO.Handle.FD.openBinaryFile5_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfTd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbfTe; else goto cbfTf;
       cbfTe: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbfTf: // global
           I64[Sp - 32] = block_cbfSB_info;
           _sbfFC::P64 = R4;
           R4 = R5;
           _sbfFB::P64 = R3;
           R3 = R3;
           _sbfFA::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbfFA::P64;
           P64[Sp - 16] = _sbfFB::P64;
           P64[Sp - 8] = _sbfFC::P64;
           Sp = Sp - 32;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfSB() //  [R1]
         { info_tbl: [(cbfSB,
                       label: block_cbfSB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSB: // global
           I64[Sp] = block_cbfSD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubfTN; else goto cbfSE;
       ubfTN: // global
           call _cbfSD(R1) args: 0, res: 0, upd: 0;
       cbfSE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfSD() //  [R1]
         { info_tbl: [(cbfSD,
                       label: block_cbfSD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSD: // global
           I64[Sp - 8] = block_cbfTh_info;
           _sbfFJ::P64 = P64[R1 + 7];
           _sbfFK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sbfFK::P64;
           P64[Sp + 24] = _sbfFJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubfTO; else goto cbfTm;
       ubfTO: // global
           call _cbfTh(R1) args: 0, res: 0, upd: 0;
       cbfTm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfTh() //  [R1]
         { info_tbl: [(cbfTh,
                       label: block_cbfTh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfTh: // global
           if (R1 & 7 == 1) goto cbfTt; else goto cbfTH;
       cbfTt: // global
           I64[Sp] = block_cbfTq_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubfTQ; else goto cbfTu;
       ubfTQ: // global
           call _cbfTq(R1) args: 0, res: 0, upd: 0;
       cbfTu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbfTH: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _cbfSL() args: 0, res: 0, upd: 0;
     }
 },
 _cbfTq() //  [R1]
         { info_tbl: [(cbfTq,
                       label: block_cbfTq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfTq: // global
           I64[Sp] = block_cbfTy_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfTy() //  [R1]
         { info_tbl: [(cbfTy,
                       label: block_cbfTy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfTy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbfTD; else goto cbfTC;
       cbfTD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfTC: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 6;
           call _cbfSL() args: 0, res: 0, upd: 0;
     }
 },
 _cbfSL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSL: // global
           Hp = Hp + 64;
           _sbfFN::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cbfTl; else goto cbfTk;
       cbfTl: // global
           HpAlloc = 64;
           I64[Sp] = block_cbfSK_info;
           R1 = _sbfFN::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfTk: // global
           I64[Hp - 56] = sat_sbfFX_info;
           _sbfFJ::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sbfFJ::P64;
           I64[Hp - 40] = sat_sbfFO_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sbfFJ::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sbfFN::P64;
           R2 = Hp - 54;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbfSK() //  [R1]
         { info_tbl: [(cbfSK,
                       label: block_cbfSK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfSK: // global
           P64[Sp] = R1;
           call _cbfSL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.999221233 UTC

[section ""data" . GHC.IO.Handle.FD.openFile2_closure" {
     GHC.IO.Handle.FD.openFile2_closure:
         const GHC.IO.Handle.FD.openFile2_info;
         const 0;
 },
 sat_sbfGi_entry() //  [R1]
         { info_tbl: [(cbfU8,
                       label: sat_sbfGi_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfU8: // global
           _sbfGi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbfU9; else goto cbfUa;
       cbfUa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbfUc; else goto cbfUb;
       cbfUc: // global
           HpAlloc = 72;
           goto cbfU9;
       cbfU9: // global
           R1 = _sbfGi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfUb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfGi::P64;
           _sbfG6::P64 = P64[_sbfGi::P64 + 16];
           _sbfGa::P64 = P64[_sbfGi::P64 + 24];
           _sbfGb::P64 = P64[_sbfGi::P64 + 32];
           _sbfGd::P64 = P64[_sbfGi::P64 + 40];
           _sbfGe::P64 = P64[_sbfGi::P64 + 48];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfG6::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = _sbfGa::P64;
           P64[Hp - 32] = _sbfGb::P64;
           P64[Hp - 24] = GHC.IO.Handle.FD.fdToHandle10_closure;
           P64[Hp - 16] = _sbfGd::P64;
           P64[Hp - 8] = _sbfGe::P64;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.openFile2_entry() //  [R2, R3]
         { info_tbl: [(cbfUd,
                       label: GHC.IO.Handle.FD.openFile2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfUd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfUe; else goto cbfUf;
       cbfUe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFile2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbfUf: // global
           I64[Sp - 16] = block_cbfTX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubfUj; else goto cbfTY;
       ubfUj: // global
           call _cbfTX(R1) args: 0, res: 0, upd: 0;
       cbfTY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfTX() //  [R1]
         { info_tbl: [(cbfTX,
                       label: block_cbfTX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfTX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbfUi; else goto cbfUh;
       cbfUi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfUh: // global
           _sbfGa::P64 = P64[R1 + 7];
           _sbfGb::P64 = P64[R1 + 15];
           _sbfGd::P64 = P64[R1 + 31];
           _sbfGe::P64 = P64[R1 + 39];
           I64[Hp - 48] = sat_sbfGi_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbfGa::P64;
           P64[Hp - 16] = _sbfGb::P64;
           P64[Hp - 8] = _sbfGd::P64;
           P64[Hp] = _sbfGe::P64;
           R1 = Hp - 48;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.001812926 UTC

[section ""data" . GHC.IO.Handle.FD.openFile1_closure" {
     GHC.IO.Handle.FD.openFile1_closure:
         const GHC.IO.Handle.FD.openFile1_info;
         const 0;
 },
 sat_sbfGt_entry() //  [R1]
         { info_tbl: [(cbfUL,
                       label: sat_sbfGt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfUL: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGv_entry() //  [R1, R2]
         { info_tbl: [(cbfUO,
                       label: sat_sbfGv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfUO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbfUP; else goto cbfUQ;
       cbfUP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbfUQ: // global
           I64[Sp - 16] = block_cbfUt_info;
           _sbfGj::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbfGj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubfV3; else goto cbfUu;
       ubfV3: // global
           call _cbfUt(R1) args: 0, res: 0, upd: 0;
       cbfUu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfUt() //  [R1]
         { info_tbl: [(cbfUt,
                       label: block_cbfUt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfUt: // global
           I64[Sp - 16] = block_cbfUy_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfUy() //  [R1]
         { info_tbl: [(cbfUy,
                       label: block_cbfUy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfUy: // global
           I64[Sp] = block_cbfUC_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfUC() //  [R1]
         { info_tbl: [(cbfUC,
                       label: block_cbfUC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfUC: // global
           if (R1 & 7 == 1) goto cbfUU; else goto cbfV1;
       cbfUU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbfUX; else goto cbfUW;
       cbfUX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfUW: // global
           I64[Hp - 8] = sat_sbfGt_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbfV1: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGm_entry() //  [R1]
         { info_tbl: [(cbfV9,
                       label: sat_sbfGm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfV9: // global
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Types.False_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openFile1_entry() //  [R2, R3]
         { info_tbl: [(cbfVc,
                       label: GHC.IO.Handle.FD.openFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfVc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbfVg; else goto cbfVf;
       cbfVg: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbfVf: // global
           I64[Hp - 32] = sat_sbfGv_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbfGm_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.006200526 UTC

[section ""data" . GHC.IO.Handle.FD.openFile_closure" {
     GHC.IO.Handle.FD.openFile_closure:
         const GHC.IO.Handle.FD.openFile_info;
         const 0;
 },
 GHC.IO.Handle.FD.openFile_entry() //  [R2, R3]
         { info_tbl: [(cbfVl,
                       label: GHC.IO.Handle.FD.openFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfVl: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.007723424 UTC

[section ""data" . GHC.IO.Handle.FD.openFileBlocking1_closure" {
     GHC.IO.Handle.FD.openFileBlocking1_closure:
         const GHC.IO.Handle.FD.openFileBlocking1_info;
         const 0;
 },
 sat_sbfGG_entry() //  [R1]
         { info_tbl: [(cbfVP,
                       label: sat_sbfGG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfVP: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGI_entry() //  [R1, R2]
         { info_tbl: [(cbfVS,
                       label: sat_sbfGI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfVS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbfVT; else goto cbfVU;
       cbfVT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbfVU: // global
           I64[Sp - 16] = block_cbfVx_info;
           _sbfGw::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbfGw::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubfW7; else goto cbfVy;
       ubfW7: // global
           call _cbfVx(R1) args: 0, res: 0, upd: 0;
       cbfVy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfVx() //  [R1]
         { info_tbl: [(cbfVx,
                       label: block_cbfVx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfVx: // global
           I64[Sp - 16] = block_cbfVC_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfVC() //  [R1]
         { info_tbl: [(cbfVC,
                       label: block_cbfVC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfVC: // global
           I64[Sp] = block_cbfVG_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfVG() //  [R1]
         { info_tbl: [(cbfVG,
                       label: block_cbfVG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfVG: // global
           if (R1 & 7 == 1) goto cbfVY; else goto cbfW5;
       cbfVY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbfW1; else goto cbfW0;
       cbfW1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfW0: // global
           I64[Hp - 8] = sat_sbfGG_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbfW5: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGz_entry() //  [R1]
         { info_tbl: [(cbfWd,
                       label: sat_sbfGz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfWd: // global
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Types.False_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openFileBlocking1_entry() //  [R2, R3]
         { info_tbl: [(cbfWg,
                       label: GHC.IO.Handle.FD.openFileBlocking1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfWg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbfWk; else goto cbfWj;
       cbfWk: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFileBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbfWj: // global
           I64[Hp - 32] = sat_sbfGI_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbfGz_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.01003467 UTC

[section ""data" . GHC.IO.Handle.FD.openFileBlocking_closure" {
     GHC.IO.Handle.FD.openFileBlocking_closure:
         const GHC.IO.Handle.FD.openFileBlocking_info;
         const 0;
 },
 GHC.IO.Handle.FD.openFileBlocking_entry() //  [R2, R3]
         { info_tbl: [(cbfWp,
                       label: GHC.IO.Handle.FD.openFileBlocking_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfWp: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openFileBlocking1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.01072266 UTC

[section ""cstring" . GHC.IO.Handle.FD.openBinaryFile4_bytes" {
     GHC.IO.Handle.FD.openBinaryFile4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.011402507 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile3_closure" {
     GHC.IO.Handle.FD.openBinaryFile3_closure:
         const GHC.IO.Handle.FD.openBinaryFile3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.openBinaryFile3_entry() //  [R1]
         { info_tbl: [(cbfWy,
                       label: GHC.IO.Handle.FD.openBinaryFile3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfWy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfWz; else goto cbfWA;
       cbfWz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfWA: // global
           (_cbfWv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbfWv::I64 == 0) goto cbfWx; else goto cbfWw;
       cbfWx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbfWw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbfWv::I64;
           R2 = GHC.IO.Handle.FD.openBinaryFile4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.012706701 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile2_closure" {
     GHC.IO.Handle.FD.openBinaryFile2_closure:
         const GHC.IO.Handle.FD.openBinaryFile2_info;
         const 0;
 },
 sat_sbfGV_entry() //  [R1]
         { info_tbl: [(cbfWQ,
                       label: sat_sbfGV_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfWQ: // global
           _sbfGV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbfWR; else goto cbfWS;
       cbfWS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbfWU; else goto cbfWT;
       cbfWU: // global
           HpAlloc = 72;
           goto cbfWR;
       cbfWR: // global
           R1 = _sbfGV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfWT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfGV::P64;
           _sbfGJ::P64 = P64[_sbfGV::P64 + 16];
           _sbfGN::P64 = P64[_sbfGV::P64 + 24];
           _sbfGO::P64 = P64[_sbfGV::P64 + 32];
           _sbfGQ::P64 = P64[_sbfGV::P64 + 40];
           _sbfGR::P64 = P64[_sbfGV::P64 + 48];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfGJ::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = _sbfGN::P64;
           P64[Hp - 32] = _sbfGO::P64;
           P64[Hp - 24] = GHC.IO.Handle.FD.openBinaryFile3_closure;
           P64[Hp - 16] = _sbfGQ::P64;
           P64[Hp - 8] = _sbfGR::P64;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile2_entry() //  [R2, R3]
         { info_tbl: [(cbfWV,
                       label: GHC.IO.Handle.FD.openBinaryFile2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfWV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfWW; else goto cbfWX;
       cbfWW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbfWX: // global
           I64[Sp - 16] = block_cbfWF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubfX1; else goto cbfWG;
       ubfX1: // global
           call _cbfWF(R1) args: 0, res: 0, upd: 0;
       cbfWG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfWF() //  [R1]
         { info_tbl: [(cbfWF,
                       label: block_cbfWF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfWF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbfX0; else goto cbfWZ;
       cbfX0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfWZ: // global
           _sbfGN::P64 = P64[R1 + 7];
           _sbfGO::P64 = P64[R1 + 15];
           _sbfGQ::P64 = P64[R1 + 31];
           _sbfGR::P64 = P64[R1 + 39];
           I64[Hp - 48] = sat_sbfGV_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbfGN::P64;
           P64[Hp - 16] = _sbfGO::P64;
           P64[Hp - 8] = _sbfGQ::P64;
           P64[Hp] = _sbfGR::P64;
           R1 = Hp - 48;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.015097364 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile1_closure" {
     GHC.IO.Handle.FD.openBinaryFile1_closure:
         const GHC.IO.Handle.FD.openBinaryFile1_info;
         const 0;
 },
 sat_sbfH6_entry() //  [R1]
         { info_tbl: [(cbfXt,
                       label: sat_sbfH6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfXt: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfH8_entry() //  [R1, R2]
         { info_tbl: [(cbfXw,
                       label: sat_sbfH8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfXw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbfXx; else goto cbfXy;
       cbfXx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbfXy: // global
           I64[Sp - 16] = block_cbfXb_info;
           _sbfGW::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbfGW::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubfXL; else goto cbfXc;
       ubfXL: // global
           call _cbfXb(R1) args: 0, res: 0, upd: 0;
       cbfXc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfXb() //  [R1]
         { info_tbl: [(cbfXb,
                       label: block_cbfXb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfXb: // global
           I64[Sp - 16] = block_cbfXg_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfXg() //  [R1]
         { info_tbl: [(cbfXg,
                       label: block_cbfXg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfXg: // global
           I64[Sp] = block_cbfXk_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbfXk() //  [R1]
         { info_tbl: [(cbfXk,
                       label: block_cbfXk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfXk: // global
           if (R1 & 7 == 1) goto cbfXC; else goto cbfXJ;
       cbfXC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbfXF; else goto cbfXE;
       cbfXF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfXE: // global
           I64[Hp - 8] = sat_sbfH6_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbfXJ: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openBinaryFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGZ_entry() //  [R1]
         { info_tbl: [(cbfXR,
                       label: sat_sbfGZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfXR: // global
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Types.True_closure+2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile1_entry() //  [R2, R3]
         { info_tbl: [(cbfXU,
                       label: GHC.IO.Handle.FD.openBinaryFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfXU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbfXY; else goto cbfXX;
       cbfXY: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbfXX: // global
           I64[Hp - 32] = sat_sbfH8_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbfGZ_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.017236989 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile_closure" {
     GHC.IO.Handle.FD.openBinaryFile_closure:
         const GHC.IO.Handle.FD.openBinaryFile_info;
         const 0;
 },
 GHC.IO.Handle.FD.openBinaryFile_entry() //  [R2, R3]
         { info_tbl: [(cbfY3,
                       label: GHC.IO.Handle.FD.openBinaryFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfY3: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.020604152 UTC

[section ""data" . $wstdHandleFinalizer_rbfCA_closure" {
     $wstdHandleFinalizer_rbfCA_closure:
         const $wstdHandleFinalizer_rbfCA_info;
         const 0;
 },
 sat_sbfHL_entry() //  [R1]
         { info_tbl: [(cbfYK,
                       label: sat_sbfHL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfYK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfYL; else goto cbfYM;
       cbfYL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfYM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfHX_entry() //  [R1]
         { info_tbl: [(cbfZ0,
                       label: sat_sbfHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZ0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfZ1; else goto cbfZ2;
       cbfZ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfZ2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfIa_entry() //  [R1]
         { info_tbl: [(cbfZl,
                       label: sat_sbfIa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfZm; else goto cbfZn;
       cbfZm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfZn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfIm_entry() //  [R1]
         { info_tbl: [(cbfZB,
                       label: sat_sbfIm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfZC; else goto cbfZD;
       cbfZC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfZD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfIo_entry() //  [R1]
         { info_tbl: [(cbfZK,
                       label: sat_sbfIo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbfZL; else goto cbfZM;
       cbfZL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfZM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wstdHandleFinalizer_rbfCA_entry() //  [R2, R3]
         { info_tbl: [(cbfZN,
                       label: $wstdHandleFinalizer_rbfCA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZN: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbfZO; else goto cbfZP;
       cbfZO: // global
           R3 = R3;
           R2 = R2;
           R1 = $wstdHandleFinalizer_rbfCA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbfZP: // global
           I64[Sp - 24] = block_cbfYa_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfYa() //  [R1]
         { info_tbl: [(cbfYa,
                       label: block_cbfYa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfYa: // global
           I64[Sp] = block_cbfYc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubg1l; else goto cbfYd;
       ubg1l: // global
           call _cbfYc(R1) args: 0, res: 0, upd: 0;
       cbfYd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfYc() //  [R1]
         { info_tbl: [(cbfYc,
                       label: block_cbfYc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfYc: // global
           I64[Sp - 48] = block_cbfYh_info;
           _sbfHh::P64 = P64[R1 + 15];
           _sbfHj::P64 = P64[R1 + 31];
           _sbfHk::P64 = P64[R1 + 39];
           _sbfHl::P64 = P64[R1 + 47];
           _sbfHq::P64 = P64[R1 + 87];
           _sbfHr::P64 = P64[R1 + 95];
           R1 = P64[_sbfHl::P64 + 8];
           P64[Sp - 40] = _sbfHj::P64;
           P64[Sp - 32] = _sbfHk::P64;
           P64[Sp - 24] = _sbfHl::P64;
           P64[Sp - 16] = _sbfHq::P64;
           P64[Sp - 8] = _sbfHr::P64;
           P64[Sp] = _sbfHh::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ubg1m; else goto cbfYi;
       ubg1m: // global
           call _cbfYh(R1) args: 0, res: 0, upd: 0;
       cbfYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfYh() //  [R1]
         { info_tbl: [(cbfYh,
                       label: block_cbfYh_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfYh: // global
           I64[Sp] = block_cbfZS_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubg1n; else goto cbg0K;
       ubg1n: // global
           call _cbfZS(R1) args: 0, res: 0, upd: 0;
       cbg0K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfZS() //  [R1]
         { info_tbl: [(cbfZS,
                       label: block_cbfZS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZS: // global
           if (R1 & 7 == 1) goto ubg1i; else goto cbg0V;
       ubg1i: // global
           Sp = Sp + 16;
           call _sbfHG() args: 0, res: 0, upd: 0;
       cbg0V: // global
           _sbfIt::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbg0T_info;
           R1 = _sbfIt::P64;
           if (R1 & 7 != 0) goto ubg1u; else goto cbg0W;
       ubg1u: // global
           call _cbg0T(R1) args: 0, res: 0, upd: 0;
       cbg0W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg0T() //  [R1]
         { info_tbl: [(cbg0T,
                       label: block_cbg0T_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg0T: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubg1j; else goto cbg16;
       ubg1j: // global
           Sp = Sp + 16;
           call _sbfHG() args: 0, res: 0, upd: 0;
       cbg16: // global
           _sbfHj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbg14_info;
           R2 = P64[Sp + 48];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sbfHj::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbg14() //  [R1]
         { info_tbl: [(cbg14,
                       label: block_cbg14_info
                       rep:StackRep [False, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg14: // global
           _sbfHl::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbfHl::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbfHl::P64);
           Sp = Sp + 8;
           call _sbfHG() args: 0, res: 0, upd: 0;
     }
 },
 _sbfHG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbfHG: // global
           I64[Sp + 8] = block_cbfYr_info;
           R1 = P64[Sp];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubg1y; else goto cbfYs;
       ubg1y: // global
           call _cbfYr(R1) args: 0, res: 0, upd: 0;
       cbfYs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfYr() //  [R1]
         { info_tbl: [(cbfYr,
                       label: block_cbfYr_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfYr: // global
           if (R1 & 7 == 1) goto cbg0E; else goto cbfZX;
       cbg0E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg0H; else goto cbg0G;
       cbg0H: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg0G: // global
           I64[Hp - 16] = sat_sbfIo_info;
           P64[Hp] = P64[Sp + 32];
           _sbfHa::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbg0D_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbfZX: // global
           I64[Sp] = block_cbfYw_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubg1o; else goto cbfYx;
       ubg1o: // global
           call _cbfYw(R1) args: 0, res: 0, upd: 0;
       cbfYx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfYw() //  [R1]
         { info_tbl: [(cbfYw,
                       label: block_cbfYw_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfYw: // global
           if (R1 & 7 == 1) goto cbg00; else goto cbg0j;
       cbg00: // global
           I64[Sp + 24] = block_cbfYB_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubg1p; else goto cbfYC;
       ubg1p: // global
           call _cbfYB(R1) args: 0, res: 0, upd: 0;
       cbfYC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbg0j: // global
           I64[Sp] = block_cbfZ5_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubg1q; else goto cbfZ6;
       ubg1q: // global
           call _cbfZ5(R1) args: 0, res: 0, upd: 0;
       cbfZ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfYB() //  [R1]
         { info_tbl: [(cbfYB,
                       label: block_cbfYB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfYB: // global
           if (R1 & 7 == 1) goto cbg03; else goto cbg0b;
       cbg03: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg06; else goto cbg05;
       cbg06: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg05: // global
           I64[Hp - 16] = sat_sbfHL_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbg0D_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbg0b: // global
           I64[Sp] = block_cbfYP_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubg1r; else goto cbfYQ;
       ubg1r: // global
           call _cbfYP(R1) args: 0, res: 0, upd: 0;
       cbfYQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfYP() //  [R1]
         { info_tbl: [(cbfYP,
                       label: block_cbfYP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfYP: // global
           I64[Sp] = block_cbfYU_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfYU() //  [R1]
         { info_tbl: [(cbfYU,
                       label: block_cbfYU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfYU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg0f; else goto cbg0e;
       cbg0f: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg0e: // global
           I64[Hp - 16] = sat_sbfHX_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbg0D_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfZ5() //  [R1]
         { info_tbl: [(cbfZ5,
                       label: block_cbfZ5_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZ5: // global
           I64[Sp] = block_cbfZa_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfZa() //  []
         { info_tbl: [(cbfZa,
                       label: block_cbfZa_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZa: // global
           I64[Sp + 24] = block_cbfZc_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubg1s; else goto cbfZd;
       ubg1s: // global
           call _cbfZc(R1) args: 0, res: 0, upd: 0;
       cbfZd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfZc() //  [R1]
         { info_tbl: [(cbfZc,
                       label: block_cbfZc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZc: // global
           if (R1 & 7 == 1) goto cbg0o; else goto cbg0w;
       cbg0o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg0r; else goto cbg0q;
       cbg0r: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg0q: // global
           I64[Hp - 16] = sat_sbfIa_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbg0D_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbg0w: // global
           I64[Sp] = block_cbfZq_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubg1t; else goto cbfZr;
       ubg1t: // global
           call _cbfZq(R1) args: 0, res: 0, upd: 0;
       cbfZr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfZq() //  [R1]
         { info_tbl: [(cbfZq,
                       label: block_cbfZq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZq: // global
           I64[Sp] = block_cbfZv_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfZv() //  [R1]
         { info_tbl: [(cbfZv,
                       label: block_cbfZv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfZv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg0A; else goto cbg0z;
       cbg0A: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg0z: // global
           I64[Hp - 16] = sat_sbfIm_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbg0D_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg0D() //  []
         { info_tbl: [(cbg0D,
                       label: block_cbg0D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg0D: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.026706753 UTC

[section ""data" . stdHandleFinalizer_rbfCB_closure" {
     stdHandleFinalizer_rbfCB_closure:
         const stdHandleFinalizer_rbfCB_info;
         const 0;
 },
 stdHandleFinalizer_rbfCB_entry() //  [R2, R3]
         { info_tbl: [(cbg1G,
                       label: stdHandleFinalizer_rbfCB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg1G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg1H; else goto cbg1I;
       cbg1H: // global
           R3 = R3;
           R2 = R2;
           R1 = stdHandleFinalizer_rbfCB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbg1I: // global
           I64[Sp - 16] = block_cbg1D_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubg1M; else goto cbg1E;
       ubg1M: // global
           call _cbg1D(R1) args: 0, res: 0, upd: 0;
       cbg1E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg1D() //  [R1]
         { info_tbl: [(cbg1D,
                       label: block_cbg1D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg1D: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wstdHandleFinalizer_rbfCA_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.027707679 UTC

[section ""cstring" . lvl6_rbfCC_bytes" {
     lvl6_rbfCC_bytes:
         I8[] [60,115,116,100,101,114,114,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.028398213 UTC

[section ""data" . lvl7_rbfCD_closure" {
     lvl7_rbfCD_closure:
         const lvl7_rbfCD_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rbfCD_entry() //  [R1]
         { info_tbl: [(cbg1T,
                       label: lvl7_rbfCD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg1T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg1U; else goto cbg1V;
       cbg1U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg1V: // global
           (_cbg1Q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg1Q::I64 == 0) goto cbg1S; else goto cbg1R;
       cbg1S: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg1R: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg1Q::I64;
           R2 = lvl6_rbfCC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.02926585 UTC

[section ""data" . lvl8_rbfCE_closure" {
     lvl8_rbfCE_closure:
         const GHC.Base.Just_con_info;
         const stdHandleFinalizer_rbfCB_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.030180349 UTC

[section ""data" . lvl9_rbfCF_closure" {
     lvl9_rbfCF_closure:
         const lvl9_rbfCF_info;
         const 0;
 },
 section ""relreadonly" . ubg2j_srtd" {
     ubg2j_srtd:
         const SbfJE_srt+64;
         const 37;
         const 120259089281;
 },
 lvl9_rbfCF_entry() //  []
         { info_tbl: [(cbg25,
                       label: lvl9_rbfCF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg25: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbg26; else goto cbg27;
       cbg26: // global
           R1 = lvl9_rbfCF_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbg27: // global
           I64[Sp - 8] = block_cbg20_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubg2k_srtd" {
     ubg2k_srtd:
         const SbfJE_srt+64;
         const 36;
         const 51539612545;
 },
 _cbg20() //  []
         { info_tbl: [(cbg20,
                       label: block_cbg20_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg20: // global
           I64[Sp] = block_cbg22_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubg2i; else goto cbg23;
       ubg2i: // global
           call _cbg22(R1) args: 0, res: 0, upd: 0;
       cbg23: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubg2l_srtd" {
     ubg2l_srtd:
         const SbfJE_srt+64;
         const 36;
         const 51539608449;
 },
 _cbg22() //  [R1]
         { info_tbl: [(cbg22,
                       label: block_cbg22_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg22: // global
           I64[Sp] = block_cbg2b_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubg2m_srtd" {
     ubg2m_srtd:
         const SbfJE_srt+64;
         const 36;
         const 51539608449;
 },
 _cbg2b() //  [R1]
         { info_tbl: [(cbg2b,
                       label: block_cbg2b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg2b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbg2g; else goto cbg2f;
       cbg2g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg2f: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl7_rbfCD_closure;
           R5 = GHC.IO.FD.stderr_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 32] = GHC.Types.False_closure+1;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.031928035 UTC

[section ""data" . GHC.IO.Handle.FD.stderr_closure" {
     GHC.IO.Handle.FD.stderr_closure:
         const GHC.IO.Handle.FD.stderr_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stderr_entry() //  [R1]
         { info_tbl: [(cbg2v,
                       label: GHC.IO.Handle.FD.stderr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg2v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbg2w; else goto cbg2x;
       cbg2w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg2x: // global
           (_cbg2q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg2q::I64 == 0) goto cbg2s; else goto cbg2r;
       cbg2s: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg2r: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg2q::I64;
           I64[Sp - 24] = block_cbg2t_info;
           Sp = Sp - 24;
           call lvl9_rbfCF_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbg2t() //  [R1]
         { info_tbl: [(cbg2t,
                       label: block_cbg2t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg2t: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.032875807 UTC

[section ""cstring" . lvl10_rbfCG_bytes" {
     lvl10_rbfCG_bytes:
         I8[] [60,115,116,100,111,117,116,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.03382445 UTC

[section ""data" . lvl11_rbfCH_closure" {
     lvl11_rbfCH_closure:
         const lvl11_rbfCH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rbfCH_entry() //  [R1]
         { info_tbl: [(cbg2F,
                       label: lvl11_rbfCH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg2F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg2G; else goto cbg2H;
       cbg2G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg2H: // global
           (_cbg2C::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg2C::I64 == 0) goto cbg2E; else goto cbg2D;
       cbg2E: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg2D: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg2C::I64;
           R2 = lvl10_rbfCG_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.035009855 UTC

[section ""data" . lvl12_rbfCI_closure" {
     lvl12_rbfCI_closure:
         const lvl12_rbfCI_info;
         const 0;
 },
 section ""relreadonly" . ubg35_srtd" {
     ubg35_srtd:
         const SbfJE_srt+64;
         const 39;
         const 446676603777;
 },
 lvl12_rbfCI_entry() //  []
         { info_tbl: [(cbg2R,
                       label: lvl12_rbfCI_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg2R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbg2S; else goto cbg2T;
       cbg2S: // global
           R1 = lvl12_rbfCI_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbg2T: // global
           I64[Sp - 8] = block_cbg2M_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubg36_srtd" {
     ubg36_srtd:
         const SbfJE_srt+64;
         const 38;
         const 171798696833;
 },
 _cbg2M() //  []
         { info_tbl: [(cbg2M,
                       label: block_cbg2M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg2M: // global
           I64[Sp] = block_cbg2O_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubg34; else goto cbg2P;
       ubg34: // global
           call _cbg2O(R1) args: 0, res: 0, upd: 0;
       cbg2P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubg37_srtd" {
     ubg37_srtd:
         const SbfJE_srt+64;
         const 38;
         const 171798692737;
 },
 _cbg2O() //  [R1]
         { info_tbl: [(cbg2O,
                       label: block_cbg2O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg2O: // global
           I64[Sp] = block_cbg2X_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubg38_srtd" {
     ubg38_srtd:
         const SbfJE_srt+64;
         const 38;
         const 171798692737;
 },
 _cbg2X() //  [R1]
         { info_tbl: [(cbg2X,
                       label: block_cbg2X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg2X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbg32; else goto cbg31;
       cbg32: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg31: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl11_rbfCH_closure;
           R5 = GHC.IO.FD.stdout_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 32] = GHC.Types.True_closure+2;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.036739774 UTC

[section ""data" . GHC.IO.Handle.FD.stdout_closure" {
     GHC.IO.Handle.FD.stdout_closure:
         const GHC.IO.Handle.FD.stdout_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stdout_entry() //  [R1]
         { info_tbl: [(cbg3h,
                       label: GHC.IO.Handle.FD.stdout_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg3h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbg3i; else goto cbg3j;
       cbg3i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg3j: // global
           (_cbg3c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg3c::I64 == 0) goto cbg3e; else goto cbg3d;
       cbg3e: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg3d: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg3c::I64;
           I64[Sp - 24] = block_cbg3f_info;
           Sp = Sp - 24;
           call lvl12_rbfCI_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbg3f() //  [R1]
         { info_tbl: [(cbg3f,
                       label: block_cbg3f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg3f: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.037804976 UTC

[section ""cstring" . lvl13_rbfCJ_bytes" {
     lvl13_rbfCJ_bytes:
         I8[] [60,115,116,100,105,110,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.038474353 UTC

[section ""data" . lvl14_rbfCK_closure" {
     lvl14_rbfCK_closure:
         const lvl14_rbfCK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_rbfCK_entry() //  [R1]
         { info_tbl: [(cbg3r,
                       label: lvl14_rbfCK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg3r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg3s; else goto cbg3t;
       cbg3s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg3t: // global
           (_cbg3o::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg3o::I64 == 0) goto cbg3q; else goto cbg3p;
       cbg3q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg3p: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg3o::I64;
           R2 = lvl13_rbfCJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.039684711 UTC

[section ""data" . lvl15_rbfCL_closure" {
     lvl15_rbfCL_closure:
         const lvl15_rbfCL_info;
         const 0;
 },
 section ""relreadonly" . ubg3R_srtd" {
     ubg3R_srtd:
         const SbfJE_srt+64;
         const 41;
         const 1683627185025;
 },
 lvl15_rbfCL_entry() //  []
         { info_tbl: [(cbg3D,
                       label: lvl15_rbfCL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg3D: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbg3E; else goto cbg3F;
       cbg3E: // global
           R1 = lvl15_rbfCL_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbg3F: // global
           I64[Sp - 8] = block_cbg3y_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubg3S_srtd" {
     ubg3S_srtd:
         const SbfJE_srt+64;
         const 40;
         const 584115557249;
 },
 _cbg3y() //  []
         { info_tbl: [(cbg3y,
                       label: block_cbg3y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg3y: // global
           I64[Sp] = block_cbg3A_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubg3Q; else goto cbg3B;
       ubg3Q: // global
           call _cbg3A(R1) args: 0, res: 0, upd: 0;
       cbg3B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubg3T_srtd" {
     ubg3T_srtd:
         const SbfJE_srt+64;
         const 40;
         const 584115553153;
 },
 _cbg3A() //  [R1]
         { info_tbl: [(cbg3A,
                       label: block_cbg3A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg3A: // global
           I64[Sp] = block_cbg3J_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubg3U_srtd" {
     ubg3U_srtd:
         const SbfJE_srt+64;
         const 40;
         const 584115553153;
 },
 _cbg3J() //  [R1]
         { info_tbl: [(cbg3J,
                       label: block_cbg3J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg3J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbg3O; else goto cbg3N;
       cbg3O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg3N: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl14_rbfCK_closure;
           R5 = GHC.IO.FD.stdin_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 32] = GHC.Types.True_closure+2;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.041442921 UTC

[section ""data" . GHC.IO.Handle.FD.stdin_closure" {
     GHC.IO.Handle.FD.stdin_closure:
         const GHC.IO.Handle.FD.stdin_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stdin_entry() //  [R1]
         { info_tbl: [(cbg43,
                       label: GHC.IO.Handle.FD.stdin_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg43: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbg44; else goto cbg45;
       cbg44: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg45: // global
           (_cbg3Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg3Y::I64 == 0) goto cbg40; else goto cbg3Z;
       cbg40: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg3Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg3Y::I64;
           I64[Sp - 24] = block_cbg41_info;
           Sp = Sp - 24;
           call lvl15_rbfCL_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbg41() //  [R1]
         { info_tbl: [(cbg41,
                       label: block_cbg41_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg41: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.042404518 UTC

[section ""relreadonly" . SbfJE_srt" {
     SbfJE_srt:
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl1_rbfCv_closure;
         const lvl3_rbfCx_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const lvl5_rbfCz_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd1_closure;
         const GHC.IO.Handle.FD.fdToHandle7_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const System.Posix.Internals.setNonBlockingFD3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.IO.FD.$fBufferedIOFD_closure;
         const GHC.IO.FD.$fIODeviceFD_closure;
         const GHC.IO.Handle.FD.fdToHandle5_closure;
         const GHC.IO.Handle.FD.fdToHandle6_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.Handle.FD.fdToHandle'1_closure;
         const GHC.IO.Handle.FD.fdToHandle2_closure;
         const System.Posix.Internals.$wfdGetMode_closure;
         const GHC.IO.Handle.FD.$wfdToHandle_closure;
         const GHC.IO.Handle.FD.fdToHandle1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.Handle.FD.openBinaryFile5_closure;
         const GHC.IO.Handle.FD.fdToHandle10_closure;
         const GHC.IO.Handle.FD.openFile2_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.FD.openFile1_closure;
         const GHC.IO.Handle.FD.openFileBlocking1_closure;
         const GHC.IO.Handle.FD.openBinaryFile3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.FD.openBinaryFile2_closure;
         const GHC.IO.Handle.FD.openBinaryFile1_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const $wstdHandleFinalizer_rbfCA_closure;
         const stdHandleFinalizer_rbfCB_closure;
         const lvl7_rbfCD_closure;
         const lvl8_rbfCE_closure;
         const lvl9_rbfCF_closure;
         const lvl11_rbfCH_closure;
         const lvl12_rbfCI_closure;
         const lvl14_rbfCK_closure;
         const lvl15_rbfCL_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.043226914 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:12.044160407 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle12_closure" {
     GHC.IO.Handle.FD.fdToHandle12_closure:
         const GHC.IO.Handle.FD.fdToHandle12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle12_entry() //  [R1]
         { info_tbl: [(cbg4i,
                       label: GHC.IO.Handle.FD.fdToHandle12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg4i: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbg4j; else goto cbg4k;
       cbg4j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg4k: // global
           (_cbg4a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg4a::I64 == 0) goto cbg4c; else goto cbg4b;
       cbg4c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg4b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg4a::I64;
           I64[Sp - 24] = block_cbg4d_info;
           R6 = 0;
           R5 = GHC.IO.FD.$tcFD1_closure;
           R4 = GHC.IO.FD.$trModule_closure;
           R3 = 15546290101957756376;
           R2 = 10838815552519039062;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbg4d() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbg4d,
                       label: block_cbg4d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg4d: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbg4e() args: 0, res: 0, upd: 0;
     }
 },
 _cbg4e() //  []
         { info_tbl: [(cbg4e,
                       label: block_cbg4e_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg4e: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbg4n; else goto cbg4m;
       cbg4n: // global
           HpAlloc = 48;
           I64[Sp] = block_cbg4e_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbg4m: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.045770236 UTC

[section ""cstring" . GHC.IO.Handle.FD.$trModule4_bytes" {
     GHC.IO.Handle.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.046318535 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule3_closure" {
     GHC.IO.Handle.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.FD.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.04685753 UTC

[section ""cstring" . GHC.IO.Handle.FD.$trModule2_bytes" {
     GHC.IO.Handle.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.047394407 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule1_closure" {
     GHC.IO.Handle.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.FD.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.047922529 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule_closure" {
     GHC.IO.Handle.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.FD.$trModule3_closure+1;
         const GHC.IO.Handle.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.048507381 UTC

[section ""cstring" . lvl_rbfCu_bytes" {
     lvl_rbfCu_bytes:
         I8[] [104,97,110,100,108,101,84,111,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.04921882 UTC

[section ""data" . lvl1_rbfCv_closure" {
     lvl1_rbfCv_closure:
         const lvl1_rbfCv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbfCv_entry() //  [R1]
         { info_tbl: [(cbg4w,
                       label: lvl1_rbfCv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg4w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg4x; else goto cbg4y;
       cbg4x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg4y: // global
           (_cbg4t::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg4t::I64 == 0) goto cbg4v; else goto cbg4u;
       cbg4v: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg4u: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg4t::I64;
           R2 = lvl_rbfCu_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.05008373 UTC

[section ""cstring" . lvl2_rbfCw_bytes" {
     lvl2_rbfCw_bytes:
         I8[] [110,111,116,32,97,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.050785245 UTC

[section ""data" . lvl3_rbfCx_closure" {
     lvl3_rbfCx_closure:
         const lvl3_rbfCx_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbfCx_entry() //  [R1]
         { info_tbl: [(cbg4F,
                       label: lvl3_rbfCx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg4F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg4G; else goto cbg4H;
       cbg4G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg4H: // global
           (_cbg4C::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg4C::I64 == 0) goto cbg4E; else goto cbg4D;
       cbg4E: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg4D: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg4C::I64;
           R2 = lvl2_rbfCw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.051992217 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd3_closure" {
     GHC.IO.Handle.FD.handleToFd3_closure:
         const GHC.IO.Handle.FD.handleToFd3_info;
         const 0;
 },
 sat_sbfCX_entry() //  [R1]
         { info_tbl: [(cbg4S,
                       label: sat_sbfCX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg4S: // global
           _sbfCX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbg4T; else goto cbg4U;
       cbg4U: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbg4W; else goto cbg4V;
       cbg4W: // global
           HpAlloc = 72;
           goto cbg4T;
       cbg4T: // global
           R1 = _sbfCX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg4V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfCX::P64;
           _sbfCT::P64 = P64[_sbfCX::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfCT::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InappropriateType_closure+1;
           P64[Hp - 24] = lvl1_rbfCv_closure;
           P64[Hp - 16] = lvl3_rbfCx_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.handleToFd3_entry() //  [R2]
         { info_tbl: [(cbg4X,
                       label: GHC.IO.Handle.FD.handleToFd3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg4X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg51; else goto cbg50;
       cbg51: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbg50: // global
           I64[Hp - 16] = sat_sbfCX_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.053261232 UTC

[section ""cstring" . lvl4_rbfCy_bytes" {
     lvl4_rbfCy_bytes:
         I8[] [110,111,116,32,97,32,102,105,108,101,32,104,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.053968895 UTC

[section ""data" . lvl5_rbfCz_closure" {
     lvl5_rbfCz_closure:
         const lvl5_rbfCz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rbfCz_entry() //  [R1]
         { info_tbl: [(cbg58,
                       label: lvl5_rbfCz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg58: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg59; else goto cbg5a;
       cbg59: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg5a: // global
           (_cbg55::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg55::I64 == 0) goto cbg57; else goto cbg56;
       cbg57: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg56: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg55::I64;
           R2 = lvl4_rbfCy_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.055155369 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd2_closure" {
     GHC.IO.Handle.FD.handleToFd2_closure:
         const GHC.IO.Handle.FD.handleToFd2_info;
         const 0;
 },
 sat_sbfD2_entry() //  [R1]
         { info_tbl: [(cbg5l,
                       label: sat_sbfD2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg5l: // global
           _sbfD2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbg5m; else goto cbg5n;
       cbg5n: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbg5p; else goto cbg5o;
       cbg5p: // global
           HpAlloc = 72;
           goto cbg5m;
       cbg5m: // global
           R1 = _sbfD2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg5o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfD2::P64;
           _sbfCY::P64 = P64[_sbfD2::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfCY::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InappropriateType_closure+1;
           P64[Hp - 24] = lvl1_rbfCv_closure;
           P64[Hp - 16] = lvl5_rbfCz_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.handleToFd2_entry() //  [R2]
         { info_tbl: [(cbg5q,
                       label: GHC.IO.Handle.FD.handleToFd2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg5q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg5u; else goto cbg5t;
       cbg5u: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbg5t: // global
           I64[Hp - 16] = sat_sbfD2_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.056890873 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd1_closure" {
     GHC.IO.Handle.FD.handleToFd1_closure:
         const GHC.IO.Handle.FD.handleToFd1_info;
         const 0;
 },
 GHC.IO.Handle.FD.handleToFd1_entry() //  [R2]
         { info_tbl: [(cbg5G,
                       label: GHC.IO.Handle.FD.handleToFd1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg5G: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbg5H; else goto cbg5I;
       cbg5H: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbg5I: // global
           I64[Sp - 8] = block_cbg5z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubg6a; else goto cbg5A;
       ubg6a: // global
           call _cbg5z(R1) args: 0, res: 0, upd: 0;
       cbg5A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg5z() //  [R1]
         { info_tbl: [(cbg5z,
                       label: block_cbg5z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg5z: // global
           if (R1 & 7 == 1) goto cbg5D; else goto cbg5E;
       cbg5D: // global
           I64[Sp - 8] = block_cbg5L_info;
           _sbfD5::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbfD5::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbg5E: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbg5L() //  [R1]
         { info_tbl: [(cbg5L,
                       label: block_cbg5L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg5L: // global
           I64[Sp] = block_cbg5N_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubg6b; else goto cbg5Q;
       ubg6b: // global
           call _cbg5N(R1) args: 0, res: 0, upd: 0;
       cbg5Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg5N() //  [R1]
         { info_tbl: [(cbg5N,
                       label: block_cbg5N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg5N: // global
           I64[Sp - 8] = block_cbg5U_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[R1 + 23];
           P64[Sp] = P64[R1 + 31];
           Sp = Sp - 8;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbg5U() //  [R1]
         { info_tbl: [(cbg5U,
                       label: block_cbg5U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg5U: // global
           if (R1 & 7 == 1) goto cbg61; else goto cbg65;
       cbg61: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbg65: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.058892731 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd_closure" {
     GHC.IO.Handle.FD.handleToFd_closure:
         const GHC.IO.Handle.FD.handleToFd_info;
         const 0;
 },
 GHC.IO.Handle.FD.handleToFd_entry() //  [R2]
         { info_tbl: [(cbg6g,
                       label: GHC.IO.Handle.FD.handleToFd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg6g: // global
           R2 = R2;
           call GHC.IO.Handle.FD.handleToFd1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.059587297 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle11_bytes" {
     GHC.IO.Handle.FD.fdToHandle11_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.062366103 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle10_closure" {
     GHC.IO.Handle.FD.fdToHandle10_closure:
         const GHC.IO.Handle.FD.fdToHandle10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle10_entry() //  [R1]
         { info_tbl: [(cbg6p,
                       label: GHC.IO.Handle.FD.fdToHandle10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg6p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg6q; else goto cbg6r;
       cbg6q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg6r: // global
           (_cbg6m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg6m::I64 == 0) goto cbg6o; else goto cbg6n;
       cbg6o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg6n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg6m::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.063228246 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle9_bytes" {
     GHC.IO.Handle.FD.fdToHandle9_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.063912446 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle8_closure" {
     GHC.IO.Handle.FD.fdToHandle8_closure:
         const GHC.IO.Handle.FD.fdToHandle8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle8_entry() //  [R1]
         { info_tbl: [(cbg6y,
                       label: GHC.IO.Handle.FD.fdToHandle8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg6y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg6z; else goto cbg6A;
       cbg6z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg6A: // global
           (_cbg6v::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg6v::I64 == 0) goto cbg6x; else goto cbg6w;
       cbg6x: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg6w: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg6v::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.064784205 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle7_closure" {
     GHC.IO.Handle.FD.fdToHandle7_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Handle.FD.fdToHandle10_closure;
         const GHC.IO.Handle.FD.fdToHandle8_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.06557116 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle6_closure" {
     GHC.IO.Handle.FD.fdToHandle6_closure:
         const GHC.IO.Handle.FD.fdToHandle6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle6_entry() //  [R1]
         { info_tbl: [(cbg6H,
                       label: GHC.IO.Handle.FD.fdToHandle6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg6H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg6I; else goto cbg6J;
       cbg6I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg6J: // global
           (_cbg6E::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbg6E::I64 == 0) goto cbg6G; else goto cbg6F;
       cbg6G: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbg6F: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbg6E::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle7_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.068603984 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle5_closure" {
     GHC.IO.Handle.FD.fdToHandle5_closure:
         const GHC.IO.Handle.FD.fdToHandle5_info;
         const 0;
 },
 nl_sbfDG_entry() //  [R1]
         { info_tbl: [(cbg70,
                       label: nl_sbfDG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg70: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbg71; else goto cbg72;
       cbg71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg72: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbg6X_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubg76; else goto cbg6Y;
       ubg76: // global
           call _cbg6X() args: 0, res: 0, upd: 0;
       cbg6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbg6X() //  []
         { info_tbl: [(cbg6X,
                       label: block_cbg6X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg6X: // global
           R1 = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfDL_entry() //  [R1]
         { info_tbl: [(cbg7p,
                       label: sat_sbfDL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg7p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbg7q; else goto cbg7r;
       cbg7q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbg7r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbg7g_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubg7G; else goto cbg7h;
       ubg7G: // global
           call _cbg7g(R1) args: 0, res: 0, upd: 0;
       cbg7h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbg7g() //  [R1]
         { info_tbl: [(cbg7g,
                       label: block_cbg7g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg7g: // global
           _cbg7o::P64 = R1 & 7;
           if (_cbg7o::P64 < 3) goto ubg7E; else goto ubg7F;
       ubg7E: // global
           if (_cbg7o::P64 < 2) goto cbg7k; else goto cbg7l;
       cbg7k: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbg7l: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ubg7F: // global
           if (_cbg7o::P64 < 4) goto cbg7m; else goto cbg7n;
       cbg7m: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbg7n: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfE4_entry() //  [R1]
         { info_tbl: [(cbg80,
                       label: sat_sbfE4_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg80: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbg8c; else goto cbg8b;
       cbg8c: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbg8b: // global
           (_sbfE1::I64) = call "capi" arg hints:  [‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC17ZCbaseZCSystemziPosixziInternalsZCfcntl(I64[R1 + 7], %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbfE1::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.fdToHandle5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbg8h,
                       label: GHC.IO.Handle.FD.fdToHandle5_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg8h: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbg8i; else goto cbg8j;
       cbg8i: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbg8j: // global
           I64[Sp - 40] = block_cbg7H_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubg9R; else goto cbg7I;
       ubg9R: // global
           call _cbg7H(R1) args: 0, res: 0, upd: 0;
       cbg7I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg7H() //  [R1]
         { info_tbl: [(cbg7H,
                       label: block_cbg7H_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg7H: // global
           _sbfDw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbg8e; else goto cbg8f;
       cbg8e: // global
           P64[Sp + 8] = _sbfDw::P64;
           Sp = Sp + 8;
           call _cbg6R() args: 0, res: 0, upd: 0;
       cbg8f: // global
           I64[Sp + 8] = block_cbg7N_info;
           R1 = _sbfDw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubg9P; else goto cbg7O;
       ubg9P: // global
           call _cbg7N(R1) args: 0, res: 0, upd: 0;
       cbg7O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg7N() //  [R1]
         { info_tbl: [(cbg7N,
                       label: block_cbg7N_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg7N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg90; else goto cbg8Z;
       cbg90: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg8Z: // global
           _sbfDQ::I64 = I64[R1 + 7];
           (_sbfDV::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_f_getfl();
           I64[Hp - 16] = sat_sbfE4_info;
           I64[Hp - 8] = _sbfDQ::I64;
           I64[Hp] = _sbfDV::I64;
           I64[Sp - 8] = block_cbg8U_info;
           R4 = Hp - 15;
           R3 = System.Posix.Internals.setNonBlockingFD3_closure;
           R2 = System.Posix.Internals.fdFileSize_pred_closure+1;
           I64[Sp] = _sbfDQ::I64;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbg8U() //  [R1]
         { info_tbl: [(cbg8U,
                       label: block_cbg8U_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg8U: // global
           I64[Sp] = block_cbg8W_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubg9V; else goto cbg92;
       ubg9V: // global
           call _cbg8W(R1) args: 0, res: 0, upd: 0;
       cbg92: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg8W() //  [R1]
         { info_tbl: [(cbg8W,
                       label: block_cbg8W_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg8W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg98; else goto cbg97;
       cbg98: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg97: // global
           _sbfDQ::I64 = I64[Sp + 8];
           _sbfE9::I64 = I64[R1 + 7];
           (_sbfEd::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           _sbfEe::I64 = _sbfE9::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbfEd::I64));
           if (_sbfE9::I64 == _sbfEe::I64) goto cbg9s; else goto cbg9t;
       cbg9s: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sbfDQ::I64;
           I64[Hp] = 1;
           P64[Sp + 8] = Hp - 15;
           Sp = Sp + 8;
           goto ubg9X;
       cbg9t: // global
           (_sbfEo::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_f_setfl();
           (_sbfEt::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC16ZCbaseZCSystemziPosixziInternalsZCfcntl(_sbfDQ::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbfEo::I64)), _sbfEe::I64);
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sbfDQ::I64;
           I64[Hp] = 1;
           P64[Sp + 8] = Hp - 15;
           Sp = Sp + 8;
           goto ubg9X;
       ubg9X: // global
           call _cbg6R() args: 0, res: 0, upd: 0;
     }
 },
 _cbg6R() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg6R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg8n; else goto cbg8m;
       cbg8n: // global
           HpAlloc = 24;
           _sbfDF::P64 = P64[Sp];
           I64[Sp] = block_cbg6Q_info;
           R1 = _sbfDF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbg8m: // global
           I64[Hp - 16] = nl_sbfDG_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp - 8] = block_cbg8k_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubg9O; else goto cbg8r;
       ubg9O: // global
           call _cbg8k(R1) args: 0, res: 0, upd: 0;
       cbg8r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg6Q() //  [R1]
         { info_tbl: [(cbg6Q,
                       label: block_cbg6Q_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg6Q: // global
           P64[Sp] = R1;
           call _cbg6R() args: 0, res: 0, upd: 0;
     }
 },
 _cbg8k() //  [R1]
         { info_tbl: [(cbg8k,
                       label: block_cbg8k_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg8k: // global
           _cbg9G::P64 = R1 & 7;
           if (_cbg9G::P64 != 1) goto ubg9I; else goto cbg8B;
       ubg9I: // global
           if (_cbg9G::P64 != 2) goto ubg9T; else goto cbg8G;
       ubg9T: // global
           call _cbg7a() args: 0, res: 0, upd: 0;
       cbg8G: // global
           I64[Sp] = block_cbg8E_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto ubg9S; else goto cbg8H;
       ubg9S: // global
           call _cbg8E(R1) args: 0, res: 0, upd: 0;
       cbg8H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbg8B: // global
           R1 = GHC.IO.Handle.FD.fdToHandle6_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbg8E() //  [R1]
         { info_tbl: [(cbg8E,
                       label: block_cbg8E_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg8E: // global
           if (R1 & 7 == 4) goto cbg8R; else goto ubg9U;
       cbg8R: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp + 32] = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
       ubg9U: // global
           call _cbg7a() args: 0, res: 0, upd: 0;
     }
 },
 _cbg7a() //  []
         { info_tbl: [(cbg7a,
                       label: block_cbg7a_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg7a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbg8q; else goto cbg8p;
       cbg8q: // global
           HpAlloc = 24;
           I64[Sp] = block_cbg7a_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbg8p: // global
           I64[Hp - 16] = sat_sbfDL_info;
           P64[Hp] = P64[Sp + 32];
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = GHC.Types.True_closure+2;
           _cbg6T::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = _cbg6T::P64;
           P64[Sp + 32] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
           P64[Sp + 40] = GHC.Base.Nothing_closure+1;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.073911635 UTC

[section ""data" . GHC.IO.Handle.FD.mkHandleFromFD_closure" {
     GHC.IO.Handle.FD.mkHandleFromFD_closure:
         const GHC.IO.Handle.FD.mkHandleFromFD_info;
         const 0;
 },
 GHC.IO.Handle.FD.mkHandleFromFD_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbga2,
                       label: GHC.IO.Handle.FD.mkHandleFromFD_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbga2: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.074687011 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'2_closure" {
     GHC.IO.Handle.FD.fdToHandle'2_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.07655043 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'1_closure" {
     GHC.IO.Handle.FD.fdToHandle'1_closure:
         const GHC.IO.Handle.FD.fdToHandle'1_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle'1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbgai,
                       label: GHC.IO.Handle.FD.fdToHandle'1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgai: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbgaj; else goto cbgak;
       cbgaj: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbgak: // global
           I64[Sp - 40] = block_cbgab_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubgbG; else goto cbgac;
       ubgbG: // global
           call _cbgab(R1) args: 0, res: 0, upd: 0;
       cbgac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgab() //  [R1]
         { info_tbl: [(cbgab,
                       label: block_cbgab_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgab: // global
           if (R1 & 7 == 1) goto cbgaf; else goto cbgag;
       cbgaf: // global
           _sbfEv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbgaP_info;
           R5 = P64[Sp + 16];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[Sp + 32];
           R2 = _sbfEv::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       cbgag: // global
           I64[Sp] = block_cbgb1_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubgbF; else goto cbgb3;
       ubgbF: // global
           call _cbgb1(R1) args: 0, res: 0, upd: 0;
       cbgb3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgaP() //  [R1]
         { info_tbl: [(cbgaP,
                       label: block_cbgaP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgaP: // global
           I64[Sp] = block_cbgaR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgbI; else goto cbgaU;
       ubgbI: // global
           call _cbgaR(R1) args: 0, res: 0, upd: 0;
       cbgaU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgaR() //  [R1]
         { info_tbl: [(cbgaR,
                       label: block_cbgaR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgaR: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _sbfEC() args: 0, res: 0, upd: 0;
     }
 },
 _cbgb1() //  [R1]
         { info_tbl: [(cbgb1,
                       label: block_cbgb1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgb1: // global
           _sbfEv::P64 = P64[Sp + 8];
           _sbfEx::P64 = P64[Sp + 16];
           _sbfEz::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto cbgbt; else goto cbgbd;
       cbgbt: // global
           I64[Sp + 8] = block_cbgbp_info;
           R5 = _sbfEx::P64;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = _sbfEz::P64;
           R2 = _sbfEv::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       cbgbd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbgbg; else goto cbgbf;
       cbgbg: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgbf: // global
           I64[Hp - 40] = (,,)_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = GHC.IO.Handle.FD.fdToHandle'2_closure+1;
           P64[Hp - 16] = GHC.IO.Handle.FD.fdToHandle'2_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           I64[Sp + 8] = block_cbgb9_info;
           R5 = _sbfEx::P64;
           R4 = Hp - 6;
           R3 = _sbfEz::P64;
           R2 = _sbfEv::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgbp() //  [R1]
         { info_tbl: [(cbgbp,
                       label: block_cbgbp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgbp: // global
           I64[Sp] = block_cbgbr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgbM; else goto cbgbv;
       ubgbM: // global
           call _cbgbr(R1) args: 0, res: 0, upd: 0;
       cbgbv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgbr() //  [R1]
         { info_tbl: [(cbgbr,
                       label: block_cbgbr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgbr: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _sbfEC() args: 0, res: 0, upd: 0;
     }
 },
 _cbgb9() //  [R1]
         { info_tbl: [(cbgb9,
                       label: block_cbgb9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgb9: // global
           I64[Sp] = block_cbgbb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgbK; else goto cbgbi;
       ubgbK: // global
           call _cbgbb(R1) args: 0, res: 0, upd: 0;
       cbgbi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgbb() //  [R1]
         { info_tbl: [(cbgbb,
                       label: block_cbgbb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgbb: // global
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call _sbfEC() args: 0, res: 0, upd: 0;
     }
 },
 _sbfEC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbfEC: // global
           I64[Sp - 8] = block_cbgao_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubgbO; else goto cbgaq;
       ubgbO: // global
           call _cbgao(R1) args: 0, res: 0, upd: 0;
       cbgaq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgao() //  [R1]
         { info_tbl: [(cbgao,
                       label: block_cbgao_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgao: // global
           if (R1 & 7 == 1) goto cbgaE; else goto cbgaM;
       cbgaE: // global
           I64[Sp] = block_cbgau_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgbH; else goto cbgav;
       ubgbH: // global
           call _cbgau(R1) args: 0, res: 0, upd: 0;
       cbgav: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbgaM: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 _cbgau() //  [R1]
         { info_tbl: [(cbgau,
                       label: block_cbgau_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgau: // global
           I64[Sp] = block_cbgaz_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgaz() //  [R1]
         { info_tbl: [(cbgaz,
                       label: block_cbgaz_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgaz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgaI; else goto cbgaH;
       cbgaI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgaH: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 48] = Hp - 6;
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.08014908 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'_closure" {
     GHC.IO.Handle.FD.fdToHandle'_closure:
         const GHC.IO.Handle.FD.fdToHandle'_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbgbT,
                       label: GHC.IO.Handle.FD.fdToHandle'_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgbT: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle'1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.080890315 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle4_bytes" {
     GHC.IO.Handle.FD.fdToHandle4_bytes:
         I8[] [60,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.081662669 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle3_bytes" {
     GHC.IO.Handle.FD.fdToHandle3_bytes:
         I8[] [62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.082374965 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle2_closure" {
     GHC.IO.Handle.FD.fdToHandle2_closure:
         const GHC.IO.Handle.FD.fdToHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle2_entry() //  [R1]
         { info_tbl: [(cbgc2,
                       label: GHC.IO.Handle.FD.fdToHandle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgc2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgc3; else goto cbgc4;
       cbgc3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgc4: // global
           (_cbgbZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgbZ::I64 == 0) goto cbgc1; else goto cbgc0;
       cbgc1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgc0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgbZ::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.084093389 UTC

[section ""data" . GHC.IO.Handle.FD.$wfdToHandle_closure" {
     GHC.IO.Handle.FD.$wfdToHandle_closure:
         const GHC.IO.Handle.FD.$wfdToHandle_info;
         const 0;
 },
 sat_sbfFu_entry() //  [R1]
         { info_tbl: [(cbgcu,
                       label: sat_sbfFu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgcu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgcA; else goto cbgcB;
       cbgcA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgcB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbgcr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubgcG; else goto cbgcs;
       ubgcG: // global
           call _cbgcr(R1) args: 0, res: 0, upd: 0;
       cbgcs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbgcr() //  [R1]
         { info_tbl: [(cbgcr,
                       label: block_cbgcr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgcr: // global
           I64[Sp] = block_cbgcx_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbgcx() //  [R1, R2]
         { info_tbl: [(cbgcx,
                       label: block_cbgcx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgcx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgcF; else goto cbgcE;
       cbgcF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbgcE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.IO.Handle.FD.fdToHandle2_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfFv_entry() //  [R1]
         { info_tbl: [(cbgcH,
                       label: sat_sbfFv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgcH: // global
           _sbfFv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbgcI; else goto cbgcJ;
       cbgcJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgcL; else goto cbgcK;
       cbgcL: // global
           HpAlloc = 24;
           goto cbgcI;
       cbgcI: // global
           R1 = _sbfFv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgcK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfFv::P64;
           _sbfFl::P64 = P64[_sbfFv::P64 + 16];
           I64[Hp - 16] = sat_sbfFu_info;
           P64[Hp] = _sbfFl::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.FD.fdToHandle4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.$wfdToHandle_entry() //  [R2]
         { info_tbl: [(cbgcM,
                       label: GHC.IO.Handle.FD.$wfdToHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgcM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgcN; else goto cbgcO;
       cbgcN: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.$wfdToHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgcO: // global
           I64[Sp - 16] = block_cbgc9_info;
           _sbfFb::I64 = R2;
           R2 = R2;
           I64[Sp - 8] = _sbfFb::I64;
           Sp = Sp - 16;
           call System.Posix.Internals.$wfdGetMode_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgc9() //  [R1]
         { info_tbl: [(cbgc9,
                       label: block_cbgc9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgc9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgcR; else goto cbgcQ;
       cbgcR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgcQ: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp] = block_cbgcc_info;
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = R1;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgcc() //  [R1]
         { info_tbl: [(cbgcc,
                       label: block_cbgcc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgcc: // global
           I64[Sp] = block_cbgce_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgcW; else goto cbgcf;
       ubgcW: // global
           call _cbgce(R1) args: 0, res: 0, upd: 0;
       cbgcf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgce() //  [R1]
         { info_tbl: [(cbgce,
                       label: block_cbgce_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgce: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgcV; else goto cbgcU;
       cbgcV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgcU: // global
           _sbfFl::P64 = P64[R1 + 7];
           _sbfFm::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sbfFv_info;
           P64[Hp] = _sbfFl::P64;
           R6 = GHC.Types.False_closure+1;
           R5 = P64[Sp + 8];
           R4 = Hp - 16;
           R3 = _sbfFm::P64;
           R2 = _sbfFl::P64;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.086837512 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle1_closure" {
     GHC.IO.Handle.FD.fdToHandle1_closure:
         const GHC.IO.Handle.FD.fdToHandle1_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle1_entry() //  [R2]
         { info_tbl: [(cbgd4,
                       label: GHC.IO.Handle.FD.fdToHandle1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgd4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbgd5; else goto cbgd6;
       cbgd5: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgd6: // global
           I64[Sp - 8] = block_cbgd1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubgda; else goto cbgd2;
       ubgda: // global
           call _cbgd1(R1) args: 0, res: 0, upd: 0;
       cbgd2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgd1() //  [R1]
         { info_tbl: [(cbgd1,
                       label: block_cbgd1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgd1: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.$wfdToHandle_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.087897624 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle_closure" {
     GHC.IO.Handle.FD.fdToHandle_closure:
         const GHC.IO.Handle.FD.fdToHandle_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle_entry() //  [R2]
         { info_tbl: [(cbgdf,
                       label: GHC.IO.Handle.FD.fdToHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdf: // global
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.089786505 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile5_closure" {
     GHC.IO.Handle.FD.openBinaryFile5_closure:
         const GHC.IO.Handle.FD.openBinaryFile5_info;
         const 0;
 },
 sat_sbfFX_entry() //  [R1, R2]
         { info_tbl: [(cbgdG,
                       label: sat_sbfFX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgdK; else goto cbgdL;
       cbgdK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgdL: // global
           I64[Sp - 16] = block_cbgdD_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgdP; else goto cbgdE;
       ubgdP: // global
           call _cbgdD(R1) args: 0, res: 0, upd: 0;
       cbgdE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgdD() //  [R1]
         { info_tbl: [(cbgdD,
                       label: block_cbgdD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdD: // global
           I64[Sp] = block_cbgdJ_info;
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgdJ() //  []
         { info_tbl: [(cbgdJ,
                       label: block_cbgdJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfFO_entry() //  [R1]
         { info_tbl: [(cbgdV,
                       label: sat_sbfFO_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbgdW; else goto cbgdX;
       cbgdW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbgdX: // global
           R6 = GHC.Types.False_closure+1;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 39];
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbgdY,
                       label: GHC.IO.Handle.FD.openBinaryFile5_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbgdZ; else goto cbge0;
       cbgdZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbge0: // global
           I64[Sp - 32] = block_cbgdm_info;
           _sbfFC::P64 = R4;
           R4 = R5;
           _sbfFB::P64 = R3;
           R3 = R3;
           _sbfFA::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbfFA::P64;
           P64[Sp - 16] = _sbfFB::P64;
           P64[Sp - 8] = _sbfFC::P64;
           Sp = Sp - 32;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgdm() //  [R1]
         { info_tbl: [(cbgdm,
                       label: block_cbgdm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdm: // global
           I64[Sp] = block_cbgdo_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgey; else goto cbgdp;
       ubgey: // global
           call _cbgdo(R1) args: 0, res: 0, upd: 0;
       cbgdp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgdo() //  [R1]
         { info_tbl: [(cbgdo,
                       label: block_cbgdo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdo: // global
           I64[Sp - 8] = block_cbge2_info;
           _sbfFJ::P64 = P64[R1 + 7];
           _sbfFK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sbfFK::P64;
           P64[Sp + 24] = _sbfFJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubgez; else goto cbge7;
       ubgez: // global
           call _cbge2(R1) args: 0, res: 0, upd: 0;
       cbge7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbge2() //  [R1]
         { info_tbl: [(cbge2,
                       label: block_cbge2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbge2: // global
           if (R1 & 7 == 1) goto cbgee; else goto cbges;
       cbgee: // global
           I64[Sp] = block_cbgeb_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgeB; else goto cbgef;
       ubgeB: // global
           call _cbgeb(R1) args: 0, res: 0, upd: 0;
       cbgef: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbges: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _cbgdw() args: 0, res: 0, upd: 0;
     }
 },
 _cbgeb() //  [R1]
         { info_tbl: [(cbgeb,
                       label: block_cbgeb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgeb: // global
           I64[Sp] = block_cbgej_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgej() //  [R1]
         { info_tbl: [(cbgej,
                       label: block_cbgej_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgej: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgeo; else goto cbgen;
       cbgeo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgen: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 6;
           call _cbgdw() args: 0, res: 0, upd: 0;
     }
 },
 _cbgdw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdw: // global
           Hp = Hp + 64;
           _sbfFN::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cbge6; else goto cbge5;
       cbge6: // global
           HpAlloc = 64;
           I64[Sp] = block_cbgdv_info;
           R1 = _sbfFN::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbge5: // global
           I64[Hp - 56] = sat_sbfFX_info;
           _sbfFJ::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sbfFJ::P64;
           I64[Hp - 40] = sat_sbfFO_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sbfFJ::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sbfFN::P64;
           R2 = Hp - 54;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbgdv() //  [R1]
         { info_tbl: [(cbgdv,
                       label: block_cbgdv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgdv: // global
           P64[Sp] = R1;
           call _cbgdw() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.09343781 UTC

[section ""data" . GHC.IO.Handle.FD.openFile2_closure" {
     GHC.IO.Handle.FD.openFile2_closure:
         const GHC.IO.Handle.FD.openFile2_info;
         const 0;
 },
 sat_sbfGi_entry() //  [R1]
         { info_tbl: [(cbgeT,
                       label: sat_sbfGi_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgeT: // global
           _sbfGi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbgeU; else goto cbgeV;
       cbgeV: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbgeX; else goto cbgeW;
       cbgeX: // global
           HpAlloc = 72;
           goto cbgeU;
       cbgeU: // global
           R1 = _sbfGi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgeW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfGi::P64;
           _sbfG6::P64 = P64[_sbfGi::P64 + 16];
           _sbfGa::P64 = P64[_sbfGi::P64 + 24];
           _sbfGb::P64 = P64[_sbfGi::P64 + 32];
           _sbfGd::P64 = P64[_sbfGi::P64 + 40];
           _sbfGe::P64 = P64[_sbfGi::P64 + 48];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfG6::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = _sbfGa::P64;
           P64[Hp - 32] = _sbfGb::P64;
           P64[Hp - 24] = GHC.IO.Handle.FD.fdToHandle10_closure;
           P64[Hp - 16] = _sbfGd::P64;
           P64[Hp - 8] = _sbfGe::P64;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.openFile2_entry() //  [R2, R3]
         { info_tbl: [(cbgeY,
                       label: GHC.IO.Handle.FD.openFile2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgeY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgeZ; else goto cbgf0;
       cbgeZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFile2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgf0: // global
           I64[Sp - 16] = block_cbgeI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgf4; else goto cbgeJ;
       ubgf4: // global
           call _cbgeI(R1) args: 0, res: 0, upd: 0;
       cbgeJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgeI() //  [R1]
         { info_tbl: [(cbgeI,
                       label: block_cbgeI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgeI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbgf3; else goto cbgf2;
       cbgf3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgf2: // global
           _sbfGa::P64 = P64[R1 + 7];
           _sbfGb::P64 = P64[R1 + 15];
           _sbfGd::P64 = P64[R1 + 31];
           _sbfGe::P64 = P64[R1 + 39];
           I64[Hp - 48] = sat_sbfGi_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbfGa::P64;
           P64[Hp - 16] = _sbfGb::P64;
           P64[Hp - 8] = _sbfGd::P64;
           P64[Hp] = _sbfGe::P64;
           R1 = Hp - 48;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.095872252 UTC

[section ""data" . GHC.IO.Handle.FD.openFile1_closure" {
     GHC.IO.Handle.FD.openFile1_closure:
         const GHC.IO.Handle.FD.openFile1_info;
         const 0;
 },
 sat_sbfGt_entry() //  [R1]
         { info_tbl: [(cbgfw,
                       label: sat_sbfGt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgfw: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGv_entry() //  [R1, R2]
         { info_tbl: [(cbgfz,
                       label: sat_sbfGv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgfz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbgfA; else goto cbgfB;
       cbgfA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgfB: // global
           I64[Sp - 16] = block_cbgfe_info;
           _sbfGj::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbfGj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgfO; else goto cbgff;
       ubgfO: // global
           call _cbgfe(R1) args: 0, res: 0, upd: 0;
       cbgff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgfe() //  [R1]
         { info_tbl: [(cbgfe,
                       label: block_cbgfe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgfe: // global
           I64[Sp - 16] = block_cbgfj_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgfj() //  [R1]
         { info_tbl: [(cbgfj,
                       label: block_cbgfj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgfj: // global
           I64[Sp] = block_cbgfn_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgfn() //  [R1]
         { info_tbl: [(cbgfn,
                       label: block_cbgfn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgfn: // global
           if (R1 & 7 == 1) goto cbgfF; else goto cbgfM;
       cbgfF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgfI; else goto cbgfH;
       cbgfI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgfH: // global
           I64[Hp - 8] = sat_sbfGt_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbgfM: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGm_entry() //  [R1]
         { info_tbl: [(cbgfU,
                       label: sat_sbfGm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgfU: // global
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Types.False_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openFile1_entry() //  [R2, R3]
         { info_tbl: [(cbgfX,
                       label: GHC.IO.Handle.FD.openFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgfX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbgg1; else goto cbgg0;
       cbgg1: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgg0: // global
           I64[Hp - 32] = sat_sbfGv_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbfGm_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.098052195 UTC

[section ""data" . GHC.IO.Handle.FD.openFile_closure" {
     GHC.IO.Handle.FD.openFile_closure:
         const GHC.IO.Handle.FD.openFile_info;
         const 0;
 },
 GHC.IO.Handle.FD.openFile_entry() //  [R2, R3]
         { info_tbl: [(cbgg6,
                       label: GHC.IO.Handle.FD.openFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgg6: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.099565056 UTC

[section ""data" . GHC.IO.Handle.FD.openFileBlocking1_closure" {
     GHC.IO.Handle.FD.openFileBlocking1_closure:
         const GHC.IO.Handle.FD.openFileBlocking1_info;
         const 0;
 },
 sat_sbfGG_entry() //  [R1]
         { info_tbl: [(cbggA,
                       label: sat_sbfGG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbggA: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGI_entry() //  [R1, R2]
         { info_tbl: [(cbggD,
                       label: sat_sbfGI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbggD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbggE; else goto cbggF;
       cbggE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbggF: // global
           I64[Sp - 16] = block_cbggi_info;
           _sbfGw::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbfGw::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubggS; else goto cbggj;
       ubggS: // global
           call _cbggi(R1) args: 0, res: 0, upd: 0;
       cbggj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbggi() //  [R1]
         { info_tbl: [(cbggi,
                       label: block_cbggi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbggi: // global
           I64[Sp - 16] = block_cbggn_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbggn() //  [R1]
         { info_tbl: [(cbggn,
                       label: block_cbggn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbggn: // global
           I64[Sp] = block_cbggr_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbggr() //  [R1]
         { info_tbl: [(cbggr,
                       label: block_cbggr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbggr: // global
           if (R1 & 7 == 1) goto cbggJ; else goto cbggQ;
       cbggJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbggM; else goto cbggL;
       cbggM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbggL: // global
           I64[Hp - 8] = sat_sbfGG_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbggQ: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGz_entry() //  [R1]
         { info_tbl: [(cbggY,
                       label: sat_sbfGz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbggY: // global
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Types.False_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openFileBlocking1_entry() //  [R2, R3]
         { info_tbl: [(cbgh1,
                       label: GHC.IO.Handle.FD.openFileBlocking1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgh1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbgh5; else goto cbgh4;
       cbgh5: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFileBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgh4: // global
           I64[Hp - 32] = sat_sbfGI_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbfGz_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.101706295 UTC

[section ""data" . GHC.IO.Handle.FD.openFileBlocking_closure" {
     GHC.IO.Handle.FD.openFileBlocking_closure:
         const GHC.IO.Handle.FD.openFileBlocking_info;
         const 0;
 },
 GHC.IO.Handle.FD.openFileBlocking_entry() //  [R2, R3]
         { info_tbl: [(cbgha,
                       label: GHC.IO.Handle.FD.openFileBlocking_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgha: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openFileBlocking1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.102412585 UTC

[section ""cstring" . GHC.IO.Handle.FD.openBinaryFile4_bytes" {
     GHC.IO.Handle.FD.openBinaryFile4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.103117648 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile3_closure" {
     GHC.IO.Handle.FD.openBinaryFile3_closure:
         const GHC.IO.Handle.FD.openBinaryFile3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.openBinaryFile3_entry() //  [R1]
         { info_tbl: [(cbghj,
                       label: GHC.IO.Handle.FD.openBinaryFile3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbghj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbghk; else goto cbghl;
       cbghk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbghl: // global
           (_cbghg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbghg::I64 == 0) goto cbghi; else goto cbghh;
       cbghi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbghh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbghg::I64;
           R2 = GHC.IO.Handle.FD.openBinaryFile4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.104466705 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile2_closure" {
     GHC.IO.Handle.FD.openBinaryFile2_closure:
         const GHC.IO.Handle.FD.openBinaryFile2_info;
         const 0;
 },
 sat_sbfGV_entry() //  [R1]
         { info_tbl: [(cbghB,
                       label: sat_sbfGV_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbghB: // global
           _sbfGV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbghC; else goto cbghD;
       cbghD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbghF; else goto cbghE;
       cbghF: // global
           HpAlloc = 72;
           goto cbghC;
       cbghC: // global
           R1 = _sbfGV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbghE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfGV::P64;
           _sbfGJ::P64 = P64[_sbfGV::P64 + 16];
           _sbfGN::P64 = P64[_sbfGV::P64 + 24];
           _sbfGO::P64 = P64[_sbfGV::P64 + 32];
           _sbfGQ::P64 = P64[_sbfGV::P64 + 40];
           _sbfGR::P64 = P64[_sbfGV::P64 + 48];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfGJ::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = _sbfGN::P64;
           P64[Hp - 32] = _sbfGO::P64;
           P64[Hp - 24] = GHC.IO.Handle.FD.openBinaryFile3_closure;
           P64[Hp - 16] = _sbfGQ::P64;
           P64[Hp - 8] = _sbfGR::P64;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile2_entry() //  [R2, R3]
         { info_tbl: [(cbghG,
                       label: GHC.IO.Handle.FD.openBinaryFile2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbghG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbghH; else goto cbghI;
       cbghH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbghI: // global
           I64[Sp - 16] = block_cbghq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubghM; else goto cbghr;
       ubghM: // global
           call _cbghq(R1) args: 0, res: 0, upd: 0;
       cbghr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbghq() //  [R1]
         { info_tbl: [(cbghq,
                       label: block_cbghq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbghq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbghL; else goto cbghK;
       cbghL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbghK: // global
           _sbfGN::P64 = P64[R1 + 7];
           _sbfGO::P64 = P64[R1 + 15];
           _sbfGQ::P64 = P64[R1 + 31];
           _sbfGR::P64 = P64[R1 + 39];
           I64[Hp - 48] = sat_sbfGV_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbfGN::P64;
           P64[Hp - 16] = _sbfGO::P64;
           P64[Hp - 8] = _sbfGQ::P64;
           P64[Hp] = _sbfGR::P64;
           R1 = Hp - 48;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.1070828 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile1_closure" {
     GHC.IO.Handle.FD.openBinaryFile1_closure:
         const GHC.IO.Handle.FD.openBinaryFile1_info;
         const 0;
 },
 sat_sbfH6_entry() //  [R1]
         { info_tbl: [(cbgie,
                       label: sat_sbfH6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgie: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfH8_entry() //  [R1, R2]
         { info_tbl: [(cbgih,
                       label: sat_sbfH8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgih: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbgii; else goto cbgij;
       cbgii: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgij: // global
           I64[Sp - 16] = block_cbghW_info;
           _sbfGW::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbfGW::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgiw; else goto cbghX;
       ubgiw: // global
           call _cbghW(R1) args: 0, res: 0, upd: 0;
       cbghX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbghW() //  [R1]
         { info_tbl: [(cbghW,
                       label: block_cbghW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbghW: // global
           I64[Sp - 16] = block_cbgi1_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgi1() //  [R1]
         { info_tbl: [(cbgi1,
                       label: block_cbgi1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgi1: // global
           I64[Sp] = block_cbgi5_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgi5() //  [R1]
         { info_tbl: [(cbgi5,
                       label: block_cbgi5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgi5: // global
           if (R1 & 7 == 1) goto cbgin; else goto cbgiu;
       cbgin: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgiq; else goto cbgip;
       cbgiq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgip: // global
           I64[Hp - 8] = sat_sbfH6_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbgiu: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openBinaryFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGZ_entry() //  [R1]
         { info_tbl: [(cbgiC,
                       label: sat_sbfGZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgiC: // global
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Types.True_closure+2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile1_entry() //  [R2, R3]
         { info_tbl: [(cbgiF,
                       label: GHC.IO.Handle.FD.openBinaryFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgiF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbgiJ; else goto cbgiI;
       cbgiJ: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgiI: // global
           I64[Hp - 32] = sat_sbfH8_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbfGZ_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.109275598 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile_closure" {
     GHC.IO.Handle.FD.openBinaryFile_closure:
         const GHC.IO.Handle.FD.openBinaryFile_info;
         const 0;
 },
 GHC.IO.Handle.FD.openBinaryFile_entry() //  [R2, R3]
         { info_tbl: [(cbgiO,
                       label: GHC.IO.Handle.FD.openBinaryFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgiO: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.112625993 UTC

[section ""data" . $wstdHandleFinalizer_rbfCA_closure" {
     $wstdHandleFinalizer_rbfCA_closure:
         const $wstdHandleFinalizer_rbfCA_info;
         const 0;
 },
 sat_sbfHL_entry() //  [R1]
         { info_tbl: [(cbgjv,
                       label: sat_sbfHL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgjw; else goto cbgjx;
       cbgjw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgjx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfHX_entry() //  [R1]
         { info_tbl: [(cbgjL,
                       label: sat_sbfHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgjM; else goto cbgjN;
       cbgjM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgjN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfIa_entry() //  [R1]
         { info_tbl: [(cbgk6,
                       label: sat_sbfIa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgk6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgk7; else goto cbgk8;
       cbgk7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgk8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfIm_entry() //  [R1]
         { info_tbl: [(cbgkm,
                       label: sat_sbfIm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgkm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgkn; else goto cbgko;
       cbgkn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgko: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfIo_entry() //  [R1]
         { info_tbl: [(cbgkv,
                       label: sat_sbfIo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgkv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgkw; else goto cbgkx;
       cbgkw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgkx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wstdHandleFinalizer_rbfCA_entry() //  [R2, R3]
         { info_tbl: [(cbgky,
                       label: $wstdHandleFinalizer_rbfCA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgky: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbgkz; else goto cbgkA;
       cbgkz: // global
           R3 = R3;
           R2 = R2;
           R1 = $wstdHandleFinalizer_rbfCA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgkA: // global
           I64[Sp - 24] = block_cbgiV_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgiV() //  [R1]
         { info_tbl: [(cbgiV,
                       label: block_cbgiV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgiV: // global
           I64[Sp] = block_cbgiX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgm6; else goto cbgiY;
       ubgm6: // global
           call _cbgiX(R1) args: 0, res: 0, upd: 0;
       cbgiY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgiX() //  [R1]
         { info_tbl: [(cbgiX,
                       label: block_cbgiX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgiX: // global
           I64[Sp - 48] = block_cbgj2_info;
           _sbfHh::P64 = P64[R1 + 15];
           _sbfHj::P64 = P64[R1 + 31];
           _sbfHk::P64 = P64[R1 + 39];
           _sbfHl::P64 = P64[R1 + 47];
           _sbfHq::P64 = P64[R1 + 87];
           _sbfHr::P64 = P64[R1 + 95];
           R1 = P64[_sbfHl::P64 + 8];
           P64[Sp - 40] = _sbfHj::P64;
           P64[Sp - 32] = _sbfHk::P64;
           P64[Sp - 24] = _sbfHl::P64;
           P64[Sp - 16] = _sbfHq::P64;
           P64[Sp - 8] = _sbfHr::P64;
           P64[Sp] = _sbfHh::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ubgm7; else goto cbgj3;
       ubgm7: // global
           call _cbgj2(R1) args: 0, res: 0, upd: 0;
       cbgj3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgj2() //  [R1]
         { info_tbl: [(cbgj2,
                       label: block_cbgj2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgj2: // global
           I64[Sp] = block_cbgkD_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubgm8; else goto cbglv;
       ubgm8: // global
           call _cbgkD(R1) args: 0, res: 0, upd: 0;
       cbglv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgkD() //  [R1]
         { info_tbl: [(cbgkD,
                       label: block_cbgkD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgkD: // global
           if (R1 & 7 == 1) goto ubgm3; else goto cbglG;
       ubgm3: // global
           Sp = Sp + 16;
           call _sbfHG() args: 0, res: 0, upd: 0;
       cbglG: // global
           _sbfIt::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbglE_info;
           R1 = _sbfIt::P64;
           if (R1 & 7 != 0) goto ubgmf; else goto cbglH;
       ubgmf: // global
           call _cbglE(R1) args: 0, res: 0, upd: 0;
       cbglH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbglE() //  [R1]
         { info_tbl: [(cbglE,
                       label: block_cbglE_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbglE: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubgm4; else goto cbglR;
       ubgm4: // global
           Sp = Sp + 16;
           call _sbfHG() args: 0, res: 0, upd: 0;
       cbglR: // global
           _sbfHj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbglP_info;
           R2 = P64[Sp + 48];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sbfHj::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbglP() //  [R1]
         { info_tbl: [(cbglP,
                       label: block_cbglP_info
                       rep:StackRep [False, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbglP: // global
           _sbfHl::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbfHl::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbfHl::P64);
           Sp = Sp + 8;
           call _sbfHG() args: 0, res: 0, upd: 0;
     }
 },
 _sbfHG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbfHG: // global
           I64[Sp + 8] = block_cbgjc_info;
           R1 = P64[Sp];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubgmj; else goto cbgjd;
       ubgmj: // global
           call _cbgjc(R1) args: 0, res: 0, upd: 0;
       cbgjd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgjc() //  [R1]
         { info_tbl: [(cbgjc,
                       label: block_cbgjc_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjc: // global
           if (R1 & 7 == 1) goto cbglp; else goto cbgkI;
       cbglp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgls; else goto cbglr;
       cbgls: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbglr: // global
           I64[Hp - 16] = sat_sbfIo_info;
           P64[Hp] = P64[Sp + 32];
           _sbfHa::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbglo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbgkI: // global
           I64[Sp] = block_cbgjh_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubgm9; else goto cbgji;
       ubgm9: // global
           call _cbgjh(R1) args: 0, res: 0, upd: 0;
       cbgji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgjh() //  [R1]
         { info_tbl: [(cbgjh,
                       label: block_cbgjh_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjh: // global
           if (R1 & 7 == 1) goto cbgkL; else goto cbgl4;
       cbgkL: // global
           I64[Sp + 24] = block_cbgjm_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubgma; else goto cbgjn;
       ubgma: // global
           call _cbgjm(R1) args: 0, res: 0, upd: 0;
       cbgjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbgl4: // global
           I64[Sp] = block_cbgjQ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubgmb; else goto cbgjR;
       ubgmb: // global
           call _cbgjQ(R1) args: 0, res: 0, upd: 0;
       cbgjR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgjm() //  [R1]
         { info_tbl: [(cbgjm,
                       label: block_cbgjm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjm: // global
           if (R1 & 7 == 1) goto cbgkO; else goto cbgkW;
       cbgkO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgkR; else goto cbgkQ;
       cbgkR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgkQ: // global
           I64[Hp - 16] = sat_sbfHL_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbglo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbgkW: // global
           I64[Sp] = block_cbgjA_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubgmc; else goto cbgjB;
       ubgmc: // global
           call _cbgjA(R1) args: 0, res: 0, upd: 0;
       cbgjB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgjA() //  [R1]
         { info_tbl: [(cbgjA,
                       label: block_cbgjA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjA: // global
           I64[Sp] = block_cbgjF_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgjF() //  [R1]
         { info_tbl: [(cbgjF,
                       label: block_cbgjF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgl0; else goto cbgkZ;
       cbgl0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgkZ: // global
           I64[Hp - 16] = sat_sbfHX_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbglo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgjQ() //  [R1]
         { info_tbl: [(cbgjQ,
                       label: block_cbgjQ_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjQ: // global
           I64[Sp] = block_cbgjV_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgjV() //  []
         { info_tbl: [(cbgjV,
                       label: block_cbgjV_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjV: // global
           I64[Sp + 24] = block_cbgjX_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubgmd; else goto cbgjY;
       ubgmd: // global
           call _cbgjX(R1) args: 0, res: 0, upd: 0;
       cbgjY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgjX() //  [R1]
         { info_tbl: [(cbgjX,
                       label: block_cbgjX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgjX: // global
           if (R1 & 7 == 1) goto cbgl9; else goto cbglh;
       cbgl9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbglc; else goto cbglb;
       cbglc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbglb: // global
           I64[Hp - 16] = sat_sbfIa_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbglo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbglh: // global
           I64[Sp] = block_cbgkb_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubgme; else goto cbgkc;
       ubgme: // global
           call _cbgkb(R1) args: 0, res: 0, upd: 0;
       cbgkc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgkb() //  [R1]
         { info_tbl: [(cbgkb,
                       label: block_cbgkb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgkb: // global
           I64[Sp] = block_cbgkg_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgkg() //  [R1]
         { info_tbl: [(cbgkg,
                       label: block_cbgkg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgkg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgll; else goto cbglk;
       cbgll: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbglk: // global
           I64[Hp - 16] = sat_sbfIm_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbglo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbglo() //  []
         { info_tbl: [(cbglo,
                       label: block_cbglo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbglo: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.118965642 UTC

[section ""data" . stdHandleFinalizer_rbfCB_closure" {
     stdHandleFinalizer_rbfCB_closure:
         const stdHandleFinalizer_rbfCB_info;
         const 0;
 },
 stdHandleFinalizer_rbfCB_entry() //  [R2, R3]
         { info_tbl: [(cbgmr,
                       label: stdHandleFinalizer_rbfCB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgmr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgms; else goto cbgmt;
       cbgms: // global
           R3 = R3;
           R2 = R2;
           R1 = stdHandleFinalizer_rbfCB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgmt: // global
           I64[Sp - 16] = block_cbgmo_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgmx; else goto cbgmp;
       ubgmx: // global
           call _cbgmo(R1) args: 0, res: 0, upd: 0;
       cbgmp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgmo() //  [R1]
         { info_tbl: [(cbgmo,
                       label: block_cbgmo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgmo: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wstdHandleFinalizer_rbfCA_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.119964454 UTC

[section ""cstring" . lvl6_rbfCC_bytes" {
     lvl6_rbfCC_bytes:
         I8[] [60,115,116,100,101,114,114,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.120672515 UTC

[section ""data" . lvl7_rbfCD_closure" {
     lvl7_rbfCD_closure:
         const lvl7_rbfCD_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rbfCD_entry() //  [R1]
         { info_tbl: [(cbgmE,
                       label: lvl7_rbfCD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgmE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgmF; else goto cbgmG;
       cbgmF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgmG: // global
           (_cbgmB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgmB::I64 == 0) goto cbgmD; else goto cbgmC;
       cbgmD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgmC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgmB::I64;
           R2 = lvl6_rbfCC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.121581681 UTC

[section ""data" . lvl8_rbfCE_closure" {
     lvl8_rbfCE_closure:
         const GHC.Base.Just_con_info;
         const stdHandleFinalizer_rbfCB_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.122528204 UTC

[section ""data" . lvl9_rbfCF_closure" {
     lvl9_rbfCF_closure:
         const lvl9_rbfCF_info;
         const 0;
 },
 section ""relreadonly" . ubgn4_srtd" {
     ubgn4_srtd:
         const SbfJE_srt+64;
         const 37;
         const 120259089281;
 },
 lvl9_rbfCF_entry() //  []
         { info_tbl: [(cbgmQ,
                       label: lvl9_rbfCF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgmQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbgmR; else goto cbgmS;
       cbgmR: // global
           R1 = lvl9_rbfCF_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbgmS: // global
           I64[Sp - 8] = block_cbgmL_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgn5_srtd" {
     ubgn5_srtd:
         const SbfJE_srt+64;
         const 36;
         const 51539612545;
 },
 _cbgmL() //  []
         { info_tbl: [(cbgmL,
                       label: block_cbgmL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgmL: // global
           I64[Sp] = block_cbgmN_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgn3; else goto cbgmO;
       ubgn3: // global
           call _cbgmN(R1) args: 0, res: 0, upd: 0;
       cbgmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgn6_srtd" {
     ubgn6_srtd:
         const SbfJE_srt+64;
         const 36;
         const 51539608449;
 },
 _cbgmN() //  [R1]
         { info_tbl: [(cbgmN,
                       label: block_cbgmN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgmN: // global
           I64[Sp] = block_cbgmW_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgn7_srtd" {
     ubgn7_srtd:
         const SbfJE_srt+64;
         const 36;
         const 51539608449;
 },
 _cbgmW() //  [R1]
         { info_tbl: [(cbgmW,
                       label: block_cbgmW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgmW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgn1; else goto cbgn0;
       cbgn1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgn0: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl7_rbfCD_closure;
           R5 = GHC.IO.FD.stderr_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 32] = GHC.Types.False_closure+1;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.124302015 UTC

[section ""data" . GHC.IO.Handle.FD.stderr_closure" {
     GHC.IO.Handle.FD.stderr_closure:
         const GHC.IO.Handle.FD.stderr_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stderr_entry() //  [R1]
         { info_tbl: [(cbgng,
                       label: GHC.IO.Handle.FD.stderr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgng: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgnh; else goto cbgni;
       cbgnh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgni: // global
           (_cbgnb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgnb::I64 == 0) goto cbgnd; else goto cbgnc;
       cbgnd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgnc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgnb::I64;
           I64[Sp - 24] = block_cbgne_info;
           Sp = Sp - 24;
           call lvl9_rbfCF_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbgne() //  [R1]
         { info_tbl: [(cbgne,
                       label: block_cbgne_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgne: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.125215428 UTC

[section ""cstring" . lvl10_rbfCG_bytes" {
     lvl10_rbfCG_bytes:
         I8[] [60,115,116,100,111,117,116,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.125964218 UTC

[section ""data" . lvl11_rbfCH_closure" {
     lvl11_rbfCH_closure:
         const lvl11_rbfCH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rbfCH_entry() //  [R1]
         { info_tbl: [(cbgnq,
                       label: lvl11_rbfCH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgnq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgnr; else goto cbgns;
       cbgnr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgns: // global
           (_cbgnn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgnn::I64 == 0) goto cbgnp; else goto cbgno;
       cbgnp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgno: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgnn::I64;
           R2 = lvl10_rbfCG_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.127156176 UTC

[section ""data" . lvl12_rbfCI_closure" {
     lvl12_rbfCI_closure:
         const lvl12_rbfCI_info;
         const 0;
 },
 section ""relreadonly" . ubgnQ_srtd" {
     ubgnQ_srtd:
         const SbfJE_srt+64;
         const 39;
         const 446676603777;
 },
 lvl12_rbfCI_entry() //  []
         { info_tbl: [(cbgnC,
                       label: lvl12_rbfCI_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgnC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbgnD; else goto cbgnE;
       cbgnD: // global
           R1 = lvl12_rbfCI_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbgnE: // global
           I64[Sp - 8] = block_cbgnx_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgnR_srtd" {
     ubgnR_srtd:
         const SbfJE_srt+64;
         const 38;
         const 171798696833;
 },
 _cbgnx() //  []
         { info_tbl: [(cbgnx,
                       label: block_cbgnx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgnx: // global
           I64[Sp] = block_cbgnz_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgnP; else goto cbgnA;
       ubgnP: // global
           call _cbgnz(R1) args: 0, res: 0, upd: 0;
       cbgnA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgnS_srtd" {
     ubgnS_srtd:
         const SbfJE_srt+64;
         const 38;
         const 171798692737;
 },
 _cbgnz() //  [R1]
         { info_tbl: [(cbgnz,
                       label: block_cbgnz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgnz: // global
           I64[Sp] = block_cbgnI_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgnT_srtd" {
     ubgnT_srtd:
         const SbfJE_srt+64;
         const 38;
         const 171798692737;
 },
 _cbgnI() //  [R1]
         { info_tbl: [(cbgnI,
                       label: block_cbgnI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgnI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgnN; else goto cbgnM;
       cbgnN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgnM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl11_rbfCH_closure;
           R5 = GHC.IO.FD.stdout_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 32] = GHC.Types.True_closure+2;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.128888001 UTC

[section ""data" . GHC.IO.Handle.FD.stdout_closure" {
     GHC.IO.Handle.FD.stdout_closure:
         const GHC.IO.Handle.FD.stdout_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stdout_entry() //  [R1]
         { info_tbl: [(cbgo2,
                       label: GHC.IO.Handle.FD.stdout_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgo2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgo3; else goto cbgo4;
       cbgo3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgo4: // global
           (_cbgnX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgnX::I64 == 0) goto cbgnZ; else goto cbgnY;
       cbgnZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgnY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgnX::I64;
           I64[Sp - 24] = block_cbgo0_info;
           Sp = Sp - 24;
           call lvl12_rbfCI_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbgo0() //  [R1]
         { info_tbl: [(cbgo0,
                       label: block_cbgo0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgo0: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.130009846 UTC

[section ""cstring" . lvl13_rbfCJ_bytes" {
     lvl13_rbfCJ_bytes:
         I8[] [60,115,116,100,105,110,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.130712342 UTC

[section ""data" . lvl14_rbfCK_closure" {
     lvl14_rbfCK_closure:
         const lvl14_rbfCK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_rbfCK_entry() //  [R1]
         { info_tbl: [(cbgoc,
                       label: lvl14_rbfCK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgoc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgod; else goto cbgoe;
       cbgod: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgoe: // global
           (_cbgo9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgo9::I64 == 0) goto cbgob; else goto cbgoa;
       cbgob: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgoa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgo9::I64;
           R2 = lvl13_rbfCJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.131924551 UTC

[section ""data" . lvl15_rbfCL_closure" {
     lvl15_rbfCL_closure:
         const lvl15_rbfCL_info;
         const 0;
 },
 section ""relreadonly" . ubgoC_srtd" {
     ubgoC_srtd:
         const SbfJE_srt+64;
         const 41;
         const 1683627185025;
 },
 lvl15_rbfCL_entry() //  []
         { info_tbl: [(cbgoo,
                       label: lvl15_rbfCL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgoo: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbgop; else goto cbgoq;
       cbgop: // global
           R1 = lvl15_rbfCL_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbgoq: // global
           I64[Sp - 8] = block_cbgoj_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgoD_srtd" {
     ubgoD_srtd:
         const SbfJE_srt+64;
         const 40;
         const 584115557249;
 },
 _cbgoj() //  []
         { info_tbl: [(cbgoj,
                       label: block_cbgoj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgoj: // global
           I64[Sp] = block_cbgol_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgoB; else goto cbgom;
       ubgoB: // global
           call _cbgol(R1) args: 0, res: 0, upd: 0;
       cbgom: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgoE_srtd" {
     ubgoE_srtd:
         const SbfJE_srt+64;
         const 40;
         const 584115553153;
 },
 _cbgol() //  [R1]
         { info_tbl: [(cbgol,
                       label: block_cbgol_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgol: // global
           I64[Sp] = block_cbgou_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgoF_srtd" {
     ubgoF_srtd:
         const SbfJE_srt+64;
         const 40;
         const 584115553153;
 },
 _cbgou() //  [R1]
         { info_tbl: [(cbgou,
                       label: block_cbgou_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgou: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgoz; else goto cbgoy;
       cbgoz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgoy: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl14_rbfCK_closure;
           R5 = GHC.IO.FD.stdin_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 32] = GHC.Types.True_closure+2;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.133790933 UTC

[section ""data" . GHC.IO.Handle.FD.stdin_closure" {
     GHC.IO.Handle.FD.stdin_closure:
         const GHC.IO.Handle.FD.stdin_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stdin_entry() //  [R1]
         { info_tbl: [(cbgoO,
                       label: GHC.IO.Handle.FD.stdin_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgoO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgoP; else goto cbgoQ;
       cbgoP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgoQ: // global
           (_cbgoJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgoJ::I64 == 0) goto cbgoL; else goto cbgoK;
       cbgoL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgoK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgoJ::I64;
           I64[Sp - 24] = block_cbgoM_info;
           Sp = Sp - 24;
           call lvl15_rbfCL_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbgoM() //  [R1]
         { info_tbl: [(cbgoM,
                       label: block_cbgoM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgoM: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.134794323 UTC

[section ""relreadonly" . SbfJE_srt" {
     SbfJE_srt:
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl1_rbfCv_closure;
         const lvl3_rbfCx_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const lvl5_rbfCz_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd1_closure;
         const GHC.IO.Handle.FD.fdToHandle7_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const System.Posix.Internals.setNonBlockingFD3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.IO.FD.$fBufferedIOFD_closure;
         const GHC.IO.FD.$fIODeviceFD_closure;
         const GHC.IO.Handle.FD.fdToHandle5_closure;
         const GHC.IO.Handle.FD.fdToHandle6_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.Handle.FD.fdToHandle'1_closure;
         const GHC.IO.Handle.FD.fdToHandle2_closure;
         const System.Posix.Internals.$wfdGetMode_closure;
         const GHC.IO.Handle.FD.$wfdToHandle_closure;
         const GHC.IO.Handle.FD.fdToHandle1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.Handle.FD.openBinaryFile5_closure;
         const GHC.IO.Handle.FD.fdToHandle10_closure;
         const GHC.IO.Handle.FD.openFile2_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.FD.openFile1_closure;
         const GHC.IO.Handle.FD.openFileBlocking1_closure;
         const GHC.IO.Handle.FD.openBinaryFile3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.FD.openBinaryFile2_closure;
         const GHC.IO.Handle.FD.openBinaryFile1_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const $wstdHandleFinalizer_rbfCA_closure;
         const stdHandleFinalizer_rbfCB_closure;
         const lvl7_rbfCD_closure;
         const lvl8_rbfCE_closure;
         const lvl9_rbfCF_closure;
         const lvl11_rbfCH_closure;
         const lvl12_rbfCI_closure;
         const lvl14_rbfCK_closure;
         const lvl15_rbfCL_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.138326037 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:12.139889201 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle12_closure" {
     GHC.IO.Handle.FD.fdToHandle12_closure:
         const GHC.IO.Handle.FD.fdToHandle12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle12_entry() //  [R1]
         { info_tbl: [(cbgp3,
                       label: GHC.IO.Handle.FD.fdToHandle12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgp3: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbgp4; else goto cbgp5;
       cbgp4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgp5: // global
           (_cbgoV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgoV::I64 == 0) goto cbgoX; else goto cbgoW;
       cbgoX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgoW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgoV::I64;
           I64[Sp - 24] = block_cbgoY_info;
           R6 = 0;
           R5 = GHC.IO.FD.$tcFD1_closure;
           R4 = GHC.IO.FD.$trModule_closure;
           R3 = 15546290101957756376;
           R2 = 10838815552519039062;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbgoY() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbgoY,
                       label: block_cbgoY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgoY: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbgoZ() args: 0, res: 0, upd: 0;
     }
 },
 _cbgoZ() //  []
         { info_tbl: [(cbgoZ,
                       label: block_cbgoZ_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgoZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbgp8; else goto cbgp7;
       cbgp8: // global
           HpAlloc = 48;
           I64[Sp] = block_cbgoZ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbgp7: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.147819575 UTC

[section ""cstring" . GHC.IO.Handle.FD.$trModule4_bytes" {
     GHC.IO.Handle.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.149446931 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule3_closure" {
     GHC.IO.Handle.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.FD.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.151064429 UTC

[section ""cstring" . GHC.IO.Handle.FD.$trModule2_bytes" {
     GHC.IO.Handle.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.15269379 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule1_closure" {
     GHC.IO.Handle.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.FD.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.154608319 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule_closure" {
     GHC.IO.Handle.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.FD.$trModule3_closure+1;
         const GHC.IO.Handle.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.156314376 UTC

[section ""cstring" . lvl_rbfCu_bytes" {
     lvl_rbfCu_bytes:
         I8[] [104,97,110,100,108,101,84,111,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.158250744 UTC

[section ""data" . lvl1_rbfCv_closure" {
     lvl1_rbfCv_closure:
         const lvl1_rbfCv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbfCv_entry() //  [R1]
         { info_tbl: [(cbgpG,
                       label: lvl1_rbfCv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgpG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgpH; else goto cbgpI;
       cbgpH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgpI: // global
           (_cbgpD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgpD::I64 == 0) goto cbgpF; else goto cbgpE;
       cbgpF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgpE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgpD::I64;
           R2 = lvl_rbfCu_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.162125341 UTC

[section ""cstring" . lvl2_rbfCw_bytes" {
     lvl2_rbfCw_bytes:
         I8[] [110,111,116,32,97,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.16392614 UTC

[section ""data" . lvl3_rbfCx_closure" {
     lvl3_rbfCx_closure:
         const lvl3_rbfCx_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbfCx_entry() //  [R1]
         { info_tbl: [(cbgpX,
                       label: lvl3_rbfCx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgpX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgpY; else goto cbgpZ;
       cbgpY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgpZ: // global
           (_cbgpU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgpU::I64 == 0) goto cbgpW; else goto cbgpV;
       cbgpW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgpV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgpU::I64;
           R2 = lvl2_rbfCw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.169659266 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd3_closure" {
     GHC.IO.Handle.FD.handleToFd3_closure:
         const GHC.IO.Handle.FD.handleToFd3_info;
         const 0;
 },
 sat_sbfCX_entry() //  [R1]
         { info_tbl: [(cbgqh,
                       label: sat_sbfCX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgqh: // global
           _sbfCX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbgqi; else goto cbgqj;
       cbgqj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbgql; else goto cbgqk;
       cbgql: // global
           HpAlloc = 72;
           goto cbgqi;
       cbgqi: // global
           R1 = _sbfCX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgqk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfCX::P64;
           _sbfCT::P64 = P64[_sbfCX::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfCT::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InappropriateType_closure+1;
           P64[Hp - 24] = lvl1_rbfCv_closure;
           P64[Hp - 16] = lvl3_rbfCx_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.handleToFd3_entry() //  [R2]
         { info_tbl: [(cbgqm,
                       label: GHC.IO.Handle.FD.handleToFd3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgqm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgqq; else goto cbgqp;
       cbgqq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgqp: // global
           I64[Hp - 16] = sat_sbfCX_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.175524574 UTC

[section ""cstring" . lvl4_rbfCy_bytes" {
     lvl4_rbfCy_bytes:
         I8[] [110,111,116,32,97,32,102,105,108,101,32,104,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.177773728 UTC

[section ""data" . lvl5_rbfCz_closure" {
     lvl5_rbfCz_closure:
         const lvl5_rbfCz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rbfCz_entry() //  [R1]
         { info_tbl: [(cbgqH,
                       label: lvl5_rbfCz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgqH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgqI; else goto cbgqJ;
       cbgqI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgqJ: // global
           (_cbgqE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgqE::I64 == 0) goto cbgqG; else goto cbgqF;
       cbgqG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgqF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgqE::I64;
           R2 = lvl4_rbfCy_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.181869555 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd2_closure" {
     GHC.IO.Handle.FD.handleToFd2_closure:
         const GHC.IO.Handle.FD.handleToFd2_info;
         const 0;
 },
 sat_sbfD2_entry() //  [R1]
         { info_tbl: [(cbgr1,
                       label: sat_sbfD2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgr1: // global
           _sbfD2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbgr2; else goto cbgr3;
       cbgr3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbgr5; else goto cbgr4;
       cbgr5: // global
           HpAlloc = 72;
           goto cbgr2;
       cbgr2: // global
           R1 = _sbfD2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgr4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfD2::P64;
           _sbfCY::P64 = P64[_sbfD2::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfCY::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InappropriateType_closure+1;
           P64[Hp - 24] = lvl1_rbfCv_closure;
           P64[Hp - 16] = lvl5_rbfCz_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.handleToFd2_entry() //  [R2]
         { info_tbl: [(cbgr6,
                       label: GHC.IO.Handle.FD.handleToFd2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgr6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgra; else goto cbgr9;
       cbgra: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgr9: // global
           I64[Hp - 16] = sat_sbfD2_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.188216604 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd1_closure" {
     GHC.IO.Handle.FD.handleToFd1_closure:
         const GHC.IO.Handle.FD.handleToFd1_info;
         const 0;
 },
 GHC.IO.Handle.FD.handleToFd1_entry() //  [R2]
         { info_tbl: [(cbgrv,
                       label: GHC.IO.Handle.FD.handleToFd1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgrv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgrw; else goto cbgrx;
       cbgrw: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgrx: // global
           I64[Sp - 8] = block_cbgro_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubgrZ; else goto cbgrp;
       ubgrZ: // global
           call _cbgro(R1) args: 0, res: 0, upd: 0;
       cbgrp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgro() //  [R1]
         { info_tbl: [(cbgro,
                       label: block_cbgro_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgro: // global
           if (R1 & 7 == 1) goto cbgrs; else goto cbgrt;
       cbgrs: // global
           I64[Sp - 8] = block_cbgrA_info;
           _sbfD5::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbfD5::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbgrt: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbgrA() //  [R1]
         { info_tbl: [(cbgrA,
                       label: block_cbgrA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgrA: // global
           I64[Sp] = block_cbgrC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgs0; else goto cbgrF;
       ubgs0: // global
           call _cbgrC(R1) args: 0, res: 0, upd: 0;
       cbgrF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgrC() //  [R1]
         { info_tbl: [(cbgrC,
                       label: block_cbgrC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgrC: // global
           I64[Sp - 8] = block_cbgrJ_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[R1 + 23];
           P64[Sp] = P64[R1 + 31];
           Sp = Sp - 8;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgrJ() //  [R1]
         { info_tbl: [(cbgrJ,
                       label: block_cbgrJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgrJ: // global
           if (R1 & 7 == 1) goto cbgrQ; else goto cbgrU;
       cbgrQ: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbgrU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.198915761 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd_closure" {
     GHC.IO.Handle.FD.handleToFd_closure:
         const GHC.IO.Handle.FD.handleToFd_info;
         const 0;
 },
 GHC.IO.Handle.FD.handleToFd_entry() //  [R2]
         { info_tbl: [(cbgsu,
                       label: GHC.IO.Handle.FD.handleToFd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgsu: // global
           R2 = R2;
           call GHC.IO.Handle.FD.handleToFd1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.202290941 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle11_bytes" {
     GHC.IO.Handle.FD.fdToHandle11_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.204550107 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle10_closure" {
     GHC.IO.Handle.FD.fdToHandle10_closure:
         const GHC.IO.Handle.FD.fdToHandle10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle10_entry() //  [R1]
         { info_tbl: [(cbgsI,
                       label: GHC.IO.Handle.FD.fdToHandle10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgsI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgsJ; else goto cbgsK;
       cbgsJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgsK: // global
           (_cbgsF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgsF::I64 == 0) goto cbgsH; else goto cbgsG;
       cbgsH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgsG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgsF::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.208432427 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle9_bytes" {
     GHC.IO.Handle.FD.fdToHandle9_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.210282223 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle8_closure" {
     GHC.IO.Handle.FD.fdToHandle8_closure:
         const GHC.IO.Handle.FD.fdToHandle8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle8_entry() //  [R1]
         { info_tbl: [(cbgsZ,
                       label: GHC.IO.Handle.FD.fdToHandle8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgsZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgt0; else goto cbgt1;
       cbgt0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgt1: // global
           (_cbgsW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgsW::I64 == 0) goto cbgsY; else goto cbgsX;
       cbgsY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgsX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgsW::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.214569813 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle7_closure" {
     GHC.IO.Handle.FD.fdToHandle7_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Handle.FD.fdToHandle10_closure;
         const GHC.IO.Handle.FD.fdToHandle8_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.216628578 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle6_closure" {
     GHC.IO.Handle.FD.fdToHandle6_closure:
         const GHC.IO.Handle.FD.fdToHandle6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle6_entry() //  [R1]
         { info_tbl: [(cbgtg,
                       label: GHC.IO.Handle.FD.fdToHandle6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgtg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgth; else goto cbgti;
       cbgth: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgti: // global
           (_cbgtd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgtd::I64 == 0) goto cbgtf; else goto cbgte;
       cbgtf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgte: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgtd::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle7_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.222789756 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle5_closure" {
     GHC.IO.Handle.FD.fdToHandle5_closure:
         const GHC.IO.Handle.FD.fdToHandle5_info;
         const 0;
 },
 nl_sbfDG_entry() //  [R1]
         { info_tbl: [(cbgtG,
                       label: nl_sbfDG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgtG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgtH; else goto cbgtI;
       cbgtH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgtI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbgtD_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubgtM; else goto cbgtE;
       ubgtM: // global
           call _cbgtD() args: 0, res: 0, upd: 0;
       cbgtE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbgtD() //  []
         { info_tbl: [(cbgtD,
                       label: block_cbgtD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgtD: // global
           R1 = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfDL_entry() //  [R1]
         { info_tbl: [(cbgu5,
                       label: sat_sbfDL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgu5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgu6; else goto cbgu7;
       cbgu6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgu7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbgtW_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubgum; else goto cbgtX;
       ubgum: // global
           call _cbgtW(R1) args: 0, res: 0, upd: 0;
       cbgtX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbgtW() //  [R1]
         { info_tbl: [(cbgtW,
                       label: block_cbgtW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgtW: // global
           _cbgu4::P64 = R1 & 7;
           if (_cbgu4::P64 < 3) goto ubguk; else goto ubgul;
       ubguk: // global
           if (_cbgu4::P64 < 2) goto cbgu0; else goto cbgu1;
       cbgu0: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbgu1: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ubgul: // global
           if (_cbgu4::P64 < 4) goto cbgu2; else goto cbgu3;
       cbgu2: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbgu3: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfE4_entry() //  [R1]
         { info_tbl: [(cbguG,
                       label: sat_sbfE4_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbguG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbguS; else goto cbguR;
       cbguS: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbguR: // global
           (_sbfE1::I64) = call "capi" arg hints:  [‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC17ZCbaseZCSystemziPosixziInternalsZCfcntl(I64[R1 + 7], %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbfE1::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.fdToHandle5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbguX,
                       label: GHC.IO.Handle.FD.fdToHandle5_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbguX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbguY; else goto cbguZ;
       cbguY: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbguZ: // global
           I64[Sp - 40] = block_cbgun_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubgwx; else goto cbguo;
       ubgwx: // global
           call _cbgun(R1) args: 0, res: 0, upd: 0;
       cbguo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgun() //  [R1]
         { info_tbl: [(cbgun,
                       label: block_cbgun_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgun: // global
           _sbfDw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbguU; else goto cbguV;
       cbguU: // global
           P64[Sp + 8] = _sbfDw::P64;
           Sp = Sp + 8;
           call _cbgtx() args: 0, res: 0, upd: 0;
       cbguV: // global
           I64[Sp + 8] = block_cbgut_info;
           R1 = _sbfDw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubgwv; else goto cbguu;
       ubgwv: // global
           call _cbgut(R1) args: 0, res: 0, upd: 0;
       cbguu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgut() //  [R1]
         { info_tbl: [(cbgut,
                       label: block_cbgut_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgut: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgvG; else goto cbgvF;
       cbgvG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgvF: // global
           _sbfDQ::I64 = I64[R1 + 7];
           (_sbfDV::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_f_getfl();
           I64[Hp - 16] = sat_sbfE4_info;
           I64[Hp - 8] = _sbfDQ::I64;
           I64[Hp] = _sbfDV::I64;
           I64[Sp - 8] = block_cbgvA_info;
           R4 = Hp - 15;
           R3 = System.Posix.Internals.setNonBlockingFD3_closure;
           R2 = System.Posix.Internals.fdFileSize_pred_closure+1;
           I64[Sp] = _sbfDQ::I64;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgvA() //  [R1]
         { info_tbl: [(cbgvA,
                       label: block_cbgvA_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgvA: // global
           I64[Sp] = block_cbgvC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgwB; else goto cbgvI;
       ubgwB: // global
           call _cbgvC(R1) args: 0, res: 0, upd: 0;
       cbgvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgvC() //  [R1]
         { info_tbl: [(cbgvC,
                       label: block_cbgvC_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgvC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgvO; else goto cbgvN;
       cbgvO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgvN: // global
           _sbfDQ::I64 = I64[Sp + 8];
           _sbfE9::I64 = I64[R1 + 7];
           (_sbfEd::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           _sbfEe::I64 = _sbfE9::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbfEd::I64));
           if (_sbfE9::I64 == _sbfEe::I64) goto cbgw8; else goto cbgw9;
       cbgw8: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sbfDQ::I64;
           I64[Hp] = 1;
           P64[Sp + 8] = Hp - 15;
           Sp = Sp + 8;
           goto ubgwD;
       cbgw9: // global
           (_sbfEo::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_f_setfl();
           (_sbfEt::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC16ZCbaseZCSystemziPosixziInternalsZCfcntl(_sbfDQ::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbfEo::I64)), _sbfEe::I64);
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sbfDQ::I64;
           I64[Hp] = 1;
           P64[Sp + 8] = Hp - 15;
           Sp = Sp + 8;
           goto ubgwD;
       ubgwD: // global
           call _cbgtx() args: 0, res: 0, upd: 0;
     }
 },
 _cbgtx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgtx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgv3; else goto cbgv2;
       cbgv3: // global
           HpAlloc = 24;
           _sbfDF::P64 = P64[Sp];
           I64[Sp] = block_cbgtw_info;
           R1 = _sbfDF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgv2: // global
           I64[Hp - 16] = nl_sbfDG_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp - 8] = block_cbgv0_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubgwu; else goto cbgv7;
       ubgwu: // global
           call _cbgv0(R1) args: 0, res: 0, upd: 0;
       cbgv7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgtw() //  [R1]
         { info_tbl: [(cbgtw,
                       label: block_cbgtw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgtw: // global
           P64[Sp] = R1;
           call _cbgtx() args: 0, res: 0, upd: 0;
     }
 },
 _cbgv0() //  [R1]
         { info_tbl: [(cbgv0,
                       label: block_cbgv0_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgv0: // global
           _cbgwm::P64 = R1 & 7;
           if (_cbgwm::P64 != 1) goto ubgwo; else goto cbgvh;
       ubgwo: // global
           if (_cbgwm::P64 != 2) goto ubgwz; else goto cbgvm;
       ubgwz: // global
           call _cbgtQ() args: 0, res: 0, upd: 0;
       cbgvm: // global
           I64[Sp] = block_cbgvk_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto ubgwy; else goto cbgvn;
       ubgwy: // global
           call _cbgvk(R1) args: 0, res: 0, upd: 0;
       cbgvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbgvh: // global
           R1 = GHC.IO.Handle.FD.fdToHandle6_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbgvk() //  [R1]
         { info_tbl: [(cbgvk,
                       label: block_cbgvk_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgvk: // global
           if (R1 & 7 == 4) goto cbgvx; else goto ubgwA;
       cbgvx: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp + 32] = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
       ubgwA: // global
           call _cbgtQ() args: 0, res: 0, upd: 0;
     }
 },
 _cbgtQ() //  []
         { info_tbl: [(cbgtQ,
                       label: block_cbgtQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgtQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgv6; else goto cbgv5;
       cbgv6: // global
           HpAlloc = 24;
           I64[Sp] = block_cbgtQ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbgv5: // global
           I64[Hp - 16] = sat_sbfDL_info;
           P64[Hp] = P64[Sp + 32];
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = GHC.Types.True_closure+2;
           _cbgtz::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = _cbgtz::P64;
           P64[Sp + 32] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
           P64[Sp + 40] = GHC.Base.Nothing_closure+1;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.254698394 UTC

[section ""data" . GHC.IO.Handle.FD.mkHandleFromFD_closure" {
     GHC.IO.Handle.FD.mkHandleFromFD_closure:
         const GHC.IO.Handle.FD.mkHandleFromFD_info;
         const 0;
 },
 GHC.IO.Handle.FD.mkHandleFromFD_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbgy2,
                       label: GHC.IO.Handle.FD.mkHandleFromFD_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgy2: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.258378734 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'2_closure" {
     GHC.IO.Handle.FD.fdToHandle'2_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.261509993 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'1_closure" {
     GHC.IO.Handle.FD.fdToHandle'1_closure:
         const GHC.IO.Handle.FD.fdToHandle'1_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle'1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbgyn,
                       label: GHC.IO.Handle.FD.fdToHandle'1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgyn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbgyo; else goto cbgyp;
       cbgyo: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbgyp: // global
           I64[Sp - 40] = block_cbgyg_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubgzL; else goto cbgyh;
       ubgzL: // global
           call _cbgyg(R1) args: 0, res: 0, upd: 0;
       cbgyh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgyg() //  [R1]
         { info_tbl: [(cbgyg,
                       label: block_cbgyg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgyg: // global
           if (R1 & 7 == 1) goto cbgyk; else goto cbgyl;
       cbgyk: // global
           _sbfEv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbgyU_info;
           R5 = P64[Sp + 16];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[Sp + 32];
           R2 = _sbfEv::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       cbgyl: // global
           I64[Sp] = block_cbgz6_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubgzK; else goto cbgz8;
       ubgzK: // global
           call _cbgz6(R1) args: 0, res: 0, upd: 0;
       cbgz8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgyU() //  [R1]
         { info_tbl: [(cbgyU,
                       label: block_cbgyU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgyU: // global
           I64[Sp] = block_cbgyW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgzN; else goto cbgyZ;
       ubgzN: // global
           call _cbgyW(R1) args: 0, res: 0, upd: 0;
       cbgyZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgyW() //  [R1]
         { info_tbl: [(cbgyW,
                       label: block_cbgyW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgyW: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _sbfEC() args: 0, res: 0, upd: 0;
     }
 },
 _cbgz6() //  [R1]
         { info_tbl: [(cbgz6,
                       label: block_cbgz6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgz6: // global
           _sbfEv::P64 = P64[Sp + 8];
           _sbfEx::P64 = P64[Sp + 16];
           _sbfEz::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto cbgzy; else goto cbgzi;
       cbgzy: // global
           I64[Sp + 8] = block_cbgzu_info;
           R5 = _sbfEx::P64;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = _sbfEz::P64;
           R2 = _sbfEv::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       cbgzi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbgzl; else goto cbgzk;
       cbgzl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgzk: // global
           I64[Hp - 40] = (,,)_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = GHC.IO.Handle.FD.fdToHandle'2_closure+1;
           P64[Hp - 16] = GHC.IO.Handle.FD.fdToHandle'2_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           I64[Sp + 8] = block_cbgze_info;
           R5 = _sbfEx::P64;
           R4 = Hp - 6;
           R3 = _sbfEz::P64;
           R2 = _sbfEv::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgzu() //  [R1]
         { info_tbl: [(cbgzu,
                       label: block_cbgzu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgzu: // global
           I64[Sp] = block_cbgzw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgzR; else goto cbgzA;
       ubgzR: // global
           call _cbgzw(R1) args: 0, res: 0, upd: 0;
       cbgzA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgzw() //  [R1]
         { info_tbl: [(cbgzw,
                       label: block_cbgzw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgzw: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _sbfEC() args: 0, res: 0, upd: 0;
     }
 },
 _cbgze() //  [R1]
         { info_tbl: [(cbgze,
                       label: block_cbgze_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgze: // global
           I64[Sp] = block_cbgzg_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgzP; else goto cbgzn;
       ubgzP: // global
           call _cbgzg(R1) args: 0, res: 0, upd: 0;
       cbgzn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgzg() //  [R1]
         { info_tbl: [(cbgzg,
                       label: block_cbgzg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgzg: // global
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call _sbfEC() args: 0, res: 0, upd: 0;
     }
 },
 _sbfEC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbfEC: // global
           I64[Sp - 8] = block_cbgyt_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubgzT; else goto cbgyv;
       ubgzT: // global
           call _cbgyt(R1) args: 0, res: 0, upd: 0;
       cbgyv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgyt() //  [R1]
         { info_tbl: [(cbgyt,
                       label: block_cbgyt_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgyt: // global
           if (R1 & 7 == 1) goto cbgyJ; else goto cbgyR;
       cbgyJ: // global
           I64[Sp] = block_cbgyz_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgzM; else goto cbgyA;
       ubgzM: // global
           call _cbgyz(R1) args: 0, res: 0, upd: 0;
       cbgyA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbgyR: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 _cbgyz() //  [R1]
         { info_tbl: [(cbgyz,
                       label: block_cbgyz_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgyz: // global
           I64[Sp] = block_cbgyE_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgyE() //  [R1]
         { info_tbl: [(cbgyE,
                       label: block_cbgyE_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgyE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgyN; else goto cbgyM;
       cbgyN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgyM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 48] = Hp - 6;
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.287004251 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'_closure" {
     GHC.IO.Handle.FD.fdToHandle'_closure:
         const GHC.IO.Handle.FD.fdToHandle'_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbgAX,
                       label: GHC.IO.Handle.FD.fdToHandle'_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgAX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle'1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.290709684 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle4_bytes" {
     GHC.IO.Handle.FD.fdToHandle4_bytes:
         I8[] [60,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.292365799 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle3_bytes" {
     GHC.IO.Handle.FD.fdToHandle3_bytes:
         I8[] [62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.294220059 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle2_closure" {
     GHC.IO.Handle.FD.fdToHandle2_closure:
         const GHC.IO.Handle.FD.fdToHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle2_entry() //  [R1]
         { info_tbl: [(cbgBc,
                       label: GHC.IO.Handle.FD.fdToHandle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgBc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgBd; else goto cbgBe;
       cbgBd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgBe: // global
           (_cbgB9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgB9::I64 == 0) goto cbgBb; else goto cbgBa;
       cbgBb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgBa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgB9::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.298994099 UTC

[section ""data" . GHC.IO.Handle.FD.$wfdToHandle_closure" {
     GHC.IO.Handle.FD.$wfdToHandle_closure:
         const GHC.IO.Handle.FD.$wfdToHandle_info;
         const 0;
 },
 sat_sbfFu_entry() //  [R1]
         { info_tbl: [(cbgBL,
                       label: sat_sbfFu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgBL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgBR; else goto cbgBS;
       cbgBR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgBS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbgBI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubgBX; else goto cbgBJ;
       ubgBX: // global
           call _cbgBI(R1) args: 0, res: 0, upd: 0;
       cbgBJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbgBI() //  [R1]
         { info_tbl: [(cbgBI,
                       label: block_cbgBI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgBI: // global
           I64[Sp] = block_cbgBO_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbgBO() //  [R1, R2]
         { info_tbl: [(cbgBO,
                       label: block_cbgBO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgBO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgBW; else goto cbgBV;
       cbgBW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbgBV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.IO.Handle.FD.fdToHandle2_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfFv_entry() //  [R1]
         { info_tbl: [(cbgBY,
                       label: sat_sbfFv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgBY: // global
           _sbfFv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbgBZ; else goto cbgC0;
       cbgC0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgC2; else goto cbgC1;
       cbgC2: // global
           HpAlloc = 24;
           goto cbgBZ;
       cbgBZ: // global
           R1 = _sbfFv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgC1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfFv::P64;
           _sbfFl::P64 = P64[_sbfFv::P64 + 16];
           I64[Hp - 16] = sat_sbfFu_info;
           P64[Hp] = _sbfFl::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.FD.fdToHandle4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.$wfdToHandle_entry() //  [R2]
         { info_tbl: [(cbgC3,
                       label: GHC.IO.Handle.FD.$wfdToHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgC3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgC4; else goto cbgC5;
       cbgC4: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.$wfdToHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgC5: // global
           I64[Sp - 16] = block_cbgBq_info;
           _sbfFb::I64 = R2;
           R2 = R2;
           I64[Sp - 8] = _sbfFb::I64;
           Sp = Sp - 16;
           call System.Posix.Internals.$wfdGetMode_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgBq() //  [R1]
         { info_tbl: [(cbgBq,
                       label: block_cbgBq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgBq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgC8; else goto cbgC7;
       cbgC8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgC7: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp] = block_cbgBt_info;
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = R1;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgBt() //  [R1]
         { info_tbl: [(cbgBt,
                       label: block_cbgBt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgBt: // global
           I64[Sp] = block_cbgBv_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgCd; else goto cbgBw;
       ubgCd: // global
           call _cbgBv(R1) args: 0, res: 0, upd: 0;
       cbgBw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgBv() //  [R1]
         { info_tbl: [(cbgBv,
                       label: block_cbgBv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgBv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgCc; else goto cbgCb;
       cbgCc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgCb: // global
           _sbfFl::P64 = P64[R1 + 7];
           _sbfFm::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sbfFv_info;
           P64[Hp] = _sbfFl::P64;
           R6 = GHC.Types.False_closure+1;
           R5 = P64[Sp + 8];
           R4 = Hp - 16;
           R3 = _sbfFm::P64;
           R2 = _sbfFl::P64;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.316429661 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle1_closure" {
     GHC.IO.Handle.FD.fdToHandle1_closure:
         const GHC.IO.Handle.FD.fdToHandle1_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle1_entry() //  [R2]
         { info_tbl: [(cbgCQ,
                       label: GHC.IO.Handle.FD.fdToHandle1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgCQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbgCR; else goto cbgCS;
       cbgCR: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgCS: // global
           I64[Sp - 8] = block_cbgCN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubgCW; else goto cbgCO;
       ubgCW: // global
           call _cbgCN(R1) args: 0, res: 0, upd: 0;
       cbgCO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgCN() //  [R1]
         { info_tbl: [(cbgCN,
                       label: block_cbgCN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgCN: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.$wfdToHandle_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.32234185 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle_closure" {
     GHC.IO.Handle.FD.fdToHandle_closure:
         const GHC.IO.Handle.FD.fdToHandle_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle_entry() //  [R2]
         { info_tbl: [(cbgDa,
                       label: GHC.IO.Handle.FD.fdToHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDa: // global
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.327112432 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile5_closure" {
     GHC.IO.Handle.FD.openBinaryFile5_closure:
         const GHC.IO.Handle.FD.openBinaryFile5_info;
         const 0;
 },
 sat_sbfFX_entry() //  [R1, R2]
         { info_tbl: [(cbgDF,
                       label: sat_sbfFX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgDJ; else goto cbgDK;
       cbgDJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgDK: // global
           I64[Sp - 16] = block_cbgDC_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgDO; else goto cbgDD;
       ubgDO: // global
           call _cbgDC(R1) args: 0, res: 0, upd: 0;
       cbgDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgDC() //  [R1]
         { info_tbl: [(cbgDC,
                       label: block_cbgDC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDC: // global
           I64[Sp] = block_cbgDI_info;
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgDI() //  []
         { info_tbl: [(cbgDI,
                       label: block_cbgDI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDI: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfFO_entry() //  [R1]
         { info_tbl: [(cbgDU,
                       label: sat_sbfFO_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbgDV; else goto cbgDW;
       cbgDV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbgDW: // global
           R6 = GHC.Types.False_closure+1;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 39];
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbgDX,
                       label: GHC.IO.Handle.FD.openBinaryFile5_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbgDY; else goto cbgDZ;
       cbgDY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgDZ: // global
           I64[Sp - 32] = block_cbgDl_info;
           _sbfFC::P64 = R4;
           R4 = R5;
           _sbfFB::P64 = R3;
           R3 = R3;
           _sbfFA::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbfFA::P64;
           P64[Sp - 16] = _sbfFB::P64;
           P64[Sp - 8] = _sbfFC::P64;
           Sp = Sp - 32;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgDl() //  [R1]
         { info_tbl: [(cbgDl,
                       label: block_cbgDl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDl: // global
           I64[Sp] = block_cbgDn_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgEx; else goto cbgDo;
       ubgEx: // global
           call _cbgDn(R1) args: 0, res: 0, upd: 0;
       cbgDo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgDn() //  [R1]
         { info_tbl: [(cbgDn,
                       label: block_cbgDn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDn: // global
           I64[Sp - 8] = block_cbgE1_info;
           _sbfFJ::P64 = P64[R1 + 7];
           _sbfFK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sbfFK::P64;
           P64[Sp + 24] = _sbfFJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubgEy; else goto cbgE6;
       ubgEy: // global
           call _cbgE1(R1) args: 0, res: 0, upd: 0;
       cbgE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgE1() //  [R1]
         { info_tbl: [(cbgE1,
                       label: block_cbgE1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgE1: // global
           if (R1 & 7 == 1) goto cbgEd; else goto cbgEr;
       cbgEd: // global
           I64[Sp] = block_cbgEa_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgEA; else goto cbgEe;
       ubgEA: // global
           call _cbgEa(R1) args: 0, res: 0, upd: 0;
       cbgEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbgEr: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _cbgDv() args: 0, res: 0, upd: 0;
     }
 },
 _cbgEa() //  [R1]
         { info_tbl: [(cbgEa,
                       label: block_cbgEa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgEa: // global
           I64[Sp] = block_cbgEi_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgEi() //  [R1]
         { info_tbl: [(cbgEi,
                       label: block_cbgEi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgEi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgEn; else goto cbgEm;
       cbgEn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgEm: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 6;
           call _cbgDv() args: 0, res: 0, upd: 0;
     }
 },
 _cbgDv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDv: // global
           Hp = Hp + 64;
           _sbfFN::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cbgE5; else goto cbgE4;
       cbgE5: // global
           HpAlloc = 64;
           I64[Sp] = block_cbgDu_info;
           R1 = _sbfFN::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgE4: // global
           I64[Hp - 56] = sat_sbfFX_info;
           _sbfFJ::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sbfFJ::P64;
           I64[Hp - 40] = sat_sbfFO_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sbfFJ::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sbfFN::P64;
           R2 = Hp - 54;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbgDu() //  [R1]
         { info_tbl: [(cbgDu,
                       label: block_cbgDu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgDu: // global
           P64[Sp] = R1;
           call _cbgDv() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.349915945 UTC

[section ""data" . GHC.IO.Handle.FD.openFile2_closure" {
     GHC.IO.Handle.FD.openFile2_closure:
         const GHC.IO.Handle.FD.openFile2_info;
         const 0;
 },
 sat_sbfGi_entry() //  [R1]
         { info_tbl: [(cbgFG,
                       label: sat_sbfGi_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgFG: // global
           _sbfGi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbgFH; else goto cbgFI;
       cbgFI: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbgFK; else goto cbgFJ;
       cbgFK: // global
           HpAlloc = 72;
           goto cbgFH;
       cbgFH: // global
           R1 = _sbfGi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgFJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfGi::P64;
           _sbfG6::P64 = P64[_sbfGi::P64 + 16];
           _sbfGa::P64 = P64[_sbfGi::P64 + 24];
           _sbfGb::P64 = P64[_sbfGi::P64 + 32];
           _sbfGd::P64 = P64[_sbfGi::P64 + 40];
           _sbfGe::P64 = P64[_sbfGi::P64 + 48];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfG6::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = _sbfGa::P64;
           P64[Hp - 32] = _sbfGb::P64;
           P64[Hp - 24] = GHC.IO.Handle.FD.fdToHandle10_closure;
           P64[Hp - 16] = _sbfGd::P64;
           P64[Hp - 8] = _sbfGe::P64;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.openFile2_entry() //  [R2, R3]
         { info_tbl: [(cbgFL,
                       label: GHC.IO.Handle.FD.openFile2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgFL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgFM; else goto cbgFN;
       cbgFM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFile2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgFN: // global
           I64[Sp - 16] = block_cbgFv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgFR; else goto cbgFw;
       ubgFR: // global
           call _cbgFv(R1) args: 0, res: 0, upd: 0;
       cbgFw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgFv() //  [R1]
         { info_tbl: [(cbgFv,
                       label: block_cbgFv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgFv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbgFQ; else goto cbgFP;
       cbgFQ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgFP: // global
           _sbfGa::P64 = P64[R1 + 7];
           _sbfGb::P64 = P64[R1 + 15];
           _sbfGd::P64 = P64[R1 + 31];
           _sbfGe::P64 = P64[R1 + 39];
           I64[Hp - 48] = sat_sbfGi_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbfGa::P64;
           P64[Hp - 16] = _sbfGb::P64;
           P64[Hp - 8] = _sbfGd::P64;
           P64[Hp] = _sbfGe::P64;
           R1 = Hp - 48;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.36010942 UTC

[section ""data" . GHC.IO.Handle.FD.openFile1_closure" {
     GHC.IO.Handle.FD.openFile1_closure:
         const GHC.IO.Handle.FD.openFile1_info;
         const 0;
 },
 sat_sbfGt_entry() //  [R1]
         { info_tbl: [(cbgGy,
                       label: sat_sbfGt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgGy: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGv_entry() //  [R1, R2]
         { info_tbl: [(cbgGB,
                       label: sat_sbfGv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgGB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbgGC; else goto cbgGD;
       cbgGC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgGD: // global
           I64[Sp - 16] = block_cbgGg_info;
           _sbfGj::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbfGj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgGQ; else goto cbgGh;
       ubgGQ: // global
           call _cbgGg(R1) args: 0, res: 0, upd: 0;
       cbgGh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgGg() //  [R1]
         { info_tbl: [(cbgGg,
                       label: block_cbgGg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgGg: // global
           I64[Sp - 16] = block_cbgGl_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgGl() //  [R1]
         { info_tbl: [(cbgGl,
                       label: block_cbgGl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgGl: // global
           I64[Sp] = block_cbgGp_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgGp() //  [R1]
         { info_tbl: [(cbgGp,
                       label: block_cbgGp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgGp: // global
           if (R1 & 7 == 1) goto cbgGH; else goto cbgGO;
       cbgGH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgGK; else goto cbgGJ;
       cbgGK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgGJ: // global
           I64[Hp - 8] = sat_sbfGt_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbgGO: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGm_entry() //  [R1]
         { info_tbl: [(cbgGW,
                       label: sat_sbfGm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgGW: // global
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Types.False_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openFile1_entry() //  [R2, R3]
         { info_tbl: [(cbgGZ,
                       label: GHC.IO.Handle.FD.openFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgGZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbgH3; else goto cbgH2;
       cbgH3: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgH2: // global
           I64[Hp - 32] = sat_sbfGv_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbfGm_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.374539393 UTC

[section ""data" . GHC.IO.Handle.FD.openFile_closure" {
     GHC.IO.Handle.FD.openFile_closure:
         const GHC.IO.Handle.FD.openFile_info;
         const 0;
 },
 GHC.IO.Handle.FD.openFile_entry() //  [R2, R3]
         { info_tbl: [(cbgHB,
                       label: GHC.IO.Handle.FD.openFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgHB: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.378768306 UTC

[section ""data" . GHC.IO.Handle.FD.openFileBlocking1_closure" {
     GHC.IO.Handle.FD.openFileBlocking1_closure:
         const GHC.IO.Handle.FD.openFileBlocking1_info;
         const 0;
 },
 sat_sbfGG_entry() //  [R1]
         { info_tbl: [(cbgI9,
                       label: sat_sbfGG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgI9: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGI_entry() //  [R1, R2]
         { info_tbl: [(cbgIc,
                       label: sat_sbfGI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgIc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbgId; else goto cbgIe;
       cbgId: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgIe: // global
           I64[Sp - 16] = block_cbgHR_info;
           _sbfGw::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbfGw::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgIr; else goto cbgHS;
       ubgIr: // global
           call _cbgHR(R1) args: 0, res: 0, upd: 0;
       cbgHS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgHR() //  [R1]
         { info_tbl: [(cbgHR,
                       label: block_cbgHR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgHR: // global
           I64[Sp - 16] = block_cbgHW_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgHW() //  [R1]
         { info_tbl: [(cbgHW,
                       label: block_cbgHW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgHW: // global
           I64[Sp] = block_cbgI0_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgI0() //  [R1]
         { info_tbl: [(cbgI0,
                       label: block_cbgI0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgI0: // global
           if (R1 & 7 == 1) goto cbgIi; else goto cbgIp;
       cbgIi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgIl; else goto cbgIk;
       cbgIl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgIk: // global
           I64[Hp - 8] = sat_sbfGG_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbgIp: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGz_entry() //  [R1]
         { info_tbl: [(cbgIx,
                       label: sat_sbfGz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgIx: // global
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Types.False_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openFileBlocking1_entry() //  [R2, R3]
         { info_tbl: [(cbgIA,
                       label: GHC.IO.Handle.FD.openFileBlocking1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgIA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbgIE; else goto cbgID;
       cbgIE: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFileBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgID: // global
           I64[Hp - 32] = sat_sbfGI_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbfGz_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.395707867 UTC

[section ""data" . GHC.IO.Handle.FD.openFileBlocking_closure" {
     GHC.IO.Handle.FD.openFileBlocking_closure:
         const GHC.IO.Handle.FD.openFileBlocking_info;
         const 0;
 },
 GHC.IO.Handle.FD.openFileBlocking_entry() //  [R2, R3]
         { info_tbl: [(cbgJc,
                       label: GHC.IO.Handle.FD.openFileBlocking_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgJc: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openFileBlocking1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.399676528 UTC

[section ""cstring" . GHC.IO.Handle.FD.openBinaryFile4_bytes" {
     GHC.IO.Handle.FD.openBinaryFile4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.402360427 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile3_closure" {
     GHC.IO.Handle.FD.openBinaryFile3_closure:
         const GHC.IO.Handle.FD.openBinaryFile3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.openBinaryFile3_entry() //  [R1]
         { info_tbl: [(cbgJq,
                       label: GHC.IO.Handle.FD.openBinaryFile3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgJq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgJr; else goto cbgJs;
       cbgJr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgJs: // global
           (_cbgJn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgJn::I64 == 0) goto cbgJp; else goto cbgJo;
       cbgJp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgJo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgJn::I64;
           R2 = GHC.IO.Handle.FD.openBinaryFile4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.406970622 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile2_closure" {
     GHC.IO.Handle.FD.openBinaryFile2_closure:
         const GHC.IO.Handle.FD.openBinaryFile2_info;
         const 0;
 },
 sat_sbfGV_entry() //  [R1]
         { info_tbl: [(cbgJP,
                       label: sat_sbfGV_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgJP: // global
           _sbfGV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbgJQ; else goto cbgJR;
       cbgJR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbgJT; else goto cbgJS;
       cbgJT: // global
           HpAlloc = 72;
           goto cbgJQ;
       cbgJQ: // global
           R1 = _sbfGV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgJS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbfGV::P64;
           _sbfGJ::P64 = P64[_sbfGV::P64 + 16];
           _sbfGN::P64 = P64[_sbfGV::P64 + 24];
           _sbfGO::P64 = P64[_sbfGV::P64 + 32];
           _sbfGQ::P64 = P64[_sbfGV::P64 + 40];
           _sbfGR::P64 = P64[_sbfGV::P64 + 48];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbfGJ::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = _sbfGN::P64;
           P64[Hp - 32] = _sbfGO::P64;
           P64[Hp - 24] = GHC.IO.Handle.FD.openBinaryFile3_closure;
           P64[Hp - 16] = _sbfGQ::P64;
           P64[Hp - 8] = _sbfGR::P64;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile2_entry() //  [R2, R3]
         { info_tbl: [(cbgJU,
                       label: GHC.IO.Handle.FD.openBinaryFile2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgJU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgJV; else goto cbgJW;
       cbgJV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgJW: // global
           I64[Sp - 16] = block_cbgJE_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgK0; else goto cbgJF;
       ubgK0: // global
           call _cbgJE(R1) args: 0, res: 0, upd: 0;
       cbgJF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgJE() //  [R1]
         { info_tbl: [(cbgJE,
                       label: block_cbgJE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgJE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbgJZ; else goto cbgJY;
       cbgJZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgJY: // global
           _sbfGN::P64 = P64[R1 + 7];
           _sbfGO::P64 = P64[R1 + 15];
           _sbfGQ::P64 = P64[R1 + 31];
           _sbfGR::P64 = P64[R1 + 39];
           I64[Hp - 48] = sat_sbfGV_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbfGN::P64;
           P64[Hp - 16] = _sbfGO::P64;
           P64[Hp - 8] = _sbfGQ::P64;
           P64[Hp] = _sbfGR::P64;
           R1 = Hp - 48;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.416622092 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile1_closure" {
     GHC.IO.Handle.FD.openBinaryFile1_closure:
         const GHC.IO.Handle.FD.openBinaryFile1_info;
         const 0;
 },
 sat_sbfH6_entry() //  [R1]
         { info_tbl: [(cbgKH,
                       label: sat_sbfH6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgKH: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfH8_entry() //  [R1, R2]
         { info_tbl: [(cbgKK,
                       label: sat_sbfH8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgKK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbgKL; else goto cbgKM;
       cbgKL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbgKM: // global
           I64[Sp - 16] = block_cbgKp_info;
           _sbfGW::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbfGW::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgKZ; else goto cbgKq;
       ubgKZ: // global
           call _cbgKp(R1) args: 0, res: 0, upd: 0;
       cbgKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgKp() //  [R1]
         { info_tbl: [(cbgKp,
                       label: block_cbgKp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgKp: // global
           I64[Sp - 16] = block_cbgKu_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgKu() //  [R1]
         { info_tbl: [(cbgKu,
                       label: block_cbgKu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgKu: // global
           I64[Sp] = block_cbgKy_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbgKy() //  [R1]
         { info_tbl: [(cbgKy,
                       label: block_cbgKy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgKy: // global
           if (R1 & 7 == 1) goto cbgKQ; else goto cbgKX;
       cbgKQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgKT; else goto cbgKS;
       cbgKT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgKS: // global
           I64[Hp - 8] = sat_sbfH6_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbgKX: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openBinaryFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbfGZ_entry() //  [R1]
         { info_tbl: [(cbgL5,
                       label: sat_sbfGZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgL5: // global
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Types.True_closure+2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile1_entry() //  [R2, R3]
         { info_tbl: [(cbgL8,
                       label: GHC.IO.Handle.FD.openBinaryFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgL8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbgLc; else goto cbgLb;
       cbgLc: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgLb: // global
           I64[Hp - 32] = sat_sbfH8_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbfGZ_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.43107574 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile_closure" {
     GHC.IO.Handle.FD.openBinaryFile_closure:
         const GHC.IO.Handle.FD.openBinaryFile_info;
         const 0;
 },
 GHC.IO.Handle.FD.openBinaryFile_entry() //  [R2, R3]
         { info_tbl: [(cbgLK,
                       label: GHC.IO.Handle.FD.openBinaryFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgLK: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.437262247 UTC

[section ""data" . $wstdHandleFinalizer_rbfCA_closure" {
     $wstdHandleFinalizer_rbfCA_closure:
         const $wstdHandleFinalizer_rbfCA_info;
         const 0;
 },
 sat_sbfHL_entry() //  [R1]
         { info_tbl: [(cbgMv,
                       label: sat_sbfHL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgMv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgMw; else goto cbgMx;
       cbgMw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgMx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfHX_entry() //  [R1]
         { info_tbl: [(cbgML,
                       label: sat_sbfHX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgML: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgMM; else goto cbgMN;
       cbgMM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgMN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfIa_entry() //  [R1]
         { info_tbl: [(cbgN6,
                       label: sat_sbfIa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgN6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgN7; else goto cbgN8;
       cbgN7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgN8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfIm_entry() //  [R1]
         { info_tbl: [(cbgNm,
                       label: sat_sbfIm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgNm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgNn; else goto cbgNo;
       cbgNn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgNo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbfIo_entry() //  [R1]
         { info_tbl: [(cbgNv,
                       label: sat_sbfIo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgNv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgNw; else goto cbgNx;
       cbgNw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgNx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wstdHandleFinalizer_rbfCA_entry() //  [R2, R3]
         { info_tbl: [(cbgNy,
                       label: $wstdHandleFinalizer_rbfCA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgNy: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbgNz; else goto cbgNA;
       cbgNz: // global
           R3 = R3;
           R2 = R2;
           R1 = $wstdHandleFinalizer_rbfCA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgNA: // global
           I64[Sp - 24] = block_cbgLV_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgLV() //  [R1]
         { info_tbl: [(cbgLV,
                       label: block_cbgLV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgLV: // global
           I64[Sp] = block_cbgLX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubgP6; else goto cbgLY;
       ubgP6: // global
           call _cbgLX(R1) args: 0, res: 0, upd: 0;
       cbgLY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgLX() //  [R1]
         { info_tbl: [(cbgLX,
                       label: block_cbgLX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgLX: // global
           I64[Sp - 48] = block_cbgM2_info;
           _sbfHh::P64 = P64[R1 + 15];
           _sbfHj::P64 = P64[R1 + 31];
           _sbfHk::P64 = P64[R1 + 39];
           _sbfHl::P64 = P64[R1 + 47];
           _sbfHq::P64 = P64[R1 + 87];
           _sbfHr::P64 = P64[R1 + 95];
           R1 = P64[_sbfHl::P64 + 8];
           P64[Sp - 40] = _sbfHj::P64;
           P64[Sp - 32] = _sbfHk::P64;
           P64[Sp - 24] = _sbfHl::P64;
           P64[Sp - 16] = _sbfHq::P64;
           P64[Sp - 8] = _sbfHr::P64;
           P64[Sp] = _sbfHh::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ubgP7; else goto cbgM3;
       ubgP7: // global
           call _cbgM2(R1) args: 0, res: 0, upd: 0;
       cbgM3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgM2() //  [R1]
         { info_tbl: [(cbgM2,
                       label: block_cbgM2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgM2: // global
           I64[Sp] = block_cbgND_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubgP8; else goto cbgOv;
       ubgP8: // global
           call _cbgND(R1) args: 0, res: 0, upd: 0;
       cbgOv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgND() //  [R1]
         { info_tbl: [(cbgND,
                       label: block_cbgND_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgND: // global
           if (R1 & 7 == 1) goto ubgP3; else goto cbgOG;
       ubgP3: // global
           Sp = Sp + 16;
           call _sbfHG() args: 0, res: 0, upd: 0;
       cbgOG: // global
           _sbfIt::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbgOE_info;
           R1 = _sbfIt::P64;
           if (R1 & 7 != 0) goto ubgPf; else goto cbgOH;
       ubgPf: // global
           call _cbgOE(R1) args: 0, res: 0, upd: 0;
       cbgOH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgOE() //  [R1]
         { info_tbl: [(cbgOE,
                       label: block_cbgOE_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgOE: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubgP4; else goto cbgOR;
       ubgP4: // global
           Sp = Sp + 16;
           call _sbfHG() args: 0, res: 0, upd: 0;
       cbgOR: // global
           _sbfHj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbgOP_info;
           R2 = P64[Sp + 48];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sbfHj::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbgOP() //  [R1]
         { info_tbl: [(cbgOP,
                       label: block_cbgOP_info
                       rep:StackRep [False, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgOP: // global
           _sbfHl::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbfHl::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbfHl::P64);
           Sp = Sp + 8;
           call _sbfHG() args: 0, res: 0, upd: 0;
     }
 },
 _sbfHG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbfHG: // global
           I64[Sp + 8] = block_cbgMc_info;
           R1 = P64[Sp];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubgPj; else goto cbgMd;
       ubgPj: // global
           call _cbgMc(R1) args: 0, res: 0, upd: 0;
       cbgMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgMc() //  [R1]
         { info_tbl: [(cbgMc,
                       label: block_cbgMc_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgMc: // global
           if (R1 & 7 == 1) goto cbgOp; else goto cbgNI;
       cbgOp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgOs; else goto cbgOr;
       cbgOs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgOr: // global
           I64[Hp - 16] = sat_sbfIo_info;
           P64[Hp] = P64[Sp + 32];
           _sbfHa::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbgOo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbgNI: // global
           I64[Sp] = block_cbgMh_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubgP9; else goto cbgMi;
       ubgP9: // global
           call _cbgMh(R1) args: 0, res: 0, upd: 0;
       cbgMi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgMh() //  [R1]
         { info_tbl: [(cbgMh,
                       label: block_cbgMh_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgMh: // global
           if (R1 & 7 == 1) goto cbgNL; else goto cbgO4;
       cbgNL: // global
           I64[Sp + 24] = block_cbgMm_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubgPa; else goto cbgMn;
       ubgPa: // global
           call _cbgMm(R1) args: 0, res: 0, upd: 0;
       cbgMn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbgO4: // global
           I64[Sp] = block_cbgMQ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubgPb; else goto cbgMR;
       ubgPb: // global
           call _cbgMQ(R1) args: 0, res: 0, upd: 0;
       cbgMR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgMm() //  [R1]
         { info_tbl: [(cbgMm,
                       label: block_cbgMm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgMm: // global
           if (R1 & 7 == 1) goto cbgNO; else goto cbgNW;
       cbgNO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgNR; else goto cbgNQ;
       cbgNR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgNQ: // global
           I64[Hp - 16] = sat_sbfHL_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbgOo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbgNW: // global
           I64[Sp] = block_cbgMA_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubgPc; else goto cbgMB;
       ubgPc: // global
           call _cbgMA(R1) args: 0, res: 0, upd: 0;
       cbgMB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgMA() //  [R1]
         { info_tbl: [(cbgMA,
                       label: block_cbgMA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgMA: // global
           I64[Sp] = block_cbgMF_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgMF() //  [R1]
         { info_tbl: [(cbgMF,
                       label: block_cbgMF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgMF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgO0; else goto cbgNZ;
       cbgO0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgNZ: // global
           I64[Hp - 16] = sat_sbfHX_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbgOo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgMQ() //  [R1]
         { info_tbl: [(cbgMQ,
                       label: block_cbgMQ_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgMQ: // global
           I64[Sp] = block_cbgMV_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgMV() //  []
         { info_tbl: [(cbgMV,
                       label: block_cbgMV_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgMV: // global
           I64[Sp + 24] = block_cbgMX_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubgPd; else goto cbgMY;
       ubgPd: // global
           call _cbgMX(R1) args: 0, res: 0, upd: 0;
       cbgMY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgMX() //  [R1]
         { info_tbl: [(cbgMX,
                       label: block_cbgMX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgMX: // global
           if (R1 & 7 == 1) goto cbgO9; else goto cbgOh;
       cbgO9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgOc; else goto cbgOb;
       cbgOc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgOb: // global
           I64[Hp - 16] = sat_sbfIa_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbgOo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbgOh: // global
           I64[Sp] = block_cbgNb_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubgPe; else goto cbgNc;
       ubgPe: // global
           call _cbgNb(R1) args: 0, res: 0, upd: 0;
       cbgNc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgNb() //  [R1]
         { info_tbl: [(cbgNb,
                       label: block_cbgNb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgNb: // global
           I64[Sp] = block_cbgNg_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgNg() //  [R1]
         { info_tbl: [(cbgNg,
                       label: block_cbgNg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgNg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgOl; else goto cbgOk;
       cbgOl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgOk: // global
           I64[Hp - 16] = sat_sbfIm_info;
           P64[Hp] = P64[Sp + 8];
           _sbfHa::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbgOo_info;
           R2 = Hp - 16;
           R1 = _sbfHa::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgOo() //  []
         { info_tbl: [(cbgOo,
                       label: block_cbgOo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgOo: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.48318537 UTC

[section ""data" . stdHandleFinalizer_rbfCB_closure" {
     stdHandleFinalizer_rbfCB_closure:
         const stdHandleFinalizer_rbfCB_info;
         const 0;
 },
 stdHandleFinalizer_rbfCB_entry() //  [R2, R3]
         { info_tbl: [(cbgRb,
                       label: stdHandleFinalizer_rbfCB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgRb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgRc; else goto cbgRd;
       cbgRc: // global
           R3 = R3;
           R2 = R2;
           R1 = stdHandleFinalizer_rbfCB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgRd: // global
           I64[Sp - 16] = block_cbgR8_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgRh; else goto cbgR9;
       ubgRh: // global
           call _cbgR8(R1) args: 0, res: 0, upd: 0;
       cbgR9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgR8() //  [R1]
         { info_tbl: [(cbgR8,
                       label: block_cbgR8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgR8: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wstdHandleFinalizer_rbfCA_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.488331871 UTC

[section ""cstring" . lvl6_rbfCC_bytes" {
     lvl6_rbfCC_bytes:
         I8[] [60,115,116,100,101,114,114,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.490915136 UTC

[section ""data" . lvl7_rbfCD_closure" {
     lvl7_rbfCD_closure:
         const lvl7_rbfCD_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rbfCD_entry() //  [R1]
         { info_tbl: [(cbgRy,
                       label: lvl7_rbfCD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgRy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgRz; else goto cbgRA;
       cbgRz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgRA: // global
           (_cbgRv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgRv::I64 == 0) goto cbgRx; else goto cbgRw;
       cbgRx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgRw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgRv::I64;
           R2 = lvl6_rbfCC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.494515974 UTC

[section ""data" . lvl8_rbfCE_closure" {
     lvl8_rbfCE_closure:
         const GHC.Base.Just_con_info;
         const stdHandleFinalizer_rbfCB_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.496589628 UTC

[section ""data" . lvl9_rbfCF_closure" {
     lvl9_rbfCF_closure:
         const lvl9_rbfCF_info;
         const 0;
 },
 section ""relreadonly" . ubgS6_srtd" {
     ubgS6_srtd:
         const SbfJE_srt+64;
         const 37;
         const 120259089281;
 },
 lvl9_rbfCF_entry() //  []
         { info_tbl: [(cbgRS,
                       label: lvl9_rbfCF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgRS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbgRT; else goto cbgRU;
       cbgRT: // global
           R1 = lvl9_rbfCF_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbgRU: // global
           I64[Sp - 8] = block_cbgRN_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgS7_srtd" {
     ubgS7_srtd:
         const SbfJE_srt+64;
         const 36;
         const 51539612545;
 },
 _cbgRN() //  []
         { info_tbl: [(cbgRN,
                       label: block_cbgRN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgRN: // global
           I64[Sp] = block_cbgRP_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgS5; else goto cbgRQ;
       ubgS5: // global
           call _cbgRP(R1) args: 0, res: 0, upd: 0;
       cbgRQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgS8_srtd" {
     ubgS8_srtd:
         const SbfJE_srt+64;
         const 36;
         const 51539608449;
 },
 _cbgRP() //  [R1]
         { info_tbl: [(cbgRP,
                       label: block_cbgRP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgRP: // global
           I64[Sp] = block_cbgRY_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgS9_srtd" {
     ubgS9_srtd:
         const SbfJE_srt+64;
         const 36;
         const 51539608449;
 },
 _cbgRY() //  [R1]
         { info_tbl: [(cbgRY,
                       label: block_cbgRY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgRY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgS3; else goto cbgS2;
       cbgS3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgS2: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl7_rbfCD_closure;
           R5 = GHC.IO.FD.stderr_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 32] = GHC.Types.False_closure+1;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.508014736 UTC

[section ""data" . GHC.IO.Handle.FD.stderr_closure" {
     GHC.IO.Handle.FD.stderr_closure:
         const GHC.IO.Handle.FD.stderr_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stderr_entry() //  [R1]
         { info_tbl: [(cbgSC,
                       label: GHC.IO.Handle.FD.stderr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgSC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgSD; else goto cbgSE;
       cbgSD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgSE: // global
           (_cbgSx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgSx::I64 == 0) goto cbgSz; else goto cbgSy;
       cbgSz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgSy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgSx::I64;
           I64[Sp - 24] = block_cbgSA_info;
           Sp = Sp - 24;
           call lvl9_rbfCF_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbgSA() //  [R1]
         { info_tbl: [(cbgSA,
                       label: block_cbgSA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgSA: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.514382156 UTC

[section ""cstring" . lvl10_rbfCG_bytes" {
     lvl10_rbfCG_bytes:
         I8[] [60,115,116,100,111,117,116,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.516285244 UTC

[section ""data" . lvl11_rbfCH_closure" {
     lvl11_rbfCH_closure:
         const lvl11_rbfCH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rbfCH_entry() //  [R1]
         { info_tbl: [(cbgSZ,
                       label: lvl11_rbfCH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgSZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgT0; else goto cbgT1;
       cbgT0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgT1: // global
           (_cbgSW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgSW::I64 == 0) goto cbgSY; else goto cbgSX;
       cbgSY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgSX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgSW::I64;
           R2 = lvl10_rbfCG_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.520514944 UTC

[section ""data" . lvl12_rbfCI_closure" {
     lvl12_rbfCI_closure:
         const lvl12_rbfCI_info;
         const 0;
 },
 section ""relreadonly" . ubgTw_srtd" {
     ubgTw_srtd:
         const SbfJE_srt+64;
         const 39;
         const 446676603777;
 },
 lvl12_rbfCI_entry() //  []
         { info_tbl: [(cbgTi,
                       label: lvl12_rbfCI_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgTi: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbgTj; else goto cbgTk;
       cbgTj: // global
           R1 = lvl12_rbfCI_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbgTk: // global
           I64[Sp - 8] = block_cbgTd_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgTx_srtd" {
     ubgTx_srtd:
         const SbfJE_srt+64;
         const 38;
         const 171798696833;
 },
 _cbgTd() //  []
         { info_tbl: [(cbgTd,
                       label: block_cbgTd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgTd: // global
           I64[Sp] = block_cbgTf_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgTv; else goto cbgTg;
       ubgTv: // global
           call _cbgTf(R1) args: 0, res: 0, upd: 0;
       cbgTg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgTy_srtd" {
     ubgTy_srtd:
         const SbfJE_srt+64;
         const 38;
         const 171798692737;
 },
 _cbgTf() //  [R1]
         { info_tbl: [(cbgTf,
                       label: block_cbgTf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgTf: // global
           I64[Sp] = block_cbgTo_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgTz_srtd" {
     ubgTz_srtd:
         const SbfJE_srt+64;
         const 38;
         const 171798692737;
 },
 _cbgTo() //  [R1]
         { info_tbl: [(cbgTo,
                       label: block_cbgTo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgTo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgTt; else goto cbgTs;
       cbgTt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgTs: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl11_rbfCH_closure;
           R5 = GHC.IO.FD.stdout_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 32] = GHC.Types.True_closure+2;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.532269953 UTC

[section ""data" . GHC.IO.Handle.FD.stdout_closure" {
     GHC.IO.Handle.FD.stdout_closure:
         const GHC.IO.Handle.FD.stdout_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stdout_entry() //  [R1]
         { info_tbl: [(cbgU2,
                       label: GHC.IO.Handle.FD.stdout_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgU2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgU3; else goto cbgU4;
       cbgU3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgU4: // global
           (_cbgTX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgTX::I64 == 0) goto cbgTZ; else goto cbgTY;
       cbgTZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgTY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgTX::I64;
           I64[Sp - 24] = block_cbgU0_info;
           Sp = Sp - 24;
           call lvl12_rbfCI_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbgU0() //  [R1]
         { info_tbl: [(cbgU0,
                       label: block_cbgU0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgU0: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.537998619 UTC

[section ""cstring" . lvl13_rbfCJ_bytes" {
     lvl13_rbfCJ_bytes:
         I8[] [60,115,116,100,105,110,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.539904133 UTC

[section ""data" . lvl14_rbfCK_closure" {
     lvl14_rbfCK_closure:
         const lvl14_rbfCK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_rbfCK_entry() //  [R1]
         { info_tbl: [(cbgUp,
                       label: lvl14_rbfCK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgUp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgUq; else goto cbgUr;
       cbgUq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgUr: // global
           (_cbgUm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgUm::I64 == 0) goto cbgUo; else goto cbgUn;
       cbgUo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgUn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgUm::I64;
           R2 = lvl13_rbfCJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.544116412 UTC

[section ""data" . lvl15_rbfCL_closure" {
     lvl15_rbfCL_closure:
         const lvl15_rbfCL_info;
         const 0;
 },
 section ""relreadonly" . ubgUW_srtd" {
     ubgUW_srtd:
         const SbfJE_srt+64;
         const 41;
         const 1683627185025;
 },
 lvl15_rbfCL_entry() //  []
         { info_tbl: [(cbgUI,
                       label: lvl15_rbfCL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgUI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbgUJ; else goto cbgUK;
       cbgUJ: // global
           R1 = lvl15_rbfCL_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbgUK: // global
           I64[Sp - 8] = block_cbgUD_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgUX_srtd" {
     ubgUX_srtd:
         const SbfJE_srt+64;
         const 40;
         const 584115557249;
 },
 _cbgUD() //  []
         { info_tbl: [(cbgUD,
                       label: block_cbgUD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgUD: // global
           I64[Sp] = block_cbgUF_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubgUV; else goto cbgUG;
       ubgUV: // global
           call _cbgUF(R1) args: 0, res: 0, upd: 0;
       cbgUG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgUY_srtd" {
     ubgUY_srtd:
         const SbfJE_srt+64;
         const 40;
         const 584115553153;
 },
 _cbgUF() //  [R1]
         { info_tbl: [(cbgUF,
                       label: block_cbgUF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgUF: // global
           I64[Sp] = block_cbgUO_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubgUZ_srtd" {
     ubgUZ_srtd:
         const SbfJE_srt+64;
         const 40;
         const 584115553153;
 },
 _cbgUO() //  [R1]
         { info_tbl: [(cbgUO,
                       label: block_cbgUO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgUO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgUT; else goto cbgUS;
       cbgUT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgUS: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl14_rbfCK_closure;
           R5 = GHC.IO.FD.stdin_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 32] = GHC.Types.True_closure+2;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.556692791 UTC

[section ""data" . GHC.IO.Handle.FD.stdin_closure" {
     GHC.IO.Handle.FD.stdin_closure:
         const GHC.IO.Handle.FD.stdin_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stdin_entry() //  [R1]
         { info_tbl: [(cbgVs,
                       label: GHC.IO.Handle.FD.stdin_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgVs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbgVt; else goto cbgVu;
       cbgVt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbgVu: // global
           (_cbgVn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbgVn::I64 == 0) goto cbgVp; else goto cbgVo;
       cbgVp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbgVo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbgVn::I64;
           I64[Sp - 24] = block_cbgVq_info;
           Sp = Sp - 24;
           call lvl15_rbfCL_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbgVq() //  [R1]
         { info_tbl: [(cbgVq,
                       label: block_cbgVq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgVq: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:12.562332544 UTC

[section ""relreadonly" . SbfJE_srt" {
     SbfJE_srt:
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl1_rbfCv_closure;
         const lvl3_rbfCx_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const lvl5_rbfCz_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd1_closure;
         const GHC.IO.Handle.FD.fdToHandle7_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const System.Posix.Internals.setNonBlockingFD3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.IO.FD.$fBufferedIOFD_closure;
         const GHC.IO.FD.$fIODeviceFD_closure;
         const GHC.IO.Handle.FD.fdToHandle5_closure;
         const GHC.IO.Handle.FD.fdToHandle6_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.Handle.FD.fdToHandle'1_closure;
         const GHC.IO.Handle.FD.fdToHandle2_closure;
         const System.Posix.Internals.$wfdGetMode_closure;
         const GHC.IO.Handle.FD.$wfdToHandle_closure;
         const GHC.IO.Handle.FD.fdToHandle1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.Handle.FD.openBinaryFile5_closure;
         const GHC.IO.Handle.FD.fdToHandle10_closure;
         const GHC.IO.Handle.FD.openFile2_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.FD.openFile1_closure;
         const GHC.IO.Handle.FD.openFileBlocking1_closure;
         const GHC.IO.Handle.FD.openBinaryFile3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.FD.openBinaryFile2_closure;
         const GHC.IO.Handle.FD.openBinaryFile1_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const $wstdHandleFinalizer_rbfCA_closure;
         const stdHandleFinalizer_rbfCB_closure;
         const lvl7_rbfCD_closure;
         const lvl8_rbfCE_closure;
         const lvl9_rbfCF_closure;
         const lvl11_rbfCH_closure;
         const lvl12_rbfCI_closure;
         const lvl14_rbfCK_closure;
         const lvl15_rbfCL_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.543072862 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:13.544712036 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle12_closure" {
     GHC.IO.Handle.FD.fdToHandle12_closure:
         const GHC.IO.Handle.FD.fdToHandle12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle12_entry() //  [R1]
         { info_tbl: [(cbh2s,
                       label: GHC.IO.Handle.FD.fdToHandle12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh2s: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbh2t; else goto cbh2u;
       cbh2t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh2u: // global
           (_cbh2k::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbh2k::I64 == 0) goto cbh2m; else goto cbh2l;
       cbh2m: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbh2l: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbh2k::I64;
           I64[Sp - 24] = block_cbh2n_info;
           R6 = 0;
           R5 = GHC.IO.FD.$tcFD1_closure;
           R4 = GHC.IO.FD.$trModule_closure;
           R3 = 15546290101957756376;
           R2 = 10838815552519039062;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbh2n() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbh2n,
                       label: block_cbh2n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh2n: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbh2o() args: 0, res: 0, upd: 0;
     }
 },
 _cbh2o() //  []
         { info_tbl: [(cbh2o,
                       label: block_cbh2o_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh2o: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbh2x; else goto cbh2w;
       cbh2x: // global
           HpAlloc = 48;
           I64[Sp] = block_cbh2o_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbh2w: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.552594654 UTC

[section ""cstring" . GHC.IO.Handle.FD.$trModule4_bytes" {
     GHC.IO.Handle.FD.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.554327203 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule3_closure" {
     GHC.IO.Handle.FD.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.FD.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.556071798 UTC

[section ""cstring" . GHC.IO.Handle.FD.$trModule2_bytes" {
     GHC.IO.Handle.FD.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,70,68]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.557788084 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule1_closure" {
     GHC.IO.Handle.FD.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.FD.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.55950655 UTC

[section ""data" . GHC.IO.Handle.FD.$trModule_closure" {
     GHC.IO.Handle.FD.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.FD.$trModule3_closure+1;
         const GHC.IO.Handle.FD.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.561168164 UTC

[section ""cstring" . lvl_rbfCu_bytes" {
     lvl_rbfCu_bytes:
         I8[] [104,97,110,100,108,101,84,111,70,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.563179904 UTC

[section ""data" . lvl1_rbfCv_closure" {
     lvl1_rbfCv_closure:
         const lvl1_rbfCv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbfCv_entry() //  [R1]
         { info_tbl: [(cbh3d,
                       label: lvl1_rbfCv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh3d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbh3e; else goto cbh3f;
       cbh3e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh3f: // global
           (_cbh3a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbh3a::I64 == 0) goto cbh3c; else goto cbh3b;
       cbh3c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbh3b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbh3a::I64;
           R2 = lvl_rbfCu_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.567634009 UTC

[section ""cstring" . lvl2_rbfCw_bytes" {
     lvl2_rbfCw_bytes:
         I8[] [110,111,116,32,97,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.569507535 UTC

[section ""data" . lvl3_rbfCx_closure" {
     lvl3_rbfCx_closure:
         const lvl3_rbfCx_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbfCx_entry() //  [R1]
         { info_tbl: [(cbh3v,
                       label: lvl3_rbfCx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh3v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbh3w; else goto cbh3x;
       cbh3w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh3x: // global
           (_cbh3s::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbh3s::I64 == 0) goto cbh3u; else goto cbh3t;
       cbh3u: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbh3t: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbh3s::I64;
           R2 = lvl2_rbfCw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.574600256 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd3_closure" {
     GHC.IO.Handle.FD.handleToFd3_closure:
         const GHC.IO.Handle.FD.handleToFd3_info;
         const 0;
 },
 sat_sbgVT_entry() //  [R1]
         { info_tbl: [(cbh3Q,
                       label: sat_sbgVT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh3Q: // global
           _sbgVT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbh3R; else goto cbh3S;
       cbh3S: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbh3U; else goto cbh3T;
       cbh3U: // global
           HpAlloc = 72;
           goto cbh3R;
       cbh3R: // global
           R1 = _sbgVT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh3T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbgVT::P64;
           _sbgVP::P64 = P64[_sbgVT::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbgVP::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InappropriateType_closure+1;
           P64[Hp - 24] = lvl1_rbfCv_closure;
           P64[Hp - 16] = lvl3_rbfCx_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.handleToFd3_entry() //  [R2]
         { info_tbl: [(cbh3V,
                       label: GHC.IO.Handle.FD.handleToFd3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh3V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbh3Z; else goto cbh3Y;
       cbh3Z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbh3Y: // global
           I64[Hp - 16] = sat_sbgVT_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.58116766 UTC

[section ""cstring" . lvl4_rbfCy_bytes" {
     lvl4_rbfCy_bytes:
         I8[] [110,111,116,32,97,32,102,105,108,101,32,104,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.583149648 UTC

[section ""data" . lvl5_rbfCz_closure" {
     lvl5_rbfCz_closure:
         const lvl5_rbfCz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rbfCz_entry() //  [R1]
         { info_tbl: [(cbh4s,
                       label: lvl5_rbfCz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh4s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbh4t; else goto cbh4u;
       cbh4t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh4u: // global
           (_cbh4p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbh4p::I64 == 0) goto cbh4r; else goto cbh4q;
       cbh4r: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbh4q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbh4p::I64;
           R2 = lvl4_rbfCy_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.587415979 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd2_closure" {
     GHC.IO.Handle.FD.handleToFd2_closure:
         const GHC.IO.Handle.FD.handleToFd2_info;
         const 0;
 },
 sat_sbgVY_entry() //  [R1]
         { info_tbl: [(cbh4N,
                       label: sat_sbgVY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh4N: // global
           _sbgVY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbh4O; else goto cbh4P;
       cbh4P: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbh4R; else goto cbh4Q;
       cbh4R: // global
           HpAlloc = 72;
           goto cbh4O;
       cbh4O: // global
           R1 = _sbgVY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh4Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbgVY::P64;
           _sbgVU::P64 = P64[_sbgVY::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbgVU::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InappropriateType_closure+1;
           P64[Hp - 24] = lvl1_rbfCv_closure;
           P64[Hp - 16] = lvl5_rbfCz_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.handleToFd2_entry() //  [R2]
         { info_tbl: [(cbh4S,
                       label: GHC.IO.Handle.FD.handleToFd2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh4S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbh4W; else goto cbh4V;
       cbh4W: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbh4V: // global
           I64[Hp - 16] = sat_sbgVY_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.594438624 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd1_closure" {
     GHC.IO.Handle.FD.handleToFd1_closure:
         const GHC.IO.Handle.FD.handleToFd1_info;
         const 0;
 },
 GHC.IO.Handle.FD.handleToFd1_entry() //  [R2]
         { info_tbl: [(cbh5t,
                       label: GHC.IO.Handle.FD.handleToFd1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh5t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbh5u; else goto cbh5v;
       cbh5u: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.handleToFd1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbh5v: // global
           I64[Sp - 8] = block_cbh5m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubh5X; else goto cbh5n;
       ubh5X: // global
           call _cbh5m(R1) args: 0, res: 0, upd: 0;
       cbh5n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbh5m() //  [R1]
         { info_tbl: [(cbh5m,
                       label: block_cbh5m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh5m: // global
           if (R1 & 7 == 1) goto cbh5q; else goto cbh5r;
       cbh5q: // global
           I64[Sp - 8] = block_cbh5y_info;
           _sbgW1::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbgW1::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbh5r: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbh5y() //  [R1]
         { info_tbl: [(cbh5y,
                       label: block_cbh5y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh5y: // global
           I64[Sp] = block_cbh5A_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubh5Y; else goto cbh5D;
       ubh5Y: // global
           call _cbh5A(R1) args: 0, res: 0, upd: 0;
       cbh5D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbh5A() //  [R1]
         { info_tbl: [(cbh5A,
                       label: block_cbh5A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh5A: // global
           I64[Sp - 8] = block_cbh5H_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[R1 + 23];
           P64[Sp] = P64[R1 + 31];
           Sp = Sp - 8;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbh5H() //  [R1]
         { info_tbl: [(cbh5H,
                       label: block_cbh5H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh5H: // global
           if (R1 & 7 == 1) goto cbh5O; else goto cbh5S;
       cbh5O: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbh5S: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.605527982 UTC

[section ""data" . GHC.IO.Handle.FD.handleToFd_closure" {
     GHC.IO.Handle.FD.handleToFd_closure:
         const GHC.IO.Handle.FD.handleToFd_info;
         const 0;
 },
 GHC.IO.Handle.FD.handleToFd_entry() //  [R2]
         { info_tbl: [(cbh6w,
                       label: GHC.IO.Handle.FD.handleToFd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh6w: // global
           R2 = R2;
           call GHC.IO.Handle.FD.handleToFd1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.608897486 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle11_bytes" {
     GHC.IO.Handle.FD.fdToHandle11_bytes:
         I8[] [111,112,101,110,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.611361378 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle10_closure" {
     GHC.IO.Handle.FD.fdToHandle10_closure:
         const GHC.IO.Handle.FD.fdToHandle10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle10_entry() //  [R1]
         { info_tbl: [(cbh6K,
                       label: GHC.IO.Handle.FD.fdToHandle10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh6K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbh6L; else goto cbh6M;
       cbh6L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh6M: // global
           (_cbh6H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbh6H::I64 == 0) goto cbh6J; else goto cbh6I;
       cbh6J: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbh6I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbh6H::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.61567537 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle9_bytes" {
     GHC.IO.Handle.FD.fdToHandle9_bytes:
         I8[] [105,115,32,97,32,100,105,114,101,99,116,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.6176358 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle8_closure" {
     GHC.IO.Handle.FD.fdToHandle8_closure:
         const GHC.IO.Handle.FD.fdToHandle8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle8_entry() //  [R1]
         { info_tbl: [(cbh72,
                       label: GHC.IO.Handle.FD.fdToHandle8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh72: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbh73; else goto cbh74;
       cbh73: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh74: // global
           (_cbh6Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbh6Z::I64 == 0) goto cbh71; else goto cbh70;
       cbh71: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbh70: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbh6Z::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.621617102 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle7_closure" {
     GHC.IO.Handle.FD.fdToHandle7_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Handle.FD.fdToHandle10_closure;
         const GHC.IO.Handle.FD.fdToHandle8_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.623660492 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle6_closure" {
     GHC.IO.Handle.FD.fdToHandle6_closure:
         const GHC.IO.Handle.FD.fdToHandle6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle6_entry() //  [R1]
         { info_tbl: [(cbh7k,
                       label: GHC.IO.Handle.FD.fdToHandle6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh7k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbh7l; else goto cbh7m;
       cbh7l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh7m: // global
           (_cbh7h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbh7h::I64 == 0) goto cbh7j; else goto cbh7i;
       cbh7j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbh7i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbh7h::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle7_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.630280562 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle5_closure" {
     GHC.IO.Handle.FD.fdToHandle5_closure:
         const GHC.IO.Handle.FD.fdToHandle5_info;
         const 0;
 },
 nl_sbgWC_entry() //  [R1]
         { info_tbl: [(cbh7L,
                       label: nl_sbgWC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh7L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbh7M; else goto cbh7N;
       cbh7M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh7N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbh7I_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubh7R; else goto cbh7J;
       ubh7R: // global
           call _cbh7I() args: 0, res: 0, upd: 0;
       cbh7J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbh7I() //  []
         { info_tbl: [(cbh7I,
                       label: block_cbh7I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh7I: // global
           R1 = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbgWH_entry() //  [R1]
         { info_tbl: [(cbh8a,
                       label: sat_sbgWH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh8a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbh8b; else goto cbh8c;
       cbh8b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbh8c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbh81_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubh8r; else goto cbh82;
       ubh8r: // global
           call _cbh81(R1) args: 0, res: 0, upd: 0;
       cbh82: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbh81() //  [R1]
         { info_tbl: [(cbh81,
                       label: block_cbh81_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh81: // global
           _cbh89::P64 = R1 & 7;
           if (_cbh89::P64 < 3) goto ubh8p; else goto ubh8q;
       ubh8p: // global
           if (_cbh89::P64 < 2) goto cbh85; else goto cbh86;
       cbh85: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbh86: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ubh8q: // global
           if (_cbh89::P64 < 4) goto cbh87; else goto cbh88;
       cbh87: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbh88: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbgX0_entry() //  [R1]
         { info_tbl: [(cbh8L,
                       label: sat_sbgX0_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh8L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbh8X; else goto cbh8W;
       cbh8X: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbh8W: // global
           (_sbgWX::I64) = call "capi" arg hints:  [‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC17ZCbaseZCSystemziPosixziInternalsZCfcntl(I64[R1 + 7], %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 15])));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbgWX::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.fdToHandle5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbh92,
                       label: GHC.IO.Handle.FD.fdToHandle5_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh92: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbh93; else goto cbh94;
       cbh93: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbh94: // global
           I64[Sp - 40] = block_cbh8s_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubhaC; else goto cbh8t;
       ubhaC: // global
           call _cbh8s(R1) args: 0, res: 0, upd: 0;
       cbh8t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbh8s() //  [R1]
         { info_tbl: [(cbh8s,
                       label: block_cbh8s_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh8s: // global
           _sbgWs::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbh8Z; else goto cbh90;
       cbh8Z: // global
           P64[Sp + 8] = _sbgWs::P64;
           Sp = Sp + 8;
           call _cbh7C() args: 0, res: 0, upd: 0;
       cbh90: // global
           I64[Sp + 8] = block_cbh8y_info;
           R1 = _sbgWs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubhaA; else goto cbh8z;
       ubhaA: // global
           call _cbh8y(R1) args: 0, res: 0, upd: 0;
       cbh8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbh8y() //  [R1]
         { info_tbl: [(cbh8y,
                       label: block_cbh8y_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh8y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbh9L; else goto cbh9K;
       cbh9L: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbh9K: // global
           _sbgWM::I64 = I64[R1 + 7];
           (_sbgWR::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_f_getfl();
           I64[Hp - 16] = sat_sbgX0_info;
           I64[Hp - 8] = _sbgWM::I64;
           I64[Hp] = _sbgWR::I64;
           I64[Sp - 8] = block_cbh9F_info;
           R4 = Hp - 15;
           R3 = System.Posix.Internals.setNonBlockingFD3_closure;
           R2 = System.Posix.Internals.fdFileSize_pred_closure+1;
           I64[Sp] = _sbgWM::I64;
           Sp = Sp - 8;
           call Foreign.C.Error.throwErrnoIfMinus1Retry2_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbh9F() //  [R1]
         { info_tbl: [(cbh9F,
                       label: block_cbh9F_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh9F: // global
           I64[Sp] = block_cbh9H_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubhaG; else goto cbh9N;
       ubhaG: // global
           call _cbh9H(R1) args: 0, res: 0, upd: 0;
       cbh9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbh9H() //  [R1]
         { info_tbl: [(cbh9H,
                       label: block_cbh9H_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh9H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbh9T; else goto cbh9S;
       cbh9T: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbh9S: // global
           _sbgWM::I64 = I64[Sp + 8];
           _sbgX5::I64 = I64[R1 + 7];
           (_sbgX9::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_o_nonblock();
           _sbgXa::I64 = _sbgX5::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbgX9::I64));
           if (_sbgX5::I64 == _sbgXa::I64) goto cbhad; else goto cbhae;
       cbhad: // global
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sbgWM::I64;
           I64[Hp] = 1;
           P64[Sp + 8] = Hp - 15;
           Sp = Sp + 8;
           goto ubhaI;
       cbhae: // global
           (_sbgXk::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_f_setfl();
           (_sbgXp::I64) = call "capi" arg hints:  [‘signed’, ‘signed’,
                                                    ‘signed’]  result hints:  [‘signed’] ghczuwrapperZC16ZCbaseZCSystemziPosixziInternalsZCfcntl(_sbgWM::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbgXk::I64)), _sbgXa::I64);
           I64[Hp - 16] = GHC.IO.FD.FD_con_info;
           I64[Hp - 8] = _sbgWM::I64;
           I64[Hp] = 1;
           P64[Sp + 8] = Hp - 15;
           Sp = Sp + 8;
           goto ubhaI;
       ubhaI: // global
           call _cbh7C() args: 0, res: 0, upd: 0;
     }
 },
 _cbh7C() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh7C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbh98; else goto cbh97;
       cbh98: // global
           HpAlloc = 24;
           _sbgWB::P64 = P64[Sp];
           I64[Sp] = block_cbh7B_info;
           R1 = _sbgWB::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbh97: // global
           I64[Hp - 16] = nl_sbgWC_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp - 8] = block_cbh95_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubhaz; else goto cbh9c;
       ubhaz: // global
           call _cbh95(R1) args: 0, res: 0, upd: 0;
       cbh9c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbh7B() //  [R1]
         { info_tbl: [(cbh7B,
                       label: block_cbh7B_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh7B: // global
           P64[Sp] = R1;
           call _cbh7C() args: 0, res: 0, upd: 0;
     }
 },
 _cbh95() //  [R1]
         { info_tbl: [(cbh95,
                       label: block_cbh95_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh95: // global
           _cbhar::P64 = R1 & 7;
           if (_cbhar::P64 != 1) goto ubhat; else goto cbh9m;
       ubhat: // global
           if (_cbhar::P64 != 2) goto ubhaE; else goto cbh9r;
       ubhaE: // global
           call _cbh7V() args: 0, res: 0, upd: 0;
       cbh9r: // global
           I64[Sp] = block_cbh9p_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto ubhaD; else goto cbh9s;
       ubhaD: // global
           call _cbh9p(R1) args: 0, res: 0, upd: 0;
       cbh9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbh9m: // global
           R1 = GHC.IO.Handle.FD.fdToHandle6_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbh9p() //  [R1]
         { info_tbl: [(cbh9p,
                       label: block_cbh9p_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh9p: // global
           if (R1 & 7 == 4) goto cbh9C; else goto ubhaF;
       cbh9C: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp + 32] = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
       ubhaF: // global
           call _cbh7V() args: 0, res: 0, upd: 0;
     }
 },
 _cbh7V() //  []
         { info_tbl: [(cbh7V,
                       label: block_cbh7V_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh7V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbh9b; else goto cbh9a;
       cbh9b: // global
           HpAlloc = 24;
           I64[Sp] = block_cbh7V_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbh9a: // global
           I64[Hp - 16] = sat_sbgWH_info;
           P64[Hp] = P64[Sp + 32];
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = GHC.Types.True_closure+2;
           _cbh7E::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = _cbh7E::P64;
           P64[Sp + 32] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
           P64[Sp + 40] = GHC.Base.Nothing_closure+1;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.663826988 UTC

[section ""data" . GHC.IO.Handle.FD.mkHandleFromFD_closure" {
     GHC.IO.Handle.FD.mkHandleFromFD_closure:
         const GHC.IO.Handle.FD.mkHandleFromFD_info;
         const 0;
 },
 GHC.IO.Handle.FD.mkHandleFromFD_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbhcz,
                       label: GHC.IO.Handle.FD.mkHandleFromFD_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhcz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.667531872 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'2_closure" {
     GHC.IO.Handle.FD.fdToHandle'2_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.670652054 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'1_closure" {
     GHC.IO.Handle.FD.fdToHandle'1_closure:
         const GHC.IO.Handle.FD.fdToHandle'1_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle'1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbhcU,
                       label: GHC.IO.Handle.FD.fdToHandle'1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhcU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbhcV; else goto cbhcW;
       cbhcV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbhcW: // global
           I64[Sp - 40] = block_cbhcN_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubhei; else goto cbhcO;
       ubhei: // global
           call _cbhcN(R1) args: 0, res: 0, upd: 0;
       cbhcO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhcN() //  [R1]
         { info_tbl: [(cbhcN,
                       label: block_cbhcN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhcN: // global
           if (R1 & 7 == 1) goto cbhcR; else goto cbhcS;
       cbhcR: // global
           _sbgXr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbhdr_info;
           R5 = P64[Sp + 16];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[Sp + 32];
           R2 = _sbgXr::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       cbhcS: // global
           I64[Sp] = block_cbhdD_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubheh; else goto cbhdF;
       ubheh: // global
           call _cbhdD(R1) args: 0, res: 0, upd: 0;
       cbhdF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhdr() //  [R1]
         { info_tbl: [(cbhdr,
                       label: block_cbhdr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhdr: // global
           I64[Sp] = block_cbhdt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubhek; else goto cbhdw;
       ubhek: // global
           call _cbhdt(R1) args: 0, res: 0, upd: 0;
       cbhdw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhdt() //  [R1]
         { info_tbl: [(cbhdt,
                       label: block_cbhdt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhdt: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _sbgXy() args: 0, res: 0, upd: 0;
     }
 },
 _cbhdD() //  [R1]
         { info_tbl: [(cbhdD,
                       label: block_cbhdD_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhdD: // global
           _sbgXr::P64 = P64[Sp + 8];
           _sbgXt::P64 = P64[Sp + 16];
           _sbgXv::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto cbhe5; else goto cbhdP;
       cbhe5: // global
           I64[Sp + 8] = block_cbhe1_info;
           R5 = _sbgXt::P64;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = _sbgXv::P64;
           R2 = _sbgXr::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       cbhdP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbhdS; else goto cbhdR;
       cbhdS: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhdR: // global
           I64[Hp - 40] = (,,)_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = GHC.IO.Handle.FD.fdToHandle'2_closure+1;
           P64[Hp - 16] = GHC.IO.Handle.FD.fdToHandle'2_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           I64[Sp + 8] = block_cbhdL_info;
           R5 = _sbgXt::P64;
           R4 = Hp - 6;
           R3 = _sbgXv::P64;
           R2 = _sbgXr::P64;
           Sp = Sp + 8;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhe1() //  [R1]
         { info_tbl: [(cbhe1,
                       label: block_cbhe1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhe1: // global
           I64[Sp] = block_cbhe3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubheo; else goto cbhe7;
       ubheo: // global
           call _cbhe3(R1) args: 0, res: 0, upd: 0;
       cbhe7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhe3() //  [R1]
         { info_tbl: [(cbhe3,
                       label: block_cbhe3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhe3: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _sbgXy() args: 0, res: 0, upd: 0;
     }
 },
 _cbhdL() //  [R1]
         { info_tbl: [(cbhdL,
                       label: block_cbhdL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhdL: // global
           I64[Sp] = block_cbhdN_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubhem; else goto cbhdU;
       ubhem: // global
           call _cbhdN(R1) args: 0, res: 0, upd: 0;
       cbhdU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhdN() //  [R1]
         { info_tbl: [(cbhdN,
                       label: block_cbhdN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhdN: // global
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 8;
           call _sbgXy() args: 0, res: 0, upd: 0;
     }
 },
 _sbgXy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbgXy: // global
           I64[Sp - 8] = block_cbhd0_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubheq; else goto cbhd2;
       ubheq: // global
           call _cbhd0(R1) args: 0, res: 0, upd: 0;
       cbhd2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhd0() //  [R1]
         { info_tbl: [(cbhd0,
                       label: block_cbhd0_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhd0: // global
           if (R1 & 7 == 1) goto cbhdg; else goto cbhdo;
       cbhdg: // global
           I64[Sp] = block_cbhd6_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubhej; else goto cbhd7;
       ubhej: // global
           call _cbhd6(R1) args: 0, res: 0, upd: 0;
       cbhd7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbhdo: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 48] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 _cbhd6() //  [R1]
         { info_tbl: [(cbhd6,
                       label: block_cbhd6_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhd6: // global
           I64[Sp] = block_cbhdb_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhdb() //  [R1]
         { info_tbl: [(cbhdb,
                       label: block_cbhdb_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhdb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbhdk; else goto cbhdj;
       cbhdk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhdj: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 40];
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp + 48] = Hp - 6;
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.69747208 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle'_closure" {
     GHC.IO.Handle.FD.fdToHandle'_closure:
         const GHC.IO.Handle.FD.fdToHandle'_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbhfO,
                       label: GHC.IO.Handle.FD.fdToHandle'_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhfO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle'1_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.700868499 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle4_bytes" {
     GHC.IO.Handle.FD.fdToHandle4_bytes:
         I8[] [60,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.70304678 UTC

[section ""cstring" . GHC.IO.Handle.FD.fdToHandle3_bytes" {
     GHC.IO.Handle.FD.fdToHandle3_bytes:
         I8[] [62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.705011705 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle2_closure" {
     GHC.IO.Handle.FD.fdToHandle2_closure:
         const GHC.IO.Handle.FD.fdToHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle2_entry() //  [R1]
         { info_tbl: [(cbhg3,
                       label: GHC.IO.Handle.FD.fdToHandle2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhg3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhg4; else goto cbhg5;
       cbhg4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhg5: // global
           (_cbhg0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbhg0::I64 == 0) goto cbhg2; else goto cbhg1;
       cbhg2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbhg1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbhg0::I64;
           R2 = GHC.IO.Handle.FD.fdToHandle3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.710074751 UTC

[section ""data" . GHC.IO.Handle.FD.$wfdToHandle_closure" {
     GHC.IO.Handle.FD.$wfdToHandle_closure:
         const GHC.IO.Handle.FD.$wfdToHandle_info;
         const 0;
 },
 sat_sbgYq_entry() //  [R1]
         { info_tbl: [(cbhgD,
                       label: sat_sbgYq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhgD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbhgJ; else goto cbhgK;
       cbhgJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhgK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbhgA_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubhgP; else goto cbhgB;
       ubhgP: // global
           call _cbhgA(R1) args: 0, res: 0, upd: 0;
       cbhgB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbhgA() //  [R1]
         { info_tbl: [(cbhgA,
                       label: block_cbhgA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhgA: // global
           I64[Sp] = block_cbhgG_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbhgG() //  [R1, R2]
         { info_tbl: [(cbhgG,
                       label: block_cbhgG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhgG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbhgO; else goto cbhgN;
       cbhgO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbhgN: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.IO.Handle.FD.fdToHandle2_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbgYr_entry() //  [R1]
         { info_tbl: [(cbhgQ,
                       label: sat_sbgYr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhgQ: // global
           _sbgYr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbhgR; else goto cbhgS;
       cbhgS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbhgU; else goto cbhgT;
       cbhgU: // global
           HpAlloc = 24;
           goto cbhgR;
       cbhgR: // global
           R1 = _sbgYr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhgT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbgYr::P64;
           _sbgYh::P64 = P64[_sbgYr::P64 + 16];
           I64[Hp - 16] = sat_sbgYq_info;
           P64[Hp] = _sbgYh::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.FD.fdToHandle4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.$wfdToHandle_entry() //  [R2]
         { info_tbl: [(cbhgV,
                       label: GHC.IO.Handle.FD.$wfdToHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhgV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhgW; else goto cbhgX;
       cbhgW: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.$wfdToHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbhgX: // global
           I64[Sp - 16] = block_cbhgi_info;
           _sbgY7::I64 = R2;
           R2 = R2;
           I64[Sp - 8] = _sbgY7::I64;
           Sp = Sp - 16;
           call System.Posix.Internals.$wfdGetMode_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhgi() //  [R1]
         { info_tbl: [(cbhgi,
                       label: block_cbhgi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhgi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbhh0; else goto cbhgZ;
       cbhh0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhgZ: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8];
           I64[Sp] = block_cbhgl_info;
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = R1;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhgl() //  [R1]
         { info_tbl: [(cbhgl,
                       label: block_cbhgl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhgl: // global
           I64[Sp] = block_cbhgn_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubhh5; else goto cbhgo;
       ubhh5: // global
           call _cbhgn(R1) args: 0, res: 0, upd: 0;
       cbhgo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhgn() //  [R1]
         { info_tbl: [(cbhgn,
                       label: block_cbhgn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhgn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbhh4; else goto cbhh3;
       cbhh4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhh3: // global
           _sbgYh::P64 = P64[R1 + 7];
           _sbgYi::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sbgYr_info;
           P64[Hp] = _sbgYh::P64;
           R6 = GHC.Types.False_closure+1;
           R5 = P64[Sp + 8];
           R4 = Hp - 16;
           R3 = _sbgYi::P64;
           R2 = _sbgYh::P64;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.728093123 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle1_closure" {
     GHC.IO.Handle.FD.fdToHandle1_closure:
         const GHC.IO.Handle.FD.fdToHandle1_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle1_entry() //  [R2]
         { info_tbl: [(cbhhZ,
                       label: GHC.IO.Handle.FD.fdToHandle1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhhZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbhi0; else goto cbhi1;
       cbhi0: // global
           R2 = R2;
           R1 = GHC.IO.Handle.FD.fdToHandle1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbhi1: // global
           I64[Sp - 8] = block_cbhhW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubhi5; else goto cbhhX;
       ubhi5: // global
           call _cbhhW(R1) args: 0, res: 0, upd: 0;
       cbhhX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhhW() //  [R1]
         { info_tbl: [(cbhhW,
                       label: block_cbhhW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhhW: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.$wfdToHandle_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.734447557 UTC

[section ""data" . GHC.IO.Handle.FD.fdToHandle_closure" {
     GHC.IO.Handle.FD.fdToHandle_closure:
         const GHC.IO.Handle.FD.fdToHandle_info;
         const 0;
 },
 GHC.IO.Handle.FD.fdToHandle_entry() //  [R2]
         { info_tbl: [(cbhik,
                       label: GHC.IO.Handle.FD.fdToHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhik: // global
           R2 = R2;
           call GHC.IO.Handle.FD.fdToHandle1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.738925049 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile5_closure" {
     GHC.IO.Handle.FD.openBinaryFile5_closure:
         const GHC.IO.Handle.FD.openBinaryFile5_info;
         const 0;
 },
 sat_sbgYT_entry() //  [R1, R2]
         { info_tbl: [(cbhiP,
                       label: sat_sbgYT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhiP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhiT; else goto cbhiU;
       cbhiT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbhiU: // global
           I64[Sp - 16] = block_cbhiM_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubhiY; else goto cbhiN;
       ubhiY: // global
           call _cbhiM(R1) args: 0, res: 0, upd: 0;
       cbhiN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhiM() //  [R1]
         { info_tbl: [(cbhiM,
                       label: block_cbhiM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhiM: // global
           I64[Sp] = block_cbhiS_info;
           R2 = I64[R1 + 7];
           call GHC.IO.FD.$w$cclose_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhiS() //  []
         { info_tbl: [(cbhiS,
                       label: block_cbhiS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhiS: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbgYK_entry() //  [R1]
         { info_tbl: [(cbhj4,
                       label: sat_sbgYK_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhj4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbhj5; else goto cbhj6;
       cbhj5: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbhj6: // global
           R6 = GHC.Types.False_closure+1;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 39];
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile5_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbhj7,
                       label: GHC.IO.Handle.FD.openBinaryFile5_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhj7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbhj8; else goto cbhj9;
       cbhj8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile5_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbhj9: // global
           I64[Sp - 32] = block_cbhiv_info;
           _sbgYy::P64 = R4;
           R4 = R5;
           _sbgYx::P64 = R3;
           R3 = R3;
           _sbgYw::P64 = R2;
           R2 = R2;
           P64[Sp - 24] = _sbgYw::P64;
           P64[Sp - 16] = _sbgYx::P64;
           P64[Sp - 8] = _sbgYy::P64;
           Sp = Sp - 32;
           call GHC.IO.FD.openFile1_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhiv() //  [R1]
         { info_tbl: [(cbhiv,
                       label: block_cbhiv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhiv: // global
           I64[Sp] = block_cbhix_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubhjH; else goto cbhiy;
       ubhjH: // global
           call _cbhix(R1) args: 0, res: 0, upd: 0;
       cbhiy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhix() //  [R1]
         { info_tbl: [(cbhix,
                       label: block_cbhix_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhix: // global
           I64[Sp - 8] = block_cbhjb_info;
           _sbgYF::P64 = P64[R1 + 7];
           _sbgYG::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sbgYG::P64;
           P64[Sp + 24] = _sbgYF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubhjI; else goto cbhjg;
       ubhjI: // global
           call _cbhjb(R1) args: 0, res: 0, upd: 0;
       cbhjg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhjb() //  [R1]
         { info_tbl: [(cbhjb,
                       label: block_cbhjb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhjb: // global
           if (R1 & 7 == 1) goto cbhjn; else goto cbhjB;
       cbhjn: // global
           I64[Sp] = block_cbhjk_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubhjK; else goto cbhjo;
       ubhjK: // global
           call _cbhjk(R1) args: 0, res: 0, upd: 0;
       cbhjo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbhjB: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _cbhiF() args: 0, res: 0, upd: 0;
     }
 },
 _cbhjk() //  [R1]
         { info_tbl: [(cbhjk,
                       label: block_cbhjk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhjk: // global
           I64[Sp] = block_cbhjs_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhjs() //  [R1]
         { info_tbl: [(cbhjs,
                       label: block_cbhjs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhjs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbhjx; else goto cbhjw;
       cbhjx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhjw: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 6;
           call _cbhiF() args: 0, res: 0, upd: 0;
     }
 },
 _cbhiF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhiF: // global
           Hp = Hp + 64;
           _sbgYJ::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cbhjf; else goto cbhje;
       cbhjf: // global
           HpAlloc = 64;
           I64[Sp] = block_cbhiE_info;
           R1 = _sbgYJ::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhje: // global
           I64[Hp - 56] = sat_sbgYT_info;
           _sbgYF::P64 = P64[Sp + 32];
           P64[Hp - 48] = _sbgYF::P64;
           I64[Hp - 40] = sat_sbgYK_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sbgYF::P64;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sbgYJ::P64;
           R2 = Hp - 54;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbhiE() //  [R1]
         { info_tbl: [(cbhiE,
                       label: block_cbhiE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhiE: // global
           P64[Sp] = R1;
           call _cbhiF() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.762734044 UTC

[section ""data" . GHC.IO.Handle.FD.openFile2_closure" {
     GHC.IO.Handle.FD.openFile2_closure:
         const GHC.IO.Handle.FD.openFile2_info;
         const 0;
 },
 sat_sbgZe_entry() //  [R1]
         { info_tbl: [(cbhl4,
                       label: sat_sbgZe_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhl4: // global
           _sbgZe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbhl5; else goto cbhl6;
       cbhl6: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbhl8; else goto cbhl7;
       cbhl8: // global
           HpAlloc = 72;
           goto cbhl5;
       cbhl5: // global
           R1 = _sbgZe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhl7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbgZe::P64;
           _sbgZ2::P64 = P64[_sbgZe::P64 + 16];
           _sbgZ6::P64 = P64[_sbgZe::P64 + 24];
           _sbgZ7::P64 = P64[_sbgZe::P64 + 32];
           _sbgZ9::P64 = P64[_sbgZe::P64 + 40];
           _sbgZa::P64 = P64[_sbgZe::P64 + 48];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbgZ2::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = _sbgZ6::P64;
           P64[Hp - 32] = _sbgZ7::P64;
           P64[Hp - 24] = GHC.IO.Handle.FD.fdToHandle10_closure;
           P64[Hp - 16] = _sbgZ9::P64;
           P64[Hp - 8] = _sbgZa::P64;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.openFile2_entry() //  [R2, R3]
         { info_tbl: [(cbhl9,
                       label: GHC.IO.Handle.FD.openFile2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhl9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhla; else goto cbhlb;
       cbhla: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFile2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbhlb: // global
           I64[Sp - 16] = block_cbhkT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubhlf; else goto cbhkU;
       ubhlf: // global
           call _cbhkT(R1) args: 0, res: 0, upd: 0;
       cbhkU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhkT() //  [R1]
         { info_tbl: [(cbhkT,
                       label: block_cbhkT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhkT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbhle; else goto cbhld;
       cbhle: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhld: // global
           _sbgZ6::P64 = P64[R1 + 7];
           _sbgZ7::P64 = P64[R1 + 15];
           _sbgZ9::P64 = P64[R1 + 31];
           _sbgZa::P64 = P64[R1 + 39];
           I64[Hp - 48] = sat_sbgZe_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbgZ6::P64;
           P64[Hp - 16] = _sbgZ7::P64;
           P64[Hp - 8] = _sbgZ9::P64;
           P64[Hp] = _sbgZa::P64;
           R1 = Hp - 48;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.77328587 UTC

[section ""data" . GHC.IO.Handle.FD.openFile1_closure" {
     GHC.IO.Handle.FD.openFile1_closure:
         const GHC.IO.Handle.FD.openFile1_info;
         const 0;
 },
 sat_sbgZp_entry() //  [R1]
         { info_tbl: [(cbhm2,
                       label: sat_sbgZp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhm2: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbgZr_entry() //  [R1, R2]
         { info_tbl: [(cbhm5,
                       label: sat_sbgZr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhm5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbhm6; else goto cbhm7;
       cbhm6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbhm7: // global
           I64[Sp - 16] = block_cbhlK_info;
           _sbgZf::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbgZf::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubhmk; else goto cbhlL;
       ubhmk: // global
           call _cbhlK(R1) args: 0, res: 0, upd: 0;
       cbhlL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhlK() //  [R1]
         { info_tbl: [(cbhlK,
                       label: block_cbhlK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhlK: // global
           I64[Sp - 16] = block_cbhlP_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhlP() //  [R1]
         { info_tbl: [(cbhlP,
                       label: block_cbhlP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhlP: // global
           I64[Sp] = block_cbhlT_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhlT() //  [R1]
         { info_tbl: [(cbhlT,
                       label: block_cbhlT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhlT: // global
           if (R1 & 7 == 1) goto cbhmb; else goto cbhmi;
       cbhmb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbhme; else goto cbhmd;
       cbhme: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhmd: // global
           I64[Hp - 8] = sat_sbgZp_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbhmi: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbgZi_entry() //  [R1]
         { info_tbl: [(cbhmq,
                       label: sat_sbgZi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhmq: // global
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Types.False_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openFile1_entry() //  [R2, R3]
         { info_tbl: [(cbhmt,
                       label: GHC.IO.Handle.FD.openFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhmt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbhmx; else goto cbhmw;
       cbhmx: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbhmw: // global
           I64[Hp - 32] = sat_sbgZr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbgZi_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.788011698 UTC

[section ""data" . GHC.IO.Handle.FD.openFile_closure" {
     GHC.IO.Handle.FD.openFile_closure:
         const GHC.IO.Handle.FD.openFile_info;
         const 0;
 },
 GHC.IO.Handle.FD.openFile_entry() //  [R2, R3]
         { info_tbl: [(cbhnd,
                       label: GHC.IO.Handle.FD.openFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhnd: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.79244862 UTC

[section ""data" . GHC.IO.Handle.FD.openFileBlocking1_closure" {
     GHC.IO.Handle.FD.openFileBlocking1_closure:
         const GHC.IO.Handle.FD.openFileBlocking1_info;
         const 0;
 },
 sat_sbgZC_entry() //  [R1]
         { info_tbl: [(cbhnL,
                       label: sat_sbgZC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhnL: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbgZE_entry() //  [R1, R2]
         { info_tbl: [(cbhnO,
                       label: sat_sbgZE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhnO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbhnP; else goto cbhnQ;
       cbhnP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbhnQ: // global
           I64[Sp - 16] = block_cbhnt_info;
           _sbgZs::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbgZs::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubho3; else goto cbhnu;
       ubho3: // global
           call _cbhnt(R1) args: 0, res: 0, upd: 0;
       cbhnu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhnt() //  [R1]
         { info_tbl: [(cbhnt,
                       label: block_cbhnt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhnt: // global
           I64[Sp - 16] = block_cbhny_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhny() //  [R1]
         { info_tbl: [(cbhny,
                       label: block_cbhny_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhny: // global
           I64[Sp] = block_cbhnC_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhnC() //  [R1]
         { info_tbl: [(cbhnC,
                       label: block_cbhnC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhnC: // global
           if (R1 & 7 == 1) goto cbhnU; else goto cbho1;
       cbhnU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbhnX; else goto cbhnW;
       cbhnX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhnW: // global
           I64[Hp - 8] = sat_sbgZC_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbho1: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbgZv_entry() //  [R1]
         { info_tbl: [(cbho9,
                       label: sat_sbgZv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbho9: // global
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Types.False_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openFileBlocking1_entry() //  [R2, R3]
         { info_tbl: [(cbhoc,
                       label: GHC.IO.Handle.FD.openFileBlocking1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhoc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbhog; else goto cbhof;
       cbhog: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openFileBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbhof: // global
           I64[Hp - 32] = sat_sbgZE_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbgZv_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.807399675 UTC

[section ""data" . GHC.IO.Handle.FD.openFileBlocking_closure" {
     GHC.IO.Handle.FD.openFileBlocking_closure:
         const GHC.IO.Handle.FD.openFileBlocking_info;
         const 0;
 },
 GHC.IO.Handle.FD.openFileBlocking_entry() //  [R2, R3]
         { info_tbl: [(cbhoW,
                       label: GHC.IO.Handle.FD.openFileBlocking_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhoW: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openFileBlocking1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.811427602 UTC

[section ""cstring" . GHC.IO.Handle.FD.openBinaryFile4_bytes" {
     GHC.IO.Handle.FD.openBinaryFile4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.813380533 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile3_closure" {
     GHC.IO.Handle.FD.openBinaryFile3_closure:
         const GHC.IO.Handle.FD.openBinaryFile3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.openBinaryFile3_entry() //  [R1]
         { info_tbl: [(cbhpa,
                       label: GHC.IO.Handle.FD.openBinaryFile3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhpa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhpb; else goto cbhpc;
       cbhpb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhpc: // global
           (_cbhp7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbhp7::I64 == 0) goto cbhp9; else goto cbhp8;
       cbhp9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbhp8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbhp7::I64;
           R2 = GHC.IO.Handle.FD.openBinaryFile4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.817829655 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile2_closure" {
     GHC.IO.Handle.FD.openBinaryFile2_closure:
         const GHC.IO.Handle.FD.openBinaryFile2_info;
         const 0;
 },
 sat_sbgZR_entry() //  [R1]
         { info_tbl: [(cbhpA,
                       label: sat_sbgZR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhpA: // global
           _sbgZR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbhpB; else goto cbhpC;
       cbhpC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbhpE; else goto cbhpD;
       cbhpE: // global
           HpAlloc = 72;
           goto cbhpB;
       cbhpB: // global
           R1 = _sbgZR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhpD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbgZR::P64;
           _sbgZF::P64 = P64[_sbgZR::P64 + 16];
           _sbgZJ::P64 = P64[_sbgZR::P64 + 24];
           _sbgZK::P64 = P64[_sbgZR::P64 + 32];
           _sbgZM::P64 = P64[_sbgZR::P64 + 40];
           _sbgZN::P64 = P64[_sbgZR::P64 + 48];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbgZF::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = _sbgZJ::P64;
           P64[Hp - 32] = _sbgZK::P64;
           P64[Hp - 24] = GHC.IO.Handle.FD.openBinaryFile3_closure;
           P64[Hp - 16] = _sbgZM::P64;
           P64[Hp - 8] = _sbgZN::P64;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile2_entry() //  [R2, R3]
         { info_tbl: [(cbhpF,
                       label: GHC.IO.Handle.FD.openBinaryFile2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhpF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhpG; else goto cbhpH;
       cbhpG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbhpH: // global
           I64[Sp - 16] = block_cbhpp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubhpL; else goto cbhpq;
       ubhpL: // global
           call _cbhpp(R1) args: 0, res: 0, upd: 0;
       cbhpq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhpp() //  [R1]
         { info_tbl: [(cbhpp,
                       label: block_cbhpp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhpp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbhpK; else goto cbhpJ;
       cbhpK: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhpJ: // global
           _sbgZJ::P64 = P64[R1 + 7];
           _sbgZK::P64 = P64[R1 + 15];
           _sbgZM::P64 = P64[R1 + 31];
           _sbgZN::P64 = P64[R1 + 39];
           I64[Hp - 48] = sat_sbgZR_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sbgZJ::P64;
           P64[Hp - 16] = _sbgZK::P64;
           P64[Hp - 8] = _sbgZM::P64;
           P64[Hp] = _sbgZN::P64;
           R1 = Hp - 48;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.827181519 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile1_closure" {
     GHC.IO.Handle.FD.openBinaryFile1_closure:
         const GHC.IO.Handle.FD.openBinaryFile1_info;
         const 0;
 },
 sat_sbh02_entry() //  [R1]
         { info_tbl: [(cbhqy,
                       label: sat_sbh02_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhqy: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbh04_entry() //  [R1, R2]
         { info_tbl: [(cbhqB,
                       label: sat_sbh04_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhqB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbhqC; else goto cbhqD;
       cbhqC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbhqD: // global
           I64[Sp - 16] = block_cbhqg_info;
           _sbgZS::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sbgZS::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubhqQ; else goto cbhqh;
       ubhqQ: // global
           call _cbhqg(R1) args: 0, res: 0, upd: 0;
       cbhqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhqg() //  [R1]
         { info_tbl: [(cbhqg,
                       label: block_cbhqg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhqg: // global
           I64[Sp - 16] = block_cbhql_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhql() //  [R1]
         { info_tbl: [(cbhql,
                       label: block_cbhql_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhql: // global
           I64[Sp] = block_cbhqp_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbhqp() //  [R1]
         { info_tbl: [(cbhqp,
                       label: block_cbhqp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhqp: // global
           if (R1 & 7 == 1) goto cbhqH; else goto cbhqO;
       cbhqH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbhqK; else goto cbhqJ;
       cbhqK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhqJ: // global
           I64[Hp - 8] = sat_sbh02_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbhqO: // global
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 24];
           R1 = GHC.IO.Handle.FD.openBinaryFile2_closure+3;
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbgZV_entry() //  [R1]
         { info_tbl: [(cbhqW,
                       label: sat_sbgZV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhqW: // global
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Types.True_closure+2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.Handle.FD.openBinaryFile5_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.FD.openBinaryFile1_entry() //  [R2, R3]
         { info_tbl: [(cbhqZ,
                       label: GHC.IO.Handle.FD.openBinaryFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhqZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbhr3; else goto cbhr2;
       cbhr3: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.FD.openBinaryFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbhr2: // global
           I64[Hp - 32] = sat_sbh04_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sbgZV_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 31;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.841559801 UTC

[section ""data" . GHC.IO.Handle.FD.openBinaryFile_closure" {
     GHC.IO.Handle.FD.openBinaryFile_closure:
         const GHC.IO.Handle.FD.openBinaryFile_info;
         const 0;
 },
 GHC.IO.Handle.FD.openBinaryFile_entry() //  [R2, R3]
         { info_tbl: [(cbhrJ,
                       label: GHC.IO.Handle.FD.openBinaryFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhrJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.848674772 UTC

[section ""data" . $wstdHandleFinalizer_rbfCA_closure" {
     $wstdHandleFinalizer_rbfCA_closure:
         const $wstdHandleFinalizer_rbfCA_info;
         const 0;
 },
 sat_sbh0H_entry() //  [R1]
         { info_tbl: [(cbhsu,
                       label: sat_sbh0H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhsv; else goto cbhsw;
       cbhsv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhsw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbh0T_entry() //  [R1]
         { info_tbl: [(cbhsK,
                       label: sat_sbh0T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhsL; else goto cbhsM;
       cbhsL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhsM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbh16_entry() //  [R1]
         { info_tbl: [(cbht5,
                       label: sat_sbh16_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbht5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbht6; else goto cbht7;
       cbht6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbht7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbh1i_entry() //  [R1]
         { info_tbl: [(cbhtl,
                       label: sat_sbh1i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhtl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhtm; else goto cbhtn;
       cbhtm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhtn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbh1k_entry() //  [R1]
         { info_tbl: [(cbhtu,
                       label: sat_sbh1k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhtu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhtv; else goto cbhtw;
       cbhtv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhtw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.ioe_finalizedHandle_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wstdHandleFinalizer_rbfCA_entry() //  [R2, R3]
         { info_tbl: [(cbhtx,
                       label: $wstdHandleFinalizer_rbfCA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhtx: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbhty; else goto cbhtz;
       cbhty: // global
           R3 = R3;
           R2 = R2;
           R1 = $wstdHandleFinalizer_rbfCA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbhtz: // global
           I64[Sp - 24] = block_cbhrU_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhrU() //  [R1]
         { info_tbl: [(cbhrU,
                       label: block_cbhrU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhrU: // global
           I64[Sp] = block_cbhrW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubhv5; else goto cbhrX;
       ubhv5: // global
           call _cbhrW(R1) args: 0, res: 0, upd: 0;
       cbhrX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhrW() //  [R1]
         { info_tbl: [(cbhrW,
                       label: block_cbhrW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhrW: // global
           I64[Sp - 48] = block_cbhs1_info;
           _sbh0d::P64 = P64[R1 + 15];
           _sbh0f::P64 = P64[R1 + 31];
           _sbh0g::P64 = P64[R1 + 39];
           _sbh0h::P64 = P64[R1 + 47];
           _sbh0m::P64 = P64[R1 + 87];
           _sbh0n::P64 = P64[R1 + 95];
           R1 = P64[_sbh0h::P64 + 8];
           P64[Sp - 40] = _sbh0f::P64;
           P64[Sp - 32] = _sbh0g::P64;
           P64[Sp - 24] = _sbh0h::P64;
           P64[Sp - 16] = _sbh0m::P64;
           P64[Sp - 8] = _sbh0n::P64;
           P64[Sp] = _sbh0d::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ubhv6; else goto cbhs2;
       ubhv6: // global
           call _cbhs1(R1) args: 0, res: 0, upd: 0;
       cbhs2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhs1() //  [R1]
         { info_tbl: [(cbhs1,
                       label: block_cbhs1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhs1: // global
           I64[Sp] = block_cbhtC_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubhv7; else goto cbhuu;
       ubhv7: // global
           call _cbhtC(R1) args: 0, res: 0, upd: 0;
       cbhuu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhtC() //  [R1]
         { info_tbl: [(cbhtC,
                       label: block_cbhtC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhtC: // global
           if (R1 & 7 == 1) goto ubhv2; else goto cbhuF;
       ubhv2: // global
           Sp = Sp + 16;
           call _sbh0C() args: 0, res: 0, upd: 0;
       cbhuF: // global
           _sbh1p::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbhuD_info;
           R1 = _sbh1p::P64;
           if (R1 & 7 != 0) goto ubhve; else goto cbhuG;
       ubhve: // global
           call _cbhuD(R1) args: 0, res: 0, upd: 0;
       cbhuG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhuD() //  [R1]
         { info_tbl: [(cbhuD,
                       label: block_cbhuD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhuD: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubhv3; else goto cbhuQ;
       ubhv3: // global
           Sp = Sp + 16;
           call _sbh0C() args: 0, res: 0, upd: 0;
       cbhuQ: // global
           _sbh0f::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbhuO_info;
           R2 = P64[Sp + 48];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sbh0f::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbhuO() //  [R1]
         { info_tbl: [(cbhuO,
                       label: block_cbhuO_info
                       rep:StackRep [False, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhuO: // global
           _sbh0h::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbh0h::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbh0h::P64);
           Sp = Sp + 8;
           call _sbh0C() args: 0, res: 0, upd: 0;
     }
 },
 _sbh0C() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbh0C: // global
           I64[Sp + 8] = block_cbhsb_info;
           R1 = P64[Sp];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubhvi; else goto cbhsc;
       ubhvi: // global
           call _cbhsb(R1) args: 0, res: 0, upd: 0;
       cbhsc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhsb() //  [R1]
         { info_tbl: [(cbhsb,
                       label: block_cbhsb_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsb: // global
           if (R1 & 7 == 1) goto cbhuo; else goto cbhtH;
       cbhuo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbhur; else goto cbhuq;
       cbhur: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhuq: // global
           I64[Hp - 16] = sat_sbh1k_info;
           P64[Hp] = P64[Sp + 32];
           _sbh06::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbhun_info;
           R2 = Hp - 16;
           R1 = _sbh06::P64;
           Sp = Sp + 40;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbhtH: // global
           I64[Sp] = block_cbhsg_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubhv8; else goto cbhsh;
       ubhv8: // global
           call _cbhsg(R1) args: 0, res: 0, upd: 0;
       cbhsh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhsg() //  [R1]
         { info_tbl: [(cbhsg,
                       label: block_cbhsg_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsg: // global
           if (R1 & 7 == 1) goto cbhtK; else goto cbhu3;
       cbhtK: // global
           I64[Sp + 24] = block_cbhsl_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubhv9; else goto cbhsm;
       ubhv9: // global
           call _cbhsl(R1) args: 0, res: 0, upd: 0;
       cbhsm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbhu3: // global
           I64[Sp] = block_cbhsP_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubhva; else goto cbhsQ;
       ubhva: // global
           call _cbhsP(R1) args: 0, res: 0, upd: 0;
       cbhsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhsl() //  [R1]
         { info_tbl: [(cbhsl,
                       label: block_cbhsl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsl: // global
           if (R1 & 7 == 1) goto cbhtN; else goto cbhtV;
       cbhtN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbhtQ; else goto cbhtP;
       cbhtQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhtP: // global
           I64[Hp - 16] = sat_sbh0H_info;
           P64[Hp] = P64[Sp + 8];
           _sbh06::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbhun_info;
           R2 = Hp - 16;
           R1 = _sbh06::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbhtV: // global
           I64[Sp] = block_cbhsz_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubhvb; else goto cbhsA;
       ubhvb: // global
           call _cbhsz(R1) args: 0, res: 0, upd: 0;
       cbhsA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhsz() //  [R1]
         { info_tbl: [(cbhsz,
                       label: block_cbhsz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsz: // global
           I64[Sp] = block_cbhsE_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhsE() //  [R1]
         { info_tbl: [(cbhsE,
                       label: block_cbhsE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbhtZ; else goto cbhtY;
       cbhtZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhtY: // global
           I64[Hp - 16] = sat_sbh0T_info;
           P64[Hp] = P64[Sp + 8];
           _sbh06::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbhun_info;
           R2 = Hp - 16;
           R1 = _sbh06::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhsP() //  [R1]
         { info_tbl: [(cbhsP,
                       label: block_cbhsP_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsP: // global
           I64[Sp] = block_cbhsU_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhsU() //  []
         { info_tbl: [(cbhsU,
                       label: block_cbhsU_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsU: // global
           I64[Sp + 24] = block_cbhsW_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubhvc; else goto cbhsX;
       ubhvc: // global
           call _cbhsW(R1) args: 0, res: 0, upd: 0;
       cbhsX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhsW() //  [R1]
         { info_tbl: [(cbhsW,
                       label: block_cbhsW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhsW: // global
           if (R1 & 7 == 1) goto cbhu8; else goto cbhug;
       cbhu8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbhub; else goto cbhua;
       cbhub: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhua: // global
           I64[Hp - 16] = sat_sbh16_info;
           P64[Hp] = P64[Sp + 8];
           _sbh06::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbhun_info;
           R2 = Hp - 16;
           R1 = _sbh06::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
       cbhug: // global
           I64[Sp] = block_cbhta_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubhvd; else goto cbhtb;
       ubhvd: // global
           call _cbhta(R1) args: 0, res: 0, upd: 0;
       cbhtb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhta() //  [R1]
         { info_tbl: [(cbhta,
                       label: block_cbhta_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhta: // global
           I64[Sp] = block_cbhtf_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhtf() //  [R1]
         { info_tbl: [(cbhtf,
                       label: block_cbhtf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhtf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbhuk; else goto cbhuj;
       cbhuk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhuj: // global
           I64[Hp - 16] = sat_sbh1i_info;
           P64[Hp] = P64[Sp + 8];
           _sbh06::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbhun_info;
           R2 = Hp - 16;
           R1 = _sbh06::P64;
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhun() //  []
         { info_tbl: [(cbhun,
                       label: block_cbhun_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhun: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.895712562 UTC

[section ""data" . stdHandleFinalizer_rbfCB_closure" {
     stdHandleFinalizer_rbfCB_closure:
         const stdHandleFinalizer_rbfCB_info;
         const 0;
 },
 stdHandleFinalizer_rbfCB_entry() //  [R2, R3]
         { info_tbl: [(cbhxH,
                       label: stdHandleFinalizer_rbfCB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhxH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhxI; else goto cbhxJ;
       cbhxI: // global
           R3 = R3;
           R2 = R2;
           R1 = stdHandleFinalizer_rbfCB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbhxJ: // global
           I64[Sp - 16] = block_cbhxE_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubhxN; else goto cbhxF;
       ubhxN: // global
           call _cbhxE(R1) args: 0, res: 0, upd: 0;
       cbhxF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhxE() //  [R1]
         { info_tbl: [(cbhxE,
                       label: block_cbhxE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhxE: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wstdHandleFinalizer_rbfCA_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.901296623 UTC

[section ""cstring" . lvl6_rbfCC_bytes" {
     lvl6_rbfCC_bytes:
         I8[] [60,115,116,100,101,114,114,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.90313906 UTC

[section ""data" . lvl7_rbfCD_closure" {
     lvl7_rbfCD_closure:
         const lvl7_rbfCD_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rbfCD_entry() //  [R1]
         { info_tbl: [(cbhy5,
                       label: lvl7_rbfCD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhy5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhy6; else goto cbhy7;
       cbhy6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhy7: // global
           (_cbhy2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbhy2::I64 == 0) goto cbhy4; else goto cbhy3;
       cbhy4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbhy3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbhy2::I64;
           R2 = lvl6_rbfCC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.906826245 UTC

[section ""data" . lvl8_rbfCE_closure" {
     lvl8_rbfCE_closure:
         const GHC.Base.Just_con_info;
         const stdHandleFinalizer_rbfCB_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.908941001 UTC

[section ""data" . lvl9_rbfCF_closure" {
     lvl9_rbfCF_closure:
         const lvl9_rbfCF_info;
         const 0;
 },
 section ""relreadonly" . ubhyE_srtd" {
     ubhyE_srtd:
         const Sbh2A_srt+64;
         const 37;
         const 120259089281;
 },
 lvl9_rbfCF_entry() //  []
         { info_tbl: [(cbhyq,
                       label: lvl9_rbfCF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhyq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbhyr; else goto cbhys;
       cbhyr: // global
           R1 = lvl9_rbfCF_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbhys: // global
           I64[Sp - 8] = block_cbhyl_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubhyF_srtd" {
     ubhyF_srtd:
         const Sbh2A_srt+64;
         const 36;
         const 51539612545;
 },
 _cbhyl() //  []
         { info_tbl: [(cbhyl,
                       label: block_cbhyl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhyl: // global
           I64[Sp] = block_cbhyn_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubhyD; else goto cbhyo;
       ubhyD: // global
           call _cbhyn(R1) args: 0, res: 0, upd: 0;
       cbhyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubhyG_srtd" {
     ubhyG_srtd:
         const Sbh2A_srt+64;
         const 36;
         const 51539608449;
 },
 _cbhyn() //  [R1]
         { info_tbl: [(cbhyn,
                       label: block_cbhyn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhyn: // global
           I64[Sp] = block_cbhyw_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubhyH_srtd" {
     ubhyH_srtd:
         const Sbh2A_srt+64;
         const 36;
         const 51539608449;
 },
 _cbhyw() //  [R1]
         { info_tbl: [(cbhyw,
                       label: block_cbhyw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhyw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbhyB; else goto cbhyA;
       cbhyB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhyA: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl7_rbfCD_closure;
           R5 = GHC.IO.FD.stderr_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 32] = GHC.Types.False_closure+1;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.921700576 UTC

[section ""data" . GHC.IO.Handle.FD.stderr_closure" {
     GHC.IO.Handle.FD.stderr_closure:
         const GHC.IO.Handle.FD.stderr_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stderr_entry() //  [R1]
         { info_tbl: [(cbhzm,
                       label: GHC.IO.Handle.FD.stderr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhzm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbhzn; else goto cbhzo;
       cbhzn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhzo: // global
           (_cbhzh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbhzh::I64 == 0) goto cbhzj; else goto cbhzi;
       cbhzj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbhzi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbhzh::I64;
           I64[Sp - 24] = block_cbhzk_info;
           Sp = Sp - 24;
           call lvl9_rbfCF_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbhzk() //  [R1]
         { info_tbl: [(cbhzk,
                       label: block_cbhzk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhzk: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.927506519 UTC

[section ""cstring" . lvl10_rbfCG_bytes" {
     lvl10_rbfCG_bytes:
         I8[] [60,115,116,100,111,117,116,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.929329638 UTC

[section ""data" . lvl11_rbfCH_closure" {
     lvl11_rbfCH_closure:
         const lvl11_rbfCH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rbfCH_entry() //  [R1]
         { info_tbl: [(cbhzL,
                       label: lvl11_rbfCH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhzL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhzM; else goto cbhzN;
       cbhzM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhzN: // global
           (_cbhzI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbhzI::I64 == 0) goto cbhzK; else goto cbhzJ;
       cbhzK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbhzJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbhzI::I64;
           R2 = lvl10_rbfCG_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.933755644 UTC

[section ""data" . lvl12_rbfCI_closure" {
     lvl12_rbfCI_closure:
         const lvl12_rbfCI_info;
         const 0;
 },
 section ""relreadonly" . ubhAj_srtd" {
     ubhAj_srtd:
         const Sbh2A_srt+64;
         const 39;
         const 446676603777;
 },
 lvl12_rbfCI_entry() //  []
         { info_tbl: [(cbhA5,
                       label: lvl12_rbfCI_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhA5: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbhA6; else goto cbhA7;
       cbhA6: // global
           R1 = lvl12_rbfCI_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbhA7: // global
           I64[Sp - 8] = block_cbhA0_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubhAk_srtd" {
     ubhAk_srtd:
         const Sbh2A_srt+64;
         const 38;
         const 171798696833;
 },
 _cbhA0() //  []
         { info_tbl: [(cbhA0,
                       label: block_cbhA0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhA0: // global
           I64[Sp] = block_cbhA2_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubhAi; else goto cbhA3;
       ubhAi: // global
           call _cbhA2(R1) args: 0, res: 0, upd: 0;
       cbhA3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubhAl_srtd" {
     ubhAl_srtd:
         const Sbh2A_srt+64;
         const 38;
         const 171798692737;
 },
 _cbhA2() //  [R1]
         { info_tbl: [(cbhA2,
                       label: block_cbhA2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhA2: // global
           I64[Sp] = block_cbhAb_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubhAm_srtd" {
     ubhAm_srtd:
         const Sbh2A_srt+64;
         const 38;
         const 171798692737;
 },
 _cbhAb() //  [R1]
         { info_tbl: [(cbhAb,
                       label: block_cbhAb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhAb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbhAg; else goto cbhAf;
       cbhAg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhAf: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl11_rbfCH_closure;
           R5 = GHC.IO.FD.stdout_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 32] = GHC.Types.True_closure+2;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.945557666 UTC

[section ""data" . GHC.IO.Handle.FD.stdout_closure" {
     GHC.IO.Handle.FD.stdout_closure:
         const GHC.IO.Handle.FD.stdout_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stdout_entry() //  [R1]
         { info_tbl: [(cbhB1,
                       label: GHC.IO.Handle.FD.stdout_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhB1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbhB2; else goto cbhB3;
       cbhB2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhB3: // global
           (_cbhAW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbhAW::I64 == 0) goto cbhAY; else goto cbhAX;
       cbhAY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbhAX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbhAW::I64;
           I64[Sp - 24] = block_cbhAZ_info;
           Sp = Sp - 24;
           call lvl12_rbfCI_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbhAZ() //  [R1]
         { info_tbl: [(cbhAZ,
                       label: block_cbhAZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhAZ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.950909826 UTC

[section ""cstring" . lvl13_rbfCJ_bytes" {
     lvl13_rbfCJ_bytes:
         I8[] [60,115,116,100,105,110,62]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.952758882 UTC

[section ""data" . lvl14_rbfCK_closure" {
     lvl14_rbfCK_closure:
         const lvl14_rbfCK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_rbfCK_entry() //  [R1]
         { info_tbl: [(cbhBq,
                       label: lvl14_rbfCK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhBq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbhBr; else goto cbhBs;
       cbhBr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhBs: // global
           (_cbhBn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbhBn::I64 == 0) goto cbhBp; else goto cbhBo;
       cbhBp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbhBo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbhBn::I64;
           R2 = lvl13_rbfCJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.957883528 UTC

[section ""data" . lvl15_rbfCL_closure" {
     lvl15_rbfCL_closure:
         const lvl15_rbfCL_info;
         const 0;
 },
 section ""relreadonly" . ubhBY_srtd" {
     ubhBY_srtd:
         const Sbh2A_srt+64;
         const 41;
         const 1683627185025;
 },
 lvl15_rbfCL_entry() //  []
         { info_tbl: [(cbhBK,
                       label: lvl15_rbfCL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhBK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbhBL; else goto cbhBM;
       cbhBL: // global
           R1 = lvl15_rbfCL_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbhBM: // global
           I64[Sp - 8] = block_cbhBF_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubhBZ_srtd" {
     ubhBZ_srtd:
         const Sbh2A_srt+64;
         const 40;
         const 584115557249;
 },
 _cbhBF() //  []
         { info_tbl: [(cbhBF,
                       label: block_cbhBF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhBF: // global
           I64[Sp] = block_cbhBH_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubhBX; else goto cbhBI;
       ubhBX: // global
           call _cbhBH(R1) args: 0, res: 0, upd: 0;
       cbhBI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubhC0_srtd" {
     ubhC0_srtd:
         const Sbh2A_srt+64;
         const 40;
         const 584115553153;
 },
 _cbhBH() //  [R1]
         { info_tbl: [(cbhBH,
                       label: block_cbhBH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhBH: // global
           I64[Sp] = block_cbhBQ_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubhC1_srtd" {
     ubhC1_srtd:
         const Sbh2A_srt+64;
         const 40;
         const 584115553153;
 },
 _cbhBQ() //  [R1]
         { info_tbl: [(cbhBQ,
                       label: block_cbhBQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhBQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbhBV; else goto cbhBU;
       cbhBV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhBU: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R6 = lvl14_rbfCK_closure;
           R5 = GHC.IO.FD.stdin_closure;
           R4 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R3 = GHC.IO.FD.$fBufferedIOFD_closure;
           R2 = GHC.IO.FD.$fIODeviceFD_closure;
           P64[Sp - 40] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 32] = GHC.Types.True_closure+2;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = GHC.IO.Handle.Types.nativeNewlineMode_closure;
           P64[Sp - 8] = lvl8_rbfCE_closure+2;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.970187035 UTC

[section ""data" . GHC.IO.Handle.FD.stdin_closure" {
     GHC.IO.Handle.FD.stdin_closure:
         const GHC.IO.Handle.FD.stdin_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.FD.stdin_entry() //  [R1]
         { info_tbl: [(cbhCG,
                       label: GHC.IO.Handle.FD.stdin_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhCG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbhCH; else goto cbhCI;
       cbhCH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhCI: // global
           (_cbhCB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbhCB::I64 == 0) goto cbhCD; else goto cbhCC;
       cbhCD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbhCC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbhCB::I64;
           I64[Sp - 24] = block_cbhCE_info;
           Sp = Sp - 24;
           call lvl15_rbfCL_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbhCE() //  [R1]
         { info_tbl: [(cbhCE,
                       label: block_cbhCE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhCE: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:13.975536681 UTC

[section ""relreadonly" . Sbh2A_srt" {
     Sbh2A_srt:
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl1_rbfCv_closure;
         const lvl3_rbfCx_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const lvl5_rbfCz_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd1_closure;
         const GHC.IO.Handle.FD.fdToHandle7_closure;
         const Foreign.C.Error.throwErrnoIfMinus1Retry2_closure;
         const System.Posix.Internals.setNonBlockingFD3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.IO.FD.$fBufferedIOFD_closure;
         const GHC.IO.FD.$fIODeviceFD_closure;
         const GHC.IO.Handle.FD.fdToHandle5_closure;
         const GHC.IO.Handle.FD.fdToHandle6_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.Handle.FD.fdToHandle'1_closure;
         const GHC.IO.Handle.FD.fdToHandle2_closure;
         const System.Posix.Internals.$wfdGetMode_closure;
         const GHC.IO.Handle.FD.$wfdToHandle_closure;
         const GHC.IO.Handle.FD.fdToHandle1_closure;
         const GHC.IO.FD.$w$cclose_closure;
         const GHC.IO.FD.openFile1_closure;
         const GHC.IO.Handle.FD.openBinaryFile5_closure;
         const GHC.IO.Handle.FD.fdToHandle10_closure;
         const GHC.IO.Handle.FD.openFile2_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.FD.openFile1_closure;
         const GHC.IO.Handle.FD.openFileBlocking1_closure;
         const GHC.IO.Handle.FD.openBinaryFile3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.FD.openBinaryFile2_closure;
         const GHC.IO.Handle.FD.openBinaryFile1_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const $wstdHandleFinalizer_rbfCA_closure;
         const stdHandleFinalizer_rbfCB_closure;
         const lvl7_rbfCD_closure;
         const lvl8_rbfCE_closure;
         const lvl9_rbfCF_closure;
         const lvl11_rbfCH_closure;
         const lvl12_rbfCI_closure;
         const lvl14_rbfCK_closure;
         const lvl15_rbfCL_closure;
 }]

