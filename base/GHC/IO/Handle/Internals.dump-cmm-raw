
==================== Raw Cmm ====================
2018-03-16 16:05:07.229169818 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:05:07.23306769 UTC

[section ""data" . GHC.IO.Handle.Internals.augmentIOError_closure" {
     GHC.IO.Handle.Internals.augmentIOError_closure:
         const GHC.IO.Handle.Internals.augmentIOError_info;
 },
 sat_sa7Q2_entry() //  [R1]
         { []
         }
     {offset
       caaL6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caaL7; else goto caaL8;
       caaL7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaL8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caaKZ_info;
           _sa7PL::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sa7PL::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaaLz; else goto caaL0;
       uaaLz: // global
           call _caaKZ(R1) args: 0, res: 0, upd: 0;
       caaL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Q2_info" {
     sat_sa7Q2_info:
         const sat_sa7Q2_entry;
         const 2;
         const 18;
 },
 _caaKZ() //  [R1]
         { []
         }
     {offset
       caaKZ: // global
           if (R1 & 7 == 1) goto caaL3; else goto caaL4;
       caaL3: // global
           _sa7PL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caaLb_info;
           R1 = _sa7PL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaaLy; else goto caaLd;
       uaaLy: // global
           call _caaLb(R1) args: 0, res: 0, upd: 0;
       caaLd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caaL4: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caaKZ_info" {
     block_caaKZ_info:
         const _caaKZ;
         const 1;
         const 30;
 },
 _caaLb() //  [R1]
         { []
         }
     {offset
       caaLb: // global
           if (R1 & 7 == 1) goto caaLj; else goto caaLq;
       caaLj: // global
           Hp = Hp + 16;
           _sa7PV::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caaLt; else goto caaLl;
       caaLl: // global
           _sa7PW::P64 = P64[_sa7PV::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa7PW::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caaLq: // global
           Hp = Hp + 16;
           _sa7PV::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caaLt; else goto caaLs;
       caaLt: // global
           HpAlloc = 16;
           R1 = _sa7PV::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caaLs: // global
           _sa7PY::P64 = P64[_sa7PV::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa7PY::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caaLb_info" {
     block_caaLb_info:
         const _caaLb;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.augmentIOError_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caaLA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaLD; else goto caaLE;
       caaLD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.augmentIOError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaLE: // global
           I64[Sp - 24] = block_caaKQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaaLI; else goto caaKR;
       uaaLI: // global
           call _caaKQ(R1) args: 0, res: 0, upd: 0;
       caaKR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.augmentIOError_info" {
     GHC.IO.Handle.Internals.augmentIOError_info:
         const GHC.IO.Handle.Internals.augmentIOError_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _caaKQ() //  [R1]
         { []
         }
     {offset
       caaKQ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caaLH; else goto caaLG;
       caaLH: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaLG: // global
           _sa7PO::P64 = P64[R1 + 15];
           _sa7PQ::P64 = P64[R1 + 31];
           _sa7PR::P64 = P64[R1 + 39];
           _sa7PS::P64 = P64[R1 + 47];
           I64[Hp - 96] = sat_sa7Q2_info;
           _sa7PL::P64 = P64[Sp + 16];
           P64[Hp - 80] = _sa7PL::P64;
           P64[Hp - 72] = _sa7PS::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa7PL::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sa7PO::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sa7PQ::P64;
           P64[Hp - 8] = _sa7PR::P64;
           P64[Hp] = Hp - 96;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caaKQ_info" {
     block_caaKQ_info:
         const _caaKQ;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.247420023 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle14_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle14_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,99,108,111,115,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.249948451 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle13_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle13_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle13_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle13_entry() //  [R1]
         { []
         }
     {offset
       caaMn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaMo; else goto caaMp;
       caaMo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaMp: // global
           (_caaMk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaMk::I64 == 0) goto caaMm; else goto caaMl;
       caaMm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaMl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaMk::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle14_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle13_info" {
     GHC.IO.Handle.Internals.wantReadableHandle13_info:
         const GHC.IO.Handle.Internals.wantReadableHandle13_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.253416871 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle12_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle12_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle13_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.255724082 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle11_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle11_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle11_entry() //  [R1]
         { []
         }
     {offset
       caaME: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaMF; else goto caaMG;
       caaMF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaMG: // global
           (_caaMB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaMB::I64 == 0) goto caaMD; else goto caaMC;
       caaMD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaMC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaMB::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle12_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle11_info" {
     GHC.IO.Handle.Internals.wantReadableHandle11_info:
         const GHC.IO.Handle.Internals.wantReadableHandle11_entry;
         const 0;
         const 12884901909;
         const Sa8nI_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.259537269 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle1_entry() //  []
         { []
         }
     {offset
       caaMS: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_closedHandle1_info" {
     GHC.IO.Handle.Internals.ioe_closedHandle1_info:
         const GHC.IO.Handle.Internals.ioe_closedHandle1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.262891586 UTC

[section ""data" . ioe_closedHandle2_ra7Pb_closure" {
     ioe_closedHandle2_ra7Pb_closure:
         const ioe_closedHandle2_ra7Pb_info;
         const 0;
 },
 ioe_closedHandle2_ra7Pb_entry() //  []
         { []
         }
     {offset
       caaN3: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_closedHandle2_ra7Pb_info" {
     ioe_closedHandle2_ra7Pb_info:
         const ioe_closedHandle2_ra7Pb_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.266475124 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle_entry() //  []
         { []
         }
     {offset
       caaNe: // global
           call ioe_closedHandle2_ra7Pb_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_closedHandle_info" {
     GHC.IO.Handle.Internals.ioe_closedHandle_info:
         const GHC.IO.Handle.Internals.ioe_closedHandle_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.270897965 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle10_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle10_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.273059866 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle9_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle9_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle9_entry() //  [R1]
         { []
         }
     {offset
       caaNs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaNt; else goto caaNu;
       caaNt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaNu: // global
           (_caaNp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaNp::I64 == 0) goto caaNr; else goto caaNq;
       caaNr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaNq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaNp::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle9_info" {
     GHC.IO.Handle.Internals.wantReadableHandle9_info:
         const GHC.IO.Handle.Internals.wantReadableHandle9_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.277117153 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle8_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle9_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.279406593 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle7_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle7_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle7_entry() //  [R1]
         { []
         }
     {offset
       caaNJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaNK; else goto caaNL;
       caaNK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaNL: // global
           (_caaNG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaNG::I64 == 0) goto caaNI; else goto caaNH;
       caaNI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaNH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaNG::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle7_info" {
     GHC.IO.Handle.Internals.wantReadableHandle7_info:
         const GHC.IO.Handle.Internals.wantReadableHandle7_entry;
         const 0;
         const 73014444053;
         const Sa8nI_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.283422086 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() //  []
         { []
         }
     {offset
       caaNX: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.286638884 UTC

[section ""data" . ioe_semiclosedHandle2_ra7Pc_closure" {
     ioe_semiclosedHandle2_ra7Pc_closure:
         const ioe_semiclosedHandle2_ra7Pc_info;
         const 0;
 },
 ioe_semiclosedHandle2_ra7Pc_entry() //  []
         { []
         }
     {offset
       caaO8: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_semiclosedHandle2_ra7Pc_info" {
     ioe_semiclosedHandle2_ra7Pc_info:
         const ioe_semiclosedHandle2_ra7Pc_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.289854088 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle_entry() //  []
         { []
         }
     {offset
       caaOj: // global
           call ioe_semiclosedHandle2_ra7Pc_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_semiclosedHandle_info" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle_info:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.292877844 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_4_closure" {
     GHC.IO.Handle.Internals.hLookAhead_4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.295490604 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_3_closure" {
     GHC.IO.Handle.Internals.hLookAhead_3_closure:
         const GHC.IO.Handle.Internals.hLookAhead_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_3_entry() //  [R1]
         { []
         }
     {offset
       caaOx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaOy; else goto caaOz;
       caaOy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaOz: // global
           (_caaOu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaOu::I64 == 0) goto caaOw; else goto caaOv;
       caaOw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaOv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaOu::I64;
           R2 = GHC.IO.Handle.Internals.hLookAhead_4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hLookAhead_3_info" {
     GHC.IO.Handle.Internals.hLookAhead_3_info:
         const GHC.IO.Handle.Internals.hLookAhead_3_entry;
         const 0;
         const 4294967317;
         const Sa8nI_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.29920074 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF1_closure" {
     GHC.IO.Handle.Internals.ioe_EOF1_closure:
         const GHC.IO.Handle.Internals.ioe_EOF1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF1_entry() //  []
         { []
         }
     {offset
       caaOL: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_EOF1_info" {
     GHC.IO.Handle.Internals.ioe_EOF1_info:
         const GHC.IO.Handle.Internals.ioe_EOF1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.303015824 UTC

[section ""data" . ioe_EOF2_ra7Pd_closure" {
     ioe_EOF2_ra7Pd_closure:
         const ioe_EOF2_ra7Pd_info;
         const 0;
 },
 ioe_EOF2_ra7Pd_entry() //  []
         { []
         }
     {offset
       caaOW: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_EOF2_ra7Pd_info" {
     ioe_EOF2_ra7Pd_info:
         const ioe_EOF2_ra7Pd_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.306630226 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF_closure" {
     GHC.IO.Handle.Internals.ioe_EOF_closure:
         const GHC.IO.Handle.Internals.ioe_EOF_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF_entry() //  []
         { []
         }
     {offset
       caaP7: // global
           call ioe_EOF2_ra7Pd_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_EOF_info" {
     GHC.IO.Handle.Internals.ioe_EOF_info:
         const GHC.IO.Handle.Internals.ioe_EOF_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.309646271 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,114,101,97,100,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.311874209 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle5_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle5_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle5_entry() //  [R1]
         { []
         }
     {offset
       caaPl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaPm; else goto caaPn;
       caaPm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaPn: // global
           (_caaPi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaPi::I64 == 0) goto caaPk; else goto caaPj;
       caaPk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaPj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaPi::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle5_info" {
     GHC.IO.Handle.Internals.wantReadableHandle5_info:
         const GHC.IO.Handle.Internals.wantReadableHandle5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.315497757 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle4_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.318164901 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle3_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle3_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle3_entry() //  [R1]
         { []
         }
     {offset
       caaPC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaPD; else goto caaPE;
       caaPD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaPE: // global
           (_caaPz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaPz::I64 == 0) goto caaPB; else goto caaPA;
       caaPB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaPA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaPz::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle3_info" {
     GHC.IO.Handle.Internals.wantReadableHandle3_info:
         const GHC.IO.Handle.Internals.wantReadableHandle3_entry;
         const 0;
         const 2203318222869;
         const Sa8nI_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.321861508 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable1_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable1_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable1_entry() //  []
         { []
         }
     {offset
       caaPQ: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_notReadable1_info" {
     GHC.IO.Handle.Internals.ioe_notReadable1_info:
         const GHC.IO.Handle.Internals.ioe_notReadable1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.325105041 UTC

[section ""data" . ioe_notReadable2_ra7Pe_closure" {
     ioe_notReadable2_ra7Pe_closure:
         const ioe_notReadable2_ra7Pe_info;
         const 0;
 },
 ioe_notReadable2_ra7Pe_entry() //  []
         { []
         }
     {offset
       caaQ1: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_notReadable2_ra7Pe_info" {
     ioe_notReadable2_ra7Pe_info:
         const ioe_notReadable2_ra7Pe_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.328206818 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable_entry() //  []
         { []
         }
     {offset
       caaQc: // global
           call ioe_notReadable2_ra7Pe_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_notReadable_info" {
     GHC.IO.Handle.Internals.ioe_notReadable_info:
         const GHC.IO.Handle.Internals.ioe_notReadable_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.331638925 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantWritableHandle5_bytes" {
     GHC.IO.Handle.Internals.wantWritableHandle5_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,119,114,105,116,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.334233848 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle4_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle4_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle4_entry() //  [R1]
         { []
         }
     {offset
       caaQq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaQr; else goto caaQs;
       caaQr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaQs: // global
           (_caaQn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaQn::I64 == 0) goto caaQp; else goto caaQo;
       caaQp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaQo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaQn::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantWritableHandle4_info" {
     GHC.IO.Handle.Internals.wantWritableHandle4_info:
         const GHC.IO.Handle.Internals.wantWritableHandle4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.337848161 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle3_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantWritableHandle4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.340074331 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle2_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle2_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle2_entry() //  [R1]
         { []
         }
     {offset
       caaQH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaQI; else goto caaQJ;
       caaQI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaQJ: // global
           (_caaQE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaQE::I64 == 0) goto caaQG; else goto caaQF;
       caaQG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaQF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaQE::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantWritableHandle2_info" {
     GHC.IO.Handle.Internals.wantWritableHandle2_info:
         const GHC.IO.Handle.Internals.wantWritableHandle2_entry;
         const 0;
         const 17596481011733;
         const Sa8nI_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.343845972 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable1_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable1_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable1_entry() //  []
         { []
         }
     {offset
       caaQV: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_notWritable1_info" {
     GHC.IO.Handle.Internals.ioe_notWritable1_info:
         const GHC.IO.Handle.Internals.ioe_notWritable1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.34764299 UTC

[section ""data" . ioe_notWritable2_ra7Pf_closure" {
     ioe_notWritable2_ra7Pf_closure:
         const ioe_notWritable2_ra7Pf_info;
         const 0;
 },
 ioe_notWritable2_ra7Pf_entry() //  []
         { []
         }
     {offset
       caaR6: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_notWritable2_ra7Pf_info" {
     ioe_notWritable2_ra7Pf_info:
         const ioe_notWritable2_ra7Pf_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.350818321 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable_entry() //  []
         { []
         }
     {offset
       caaRh: // global
           call ioe_notWritable2_ra7Pf_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_notWritable_info" {
     GHC.IO.Handle.Internals.ioe_notWritable_info:
         const GHC.IO.Handle.Internals.ioe_notWritable_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Sa8nI_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.353818998 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantSeekableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantSeekableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.355981709 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle5_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle5_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle5_entry() //  [R1]
         { []
         }
     {offset
       caaRv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaRw; else goto caaRx;
       caaRw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaRx: // global
           (_caaRs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaRs::I64 == 0) goto caaRu; else goto caaRt;
       caaRu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaRt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaRs::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle5_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle5_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.360003385 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle4_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.36277842 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle3_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle3_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle3_entry() //  [R1]
         { []
         }
     {offset
       caaRM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaRN; else goto caaRO;
       caaRN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaRO: // global
           (_caaRJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaRJ::I64 == 0) goto caaRL; else goto caaRK;
       caaRL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaRK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaRJ::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle3_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle3_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle3_entry;
         const 0;
         const 140741783322645;
         const Sa8nI_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.366364975 UTC

[section ""cstring" . GHC.IO.Handle.Internals.flushBuffer6_bytes" {
     GHC.IO.Handle.Internals.flushBuffer6_bytes:
         I8[] [99,97,110,110,111,116,32,102,108,117,115,104,32,116,104,101,32,114,101,97,100,32,98,117,102,102,101,114,58,32,117,110,100,101,114,108,121,105,110,103,32,100,101,118,105,99,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.368509774 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer5_closure" {
     GHC.IO.Handle.Internals.flushBuffer5_closure:
         const GHC.IO.Handle.Internals.flushBuffer5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer5_entry() //  [R1]
         { []
         }
     {offset
       caaS3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaS4; else goto caaS5;
       caaS4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaS5: // global
           (_caaS0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaS0::I64 == 0) goto caaS2; else goto caaS1;
       caaS2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaS1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaS0::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer5_info" {
     GHC.IO.Handle.Internals.flushBuffer5_info:
         const GHC.IO.Handle.Internals.flushBuffer5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.372428699 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer4_closure" {
     GHC.IO.Handle.Internals.flushBuffer4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.flushBuffer5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.374743583 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer3_closure" {
     GHC.IO.Handle.Internals.flushBuffer3_closure:
         const GHC.IO.Handle.Internals.flushBuffer3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer3_entry() //  [R1]
         { []
         }
     {offset
       caaSk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaSl; else goto caaSm;
       caaSl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaSm: // global
           (_caaSh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaSh::I64 == 0) goto caaSj; else goto caaSi;
       caaSj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaSi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaSh::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer3_info" {
     GHC.IO.Handle.Internals.flushBuffer3_info:
         const GHC.IO.Handle.Internals.flushBuffer3_entry;
         const 0;
         const 281479271677973;
         const Sa8nI_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.378292686 UTC

[section ""cstring" . lvl_ra7Pg_bytes" {
     lvl_ra7Pg_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.380528553 UTC

[section ""data" . lvl1_ra7Ph_closure" {
     lvl1_ra7Ph_closure:
         const lvl1_ra7Ph_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra7Ph_entry() //  [R1]
         { []
         }
     {offset
       caaSB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaSC; else goto caaSD;
       caaSC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaSD: // global
           (_caaSy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaSy::I64 == 0) goto caaSA; else goto caaSz;
       caaSA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaSz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaSy::I64;
           R2 = lvl_ra7Pg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_ra7Ph_info" {
     lvl1_ra7Ph_info:
         const lvl1_ra7Ph_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.384341241 UTC

[section ""cstring" . lvl2_ra7Pi_bytes" {
     lvl2_ra7Pi_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.388141974 UTC

[section ""data" . GHC.IO.Handle.Internals.$wioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.$wioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.$wioe_bufsiz_info;
         const 0;
 },
 sat_sa7Qi_entry() //  [R1]
         { []
         }
     {offset
       caaT5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaT6; else goto caaT7;
       caaT6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaT7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caaT2_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Qi_info" {
     sat_sa7Qi_info:
         const sat_sa7Qi_entry;
         const 4294967296;
         const 17;
 },
 _caaT2() //  [R1, R2]
         { []
         }
     {offset
       caaT2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaTa; else goto caaT9;
       caaTa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       caaT9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caaT2_info" {
     block_caaT2_info:
         const _caaT2;
         const 0;
         const 30;
 },
 sat_sa7Qj_entry() //  [R1]
         { []
         }
     {offset
       caaTb: // global
           _sa7Qj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaTc; else goto caaTd;
       caaTd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaTf; else goto caaTe;
       caaTf: // global
           HpAlloc = 24;
           goto caaTc;
       caaTc: // global
           R1 = _sa7Qj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaTe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Qj::P64;
           _sa7Qd::I64 = I64[_sa7Qj::P64 + 16];
           I64[Hp - 16] = sat_sa7Qi_info;
           I64[Hp] = _sa7Qd::I64;
           R3 = Hp - 16;
           R2 = lvl2_ra7Pi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Qj_info" {
     sat_sa7Qj_info:
         const sat_sa7Qj_entry;
         const 4294967296;
         const 17;
 },
 sat_sa7Ql_entry() //  [R1]
         { []
         }
     {offset
       caaTh: // global
           _sa7Ql::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caaTi; else goto caaTj;
       caaTj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caaTl; else goto caaTk;
       caaTl: // global
           HpAlloc = 80;
           goto caaTi;
       caaTi: // global
           R1 = _sa7Ql::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaTk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Ql::P64;
           _sa7Qd::I64 = I64[_sa7Ql::P64 + 16];
           I64[Hp - 72] = sat_sa7Qj_info;
           I64[Hp - 56] = _sa7Qd::I64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = lvl1_ra7Ph_closure;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Ql_info" {
     sat_sa7Ql_info:
         const sat_sa7Ql_entry;
         const 4294967296;
         const 562954248388625;
         const Sa8nI_srt;
 },
 GHC.IO.Handle.Internals.$wioe_bufsiz_entry() //  [R2]
         { []
         }
     {offset
       caaTm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaTq; else goto caaTp;
       caaTq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaTp: // global
           I64[Hp - 16] = sat_sa7Ql_info;
           I64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wioe_bufsiz_info" {
     GHC.IO.Handle.Internals.$wioe_bufsiz_info:
         const GHC.IO.Handle.Internals.$wioe_bufsiz_entry;
         const 0;
         const 1688854155231246;
         const 8589934596;
         const Sa8nI_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.399939035 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz1_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz1_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz1_entry() //  [R2]
         { []
         }
     {offset
       caaTT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caaTU; else goto caaTV;
       caaTU: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaTV: // global
           I64[Sp - 8] = block_caaTQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaaTZ; else goto caaTR;
       uaaTZ: // global
           call _caaTQ(R1) args: 0, res: 0, upd: 0;
       caaTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_bufsiz1_info" {
     GHC.IO.Handle.Internals.ioe_bufsiz1_info:
         const GHC.IO.Handle.Internals.ioe_bufsiz1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Sa8nI_srt+144;
 },
 _caaTQ() //  [R1]
         { []
         }
     {offset
       caaTQ: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caaTQ_info" {
     block_caaTQ_info:
         const _caaTQ;
         const 0;
         const 4294967326;
         const Sa8nI_srt+144;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.404779362 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz_entry() //  [R2]
         { []
         }
     {offset
       caaUd: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.ioe_bufsiz1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_bufsiz_info" {
     GHC.IO.Handle.Internals.ioe_bufsiz_info:
         const GHC.IO.Handle.Internals.ioe_bufsiz_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Sa8nI_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.411164515 UTC

[section ""data" . GHC.IO.Handle.Internals.$wstreamEncode_closure" {
     GHC.IO.Handle.Internals.$wstreamEncode_closure:
         const GHC.IO.Handle.Internals.$wstreamEncode_info;
 },
 GHC.IO.Handle.Internals.$wstreamEncode_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caaUq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caaUr; else goto caaUs;
       caaUr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wstreamEncode_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caaUs: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _caaUu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wstreamEncode_info" {
     GHC.IO.Handle.Internals.$wstreamEncode_info:
         const GHC.IO.Handle.Internals.$wstreamEncode_entry;
         const 0;
         const 14;
         const 21474836504;
 },
 _caaUu() //  []
         { []
         }
     {offset
       caaUu: // global
           I64[Sp - 8] = block_caaUw_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caaUw() //  [R1]
         { []
         }
     {offset
       caaUw: // global
           I64[Sp] = block_caaUy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaVu; else goto caaUB;
       uaaVu: // global
           call _caaUy(R1) args: 0, res: 0, upd: 0;
       caaUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaUw_info" {
     block_caaUw_info:
         const _caaUw;
         const 516;
         const 30;
 },
 _caaUy() //  [R1]
         { []
         }
     {offset
       caaUy: // global
           I64[Sp - 8] = block_caaUF_info;
           _sa7QE::P64 = P64[R1 + 15];
           _sa7QF::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa7QF::P64;
           P64[Sp + 32] = _sa7QE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaaVv; else goto caaUH;
       uaaVv: // global
           call _caaUF(R1) args: 0, res: 0, upd: 0;
       caaUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaUy_info" {
     block_caaUy_info:
         const _caaUy;
         const 516;
         const 30;
 },
 _caaUF() //  [R1]
         { []
         }
     {offset
       caaUF: // global
           if (R1 & 7 == 3) goto caaV0; else goto caaUN;
       caaV0: // global
           I64[Sp] = block_caaUT_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto uaaVw; else goto caaUU;
       uaaVw: // global
           call _caaUT(R1) args: 0, res: 0, upd: 0;
       caaUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caaUN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaUQ; else goto caaUP;
       caaUQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaUP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caaUF_info" {
     block_caaUF_info:
         const _caaUF;
         const 5;
         const 30;
 },
 _caaUT() //  [R1]
         { []
         }
     {offset
       caaUT: // global
           I64[Sp] = block_caaUY_info;
           _sa7QN::I64 = I64[R1 + 39];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sa7QN::I64;
           if (R1 & 7 != 0) goto uaaVx; else goto caaV2;
       uaaVx: // global
           call _caaUY(R1) args: 0, res: 0, upd: 0;
       caaV2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaUT_info" {
     block_caaUT_info:
         const _caaUT;
         const 517;
         const 30;
 },
 _caaUY() //  [R1]
         { []
         }
     {offset
       caaUY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caaV8; else goto caaV7;
       caaV8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaV7: // global
           _sa7QF::P64 = P64[Sp + 8];
           if (I64[Sp + 40] == I64[R1 + 39]) goto caaVj; else goto caaVe;
       caaVj: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_caaVg_info;
           R3 = _sa7QF::P64;
           R2 = R1;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       caaVe: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sa7QF::P64;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caaUY_info" {
     block_caaUY_info:
         const _caaUY;
         const 1541;
         const 30;
 },
 _caaVg() //  [R1]
         { []
         }
     {offset
       caaVg: // global
           I64[Sp] = block_caaVi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaaVy; else goto caaVl;
       uaaVy: // global
           call _caaVi(R1) args: 0, res: 0, upd: 0;
       caaVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaVg_info" {
     block_caaVg_info:
         const _caaVg;
         const 772;
         const 30;
 },
 _caaVi() //  [R1]
         { []
         }
     {offset
       caaVi: // global
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 8;
           call _caaUu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caaVi_info" {
     block_caaVi_info:
         const _caaVi;
         const 772;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.426582195 UTC

[section ""data" . GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure" {
     GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure:
         const GHC.Types.I#_con_info;
         const 2048;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.42914617 UTC

[section ""data" . GHC.IO.Handle.Internals.initBufferState_closure" {
     GHC.IO.Handle.Internals.initBufferState_closure:
         const GHC.IO.Handle.Internals.initBufferState_info;
 },
 GHC.IO.Handle.Internals.initBufferState_entry() //  [R2]
         { []
         }
     {offset
       caaWs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caaWt; else goto caaWu;
       caaWt: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.initBufferState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaWu: // global
           I64[Sp - 8] = block_caaWl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaaWB; else goto caaWm;
       uaaWB: // global
           call _caaWl(R1) args: 0, res: 0, upd: 0;
       caaWm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.initBufferState_info" {
     GHC.IO.Handle.Internals.initBufferState_info:
         const GHC.IO.Handle.Internals.initBufferState_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _caaWl() //  [R1]
         { []
         }
     {offset
       caaWl: // global
           if (R1 & 7 == 3) goto caaWq; else goto caaWp;
       caaWq: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caaWp: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caaWl_info" {
     block_caaWl_info:
         const _caaWl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.435994286 UTC

[section ""data" . lvl3_ra7Pj_closure" {
     lvl3_ra7Pj_closure:
         const lvl3_ra7Pj_info;
 },
 lvl3_ra7Pj_entry() //  []
         { []
         }
     {offset
       caaX2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaX5; else goto caaX6;
       caaX5: // global
           R1 = lvl3_ra7Pj_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaX6: // global
           I64[Sp - 8] = block_caaWT_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl3_ra7Pj_info" {
     lvl3_ra7Pj_info:
         const lvl3_ra7Pj_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _caaWT() //  []
         { []
         }
     {offset
       caaWT: // global
           I64[Sp] = block_caaWV_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaWT_info" {
     block_caaWT_info:
         const _caaWT;
         const 0;
         const 30;
 },
 _caaWV() //  [R1]
         { []
         }
     {offset
       caaWV: // global
           I64[Sp - 8] = block_caaWX_info;
           _sa7Ra::P64 = R1;
           R1 = 4;
           P64[Sp] = _sa7Ra::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaWV_info" {
     block_caaWV_info:
         const _caaWV;
         const 0;
         const 30;
 },
 _caaWX() //  [R1]
         { []
         }
     {offset
       caaWX: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caaXb; else goto caaXa;
       caaXb: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaXa: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caaWX_info" {
     block_caaWX_info:
         const _caaWX;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.444280106 UTC

[section ""data" . GHC.IO.Handle.Internals.noCharBuffer_closure" {
     GHC.IO.Handle.Internals.noCharBuffer_closure:
         const GHC.IO.Handle.Internals.noCharBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noCharBuffer_entry() //  [R1]
         { []
         }
     {offset
       caaXC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaXD; else goto caaXE;
       caaXD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaXE: // global
           (_caaXx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaXx::I64 == 0) goto caaXz; else goto caaXy;
       caaXz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaXy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaXx::I64;
           I64[Sp - 24] = block_caaXA_info;
           Sp = Sp - 24;
           call lvl3_ra7Pj_entry() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.noCharBuffer_info" {
     GHC.IO.Handle.Internals.noCharBuffer_info:
         const GHC.IO.Handle.Internals.noCharBuffer_entry;
         const 0;
         const 21;
 },
 _caaXA() //  [R1]
         { []
         }
     {offset
       caaXA: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caaXA_info" {
     block_caaXA_info:
         const _caaXA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.450465545 UTC

[section ""data" . lvl4_ra7Pk_closure" {
     lvl4_ra7Pk_closure:
         const lvl4_ra7Pk_info;
 },
 lvl4_ra7Pk_entry() //  []
         { []
         }
     {offset
       caaY5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaY8; else goto caaY9;
       caaY8: // global
           R1 = lvl4_ra7Pk_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caaY9: // global
           I64[Sp - 8] = block_caaXW_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl4_ra7Pk_info" {
     lvl4_ra7Pk_info:
         const lvl4_ra7Pk_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _caaXW() //  []
         { []
         }
     {offset
       caaXW: // global
           I64[Sp] = block_caaXY_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaXW_info" {
     block_caaXW_info:
         const _caaXW;
         const 0;
         const 30;
 },
 _caaXY() //  [R1]
         { []
         }
     {offset
       caaXY: // global
           I64[Sp - 8] = block_caaY0_info;
           _sa7Ro::P64 = R1;
           R1 = 1;
           P64[Sp] = _sa7Ro::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaXY_info" {
     block_caaXY_info:
         const _caaXY;
         const 0;
         const 30;
 },
 _caaY0() //  [R1]
         { []
         }
     {offset
       caaY0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caaYe; else goto caaYd;
       caaYe: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caaYd: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caaY0_info" {
     block_caaY0_info:
         const _caaY0;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.458852035 UTC

[section ""data" . GHC.IO.Handle.Internals.noByteBuffer_closure" {
     GHC.IO.Handle.Internals.noByteBuffer_closure:
         const GHC.IO.Handle.Internals.noByteBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noByteBuffer_entry() //  [R1]
         { []
         }
     {offset
       caaYF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caaYG; else goto caaYH;
       caaYG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaYH: // global
           (_caaYA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaYA::I64 == 0) goto caaYC; else goto caaYB;
       caaYC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaYB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaYA::I64;
           I64[Sp - 24] = block_caaYD_info;
           Sp = Sp - 24;
           call lvl4_ra7Pk_entry() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.noByteBuffer_info" {
     GHC.IO.Handle.Internals.noByteBuffer_info:
         const GHC.IO.Handle.Internals.noByteBuffer_entry;
         const 0;
         const 21;
 },
 _caaYD() //  [R1]
         { []
         }
     {offset
       caaYD: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caaYD_info" {
     block_caaYD_info:
         const _caaYD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.463511204 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule4_bytes" {
     GHC.IO.Handle.Internals.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.465218975 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule3_closure" {
     GHC.IO.Handle.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.467340379 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule2_bytes" {
     GHC.IO.Handle.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.469057643 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule1_closure" {
     GHC.IO.Handle.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.471063946 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule_closure" {
     GHC.IO.Handle.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Internals.$trModule3_closure+1;
         const GHC.IO.Handle.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.472695409 UTC

[section ""cstring" . lvl5_ra7Pl_bytes" {
     lvl5_ra7Pl_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,102,105,110,97,108,105,122,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.47498348 UTC

[section ""data" . lvl6_ra7Pm_closure" {
     lvl6_ra7Pm_closure:
         const lvl6_ra7Pm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra7Pm_entry() //  [R1]
         { []
         }
     {offset
       caaZ7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaZ8; else goto caaZ9;
       caaZ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaZ9: // global
           (_caaZ4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caaZ4::I64 == 0) goto caaZ6; else goto caaZ5;
       caaZ6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caaZ5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caaZ4::I64;
           R2 = lvl5_ra7Pl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl6_ra7Pm_info" {
     lvl6_ra7Pm_info:
         const lvl6_ra7Pm_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.479021925 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_finalizedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_finalizedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_finalizedHandle_entry() //  [R2]
         { []
         }
     {offset
       caaZn: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caaZr; else goto caaZq;
       caaZr: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaZq: // global
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = lvl6_ra7Pm_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_finalizedHandle_info" {
     GHC.IO.Handle.Internals.ioe_finalizedHandle_info:
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const Sa8nI_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.487617925 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs1_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs1_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs1_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs1_entry() //  [R2]
         { []
         }
     {offset
       caaZE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaZF; else goto caaZG;
       caaZF: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.closeTextCodecs1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caaZG: // global
           I64[Sp - 8] = block_caaZB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab0L; else goto caaZC;
       uab0L: // global
           call _caaZB(R1) args: 0, res: 0, upd: 0;
       caaZC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.closeTextCodecs1_info" {
     GHC.IO.Handle.Internals.closeTextCodecs1_info:
         const GHC.IO.Handle.Internals.closeTextCodecs1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _caaZB() //  [R1]
         { []
         }
     {offset
       caaZB: // global
           I64[Sp - 8] = block_caaZJ_info;
           _sa7RO::P64 = P64[R1 + 87];
           R1 = P64[R1 + 95];
           P64[Sp] = _sa7RO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab0K; else goto caaZL;
       uab0K: // global
           call _caaZJ(R1) args: 0, res: 0, upd: 0;
       caaZL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaZB_info" {
     block_caaZB_info:
         const _caaZB;
         const 0;
         const 30;
 },
 _caaZJ() //  [R1]
         { []
         }
     {offset
       caaZJ: // global
           if (R1 & 7 == 1) goto caaZS; else goto cab0e;
       caaZS: // global
           _sa7RO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caaZP_info;
           R1 = _sa7RO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uab0M; else goto caaZT;
       uab0M: // global
           call _caaZP(R1) args: 0, res: 0, upd: 0;
       caaZT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cab0e: // global
           I64[Sp] = block_cab0c_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab0N; else goto cab0f;
       uab0N: // global
           call _cab0c(R1) args: 0, res: 0, upd: 0;
       cab0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaZJ_info" {
     block_caaZJ_info:
         const _caaZJ;
         const 1;
         const 30;
 },
 _caaZP() //  [R1]
         { []
         }
     {offset
       caaZP: // global
           if (R1 & 7 == 1) goto uab0J; else goto cab04;
       uab0J: // global
           Sp = Sp + 8;
           call _cab0u() args: 0, res: 0, upd: 0;
       cab04: // global
           I64[Sp] = block_cab02_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab0O; else goto cab05;
       uab0O: // global
           call _cab02(R1) args: 0, res: 0, upd: 0;
       cab05: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caaZP_info" {
     block_caaZP_info:
         const _caaZP;
         const 0;
         const 30;
 },
 _cab02() //  [R1]
         { []
         }
     {offset
       cab02: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab02_info" {
     block_cab02_info:
         const _cab02;
         const 0;
         const 30;
 },
 _cab0c() //  [R1]
         { []
         }
     {offset
       cab0c: // global
           I64[Sp] = block_cab0j_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab0c_info" {
     block_cab0c_info:
         const _cab0c;
         const 1;
         const 30;
 },
 _cab0j() //  []
         { []
         }
     {offset
       cab0j: // global
           _sa7RO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cab0l_info;
           R1 = _sa7RO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uab0Q; else goto cab0o;
       uab0Q: // global
           call _cab0l(R1) args: 0, res: 0, upd: 0;
       cab0o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab0j_info" {
     block_cab0j_info:
         const _cab0j;
         const 1;
         const 30;
 },
 _cab0l() //  [R1]
         { []
         }
     {offset
       cab0l: // global
           if (R1 & 7 == 1) goto uab0I; else goto cab0z;
       uab0I: // global
           Sp = Sp + 8;
           call _cab0u() args: 0, res: 0, upd: 0;
       cab0z: // global
           I64[Sp] = block_cab0x_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab0R; else goto cab0A;
       uab0R: // global
           call _cab0x(R1) args: 0, res: 0, upd: 0;
       cab0A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab0l_info" {
     block_cab0l_info:
         const _cab0l;
         const 0;
         const 30;
 },
 _cab0u() //  []
         { []
         }
     {offset
       cab0u: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cab0x() //  [R1]
         { []
         }
     {offset
       cab0x: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab0x_info" {
     block_cab0x_info:
         const _cab0x;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.504833508 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs_entry() //  [R2]
         { []
         }
     {offset
       cab1G: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.closeTextCodecs1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.closeTextCodecs_info" {
     GHC.IO.Handle.Internals.closeTextCodecs_info:
         const GHC.IO.Handle.Internals.closeTextCodecs_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.513039554 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding1_closure" {
     GHC.IO.Handle.Internals.openTextEncoding1_closure:
         const GHC.IO.Handle.Internals.openTextEncoding1_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cab1Y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cab1Z; else goto cab20;
       cab1Z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.openTextEncoding1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cab20: // global
           I64[Sp - 24] = block_cab1R_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uab3w; else goto cab1S;
       uab3w: // global
           call _cab1R(R1) args: 0, res: 0, upd: 0;
       cab1S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.openTextEncoding1_info" {
     GHC.IO.Handle.Internals.openTextEncoding1_info:
         const GHC.IO.Handle.Internals.openTextEncoding1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _cab1R() //  [R1]
         { []
         }
     {offset
       cab1R: // global
           if (R1 & 7 == 1) goto cab1V; else goto cab1W;
       cab1V: // global
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cab1W: // global
           I64[Sp] = block_cab26_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab3v; else goto cab28;
       uab3v: // global
           call _cab26(R1) args: 0, res: 0, upd: 0;
       cab28: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab1R_info" {
     block_cab1R_info:
         const _cab1R;
         const 2;
         const 30;
 },
 _cab26() //  [R1]
         { []
         }
     {offset
       cab26: // global
           I64[Sp - 16] = block_cab2e_info;
           _sa7St::P64 = P64[R1 + 15];
           _sa7Su::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _sa7Su::P64;
           P64[Sp] = _sa7St::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uab3x; else goto cab2W;
       uab3x: // global
           call _cab2e(R1) args: 0, res: 0, upd: 0;
       cab2W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab26_info" {
     block_cab26_info:
         const _cab26;
         const 2;
         const 30;
 },
 _cab2e() //  [R1]
         { []
         }
     {offset
       cab2e: // global
           _sa7St::P64 = P64[Sp + 16];
           _cab3l::P64 = R1 & 7;
           if (_cab3l::P64 != 3) goto uab3p; else goto cab37;
       uab3p: // global
           if (_cab3l::P64 != 6) goto cab32; else goto cab3g;
       cab32: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
       cab3g: // global
           I64[Sp] = block_cab3e_info;
           R1 = _sa7St::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cab37: // global
           I64[Sp] = block_cab35_info;
           R1 = _sa7St::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab2e_info" {
     block_cab2e_info:
         const _cab2e;
         const 4;
         const 30;
 },
 _cab3e() //  [R1]
         { []
         }
     {offset
       cab3e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab3k; else goto cab3j;
       cab3k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab3j: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cab3e_info" {
     block_cab3e_info:
         const _cab3e;
         const 132;
         const 30;
 },
 _cab35() //  [R1]
         { []
         }
     {offset
       cab35: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab3b; else goto cab3a;
       cab3b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab3a: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Sv() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cab35_info" {
     block_cab35_info:
         const _cab35;
         const 132;
         const 30;
 },
 _sa7Sv() //  []
         { []
         }
     {offset
       sa7Sv: // global
           I64[Sp - 8] = block_cab2j_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab3B; else goto cab2l;
       uab3B: // global
           call _cab2j(R1) args: 0, res: 0, upd: 0;
       cab2l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab2j() //  [R1]
         { []
         }
     {offset
       cab2j: // global
           _sa7Su::P64 = P64[Sp + 8];
           _cab3o::P64 = R1 & 7;
           if (_cab3o::P64 < 5) goto uab3q; else goto uab3r;
       uab3q: // global
           if (_cab3o::P64 < 4) goto cab2r; else goto cab2y;
       cab2r: // global
           R3 = P64[Sp + 16];
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cab2y: // global
           I64[Sp + 8] = block_cab2u_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       uab3r: // global
           if (_cab3o::P64 < 6) goto cab2I; else goto cab2S;
       cab2I: // global
           I64[Sp + 8] = block_cab2E_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cab2S: // global
           I64[Sp + 8] = block_cab2O_info;
           R1 = _sa7Su::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab2j_info" {
     block_cab2j_info:
         const _cab2j;
         const 260;
         const 30;
 },
 _cab2u() //  [R1]
         { []
         }
     {offset
       cab2u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab2B; else goto cab2A;
       cab2B: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab2A: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab2u_info" {
     block_cab2u_info:
         const _cab2u;
         const 131;
         const 30;
 },
 _cab2E() //  [R1]
         { []
         }
     {offset
       cab2E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab2L; else goto cab2K;
       cab2L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab2K: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab2E_info" {
     block_cab2E_info:
         const _cab2E;
         const 131;
         const 30;
 },
 _cab2O() //  [R1]
         { []
         }
     {offset
       cab2O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cab2V; else goto cab2U;
       cab2V: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab2U: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab2O_info" {
     block_cab2O_info:
         const _cab2O;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.532468206 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding_closure" {
     GHC.IO.Handle.Internals.openTextEncoding_closure:
         const GHC.IO.Handle.Internals.openTextEncoding_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cab4o: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.openTextEncoding1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.openTextEncoding_info" {
     GHC.IO.Handle.Internals.openTextEncoding_info:
         const GHC.IO.Handle.Internals.openTextEncoding_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.537373655 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry() //  [R2]
         { []
         }
     {offset
       cab4C: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cab4G; else goto cab4H;
       cab4G: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cab4H: // global
           I64[Sp - 8] = block_cab4z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab51; else goto cab4A;
       uab51: // global
           call _cab4z(R1) args: 0, res: 0, upd: 0;
       cab4A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushByteWriteBuffer1_info" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer1_info:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cab4z() //  [R1]
         { []
         }
     {offset
       cab4z: // global
           I64[Sp - 24] = block_cab4F_info;
           _sa7SY::P64 = P64[R1 + 15];
           _sa7T0::P64 = P64[R1 + 31];
           _sa7T2::P64 = P64[R1 + 47];
           R1 = P64[_sa7T2::P64 + 8];
           P64[Sp - 16] = _sa7T0::P64;
           P64[Sp - 8] = _sa7T2::P64;
           P64[Sp] = _sa7SY::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uab50; else goto cab4J;
       uab50: // global
           call _cab4F(R1) args: 0, res: 0, upd: 0;
       cab4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab4z_info" {
     block_cab4z_info:
         const _cab4z;
         const 0;
         const 30;
 },
 _cab4F() //  [R1]
         { []
         }
     {offset
       cab4F: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cab4W; else goto cab4T;
       cab4W: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cab4T: // global
           _sa7T0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cab4R_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7T0::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab4F_info" {
     block_cab4F_info:
         const _cab4F;
         const 3;
         const 30;
 },
 _cab4R() //  [R1]
         { []
         }
     {offset
       cab4R: // global
           _sa7T2::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7T2::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7T2::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab4R_info" {
     block_cab4R_info:
         const _cab4R;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.547102228 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer_entry() //  [R2]
         { []
         }
     {offset
       cab5q: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushByteWriteBuffer_info" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer_info:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.552302133 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer1_entry() //  [R2]
         { []
         }
     {offset
       cab5E: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cab5I; else goto cab5J;
       cab5I: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cab5J: // global
           I64[Sp - 8] = block_cab5B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uab6o; else goto cab5C;
       uab6o: // global
           call _cab5B(R1) args: 0, res: 0, upd: 0;
       cab5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushWriteBuffer1_info" {
     GHC.IO.Handle.Internals.flushWriteBuffer1_info:
         const GHC.IO.Handle.Internals.flushWriteBuffer1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cab5B() //  [R1]
         { []
         }
     {offset
       cab5B: // global
           I64[Sp - 24] = block_cab5H_info;
           _sa7Tw::P64 = P64[R1 + 15];
           _sa7Ty::P64 = P64[R1 + 31];
           _sa7TA::P64 = P64[R1 + 47];
           R1 = P64[_sa7TA::P64 + 8];
           P64[Sp - 16] = _sa7Ty::P64;
           P64[Sp - 8] = _sa7TA::P64;
           P64[Sp] = _sa7Tw::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uab6n; else goto cab5L;
       uab6n: // global
           call _cab5H(R1) args: 0, res: 0, upd: 0;
       cab5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab5B_info" {
     block_cab5B_info:
         const _cab5B;
         const 0;
         const 30;
 },
 _cab5H() //  [R1]
         { []
         }
     {offset
       cab5H: // global
           I64[Sp] = block_cab5P_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uab6p; else goto cab5R;
       uab6p: // global
           call _cab5P(R1) args: 0, res: 0, upd: 0;
       cab5R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab5H_info" {
     block_cab5H_info:
         const _cab5H;
         const 3;
         const 30;
 },
 _cab5P() //  [R1]
         { []
         }
     {offset
       cab5P: // global
           if (R1 & 7 == 1) goto uab6l; else goto cab62;
       uab6l: // global
           Sp = Sp + 32;
           call _cab6g() args: 0, res: 0, upd: 0;
       cab62: // global
           _sa7TY::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cab60_info;
           R1 = _sa7TY::P64;
           if (R1 & 7 != 0) goto uab6q; else goto cab63;
       uab6q: // global
           call _cab60(R1) args: 0, res: 0, upd: 0;
       cab63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab5P_info" {
     block_cab5P_info:
         const _cab5P;
         const 3;
         const 30;
 },
 _cab60() //  [R1]
         { []
         }
     {offset
       cab60: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uab6m; else goto cab6d;
       uab6m: // global
           Sp = Sp + 32;
           call _cab6g() args: 0, res: 0, upd: 0;
       cab6d: // global
           _sa7Ty::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cab6b_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7Ty::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab60_info" {
     block_cab60_info:
         const _cab60;
         const 3;
         const 30;
 },
 _cab6g() //  []
         { []
         }
     {offset
       cab6g: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cab6b() //  [R1]
         { []
         }
     {offset
       cab6b: // global
           _sa7TA::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7TA::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7TA::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab6b_info" {
     block_cab6b_info:
         const _cab6b;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.564548852 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer_entry() //  [R2]
         { []
         }
     {offset
       cab74: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushWriteBuffer_info" {
     GHC.IO.Handle.Internals.flushWriteBuffer_info:
         const GHC.IO.Handle.Internals.flushWriteBuffer_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.567702014 UTC

[section ""cstring" . lvl7_ra7Pn_bytes" {
     lvl7_ra7Pn_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.5700736 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf2_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf2_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf2_entry() //  [R1]
         { []
         }
     {offset
       cab7k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cab7l; else goto cab7m;
       cab7l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cab7m: // global
           (_cab7f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cab7f::I64 == 0) goto cab7h; else goto cab7g;
       cab7h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cab7g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cab7f::I64;
           I64[Sp - 24] = block_cab7i_info;
           R2 = lvl7_ra7Pn_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.decodeByteBuf2_info" {
     GHC.IO.Handle.Internals.decodeByteBuf2_info:
         const GHC.IO.Handle.Internals.decodeByteBuf2_entry;
         const 0;
         const 4294967317;
         const Sa8nI_srt+184;
 },
 _cab7i() //  [R1]
         { []
         }
     {offset
       cab7i: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cab7i_info" {
     block_cab7i_info:
         const _cab7i;
         const 0;
         const 4294967326;
         const Sa8nI_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.578729383 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf1_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf1_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf1_entry() //  [R2, R3]
         { []
         }
     {offset
       cab7H: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cab7I; else goto cab7J;
       cab7I: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.decodeByteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cab7J: // global
           I64[Sp - 16] = block_cab7E_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uab8K; else goto cab7F;
       uab8K: // global
           call _cab7E(R1) args: 0, res: 0, upd: 0;
       cab7F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.decodeByteBuf1_info" {
     GHC.IO.Handle.Internals.decodeByteBuf1_info:
         const GHC.IO.Handle.Internals.decodeByteBuf1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const Sa8nI_srt+192;
 },
 _cab7E() //  [R1]
         { []
         }
     {offset
       cab7E: // global
           I64[Sp - 24] = block_cab7M_info;
           _sa7Ul::P64 = P64[R1 + 47];
           _sa7Un::P64 = P64[R1 + 63];
           R1 = P64[R1 + 95];
           P64[Sp - 16] = _sa7Un::P64;
           P64[Sp - 8] = P64[_sa7Ul::P64 + 8];
           P64[Sp] = _sa7Ul::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uab8J; else goto cab7O;
       uab8J: // global
           call _cab7M(R1) args: 0, res: 0, upd: 0;
       cab7O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab7E_info" {
     block_cab7E_info:
         const _cab7E;
         const 1;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cab7M() //  [R1]
         { []
         }
     {offset
       cab7M: // global
           if (R1 & 7 == 1) goto cab80; else goto cab8r;
       cab80: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cab83; else goto cab82;
       cab83: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab82: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sa7Uy::P64 = P64[Sp + 16];
           P64[Hp] = _sa7Uy::P64;
           _sa7Ud::P64 = P64[Sp + 32];
           _sa7Un::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Un::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Un::P64);
           I64[Sp + 16] = block_cab7W_info;
           R3 = _sa7Ud::P64;
           R2 = _sa7Uy::P64;
           Sp = Sp + 16;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cab8r: // global
           I64[Sp] = block_cab8c_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uab8L; else goto cab8d;
       uab8L: // global
           call _cab8c(R1) args: 0, res: 0, upd: 0;
       cab8d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab7M_info" {
     block_cab7M_info:
         const _cab7M;
         const 4;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cab7W() //  [R1]
         { []
         }
     {offset
       cab7W: // global
           I64[Sp] = block_cab7Y_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uab8M; else goto cab85;
       uab8M: // global
           call _cab7Y(R1) args: 0, res: 0, upd: 0;
       cab85: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab7W_info" {
     block_cab7W_info:
         const _cab7W;
         const 130;
         const 30;
 },
 _cab7Y() //  [R1]
         { []
         }
     {offset
       cab7Y: // global
           _sa7Ul::P64 = P64[Sp + 8];
           _sa7UH::P64 = P64[R1 + 15];
           _sa7UI::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sa7Ul::P64 + 8] = _sa7UH::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Ul::P64);
           R1 = _sa7UI::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab7Y_info" {
     block_cab7Y_info:
         const _cab7Y;
         const 130;
         const 30;
 },
 _cab8c() //  [R1]
         { []
         }
     {offset
       cab8c: // global
           I64[Sp - 16] = block_cab8h_info;
           _sa7UM::P64 = P64[R1 + 7];
           _sa7UN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sa7UN::P64;
           P64[Sp] = _sa7UM::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab8c_info" {
     block_cab8c_info:
         const _cab8c;
         const 4;
         const 30;
 },
 _cab8h() //  [R1]
         { []
         }
     {offset
       cab8h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cab8v; else goto cab8u;
       cab8v: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cab8u: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa7Uy::P64 = P64[Sp + 32];
           P64[Hp] = _sa7Uy::P64;
           _sa7Ud::P64 = P64[Sp + 48];
           _sa7Un::P64 = P64[Sp + 24];
           _sa7UM::P64 = P64[Sp + 16];
           _sa7UN::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Un::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Un::P64);
           I64[Sp + 32] = block_cab8n_info;
           R5 = _sa7Ud::P64;
           R4 = _sa7Uy::P64;
           R3 = _sa7UN::P64;
           R2 = _sa7UM::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab8h_info" {
     block_cab8h_info:
         const _cab8h;
         const 6;
         const 30;
 },
 _cab8n() //  [R1]
         { []
         }
     {offset
       cab8n: // global
           I64[Sp] = block_cab8p_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uab8N; else goto cab8x;
       uab8N: // global
           call _cab8p(R1) args: 0, res: 0, upd: 0;
       cab8x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab8n_info" {
     block_cab8n_info:
         const _cab8n;
         const 130;
         const 30;
 },
 _cab8p() //  [R1]
         { []
         }
     {offset
       cab8p: // global
           _sa7Ul::P64 = P64[Sp + 8];
           _sa7V0::P64 = P64[R1 + 7];
           _sa7V1::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa7Ul::P64 + 8] = _sa7V0::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Ul::P64);
           R1 = _sa7V1::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab8p_info" {
     block_cab8p_info:
         const _cab8p;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.596497402 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf_entry() //  [R2, R3]
         { []
         }
     {offset
       cab9B: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.decodeByteBuf_info" {
     GHC.IO.Handle.Internals.decodeByteBuf_info:
         const GHC.IO.Handle.Internals.decodeByteBuf_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Sa8nI_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.60207045 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry() //  [R2,
                                                                 R3]
         { []
         }
     {offset
       cab9P: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cab9T; else goto cab9U;
       cab9T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cab9U: // global
           I64[Sp - 16] = block_cab9M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabay; else goto cab9N;
       uabay: // global
           call _cab9M(R1) args: 0, res: 0, upd: 0;
       cab9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry;
         const 0;
         const 2814754062073870;
         const 12884901903;
         const Sa8nI_srt+56;
 },
 _cab9M() //  [R1]
         { []
         }
     {offset
       cab9M: // global
           I64[Sp - 32] = block_cab9S_info;
           _sa7V6::P64 = R1;
           _sa7V8::P64 = P64[R1 + 15];
           _sa7Va::P64 = P64[R1 + 31];
           _sa7Vc::P64 = P64[R1 + 47];
           R1 = P64[_sa7Vc::P64 + 8];
           P64[Sp - 24] = _sa7V8::P64;
           P64[Sp - 16] = _sa7Va::P64;
           P64[Sp - 8] = _sa7Vc::P64;
           P64[Sp] = _sa7V6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabax; else goto cab9W;
       uabax: // global
           call _cab9S(R1) args: 0, res: 0, upd: 0;
       cab9W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cab9M_info" {
     block_cab9M_info:
         const _cab9M;
         const 1;
         const 562954248388638;
         const Sa8nI_srt+56;
 },
 _cab9S() //  [R1]
         { []
         }
     {offset
       cab9S: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabaa; else goto caba4;
       cabaa: // global
           _sa7Va::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caba7_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa7Va::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
       caba4: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cab9S_info" {
     block_cab9S_info:
         const _cab9S;
         const 5;
         const 562954248388638;
         const Sa8nI_srt+56;
 },
 _caba7() //  [R1]
         { []
         }
     {offset
       caba7: // global
           I64[Sp] = block_caba9_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabaz; else goto cabac;
       uabaz: // global
           call _caba9(R1) args: 0, res: 0, upd: 0;
       cabac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caba7_info" {
     block_caba7_info:
         const _caba7;
         const 3;
         const 562954248388638;
         const Sa8nI_srt+56;
 },
 _caba9() //  [R1]
         { []
         }
     {offset
       caba9: // global
           I64[Sp - 8] = block_cabag_info;
           _sa7VD::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa7VD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabaA; else goto cabai;
       uabaA: // global
           call _cabag(R1) args: 0, res: 0, upd: 0;
       cabai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caba9_info" {
     block_caba9_info:
         const _caba9;
         const 3;
         const 562954248388638;
         const Sa8nI_srt+56;
 },
 _cabag() //  [R1]
         { []
         }
     {offset
       cabag: // global
           if (R1 & 7 == 1) goto cabao; else goto cabas;
       cabao: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabas: // global
           _sa7V4::P64 = P64[Sp + 32];
           _sa7V6::P64 = P64[Sp + 24];
           _sa7Vc::P64 = P64[Sp + 16];
           _sa7VD::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7Vc::P64 + 8] = _sa7VD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7Vc::P64);
           R3 = _sa7V4::P64;
           R2 = _sa7V6::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabag_info" {
     block_cabag_info:
         const _cabag;
         const 4;
         const 562954248388638;
         const Sa8nI_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.614557937 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking_entry() //  [R2,
                                                                R3]
         { []
         }
     {offset
       cabb7: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Sa8nI_srt+208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.628889428 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle2_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle2_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle2_info;
         const 0;
 },
 sat_sa7WE_entry() //  [R1]
         { []
         }
     {offset
       cabc5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabc9; else goto cabca;
       cabc9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabca: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabc2_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabce; else goto cabc3;
       uabce: // global
           call _cabc2(R1) args: 0, res: 0, upd: 0;
       cabc3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7WE_info" {
     sat_sa7WE_info:
         const sat_sa7WE_entry;
         const 1;
         const 16;
 },
 _cabc2() //  [R1]
         { []
         }
     {offset
       cabc2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabcd; else goto cabcc;
       cabcd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabcc: // global
           _sa7Wz::P64 = P64[R1 + 7];
           _sa7Wy::I64 = I64[R1 + 23];
           _sa7WB::I64 = I64[R1 + 31];
           _sa7WC::I64 = I64[R1 + 39];
           _sa7WD::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Wz::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Wy::I64;
           I64[Hp - 16] = _sa7WB::I64;
           I64[Hp - 8] = _sa7WC::I64;
           I64[Hp] = _sa7WD::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabc2_info" {
     block_cabc2_info:
         const _cabc2;
         const 0;
         const 30;
 },
 sat_sa7WQ_entry() //  [R1]
         { []
         }
     {offset
       cabcp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabct; else goto cabcu;
       cabct: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabcu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabcm_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabcy; else goto cabcn;
       uabcy: // global
           call _cabcm(R1) args: 0, res: 0, upd: 0;
       cabcn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7WQ_info" {
     sat_sa7WQ_info:
         const sat_sa7WQ_entry;
         const 1;
         const 16;
 },
 _cabcm() //  [R1]
         { []
         }
     {offset
       cabcm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabcx; else goto cabcw;
       cabcx: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabcw: // global
           _sa7WL::P64 = P64[R1 + 7];
           _sa7WK::I64 = I64[R1 + 23];
           _sa7WN::I64 = I64[R1 + 31];
           _sa7WO::I64 = I64[R1 + 39];
           _sa7WP::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7WL::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7WK::I64;
           I64[Hp - 16] = _sa7WN::I64;
           I64[Hp - 8] = _sa7WO::I64;
           I64[Hp] = _sa7WP::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabcm_info" {
     block_cabcm_info:
         const _cabcm;
         const 0;
         const 30;
 },
 sat_sa7X2_entry() //  [R1]
         { []
         }
     {offset
       cabcH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabcL; else goto cabcM;
       cabcL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabcM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabcE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabcQ; else goto cabcF;
       uabcQ: // global
           call _cabcE(R1) args: 0, res: 0, upd: 0;
       cabcF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7X2_info" {
     sat_sa7X2_info:
         const sat_sa7X2_entry;
         const 1;
         const 16;
 },
 _cabcE() //  [R1]
         { []
         }
     {offset
       cabcE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabcP; else goto cabcO;
       cabcP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabcO: // global
           _sa7WX::P64 = P64[R1 + 7];
           _sa7WW::I64 = I64[R1 + 23];
           _sa7WZ::I64 = I64[R1 + 31];
           _sa7X0::I64 = I64[R1 + 39];
           _sa7X1::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7WX::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7WW::I64;
           I64[Hp - 16] = _sa7WZ::I64;
           I64[Hp - 8] = _sa7X0::I64;
           I64[Hp] = _sa7X1::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabcE_info" {
     block_cabcE_info:
         const _cabcE;
         const 0;
         const 30;
 },
 sat_sa7Xe_entry() //  [R1]
         { []
         }
     {offset
       cabd1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabd5; else goto cabd6;
       cabd5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabd6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabcY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabda; else goto cabcZ;
       uabda: // global
           call _cabcY(R1) args: 0, res: 0, upd: 0;
       cabcZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Xe_info" {
     sat_sa7Xe_info:
         const sat_sa7Xe_entry;
         const 1;
         const 16;
 },
 _cabcY() //  [R1]
         { []
         }
     {offset
       cabcY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabd9; else goto cabd8;
       cabd9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabd8: // global
           _sa7X9::P64 = P64[R1 + 7];
           _sa7X8::I64 = I64[R1 + 23];
           _sa7Xb::I64 = I64[R1 + 31];
           _sa7Xc::I64 = I64[R1 + 39];
           _sa7Xd::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7X9::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7X8::I64;
           I64[Hp - 16] = _sa7Xb::I64;
           I64[Hp - 8] = _sa7Xc::I64;
           I64[Hp] = _sa7Xd::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabcY_info" {
     block_cabcY_info:
         const _cabcY;
         const 0;
         const 30;
 },
 sat_sa7Xq_entry() //  [R1]
         { []
         }
     {offset
       cabdj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabdn; else goto cabdo;
       cabdn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabdo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabdg_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabds; else goto cabdh;
       uabds: // global
           call _cabdg(R1) args: 0, res: 0, upd: 0;
       cabdh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Xq_info" {
     sat_sa7Xq_info:
         const sat_sa7Xq_entry;
         const 1;
         const 16;
 },
 _cabdg() //  [R1]
         { []
         }
     {offset
       cabdg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabdr; else goto cabdq;
       cabdr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabdq: // global
           _sa7Xl::P64 = P64[R1 + 7];
           _sa7Xk::I64 = I64[R1 + 23];
           _sa7Xn::I64 = I64[R1 + 31];
           _sa7Xo::I64 = I64[R1 + 39];
           _sa7Xp::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Xl::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Xk::I64;
           I64[Hp - 16] = _sa7Xn::I64;
           I64[Hp - 8] = _sa7Xo::I64;
           I64[Hp] = _sa7Xp::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabdg_info" {
     block_cabdg_info:
         const _cabdg;
         const 0;
         const 30;
 },
 sat_sa7XC_entry() //  [R1]
         { []
         }
     {offset
       cabdD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabdH; else goto cabdI;
       cabdH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabdI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabdA_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabdM; else goto cabdB;
       uabdM: // global
           call _cabdA(R1) args: 0, res: 0, upd: 0;
       cabdB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7XC_info" {
     sat_sa7XC_info:
         const sat_sa7XC_entry;
         const 1;
         const 16;
 },
 _cabdA() //  [R1]
         { []
         }
     {offset
       cabdA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabdL; else goto cabdK;
       cabdL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabdK: // global
           _sa7Xx::P64 = P64[R1 + 7];
           _sa7Xw::I64 = I64[R1 + 23];
           _sa7Xz::I64 = I64[R1 + 31];
           _sa7XA::I64 = I64[R1 + 39];
           _sa7XB::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa7Xx::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sa7Xw::I64;
           I64[Hp - 16] = _sa7Xz::I64;
           I64[Hp - 8] = _sa7XA::I64;
           I64[Hp] = _sa7XB::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabdA_info" {
     block_cabdA_info:
         const _cabdA;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.wantReadableHandle2_entry() //  [R2, R3]
         { []
         }
     {offset
       cabdN: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cabdO; else goto cabdP;
       cabdO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cabdP: // global
           I64[Sp - 16] = block_cabbi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabeN; else goto cabbj;
       uabeN: // global
           call _cabbi(R1) args: 0, res: 0, upd: 0;
       cabbj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle2_info" {
     GHC.IO.Handle.Internals.wantReadableHandle2_info:
         const GHC.IO.Handle.Internals.wantReadableHandle2_entry;
         const 0;
         const 144116326242189326;
         const 12884901903;
         const Sa8nI_srt+16;
 },
 _cabbi() //  [R1]
         { []
         }
     {offset
       cabbi: // global
           I64[Sp - 40] = block_cabbn_info;
           _sa7VL::P64 = R1;
           _sa7VN::P64 = P64[R1 + 15];
           _sa7VP::P64 = P64[R1 + 31];
           _sa7VR::P64 = P64[R1 + 47];
           _sa7VU::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sa7VN::P64;
           P64[Sp - 24] = _sa7VP::P64;
           P64[Sp - 16] = _sa7VR::P64;
           P64[Sp - 8] = _sa7VU::P64;
           P64[Sp] = _sa7VL::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uabeH; else goto cabbo;
       uabeH: // global
           call _cabbn(R1) args: 0, res: 0, upd: 0;
       cabbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabbi_info" {
     block_cabbi_info:
         const _cabbi;
         const 1;
         const 1138166333470;
         const Sa8nI_srt+16;
 },
 _cabbn() //  [R1]
         { []
         }
     {offset
       cabbn: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto cabdU;
               case 2 : goto cabdX;
               case 3 : goto uabeF;
               case 4, 5 : goto cabe6;
               case 6 : goto cabe8;
           }
       cabe8: // global
           _sa7W5::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cabbx_info;
           R1 = _sa7W5::P64;
           if (R1 & 7 != 0) goto uabeI; else goto cabby;
       uabeI: // global
           call _cabbx(R1) args: 0, res: 0, upd: 0;
       cabby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabe6: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uabeF: // global
           Sp = Sp + 40;
           call _cabed() args: 0, res: 0, upd: 0;
       cabdX: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabdU: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabbn_info" {
     block_cabbn_info:
         const _cabbn;
         const 6;
         const 1138166333470;
         const Sa8nI_srt+16;
 },
 _cabbx() //  [R1]
         { []
         }
     {offset
       cabbx: // global
           I64[Sp - 16] = block_cabbC_info;
           _sa7Wb::I64 = I64[R1 + 39];
           _sa7Wc::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa7Wc::I64;
           I64[Sp] = _sa7Wb::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabeK; else goto cabbD;
       uabeK: // global
           call _cabbC(R1) args: 0, res: 0, upd: 0;
       cabbD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabbx_info" {
     block_cabbx_info:
         const _cabbx;
         const 6;
         const 30;
 },
 _cabbC() //  [R1]
         { []
         }
     {offset
       cabbC: // global
           if (R1 & 7 == 1) goto uabeG; else goto cabee;
       uabeG: // global
           Sp = Sp + 56;
           call _cabed() args: 0, res: 0, upd: 0;
       cabee: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cabeh; else goto cabeg;
       cabeh: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabeg: // global
           _sa7VR::P64 = P64[Sp + 40];
           if (I64[Sp + 16] == I64[Sp + 8]) goto cabet; else goto cabej;
       cabet: // global
           _sa7VU::P64 = P64[Sp + 48];
           _sa7Xi::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7Xq_info;
           P64[Hp - 24] = _sa7Xi::P64;
           _sa7VI::P64 = P64[Sp + 64];
           _sa7VL::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7Xu::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7XC_info;
           P64[Hp] = _sa7Xu::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 72;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cabej: // global
           _sa7Wh::P64 = P64[_sa7VR::P64 + 8];
           Hp = Hp - 48;
           I64[Sp + 16] = block_cabbL_info;
           R1 = _sa7Wh::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabeL; else goto cabbM;
       uabeL: // global
           call _cabbL(R1) args: 0, res: 0, upd: 0;
       cabbM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabbC_info" {
     block_cabbC_info:
         const _cabbC;
         const 200;
         const 30;
 },
 _cabbL() //  [R1]
         { []
         }
     {offset
       cabbL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cabem; else goto cabel;
       cabem: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabel: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabes; else goto cabeo;
       cabes: // global
           _sa7VU::P64 = P64[Sp + 32];
           _sa7WU::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7X2_info;
           P64[Hp - 24] = _sa7WU::P64;
           _sa7VI::P64 = P64[Sp + 48];
           _sa7VL::P64 = P64[Sp + 40];
           _sa7VR::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7X6::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7Xe_info;
           P64[Hp] = _sa7X6::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cabeo: // global
           Hp = Hp - 48;
           _sa7VP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabbT_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa7VP::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabbL_info" {
     block_cabbL_info:
         const _cabbL;
         const 6;
         const 30;
 },
 _cabbT() //  [R1]
         { []
         }
     {offset
       cabbT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caber; else goto cabeq;
       caber: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabeq: // global
           _sa7VI::P64 = P64[Sp + 32];
           _sa7VL::P64 = P64[Sp + 24];
           _sa7VR::P64 = P64[Sp + 8];
           _sa7VU::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           _sa7Ww::P64 = P64[_sa7VU::P64 + 8];
           I64[Hp - 40] = sat_sa7WE_info;
           P64[Hp - 24] = _sa7Ww::P64;
           call MO_WriteBarrier();
           P64[_sa7VU::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VU::P64);
           _sa7WI::P64 = P64[_sa7VR::P64 + 8];
           I64[Hp - 16] = sat_sa7WQ_info;
           P64[Hp] = _sa7WI::P64;
           call MO_WriteBarrier();
           P64[_sa7VR::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7VR::P64);
           R2 = _sa7VL::P64;
           R1 = _sa7VI::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabbT_info" {
     block_cabbT_info:
         const _cabbT;
         const 4;
         const 30;
 },
 _cabed() //  []
         { []
         }
     {offset
       cabed: // global
           R2 = P64[Sp];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.667594067 UTC

[section ""data" . lvl8_ra7Po_closure" {
     lvl8_ra7Po_closure:
         const GHC.IO.Handle.Types.BlockBuffering_con_info;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.686118323 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle5_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle5_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle5_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_slow() //  [R1]
         { []
         }
     {offset
       cabgx: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 56, res: 0, upd: 8;
     }
 },
 buf_state_sa7XU_entry() //  [R1]
         { []
         }
     {offset
       cabi8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabi9; else goto cabia;
       cabi9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabi1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabih; else goto cabi2;
       uabih: // global
           call _cabi1(R1) args: 0, res: 0, upd: 0;
       cabi2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . buf_state_sa7XU_info" {
     buf_state_sa7XU_info:
         const buf_state_sa7XU_entry;
         const 1;
         const 16;
 },
 _cabi1() //  [R1]
         { []
         }
     {offset
       cabi1: // global
           if (R1 & 7 == 3) goto cabi6; else goto cabi5;
       cabi6: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cabi5: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabi1_info" {
     block_cabi1_info:
         const _cabi1;
         const 0;
         const 30;
 },
 sat_sa7Yk_entry() //  [R1]
         { []
         }
     {offset
       cabiE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabiF; else goto cabiG;
       cabiF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabiG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.outputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Yk_info" {
     sat_sa7Yk_info:
         const sat_sa7Yk_entry;
         const 1;
         const 16;
 },
 sat_sa7Yj_entry() //  [R1]
         { []
         }
     {offset
       cabiL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabiM; else goto cabiN;
       cabiM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabiN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.inputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Yj_info" {
     sat_sa7Yj_info:
         const sat_sa7Yj_entry;
         const 1;
         const 16;
 },
 sat_sa7Yl_entry() //  [R1]
         { []
         }
     {offset
       cabiO: // global
           if ((Sp + -136) < SpLim) (likely: False) goto cabiQ; else goto cabiR;
       cabiQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabiR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_cabit_info;
           _sa7XE::P64 = P64[R1 + 16];
           _sa7XF::P64 = P64[R1 + 24];
           _sa7XG::P64 = P64[R1 + 32];
           _sa7XJ::P64 = P64[R1 + 48];
           _sa7XL::P64 = P64[R1 + 56];
           _sa7XM::P64 = P64[R1 + 64];
           _sa7XO::P64 = P64[R1 + 72];
           _sa7XR::P64 = P64[R1 + 80];
           _sa7XS::P64 = P64[R1 + 88];
           _sa7Y1::P64 = P64[R1 + 96];
           _sa7Y5::P64 = P64[R1 + 104];
           _sa7Y8::P64 = P64[R1 + 112];
           _sa7Y9::P64 = P64[R1 + 120];
           _sa7Yc::P64 = P64[R1 + 128];
           R1 = P64[R1 + 40];
           P64[Sp - 128] = _sa7XE::P64;
           P64[Sp - 120] = _sa7XF::P64;
           P64[Sp - 112] = _sa7XG::P64;
           P64[Sp - 104] = _sa7XJ::P64;
           P64[Sp - 96] = _sa7XL::P64;
           P64[Sp - 88] = _sa7XM::P64;
           P64[Sp - 80] = _sa7XO::P64;
           P64[Sp - 72] = _sa7XR::P64;
           P64[Sp - 64] = _sa7XS::P64;
           P64[Sp - 56] = _sa7Y1::P64;
           P64[Sp - 48] = _sa7Y5::P64;
           P64[Sp - 40] = _sa7Y8::P64;
           P64[Sp - 32] = _sa7Y9::P64;
           P64[Sp - 24] = _sa7Yc::P64;
           Sp = Sp - 136;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Yl_info" {
     sat_sa7Yl_info:
         const sat_sa7Yl_entry;
         const 15;
         const 15;
 },
 _cabit() //  [R1]
         { []
         }
     {offset
       cabit: // global
           I64[Sp] = block_cabiv_info;
           _sa7Yg::P64 = R1;
           R1 = P64[Sp + 96];
           P64[Sp + 96] = _sa7Yg::P64;
           if (R1 & 7 != 0) goto uabiW; else goto cabiw;
       uabiW: // global
           call _cabiv(R1) args: 0, res: 0, upd: 0;
       cabiw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cabit_info" {
     block_cabit_info:
         const _cabit;
         const 14;
         const 30;
 },
 _cabiv() //  [R1]
         { []
         }
     {offset
       cabiv: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cabiV; else goto cabiU;
       cabiV: // global
           HpAlloc = 184;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabiU: // global
           _sa7Yi::P64 = P64[R1 + 7];
           I64[Hp - 176] = sat_sa7Yk_info;
           _sa7XM::P64 = P64[Sp + 48];
           P64[Hp - 160] = _sa7XM::P64;
           I64[Hp - 152] = sat_sa7Yj_info;
           P64[Hp - 136] = _sa7XM::P64;
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = _sa7Yi::P64;
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = Hp - 152;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 127;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabiv_info" {
     block_cabiv_info:
         const _cabiv;
         const 14;
         const 30;
 },
 sat_sa7Yr_entry() //  [R1]
         { []
         }
     {offset
       cabja: // global
           _sa7Yr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cabjb; else goto cabjc;
       cabjc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabje; else goto cabjd;
       cabje: // global
           HpAlloc = 16;
           goto cabjb;
       cabjb: // global
           R1 = _sa7Yr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabjd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa7Yr::P64;
           _sa7XI::P64 = P64[_sa7Yr::P64 + 16];
           _sa7Yf::P64 = P64[_sa7Yr::P64 + 24];
           _sa7Yp::P64 = P64[_sa7Yr::P64 + 32];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _sa7Yf::P64;
           R3 = Hp - 7;
           R2 = _sa7XI::P64;
           R1 = _sa7Yp::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Yr_info" {
     sat_sa7Yr_info:
         const sat_sa7Yr_entry;
         const 3;
         const 15;
 },
 sat_sa7Z1_entry() //  [R1]
         { []
         }
     {offset
       cabjo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabjp; else goto cabjq;
       cabjp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabjq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabjh_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabjx; else goto cabji;
       uabjx: // global
           call _cabjh(R1) args: 0, res: 0, upd: 0;
       cabji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa7Z1_info" {
     sat_sa7Z1_info:
         const sat_sa7Z1_entry;
         const 1;
         const 16;
 },
 _cabjh() //  [R1]
         { []
         }
     {offset
       cabjh: // global
           if (R1 & 7 == 1) goto cabjl; else goto cabjm;
       cabjl: // global
           R1 = lvl8_ra7Po_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cabjm: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabjh_info" {
     block_cabjh_info:
         const _cabjh;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { []
         }
     {offset
       cabjC: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cabjD; else goto cabjE;
       cabjD: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 96, res: 0, upd: 8;
       cabjE: // global
           I64[Sp - 48] = block_cabhq_info;
           R1 = P64[Sp + 16];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uablO; else goto cabhr;
       uablO: // global
           call _cabhq(R1) args: 0, res: 0, upd: 0;
       cabhr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle5_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle5_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle5_entry;
         const 0;
         const 38654705678;
         const 51539607552;
         const Sa8nI_srt+200;
         const 11;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_slow;
 },
 _cabhq() //  [R1]
         { []
         }
     {offset
       cabhq: // global
           if (R1 & 7 == 1) goto cabjz; else goto cabjA;
       cabjz: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _cabgE() args: 0, res: 0, upd: 0;
       cabjA: // global
           I64[Sp] = block_cabhw_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uablG; else goto cabhx;
       uablG: // global
           call _cabhw(R1) args: 0, res: 0, upd: 0;
       cabhx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabhq_info" {
     block_cabhq_info:
         const _cabhq;
         const 11;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabhw() //  [R1]
         { []
         }
     {offset
       cabhw: // global
           I64[Sp - 16] = block_cabkx_info;
           _sa7Z6::P64 = P64[R1 + 15];
           _sa7Z7::P64 = P64[R1 + 23];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _sa7Z7::P64;
           P64[Sp] = _sa7Z6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uablI; else goto cabkT;
       uablI: // global
           call _cabkx(R1) args: 0, res: 0, upd: 0;
       cabkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabhw_info" {
     block_cabhw_info:
         const _cabhw;
         const 11;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabkx() //  [R1]
         { []
         }
     {offset
       cabkx: // global
           _sa7Z6::P64 = P64[Sp + 16];
           _cabli::P64 = R1 & 7;
           if (_cabli::P64 != 3) goto uablq; else goto cabl4;
       uablq: // global
           if (_cabli::P64 != 6) goto cabkZ; else goto cabld;
       cabkZ: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
       cabld: // global
           I64[Sp] = block_cablb_info;
           R1 = _sa7Z6::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cabl4: // global
           I64[Sp] = block_cabl2_info;
           R1 = _sa7Z6::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabkx_info" {
     block_cabkx_info:
         const _cabkx;
         const 13;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cablb() //  [R1]
         { []
         }
     {offset
       cablb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cablh; else goto cablg;
       cablh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cablg: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cablb_info" {
     block_cablb_info:
         const _cablb;
         const 141;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabl2() //  [R1]
         { []
         }
     {offset
       cabl2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabl8; else goto cabl7;
       cabl8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabl7: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sa7Z8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabl2_info" {
     block_cabl2_info:
         const _cabl2;
         const 141;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _sa7Z8() //  []
         { []
         }
     {offset
       sa7Z8: // global
           I64[Sp - 8] = block_cabhG_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uablS; else goto cabhH;
       uablS: // global
           call _cabhG(R1) args: 0, res: 0, upd: 0;
       cabhH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabhG() //  [R1]
         { []
         }
     {offset
       cabhG: // global
           _sa7Z7::P64 = P64[Sp + 8];
           _cabll::P64 = R1 & 7;
           if (_cabll::P64 < 5) goto uablo; else goto uablp;
       uablo: // global
           if (_cabll::P64 < 4) goto cabkD; else goto cabkF;
       cabkD: // global
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _cabgE() args: 0, res: 0, upd: 0;
       cabkF: // global
           I64[Sp + 8] = block_cabhM_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       uablp: // global
           if (_cabll::P64 < 6) goto cabkK; else goto cabkP;
       cabkK: // global
           I64[Sp + 8] = block_cabhR_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cabkP: // global
           I64[Sp + 8] = block_cabhW_info;
           R1 = _sa7Z7::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabhG_info" {
     block_cabhG_info:
         const _cabhG;
         const 13;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabhM() //  [R1]
         { []
         }
     {offset
       cabhM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabkI; else goto cabkH;
       cabkI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabkH: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _cabgE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabhM_info" {
     block_cabhM_info:
         const _cabhM;
         const 12;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabhR() //  [R1]
         { []
         }
     {offset
       cabhR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabkN; else goto cabkM;
       cabkN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabkM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _cabgE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabhR_info" {
     block_cabhR_info:
         const _cabhR;
         const 12;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabhW() //  [R1]
         { []
         }
     {offset
       cabhW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabkS; else goto cabkR;
       cabkS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabkR: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sa7XS::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sa7XS::P64;
           call _cabgE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabhW_info" {
     block_cabhW_info:
         const _cabhW;
         const 12;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabgE() //  []
         { []
         }
     {offset
       cabgE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabjH; else goto cabjG;
       cabjH: // global
           HpAlloc = 24;
           _sa7XR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabgD_info;
           R2 = P64[Sp];
           R1 = _sa7XR::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cabjG: // global
           I64[Hp - 16] = buf_state_sa7XU_info;
           P64[Hp] = P64[Sp + 56];
           I64[Sp - 16] = block_cabgI_info;
           R2 = P64[Sp + 24];
           I64[Sp - 40] = stg_ap_ppv_info;
           P64[Sp - 32] = P64[Sp + 40];
           _cabgG::P64 = Hp - 16;
           P64[Sp - 24] = _cabgG::P64;
           P64[Sp - 8] = _cabgG::P64;
           Sp = Sp - 40;
           call GHC.IO.BufferedIO.newBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cabgD() //  [R1, R2]
         { []
         }
     {offset
       cabgD: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cabgE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabgD_info" {
     block_cabgD_info:
         const _cabgD;
         const 11;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabgI() //  [R1]
         { []
         }
     {offset
       cabgI: // global
           I64[Sp - 8] = block_cabgK_info;
           _sa7XY::P64 = R1;
           R1 = R1;
           P64[Sp] = _sa7XY::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabgI_info" {
     block_cabgI_info:
         const _cabgI;
         const 14;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabgK() //  [R1]
         { []
         }
     {offset
       cabgK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabjL; else goto cabjK;
       cabjL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabjK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cabgN_info;
           _sa7Y1::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _sa7Y1::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabgK_info" {
     block_cabgK_info:
         const _cabgK;
         const 15;
         const 4294967326;
         const Sa8nI_srt+200;
 },
 _cabgN() //  [R1]
         { []
         }
     {offset
       cabgN: // global
           I64[Sp] = block_cabgR_info;
           _sa7Y5::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _sa7Y5::P64;
           if (R1 & 7 != 0) goto uablD; else goto cabgS;
       uablD: // global
           call _cabgR(R1) args: 0, res: 0, upd: 0;
       cabgS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabgN_info" {
     block_cabgN_info:
         const _cabgN;
         const 15;
         const 30;
 },
 _cabgR() //  [R1]
         { []
         }
     {offset
       cabgR: // global
           if (R1 & 7 == 1) goto cabkc; else goto cabkl;
       cabkc: // global
           I64[Sp] = block_cabgW_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cabkl: // global
           I64[Sp] = block_cabha_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabgR_info" {
     block_cabgR_info:
         const _cabgR;
         const 15;
         const 30;
 },
 _cabgW() //  [R1]
         { []
         }
     {offset
       cabgW: // global
           I64[Sp - 8] = block_cabgY_info;
           _sa7Yz::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sa7Yz::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabgW_info" {
     block_cabgW_info:
         const _cabgW;
         const 15;
         const 30;
 },
 _cabgY() //  [R1]
         { []
         }
     {offset
       cabgY: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cabkg; else goto cabkf;
       cabkg: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabkf: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_cabh5_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabgY_info" {
     block_cabgY_info:
         const _cabgY;
         const 16;
         const 30;
 },
 _cabh5() //  [R1]
         { []
         }
     {offset
       cabh5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabkj; else goto cabki;
       cabkj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabki: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 7;
           P64[Sp] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           call _sa7Y6() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabh5_info" {
     block_cabh5_info:
         const _cabh5;
         const 143;
         const 30;
 },
 _cabha() //  [R1]
         { []
         }
     {offset
       cabha: // global
           I64[Sp - 8] = block_cabhc_info;
           _sa7YM::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sa7YM::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabha_info" {
     block_cabha_info:
         const _cabha;
         const 15;
         const 30;
 },
 _cabhc() //  [R1]
         { []
         }
     {offset
       cabhc: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cabkp; else goto cabko;
       cabkp: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabko: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_cabhj_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabhc_info" {
     block_cabhc_info:
         const _cabhc;
         const 16;
         const 30;
 },
 _cabhj() //  [R1]
         { []
         }
     {offset
       cabhj: // global
           I64[Sp] = block_cabhl_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 64];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabhj_info" {
     block_cabhj_info:
         const _cabhj;
         const 143;
         const 30;
 },
 _cabhl() //  [R1]
         { []
         }
     {offset
       cabhl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cabkt; else goto cabks;
       cabkt: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabks: // global
           I64[Hp - 32] = sat_sa7Z1_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = Hp - 32;
           P64[Sp + 16] = Hp - 7;
           call _sa7Y6() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabhl_info" {
     block_cabhl_info:
         const _cabhl;
         const 15;
         const 30;
 },
 _sa7Y6() //  []
         { []
         }
     {offset
       sa7Y6: // global
           I64[Sp - 8] = block_cabil_info;
           R1 = GHC.IO.Handle.Types.BufferListNil_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabil() //  [R1]
         { []
         }
     {offset
       cabil: // global
           I64[Sp - 8] = block_cabin_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabil_info" {
     block_cabil_info:
         const _cabil;
         const 16;
         const 30;
 },
 _cabin() //  [R1]
         { []
         }
     {offset
       cabin: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cabjR; else goto cabjQ;
       cabjR: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabjQ: // global
           I64[Hp - 128] = sat_sa7Yl_info;
           P64[Hp - 112] = P64[Sp + 56];
           P64[Hp - 104] = P64[Sp + 64];
           P64[Hp - 96] = P64[Sp + 72];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 112];
           P64[Hp - 64] = P64[Sp + 120];
           P64[Hp - 56] = P64[Sp + 136];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 104];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 80] = block_cabiX_info;
           R2 = Hp - 128;
           _sa7Yf::P64 = R1;
           R1 = R1;
           P64[Sp + 136] = _sa7Yf::P64;
           Sp = Sp + 80;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabin_info" {
     block_cabin_info:
         const _cabin;
         const 17;
         const 30;
 },
 _cabiX() //  []
         { []
         }
     {offset
       cabiX: // global
           I64[Sp] = block_cabiZ_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uablN; else goto cabj0;
       uablN: // global
           call _cabiZ(R1) args: 0, res: 0, upd: 0;
       cabj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabiX_info" {
     block_cabiX_info:
         const _cabiX;
         const 1927;
         const 30;
 },
 _cabiZ() //  [R1]
         { []
         }
     {offset
       cabiZ: // global
           _sa7XI::P64 = P64[Sp + 8];
           _sa7Yf::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cabjW; else goto cabk3;
       cabjW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabjZ; else goto cabjY;
       cabjZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabjY: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = _sa7XI::P64;
           P64[Hp] = _sa7Yf::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabk3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cabk6; else goto cabk5;
       cabk6: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabk5: // global
           _sa7Yp::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_sa7Yr_info;
           P64[Hp - 16] = _sa7XI::P64;
           P64[Hp - 8] = _sa7Yf::P64;
           P64[Hp] = _sa7Yp::P64;
           I64[Sp] = block_cabk0_info;
           R3 = Hp - 32;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _sa7Yf::P64;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabiZ_info" {
     block_cabiZ_info:
         const _cabiZ;
         const 3975;
         const 30;
 },
 _cabk0() //  [R1]
         { []
         }
     {offset
       cabk0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabk9; else goto cabk8;
       cabk9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabk8: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabk0_info" {
     block_cabk0_info:
         const _cabk0;
         const 3975;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.754852867 UTC

[section ""data" . GHC.IO.Handle.Internals.mkHandle_closure" {
     GHC.IO.Handle.Internals.mkHandle_closure:
         const GHC.IO.Handle.Internals.mkHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkHandle_slow() //  [R1]
         { []
         }
     {offset
       cabph: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkHandle_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 56, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkHandle_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cabpl: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkHandle_info" {
     GHC.IO.Handle.Internals.mkHandle_info:
         const GHC.IO.Handle.Internals.mkHandle_entry;
         const 0;
         const 4294967310;
         const 51539607552;
         const Sa8nI_srt+224;
         const 11;
         const GHC.IO.Handle.Internals.mkHandle_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.760086325 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO1_closure" {
     GHC.IO.Handle.Internals.debugIO1_closure:
         const GHC.IO.Handle.Internals.debugIO1_info;
 },
 GHC.IO.Handle.Internals.debugIO1_entry() //  []
         { []
         }
     {offset
       cabpy: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.debugIO1_info" {
     GHC.IO.Handle.Internals.debugIO1_info:
         const GHC.IO.Handle.Internals.debugIO1_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.763420795 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO_closure" {
     GHC.IO.Handle.Internals.debugIO_closure:
         const GHC.IO.Handle.Internals.debugIO_info;
 },
 GHC.IO.Handle.Internals.debugIO_entry() //  [R2]
         { []
         }
     {offset
       cabpK: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.debugIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.debugIO_info" {
     GHC.IO.Handle.Internals.debugIO_info:
         const GHC.IO.Handle.Internals.debugIO_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.776731147 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwriteCharBuffer_closure" {
     GHC.IO.Handle.Internals.$wwriteCharBuffer_closure:
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_info;
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_slow() //  [R1]
         { []
         }
     {offset
       cabpS: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { []
         }
     {offset
       cabpZ: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cabq0; else goto uabt5;
       cabq0: // global
           R1 = GHC.IO.Handle.Internals.$wwriteCharBuffer_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       uabt5: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cabpT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wwriteCharBuffer_info" {
     GHC.IO.Handle.Internals.$wwriteCharBuffer_info:
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_entry;
         const 0;
         const 14;
         const 34359738368;
         const 0;
         const 7303;
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_slow;
 },
 _cabpT() //  []
         { []
         }
     {offset
       cabpT: // global
           _sa7Zz::P64 = P64[Sp];
           I64[Sp] = block_cabpW_info;
           R1 = _sa7Zz::P64;
           if (R1 & 7 != 0) goto uabtl; else goto cabpX;
       uabtl: // global
           call _cabpW(R1) args: 0, res: 0, upd: 0;
       cabpX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabpW() //  [R1]
         { []
         }
     {offset
       cabpW: // global
           I64[Sp - 48] = block_cabq6_info;
           _sa7ZH::P64 = R1;
           _sa7ZJ::P64 = P64[R1 + 15];
           _sa7ZL::P64 = P64[R1 + 31];
           _sa7ZN::P64 = P64[R1 + 47];
           _sa7ZO::P64 = P64[R1 + 55];
           R1 = P64[R1 + 87];
           P64[Sp - 40] = _sa7ZJ::P64;
           P64[Sp - 32] = _sa7ZL::P64;
           P64[Sp - 24] = _sa7ZN::P64;
           P64[Sp - 16] = _sa7ZO::P64;
           P64[Sp - 8] = P64[_sa7ZN::P64 + 8];
           P64[Sp] = _sa7ZH::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uabtm; else goto cabsa;
       uabtm: // global
           call _cabq6(R1) args: 0, res: 0, upd: 0;
       cabsa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabpW_info" {
     block_cabpW_info:
         const _cabpW;
         const 3654;
         const 30;
 },
 _cabq6() //  [R1]
         { []
         }
     {offset
       cabq6: // global
           if (R1 & 7 == 1) goto cabso; else goto cabsQ;
       cabso: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabsr; else goto cabsq;
       cabsr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabsq: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_cabsf_info;
           R3 = P64[Sp + 40];
           R2 = Hp - 47;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cabsQ: // global
           I64[Sp] = block_cabsB_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabto; else goto cabsC;
       uabto: // global
           call _cabsB(R1) args: 0, res: 0, upd: 0;
       cabsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabq6_info" {
     block_cabq6_info:
         const _cabq6;
         const 233484;
         const 30;
 },
 _cabsf() //  [R1]
         { []
         }
     {offset
       cabsf: // global
           I64[Sp] = block_cabsh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabtH; else goto cabsi;
       uabtH: // global
           call _cabsh(R1) args: 0, res: 0, upd: 0;
       cabsi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabsf_info" {
     block_cabsf_info:
         const _cabsf;
         const 259084;
         const 30;
 },
 _cabsh() //  [R1]
         { []
         }
     {offset
       cabsh: // global
           I64[Sp] = block_cabsm_info;
           _sa80U::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp + 96] = _sa80U::P64;
           if (R1 & 7 != 0) goto uabtI; else goto cabsu;
       uabtI: // global
           call _cabsm(R1) args: 0, res: 0, upd: 0;
       cabsu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabsh_info" {
     block_cabsh_info:
         const _cabsh;
         const 259084;
         const 30;
 },
 _cabsm() //  [R1]
         { []
         }
     {offset
       cabsm: // global
           P64[Sp + 96] = P64[Sp + 96];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 72] = P64[R1 + 7];
           P64[Sp + 64] = P64[R1 + 15];
           I64[Sp + 56] = I64[R1 + 31];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 8;
           call _cabq8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabsm_info" {
     block_cabsm_info:
         const _cabsm;
         const 128012;
         const 30;
 },
 _cabsB() //  [R1]
         { []
         }
     {offset
       cabsB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabsT; else goto cabsS;
       cabsT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabsS: // global
           _sa815::P64 = P64[R1 + 7];
           _sa816::P64 = P64[R1 + 15];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_cabsH_info;
           R5 = P64[Sp + 40];
           R4 = Hp - 47;
           R3 = _sa816::P64;
           R2 = _sa815::P64;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabsB_info" {
     block_cabsB_info:
         const _cabsB;
         const 233484;
         const 30;
 },
 _cabsH() //  [R1]
         { []
         }
     {offset
       cabsH: // global
           I64[Sp] = block_cabsJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabtK; else goto cabsK;
       uabtK: // global
           call _cabsJ(R1) args: 0, res: 0, upd: 0;
       cabsK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabsH_info" {
     block_cabsH_info:
         const _cabsH;
         const 259084;
         const 30;
 },
 _cabsJ() //  [R1]
         { []
         }
     {offset
       cabsJ: // global
           I64[Sp] = block_cabsO_info;
           _sa81f::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _sa81f::P64;
           if (R1 & 7 != 0) goto uabtL; else goto cabsW;
       uabtL: // global
           call _cabsO(R1) args: 0, res: 0, upd: 0;
       cabsW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabsJ_info" {
     block_cabsJ_info:
         const _cabsJ;
         const 259084;
         const 30;
 },
 _cabsO() //  [R1]
         { []
         }
     {offset
       cabsO: // global
           I64[Sp] = I64[R1 + 47];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp + 56] = I64[R1 + 31];
           P64[Sp + 64] = P64[R1 + 15];
           P64[Sp + 72] = P64[R1 + 7];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 96] = P64[Sp + 96];
           Sp = Sp - 8;
           call _cabq8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabsO_info" {
     block_cabsO_info:
         const _cabsO;
         const 128012;
         const 30;
 },
 _cabq8() //  []
         { []
         }
     {offset
       cabq8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabqd; else goto cabqc;
       cabqd: // global
           HpAlloc = 56;
           I64[Sp] = block_cabq8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cabqc: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 88];
           _sa807::I64 = I64[Sp + 64];
           I64[Hp - 16] = _sa807::I64;
           I64[Hp - 8] = I64[Sp + 48];
           _sa809::I64 = I64[Sp + 8];
           I64[Hp] = _sa809::I64;
           _cabqe::P64 = Hp - 47;
           if (_sa807::I64 == _sa809::I64) goto uabt8; else goto cabqH;
       uabt8: // global
           P64[Sp + 96] = _cabqe::P64;
           Sp = Sp + 16;
           call _sa80b() args: 0, res: 0, upd: 0;
       cabqH: // global
           I64[Sp] = block_cabqF_info;
           R1 = P64[Sp + 104];
           P64[Sp + 88] = _cabqe::P64;
           if (R1 & 7 != 0) goto uabtp; else goto cabqI;
       uabtp: // global
           call _cabqF(R1) args: 0, res: 0, upd: 0;
       cabqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabq8_info" {
     block_cabq8_info:
         const _cabq8;
         const 206925;
         const 30;
 },
 _cabqF() //  [R1]
         { []
         }
     {offset
       cabqF: // global
           _sa7ZO::P64 = P64[Sp + 40];
           _sa80r::P64 = P64[R1 + 7];
           _sa80s::P64 = P64[R1 + 15];
           _sa80q::I64 = I64[R1 + 23];
           _sa80t::I64 = I64[R1 + 31];
           _sa80u::I64 = I64[R1 + 39];
           _sa80v::I64 = I64[R1 + 47];
           if (_sa80u::I64 == _sa80v::I64) goto sa80w; else goto cabs7;
       cabs7: // global
           if (_sa80u::I64 != I64[Sp + 96]) goto sa80w; else goto uabt9;
       sa80w: // global
           I64[Sp - 8] = block_cabqS_info;
           R1 = _sa7ZO::P64;
           I64[Sp] = _sa80v::I64;
           I64[Sp + 40] = _sa80u::I64;
           I64[Sp + 64] = _sa80t::I64;
           P64[Sp + 72] = _sa80s::P64;
           P64[Sp + 80] = _sa80r::P64;
           I64[Sp + 96] = _sa80q::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabtu; else goto cabqU;
       uabtu: // global
           call _cabqS(R1) args: 0, res: 0, upd: 0;
       cabqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uabt9: // global
           P64[Sp + 96] = P64[Sp + 88];
           Sp = Sp + 16;
           call _sa80b() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabqF_info" {
     block_cabqF_info:
         const _cabqF;
         const 190541;
         const 30;
 },
 _cabqS() //  [R1]
         { []
         }
     {offset
       cabqS: // global
           _cabt2::P64 = R1 & 7;
           if (_cabt2::P64 < 3) goto uabt4; else goto cabrh;
       uabt4: // global
           _cabqe::P64 = P64[Sp + 96];
           if (_cabt2::P64 < 2) goto uabta; else goto cabrc;
       uabta: // global
           P64[Sp + 104] = _cabqe::P64;
           Sp = Sp + 24;
           call _sa80b() args: 0, res: 0, upd: 0;
       cabrc: // global
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _cabqe::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto uabtb; else goto uabtc;
       uabtb: // global
           Sp = Sp + 120;
           call _cabrU() args: 0, res: 0, upd: 0;
       uabtc: // global
           Sp = Sp + 8;
           call _cabrT() args: 0, res: 0, upd: 0;
       cabrh: // global
           I64[Sp] = block_cabrf_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto uabtw; else goto cabri;
       uabtw: // global
           call _cabrf(R1) args: 0, res: 0, upd: 0;
       cabri: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabqS_info" {
     block_cabqS_info:
         const _cabqS;
         const 284878;
         const 30;
 },
 _cabrf() //  [R1]
         { []
         }
     {offset
       cabrf: // global
           if (R1 & 7 == 1) goto cabrw; else goto cabrB;
       cabrw: // global
           _cabqe::P64 = P64[Sp + 96];
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _cabqe::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto uabtg; else goto uabth;
       uabtg: // global
           Sp = Sp + 120;
           call _cabrU() args: 0, res: 0, upd: 0;
       uabth: // global
           Sp = Sp + 8;
           call _cabrT() args: 0, res: 0, upd: 0;
       cabrB: // global
           I64[Sp] = block_cabrz_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabtA; else goto cabrC;
       uabtA: // global
           call _cabrz(R1) args: 0, res: 0, upd: 0;
       cabrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabrf_info" {
     block_cabrf_info:
         const _cabrf;
         const 284878;
         const 30;
 },
 _cabrz() //  [R1]
         { []
         }
     {offset
       cabrz: // global
           _cabqe::P64 = P64[Sp + 96];
           if (%MO_S_Lt_W64(I64[Sp + 16] - I64[Sp + 56],
                            I64[R1 + 7])) goto cabrW; else goto uabtd;
       cabrW: // global
           _sa7ZN::P64 = P64[Sp + 40];
           _sa80u::I64 = I64[Sp + 48];
           _sa80v::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = _cabqe::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           if (_sa80u::I64 == _sa80v::I64) goto uabte; else goto uabtf;
       uabte: // global
           Sp = Sp + 120;
           call _cabrU() args: 0, res: 0, upd: 0;
       uabtf: // global
           Sp = Sp + 8;
           call _cabrT() args: 0, res: 0, upd: 0;
       uabtd: // global
           P64[Sp + 104] = _cabqe::P64;
           Sp = Sp + 24;
           call _sa80b() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabrz_info" {
     block_cabrz_info:
         const _cabrz;
         const 284878;
         const 30;
 },
 _cabrT() //  []
         { []
         }
     {offset
       cabrT: // global
           P64[Sp + 56] = P64[Sp + 56];
           _sa7ZD::I64 = I64[Sp + 64];
           I64[Sp + 64] = I64[Sp + 96];
           _sa7ZC::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sa7ZC::P64;
           I64[Sp + 88] = _sa7ZD::I64;
           I64[Sp + 96] = I64[Sp + 40];
           I64[Sp + 104] = I64[Sp];
           Sp = Sp + 56;
           call _cabpT() args: 0, res: 0, upd: 0;
     }
 },
 _sa80b() //  []
         { []
         }
     {offset
       sa80b: // global
           _sa7ZL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabqk_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sa7ZL::P64;
           P64[Sp] = P64[Sp + 80];
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cabqk() //  [R1]
         { []
         }
     {offset
       cabqk: // global
           _sa7ZN::P64 = P64[Sp + 8];
           _sa803::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sa7ZN::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa7ZN::P64);
           I64[Sp + 24] = block_cabqp_info;
           R1 = _sa803::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uabtr; else goto cabqs;
       uabtr: // global
           call _cabqp(R1) args: 0, res: 0, upd: 0;
       cabqs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabqk_info" {
     block_cabqk_info:
         const _cabqk;
         const 32138;
         const 30;
 },
 _cabqp() //  [R1]
         { []
         }
     {offset
       cabqp: // global
           _sa80l::I64 = I64[R1 + 39];
           _sa80m::I64 = I64[R1 + 47];
           if (_sa80l::I64 == _sa80m::I64) goto uabtj; else goto cabqA;
       uabtj: // global
           Sp = Sp + 64;
           call _cabrU() args: 0, res: 0, upd: 0;
       cabqA: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 40] = I64[R1 + 31];
           I64[Sp + 48] = _sa80l::I64;
           I64[Sp + 56] = _sa80m::I64;
           Sp = Sp + 8;
           call _cabpT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabqp_info" {
     block_cabqp_info:
         const _cabqp;
         const 8071;
         const 30;
 },
 _cabrU() //  []
         { []
         }
     {offset
       cabrU: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.814639624 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer1_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer1_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer1_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer1_entry() //  [R2, R3]
         { []
         }
     {offset
       cabw0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabw1; else goto cabw2;
       cabw1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.writeCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cabw2: // global
           I64[Sp - 16] = block_cabvX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabw6; else goto cabvY;
       uabw6: // global
           call _cabvX(R1) args: 0, res: 0, upd: 0;
       cabvY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.writeCharBuffer1_info" {
     GHC.IO.Handle.Internals.writeCharBuffer1_info:
         const GHC.IO.Handle.Internals.writeCharBuffer1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cabvX() //  [R1]
         { []
         }
     {offset
       cabvX: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabvX_info" {
     block_cabvX_info:
         const _cabvX;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.820286578 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer_entry() //  [R2, R3]
         { []
         }
     {offset
       cabwm: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.writeCharBuffer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.writeCharBuffer_info" {
     GHC.IO.Handle.Internals.writeCharBuffer_info:
         const GHC.IO.Handle.Internals.writeCharBuffer_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.83044069 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer3_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer3_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer3_info;
 },
 sat_sa82j_entry() //  [R1]
         { []
         }
     {offset
       cabx1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabx5; else goto cabx6;
       cabx5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabx6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabwY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabxa; else goto cabwZ;
       uabxa: // global
           call _cabwY(R1) args: 0, res: 0, upd: 0;
       cabwZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa82j_info" {
     sat_sa82j_info:
         const sat_sa82j_entry;
         const 1;
         const 16;
 },
 _cabwY() //  [R1]
         { []
         }
     {offset
       cabwY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabx9; else goto cabx8;
       cabx9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabx8: // global
           _sa82e::P64 = P64[R1 + 7];
           _sa82f::P64 = P64[R1 + 15];
           _sa82d::I64 = I64[R1 + 23];
           _sa82g::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa82e::P64;
           P64[Hp - 32] = _sa82f::P64;
           I64[Hp - 24] = _sa82d::I64;
           I64[Hp - 16] = _sa82g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabwY_info" {
     block_cabwY_info:
         const _cabwY;
         const 0;
         const 30;
 },
 sat_sa82C_entry() //  [R1]
         { []
         }
     {offset
       cabxx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabxE; else goto cabxF;
       cabxE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabxF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cabxu_info;
           _sa82s::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa82s::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabxJ; else goto cabxv;
       uabxJ: // global
           call _cabxu(R1) args: 0, res: 0, upd: 0;
       cabxv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa82C_info" {
     sat_sa82C_info:
         const sat_sa82C_entry;
         const 4294967297;
         const 19;
 },
 _cabxu() //  [R1]
         { []
         }
     {offset
       cabxu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabxI; else goto cabxH;
       cabxI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabxH: // global
           _sa82w::P64 = P64[R1 + 7];
           _sa82x::P64 = P64[R1 + 15];
           _sa82v::I64 = I64[R1 + 23];
           _sa82y::I64 = I64[R1 + 31];
           _sa82A::I64 = I64[R1 + 47];
           _sa82B::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa82w::P64;
           P64[Hp - 32] = _sa82x::P64;
           I64[Hp - 24] = _sa82v::I64;
           I64[Hp - 16] = _sa82y::I64;
           I64[Hp - 8] = _sa82B::I64;
           I64[Hp] = _sa82A::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabxu_info" {
     block_cabxu_info:
         const _cabxu;
         const 65;
         const 30;
 },
 GHC.IO.Handle.Internals.flushCharBuffer3_entry() //  [R2]
         { []
         }
     {offset
       cabxK: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cabxL; else goto cabxM;
       cabxL: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabxM: // global
           I64[Sp - 8] = block_cabwx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabyS; else goto cabwy;
       uabyS: // global
           call _cabwx(R1) args: 0, res: 0, upd: 0;
       cabwy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharBuffer3_info" {
     GHC.IO.Handle.Internals.flushCharBuffer3_info:
         const GHC.IO.Handle.Internals.flushCharBuffer3_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cabwx() //  [R1]
         { []
         }
     {offset
       cabwx: // global
           I64[Sp - 32] = block_cabwC_info;
           _sa81G::P64 = P64[R1 + 47];
           _sa81I::P64 = P64[R1 + 63];
           _sa81J::P64 = P64[R1 + 71];
           _sa81M::P64 = P64[R1 + 95];
           R1 = P64[_sa81J::P64 + 8];
           P64[Sp - 24] = _sa81I::P64;
           P64[Sp - 16] = _sa81J::P64;
           P64[Sp - 8] = _sa81M::P64;
           P64[Sp] = _sa81G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabyM; else goto cabwD;
       uabyM: // global
           call _cabwC(R1) args: 0, res: 0, upd: 0;
       cabwD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabwx_info" {
     block_cabwx_info:
         const _cabwx;
         const 0;
         const 30;
 },
 _cabwC() //  [R1]
         { []
         }
     {offset
       cabwC: // global
           I64[Sp - 16] = block_cabwH_info;
           _sa81Z::I64 = I64[R1 + 39];
           _sa820::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa820::I64;
           I64[Sp] = _sa81Z::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabyN; else goto cabwI;
       uabyN: // global
           call _cabwH(R1) args: 0, res: 0, upd: 0;
       cabwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabwC_info" {
     block_cabwC_info:
         const _cabwC;
         const 4;
         const 30;
 },
 _cabwH() //  [R1]
         { []
         }
     {offset
       cabwH: // global
           if (R1 & 7 != 1) goto cabyz; else goto cabyv;
       cabyv: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cabyz; else goto cabxR;
       cabyz: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabxR: // global
           _sa825::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_cabwP_info;
           R1 = _sa825::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uabyO; else goto cabwQ;
       uabyO: // global
           call _cabwP(R1) args: 0, res: 0, upd: 0;
       cabwQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabwH_info" {
     block_cabwH_info:
         const _cabwH;
         const 198;
         const 30;
 },
 _cabwP() //  [R1]
         { []
         }
     {offset
       cabwP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabxU; else goto cabxT;
       cabxU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabxT: // global
           _sa81J::P64 = P64[Sp + 8];
           _sa827::P64 = P64[R1 + 7];
           _sa828::P64 = P64[R1 + 15];
           _sa82b::P64 = P64[_sa81J::P64 + 8];
           I64[Hp - 16] = sat_sa82j_info;
           P64[Hp] = _sa82b::P64;
           call MO_WriteBarrier();
           P64[_sa81J::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81J::P64);
           I64[Sp - 8] = block_cabxe_info;
           R1 = _sa82b::P64;
           P64[Sp] = _sa828::P64;
           P64[Sp + 8] = _sa827::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabyP; else goto cabxf;
       uabyP: // global
           call _cabxe(R1) args: 0, res: 0, upd: 0;
       cabxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabwP_info" {
     block_cabwP_info:
         const _cabwP;
         const 3;
         const 30;
 },
 _cabxe() //  [R1]
         { []
         }
     {offset
       cabxe: // global
           _sa82s::I64 = I64[R1 + 39];
           if (_sa82s::I64 != 0) goto cabxX; else goto cabys;
       cabxX: // global
           I64[Sp - 24] = block_cabxl_info;
           _sa82n::P64 = P64[R1 + 7];
           _sa82o::P64 = P64[R1 + 15];
           _sa82m::I64 = I64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 16] = _sa82o::P64;
           I64[Sp - 8] = _sa82s::I64;
           P64[Sp] = _sa82n::P64;
           I64[Sp + 24] = _sa82m::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabyQ; else goto cabxm;
       uabyQ: // global
           call _cabxl(R1) args: 0, res: 0, upd: 0;
       cabxm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabys: // global
           _sa81G::P64 = P64[Sp + 32];
           _sa828::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = _sa828::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabxe_info" {
     block_cabxe_info:
         const _cabxe;
         const 4;
         const 30;
 },
 _cabxl() //  [R1]
         { []
         }
     {offset
       cabxl: // global
           if (R1 & 7 == 1) goto cabxZ; else goto cabyh;
       cabxZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caby2; else goto caby1;
       caby2: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caby1: // global
           I64[Hp - 24] = sat_sa82C_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sa81G::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabyh: // global
           I64[Sp] = block_caby5_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabyR; else goto caby6;
       uabyR: // global
           call _caby5(R1) args: 0, res: 0, upd: 0;
       caby6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabxl_info" {
     block_cabxl_info:
         const _cabxl;
         const 2183;
         const 30;
 },
 _caby5() //  [R1]
         { []
         }
     {offset
       caby5: // global
           I64[Sp - 8] = block_cabya_info;
           R2 = P64[Sp + 40];
           _sa82G::P64 = P64[R1 + 7];
           _sa82H::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa82H::P64;
           P64[Sp + 40] = _sa82G::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caby5_info" {
     block_caby5_info:
         const _caby5;
         const 2183;
         const 30;
 },
 _cabya() //  [R1]
         { []
         }
     {offset
       cabya: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabyl; else goto cabyk;
       cabyl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabyk: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 56] = block_cabyd_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 48];
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabya_info" {
     block_cabya_info:
         const _cabya;
         const 4360;
         const 30;
 },
 _cabyd() //  [R1]
         { []
         }
     {offset
       cabyd: // global
           I64[Sp] = block_cabyf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabyT; else goto cabyn;
       uabyT: // global
           call _cabyf(R1) args: 0, res: 0, upd: 0;
       cabyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabyd_info" {
     block_cabyd_info:
         const _cabyd;
         const 1;
         const 30;
 },
 _cabyf() //  [R1]
         { []
         }
     {offset
       cabyf: // global
           _sa81G::P64 = P64[Sp + 8];
           _sa82T::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa81G::P64 + 8] = _sa82T::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa81G::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabyf_info" {
     block_cabyf_info:
         const _cabyf;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.859439909 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharReadBuffer_info;
 },
 GHC.IO.Handle.Internals.flushCharReadBuffer_entry() //  [R2]
         { []
         }
     {offset
       cabAk: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharReadBuffer_info" {
     GHC.IO.Handle.Internals.flushCharReadBuffer_info:
         const GHC.IO.Handle.Internals.flushCharReadBuffer_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.862579005 UTC

[section ""cstring" . lvl9_ra7Pp_bytes" {
     lvl9_ra7Pp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.864846019 UTC

[section ""data" . lvl10_ra7Pq_closure" {
     lvl10_ra7Pq_closure:
         const lvl10_ra7Pq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ra7Pq_entry() //  [R1]
         { []
         }
     {offset
       cabAy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabAz; else goto cabAA;
       cabAz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabAA: // global
           (_cabAv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabAv::I64 == 0) goto cabAx; else goto cabAw;
       cabAx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabAw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabAv::I64;
           R2 = lvl9_ra7Pp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl10_ra7Pq_info" {
     lvl10_ra7Pq_info:
         const lvl10_ra7Pq_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.869356697 UTC

[section ""data" . lvl11_ra7Pr_closure" {
     lvl11_ra7Pr_closure:
         const lvl11_ra7Pr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_ra7Pr_entry() //  [R1]
         { []
         }
     {offset
       cabAO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabAP; else goto cabAQ;
       cabAP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabAQ: // global
           (_cabAL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabAL::I64 == 0) goto cabAN; else goto cabAM;
       cabAN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabAM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabAL::I64;
           R2 = GHC.IO.Handle.Internals.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl11_ra7Pr_info" {
     lvl11_ra7Pr_info:
         const lvl11_ra7Pr_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.873445051 UTC

[section ""data" . lvl12_ra7Ps_closure" {
     lvl12_ra7Ps_closure:
         const lvl12_ra7Ps_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ra7Ps_entry() //  [R1]
         { []
         }
     {offset
       cabB4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabB5; else goto cabB6;
       cabB5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabB6: // global
           (_cabB1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabB1::I64 == 0) goto cabB3; else goto cabB2;
       cabB3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabB2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabB1::I64;
           R2 = GHC.IO.Handle.Internals.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl12_ra7Ps_info" {
     lvl12_ra7Ps_info:
         const lvl12_ra7Ps_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.877005826 UTC

[section ""cstring" . lvl13_ra7Pt_bytes" {
     lvl13_ra7Pt_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.879774683 UTC

[section ""data" . lvl14_ra7Pu_closure" {
     lvl14_ra7Pu_closure:
         const lvl14_ra7Pu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ra7Pu_entry() //  [R1]
         { []
         }
     {offset
       cabBl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabBm; else goto cabBn;
       cabBm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabBn: // global
           (_cabBi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabBi::I64 == 0) goto cabBk; else goto cabBj;
       cabBk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabBj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabBi::I64;
           R2 = lvl13_ra7Pt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl14_ra7Pu_info" {
     lvl14_ra7Pu_info:
         const lvl14_ra7Pu_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.883448331 UTC

[section ""data" . lvl15_ra7Pv_closure" {
     lvl15_ra7Pv_closure:
         const GHC.Types.I#_con_info;
         const 487;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.885105398 UTC

[section ""data" . lvl16_ra7Pw_closure" {
     lvl16_ra7Pw_closure:
         const GHC.Types.I#_con_info;
         const 12;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.886822074 UTC

[section ""data" . lvl17_ra7Px_closure" {
     lvl17_ra7Px_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.888587026 UTC

[section ""data" . lvl18_ra7Py_closure" {
     lvl18_ra7Py_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl11_ra7Pr_closure;
         const lvl12_ra7Ps_closure;
         const lvl14_ra7Pu_closure;
         const lvl15_ra7Pv_closure+1;
         const lvl16_ra7Pw_closure+1;
         const lvl15_ra7Pv_closure+1;
         const lvl17_ra7Px_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.890939357 UTC

[section ""data" . lvl19_ra7Pz_closure" {
     lvl19_ra7Pz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl10_ra7Pq_closure;
         const lvl18_ra7Py_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.892743819 UTC

[section ""cstring" . lvl20_ra7PA_bytes" {
     lvl20_ra7PA_bytes:
         I8[] [105,110,116,101,114,110,97,108,32,73,79,32,108,105,98,114,97,114,121,32,101,114,114,111,114,58,32,67,104,97,114,32,98,117,102,102,101,114,32,110,111,110,45,101,109,112,116,121]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.895445164 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer2_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer2_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer2_entry() //  [R1]
         { []
         }
     {offset
       cabBJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabBK; else goto cabBL;
       cabBK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabBL: // global
           (_cabBE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabBE::I64 == 0) goto cabBG; else goto cabBF;
       cabBG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabBF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabBE::I64;
           I64[Sp - 24] = block_cabBH_info;
           R2 = lvl20_ra7PA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharBuffer2_info" {
     GHC.IO.Handle.Internals.flushCharBuffer2_info:
         const GHC.IO.Handle.Internals.flushCharBuffer2_entry;
         const 0;
         const 12884901909;
         const Sa8nI_srt+232;
 },
 _cabBH() //  [R1]
         { []
         }
     {offset
       cabBH: // global
           R3 = R1;
           R2 = lvl19_ra7Pz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabBH_info" {
     block_cabBH_info:
         const _cabBH;
         const 0;
         const 12884901918;
         const Sa8nI_srt+232;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.902714425 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer1_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer1_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer1_entry() //  [R2]
         { []
         }
     {offset
       cabC6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabCa; else goto cabCb;
       cabCa: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabCb: // global
           I64[Sp - 8] = block_cabC3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabCB; else goto cabC4;
       uabCB: // global
           call _cabC3(R1) args: 0, res: 0, upd: 0;
       cabC4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharBuffer1_info" {
     GHC.IO.Handle.Internals.flushCharBuffer1_info:
         const GHC.IO.Handle.Internals.flushCharBuffer1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Sa8nI_srt+248;
 },
 _cabC3() //  [R1]
         { []
         }
     {offset
       cabC3: // global
           _sa83j::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_cabC9_info;
           _sa830::P64 = R1;
           R1 = _sa83j::P64;
           P64[Sp] = _sa830::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabCA; else goto cabCd;
       uabCA: // global
           call _cabC9(R1) args: 0, res: 0, upd: 0;
       cabCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabC3_info" {
     block_cabC3_info:
         const _cabC3;
         const 0;
         const 4294967326;
         const Sa8nI_srt+256;
 },
 _cabC9() //  [R1]
         { []
         }
     {offset
       cabC9: // global
           I64[Sp - 16] = block_cabCh_info;
           _sa83p::I64 = I64[R1 + 39];
           _sa83q::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa83q::I64;
           I64[Sp] = _sa83p::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabCC; else goto cabCj;
       uabCC: // global
           call _cabCh(R1) args: 0, res: 0, upd: 0;
       cabCj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabC9_info" {
     block_cabC9_info:
         const _cabC9;
         const 1;
         const 4294967326;
         const Sa8nI_srt+256;
 },
 _cabCh() //  [R1]
         { []
         }
     {offset
       cabCh: // global
           if (R1 & 7 == 1) goto cabCp; else goto cabCy;
       cabCp: // global
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
       cabCy: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cabCx; else goto cabCw;
       cabCx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabCw: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabCh_info" {
     block_cabCh_info:
         const _cabCh;
         const 195;
         const 4294967326;
         const Sa8nI_srt+256;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.911170231 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer_entry() //  [R2]
         { []
         }
     {offset
       cabD3: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharBuffer_info" {
     GHC.IO.Handle.Internals.flushCharBuffer_info:
         const GHC.IO.Handle.Internals.flushCharBuffer_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Sa8nI_srt+248;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.918299233 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer2_closure" {
     GHC.IO.Handle.Internals.flushBuffer2_closure:
         const GHC.IO.Handle.Internals.flushBuffer2_info;
         const 0;
 },
 sat_sa844_entry() //  [R1]
         { []
         }
     {offset
       cabDF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabDG; else goto cabDH;
       cabDG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabDH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -(I64[R1 + 24] - I64[R1 + 16]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa844_info" {
     sat_sa844_info:
         const sat_sa844_entry;
         const 8589934592;
         const 20;
 },
 GHC.IO.Handle.Internals.flushBuffer2_entry() //  [R2]
         { []
         }
     {offset
       cabDK: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cabDL; else goto cabDM;
       cabDL: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabDM: // global
           I64[Sp - 8] = block_cabDe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabEd; else goto cabDf;
       uabEd: // global
           call _cabDe(R1) args: 0, res: 0, upd: 0;
       cabDf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer2_info" {
     GHC.IO.Handle.Internals.flushBuffer2_info:
         const GHC.IO.Handle.Internals.flushBuffer2_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Sa8nI_srt+264;
 },
 _cabDe() //  [R1]
         { []
         }
     {offset
       cabDe: // global
           I64[Sp - 24] = block_cabDj_info;
           _sa83x::P64 = P64[R1 + 7];
           _sa83A::P64 = P64[R1 + 31];
           _sa83C::P64 = P64[R1 + 47];
           R1 = P64[_sa83C::P64 + 8];
           P64[Sp - 16] = _sa83A::P64;
           P64[Sp - 8] = _sa83C::P64;
           P64[Sp] = _sa83x::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabEb; else goto cabDk;
       uabEb: // global
           call _cabDj(R1) args: 0, res: 0, upd: 0;
       cabDk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabDe_info" {
     block_cabDe_info:
         const _cabDe;
         const 0;
         const 4294967326;
         const Sa8nI_srt+272;
 },
 _cabDj() //  [R1]
         { []
         }
     {offset
       cabDj: // global
           _sa83V::I64 = I64[R1 + 39];
           _sa83W::I64 = I64[R1 + 47];
           if (_sa83V::I64 == _sa83W::I64) goto cabE5; else goto cabDQ;
       cabE5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabDQ: // global
           I64[Sp - 48] = block_cabDr_info;
           R2 = P64[Sp + 24];
           I64[Sp - 64] = stg_ap_pv_info;
           P64[Sp - 56] = P64[Sp + 8];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sa83V::I64;
           I64[Sp - 8] = _sa83W::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabDj_info" {
     block_cabDj_info:
         const _cabDj;
         const 3;
         const 4294967326;
         const Sa8nI_srt+272;
 },
 _cabDr() //  [R1]
         { []
         }
     {offset
       cabDr: // global
           I64[Sp] = block_cabDt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabEc; else goto cabDu;
       uabEc: // global
           call _cabDt(R1) args: 0, res: 0, upd: 0;
       cabDu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabDr_info" {
     block_cabDr_info:
         const _cabDr;
         const 3849;
         const 4294967326;
         const Sa8nI_srt+272;
 },
 _cabDt() //  [R1]
         { []
         }
     {offset
       cabDt: // global
           if (R1 & 7 == 1) goto cabDV; else goto cabDX;
       cabDV: // global
           R1 = GHC.IO.Handle.Internals.flushBuffer3_closure;
           Sp = Sp + 80;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabDX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cabE0; else goto cabDZ;
       cabE0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabDZ: // global
           I64[Hp - 24] = sat_sa844_info;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 40];
           I64[Sp] = block_cabDW_info;
           R2 = P64[Sp + 72];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 16] = GHC.IO.Device.RelativeSeek_closure+2;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabDt_info" {
     block_cabDt_info:
         const _cabDt;
         const 3849;
         const 4294967326;
         const Sa8nI_srt+272;
 },
 _cabDW() //  [R1]
         { []
         }
     {offset
       cabDW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabE4; else goto cabE3;
       cabE4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabE3: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sa83C::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sa83C::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa83C::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabDW_info" {
     block_cabDW_info:
         const _cabDW;
         const 24329;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.932691024 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteReadBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushByteReadBuffer_entry() //  [R2]
         { []
         }
     {offset
       cabF4: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushByteReadBuffer_info" {
     GHC.IO.Handle.Internals.flushByteReadBuffer_info:
         const GHC.IO.Handle.Internals.flushByteReadBuffer_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Sa8nI_srt+264;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.944213543 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer1_closure" {
     GHC.IO.Handle.Internals.flushBuffer1_closure:
         const GHC.IO.Handle.Internals.flushBuffer1_info;
         const 0;
 },
 sat_sa856_entry() //  [R1]
         { []
         }
     {offset
       cabFT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabFX; else goto cabFY;
       cabFX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabFY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cabFQ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabG2; else goto cabFR;
       uabG2: // global
           call _cabFQ(R1) args: 0, res: 0, upd: 0;
       cabFR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa856_info" {
     sat_sa856_info:
         const sat_sa856_entry;
         const 1;
         const 16;
 },
 _cabFQ() //  [R1]
         { []
         }
     {offset
       cabFQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabG1; else goto cabG0;
       cabG1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabG0: // global
           _sa851::P64 = P64[R1 + 7];
           _sa852::P64 = P64[R1 + 15];
           _sa850::I64 = I64[R1 + 23];
           _sa853::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa851::P64;
           P64[Hp - 32] = _sa852::P64;
           I64[Hp - 24] = _sa850::I64;
           I64[Hp - 16] = _sa853::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabFQ_info" {
     block_cabFQ_info:
         const _cabFQ;
         const 0;
         const 30;
 },
 sat_sa85p_entry() //  [R1]
         { []
         }
     {offset
       cabGp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabGw; else goto cabGx;
       cabGw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabGx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cabGm_info;
           _sa85f::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa85f::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabGB; else goto cabGn;
       uabGB: // global
           call _cabGm(R1) args: 0, res: 0, upd: 0;
       cabGn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa85p_info" {
     sat_sa85p_info:
         const sat_sa85p_entry;
         const 4294967297;
         const 19;
 },
 _cabGm() //  [R1]
         { []
         }
     {offset
       cabGm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabGA; else goto cabGz;
       cabGA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cabGz: // global
           _sa85j::P64 = P64[R1 + 7];
           _sa85k::P64 = P64[R1 + 15];
           _sa85i::I64 = I64[R1 + 23];
           _sa85l::I64 = I64[R1 + 31];
           _sa85n::I64 = I64[R1 + 47];
           _sa85o::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa85j::P64;
           P64[Hp - 32] = _sa85k::P64;
           I64[Hp - 24] = _sa85i::I64;
           I64[Hp - 16] = _sa85l::I64;
           I64[Hp - 8] = _sa85o::I64;
           I64[Hp] = _sa85n::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabGm_info" {
     block_cabGm_info:
         const _cabGm;
         const 65;
         const 30;
 },
 GHC.IO.Handle.Internals.flushBuffer1_entry() //  [R2]
         { []
         }
     {offset
       cabGC: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cabGD; else goto cabGE;
       cabGD: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabGE: // global
           I64[Sp - 8] = block_cabFf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabIe; else goto cabFg;
       uabIe: // global
           call _cabFf(R1) args: 0, res: 0, upd: 0;
       cabFg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer1_info" {
     GHC.IO.Handle.Internals.flushBuffer1_info:
         const GHC.IO.Handle.Internals.flushBuffer1_entry;
         const 0;
         const 21474836494;
         const 8589934597;
         const Sa8nI_srt+264;
 },
 _cabFf() //  [R1]
         { []
         }
     {offset
       cabFf: // global
           I64[Sp - 56] = block_cabFk_info;
           _sa84c::P64 = R1;
           _sa84e::P64 = P64[R1 + 15];
           _sa84g::P64 = P64[R1 + 31];
           _sa84i::P64 = P64[R1 + 47];
           _sa84k::P64 = P64[R1 + 63];
           _sa84l::P64 = P64[R1 + 71];
           _sa84o::P64 = P64[R1 + 95];
           R1 = P64[_sa84l::P64 + 8];
           P64[Sp - 48] = _sa84e::P64;
           P64[Sp - 40] = _sa84g::P64;
           P64[Sp - 32] = _sa84i::P64;
           P64[Sp - 24] = _sa84k::P64;
           P64[Sp - 16] = _sa84l::P64;
           P64[Sp - 8] = _sa84o::P64;
           P64[Sp] = _sa84c::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uabI5; else goto cabFl;
       uabI5: // global
           call _cabFk(R1) args: 0, res: 0, upd: 0;
       cabFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabFf_info" {
     block_cabFf_info:
         const _cabFf;
         const 0;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabFk() //  [R1]
         { []
         }
     {offset
       cabFk: // global
           I64[Sp] = block_cabFp_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uabI6; else goto cabFq;
       uabI6: // global
           call _cabFp(R1) args: 0, res: 0, upd: 0;
       cabFq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabFk_info" {
     block_cabFk_info:
         const _cabFk;
         const 7;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabFp() //  [R1]
         { []
         }
     {offset
       cabFp: // global
           if (R1 & 7 == 1) goto cabGJ; else goto cabHA;
       cabGJ: // global
           _sa84G::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_cabFu_info;
           R1 = _sa84G::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabI7; else goto cabFv;
       uabI7: // global
           call _cabFu(R1) args: 0, res: 0, upd: 0;
       cabFv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabHA: // global
           _sa85M::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cabHy_info;
           R1 = _sa85M::P64;
           if (R1 & 7 != 0) goto uabI8; else goto cabHB;
       uabI8: // global
           call _cabHy(R1) args: 0, res: 0, upd: 0;
       cabHB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabFp_info" {
     block_cabFp_info:
         const _cabFp;
         const 7;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabFu() //  [R1]
         { []
         }
     {offset
       cabFu: // global
           I64[Sp - 16] = block_cabFz_info;
           _sa84M::I64 = I64[R1 + 39];
           _sa84N::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa84N::I64;
           I64[Sp] = _sa84M::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabI9; else goto cabFA;
       uabI9: // global
           call _cabFz(R1) args: 0, res: 0, upd: 0;
       cabFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabFu_info" {
     block_cabFu_info:
         const _cabFu;
         const 5;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabFz() //  [R1]
         { []
         }
     {offset
       cabFz: // global
           _sa84c::P64 = P64[Sp + 56];
           if (R1 & 7 != 1) goto cabHv; else goto cabHr;
       cabHr: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cabHv; else goto cabGN;
       cabHv: // global
           R2 = _sa84c::P64;
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       cabGN: // global
           _sa84S::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cabFH_info;
           R1 = _sa84S::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabIa; else goto cabFI;
       uabIa: // global
           call _cabFH(R1) args: 0, res: 0, upd: 0;
       cabFI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabFz_info" {
     block_cabFz_info:
         const _cabFz;
         const 199;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabFH() //  [R1]
         { []
         }
     {offset
       cabFH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabGQ; else goto cabGP;
       cabGQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabGP: // global
           _sa84l::P64 = P64[Sp + 24];
           _sa84U::P64 = P64[R1 + 7];
           _sa84V::P64 = P64[R1 + 15];
           _sa84Y::P64 = P64[_sa84l::P64 + 8];
           I64[Hp - 16] = sat_sa856_info;
           P64[Hp] = _sa84Y::P64;
           call MO_WriteBarrier();
           P64[_sa84l::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84l::P64);
           I64[Sp] = block_cabG6_info;
           R1 = _sa84Y::P64;
           P64[Sp + 16] = _sa84V::P64;
           P64[Sp + 24] = _sa84U::P64;
           if (R1 & 7 != 0) goto uabIb; else goto cabG7;
       uabIb: // global
           call _cabG6(R1) args: 0, res: 0, upd: 0;
       cabG7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabFH_info" {
     block_cabFH_info:
         const _cabFH;
         const 133;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabG6() //  [R1]
         { []
         }
     {offset
       cabG6: // global
           _sa85f::I64 = I64[R1 + 39];
           if (_sa85f::I64 != 0) goto cabGT; else goto cabHo;
       cabGT: // global
           I64[Sp - 24] = block_cabGd_info;
           _sa85a::P64 = P64[R1 + 7];
           _sa85b::P64 = P64[R1 + 15];
           _sa859::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sa85b::P64;
           I64[Sp - 8] = _sa85f::I64;
           P64[Sp] = _sa85a::P64;
           I64[Sp + 32] = _sa859::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uabIc; else goto cabGe;
       uabIc: // global
           call _cabGd(R1) args: 0, res: 0, upd: 0;
       cabGe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabHo: // global
           _sa84c::P64 = P64[Sp + 40];
           _sa84i::P64 = P64[Sp + 8];
           _sa84V::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = _sa84V::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabG6_info" {
     block_cabG6_info:
         const _cabG6;
         const 5;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabGd() //  [R1]
         { []
         }
     {offset
       cabGd: // global
           if (R1 & 7 == 1) goto cabGV; else goto cabHd;
       cabGV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cabGY; else goto cabGX;
       cabGY: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabGX: // global
           I64[Hp - 24] = sat_sa85p_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sa84c::P64 = P64[Sp + 64];
           _sa84i::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       cabHd: // global
           I64[Sp] = block_cabH1_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabId; else goto cabH2;
       uabId: // global
           call _cabH1(R1) args: 0, res: 0, upd: 0;
       cabH2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabGd_info" {
     block_cabGd_info:
         const _cabGd;
         const 4232;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabH1() //  [R1]
         { []
         }
     {offset
       cabH1: // global
           I64[Sp - 8] = block_cabH6_info;
           R2 = P64[Sp + 48];
           _sa85t::P64 = P64[R1 + 7];
           _sa85u::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa85u::P64;
           P64[Sp + 48] = _sa85t::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabH1_info" {
     block_cabH1_info:
         const _cabH1;
         const 4232;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabH6() //  [R1]
         { []
         }
     {offset
       cabH6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabHh; else goto cabHg;
       cabHh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabHg: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cabH9_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabH6_info" {
     block_cabH6_info:
         const _cabH6;
         const 8457;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabH9() //  [R1]
         { []
         }
     {offset
       cabH9: // global
           I64[Sp] = block_cabHb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabIf; else goto cabHj;
       uabIf: // global
           call _cabHb(R1) args: 0, res: 0, upd: 0;
       cabHj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabH9_info" {
     block_cabH9_info:
         const _cabH9;
         const 901;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabHb() //  [R1]
         { []
         }
     {offset
       cabHb: // global
           _sa84c::P64 = P64[Sp + 40];
           _sa84i::P64 = P64[Sp + 8];
           _sa85G::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = _sa85G::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R2 = _sa84c::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabHb_info" {
     block_cabHb_info:
         const _cabHb;
         const 901;
         const 4294967326;
         const Sa8nI_srt+264;
 },
 _cabHy() //  [R1]
         { []
         }
     {offset
       cabHy: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabHO; else goto cabHL;
       cabHO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabHL: // global
           _sa84g::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabHJ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa84g::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabHy_info" {
     block_cabHy_info:
         const _cabHy;
         const 7687;
         const 30;
 },
 _cabHJ() //  [R1]
         { []
         }
     {offset
       cabHJ: // global
           _sa84i::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa84i::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa84i::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabHJ_info" {
     block_cabHJ_info:
         const _cabHJ;
         const 1925;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.979715416 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer_closure" {
     GHC.IO.Handle.Internals.flushBuffer_closure:
         const GHC.IO.Handle.Internals.flushBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer_entry() //  [R2]
         { []
         }
     {offset
       cabJZ: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer_info" {
     GHC.IO.Handle.Internals.flushBuffer_info:
         const GHC.IO.Handle.Internals.flushBuffer_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Sa8nI_srt+280;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.982737739 UTC

[section ""cstring" . lvl21_ra7PB_bytes" {
     lvl21_ra7PB_bytes:
         I8[] [71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,56,56,49,58,55,45,51,48,124,74,117,115,116,32,100,101,99,111,100,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:07.984980374 UTC

[section ""data" . lvl22_ra7PC_closure" {
     lvl22_ra7PC_closure:
         const lvl22_ra7PC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ra7PC_entry() //  [R1]
         { []
         }
     {offset
       cabKd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabKe; else goto cabKf;
       cabKe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabKf: // global
           (_cabKa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cabKa::I64 == 0) goto cabKc; else goto cabKb;
       cabKc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cabKb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cabKa::I64;
           R2 = lvl21_ra7PB_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl22_ra7PC_info" {
     lvl22_ra7PC_info:
         const lvl22_ra7PC_entry;
         const 0;
         const 4294967317;
         const Sa8nI_srt+288;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.005259015 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_2_closure" {
     GHC.IO.Handle.Internals.hLookAhead_2_closure:
         const GHC.IO.Handle.Internals.hLookAhead_2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_2_entry() //  [R2, R3]
         { []
         }
     {offset
       cabKu: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cabKy; else goto cabKz;
       cabKy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cabKz: // global
           I64[Sp - 16] = block_cabKr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabMZ; else goto cabKs;
       uabMZ: // global
           call _cabKr(R1) args: 0, res: 0, upd: 0;
       cabKs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hLookAhead_2_info" {
     GHC.IO.Handle.Internals.hLookAhead_2_info:
         const GHC.IO.Handle.Internals.hLookAhead_2_entry;
         const 0;
         const 13836183959483973646;
         const 12884901903;
         const Sa8nI_srt+56;
 },
 _cabKr() //  [R1]
         { []
         }
     {offset
       cabKr: // global
           I64[Sp - 48] = block_cabKx_info;
           _sa862::P64 = R1;
           _sa864::P64 = P64[R1 + 15];
           _sa866::P64 = P64[R1 + 31];
           _sa868::P64 = P64[R1 + 47];
           _sa86a::P64 = P64[R1 + 63];
           _sa86e::P64 = P64[R1 + 95];
           R1 = P64[_sa868::P64 + 8];
           P64[Sp - 40] = _sa864::P64;
           P64[Sp - 32] = _sa866::P64;
           P64[Sp - 24] = _sa868::P64;
           P64[Sp - 16] = _sa86a::P64;
           P64[Sp - 8] = _sa86e::P64;
           P64[Sp] = _sa862::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uabMY; else goto cabKB;
       uabMY: // global
           call _cabKx(R1) args: 0, res: 0, upd: 0;
       cabKB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabKr_info" {
     block_cabKr_info:
         const _cabKr;
         const 1;
         const 9224497941056585758;
         const Sa8nI_srt+56;
 },
 _cabKx() //  [R1]
         { []
         }
     {offset
       cabKx: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabMJ; else goto cabMy;
       cabMJ: // global
           _sa866::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabMB_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa866::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cabMy: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sa86t() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabKx_info" {
     block_cabKx_info:
         const _cabKx;
         const 7;
         const 9224497941056585758;
         const Sa8nI_srt+56;
 },
 _cabMB() //  [R1]
         { []
         }
     {offset
       cabMB: // global
           I64[Sp] = block_cabMD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabNa; else goto cabME;
       uabNa: // global
           call _cabMD(R1) args: 0, res: 0, upd: 0;
       cabME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabMB_info" {
     block_cabMB_info:
         const _cabMB;
         const 5;
         const 9224497941056585758;
         const Sa8nI_srt+56;
 },
 _cabMD() //  [R1]
         { []
         }
     {offset
       cabMD: // global
           I64[Sp - 8] = block_cabMI_info;
           _sa87O::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa87O::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabNb; else goto cabMM;
       uabNb: // global
           call _cabMI(R1) args: 0, res: 0, upd: 0;
       cabMM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabMD_info" {
     block_cabMD_info:
         const _cabMD;
         const 5;
         const 9224497941056585758;
         const Sa8nI_srt+56;
 },
 _cabMI() //  [R1]
         { []
         }
     {offset
       cabMI: // global
           if (I64[R1 + 7] == 0) goto cabMU; else goto cabMT;
       cabMU: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabMT: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _sa86t() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabMI_info" {
     block_cabMI_info:
         const _cabMI;
         const 6;
         const 9224497941056585758;
         const Sa8nI_srt+56;
 },
 _sa86t() //  []
         { []
         }
     {offset
       sa86t: // global
           I64[Sp - 8] = block_cabKL_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabNd; else goto cabKN;
       uabNd: // global
           call _cabKL(R1) args: 0, res: 0, upd: 0;
       cabKN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabKL() //  [R1]
         { []
         }
     {offset
       cabKL: // global
           if (R1 & 7 == 1) goto cabLc; else goto cabM5;
       cabLc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabLf; else goto cabLe;
       cabLf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabLe: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sa86v::P64 = P64[Sp + 8];
           P64[Hp] = _sa86v::P64;
           _sa860::P64 = P64[Sp + 48];
           _sa86a::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa86a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa86a::P64);
           I64[Sp + 8] = block_cabKV_info;
           R3 = _sa860::P64;
           R2 = _sa86v::P64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cabM5: // global
           I64[Sp] = block_cabLD_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabN1; else goto cabLE;
       uabN1: // global
           call _cabLD(R1) args: 0, res: 0, upd: 0;
       cabLE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabKL_info" {
     block_cabKL_info:
         const _cabKL;
         const 518;
         const 35188667056158;
         const Sa8nI_srt+200;
 },
 _cabKV() //  [R1]
         { []
         }
     {offset
       cabKV: // global
           I64[Sp] = block_cabKX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabN2; else goto cabKY;
       uabN2: // global
           call _cabKX(R1) args: 0, res: 0, upd: 0;
       cabKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabKV_info" {
     block_cabKV_info:
         const _cabKV;
         const 389;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabKX() //  [R1]
         { []
         }
     {offset
       cabKX: // global
           _sa868::P64 = P64[Sp + 8];
           _sa86E::P64 = P64[R1 + 15];
           _sa86F::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sa868::P64 + 8] = _sa86E::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa868::P64);
           I64[Sp + 16] = block_cabL5_info;
           R1 = _sa86F::P64;
           P64[Sp + 24] = _sa86E::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabN3; else goto cabL6;
       uabN3: // global
           call _cabL5(R1) args: 0, res: 0, upd: 0;
       cabL6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabKX_info" {
     block_cabKX_info:
         const _cabKX;
         const 389;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabL5() //  [R1]
         { []
         }
     {offset
       cabL5: // global
           I64[Sp - 8] = block_cabLa_info;
           _sa86H::P64 = R1;
           _sa86N::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sa86N::I64;
           P64[Sp + 24] = _sa86H::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabN4; else goto cabLj;
       uabN4: // global
           call _cabLa(R1) args: 0, res: 0, upd: 0;
       cabLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabL5_info" {
     block_cabL5_info:
         const _cabL5;
         const 3;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabLa() //  [R1]
         { []
         }
     {offset
       cabLa: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto cabLv; else goto cabLr;
       cabLv: // global
           _sa86E::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabLu_info;
           _sa86O::P64 = R1;
           R1 = _sa86E::P64;
           P64[Sp + 32] = _sa86O::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabN5; else goto cabLw;
       uabN5: // global
           call _cabLu(R1) args: 0, res: 0, upd: 0;
       cabLw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabLr: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabLa_info" {
     block_cabLa_info:
         const _cabLa;
         const 68;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabLu() //  [R1]
         { []
         }
     {offset
       cabLu: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabLu_info" {
     block_cabLu_info:
         const _cabLu;
         const 2;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabLD() //  [R1]
         { []
         }
     {offset
       cabLD: // global
           I64[Sp - 8] = block_cabLI_info;
           _sa875::P64 = P64[R1 + 7];
           _sa876::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sa876::P64;
           P64[Sp + 32] = _sa875::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabLD_info" {
     block_cabLD_info:
         const _cabLD;
         const 518;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabLI() //  [R1]
         { []
         }
     {offset
       cabLI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabM9; else goto cabM8;
       cabM9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabM8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa86v::P64 = P64[Sp + 16];
           P64[Hp] = _sa86v::P64;
           _sa860::P64 = P64[Sp + 56];
           _sa86a::P64 = P64[Sp + 32];
           _sa875::P64 = P64[Sp + 40];
           _sa876::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa86a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa86a::P64);
           I64[Sp + 16] = block_cabLO_info;
           R5 = _sa860::P64;
           R4 = _sa86v::P64;
           R3 = _sa876::P64;
           R2 = _sa875::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabLI_info" {
     block_cabLI_info:
         const _cabLI;
         const 7;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabLO() //  [R1]
         { []
         }
     {offset
       cabLO: // global
           I64[Sp] = block_cabLQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabN6; else goto cabLR;
       uabN6: // global
           call _cabLQ(R1) args: 0, res: 0, upd: 0;
       cabLR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabLO_info" {
     block_cabLO_info:
         const _cabLO;
         const 389;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabLQ() //  [R1]
         { []
         }
     {offset
       cabLQ: // global
           _sa868::P64 = P64[Sp + 8];
           _sa87j::P64 = P64[R1 + 7];
           _sa87k::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa868::P64 + 8] = _sa87j::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa868::P64);
           I64[Sp + 16] = block_cabLY_info;
           R1 = _sa87k::P64;
           P64[Sp + 24] = _sa87j::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabN7; else goto cabLZ;
       uabN7: // global
           call _cabLY(R1) args: 0, res: 0, upd: 0;
       cabLZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabLQ_info" {
     block_cabLQ_info:
         const _cabLQ;
         const 389;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabLY() //  [R1]
         { []
         }
     {offset
       cabLY: // global
           I64[Sp - 8] = block_cabM3_info;
           _sa87m::P64 = R1;
           _sa87s::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sa87s::I64;
           P64[Sp + 24] = _sa87m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabN8; else goto cabMd;
       uabN8: // global
           call _cabM3(R1) args: 0, res: 0, upd: 0;
       cabMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabLY_info" {
     block_cabLY_info:
         const _cabLY;
         const 3;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabM3() //  [R1]
         { []
         }
     {offset
       cabM3: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto cabMp; else goto cabMl;
       cabMp: // global
           _sa87j::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabMo_info;
           _sa87t::P64 = R1;
           R1 = _sa87j::P64;
           P64[Sp + 32] = _sa87t::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uabN9; else goto cabMq;
       uabN9: // global
           call _cabMo(R1) args: 0, res: 0, upd: 0;
       cabMq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabMl: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabM3_info" {
     block_cabM3_info:
         const _cabM3;
         const 68;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 _cabMo() //  [R1]
         { []
         }
     {offset
       cabMo: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabMo_info" {
     block_cabMo_info:
         const _cabMo;
         const 2;
         const 4294967326;
         const Sa8nI_srt+304;
 },
 section ""data" . GHC.IO.Handle.Internals.$wreadTextDevice'_closure" {
     GHC.IO.Handle.Internals.$wreadTextDevice'_closure:
         const GHC.IO.Handle.Internals.$wreadTextDevice'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_slow() //  [R1]
         { []
         }
     {offset
       cabNf: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uabQs_srtd" {
     uabQs_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 7516192769;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { []
         }
     {offset
       cabNm: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cabNM; else goto uabQ5;
       cabNM: // global
           R1 = GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       uabQ5: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cabNg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wreadTextDevice'_info" {
     GHC.IO.Handle.Internals.$wreadTextDevice'_info:
         const GHC.IO.Handle.Internals.$wreadTextDevice'_entry;
         const 0;
         const 18446744069414584334;
         const 38654705664;
         const uabQs_srtd;
         const 7304;
         const GHC.IO.Handle.Internals.$wreadTextDevice'_slow;
 },
 _cabNg() //  []
         { []
         }
     {offset
       cabNg: // global
           _sa87T::P64 = P64[Sp];
           I64[Sp] = block_cabNj_info;
           R1 = _sa87T::P64;
           if (R1 & 7 != 0) goto uabQ9; else goto cabNk;
       uabQ9: // global
           call _cabNj(R1) args: 0, res: 0, upd: 0;
       cabNk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uabQt_srtd" {
     uabQt_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabNj() //  [R1]
         { []
         }
     {offset
       cabNj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cabNQ; else goto cabNP;
       cabNQ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabNP: // global
           _sa87U::I64 = I64[Sp + 8];
           _sa87V::P64 = P64[Sp + 16];
           _sa87W::P64 = P64[Sp + 24];
           _sa87X::I64 = I64[Sp + 32];
           _sa87Y::I64 = I64[Sp + 40];
           _sa884::P64 = P64[R1 + 15];
           _sa886::P64 = P64[R1 + 31];
           _sa888::P64 = P64[R1 + 47];
           _sa88a::P64 = P64[R1 + 63];
           _sa88e::P64 = P64[R1 + 95];
           _sa88j::I64 = I64[Sp + 48] - _sa87Y::I64;
           (_sa88p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_sa87U::I64, _sa87U::I64 + _sa87Y::I64, _sa88j::I64);
           call MO_Touch(_sa87V::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa87V::P64;
           P64[Hp - 32] = _sa87W::P64;
           I64[Hp - 24] = _sa87U::I64;
           I64[Hp - 16] = _sa87X::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sa88j::I64;
           I64[Sp + 16] = block_cabNE_info;
           R2 = _sa884::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa886::P64;
           P64[Sp + 8] = Hp - 47;
           P64[Sp + 24] = _sa88e::P64;
           P64[Sp + 32] = _sa88a::P64;
           P64[Sp + 40] = _sa888::P64;
           P64[Sp + 48] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabNj_info" {
     block_cabNj_info:
         const _cabNj;
         const 3655;
         const 18446744069414584350;
         const uabQt_srtd;
 },
 section ""relreadonly" . uabQu_srtd" {
     uabQu_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabNE() //  [R1]
         { []
         }
     {offset
       cabNE: // global
           I64[Sp] = block_cabNG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabQb; else goto cabNH;
       uabQb: // global
           call _cabNG(R1) args: 0, res: 0, upd: 0;
       cabNH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabNE_info" {
     block_cabNE_info:
         const _cabNE;
         const 5;
         const 18446744069414584350;
         const uabQu_srtd;
 },
 section ""relreadonly" . uabQv_srtd" {
     uabQv_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabNG() //  [R1]
         { []
         }
     {offset
       cabNG: // global
           I64[Sp - 8] = block_cabNL_info;
           _sa88x::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sa88x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabQc; else goto cabNT;
       uabQc: // global
           call _cabNL(R1) args: 0, res: 0, upd: 0;
       cabNT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabNG_info" {
     block_cabNG_info:
         const _cabNG;
         const 5;
         const 18446744069414584350;
         const uabQv_srtd;
 },
 section ""relreadonly" . uabQw_srtd" {
     uabQw_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabNL() //  [R1]
         { []
         }
     {offset
       cabNL: // global
           if (I64[R1 + 7] == 0) goto cabP6; else goto cabO2;
       cabP6: // global
           _sa88x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabP5_info;
           R1 = _sa88x::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uabQe; else goto cabP7;
       uabQe: // global
           call _cabP5(R1) args: 0, res: 0, upd: 0;
       cabP7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabO2: // global
           I64[Sp] = block_cabO0_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto uabQd; else goto cabO3;
       uabQd: // global
           call _cabO0(R1) args: 0, res: 0, upd: 0;
       cabO3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabNL_info" {
     block_cabNL_info:
         const _cabNL;
         const 6;
         const 18446744069414584350;
         const uabQw_srtd;
 },
 section ""relreadonly" . uabQx_srtd" {
     uabQx_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabP5() //  [R1]
         { []
         }
     {offset
       cabP5: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cabQ2; else goto cabPh;
       cabQ2: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cabPh: // global
           _sa88e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabPf_info;
           _sa89i::P64 = R1;
           R1 = _sa88e::P64;
           P64[Sp + 16] = _sa89i::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uabQm; else goto cabPi;
       uabQm: // global
           call _cabPf(R1) args: 0, res: 0, upd: 0;
       cabPi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabP5_info" {
     block_cabP5_info:
         const _cabP5;
         const 133;
         const 18446744069414584350;
         const uabQx_srtd;
 },
 _cabPf() //  [R1]
         { []
         }
     {offset
       cabPf: // global
           if (R1 & 7 == 1) goto uabQ8; else goto cabPN;
       uabQ8: // global
           Sp = Sp + 40;
           call _cabPo() args: 0, res: 0, upd: 0;
       cabPN: // global
           I64[Sp] = block_cabPr_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabQn; else goto cabPs;
       uabQn: // global
           call _cabPr(R1) args: 0, res: 0, upd: 0;
       cabPs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabPf_info" {
     block_cabPf_info:
         const _cabPf;
         const 4;
         const 21474836510;
         const Sa8nI_srt+296;
 },
 _cabPr() //  [R1]
         { []
         }
     {offset
       cabPr: // global
           _sa89i::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cabPw_info;
           R3 = P64[Sp + 32];
           R2 = _sa89i::P64;
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabPr_info" {
     block_cabPr_info:
         const _cabPr;
         const 4;
         const 4294967326;
         const Sa8nI_srt+296;
 },
 _cabPw() //  [R1]
         { []
         }
     {offset
       cabPw: // global
           I64[Sp] = block_cabPy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabQp; else goto cabPz;
       uabQp: // global
           call _cabPy(R1) args: 0, res: 0, upd: 0;
       cabPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabPw_info" {
     block_cabPw_info:
         const _cabPw;
         const 3;
         const 4294967326;
         const Sa8nI_srt+296;
 },
 _cabPy() //  [R1]
         { []
         }
     {offset
       cabPy: // global
           _sa888::P64 = P64[Sp + 8];
           _sa89D::P64 = P64[R1 + 7];
           _sa89E::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa888::P64 + 8] = _sa89D::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa888::P64);
           I64[Sp + 8] = block_cabPG_info;
           R1 = _sa89E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uabQq; else goto cabPH;
       uabQq: // global
           call _cabPG(R1) args: 0, res: 0, upd: 0;
       cabPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabPy_info" {
     block_cabPy_info:
         const _cabPy;
         const 3;
         const 4294967326;
         const Sa8nI_srt+296;
 },
 _cabPG() //  [R1]
         { []
         }
     {offset
       cabPG: // global
           I64[Sp - 8] = block_cabPL_info;
           _sa89G::P64 = R1;
           _sa89M::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           I64[Sp] = _sa89M::I64;
           P64[Sp + 16] = _sa89G::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabQr; else goto cabPS;
       uabQr: // global
           call _cabPL(R1) args: 0, res: 0, upd: 0;
       cabPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabPG_info" {
     block_cabPG_info:
         const _cabPG;
         const 2;
         const 4294967326;
         const Sa8nI_srt+296;
 },
 _cabPL() //  [R1]
         { []
         }
     {offset
       cabPL: // global
           _sa89G::P64 = P64[Sp + 24];
           if (I64[Sp + 8] == I64[R1 + 47]) goto cabQ1; else goto cabQ0;
       cabQ1: // global
           R3 = _sa89G::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       cabQ0: // global
           R1 = _sa89G::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabPL_info" {
     block_cabPL_info:
         const _cabPL;
         const 67;
         const 4294967326;
         const Sa8nI_srt+296;
 },
 section ""relreadonly" . uabQy_srtd" {
     uabQy_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabO0() //  [R1]
         { []
         }
     {offset
       cabO0: // global
           if (R1 & 7 == 1) goto uabQ6; else goto cabOE;
       uabQ6: // global
           Sp = Sp + 56;
           call _cabPo() args: 0, res: 0, upd: 0;
       cabOE: // global
           I64[Sp] = block_cabOc_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabQf; else goto cabOd;
       uabQf: // global
           call _cabOc(R1) args: 0, res: 0, upd: 0;
       cabOd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabO0_info" {
     block_cabO0_info:
         const _cabO0;
         const 134;
         const 18446744069414584350;
         const uabQy_srtd;
 },
 _cabPo() //  []
         { []
         }
     {offset
       cabPo: // global
           R1 = lvl22_ra7PC_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uabQz_srtd" {
     uabQz_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOc() //  [R1]
         { []
         }
     {offset
       cabOc: // global
           I64[Sp - 8] = block_cabOh_info;
           _sa88F::P64 = P64[R1 + 7];
           _sa88G::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sa88G::P64;
           P64[Sp + 16] = _sa88F::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabOc_info" {
     block_cabOc_info:
         const _cabOc;
         const 134;
         const 18446744069414584350;
         const uabQz_srtd;
 },
 section ""relreadonly" . uabQA_srtd" {
     uabQA_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOh() //  [R1]
         { []
         }
     {offset
       cabOh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabOI; else goto cabOH;
       cabOI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabOH: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sa88x::P64 = P64[Sp + 16];
           P64[Hp] = _sa88x::P64;
           _sa880::P64 = P64[Sp + 56];
           _sa88a::P64 = P64[Sp + 32];
           _sa88F::P64 = P64[Sp + 24];
           _sa88G::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa88a::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa88a::P64);
           I64[Sp + 32] = block_cabOn_info;
           R5 = _sa880::P64;
           R4 = _sa88x::P64;
           R3 = _sa88G::P64;
           R2 = _sa88F::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabOh_info" {
     block_cabOh_info:
         const _cabOh;
         const 7;
         const 18446744069414584350;
         const uabQA_srtd;
 },
 section ""relreadonly" . uabQB_srtd" {
     uabQB_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOn() //  [R1]
         { []
         }
     {offset
       cabOn: // global
           I64[Sp] = block_cabOp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uabQh; else goto cabOq;
       uabQh: // global
           call _cabOp(R1) args: 0, res: 0, upd: 0;
       cabOq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabOn_info" {
     block_cabOn_info:
         const _cabOn;
         const 3;
         const 18446744069414584350;
         const uabQB_srtd;
 },
 section ""relreadonly" . uabQC_srtd" {
     uabQC_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOp() //  [R1]
         { []
         }
     {offset
       cabOp: // global
           _sa880::P64 = P64[Sp + 24];
           _sa888::P64 = P64[Sp + 8];
           _sa88T::P64 = P64[R1 + 7];
           _sa88U::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sa888::P64 + 8] = _sa88T::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa888::P64);
           I64[Sp] = block_cabOx_info;
           R1 = _sa880::P64;
           P64[Sp + 8] = _sa88U::P64;
           P64[Sp + 24] = _sa88T::P64;
           if (R1 & 7 != 0) goto uabQi; else goto cabOy;
       uabQi: // global
           call _cabOx(R1) args: 0, res: 0, upd: 0;
       cabOy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabOp_info" {
     block_cabOp_info:
         const _cabOp;
         const 3;
         const 18446744069414584350;
         const uabQC_srtd;
 },
 section ""relreadonly" . uabQD_srtd" {
     uabQD_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOx() //  [R1]
         { []
         }
     {offset
       cabOx: // global
           I64[Sp] = block_cabOC_info;
           _sa892::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sa892::I64;
           if (R1 & 7 != 0) goto uabQj; else goto cabOM;
       uabQj: // global
           call _cabOC(R1) args: 0, res: 0, upd: 0;
       cabOM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabOx_info" {
     block_cabOx_info:
         const _cabOx;
         const 3;
         const 18446744069414584350;
         const uabQD_srtd;
 },
 section ""relreadonly" . uabQE_srtd" {
     uabQE_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOC() //  [R1]
         { []
         }
     {offset
       cabOC: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto cabOY; else goto cabOU;
       cabOY: // global
           I64[Sp + 8] = block_cabOX_info;
           _sa893::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sa893::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uabQk; else goto cabOZ;
       uabQk: // global
           call _cabOX(R1) args: 0, res: 0, upd: 0;
       cabOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cabOU: // global
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabOC_info" {
     block_cabOC_info:
         const _cabOC;
         const 67;
         const 18446744069414584350;
         const uabQE_srtd;
 },
 section ""relreadonly" . uabQF_srtd" {
     uabQF_srtd:
         const Sa8nI_srt+56;
         const 33;
         const 5368709121;
 },
 _cabOX() //  [R1]
         { []
         }
     {offset
       cabOX: // global
           P64[Sp - 40] = P64[Sp + 8];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 8] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 40;
           call _cabNg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabOX_info" {
     block_cabOX_info:
         const _cabOX;
         const 2;
         const 18446744069414584350;
         const uabQF_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.085972375 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDevice_closure" {
     GHC.IO.Handle.Internals.readTextDevice_closure:
         const GHC.IO.Handle.Internals.readTextDevice_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDevice_entry() //  [R2, R3]
         { []
         }
     {offset
       cabUf: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.readTextDevice_info" {
     GHC.IO.Handle.Internals.readTextDevice_info:
         const GHC.IO.Handle.Internals.readTextDevice_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Sa8nI_srt+296;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.091303393 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_1_closure" {
     GHC.IO.Handle.Internals.hLookAhead_1_closure:
         const GHC.IO.Handle.Internals.hLookAhead_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_1_entry() //  [R2]
         { []
         }
     {offset
       cabUt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cabUx; else goto cabUy;
       cabUx: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabUy: // global
           I64[Sp - 8] = block_cabUq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabV4; else goto cabUr;
       uabV4: // global
           call _cabUq(R1) args: 0, res: 0, upd: 0;
       cabUr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hLookAhead_1_info" {
     GHC.IO.Handle.Internals.hLookAhead_1_info:
         const GHC.IO.Handle.Internals.hLookAhead_1_entry;
         const 0;
         const 38654705678;
         const 8589934597;
         const Sa8nI_srt+296;
 },
 _cabUq() //  [R1]
         { []
         }
     {offset
       cabUq: // global
           I64[Sp - 16] = block_cabUw_info;
           _sa89X::P64 = R1;
           _sa8a6::P64 = P64[R1 + 71];
           R1 = P64[_sa8a6::P64 + 8];
           P64[Sp - 8] = _sa8a6::P64;
           P64[Sp] = _sa89X::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uabV3; else goto cabUA;
       uabV3: // global
           call _cabUw(R1) args: 0, res: 0, upd: 0;
       cabUA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabUq_info" {
     block_cabUq_info:
         const _cabUq;
         const 0;
         const 4294967326;
         const Sa8nI_srt+296;
 },
 _cabUw() //  [R1]
         { []
         }
     {offset
       cabUw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabUG; else goto cabUF;
       cabUG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabUF: // global
           _sa8aj::P64 = P64[R1 + 7];
           _sa8ai::I64 = I64[R1 + 23];
           _sa8am::I64 = I64[R1 + 39];
           if (_sa8am::I64 == I64[R1 + 47]) goto cabUZ; else goto cabUQ;
       cabUZ: // global
           Hp = Hp - 16;
           I64[Sp - 16] = block_cabUS_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = _sa8am::I64;
           P64[Sp] = _sa8aj::P64;
           I64[Sp + 16] = _sa8ai::I64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cabUQ: // global
           _sa8a6::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8a6::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8a6::P64);
           _sa8as::I64 = %MO_UU_Conv_W32_W64(I32[_sa8ai::I64 + (_sa8am::I64 << 2)]);
           call MO_Touch(_sa8aj::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sa8as::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabUw_info" {
     block_cabUw_info:
         const _cabUw;
         const 2;
         const 4294967326;
         const Sa8nI_srt+296;
 },
 _cabUS() //  [R1]
         { []
         }
     {offset
       cabUS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabV2; else goto cabV1;
       cabV2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabV1: // global
           _sa8a6::P64 = P64[Sp + 24];
           _sa8ai::I64 = I64[Sp + 32];
           _sa8aj::P64 = P64[Sp + 16];
           _sa8am::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8a6::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8a6::P64);
           _sa8aB::I64 = %MO_UU_Conv_W32_W64(I32[_sa8ai::I64 + (_sa8am::I64 << 2)]);
           call MO_Touch(_sa8aj::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sa8aB::I64;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabUS_info" {
     block_cabUS_info:
         const _cabUS;
         const 580;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.100826033 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead__closure" {
     GHC.IO.Handle.Internals.hLookAhead__closure:
         const GHC.IO.Handle.Internals.hLookAhead__info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead__entry() //  [R2]
         { []
         }
     {offset
       cabVt: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hLookAhead__info" {
     GHC.IO.Handle.Internals.hLookAhead__info:
         const GHC.IO.Handle.Internals.hLookAhead__entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Sa8nI_srt+320;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.104384465 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help2_closure" {
     GHC.IO.Handle.Internals.hClose_help2_closure:
         const GHC.IO.Handle.Internals.hClose_help2_info;
 },
 GHC.IO.Handle.Internals.hClose_help2_entry() //  [R2]
         { []
         }
     {offset
       cabVF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cabVJ; else goto cabVI;
       cabVJ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabVI: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hClose_help2_info" {
     GHC.IO.Handle.Internals.hClose_help2_info:
         const GHC.IO.Handle.Internals.hClose_help2_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.118351973 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help1_closure" {
     GHC.IO.Handle.Internals.hClose_help1_closure:
         const GHC.IO.Handle.Internals.hClose_help1_info;
         const 0;
 },
 sat_sa8bs_entry() //  [R1]
         { []
         }
     {offset
       cabWb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cabWc; else goto cabWd;
       cabWc: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cabWd: // global
           I64[Sp - 32] = block_cabW8_info;
           _sa8aL::P64 = P64[R1 + 7];
           _sa8aN::P64 = P64[R1 + 15];
           _sa8aP::P64 = P64[R1 + 23];
           R1 = P64[_sa8aP::P64 + 8];
           P64[Sp - 24] = _sa8aL::P64;
           P64[Sp - 16] = _sa8aN::P64;
           P64[Sp - 8] = _sa8aP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabWP; else goto cabW9;
       uabWP: // global
           call _cabW8(R1) args: 0, res: 0, upd: 0;
       cabW9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8bs_info" {
     sat_sa8bs_info:
         const sat_sa8bs_entry;
         const 3;
         const 8;
         const 4294967299;
 },
 _cabW8() //  [R1]
         { []
         }
     {offset
       cabW8: // global
           I64[Sp] = block_cabWg_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uabWO; else goto cabWi;
       uabWO: // global
           call _cabWg(R1) args: 0, res: 0, upd: 0;
       cabWi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabW8_info" {
     block_cabW8_info:
         const _cabW8;
         const 3;
         const 30;
 },
 _cabWg() //  [R1]
         { []
         }
     {offset
       cabWg: // global
           if (R1 & 7 == 1) goto uabWM; else goto cabWt;
       uabWM: // global
           Sp = Sp + 32;
           call _cabWH() args: 0, res: 0, upd: 0;
       cabWt: // global
           _sa8bf::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cabWr_info;
           R1 = _sa8bf::P64;
           if (R1 & 7 != 0) goto uabWQ; else goto cabWu;
       uabWQ: // global
           call _cabWr(R1) args: 0, res: 0, upd: 0;
       cabWu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabWg_info" {
     block_cabWg_info:
         const _cabWg;
         const 3;
         const 30;
 },
 _cabWr() //  [R1]
         { []
         }
     {offset
       cabWr: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uabWN; else goto cabWE;
       uabWN: // global
           Sp = Sp + 32;
           call _cabWH() args: 0, res: 0, upd: 0;
       cabWE: // global
           _sa8aN::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cabWC_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa8aN::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabWr_info" {
     block_cabWr_info:
         const _cabWr;
         const 3;
         const 30;
 },
 _cabWH() //  []
         { []
         }
     {offset
       cabWH: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cabWC() //  [R1]
         { []
         }
     {offset
       cabWC: // global
           _sa8aP::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8aP::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aP::P64);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabWC_info" {
     block_cabWC_info:
         const _cabWC;
         const 1;
         const 30;
 },
 sat_sa8bI_entry() //  [R1]
         { []
         }
     {offset
       cabXu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabXv; else goto cabXw;
       cabXv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabXw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cabXn_info;
           _sa8by::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8by::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabXD; else goto cabXo;
       uabXD: // global
           call _cabXn(R1) args: 0, res: 0, upd: 0;
       cabXo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa8bI_info" {
     sat_sa8bI_info:
         const sat_sa8bI_entry;
         const 2;
         const 18;
 },
 _cabXn() //  [R1]
         { []
         }
     {offset
       cabXn: // global
           if (R1 & 7 == 1) goto cabXr; else goto cabXs;
       cabXr: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cabXs: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabXn_info" {
     block_cabXn_info:
         const _cabXn;
         const 1;
         const 30;
 },
 sat_sa8bX_entry() //  [R1]
         { []
         }
     {offset
       cabXY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabXZ; else goto cabY0;
       cabXZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabY0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cabXR_info;
           _sa8by::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8by::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabY7; else goto cabXS;
       uabY7: // global
           call _cabXR(R1) args: 0, res: 0, upd: 0;
       cabXS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa8bX_info" {
     sat_sa8bX_info:
         const sat_sa8bX_entry;
         const 2;
         const 18;
 },
 _cabXR() //  [R1]
         { []
         }
     {offset
       cabXR: // global
           if (R1 & 7 == 1) goto cabXV; else goto cabXW;
       cabXV: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cabXW: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cabXR_info" {
     block_cabXR_info:
         const _cabXR;
         const 1;
         const 30;
 },
 sat_sa8cf_entry() //  [R1]
         { []
         }
     {offset
       cabYk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cabYl; else goto cabYm;
       cabYl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cabYm: // global
           I64[Sp - 8] = block_cabYi_info;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.IO.Device.close_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8cf_info" {
     sat_sa8cf_info:
         const sat_sa8cf_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cabYi() //  []
         { []
         }
     {offset
       cabYi: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabYi_info" {
     block_cabYi_info:
         const _cabYi;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.hClose_help1_entry() //  [R2]
         { []
         }
     {offset
       cabYo: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cabYp; else goto cabYq;
       cabYp: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabYq: // global
           I64[Sp - 8] = block_cabVT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabZF; else goto cabVU;
       uabZF: // global
           call _cabVT(R1) args: 0, res: 0, upd: 0;
       cabVU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hClose_help1_info" {
     GHC.IO.Handle.Internals.hClose_help1_info:
         const GHC.IO.Handle.Internals.hClose_help1_entry;
         const 0;
         const 30064771086;
         const 8589934597;
         const Sa8nI_srt+328;
 },
 _cabVT() //  [R1]
         { []
         }
     {offset
       cabVT: // global
           I64[Sp - 128] = block_cabVY_info;
           _sa8aJ::P64 = R1;
           _sa8aK::P64 = P64[R1 + 7];
           _sa8aL::P64 = P64[R1 + 15];
           _sa8aM::P64 = P64[R1 + 23];
           _sa8aN::P64 = P64[R1 + 31];
           _sa8aP::P64 = P64[R1 + 47];
           _sa8aQ::P64 = P64[R1 + 55];
           _sa8aR::P64 = P64[R1 + 63];
           _sa8aS::P64 = P64[R1 + 71];
           _sa8aT::P64 = P64[R1 + 79];
           _sa8aU::P64 = P64[R1 + 87];
           _sa8aV::P64 = P64[R1 + 95];
           _sa8aW::P64 = P64[R1 + 103];
           _sa8aX::P64 = P64[R1 + 111];
           _sa8aY::P64 = P64[R1 + 119];
           _sa8aZ::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sa8aK::P64;
           P64[Sp - 112] = _sa8aL::P64;
           P64[Sp - 104] = _sa8aM::P64;
           P64[Sp - 96] = _sa8aN::P64;
           P64[Sp - 88] = _sa8aP::P64;
           P64[Sp - 80] = _sa8aQ::P64;
           P64[Sp - 72] = _sa8aR::P64;
           P64[Sp - 64] = _sa8aS::P64;
           P64[Sp - 56] = _sa8aT::P64;
           P64[Sp - 48] = _sa8aU::P64;
           P64[Sp - 40] = _sa8aV::P64;
           P64[Sp - 32] = _sa8aW::P64;
           P64[Sp - 24] = _sa8aX::P64;
           P64[Sp - 16] = _sa8aY::P64;
           P64[Sp - 8] = _sa8aZ::P64;
           P64[Sp] = _sa8aJ::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto uabZB; else goto cabVZ;
       uabZB: // global
           call _cabVY(R1) args: 0, res: 0, upd: 0;
       cabVZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabVT_info" {
     block_cabVT_info:
         const _cabVT;
         const 0;
         const 12884901918;
         const Sa8nI_srt+328;
 },
 _cabVY() //  [R1]
         { []
         }
     {offset
       cabVY: // global
           if (R1 & 7 == 1) goto cabZp; else goto cabYt;
       cabZp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabZs; else goto cabZr;
       cabZs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabZr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabYt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cabYw; else goto cabYv;
       cabYw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabYv: // global
           I64[Hp - 24] = sat_sa8bs_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_cabWT_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabVY_info" {
     block_cabVY_info:
         const _cabVY;
         const 16;
         const 12884901918;
         const Sa8nI_srt+328;
 },
 _cabWT() //  [R1]
         { []
         }
     {offset
       cabWT: // global
           I64[Sp] = block_cabY8_info;
           _sa8bv::P64 = R1;
           R1 = P64[Sp + 120];
           P64[Sp + 128] = _sa8bv::P64;
           if (R1 & 7 != 0) goto uabZC; else goto cabY9;
       uabZC: // global
           call _cabY8(R1) args: 0, res: 0, upd: 0;
       cabY9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabWT_info" {
     block_cabWT_info:
         const _cabWT;
         const 2097168;
         const 12884901918;
         const Sa8nI_srt+328;
 },
 _cabY8() //  [R1]
         { []
         }
     {offset
       cabY8: // global
           if (R1 & 7 == 1) goto cabZc; else goto cabZl;
       cabZc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cabZf; else goto cabZe;
       cabZf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabZe: // global
           I64[Hp - 16] = sat_sa8cf_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_cabZa_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cabZl: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _sa8bw() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabY8_info" {
     block_cabY8_info:
         const _cabY8;
         const 16;
         const 12884901918;
         const Sa8nI_srt+328;
 },
 _cabZa() //  [R1]
         { []
         }
     {offset
       cabZa: // global
           P64[Sp] = R1;
           call _sa8bw() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabZa_info" {
     block_cabZa_info:
         const _cabZa;
         const 16;
         const 12884901918;
         const Sa8nI_srt+328;
 },
 _sa8bw() //  []
         { []
         }
     {offset
       sa8bw: // global
           _sa8aP::P64 = P64[Sp + 40];
           _sa8aS::P64 = P64[Sp + 64];
           _sa8aT::P64 = P64[Sp + 72];
           _sa8aV::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sa8aT::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aT::P64);
           call MO_WriteBarrier();
           P64[_sa8aS::P64 + 8] = GHC.IO.Handle.Internals.noCharBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aS::P64);
           call MO_WriteBarrier();
           P64[_sa8aP::P64 + 8] = GHC.IO.Handle.Internals.noByteBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8aP::P64);
           I64[Sp - 8] = block_cabYy_info;
           R1 = _sa8aV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabZK; else goto cabYQ;
       uabZK: // global
           call _cabYy(R1) args: 0, res: 0, upd: 0;
       cabYQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabYy() //  [R1]
         { []
         }
     {offset
       cabYy: // global
           if (R1 & 7 == 1) goto uabZz; else goto cabZ6;
       uabZz: // global
           Sp = Sp + 8;
           call _sa8bC() args: 0, res: 0, upd: 0;
       cabZ6: // global
           I64[Sp] = block_cabYZ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uabZG; else goto cabZ0;
       uabZG: // global
           call _cabYZ(R1) args: 0, res: 0, upd: 0;
       cabZ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabYy_info" {
     block_cabYy_info:
         const _cabYy;
         const 17;
         const 30;
 },
 _cabYZ() //  [R1]
         { []
         }
     {offset
       cabYZ: // global
           I64[Sp] = block_cabZ4_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabYZ_info" {
     block_cabYZ_info:
         const _cabYZ;
         const 17;
         const 30;
 },
 _cabZ4() //  []
         { []
         }
     {offset
       cabZ4: // global
           Sp = Sp + 8;
           call _sa8bC() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cabZ4_info" {
     block_cabZ4_info:
         const _cabZ4;
         const 17;
         const 30;
 },
 _sa8bC() //  []
         { []
         }
     {offset
       sa8bC: // global
           I64[Sp - 8] = block_cabXe_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uabZL; else goto cabXf;
       uabZL: // global
           call _cabXe(R1) args: 0, res: 0, upd: 0;
       cabXf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cabXe() //  [R1]
         { []
         }
     {offset
       cabXe: // global
           if (R1 & 7 == 1) goto cabYE; else goto cabYL;
       cabYE: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto cabYH; else goto cabYG;
       cabYH: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabYG: // global
           I64[Hp - 184] = sat_sa8bI_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = GHC.Base.Nothing_closure+1;
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cabYL: // global
           I64[Sp] = block_cabXG_info;
           _sa8bE::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 88] = _sa8bE::P64;
           if (R1 & 7 != 0) goto uabZD; else goto cabXH;
       uabZD: // global
           call _cabXG(R1) args: 0, res: 0, upd: 0;
       cabXH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabXe_info" {
     block_cabXe_info:
         const _cabXe;
         const 65553;
         const 30;
 },
 _cabXG() //  [R1]
         { []
         }
     {offset
       cabXG: // global
           I64[Sp] = block_cabXL_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cabXG_info" {
     block_cabXG_info:
         const _cabXG;
         const 17;
         const 30;
 },
 _cabXL() //  [R1]
         { []
         }
     {offset
       cabXL: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto cabYP; else goto cabYO;
       cabYP: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabYO: // global
           I64[Hp - 184] = sat_sa8bX_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cabXL_info" {
     block_cabXL_info:
         const _cabXL;
         const 17;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.163205496 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help_closure" {
     GHC.IO.Handle.Internals.hClose_help_closure:
         const GHC.IO.Handle.Internals.hClose_help_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hClose_help_entry() //  [R2]
         { []
         }
     {offset
       cac2B: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hClose_help_info" {
     GHC.IO.Handle.Internals.hClose_help_info:
         const GHC.IO.Handle.Internals.hClose_help_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Sa8nI_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.167657378 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer1_closure" {
     GHC.IO.Handle.Internals.handleFinalizer1_closure:
         const GHC.IO.Handle.Internals.handleFinalizer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer1_entry() //  [R2, R3]
         { []
         }
     {offset
       cac2P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cac32; else goto cac33;
       cac32: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.handleFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cac33: // global
           I64[Sp - 8] = block_cac2M_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uac3a; else goto cac2N;
       uac3a: // global
           call _cac2M(R1) args: 0, res: 0, upd: 0;
       cac2N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.handleFinalizer1_info" {
     GHC.IO.Handle.Internals.handleFinalizer1_info:
         const GHC.IO.Handle.Internals.handleFinalizer1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const Sa8nI_srt+344;
 },
 _cac2M() //  [R1]
         { []
         }
     {offset
       cac2M: // global
           I64[Sp - 8] = block_cac2S_info;
           _sa8cp::P64 = P64[R1 + 7];
           R1 = _sa8cp::P64;
           P64[Sp] = _sa8cp::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac2M_info" {
     block_cac2M_info:
         const _cac2M;
         const 0;
         const 4294967326;
         const Sa8nI_srt+344;
 },
 _cac2S() //  [R1]
         { []
         }
     {offset
       cac2S: // global
           I64[Sp] = block_cac2U_info;
           R2 = R1;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac2S_info" {
     block_cac2S_info:
         const _cac2S;
         const 1;
         const 4294967326;
         const Sa8nI_srt+344;
 },
 _cac2U() //  [R1]
         { []
         }
     {offset
       cac2U: // global
           I64[Sp] = block_cac2W_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uac3b; else goto cac2X;
       uac3b: // global
           call _cac2W(R1) args: 0, res: 0, upd: 0;
       cac2X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac2U_info" {
     block_cac2U_info:
         const _cac2U;
         const 1;
         const 30;
 },
 _cac2W() //  [R1]
         { []
         }
     {offset
       cac2W: // global
           _sa8cp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cac31_info;
           R2 = P64[R1 + 7];
           R1 = _sa8cp::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac2W_info" {
     block_cac2W_info:
         const _cac2W;
         const 1;
         const 30;
 },
 _cac31() //  []
         { []
         }
     {offset
       cac31: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cac31_info" {
     block_cac31_info:
         const _cac31;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.178765013 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer_closure" {
     GHC.IO.Handle.Internals.handleFinalizer_closure:
         const GHC.IO.Handle.Internals.handleFinalizer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer_entry() //  [R2, R3]
         { []
         }
     {offset
       cac3D: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.handleFinalizer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.handleFinalizer_info" {
     GHC.IO.Handle.Internals.handleFinalizer_info:
         const GHC.IO.Handle.Internals.handleFinalizer_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Sa8nI_srt+352;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.181902614 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle4_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.186380505 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle1_closure" {
     GHC.IO.Handle.Internals.mkFileHandle1_closure:
         const GHC.IO.Handle.Internals.mkFileHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle1_slow() //  [R1]
         { []
         }
     {offset
       cac3M: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sa8cK_entry() //  [R1]
         { []
         }
     {offset
       cac43: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cac44; else goto cac45;
       cac44: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cac45: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cac3U_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uac4k; else goto cac3V;
       uac4k: // global
           call _cac3U(R1) args: 0, res: 0, upd: 0;
       cac3V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa8cK_info" {
     sat_sa8cK_info:
         const sat_sa8cK_entry;
         const 1;
         const 16;
 },
 _cac3U() //  [R1]
         { []
         }
     {offset
       cac3U: // global
           _cac42::P64 = R1 & 7;
           if (_cac42::P64 < 3) goto uac4i; else goto uac4j;
       uac4i: // global
           if (_cac42::P64 < 2) goto cac3Y; else goto cac3Z;
       cac3Y: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cac3Z: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uac4j: // global
           if (_cac42::P64 < 4) goto cac40; else goto cac41;
       cac40: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cac41: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cac3U_info" {
     block_cac3U_info:
         const _cac3U;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.mkFileHandle1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { []
         }
     {offset
       cac4l: // global
           _sa8cE::P64 = R6;
           _sa8cD::P64 = R5;
           _sa8cC::P64 = R4;
           _sa8cB::P64 = R3;
           _sa8cA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cac4m; else goto cac4n;
       cac4n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cac4p; else goto cac4o;
       cac4p: // global
           HpAlloc = 24;
           goto cac4m;
       cac4m: // global
           R1 = GHC.IO.Handle.Internals.mkFileHandle1_closure;
           P64[Sp - 40] = _sa8cA::P64;
           P64[Sp - 32] = _sa8cB::P64;
           P64[Sp - 24] = _sa8cC::P64;
           P64[Sp - 16] = _sa8cD::P64;
           P64[Sp - 8] = _sa8cE::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cac4o: // global
           I64[Hp - 16] = sat_sa8cK_info;
           P64[Hp] = P64[Sp];
           R6 = _sa8cE::P64;
           R5 = _sa8cD::P64;
           R4 = _sa8cC::P64;
           R3 = _sa8cB::P64;
           R2 = _sa8cA::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = GHC.Types.True_closure+2;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 8] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkFileHandle1_info" {
     GHC.IO.Handle.Internals.mkFileHandle1_info:
         const GHC.IO.Handle.Internals.mkFileHandle1_entry;
         const 0;
         const 1688854155231246;
         const 38654705664;
         const Sa8nI_srt+224;
         const 8;
         const GHC.IO.Handle.Internals.mkFileHandle1_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.1952701 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle_closure" {
     GHC.IO.Handle.Internals.mkFileHandle_closure:
         const GHC.IO.Handle.Internals.mkFileHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle_slow() //  [R1]
         { []
         }
     {offset
       cac4P: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       cac4T: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkFileHandle_info" {
     GHC.IO.Handle.Internals.mkFileHandle_info:
         const GHC.IO.Handle.Internals.mkFileHandle_entry;
         const 0;
         const 4294967310;
         const 38654705664;
         const Sa8nI_srt+368;
         const 8;
         const GHC.IO.Handle.Internals.mkFileHandle_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.200197492 UTC

[section ""cstring" . lvl23_ra7PD_bytes" {
     lvl23_ra7PD_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,54,58,51,45,51,51]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.20236959 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle3_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle3_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle3_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle3_entry() //  []
         { []
         }
     {offset
       cac59: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cac5a; else goto cac5b;
       cac5a: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cac5b: // global
           I64[Sp - 8] = block_cac57_info;
           R2 = lvl23_ra7PD_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle3_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle3_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle3_entry;
         const 0;
         const 12884901902;
         const 4294967299;
         const Sa8nI_srt+376;
 },
 _cac57() //  [R1]
         { []
         }
     {offset
       cac57: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cac57_info" {
     block_cac57_info:
         const _cac57;
         const 0;
         const 4294967326;
         const Sa8nI_srt+376;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.206943284 UTC

[section ""cstring" . lvl24_ra7PE_bytes" {
     lvl24_ra7PE_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,48,58,51,45,51,53]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.209124298 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle2_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle2_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle2_entry() //  []
         { []
         }
     {offset
       cac5u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cac5v; else goto cac5w;
       cac5v: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cac5w: // global
           I64[Sp - 8] = block_cac5s_info;
           R2 = lvl24_ra7PE_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle2_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle2_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle2_entry;
         const 0;
         const 21474836494;
         const 4294967299;
         const Sa8nI_srt+376;
 },
 _cac5s() //  [R1]
         { []
         }
     {offset
       cac5s: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cac5s_info" {
     block_cac5s_info:
         const _cac5s;
         const 0;
         const 4294967326;
         const Sa8nI_srt+376;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.216751139 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle1_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle1_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_slow() //  [R1]
         { []
         }
     {offset
       cac5J: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { []
         }
     {offset
       cac5W: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cac5X; else goto cac5Y;
       cac5X: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cac5Y: // global
           I64[Sp - 48] = block_cac5N_info;
           _sa8cT::P64 = R6;
           R6 = R6;
           _sa8cS::P64 = R5;
           R5 = R5;
           _sa8cR::P64 = R4;
           R4 = R4;
           _sa8cQ::P64 = R3;
           R3 = R3;
           _sa8cP::P64 = R2;
           R2 = R2;
           P64[Sp - 96] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 88] = GHC.Types.True_closure+2;
           P64[Sp - 80] = P64[Sp];
           P64[Sp - 72] = P64[Sp + 8];
           P64[Sp - 64] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp - 56] = GHC.Base.Nothing_closure+1;
           P64[Sp - 40] = _sa8cP::P64;
           P64[Sp - 32] = _sa8cQ::P64;
           P64[Sp - 24] = _sa8cR::P64;
           P64[Sp - 16] = _sa8cS::P64;
           P64[Sp - 8] = _sa8cT::P64;
           Sp = Sp - 96;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle1_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle1_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle1_entry;
         const 0;
         const 32088151639982094;
         const 34359738368;
         const Sa8nI_srt+224;
         const 7;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_slow;
 },
 _cac5N() //  [R1]
         { []
         }
     {offset
       cac5N: // global
           I64[Sp] = block_cac5P_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uac6t; else goto cac5Q;
       uac6t: // global
           call _cac5P(R1) args: 0, res: 0, upd: 0;
       cac5Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac5N_info" {
     block_cac5N_info:
         const _cac5N;
         const 7;
         const 13510803177078814;
         const Sa8nI_srt+224;
 },
 _cac5P() //  [R1]
         { []
         }
     {offset
       cac5P: // global
           if (R1 & 7 == 1) goto cac5T; else goto cac5U;
       cac5T: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cac69; else goto cac68;
       cac69: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cac68: // global
           _sa8d2::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = _sa8d2::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           _sa8cS::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cac64_info;
           R6 = P64[Sp + 40];
           R5 = _sa8cS::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp - 16] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 8] = P64[Sp + 56];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = Hp - 6;
           P64[Sp + 56] = _sa8d2::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
       cac5U: // global
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.mkDuplexHandle2_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cac5P_info" {
     block_cac5P_info:
         const _cac5P;
         const 7;
         const 13510803177078814;
         const Sa8nI_srt+224;
 },
 _cac64() //  [R1]
         { []
         }
     {offset
       cac64: // global
           I64[Sp] = block_cac66_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uac6u; else goto cac6b;
       uac6u: // global
           call _cac66(R1) args: 0, res: 0, upd: 0;
       cac6b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac64_info" {
     block_cac64_info:
         const _cac64;
         const 131;
         const 4294967326;
         const Sa8nI_srt+384;
 },
 _cac66() //  [R1]
         { []
         }
     {offset
       cac66: // global
           if (R1 & 7 == 1) goto cac6h; else goto cac6o;
       cac6h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cac6k; else goto cac6j;
       cac6k: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cac6j: // global
           _sa8da::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sa8da::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cac6o: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle3_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cac66_info" {
     block_cac66_info:
         const _cac66;
         const 131;
         const 4294967326;
         const Sa8nI_srt+384;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.22935147 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_slow() //  [R1]
         { []
         }
     {offset
       cac74: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { []
         }
     {offset
       cac78: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle_entry;
         const 0;
         const 4294967310;
         const 34359738368;
         const Sa8nI_srt+400;
         const 7;
         const GHC.IO.Handle.Internals.mkDuplexHandle_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.236703379 UTC

[section ""data" . $wlvl_ra7PF_closure" {
     $wlvl_ra7PF_closure:
         const $wlvl_ra7PF_info;
         const 0;
 },
 sat_sa8dy_entry() //  [R1]
         { []
         }
     {offset
       cac7A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cac7B; else goto cac7C;
       cac7B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cac7C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cac7t_info;
           _sa8dn::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sa8dn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uac83; else goto cac7u;
       uac83: // global
           call _cac7t(R1) args: 0, res: 0, upd: 0;
       cac7u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa8dy_info" {
     sat_sa8dy_info:
         const sat_sa8dy_entry;
         const 2;
         const 18;
 },
 _cac7t() //  [R1]
         { []
         }
     {offset
       cac7t: // global
           if (R1 & 7 == 1) goto cac7x; else goto cac7y;
       cac7x: // global
           _sa8dn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cac7F_info;
           R1 = _sa8dn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uac82; else goto cac7H;
       uac82: // global
           call _cac7F(R1) args: 0, res: 0, upd: 0;
       cac7H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cac7y: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cac7t_info" {
     block_cac7t_info:
         const _cac7t;
         const 1;
         const 30;
 },
 _cac7F() //  [R1]
         { []
         }
     {offset
       cac7F: // global
           if (R1 & 7 == 1) goto cac7N; else goto cac7U;
       cac7N: // global
           Hp = Hp + 16;
           _sa8dr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cac7X; else goto cac7P;
       cac7P: // global
           _sa8ds::P64 = P64[_sa8dr::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa8ds::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cac7U: // global
           Hp = Hp + 16;
           _sa8dr::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cac7X; else goto cac7W;
       cac7X: // global
           HpAlloc = 16;
           R1 = _sa8dr::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cac7W: // global
           _sa8du::P64 = P64[_sa8dr::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sa8du::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cac7F_info" {
     block_cac7F_info:
         const _cac7F;
         const 0;
         const 30;
 },
 sat_sa8dA_entry() //  [R1]
         { []
         }
     {offset
       cac86: // global
           _sa8dA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cac87; else goto cac88;
       cac88: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cac8a; else goto cac89;
       cac8a: // global
           HpAlloc = 104;
           goto cac87;
       cac87: // global
           R1 = _sa8dA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cac89: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa8dA::P64;
           _sa8di::P64 = P64[_sa8dA::P64 + 16];
           _sa8dj::P64 = P64[_sa8dA::P64 + 24];
           _sa8dk::P64 = P64[_sa8dA::P64 + 32];
           _sa8dl::P64 = P64[_sa8dA::P64 + 40];
           _sa8dm::P64 = P64[_sa8dA::P64 + 48];
           _sa8dn::P64 = P64[_sa8dA::P64 + 56];
           I64[Hp - 96] = sat_sa8dy_info;
           P64[Hp - 80] = _sa8dl::P64;
           P64[Hp - 72] = _sa8dn::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa8dn::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sa8di::P64;
           P64[Hp - 24] = _sa8dm::P64;
           P64[Hp - 16] = _sa8dj::P64;
           P64[Hp - 8] = _sa8dk::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa8dA_info" {
     sat_sa8dA_info:
         const sat_sa8dA_entry;
         const 6;
         const 4294967311;
         const Sa8nI_srt+408;
 },
 $wlvl_ra7PF_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cac8b: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cac8f; else goto cac8e;
       cac8f: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_ra7PF_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cac8e: // global
           I64[Hp - 56] = sat_sa8dA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 56;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wlvl_ra7PF_info" {
     $wlvl_ra7PF_info:
         const $wlvl_ra7PF_entry;
         const 0;
         const 12884901902;
         const 30064771098;
         const Sa8nI_srt+408;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.251819901 UTC

[section ""data" . GHC.IO.Handle.Internals.$wdo_operation_closure" {
     GHC.IO.Handle.Internals.$wdo_operation_closure:
         const GHC.IO.Handle.Internals.$wdo_operation_info;
         const 0;
 },
 sat_sa8e5_entry() //  [R1, R2]
         { []
         }
     {offset
       cac93: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cac97; else goto cac98;
       cac97: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cac98: // global
           I64[Sp - 48] = block_cac8Y_info;
           _sa8dK::P64 = R2;
           R2 = P64[R1 + 38];
           _sa8dB::P64 = P64[R1 + 6];
           _sa8dC::P64 = P64[R1 + 14];
           _sa8dD::P64 = P64[R1 + 22];
           _sa8dE::P64 = P64[R1 + 30];
           R1 = _sa8dE::P64;
           P64[Sp - 40] = _sa8dB::P64;
           P64[Sp - 32] = _sa8dC::P64;
           P64[Sp - 24] = _sa8dD::P64;
           P64[Sp - 16] = _sa8dE::P64;
           P64[Sp - 8] = _sa8dK::P64;
           Sp = Sp - 48;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8e5_info" {
     sat_sa8e5_info:
         const sat_sa8e5_entry;
         const 5;
         const 133143986184;
         const 8589934597;
         const Sa8nI_srt+416;
 },
 _cac8Y() //  []
         { []
         }
     {offset
       cac8Y: // global
           I64[Sp] = block_cac90_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto uac9Q; else goto cac91;
       uac9Q: // global
           call _cac90(R1) args: 0, res: 0, upd: 0;
       cac91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac8Y_info" {
     block_cac8Y_info:
         const _cac8Y;
         const 5;
         const 133143986206;
         const Sa8nI_srt+416;
 },
 _cac90() //  [R1]
         { []
         }
     {offset
       cac90: // global
           I64[Sp - 16] = block_cac96_info;
           _sa8dO::P64 = P64[R1 + 7];
           R2 = _sa8dO::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sa8dO::P64;
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac90_info" {
     block_cac90_info:
         const _cac90;
         const 1029;
         const 133143986206;
         const Sa8nI_srt+416;
 },
 _cac96() //  [R1]
         { []
         }
     {offset
       cac96: // global
           I64[Sp] = block_cac9e_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac96_info" {
     block_cac96_info:
         const _cac96;
         const 7;
         const 133143986206;
         const Sa8nI_srt+416;
 },
 _cac9e() //  [R1]
         { []
         }
     {offset
       cac9e: // global
           if (R1 & 7 == 1) goto cac9m; else goto cac9J;
       cac9m: // global
           _sa8dO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cac9j_info;
           R2 = _sa8dO::P64;
           Sp = Sp + 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       cac9J: // global
           I64[Sp + 16] = block_cac9H_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac9e_info" {
     block_cac9e_info:
         const _cac9e;
         const 7;
         const 98784247838;
         const Sa8nI_srt+416;
 },
 _cac9j() //  [R1]
         { []
         }
     {offset
       cac9j: // global
           I64[Sp] = block_cac9q_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac9j_info" {
     block_cac9j_info:
         const _cac9j;
         const 5;
         const 47244640286;
         const Sa8nI_srt+424;
 },
 _cac9q() //  [R1]
         { []
         }
     {offset
       cac9q: // global
           _sa8dN::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cac9x; else goto cac9C;
       cac9x: // global
           R1 = _sa8dN::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cac9C: // global
           I64[Sp] = block_cac9A_info;
           R2 = _sa8dN::P64;
           R1 = CurrentTSO;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac9q_info" {
     block_cac9q_info:
         const _cac9q;
         const 5;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cac9A() //  []
         { []
         }
     {offset
       cac9A: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cac9A_info" {
     block_cac9A_info:
         const _cac9A;
         const 1029;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cac9H() //  [R1]
         { []
         }
     {offset
       cac9H: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 47];
           R4 = P64[R1 + 39];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 15];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 40;
           call $wlvl_ra7PF_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cac9H_info" {
     block_cac9H_info:
         const _cac9H;
         const 1797;
         const 4294967326;
         const Sa8nI_srt+416;
 },
 GHC.IO.Handle.Internals.$wdo_operation_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cac9R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cac9S; else goto cac9T;
       cac9S: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wdo_operation_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cac9T: // global
           I64[Sp - 40] = block_cac8P_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wdo_operation_info" {
     GHC.IO.Handle.Internals.$wdo_operation_info:
         const GHC.IO.Handle.Internals.$wdo_operation_entry;
         const 0;
         const 133143986190;
         const 21474836504;
         const Sa8nI_srt+416;
 },
 _cac8P() //  [R1]
         { []
         }
     {offset
       cac8P: // global
           I64[Sp - 8] = block_cac8R_info;
           R2 = R1;
           _sa8dI::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _sa8dI::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cac8P_info" {
     block_cac8P_info:
         const _cac8P;
         const 4;
         const 133143986206;
         const Sa8nI_srt+416;
 },
 _cac8R() //  [R1]
         { []
         }
     {offset
       cac8R: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cac9X; else goto cac9W;
       cac9X: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cac9W: // global
           I64[Hp - 40] = sat_sa8e5_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 38;
           R1 = R1;
           Sp = Sp + 48;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cac8R_info" {
     block_cac8R_info:
         const _cac8R;
         const 5;
         const 133143986206;
         const Sa8nI_srt+416;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.273107208 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_1_closure" {
     GHC.IO.Handle.Internals.withHandle_1_closure:
         const GHC.IO.Handle.Internals.withHandle_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cacaU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cacaV; else goto cacaW;
       cacaV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacaW: // global
           I64[Sp - 32] = block_cacaR_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uacb0; else goto cacaS;
       uacb0: // global
           call _cacaR(R1) args: 0, res: 0, upd: 0;
       cacaS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle_1_info" {
     GHC.IO.Handle.Internals.withHandle_1_info:
         const GHC.IO.Handle.Internals.withHandle_1_entry;
         const 0;
         const 12884901902;
         const 21474836504;
         const Sa8nI_srt+448;
 },
 _cacaR() //  [R1]
         { []
         }
     {offset
       cacaR: // global
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacaR_info" {
     block_cacaR_info:
         const _cacaR;
         const 3;
         const 4294967326;
         const Sa8nI_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.281052492 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle__'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle__'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle__'_info;
         const 0;
 },
 sat_sa8ev_entry() //  [R1]
         { []
         }
     {offset
       cacbs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacbt; else goto cacbu;
       cacbt: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacbu: // global
           I64[Sp - 16] = block_cacbo_info;
           _sa8ef::P64 = P64[R1 + 23];
           R5 = _sa8ef::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8ef::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8ev_info" {
     sat_sa8ev_info:
         const sat_sa8ev_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacbo() //  [R1]
         { []
         }
     {offset
       cacbo: // global
           _sa8ef::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cacbq_info;
           R2 = R1;
           R1 = _sa8ef::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacbo_info" {
     block_cacbo_info:
         const _cacbo;
         const 1;
         const 30;
 },
 _cacbq() //  []
         { []
         }
     {offset
       cacbq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacbq_info" {
     block_cacbq_info:
         const _cacbq;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.$wwithHandle__'_entry() //  [R2, R3, R4,
                                                      R5]
         { []
         }
     {offset
       cacbA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacbB; else goto cacbC;
       cacbB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle__'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacbC: // global
           I64[Sp - 40] = block_cacbe_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wwithHandle__'_info" {
     GHC.IO.Handle.Internals.$wwithHandle__'_info:
         const GHC.IO.Handle.Internals.$wwithHandle__'_entry;
         const 0;
         const 21474836494;
         const 21474836504;
         const Sa8nI_srt+448;
 },
 _cacbe() //  [R1]
         { []
         }
     {offset
       cacbe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacbF; else goto cacbE;
       cacbF: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacbE: // global
           _sa8ed::P64 = P64[Sp + 8];
           _sa8ee::P64 = P64[Sp + 16];
           _sa8ef::P64 = P64[Sp + 24];
           _sa8eg::P64 = P64[Sp + 32];
           if (R1 == 0) goto cacbz; else goto cacby;
       cacbz: // global
           I64[Hp - 32] = sat_sa8ev_info;
           P64[Hp - 24] = _sa8ed::P64;
           P64[Hp - 16] = _sa8ee::P64;
           P64[Hp - 8] = _sa8ef::P64;
           P64[Hp] = _sa8eg::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacby: // global
           Hp = Hp - 40;
           I64[Sp + 16] = block_cacbG_info;
           R5 = _sa8ef::P64;
           R4 = _sa8eg::P64;
           R3 = _sa8ee::P64;
           R2 = _sa8ed::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacbe_info" {
     block_cacbe_info:
         const _cacbe;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cacbG() //  [R1]
         { []
         }
     {offset
       cacbG: // global
           I64[Sp + 16] = block_cacbI_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacbG_info" {
     block_cacbG_info:
         const _cacbG;
         const 130;
         const 30;
 },
 _cacbI() //  []
         { []
         }
     {offset
       cacbI: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacbI_info" {
     block_cacbI_info:
         const _cacbI;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.294512648 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'1_closure" {
     GHC.IO.Handle.Internals.withHandle__'1_closure:
         const GHC.IO.Handle.Internals.withHandle__'1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caccj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cacck; else goto caccl;
       cacck: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle__'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caccl: // global
           I64[Sp - 32] = block_caccg_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaccp; else goto cacch;
       uaccp: // global
           call _caccg(R1) args: 0, res: 0, upd: 0;
       cacch: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle__'1_info" {
     GHC.IO.Handle.Internals.withHandle__'1_info:
         const GHC.IO.Handle.Internals.withHandle__'1_entry;
         const 0;
         const 12884901902;
         const 21474836504;
         const Sa8nI_srt+464;
 },
 _caccg() //  [R1]
         { []
         }
     {offset
       caccg: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caccg_info" {
     block_caccg_info:
         const _caccg;
         const 3;
         const 4294967326;
         const Sa8nI_srt+464;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.299966009 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'_closure" {
     GHC.IO.Handle.Internals.withHandle__'_closure:
         const GHC.IO.Handle.Internals.withHandle__'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caccD: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle__'1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle__'_info" {
     GHC.IO.Handle.Internals.withHandle__'_info:
         const GHC.IO.Handle.Internals.withHandle__'_entry;
         const 0;
         const 4294967310;
         const 21474836504;
         const Sa8nI_srt+472;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.308894993 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles__1_closure" {
     GHC.IO.Handle.Internals.withAllHandles__1_closure:
         const GHC.IO.Handle.Internals.withAllHandles__1_info;
         const 0;
 },
 sat_sa8eX_entry() //  [R1]
         { []
         }
     {offset
       cacd7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacd8; else goto cacd9;
       cacd8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacd9: // global
           I64[Sp - 16] = block_cacd3_info;
           _sa8eJ::P64 = P64[R1 + 31];
           R5 = _sa8eJ::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8eJ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8eX_info" {
     sat_sa8eX_info:
         const sat_sa8eX_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacd3() //  [R1]
         { []
         }
     {offset
       cacd3: // global
           _sa8eJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cacd5_info;
           R2 = R1;
           R1 = _sa8eJ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacd3_info" {
     block_cacd3_info:
         const _cacd3;
         const 1;
         const 30;
 },
 _cacd5() //  []
         { []
         }
     {offset
       cacd5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacd5_info" {
     block_cacd5_info:
         const _cacd5;
         const 0;
         const 30;
 },
 sat_sa8fj_entry() //  [R1]
         { []
         }
     {offset
       cacdz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacdA; else goto cacdB;
       cacdA: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacdB: // global
           I64[Sp - 16] = block_cacdv_info;
           _sa8f0::P64 = P64[R1 + 31];
           R5 = _sa8f0::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8f0::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8fj_info" {
     sat_sa8fj_info:
         const sat_sa8fj_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacdv() //  [R1]
         { []
         }
     {offset
       cacdv: // global
           _sa8f0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cacdx_info;
           R2 = R1;
           R1 = _sa8f0::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacdv_info" {
     block_cacdv_info:
         const _cacdv;
         const 1;
         const 30;
 },
 _cacdx() //  []
         { []
         }
     {offset
       cacdx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacdx_info" {
     block_cacdx_info:
         const _cacdx;
         const 0;
         const 30;
 },
 sat_sa8fu_entry() //  [R1]
         { []
         }
     {offset
       cacdQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacdR; else goto cacdS;
       cacdR: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacdS: // global
           I64[Sp - 16] = block_cacdM_info;
           _sa8eZ::P64 = P64[R1 + 31];
           R5 = _sa8eZ::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8eZ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8fu_info" {
     sat_sa8fu_info:
         const sat_sa8fu_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacdM() //  [R1]
         { []
         }
     {offset
       cacdM: // global
           _sa8eZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cacdO_info;
           R2 = R1;
           R1 = _sa8eZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacdM_info" {
     block_cacdM_info:
         const _cacdM;
         const 1;
         const 30;
 },
 _cacdO() //  []
         { []
         }
     {offset
       cacdO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacdO_info" {
     block_cacdO_info:
         const _cacdO;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.withAllHandles__1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cacdZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cace0; else goto cace1;
       cace0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withAllHandles__1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cace1: // global
           I64[Sp - 24] = block_caccO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaceI; else goto caccP;
       uaceI: // global
           call _caccO(R1) args: 0, res: 0, upd: 0;
       caccP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withAllHandles__1_info" {
     GHC.IO.Handle.Internals.withAllHandles__1_info:
         const GHC.IO.Handle.Internals.withAllHandles__1_entry;
         const 0;
         const 73014444046;
         const 17179869207;
         const Sa8nI_srt+448;
 },
 _caccO() //  [R1]
         { []
         }
     {offset
       caccO: // global
           if (R1 & 7 == 1) goto cacdW; else goto cacdX;
       cacdW: // global
           I64[Sp - 16] = block_caccT_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacdX: // global
           I64[Sp - 24] = block_cacde_info;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caccO_info" {
     block_caccO_info:
         const _caccO;
         const 2;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _caccT() //  [R1]
         { []
         }
     {offset
       caccT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cace5; else goto cace4;
       cace5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cace4: // global
           _sa8eD::P64 = P64[Sp + 24];
           _sa8eF::P64 = P64[Sp + 32];
           _sa8eH::P64 = P64[Sp + 16];
           _sa8eJ::P64 = P64[Sp + 8];
           if (R1 == 0) goto cacee; else goto cacea;
       cacee: // global
           I64[Hp - 32] = sat_sa8eX_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8eJ::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacea: // global
           Hp = Hp - 40;
           I64[Sp] = block_cace6_info;
           R5 = _sa8eJ::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caccT_info" {
     block_caccT_info:
         const _caccT;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cace6() //  [R1]
         { []
         }
     {offset
       cace6: // global
           I64[Sp + 32] = block_cacep_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cace6_info" {
     block_cace6_info:
         const _cace6;
         const 900;
         const 30;
 },
 _cacde() //  [R1]
         { []
         }
     {offset
       cacde: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacei; else goto caceh;
       cacei: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caceh: // global
           _sa8eD::P64 = P64[Sp + 32];
           _sa8eF::P64 = P64[Sp + 40];
           _sa8eH::P64 = P64[Sp + 24];
           _sa8eZ::P64 = P64[Sp + 8];
           if (R1 == 0) goto caceF; else goto caceA;
       caceF: // global
           I64[Hp - 32] = sat_sa8fu_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8eZ::P64;
           I64[Sp + 8] = block_caceE_info;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       caceA: // global
           Hp = Hp - 40;
           I64[Sp] = block_cacew_info;
           R5 = _sa8eZ::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacde_info" {
     block_cacde_info:
         const _cacde;
         const 5;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _caceE() //  []
         { []
         }
     {offset
       caceE: // global
           call _sa8f4() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caceE_info" {
     block_caceE_info:
         const _caceE;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cacew() //  [R1]
         { []
         }
     {offset
       cacew: // global
           _sa8eZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_sa8f4_info;
           R2 = R1;
           R1 = _sa8eZ::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacew_info" {
     block_cacew_info:
         const _cacew;
         const 5;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _sa8f4() //  []
         { []
         }
     {offset
       sa8f4: // global
           I64[Sp] = block_cacdl_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_sa8f4_info" {
     block_sa8f4_info:
         const _sa8f4;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cacdl() //  [R1]
         { []
         }
     {offset
       cacdl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacem; else goto cacel;
       cacem: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacel: // global
           _sa8eD::P64 = P64[Sp + 24];
           _sa8eF::P64 = P64[Sp + 32];
           _sa8eH::P64 = P64[Sp + 16];
           _sa8f0::P64 = P64[Sp + 8];
           if (R1 == 0) goto cacev; else goto cacer;
       cacev: // global
           I64[Hp - 32] = sat_sa8fj_info;
           P64[Hp - 24] = _sa8eD::P64;
           P64[Hp - 16] = _sa8eF::P64;
           P64[Hp - 8] = _sa8eH::P64;
           P64[Hp] = _sa8f0::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacer: // global
           Hp = Hp - 40;
           I64[Sp] = block_cacen_info;
           R5 = _sa8f0::P64;
           R4 = _sa8eF::P64;
           R3 = _sa8eH::P64;
           R2 = _sa8eD::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacdl_info" {
     block_cacdl_info:
         const _cacdl;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cacen() //  [R1]
         { []
         }
     {offset
       cacen: // global
           I64[Sp + 32] = block_cacep_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacen_info" {
     block_cacen_info:
         const _cacen;
         const 900;
         const 30;
 },
 _cacep() //  []
         { []
         }
     {offset
       cacep: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacep_info" {
     block_cacep_info:
         const _cacep;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.342623396 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles___closure" {
     GHC.IO.Handle.Internals.withAllHandles___closure:
         const GHC.IO.Handle.Internals.withAllHandles___info;
         const 0;
 },
 GHC.IO.Handle.Internals.withAllHandles___entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cacg1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withAllHandles___info" {
     GHC.IO.Handle.Internals.withAllHandles___info:
         const GHC.IO.Handle.Internals.withAllHandles___entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Sa8nI_srt+480;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.347780739 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle'_info;
         const 0;
 },
 io_sa8fG_entry() //  [R1]
         { []
         }
     {offset
       cacgo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacgs; else goto cacgt;
       cacgs: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacgt: // global
           I64[Sp - 16] = block_cacgj_info;
           _sa8fA::P64 = P64[R1 + 23];
           R5 = _sa8fA::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8fA::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8fG_info" {
     io_sa8fG_info:
         const io_sa8fG_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacgj() //  [R1]
         { []
         }
     {offset
       cacgj: // global
           I64[Sp] = block_cacgl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacgy; else goto cacgm;
       uacgy: // global
           call _cacgl(R1) args: 0, res: 0, upd: 0;
       cacgm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacgj_info" {
     block_cacgj_info:
         const _cacgj;
         const 1;
         const 30;
 },
 _cacgl() //  [R1]
         { []
         }
     {offset
       cacgl: // global
           I64[Sp] = block_cacgr_info;
           R2 = P64[R1 + 7];
           _sa8fN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8fN::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacgl_info" {
     block_cacgl_info:
         const _cacgl;
         const 1;
         const 30;
 },
 _cacgr() //  []
         { []
         }
     {offset
       cacgr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacgr_info" {
     block_cacgr_info:
         const _cacgr;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.$wwithHandle'_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cacgD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacgE; else goto cacgF;
       cacgE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacgF: // global
           I64[Sp - 40] = block_cacgc_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wwithHandle'_info" {
     GHC.IO.Handle.Internals.$wwithHandle'_info:
         const GHC.IO.Handle.Internals.$wwithHandle'_entry;
         const 0;
         const 141733920782;
         const 21474836504;
         const Sa8nI_srt+448;
 },
 _cacgc() //  [R1]
         { []
         }
     {offset
       cacgc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacgI; else goto cacgH;
       cacgI: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacgH: // global
           I64[Hp - 32] = io_sa8fG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           _cacge::P64 = Hp - 31;
           if (R1 == 0) goto cacgC; else goto cacgB;
       cacgC: // global
           R1 = _cacge::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacgB: // global
           R1 = _cacge::P64;
           Sp = Sp + 40;
           call io_sa8fG_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacgc_info" {
     block_cacgc_info:
         const _cacgc;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.360781298 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle1_closure" {
     GHC.IO.Handle.Internals.withHandle1_closure:
         const GHC.IO.Handle.Internals.withHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cachh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cachi; else goto cachj;
       cachi: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cachj: // global
           I64[Sp - 32] = block_cache_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uachn; else goto cachf;
       uachn: // global
           call _cache(R1) args: 0, res: 0, upd: 0;
       cachf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle1_info" {
     GHC.IO.Handle.Internals.withHandle1_info:
         const GHC.IO.Handle.Internals.withHandle1_entry;
         const 0;
         const 12884901902;
         const 21474836504;
         const Sa8nI_srt+488;
 },
 _cache() //  [R1]
         { []
         }
     {offset
       cache: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cache_info" {
     block_cache_info:
         const _cache;
         const 3;
         const 4294967326;
         const Sa8nI_srt+488;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.366419234 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle'_closure" {
     GHC.IO.Handle.Internals.withHandle'_closure:
         const GHC.IO.Handle.Internals.withHandle'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle'_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cachB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle'_info" {
     GHC.IO.Handle.Internals.withHandle'_info:
         const GHC.IO.Handle.Internals.withHandle'_entry;
         const 0;
         const 4294967310;
         const 21474836504;
         const Sa8nI_srt+496;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.371334134 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'1_closure" {
     GHC.IO.Handle.Internals.withHandle_'1_closure:
         const GHC.IO.Handle.Internals.withHandle_'1_info;
         const 0;
 },
 sat_sa8ga_entry() //  [R1, R2]
         { []
         }
     {offset
       cachZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caci0; else goto caci1;
       caci0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caci1: // global
           I64[Sp - 16] = block_cachW_info;
           _sa8g4::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8g4::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8ga_info" {
     sat_sa8ga_info:
         const sat_sa8ga_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 _cachW() //  [R1]
         { []
         }
     {offset
       cachW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caci4; else goto caci3;
       caci4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caci3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cachW_info" {
     block_cachW_info:
         const _cachW;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.withHandle_'1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caci5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caci6; else goto caci7;
       caci6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caci7: // global
           I64[Sp - 32] = block_cachM_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uacib; else goto cachN;
       uacib: // global
           call _cachM(R1) args: 0, res: 0, upd: 0;
       cachN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle_'1_info" {
     GHC.IO.Handle.Internals.withHandle_'1_info:
         const GHC.IO.Handle.Internals.withHandle_'1_entry;
         const 0;
         const 21474836494;
         const 21474836504;
         const Sa8nI_srt+488;
 },
 _cachM() //  [R1]
         { []
         }
     {offset
       cachM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacia; else goto caci9;
       cacia: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caci9: // global
           _sa8g3::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sa8ga_info;
           P64[Hp] = P64[Sp + 24];
           R5 = Hp - 6;
           R4 = _sa8g3::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cachM_info" {
     block_cachM_info:
         const _cachM;
         const 3;
         const 4294967326;
         const Sa8nI_srt+488;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.380092589 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'_closure" {
     GHC.IO.Handle.Internals.withHandle_'_closure:
         const GHC.IO.Handle.Internals.withHandle_'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_'_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caciz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle_'1_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle_'_info" {
     GHC.IO.Handle.Internals.withHandle_'_info:
         const GHC.IO.Handle.Internals.withHandle_'_entry;
         const 0;
         const 4294967310;
         const 21474836504;
         const Sa8nI_srt+504;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.389329303 UTC

[section ""data" . withHandle_2_ra7PG_closure" {
     withHandle_2_ra7PG_closure:
         const withHandle_2_ra7PG_info;
         const 0;
 },
 sat_sa8gt_entry() //  [R1, R2]
         { []
         }
     {offset
       cacj4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacj5; else goto cacj6;
       cacj5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacj6: // global
           I64[Sp - 16] = block_cacj1_info;
           _sa8gn::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8gn::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8gt_info" {
     sat_sa8gt_info:
         const sat_sa8gt_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 _cacj1() //  [R1]
         { []
         }
     {offset
       cacj1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacj9; else goto cacj8;
       cacj9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacj8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacj1_info" {
     block_cacj1_info:
         const _cacj1;
         const 1;
         const 30;
 },
 io_sa8gl_entry() //  [R1]
         { []
         }
     {offset
       cacjf: // global
           _sa8gl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacjj; else goto cacjk;
       cacjk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacjm; else goto cacjl;
       cacjm: // global
           HpAlloc = 16;
           goto cacjj;
       cacjj: // global
           R1 = _sa8gl::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacjl: // global
           _sa8gb::P64 = P64[_sa8gl::P64 + 7];
           _sa8gd::P64 = P64[_sa8gl::P64 + 15];
           _sa8gf::P64 = P64[_sa8gl::P64 + 23];
           _sa8gh::P64 = P64[_sa8gl::P64 + 31];
           I64[Hp - 8] = sat_sa8gt_info;
           P64[Hp] = _sa8gd::P64;
           I64[Sp - 16] = block_cacja_info;
           R5 = _sa8gh::P64;
           R4 = Hp - 6;
           R3 = _sa8gf::P64;
           R2 = _sa8gb::P64;
           P64[Sp - 8] = _sa8gh::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8gl_info" {
     io_sa8gl_info:
         const io_sa8gl_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacja() //  [R1]
         { []
         }
     {offset
       cacja: // global
           I64[Sp] = block_cacjc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacjr; else goto cacjd;
       uacjr: // global
           call _cacjc(R1) args: 0, res: 0, upd: 0;
       cacjd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacja_info" {
     block_cacja_info:
         const _cacja;
         const 1;
         const 30;
 },
 _cacjc() //  [R1]
         { []
         }
     {offset
       cacjc: // global
           I64[Sp] = block_cacji_info;
           R2 = P64[R1 + 7];
           _sa8gz::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8gz::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacjc_info" {
     block_cacjc_info:
         const _cacjc;
         const 1;
         const 30;
 },
 _cacji() //  []
         { []
         }
     {offset
       cacji: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacji_info" {
     block_cacji_info:
         const _cacji;
         const 1;
         const 30;
 },
 sat_sa8gQ_entry() //  [R1, R2]
         { []
         }
     {offset
       cacjJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacjK; else goto cacjL;
       cacjK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacjL: // global
           I64[Sp - 16] = block_cacjG_info;
           _sa8gK::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sa8gK::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8gQ_info" {
     sat_sa8gQ_info:
         const sat_sa8gQ_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 _cacjG() //  [R1]
         { []
         }
     {offset
       cacjG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacjO; else goto cacjN;
       cacjO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacjN: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacjG_info" {
     block_cacjG_info:
         const _cacjG;
         const 1;
         const 30;
 },
 io_sa8gI_entry() //  [R1]
         { []
         }
     {offset
       cacjU: // global
           _sa8gI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacjY; else goto cacjZ;
       cacjZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cack1; else goto cack0;
       cack1: // global
           HpAlloc = 16;
           goto cacjY;
       cacjY: // global
           R1 = _sa8gI::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cack0: // global
           _sa8gb::P64 = P64[_sa8gI::P64 + 7];
           _sa8gd::P64 = P64[_sa8gI::P64 + 15];
           _sa8gf::P64 = P64[_sa8gI::P64 + 23];
           _sa8gD::P64 = P64[_sa8gI::P64 + 31];
           I64[Hp - 8] = sat_sa8gQ_info;
           P64[Hp] = _sa8gd::P64;
           I64[Sp - 16] = block_cacjP_info;
           R5 = _sa8gD::P64;
           R4 = Hp - 6;
           R3 = _sa8gf::P64;
           R2 = _sa8gb::P64;
           P64[Sp - 8] = _sa8gD::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8gI_info" {
     io_sa8gI_info:
         const io_sa8gI_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacjP() //  [R1]
         { []
         }
     {offset
       cacjP: // global
           I64[Sp] = block_cacjR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uack6; else goto cacjS;
       uack6: // global
           call _cacjR(R1) args: 0, res: 0, upd: 0;
       cacjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacjP_info" {
     block_cacjP_info:
         const _cacjP;
         const 1;
         const 30;
 },
 _cacjR() //  [R1]
         { []
         }
     {offset
       cacjR: // global
           I64[Sp] = block_cacjX_info;
           R2 = P64[R1 + 7];
           _sa8gW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8gW::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacjR_info" {
     block_cacjR_info:
         const _cacjR;
         const 1;
         const 30;
 },
 _cacjX() //  []
         { []
         }
     {offset
       cacjX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacjX_info" {
     block_cacjX_info:
         const _cacjX;
         const 1;
         const 30;
 },
 withHandle_2_ra7PG_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cackb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cackc; else goto cackd;
       cackc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle_2_ra7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cackd: // global
           I64[Sp - 24] = block_caciK_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacku; else goto caciL;
       uacku: // global
           call _caciK(R1) args: 0, res: 0, upd: 0;
       caciL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . withHandle_2_ra7PG_info" {
     withHandle_2_ra7PG_info:
         const withHandle_2_ra7PG_entry;
         const 0;
         const 1103806595086;
         const 17179869207;
         const Sa8nI_srt+448;
 },
 _caciK() //  [R1]
         { []
         }
     {offset
       caciK: // global
           if (R1 & 7 == 1) goto cack8; else goto cack9;
       cack8: // global
           I64[Sp - 16] = block_caciP_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cack9: // global
           I64[Sp - 16] = block_cacju_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caciK_info" {
     block_caciK_info:
         const _caciK;
         const 2;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _caciP() //  [R1]
         { []
         }
     {offset
       caciP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cackh; else goto cackg;
       cackh: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cackg: // global
           I64[Hp - 32] = io_sa8gl_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caciR::P64 = Hp - 31;
           if (R1 == 0) goto cackl; else goto cackk;
       cackl: // global
           R1 = _caciR::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cackk: // global
           R1 = _caciR::P64;
           Sp = Sp + 40;
           call io_sa8gl_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caciP_info" {
     block_caciP_info:
         const _caciP;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cacju() //  [R1]
         { []
         }
     {offset
       cacju: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cackp; else goto cacko;
       cackp: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacko: // global
           I64[Hp - 32] = io_sa8gI_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacjw::P64 = Hp - 31;
           if (R1 == 0) goto cackt; else goto cacks;
       cackt: // global
           R1 = _cacjw::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacks: // global
           R1 = _cacjw::P64;
           Sp = Sp + 40;
           call io_sa8gI_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacju_info" {
     block_cacju_info:
         const _cacju;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.417966144 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__closure" {
     GHC.IO.Handle.Internals.withHandle__closure:
         const GHC.IO.Handle.Internals.withHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caclM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle_2_ra7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle__info" {
     GHC.IO.Handle.Internals.withHandle__info:
         const GHC.IO.Handle.Internals.withHandle__entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Sa8nI_srt+512;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.427024407 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_1_info;
         const 0;
 },
 sat_sa8hh_entry() //  [R1, R2]
         { []
         }
     {offset
       cacmh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacmi; else goto cacmj;
       cacmi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacmj: // global
           I64[Sp - 16] = block_cacme_info;
           R3 = R2;
           _sa8hb::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sa8hb::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8hh_info" {
     sat_sa8hh_info:
         const sat_sa8hh_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const Sa8nI_srt+520;
 },
 _cacme() //  [R1]
         { []
         }
     {offset
       cacme: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacmm; else goto cacml;
       cacmm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacml: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacme_info" {
     block_cacme_info:
         const _cacme;
         const 1;
         const 30;
 },
 io_sa8h9_entry() //  [R1]
         { []
         }
     {offset
       cacms: // global
           _sa8h9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacmw; else goto cacmx;
       cacmx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacmz; else goto cacmy;
       cacmz: // global
           HpAlloc = 16;
           goto cacmw;
       cacmw: // global
           R1 = _sa8h9::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacmy: // global
           _sa8gZ::P64 = P64[_sa8h9::P64 + 7];
           _sa8h1::P64 = P64[_sa8h9::P64 + 15];
           _sa8h3::P64 = P64[_sa8h9::P64 + 23];
           _sa8h5::P64 = P64[_sa8h9::P64 + 31];
           I64[Hp - 8] = sat_sa8hh_info;
           P64[Hp] = _sa8h1::P64;
           I64[Sp - 16] = block_cacmn_info;
           R5 = _sa8h5::P64;
           R4 = Hp - 6;
           R3 = _sa8h3::P64;
           R2 = _sa8gZ::P64;
           P64[Sp - 8] = _sa8h5::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8h9_info" {
     io_sa8h9_info:
         const io_sa8h9_entry;
         const 4;
         const 2203318222856;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacmn() //  [R1]
         { []
         }
     {offset
       cacmn: // global
           I64[Sp] = block_cacmp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacmE; else goto cacmq;
       uacmE: // global
           call _cacmp(R1) args: 0, res: 0, upd: 0;
       cacmq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacmn_info" {
     block_cacmn_info:
         const _cacmn;
         const 1;
         const 30;
 },
 _cacmp() //  [R1]
         { []
         }
     {offset
       cacmp: // global
           I64[Sp] = block_cacmv_info;
           R2 = P64[R1 + 7];
           _sa8hn::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8hn::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacmp_info" {
     block_cacmp_info:
         const _cacmp;
         const 1;
         const 30;
 },
 _cacmv() //  []
         { []
         }
     {offset
       cacmv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacmv_info" {
     block_cacmv_info:
         const _cacmv;
         const 1;
         const 30;
 },
 sat_sa8hE_entry() //  [R1, R2]
         { []
         }
     {offset
       cacmW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacmX; else goto cacmY;
       cacmX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacmY: // global
           I64[Sp - 16] = block_cacmT_info;
           R3 = R2;
           _sa8hy::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sa8hy::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8hE_info" {
     sat_sa8hE_info:
         const sat_sa8hE_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const Sa8nI_srt+520;
 },
 _cacmT() //  [R1]
         { []
         }
     {offset
       cacmT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacn1; else goto cacn0;
       cacn1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacn0: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacmT_info" {
     block_cacmT_info:
         const _cacmT;
         const 1;
         const 30;
 },
 io_sa8hw_entry() //  [R1]
         { []
         }
     {offset
       cacn7: // global
           _sa8hw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacnb; else goto cacnc;
       cacnc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacne; else goto cacnd;
       cacne: // global
           HpAlloc = 16;
           goto cacnb;
       cacnb: // global
           R1 = _sa8hw::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacnd: // global
           _sa8gZ::P64 = P64[_sa8hw::P64 + 7];
           _sa8h1::P64 = P64[_sa8hw::P64 + 15];
           _sa8h3::P64 = P64[_sa8hw::P64 + 23];
           _sa8hr::P64 = P64[_sa8hw::P64 + 31];
           I64[Hp - 8] = sat_sa8hE_info;
           P64[Hp] = _sa8h1::P64;
           I64[Sp - 16] = block_cacn2_info;
           R5 = _sa8hr::P64;
           R4 = Hp - 6;
           R3 = _sa8h3::P64;
           R2 = _sa8gZ::P64;
           P64[Sp - 8] = _sa8hr::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8hw_info" {
     io_sa8hw_info:
         const io_sa8hw_entry;
         const 4;
         const 2203318222856;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacn2() //  [R1]
         { []
         }
     {offset
       cacn2: // global
           I64[Sp] = block_cacn4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacnj; else goto cacn5;
       uacnj: // global
           call _cacn4(R1) args: 0, res: 0, upd: 0;
       cacn5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacn2_info" {
     block_cacn2_info:
         const _cacn2;
         const 1;
         const 30;
 },
 _cacn4() //  [R1]
         { []
         }
     {offset
       cacn4: // global
           I64[Sp] = block_cacna_info;
           R2 = P64[R1 + 7];
           _sa8hK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8hK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacn4_info" {
     block_cacn4_info:
         const _cacn4;
         const 1;
         const 30;
 },
 _cacna() //  []
         { []
         }
     {offset
       cacna: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacna_info" {
     block_cacna_info:
         const _cacna;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.wantReadableHandle_1_entry() //  [R2, R3,
                                                           R4]
         { []
         }
     {offset
       cacno: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacnp; else goto cacnq;
       cacnp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacnq: // global
           I64[Sp - 24] = block_caclX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacnH; else goto caclY;
       uacnH: // global
           call _caclX(R1) args: 0, res: 0, upd: 0;
       caclY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle_1_info" {
     GHC.IO.Handle.Internals.wantReadableHandle_1_info:
         const GHC.IO.Handle.Internals.wantReadableHandle_1_entry;
         const 0;
         const 6601364733966;
         const 17179869207;
         const Sa8nI_srt+448;
 },
 _caclX() //  [R1]
         { []
         }
     {offset
       caclX: // global
           if (R1 & 7 == 1) goto cacnl; else goto cacnm;
       cacnl: // global
           I64[Sp - 16] = block_cacm2_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacnm: // global
           I64[Sp - 16] = block_cacmH_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caclX_info" {
     block_caclX_info:
         const _caclX;
         const 2;
         const 2203318222878;
         const Sa8nI_srt+448;
 },
 _cacm2() //  [R1]
         { []
         }
     {offset
       cacm2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacnu; else goto cacnt;
       cacnu: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacnt: // global
           I64[Hp - 32] = io_sa8h9_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacm4::P64 = Hp - 31;
           if (R1 == 0) goto cacny; else goto cacnx;
       cacny: // global
           R1 = _cacm4::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacnx: // global
           R1 = _cacm4::P64;
           Sp = Sp + 40;
           call io_sa8h9_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacm2_info" {
     block_cacm2_info:
         const _cacm2;
         const 4;
         const 2203318222878;
         const Sa8nI_srt+448;
 },
 _cacmH() //  [R1]
         { []
         }
     {offset
       cacmH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacnC; else goto cacnB;
       cacnC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacnB: // global
           I64[Hp - 32] = io_sa8hw_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacmJ::P64 = Hp - 31;
           if (R1 == 0) goto cacnG; else goto cacnF;
       cacnG: // global
           R1 = _cacmJ::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacnF: // global
           R1 = _cacmJ::P64;
           Sp = Sp + 40;
           call io_sa8hw_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacmH_info" {
     block_cacmH_info:
         const _cacmH;
         const 4;
         const 2203318222878;
         const Sa8nI_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.455398396 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle__closure" {
     GHC.IO.Handle.Internals.wantReadableHandle__closure:
         const GHC.IO.Handle.Internals.wantReadableHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle__entry() //  [R2, R3,
                                                          R4]
         { []
         }
     {offset
       cacoZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle__info" {
     GHC.IO.Handle.Internals.wantReadableHandle__info:
         const GHC.IO.Handle.Internals.wantReadableHandle__entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Sa8nI_srt+528;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.459909637 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle2_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle2_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle2_info;
         const 0;
 },
 sat_sa8hS_entry() //  [R1]
         { []
         }
     {offset
       cacpg: // global
           _sa8hS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacph; else goto cacpi;
       cacpi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cacpk; else goto cacpj;
       cacpk: // global
           HpAlloc = 72;
           goto cacph;
       cacph: // global
           R1 = _sa8hS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cacpj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa8hS::P64;
           _sa8hN::P64 = P64[_sa8hS::P64 + 16];
           _sa8hO::P64 = P64[_sa8hS::P64 + 24];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sa8hO::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = _sa8hN::P64;
           P64[Hp - 16] = GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa8hS_info" {
     sat_sa8hS_info:
         const sat_sa8hS_entry;
         const 2;
         const 281479271677970;
         const Sa8nI_srt+408;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle2_entry() //  [R2, R3]
         { []
         }
     {offset
       cacpl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cacpp; else goto cacpo;
       cacpp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cacpo: // global
           I64[Hp - 24] = sat_sa8hS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle2_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle2_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle2_entry;
         const 0;
         const 844429225099278;
         const 12884901903;
         const Sa8nI_srt+408;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.470399532 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle1_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle1_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle1_info;
         const 0;
 },
 sat_sa8iB_entry() //  [R1, R2]
         { []
         }
     {offset
       cacpX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacpY; else goto cacpZ;
       cacpY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacpZ: // global
           I64[Sp - 16] = block_cacpU_info;
           _sa8hV::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sa8hV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uacqP; else goto cacpV;
       uacqP: // global
           call _cacpU(R1) args: 0, res: 0, upd: 0;
       cacpV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8iB_info" {
     sat_sa8iB_info:
         const sat_sa8iB_entry;
         const 1;
         const 30064771081;
         const 8589934597;
         const Sa8nI_srt+552;
 },
 _cacpU() //  [R1]
         { []
         }
     {offset
       cacpU: // global
           I64[Sp - 24] = block_cacq2_info;
           _sa8i7::P64 = R1;
           _sa8i8::P64 = P64[R1 + 7];
           _sa8ib::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sa8i8::P64;
           P64[Sp - 8] = _sa8ib::P64;
           P64[Sp] = _sa8i7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacqO; else goto cacq4;
       uacqO: // global
           call _cacq2(R1) args: 0, res: 0, upd: 0;
       cacq4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacpU_info" {
     block_cacpU_info:
         const _cacpU;
         const 1;
         const 30064771102;
         const Sa8nI_srt+552;
 },
 _cacq2() //  [R1]
         { []
         }
     {offset
       cacq2: // global
           _cacqI::P64 = R1 & 7;
           if (_cacqI::P64 < 3) goto uacqK; else goto uacqL;
       uacqK: // global
           if (_cacqI::P64 < 2) goto cacqz; else goto cacqD;
       cacqz: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cacqD: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uacqL: // global
           if (_cacqI::P64 != 5) goto cacqd; else goto uacqM;
       cacqd: // global
           _sa8ib::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cacq8_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sa8ib::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
       uacqM: // global
           Sp = Sp + 40;
           call _cacqH() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cacq2_info" {
     block_cacq2_info:
         const _cacq2;
         const 4;
         const 30064771102;
         const Sa8nI_srt+552;
 },
 _cacq8() //  [R1]
         { []
         }
     {offset
       cacq8: // global
           I64[Sp] = block_cacqa_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacqR; else goto cacqf;
       uacqR: // global
           call _cacqa(R1) args: 0, res: 0, upd: 0;
       cacqf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacq8_info" {
     block_cacq8_info:
         const _cacq8;
         const 2;
         const 4294967326;
         const Sa8nI_srt+552;
 },
 _cacqa() //  [R1]
         { []
         }
     {offset
       cacqa: // global
           if (R1 & 7 == 1) goto uacqN; else goto cacqs;
       uacqN: // global
           Sp = Sp + 24;
           call _cacqH() args: 0, res: 0, upd: 0;
       cacqs: // global
           I64[Sp] = block_cacqo_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacqa_info" {
     block_cacqa_info:
         const _cacqa;
         const 2;
         const 4294967326;
         const Sa8nI_srt+552;
 },
 _cacqo() //  [R1]
         { []
         }
     {offset
       cacqo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacqv; else goto cacqu;
       cacqv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacqu: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacqo_info" {
     block_cacqo_info:
         const _cacqo;
         const 130;
         const 30;
 },
 _cacqH() //  []
         { []
         }
     {offset
       cacqH: // global
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sa8i3_entry() //  [R1]
         { []
         }
     {offset
       cacqY: // global
           _sa8i3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacr2; else goto cacr3;
       cacr3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacr5; else goto cacr4;
       cacr5: // global
           HpAlloc = 16;
           goto cacr2;
       cacr2: // global
           R1 = _sa8i3::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacr4: // global
           _sa8hT::P64 = P64[_sa8i3::P64 + 7];
           _sa8hV::P64 = P64[_sa8i3::P64 + 15];
           _sa8hX::P64 = P64[_sa8i3::P64 + 23];
           _sa8hZ::P64 = P64[_sa8i3::P64 + 31];
           I64[Hp - 8] = sat_sa8iB_info;
           P64[Hp] = _sa8hV::P64;
           I64[Sp - 16] = block_cacqT_info;
           R5 = _sa8hZ::P64;
           R4 = Hp - 6;
           R3 = _sa8hX::P64;
           R2 = _sa8hT::P64;
           P64[Sp - 8] = _sa8hZ::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8i3_info" {
     io_sa8i3_info:
         const io_sa8i3_entry;
         const 4;
         const 246294899589128;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacqT() //  [R1]
         { []
         }
     {offset
       cacqT: // global
           I64[Sp] = block_cacqV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacra; else goto cacqW;
       uacra: // global
           call _cacqV(R1) args: 0, res: 0, upd: 0;
       cacqW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacqT_info" {
     block_cacqT_info:
         const _cacqT;
         const 1;
         const 30;
 },
 _cacqV() //  [R1]
         { []
         }
     {offset
       cacqV: // global
           I64[Sp] = block_cacr1_info;
           R2 = P64[R1 + 7];
           _sa8iH::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8iH::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacqV_info" {
     block_cacqV_info:
         const _cacqV;
         const 1;
         const 30;
 },
 _cacr1() //  []
         { []
         }
     {offset
       cacr1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacr1_info" {
     block_cacr1_info:
         const _cacr1;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle1_entry() //  [R2, R3,
                                                          R4]
         { []
         }
     {offset
       cacrf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacrg; else goto cacrh;
       cacrg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacrh: // global
           I64[Sp - 24] = block_cacpD_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacrt; else goto cacpE;
       uacrt: // global
           call _cacpD(R1) args: 0, res: 0, upd: 0;
       cacpE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle1_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle1_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle1_entry;
         const 0;
         const 545362062344206;
         const 17179869207;
         const Sa8nI_srt+448;
 },
 _cacpD() //  [R1]
         { []
         }
     {offset
       cacpD: // global
           if (R1 & 7 == 1) goto cacrc; else goto cacrd;
       cacrc: // global
           I64[Sp - 16] = block_cacpI_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacrd: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.wantSeekableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacpD_info" {
     block_cacpD_info:
         const _cacpD;
         const 2;
         const 263887085633566;
         const Sa8nI_srt+448;
 },
 _cacpI() //  [R1]
         { []
         }
     {offset
       cacpI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacrl; else goto cacrk;
       cacrl: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacrk: // global
           I64[Hp - 32] = io_sa8i3_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacpK::P64 = Hp - 31;
           if (R1 == 0) goto cacrp; else goto cacro;
       cacrp: // global
           R1 = _cacpK::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacro: // global
           R1 = _cacpK::P64;
           Sp = Sp + 40;
           call io_sa8i3_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacpI_info" {
     block_cacpI_info:
         const _cacpI;
         const 4;
         const 246294899589150;
         const Sa8nI_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.494611779 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cacsz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Sa8nI_srt+576;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.5099475 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwantWritableHandle'_closure" {
     GHC.IO.Handle.Internals.$wwantWritableHandle'_closure:
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_info;
         const 0;
 },
 sat_sa8jT_entry() //  [R1]
         { []
         }
     {offset
       cactw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cactA; else goto cactB;
       cactA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cactB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cactt_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uactF; else goto cactu;
       uactF: // global
           call _cactt(R1) args: 0, res: 0, upd: 0;
       cactu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa8jT_info" {
     sat_sa8jT_info:
         const sat_sa8jT_entry;
         const 1;
         const 16;
 },
 _cactt() //  [R1]
         { []
         }
     {offset
       cactt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cactE; else goto cactD;
       cactE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cactD: // global
           _sa8jO::P64 = P64[R1 + 7];
           _sa8jN::I64 = I64[R1 + 23];
           _sa8jQ::I64 = I64[R1 + 31];
           _sa8jR::I64 = I64[R1 + 39];
           _sa8jS::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8jO::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sa8jN::I64;
           I64[Hp - 16] = _sa8jQ::I64;
           I64[Hp - 8] = _sa8jR::I64;
           I64[Hp] = _sa8jS::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cactt_info" {
     block_cactt_info:
         const _cactt;
         const 0;
         const 30;
 },
 sat_sa8ko_entry() //  [R1]
         { []
         }
     {offset
       cacu0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cacu4; else goto cacu5;
       cacu4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cacu5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cactX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacu9; else goto cactY;
       uacu9: // global
           call _cactX(R1) args: 0, res: 0, upd: 0;
       cactY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa8ko_info" {
     sat_sa8ko_info:
         const sat_sa8ko_entry;
         const 1;
         const 16;
 },
 _cactX() //  [R1]
         { []
         }
     {offset
       cactX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cacu8; else goto cacu7;
       cacu8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cacu7: // global
           _sa8kj::P64 = P64[R1 + 7];
           _sa8kk::P64 = P64[R1 + 15];
           _sa8ki::I64 = I64[R1 + 23];
           _sa8kl::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8kj::P64;
           P64[Hp - 32] = _sa8kk::P64;
           I64[Hp - 24] = _sa8ki::I64;
           I64[Hp - 16] = _sa8kl::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cactX_info" {
     block_cactX_info:
         const _cactX;
         const 0;
         const 30;
 },
 sat_sa8kH_entry() //  [R1]
         { []
         }
     {offset
       cacuw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cacuD; else goto cacuE;
       cacuD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cacuE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cacut_info;
           _sa8kx::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sa8kx::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uacuI; else goto cacuu;
       uacuI: // global
           call _cacut(R1) args: 0, res: 0, upd: 0;
       cacuu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sa8kH_info" {
     sat_sa8kH_info:
         const sat_sa8kH_entry;
         const 4294967297;
         const 19;
 },
 _cacut() //  [R1]
         { []
         }
     {offset
       cacut: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cacuH; else goto cacuG;
       cacuH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cacuG: // global
           _sa8kB::P64 = P64[R1 + 7];
           _sa8kC::P64 = P64[R1 + 15];
           _sa8kA::I64 = I64[R1 + 23];
           _sa8kD::I64 = I64[R1 + 31];
           _sa8kF::I64 = I64[R1 + 47];
           _sa8kG::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sa8kB::P64;
           P64[Hp - 32] = _sa8kC::P64;
           I64[Hp - 24] = _sa8kA::I64;
           I64[Hp - 16] = _sa8kD::I64;
           I64[Hp - 8] = _sa8kG::I64;
           I64[Hp] = _sa8kF::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cacut_info" {
     block_cacut_info:
         const _cacut;
         const 65;
         const 30;
 },
 section ""relreadonly" . uacx8_srtd" {
     uacx8_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 sat_sa8l6_entry() //  [R1, R2]
         { []
         }
     {offset
       cacuJ: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cacuK; else goto cacuL;
       cacuK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cacuL: // global
           I64[Sp - 16] = block_cacsP_info;
           _sa8iQ::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sa8iQ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uacx0; else goto cacsQ;
       uacx0: // global
           call _cacsP(R1) args: 0, res: 0, upd: 0;
       cacsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8l6_info" {
     sat_sa8l6_info:
         const sat_sa8l6_entry;
         const 1;
         const 18446744069414584329;
         const 8589934597;
         const uacx8_srtd;
 },
 section ""relreadonly" . uacx9_srtd" {
     uacx9_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 _cacsP() //  [R1]
         { []
         }
     {offset
       cacsP: // global
           I64[Sp - 56] = block_cacsU_info;
           _sa8iU::P64 = R1;
           _sa8iW::P64 = P64[R1 + 15];
           _sa8iY::P64 = P64[R1 + 31];
           _sa8j0::P64 = P64[R1 + 47];
           _sa8j2::P64 = P64[R1 + 63];
           _sa8j3::P64 = P64[R1 + 71];
           _sa8j6::P64 = P64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 48] = _sa8iW::P64;
           P64[Sp - 40] = _sa8iY::P64;
           P64[Sp - 32] = _sa8j0::P64;
           P64[Sp - 24] = _sa8j2::P64;
           P64[Sp - 16] = _sa8j3::P64;
           P64[Sp - 8] = _sa8j6::P64;
           P64[Sp] = _sa8iU::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uacwN; else goto cacsV;
       uacwN: // global
           call _cacsU(R1) args: 0, res: 0, upd: 0;
       cacsV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacsP_info" {
     block_cacsP_info:
         const _cacsP;
         const 1;
         const 18446744069414584350;
         const uacx9_srtd;
 },
 section ""relreadonly" . uacxa_srtd" {
     uacxa_srtd:
         const Sa8nI_srt+104;
         const 59;
         const 432345564228616193;
 },
 _cacsU() //  [R1]
         { []
         }
     {offset
       cacsU: // global
           _cacwr::P64 = R1 & 7;
           if (_cacwr::P64 < 4) goto uacwF; else goto uacwH;
       uacwF: // global
           if (_cacwr::P64 < 3) goto uacwG; else goto cacv5;
       uacwG: // global
           if (_cacwr::P64 < 2) goto cacuZ; else goto cacv2;
       cacuZ: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cacv2: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cacv5: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uacwH: // global
           if (_cacwr::P64 < 6) goto cacuT; else goto cacv7;
       cacuT: // global
           I64[Sp + 48] = block_cacuO_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       cacv7: // global
           _sa8jl::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cact3_info;
           R1 = _sa8jl::P64;
           if (R1 & 7 != 0) goto uacwO; else goto cact4;
       uacwO: // global
           call _cact3(R1) args: 0, res: 0, upd: 0;
       cact4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacsU_info" {
     block_cacsU_info:
         const _cacsU;
         const 8;
         const 18446744069414584350;
         const uacxa_srtd;
 },
 _cacuO() //  [R1]
         { []
         }
     {offset
       cacuO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacuW; else goto cacuV;
       cacuW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacuV: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacuO_info" {
     block_cacuO_info:
         const _cacuO;
         const 130;
         const 30;
 },
 _cact3() //  [R1]
         { []
         }
     {offset
       cact3: // global
           I64[Sp] = block_cact8_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uacwP; else goto cact9;
       uacwP: // global
           call _cact8(R1) args: 0, res: 0, upd: 0;
       cact9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cact3_info" {
     block_cact3_info:
         const _cact3;
         const 8;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cact8() //  [R1]
         { []
         }
     {offset
       cact8: // global
           if (R1 & 7 == 1) goto cacvb; else goto cacwn;
       cacvb: // global
           _sa8jw::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cactd_info;
           R1 = _sa8jw::P64;
           if (R1 & 7 != 0) goto uacwQ; else goto cacte;
       uacwQ: // global
           call _cactd(R1) args: 0, res: 0, upd: 0;
       cacte: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cacwn: // global
           I64[Sp + 48] = block_cacwj_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cact8_info" {
     block_cact8_info:
         const _cact8;
         const 8;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cactd() //  [R1]
         { []
         }
     {offset
       cactd: // global
           I64[Sp - 16] = block_cactG_info;
           _sa8jC::I64 = I64[R1 + 39];
           _sa8jD::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sa8jD::I64;
           I64[Sp] = _sa8jC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uacwR; else goto cactH;
       uacwR: // global
           call _cactG(R1) args: 0, res: 0, upd: 0;
       cactH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cactd_info" {
     block_cactd_info:
         const _cactd;
         const 8;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cactG() //  [R1]
         { []
         }
     {offset
       cactG: // global
           if (R1 & 7 == 1) goto cacwc; else goto uacwI;
       cacwc: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto uacwJ; else goto cacvy;
       uacwJ: // global
           Sp = Sp + 24;
           goto uacwU;
       cacvy: // global
           _sa8ka::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp + 16] = block_cactO_info;
           R1 = _sa8ka::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uacwS; else goto cactP;
       uacwS: // global
           call _cactO(R1) args: 0, res: 0, upd: 0;
       cactP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uacwI: // global
           Sp = Sp + 24;
           goto uacwU;
       uacwU: // global
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cactG_info" {
     block_cactG_info:
         const _cactG;
         const 202;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cactO() //  [R1]
         { []
         }
     {offset
       cactO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacvB; else goto cacvA;
       cacvB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacvA: // global
           _sa8j3::P64 = P64[Sp + 40];
           _sa8kc::P64 = P64[R1 + 7];
           _sa8kd::P64 = P64[R1 + 15];
           _sa8kg::P64 = P64[_sa8j3::P64 + 8];
           I64[Hp - 16] = sat_sa8ko_info;
           P64[Hp] = _sa8kg::P64;
           call MO_WriteBarrier();
           P64[_sa8j3::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j3::P64);
           I64[Sp - 8] = block_cacud_info;
           R1 = _sa8kg::P64;
           P64[Sp] = _sa8kd::P64;
           P64[Sp + 32] = _sa8kc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uacwV; else goto cacue;
       uacwV: // global
           call _cacud(R1) args: 0, res: 0, upd: 0;
       cacue: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cactO_info" {
     block_cactO_info:
         const _cactO;
         const 520;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cacud() //  [R1]
         { []
         }
     {offset
       cacud: // global
           _sa8kx::I64 = I64[R1 + 39];
           if (_sa8kx::I64 != 0) goto cacvE; else goto cacw9;
       cacvE: // global
           I64[Sp - 24] = block_cacuk_info;
           _sa8ks::P64 = P64[R1 + 7];
           _sa8kt::P64 = P64[R1 + 15];
           _sa8kr::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           P64[Sp - 16] = _sa8kt::P64;
           I64[Sp - 8] = _sa8kx::I64;
           P64[Sp] = _sa8ks::P64;
           I64[Sp + 56] = _sa8kr::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacwW; else goto cacul;
       uacwW: // global
           call _cacuk(R1) args: 0, res: 0, upd: 0;
       cacul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cacw9: // global
           _sa8j0::P64 = P64[Sp + 32];
           _sa8kd::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = _sa8kd::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 16;
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cacud_info" {
     block_cacud_info:
         const _cacud;
         const 9;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cacuk() //  [R1]
         { []
         }
     {offset
       cacuk: // global
           if (R1 & 7 == 1) goto cacvG; else goto cacvY;
       cacvG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cacvJ; else goto cacvI;
       cacvJ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacvI: // global
           I64[Hp - 24] = sat_sa8kH_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sa8j0::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 40;
           call _sa8jE() args: 0, res: 0, upd: 0;
       cacvY: // global
           I64[Sp] = block_cacvM_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uacwY; else goto cacvN;
       uacwY: // global
           call _cacvM(R1) args: 0, res: 0, upd: 0;
       cacvN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacuk_info" {
     block_cacuk_info:
         const _cacuk;
         const 32908;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cacvM() //  [R1]
         { []
         }
     {offset
       cacvM: // global
           I64[Sp - 8] = block_cacvR_info;
           R2 = P64[Sp + 64];
           _sa8kL::P64 = P64[R1 + 7];
           _sa8kM::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sa8kM::P64;
           P64[Sp + 64] = _sa8kL::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacvM_info" {
     block_cacvM_info:
         const _cacvM;
         const 32908;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cacvR() //  [R1]
         { []
         }
     {offset
       cacvR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cacw2; else goto cacw1;
       cacw2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacw1: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sa8kd::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cacvU_info;
           R5 = Hp - 47;
           R4 = _sa8kd::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 72];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacvR_info" {
     block_cacvR_info:
         const _cacvR;
         const 65805;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cacvU() //  [R1]
         { []
         }
     {offset
       cacvU: // global
           I64[Sp] = block_cacvW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacx1; else goto cacw4;
       uacx1: // global
           call _cacvW(R1) args: 0, res: 0, upd: 0;
       cacw4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacvU_info" {
     block_cacvU_info:
         const _cacvU;
         const 2568;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _cacvW() //  [R1]
         { []
         }
     {offset
       cacvW: // global
           _sa8j0::P64 = P64[Sp + 24];
           _sa8kY::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = _sa8kY::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           Sp = Sp + 8;
           call _sa8jE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cacvW_info" {
     block_cacvW_info:
         const _cacvW;
         const 2568;
         const 4294967326;
         const Sa8nI_srt+584;
 },
 _sa8jE() //  []
         { []
         }
     {offset
       sa8jE: // global
           I64[Sp - 8] = block_cactn_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cactn() //  [R1]
         { []
         }
     {offset
       cactn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacvr; else goto cacvq;
       cacvr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacvq: // global
           _sa8j3::P64 = P64[Sp + 40];
           _sa8jL::P64 = P64[_sa8j3::P64 + 8];
           I64[Hp - 16] = sat_sa8jT_info;
           P64[Hp] = _sa8jL::P64;
           _sa8iW::P64 = P64[Sp + 8];
           _sa8iY::P64 = P64[Sp + 16];
           _sa8j0::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sa8j3::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j3::P64);
           I64[Sp + 16] = block_cacvg_info;
           R2 = _sa8iW::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sa8iY::P64;
           P64[Sp + 8] = P64[_sa8j0::P64 + 8];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.emptyWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cactn_info" {
     block_cactn_info:
         const _cactn;
         const 2568;
         const 30;
 },
 _cacvg() //  [R1]
         { []
         }
     {offset
       cacvg: // global
           _sa8iQ::P64 = P64[Sp + 48];
           _sa8iU::P64 = P64[Sp + 40];
           _sa8j0::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sa8j0::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sa8j0::P64);
           I64[Sp + 32] = block_cacvl_info;
           R2 = _sa8iU::P64;
           R1 = _sa8iQ::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacvg_info" {
     block_cacvg_info:
         const _cacvg;
         const 902;
         const 30;
 },
 _cacvl() //  [R1]
         { []
         }
     {offset
       cacvl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacvv; else goto cacvu;
       cacvv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacvu: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacvl_info" {
     block_cacvl_info:
         const _cacvl;
         const 130;
         const 30;
 },
 _cacwj() //  [R1]
         { []
         }
     {offset
       cacwj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cacwq; else goto cacwp;
       cacwq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacwp: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacwj_info" {
     block_cacwj_info:
         const _cacwj;
         const 130;
         const 30;
 },
 section ""relreadonly" . uacxb_srtd" {
     uacxb_srtd:
         const Sa8nI_srt+104;
         const 62;
         const 3891391553024819201;
 },
 GHC.IO.Handle.Internals.$wwantWritableHandle'_entry() //  [R2, R3,
                                                            R4, R5]
         { []
         }
     {offset
       cacx3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacx7; else goto cacx6;
       cacx7: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacx6: // global
           I64[Hp - 8] = sat_sa8l6_info;
           P64[Hp] = R5;
           R5 = Hp - 6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wwantWritableHandle'_info" {
     GHC.IO.Handle.Internals.$wwantWritableHandle'_info:
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_entry;
         const 0;
         const 18446744069414584334;
         const 21474836504;
         const uacxb_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.561878908 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle1_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle1_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle1_entry() //  [R2, R3,
                                                          R4]
         { []
         }
     {offset
       caczD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caczE; else goto caczF;
       caczE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantWritableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caczF: // global
           I64[Sp - 24] = block_caczw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaczM; else goto caczx;
       uaczM: // global
           call _caczw(R1) args: 0, res: 0, upd: 0;
       caczx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantWritableHandle1_info" {
     GHC.IO.Handle.Internals.wantWritableHandle1_info:
         const GHC.IO.Handle.Internals.wantWritableHandle1_entry;
         const 0;
         const 12884901902;
         const 17179869207;
         const Sa8nI_srt+592;
 },
 _caczw() //  [R1]
         { []
         }
     {offset
       caczw: // global
           _sa8l7::P64 = P64[Sp + 8];
           _sa8l9::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto caczA; else goto caczB;
       caczA: // global
           R5 = _sa8l9::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = _sa8l7::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       caczB: // global
           R5 = _sa8l9::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = _sa8l7::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caczw_info" {
     block_caczw_info:
         const _caczw;
         const 2;
         const 4294967326;
         const Sa8nI_srt+592;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.567780514 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cacA2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantWritableHandle_info" {
     GHC.IO.Handle.Internals.wantWritableHandle_info:
         const GHC.IO.Handle.Internals.wantWritableHandle_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Sa8nI_srt+600;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.574588291 UTC

[section ""data" . withHandle2_ra7PH_closure" {
     withHandle2_ra7PH_closure:
         const withHandle2_ra7PH_info;
         const 0;
 },
 io_sa8lr_entry() //  [R1]
         { []
         }
     {offset
       cacAu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacAy; else goto cacAz;
       cacAy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacAz: // global
           I64[Sp - 16] = block_cacAp_info;
           _sa8ln::P64 = P64[R1 + 31];
           R5 = _sa8ln::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8ln::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8lr_info" {
     io_sa8lr_info:
         const io_sa8lr_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacAp() //  [R1]
         { []
         }
     {offset
       cacAp: // global
           I64[Sp] = block_cacAr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacAE; else goto cacAs;
       uacAE: // global
           call _cacAr(R1) args: 0, res: 0, upd: 0;
       cacAs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacAp_info" {
     block_cacAp_info:
         const _cacAp;
         const 1;
         const 30;
 },
 _cacAr() //  [R1]
         { []
         }
     {offset
       cacAr: // global
           I64[Sp] = block_cacAx_info;
           R2 = P64[R1 + 7];
           _sa8ly::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8ly::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacAr_info" {
     block_cacAr_info:
         const _cacAr;
         const 1;
         const 30;
 },
 _cacAx() //  []
         { []
         }
     {offset
       cacAx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacAx_info" {
     block_cacAx_info:
         const _cacAx;
         const 1;
         const 30;
 },
 io_sa8lH_entry() //  [R1]
         { []
         }
     {offset
       cacAT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cacAX; else goto cacAY;
       cacAX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacAY: // global
           I64[Sp - 16] = block_cacAO_info;
           _sa8lC::P64 = P64[R1 + 31];
           R5 = _sa8lC::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sa8lC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8lH_info" {
     io_sa8lH_info:
         const io_sa8lH_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacAO() //  [R1]
         { []
         }
     {offset
       cacAO: // global
           I64[Sp] = block_cacAQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacB3; else goto cacAR;
       uacB3: // global
           call _cacAQ(R1) args: 0, res: 0, upd: 0;
       cacAR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacAO_info" {
     block_cacAO_info:
         const _cacAO;
         const 1;
         const 30;
 },
 _cacAQ() //  [R1]
         { []
         }
     {offset
       cacAQ: // global
           I64[Sp] = block_cacAW_info;
           R2 = P64[R1 + 7];
           _sa8lO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8lO::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacAQ_info" {
     block_cacAQ_info:
         const _cacAQ;
         const 1;
         const 30;
 },
 _cacAW() //  []
         { []
         }
     {offset
       cacAW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacAW_info" {
     block_cacAW_info:
         const _cacAW;
         const 1;
         const 30;
 },
 withHandle2_ra7PH_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cacB8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacB9; else goto cacBa;
       cacB9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle2_ra7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacBa: // global
           I64[Sp - 24] = block_cacAd_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacBr; else goto cacAe;
       uacBr: // global
           call _cacAd(R1) args: 0, res: 0, upd: 0;
       cacAe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . withHandle2_ra7PH_info" {
     withHandle2_ra7PH_info:
         const withHandle2_ra7PH_entry;
         const 0;
         const 4503603922337806;
         const 17179869207;
         const Sa8nI_srt+448;
 },
 _cacAd() //  [R1]
         { []
         }
     {offset
       cacAd: // global
           if (R1 & 7 == 1) goto cacB5; else goto cacB6;
       cacB5: // global
           I64[Sp - 16] = block_cacAi_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacB6: // global
           I64[Sp - 16] = block_cacAH_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacAd_info" {
     block_cacAd_info:
         const _cacAd;
         const 2;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cacAi() //  [R1]
         { []
         }
     {offset
       cacAi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacBe; else goto cacBd;
       cacBe: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacBd: // global
           I64[Hp - 32] = io_sa8lr_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacAk::P64 = Hp - 31;
           if (R1 == 0) goto cacBi; else goto cacBh;
       cacBi: // global
           R1 = _cacAk::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacBh: // global
           R1 = _cacAk::P64;
           Sp = Sp + 40;
           call io_sa8lr_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacAi_info" {
     block_cacAi_info:
         const _cacAi;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 },
 _cacAH() //  [R1]
         { []
         }
     {offset
       cacAH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacBm; else goto cacBl;
       cacBm: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacBl: // global
           I64[Hp - 32] = io_sa8lH_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacAJ::P64 = Hp - 31;
           if (R1 == 0) goto cacBq; else goto cacBp;
       cacBq: // global
           R1 = _cacAJ::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacBp: // global
           R1 = _cacAJ::P64;
           Sp = Sp + 40;
           call io_sa8lH_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacAH_info" {
     block_cacAH_info:
         const _cacAH;
         const 4;
         const 4294967326;
         const Sa8nI_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.596360589 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_closure" {
     GHC.IO.Handle.Internals.withHandle_closure:
         const GHC.IO.Handle.Internals.withHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cacCr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle2_ra7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle_info" {
     GHC.IO.Handle.Internals.withHandle_info:
         const GHC.IO.Handle.Internals.withHandle_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Sa8nI_srt+608;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.60443212 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle1_info;
         const 0;
 },
 sat_sa8m3_entry() //  [R1, R2]
         { []
         }
     {offset
       cacCT: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8m3_info" {
     sat_sa8m3_info:
         const sat_sa8m3_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const Sa8nI_srt+520;
 },
 io_sa8m1_entry() //  [R1]
         { []
         }
     {offset
       cacD1: // global
           _sa8m1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacD5; else goto cacD6;
       cacD6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacD8; else goto cacD7;
       cacD8: // global
           HpAlloc = 16;
           goto cacD5;
       cacD5: // global
           R1 = _sa8m1::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacD7: // global
           _sa8lR::P64 = P64[_sa8m1::P64 + 7];
           _sa8lT::P64 = P64[_sa8m1::P64 + 15];
           _sa8lV::P64 = P64[_sa8m1::P64 + 23];
           _sa8lX::P64 = P64[_sa8m1::P64 + 31];
           I64[Hp - 8] = sat_sa8m3_info;
           P64[Hp] = _sa8lT::P64;
           I64[Sp - 16] = block_cacCW_info;
           R5 = _sa8lX::P64;
           R4 = Hp - 6;
           R3 = _sa8lV::P64;
           R2 = _sa8lR::P64;
           P64[Sp - 8] = _sa8lX::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8m1_info" {
     io_sa8m1_info:
         const io_sa8m1_entry;
         const 4;
         const 2203318222856;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacCW() //  [R1]
         { []
         }
     {offset
       cacCW: // global
           I64[Sp] = block_cacCY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacDd; else goto cacCZ;
       uacDd: // global
           call _cacCY(R1) args: 0, res: 0, upd: 0;
       cacCZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacCW_info" {
     block_cacCW_info:
         const _cacCW;
         const 1;
         const 30;
 },
 _cacCY() //  [R1]
         { []
         }
     {offset
       cacCY: // global
           I64[Sp] = block_cacD4_info;
           R2 = P64[R1 + 7];
           _sa8m9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8m9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacCY_info" {
     block_cacCY_info:
         const _cacCY;
         const 1;
         const 30;
 },
 _cacD4() //  []
         { []
         }
     {offset
       cacD4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacD4_info" {
     block_cacD4_info:
         const _cacD4;
         const 1;
         const 30;
 },
 sat_sa8mk_entry() //  [R1, R2]
         { []
         }
     {offset
       cacDs: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sa8mk_info" {
     sat_sa8mk_info:
         const sat_sa8mk_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const Sa8nI_srt+520;
 },
 io_sa8mi_entry() //  [R1]
         { []
         }
     {offset
       cacDA: // global
           _sa8mi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cacDE; else goto cacDF;
       cacDF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cacDH; else goto cacDG;
       cacDH: // global
           HpAlloc = 16;
           goto cacDE;
       cacDE: // global
           R1 = _sa8mi::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cacDG: // global
           _sa8lR::P64 = P64[_sa8mi::P64 + 7];
           _sa8lT::P64 = P64[_sa8mi::P64 + 15];
           _sa8lV::P64 = P64[_sa8mi::P64 + 23];
           _sa8md::P64 = P64[_sa8mi::P64 + 31];
           I64[Hp - 8] = sat_sa8mk_info;
           P64[Hp] = _sa8lT::P64;
           I64[Sp - 16] = block_cacDv_info;
           R5 = _sa8md::P64;
           R4 = Hp - 6;
           R3 = _sa8lV::P64;
           R2 = _sa8lR::P64;
           P64[Sp - 8] = _sa8md::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sa8mi_info" {
     io_sa8mi_info:
         const io_sa8mi_entry;
         const 4;
         const 2203318222856;
         const 4294967299;
         const Sa8nI_srt+448;
 },
 _cacDv() //  [R1]
         { []
         }
     {offset
       cacDv: // global
           I64[Sp] = block_cacDx_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uacDM; else goto cacDy;
       uacDM: // global
           call _cacDx(R1) args: 0, res: 0, upd: 0;
       cacDy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacDv_info" {
     block_cacDv_info:
         const _cacDv;
         const 1;
         const 30;
 },
 _cacDx() //  [R1]
         { []
         }
     {offset
       cacDx: // global
           I64[Sp] = block_cacDD_info;
           R2 = P64[R1 + 7];
           _sa8mq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sa8mq::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacDx_info" {
     block_cacDx_info:
         const _cacDx;
         const 1;
         const 30;
 },
 _cacDD() //  []
         { []
         }
     {offset
       cacDD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacDD_info" {
     block_cacDD_info:
         const _cacDD;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.wantReadableHandle1_entry() //  [R2, R3,
                                                          R4]
         { []
         }
     {offset
       cacDR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacDS; else goto cacDT;
       cacDS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cacDT: // global
           I64[Sp - 24] = block_cacCC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacEa; else goto cacCD;
       uacEa: // global
           call _cacCC(R1) args: 0, res: 0, upd: 0;
       cacCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle1_info" {
     GHC.IO.Handle.Internals.wantReadableHandle1_info:
         const GHC.IO.Handle.Internals.wantReadableHandle1_entry;
         const 0;
         const 9009402572963854;
         const 17179869207;
         const Sa8nI_srt+448;
 },
 _cacCC() //  [R1]
         { []
         }
     {offset
       cacCC: // global
           if (R1 & 7 == 1) goto cacDO; else goto cacDP;
       cacDO: // global
           I64[Sp - 16] = block_cacCH_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cacDP: // global
           I64[Sp - 16] = block_cacDg_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cacCC_info" {
     block_cacCC_info:
         const _cacCC;
         const 2;
         const 2203318222878;
         const Sa8nI_srt+448;
 },
 _cacCH() //  [R1]
         { []
         }
     {offset
       cacCH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacDX; else goto cacDW;
       cacDX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacDW: // global
           I64[Hp - 32] = io_sa8m1_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacCJ::P64 = Hp - 31;
           if (R1 == 0) goto cacE1; else goto cacE0;
       cacE1: // global
           R1 = _cacCJ::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacE0: // global
           R1 = _cacCJ::P64;
           Sp = Sp + 40;
           call io_sa8m1_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacCH_info" {
     block_cacCH_info:
         const _cacCH;
         const 4;
         const 2203318222878;
         const Sa8nI_srt+448;
 },
 _cacDg() //  [R1]
         { []
         }
     {offset
       cacDg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cacE5; else goto cacE4;
       cacE5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cacE4: // global
           I64[Hp - 32] = io_sa8mi_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cacDi::P64 = Hp - 31;
           if (R1 == 0) goto cacE9; else goto cacE8;
       cacE9: // global
           R1 = _cacDi::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cacE8: // global
           R1 = _cacDi::P64;
           Sp = Sp + 40;
           call io_sa8mi_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cacDg_info" {
     block_cacDg_info:
         const _cacDg;
         const 4;
         const 2203318222878;
         const Sa8nI_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.628708872 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cacFg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle_info" {
     GHC.IO.Handle.Internals.wantReadableHandle_info:
         const GHC.IO.Handle.Internals.wantReadableHandle_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Sa8nI_srt+616;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:08.633022557 UTC

[section ""relreadonly" . Sa8nI_srt" {
     Sa8nI_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle12_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const ioe_closedHandle2_ra7Pb_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle8_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const ioe_semiclosedHandle2_ra7Pc_closure;
         const GHC.IO.Handle.Internals.hLookAhead_3_closure;
         const ioe_EOF2_ra7Pd_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle4_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle3_closure;
         const ioe_notReadable2_ra7Pe_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle3_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle2_closure;
         const ioe_notWritable2_ra7Pf_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle4_closure;
         const GHC.IO.Handle.Internals.flushBuffer4_closure;
         const lvl1_ra7Ph_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const lvl6_ra7Pm_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf1_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.Err.error_closure;
         const lvl19_ra7Pz_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer1_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer3_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
         const lvl22_ra7PC_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.noCharBuffer_closure;
         const GHC.IO.Handle.Internals.noByteBuffer_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkFileHandle1_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const $wlvl_ra7PF_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.Internals.withHandle_1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.Internals.withHandle__'1_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.withHandle1_closure;
         const GHC.IO.Handle.Internals.withHandle_'1_closure;
         const withHandle_2_ra7PG_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const withHandle2_ra7PH_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.228711543 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:05:15.232544925 UTC

[section ""data" . GHC.IO.Handle.Internals.augmentIOError_closure" {
     GHC.IO.Handle.Internals.augmentIOError_closure:
         const GHC.IO.Handle.Internals.augmentIOError_info;
 },
 sat_sacFH_entry() //  [R1]
         { []
         }
     {offset
       cadcs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cadct; else goto cadcu;
       cadct: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadcu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cadcl_info;
           _sacFq::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sacFq::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uadcV; else goto cadcm;
       uadcV: // global
           call _cadcl(R1) args: 0, res: 0, upd: 0;
       cadcm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacFH_info" {
     sat_sacFH_info:
         const sat_sacFH_entry;
         const 2;
         const 18;
 },
 _cadcl() //  [R1]
         { []
         }
     {offset
       cadcl: // global
           if (R1 & 7 == 1) goto cadcp; else goto cadcq;
       cadcp: // global
           _sacFq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadcx_info;
           R1 = _sacFq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uadcU; else goto cadcz;
       uadcU: // global
           call _cadcx(R1) args: 0, res: 0, upd: 0;
       cadcz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cadcq: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadcl_info" {
     block_cadcl_info:
         const _cadcl;
         const 1;
         const 30;
 },
 _cadcx() //  [R1]
         { []
         }
     {offset
       cadcx: // global
           if (R1 & 7 == 1) goto cadcF; else goto cadcM;
       cadcF: // global
           Hp = Hp + 16;
           _sacFA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cadcP; else goto cadcH;
       cadcH: // global
           _sacFB::P64 = P64[_sacFA::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sacFB::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cadcM: // global
           Hp = Hp + 16;
           _sacFA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cadcP; else goto cadcO;
       cadcP: // global
           HpAlloc = 16;
           R1 = _sacFA::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadcO: // global
           _sacFD::P64 = P64[_sacFA::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sacFD::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadcx_info" {
     block_cadcx_info:
         const _cadcx;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.augmentIOError_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cadcW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadcZ; else goto cadd0;
       cadcZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.augmentIOError_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cadd0: // global
           I64[Sp - 24] = block_cadcc_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadd4; else goto cadcd;
       uadd4: // global
           call _cadcc(R1) args: 0, res: 0, upd: 0;
       cadcd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.augmentIOError_info" {
     GHC.IO.Handle.Internals.augmentIOError_info:
         const GHC.IO.Handle.Internals.augmentIOError_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cadcc() //  [R1]
         { []
         }
     {offset
       cadcc: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cadd3; else goto cadd2;
       cadd3: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadd2: // global
           _sacFt::P64 = P64[R1 + 15];
           _sacFv::P64 = P64[R1 + 31];
           _sacFw::P64 = P64[R1 + 39];
           _sacFx::P64 = P64[R1 + 47];
           I64[Hp - 96] = sat_sacFH_info;
           _sacFq::P64 = P64[Sp + 16];
           P64[Hp - 80] = _sacFq::P64;
           P64[Hp - 72] = _sacFx::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sacFq::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sacFt::P64;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sacFv::P64;
           P64[Hp - 8] = _sacFw::P64;
           P64[Hp] = Hp - 96;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadcc_info" {
     block_cadcc_info:
         const _cadcc;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.243402148 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle14_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle14_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,99,108,111,115,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.245777061 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle13_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle13_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle13_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle13_entry() //  [R1]
         { []
         }
     {offset
       caddS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caddT; else goto caddU;
       caddT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caddU: // global
           (_caddP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caddP::I64 == 0) goto caddR; else goto caddQ;
       caddR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caddQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caddP::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle14_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle13_info" {
     GHC.IO.Handle.Internals.wantReadableHandle13_info:
         const GHC.IO.Handle.Internals.wantReadableHandle13_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.249466516 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle12_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle12_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle13_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.251716225 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle11_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle11_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle11_entry() //  [R1]
         { []
         }
     {offset
       cadea: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadeb; else goto cadec;
       cadeb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadec: // global
           (_cade7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cade7::I64 == 0) goto cade9; else goto cade8;
       cade9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cade8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cade7::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle12_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle11_info" {
     GHC.IO.Handle.Internals.wantReadableHandle11_info:
         const GHC.IO.Handle.Internals.wantReadableHandle11_entry;
         const 0;
         const 12884901909;
         const Saded_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.255468882 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle1_entry() //  []
         { []
         }
     {offset
       cadeq: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_closedHandle1_info" {
     GHC.IO.Handle.Internals.ioe_closedHandle1_info:
         const GHC.IO.Handle.Internals.ioe_closedHandle1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.258871241 UTC

[section ""data" . ioe_closedHandle2_ra7Pb_closure" {
     ioe_closedHandle2_ra7Pb_closure:
         const ioe_closedHandle2_ra7Pb_info;
         const 0;
 },
 ioe_closedHandle2_ra7Pb_entry() //  []
         { []
         }
     {offset
       cadeB: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_closedHandle2_ra7Pb_info" {
     ioe_closedHandle2_ra7Pb_info:
         const ioe_closedHandle2_ra7Pb_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.263293052 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_closedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_closedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_closedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_closedHandle_entry() //  []
         { []
         }
     {offset
       cadeM: // global
           call ioe_closedHandle2_ra7Pb_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_closedHandle_info" {
     GHC.IO.Handle.Internals.ioe_closedHandle_info:
         const GHC.IO.Handle.Internals.ioe_closedHandle_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.266481638 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle10_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle10_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.268694754 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle9_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle9_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle9_entry() //  [R1]
         { []
         }
     {offset
       cadf0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadf1; else goto cadf2;
       cadf1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadf2: // global
           (_cadeX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadeX::I64 == 0) goto cadeZ; else goto cadeY;
       cadeZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadeY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadeX::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle9_info" {
     GHC.IO.Handle.Internals.wantReadableHandle9_info:
         const GHC.IO.Handle.Internals.wantReadableHandle9_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.272422314 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle8_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle9_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.274695457 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle7_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle7_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle7_entry() //  [R1]
         { []
         }
     {offset
       cadfi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadfj; else goto cadfk;
       cadfj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadfk: // global
           (_cadff::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadff::I64 == 0) goto cadfh; else goto cadfg;
       cadfh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadfg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadff::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle7_info" {
     GHC.IO.Handle.Internals.wantReadableHandle7_info:
         const GHC.IO.Handle.Internals.wantReadableHandle7_entry;
         const 0;
         const 73014444053;
         const Saded_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.278923872 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() //  []
         { []
         }
     {offset
       cadfx: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle1_info:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.282298911 UTC

[section ""data" . ioe_semiclosedHandle2_ra7Pc_closure" {
     ioe_semiclosedHandle2_ra7Pc_closure:
         const ioe_semiclosedHandle2_ra7Pc_info;
         const 0;
 },
 ioe_semiclosedHandle2_ra7Pc_entry() //  []
         { []
         }
     {offset
       cadfI: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_semiclosedHandle2_ra7Pc_info" {
     ioe_semiclosedHandle2_ra7Pc_info:
         const ioe_semiclosedHandle2_ra7Pc_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.285574931 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_semiclosedHandle_entry() //  []
         { []
         }
     {offset
       cadfT: // global
           call ioe_semiclosedHandle2_ra7Pc_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_semiclosedHandle_info" {
     GHC.IO.Handle.Internals.ioe_semiclosedHandle_info:
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.288619814 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_4_closure" {
     GHC.IO.Handle.Internals.hLookAhead_4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.EOF_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.291355341 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_3_closure" {
     GHC.IO.Handle.Internals.hLookAhead_3_closure:
         const GHC.IO.Handle.Internals.hLookAhead_3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_3_entry() //  [R1]
         { []
         }
     {offset
       cadg7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadg8; else goto cadg9;
       cadg8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadg9: // global
           (_cadg4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadg4::I64 == 0) goto cadg6; else goto cadg5;
       cadg6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadg5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadg4::I64;
           R2 = GHC.IO.Handle.Internals.hLookAhead_4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hLookAhead_3_info" {
     GHC.IO.Handle.Internals.hLookAhead_3_info:
         const GHC.IO.Handle.Internals.hLookAhead_3_entry;
         const 0;
         const 4294967317;
         const Saded_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.295768007 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF1_closure" {
     GHC.IO.Handle.Internals.ioe_EOF1_closure:
         const GHC.IO.Handle.Internals.ioe_EOF1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF1_entry() //  []
         { []
         }
     {offset
       cadgm: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_EOF1_info" {
     GHC.IO.Handle.Internals.ioe_EOF1_info:
         const GHC.IO.Handle.Internals.ioe_EOF1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.299176533 UTC

[section ""data" . ioe_EOF2_ra7Pd_closure" {
     ioe_EOF2_ra7Pd_closure:
         const ioe_EOF2_ra7Pd_info;
         const 0;
 },
 ioe_EOF2_ra7Pd_entry() //  []
         { []
         }
     {offset
       cadgx: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_EOF2_ra7Pd_info" {
     ioe_EOF2_ra7Pd_info:
         const ioe_EOF2_ra7Pd_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.302818212 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_EOF_closure" {
     GHC.IO.Handle.Internals.ioe_EOF_closure:
         const GHC.IO.Handle.Internals.ioe_EOF_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_EOF_entry() //  []
         { []
         }
     {offset
       cadgI: // global
           call ioe_EOF2_ra7Pd_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_EOF_info" {
     GHC.IO.Handle.Internals.ioe_EOF_info:
         const GHC.IO.Handle.Internals.ioe_EOF_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.30582507 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantReadableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantReadableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,114,101,97,100,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.308001687 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle5_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle5_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle5_entry() //  [R1]
         { []
         }
     {offset
       cadgW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadgX; else goto cadgY;
       cadgX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadgY: // global
           (_cadgT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadgT::I64 == 0) goto cadgV; else goto cadgU;
       cadgV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadgU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadgT::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle5_info" {
     GHC.IO.Handle.Internals.wantReadableHandle5_info:
         const GHC.IO.Handle.Internals.wantReadableHandle5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.312124556 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle4_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantReadableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.31450289 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle3_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle3_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle3_entry() //  [R1]
         { []
         }
     {offset
       cadhe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadhf; else goto cadhg;
       cadhf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadhg: // global
           (_cadhb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadhb::I64 == 0) goto cadhd; else goto cadhc;
       cadhd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadhc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadhb::I64;
           R2 = GHC.IO.Handle.Internals.wantReadableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle3_info" {
     GHC.IO.Handle.Internals.wantReadableHandle3_info:
         const GHC.IO.Handle.Internals.wantReadableHandle3_entry;
         const 0;
         const 2203318222869;
         const Saded_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.318435439 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable1_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable1_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable1_entry() //  []
         { []
         }
     {offset
       cadht: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_notReadable1_info" {
     GHC.IO.Handle.Internals.ioe_notReadable1_info:
         const GHC.IO.Handle.Internals.ioe_notReadable1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.321772554 UTC

[section ""data" . ioe_notReadable2_ra7Pe_closure" {
     ioe_notReadable2_ra7Pe_closure:
         const ioe_notReadable2_ra7Pe_info;
         const 0;
 },
 ioe_notReadable2_ra7Pe_entry() //  []
         { []
         }
     {offset
       cadhE: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_notReadable2_ra7Pe_info" {
     ioe_notReadable2_ra7Pe_info:
         const ioe_notReadable2_ra7Pe_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.32556582 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notReadable_closure" {
     GHC.IO.Handle.Internals.ioe_notReadable_closure:
         const GHC.IO.Handle.Internals.ioe_notReadable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notReadable_entry() //  []
         { []
         }
     {offset
       cadhP: // global
           call ioe_notReadable2_ra7Pe_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_notReadable_info" {
     GHC.IO.Handle.Internals.ioe_notReadable_info:
         const GHC.IO.Handle.Internals.ioe_notReadable_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.328652025 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantWritableHandle5_bytes" {
     GHC.IO.Handle.Internals.wantWritableHandle5_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,111,112,101,110,32,102,111,114,32,119,114,105,116,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.331273786 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle4_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle4_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle4_entry() //  [R1]
         { []
         }
     {offset
       cadi3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadi4; else goto cadi5;
       cadi4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadi5: // global
           (_cadi0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadi0::I64 == 0) goto cadi2; else goto cadi1;
       cadi2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadi1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadi0::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantWritableHandle4_info" {
     GHC.IO.Handle.Internals.wantWritableHandle4_info:
         const GHC.IO.Handle.Internals.wantWritableHandle4_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.334974604 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle3_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantWritableHandle4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.337402578 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle2_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle2_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle2_entry() //  [R1]
         { []
         }
     {offset
       cadil: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadim; else goto cadin;
       cadim: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadin: // global
           (_cadii::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadii::I64 == 0) goto cadik; else goto cadij;
       cadik: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadij: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadii::I64;
           R2 = GHC.IO.Handle.Internals.wantWritableHandle3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantWritableHandle2_info" {
     GHC.IO.Handle.Internals.wantWritableHandle2_info:
         const GHC.IO.Handle.Internals.wantWritableHandle2_entry;
         const 0;
         const 17596481011733;
         const Saded_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.341235738 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable1_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable1_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable1_entry() //  []
         { []
         }
     {offset
       cadiA: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_notWritable1_info" {
     GHC.IO.Handle.Internals.ioe_notWritable1_info:
         const GHC.IO.Handle.Internals.ioe_notWritable1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.345700761 UTC

[section ""data" . ioe_notWritable2_ra7Pf_closure" {
     ioe_notWritable2_ra7Pf_closure:
         const ioe_notWritable2_ra7Pf_info;
         const 0;
 },
 ioe_notWritable2_ra7Pf_entry() //  []
         { []
         }
     {offset
       cadiL: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ioe_notWritable2_ra7Pf_info" {
     ioe_notWritable2_ra7Pf_info:
         const ioe_notWritable2_ra7Pf_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.348933378 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_notWritable_closure" {
     GHC.IO.Handle.Internals.ioe_notWritable_closure:
         const GHC.IO.Handle.Internals.ioe_notWritable_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_notWritable_entry() //  []
         { []
         }
     {offset
       cadiW: // global
           call ioe_notWritable2_ra7Pf_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_notWritable_info" {
     GHC.IO.Handle.Internals.ioe_notWritable_info:
         const GHC.IO.Handle.Internals.ioe_notWritable_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const Saded_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.351982475 UTC

[section ""cstring" . GHC.IO.Handle.Internals.wantSeekableHandle6_bytes" {
     GHC.IO.Handle.Internals.wantSeekableHandle6_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.35434789 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle5_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle5_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle5_entry() //  [R1]
         { []
         }
     {offset
       cadja: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadjb; else goto cadjc;
       cadjb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadjc: // global
           (_cadj7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadj7::I64 == 0) goto cadj9; else goto cadj8;
       cadj9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadj8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadj7::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle5_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle5_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.358704407 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle4_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.361053795 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle3_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle3_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle3_entry() //  [R1]
         { []
         }
     {offset
       cadjs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadjt; else goto cadju;
       cadjt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadju: // global
           (_cadjp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadjp::I64 == 0) goto cadjr; else goto cadjq;
       cadjr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadjq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadjp::I64;
           R2 = GHC.IO.Handle.Internals.wantSeekableHandle4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle3_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle3_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle3_entry;
         const 0;
         const 140741783322645;
         const Saded_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.364741885 UTC

[section ""cstring" . GHC.IO.Handle.Internals.flushBuffer6_bytes" {
     GHC.IO.Handle.Internals.flushBuffer6_bytes:
         I8[] [99,97,110,110,111,116,32,102,108,117,115,104,32,116,104,101,32,114,101,97,100,32,98,117,102,102,101,114,58,32,117,110,100,101,114,108,121,105,110,103,32,100,101,118,105,99,101,32,105,115,32,110,111,116,32,115,101,101,107,97,98,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.367047254 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer5_closure" {
     GHC.IO.Handle.Internals.flushBuffer5_closure:
         const GHC.IO.Handle.Internals.flushBuffer5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer5_entry() //  [R1]
         { []
         }
     {offset
       cadjK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadjL; else goto cadjM;
       cadjL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadjM: // global
           (_cadjH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadjH::I64 == 0) goto cadjJ; else goto cadjI;
       cadjJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadjI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadjH::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer5_info" {
     GHC.IO.Handle.Internals.flushBuffer5_info:
         const GHC.IO.Handle.Internals.flushBuffer5_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.371326975 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer4_closure" {
     GHC.IO.Handle.Internals.flushBuffer4_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.IllegalOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.IO.Handle.Internals.flushBuffer5_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.373730534 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer3_closure" {
     GHC.IO.Handle.Internals.flushBuffer3_closure:
         const GHC.IO.Handle.Internals.flushBuffer3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer3_entry() //  [R1]
         { []
         }
     {offset
       cadk2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadk3; else goto cadk4;
       cadk3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadk4: // global
           (_cadjZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadjZ::I64 == 0) goto cadk1; else goto cadk0;
       cadk1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadk0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadjZ::I64;
           R2 = GHC.IO.Handle.Internals.flushBuffer4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer3_info" {
     GHC.IO.Handle.Internals.flushBuffer3_info:
         const GHC.IO.Handle.Internals.flushBuffer3_entry;
         const 0;
         const 281479271677973;
         const Saded_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.377650887 UTC

[section ""cstring" . lvl_ra7Pg_bytes" {
     lvl_ra7Pg_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.379843452 UTC

[section ""data" . lvl1_ra7Ph_closure" {
     lvl1_ra7Ph_closure:
         const lvl1_ra7Ph_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra7Ph_entry() //  [R1]
         { []
         }
     {offset
       cadkk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadkl; else goto cadkm;
       cadkl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadkm: // global
           (_cadkh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadkh::I64 == 0) goto cadkj; else goto cadki;
       cadkj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadki: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadkh::I64;
           R2 = lvl_ra7Pg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_ra7Ph_info" {
     lvl1_ra7Ph_info:
         const lvl1_ra7Ph_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.383311907 UTC

[section ""cstring" . lvl2_ra7Pi_bytes" {
     lvl2_ra7Pi_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.38723839 UTC

[section ""data" . GHC.IO.Handle.Internals.$wioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.$wioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.$wioe_bufsiz_info;
         const 0;
 },
 sat_sacFX_entry() //  [R1]
         { []
         }
     {offset
       cadkP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadkQ; else goto cadkR;
       cadkQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadkR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadkM_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacFX_info" {
     sat_sacFX_info:
         const sat_sacFX_entry;
         const 4294967296;
         const 17;
 },
 _cadkM() //  [R1, R2]
         { []
         }
     {offset
       cadkM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadkU; else goto cadkT;
       cadkU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cadkT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadkM_info" {
     block_cadkM_info:
         const _cadkM;
         const 0;
         const 30;
 },
 sat_sacFY_entry() //  [R1]
         { []
         }
     {offset
       cadkV: // global
           _sacFY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cadkW; else goto cadkX;
       cadkX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadkZ; else goto cadkY;
       cadkZ: // global
           HpAlloc = 24;
           goto cadkW;
       cadkW: // global
           R1 = _sacFY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadkY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sacFY::P64;
           _sacFS::I64 = I64[_sacFY::P64 + 16];
           I64[Hp - 16] = sat_sacFX_info;
           I64[Hp] = _sacFS::I64;
           R3 = Hp - 16;
           R2 = lvl2_ra7Pi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacFY_info" {
     sat_sacFY_info:
         const sat_sacFY_entry;
         const 4294967296;
         const 17;
 },
 sat_sacG0_entry() //  [R1]
         { []
         }
     {offset
       cadl1: // global
           _sacG0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cadl2; else goto cadl3;
       cadl3: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadl5; else goto cadl4;
       cadl5: // global
           HpAlloc = 80;
           goto cadl2;
       cadl2: // global
           R1 = _sacG0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadl4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sacG0::P64;
           _sacFS::I64 = I64[_sacG0::P64 + 16];
           I64[Hp - 72] = sat_sacFY_info;
           I64[Hp - 56] = _sacFS::I64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = lvl1_ra7Ph_closure;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacG0_info" {
     sat_sacG0_info:
         const sat_sacG0_entry;
         const 4294967296;
         const 562954248388625;
         const Saded_srt;
 },
 GHC.IO.Handle.Internals.$wioe_bufsiz_entry() //  [R2]
         { []
         }
     {offset
       cadl6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadla; else goto cadl9;
       cadla: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadl9: // global
           I64[Hp - 16] = sat_sacG0_info;
           I64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wioe_bufsiz_info" {
     GHC.IO.Handle.Internals.$wioe_bufsiz_info:
         const GHC.IO.Handle.Internals.$wioe_bufsiz_entry;
         const 0;
         const 1688854155231246;
         const 8589934596;
         const Saded_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.399848465 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz1_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz1_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz1_entry() //  [R2]
         { []
         }
     {offset
       cadlW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cadlX; else goto cadlY;
       cadlX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadlY: // global
           I64[Sp - 8] = block_cadlT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadm2; else goto cadlU;
       uadm2: // global
           call _cadlT(R1) args: 0, res: 0, upd: 0;
       cadlU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_bufsiz1_info" {
     GHC.IO.Handle.Internals.ioe_bufsiz1_info:
         const GHC.IO.Handle.Internals.ioe_bufsiz1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Saded_srt+144;
 },
 _cadlT() //  [R1]
         { []
         }
     {offset
       cadlT: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadlT_info" {
     block_cadlT_info:
         const _cadlT;
         const 0;
         const 4294967326;
         const Saded_srt+144;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.404858923 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_bufsiz_closure" {
     GHC.IO.Handle.Internals.ioe_bufsiz_closure:
         const GHC.IO.Handle.Internals.ioe_bufsiz_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_bufsiz_entry() //  [R2]
         { []
         }
     {offset
       cadmh: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.ioe_bufsiz1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_bufsiz_info" {
     GHC.IO.Handle.Internals.ioe_bufsiz_info:
         const GHC.IO.Handle.Internals.ioe_bufsiz_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Saded_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.411350808 UTC

[section ""data" . GHC.IO.Handle.Internals.$wstreamEncode_closure" {
     GHC.IO.Handle.Internals.$wstreamEncode_closure:
         const GHC.IO.Handle.Internals.$wstreamEncode_info;
 },
 GHC.IO.Handle.Internals.$wstreamEncode_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cadmu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cadmv; else goto cadmw;
       cadmv: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wstreamEncode_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cadmw: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _cadmy() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wstreamEncode_info" {
     GHC.IO.Handle.Internals.$wstreamEncode_info:
         const GHC.IO.Handle.Internals.$wstreamEncode_entry;
         const 0;
         const 14;
         const 21474836504;
 },
 _cadmy() //  []
         { []
         }
     {offset
       cadmy: // global
           I64[Sp - 8] = block_cadmA_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadmA() //  [R1]
         { []
         }
     {offset
       cadmA: // global
           I64[Sp] = block_cadmC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadny; else goto cadmF;
       uadny: // global
           call _cadmC(R1) args: 0, res: 0, upd: 0;
       cadmF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadmA_info" {
     block_cadmA_info:
         const _cadmA;
         const 516;
         const 30;
 },
 _cadmC() //  [R1]
         { []
         }
     {offset
       cadmC: // global
           I64[Sp - 8] = block_cadmJ_info;
           _sacGj::P64 = P64[R1 + 15];
           _sacGk::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp] = _sacGk::P64;
           P64[Sp + 32] = _sacGj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadnz; else goto cadmL;
       uadnz: // global
           call _cadmJ(R1) args: 0, res: 0, upd: 0;
       cadmL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadmC_info" {
     block_cadmC_info:
         const _cadmC;
         const 516;
         const 30;
 },
 _cadmJ() //  [R1]
         { []
         }
     {offset
       cadmJ: // global
           if (R1 & 7 == 3) goto cadn4; else goto cadmR;
       cadn4: // global
           I64[Sp] = block_cadmX_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto uadnA; else goto cadmY;
       uadnA: // global
           call _cadmX(R1) args: 0, res: 0, upd: 0;
       cadmY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cadmR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadmU; else goto cadmT;
       cadmU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadmT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadmJ_info" {
     block_cadmJ_info:
         const _cadmJ;
         const 5;
         const 30;
 },
 _cadmX() //  [R1]
         { []
         }
     {offset
       cadmX: // global
           I64[Sp] = block_cadn2_info;
           _sacGs::I64 = I64[R1 + 39];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sacGs::I64;
           if (R1 & 7 != 0) goto uadnB; else goto cadn6;
       uadnB: // global
           call _cadn2(R1) args: 0, res: 0, upd: 0;
       cadn6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadmX_info" {
     block_cadmX_info:
         const _cadmX;
         const 517;
         const 30;
 },
 _cadn2() //  [R1]
         { []
         }
     {offset
       cadn2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadnc; else goto cadnb;
       cadnc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadnb: // global
           _sacGk::P64 = P64[Sp + 8];
           if (I64[Sp + 40] == I64[R1 + 39]) goto cadnn; else goto cadni;
       cadnn: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_cadnk_info;
           R3 = _sacGk::P64;
           R2 = R1;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
       cadni: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sacGk::P64;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadn2_info" {
     block_cadn2_info:
         const _cadn2;
         const 1541;
         const 30;
 },
 _cadnk() //  [R1]
         { []
         }
     {offset
       cadnk: // global
           I64[Sp] = block_cadnm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadnC; else goto cadnp;
       uadnC: // global
           call _cadnm(R1) args: 0, res: 0, upd: 0;
       cadnp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadnk_info" {
     block_cadnk_info:
         const _cadnk;
         const 772;
         const 30;
 },
 _cadnm() //  [R1]
         { []
         }
     {offset
       cadnm: // global
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 8;
           call _cadmy() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadnm_info" {
     block_cadnm_info:
         const _cadnm;
         const 772;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.427443099 UTC

[section ""data" . GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure" {
     GHC.IO.Handle.Internals.dEFAULT_CHAR_BUFFER_SIZE_closure:
         const GHC.Types.I#_con_info;
         const 2048;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.430101534 UTC

[section ""data" . GHC.IO.Handle.Internals.initBufferState_closure" {
     GHC.IO.Handle.Internals.initBufferState_closure:
         const GHC.IO.Handle.Internals.initBufferState_info;
 },
 GHC.IO.Handle.Internals.initBufferState_entry() //  [R2]
         { []
         }
     {offset
       cadoF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cadoG; else goto cadoH;
       cadoG: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.initBufferState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadoH: // global
           I64[Sp - 8] = block_cadoy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadoO; else goto cadoz;
       uadoO: // global
           call _cadoy(R1) args: 0, res: 0, upd: 0;
       cadoz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.initBufferState_info" {
     GHC.IO.Handle.Internals.initBufferState_info:
         const GHC.IO.Handle.Internals.initBufferState_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cadoy() //  [R1]
         { []
         }
     {offset
       cadoy: // global
           if (R1 & 7 == 3) goto cadoD; else goto cadoC;
       cadoD: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cadoC: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadoy_info" {
     block_cadoy_info:
         const _cadoy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.436718749 UTC

[section ""data" . lvl3_ra7Pj_closure" {
     lvl3_ra7Pj_closure:
         const lvl3_ra7Pj_info;
 },
 lvl3_ra7Pj_entry() //  []
         { []
         }
     {offset
       cadpi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadpl; else goto cadpm;
       cadpl: // global
           R1 = lvl3_ra7Pj_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cadpm: // global
           I64[Sp - 8] = block_cadp9_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl3_ra7Pj_info" {
     lvl3_ra7Pj_info:
         const lvl3_ra7Pj_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _cadp9() //  []
         { []
         }
     {offset
       cadp9: // global
           I64[Sp] = block_cadpb_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadp9_info" {
     block_cadp9_info:
         const _cadp9;
         const 0;
         const 30;
 },
 _cadpb() //  [R1]
         { []
         }
     {offset
       cadpb: // global
           I64[Sp - 8] = block_cadpd_info;
           _sacGP::P64 = R1;
           R1 = 4;
           P64[Sp] = _sacGP::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadpb_info" {
     block_cadpb_info:
         const _cadpb;
         const 0;
         const 30;
 },
 _cadpd() //  [R1]
         { []
         }
     {offset
       cadpd: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadpr; else goto cadpq;
       cadpr: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadpq: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadpd_info" {
     block_cadpd_info:
         const _cadpd;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.445820404 UTC

[section ""data" . GHC.IO.Handle.Internals.noCharBuffer_closure" {
     GHC.IO.Handle.Internals.noCharBuffer_closure:
         const GHC.IO.Handle.Internals.noCharBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noCharBuffer_entry() //  [R1]
         { []
         }
     {offset
       cadq0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadq1; else goto cadq2;
       cadq1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadq2: // global
           (_cadpV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadpV::I64 == 0) goto cadpX; else goto cadpW;
       cadpX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadpW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadpV::I64;
           I64[Sp - 24] = block_cadpY_info;
           Sp = Sp - 24;
           call lvl3_ra7Pj_entry() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.noCharBuffer_info" {
     GHC.IO.Handle.Internals.noCharBuffer_info:
         const GHC.IO.Handle.Internals.noCharBuffer_entry;
         const 0;
         const 21;
 },
 _cadpY() //  [R1]
         { []
         }
     {offset
       cadpY: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadpY_info" {
     block_cadpY_info:
         const _cadpY;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.451850184 UTC

[section ""data" . lvl4_ra7Pk_closure" {
     lvl4_ra7Pk_closure:
         const lvl4_ra7Pk_info;
 },
 lvl4_ra7Pk_entry() //  []
         { []
         }
     {offset
       cadqv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadqy; else goto cadqz;
       cadqy: // global
           R1 = lvl4_ra7Pk_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cadqz: // global
           I64[Sp - 8] = block_cadqm_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl4_ra7Pk_info" {
     lvl4_ra7Pk_info:
         const lvl4_ra7Pk_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _cadqm() //  []
         { []
         }
     {offset
       cadqm: // global
           I64[Sp] = block_cadqo_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadqm_info" {
     block_cadqm_info:
         const _cadqm;
         const 0;
         const 30;
 },
 _cadqo() //  [R1]
         { []
         }
     {offset
       cadqo: // global
           I64[Sp - 8] = block_cadqq_info;
           _sacH3::P64 = R1;
           R1 = 1;
           P64[Sp] = _sacH3::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadqo_info" {
     block_cadqo_info:
         const _cadqo;
         const 0;
         const 30;
 },
 _cadqq() //  [R1]
         { []
         }
     {offset
       cadqq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadqE; else goto cadqD;
       cadqE: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadqD: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 1;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadqq_info" {
     block_cadqq_info:
         const _cadqq;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.460795883 UTC

[section ""data" . GHC.IO.Handle.Internals.noByteBuffer_closure" {
     GHC.IO.Handle.Internals.noByteBuffer_closure:
         const GHC.IO.Handle.Internals.noByteBuffer_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.noByteBuffer_entry() //  [R1]
         { []
         }
     {offset
       cadrd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadre; else goto cadrf;
       cadre: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadrf: // global
           (_cadr8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadr8::I64 == 0) goto cadra; else goto cadr9;
       cadra: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadr9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadr8::I64;
           I64[Sp - 24] = block_cadrb_info;
           Sp = Sp - 24;
           call lvl4_ra7Pk_entry() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.noByteBuffer_info" {
     GHC.IO.Handle.Internals.noByteBuffer_info:
         const GHC.IO.Handle.Internals.noByteBuffer_entry;
         const 0;
         const 21;
 },
 _cadrb() //  [R1]
         { []
         }
     {offset
       cadrb: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadrb_info" {
     block_cadrb_info:
         const _cadrb;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.465685943 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule4_bytes" {
     GHC.IO.Handle.Internals.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.467906778 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule3_closure" {
     GHC.IO.Handle.Internals.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.469965109 UTC

[section ""cstring" . GHC.IO.Handle.Internals.$trModule2_bytes" {
     GHC.IO.Handle.Internals.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,73,110,116,101,114,110,97,108,115]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.471645242 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule1_closure" {
     GHC.IO.Handle.Internals.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Internals.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.473348957 UTC

[section ""data" . GHC.IO.Handle.Internals.$trModule_closure" {
     GHC.IO.Handle.Internals.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Internals.$trModule3_closure+1;
         const GHC.IO.Handle.Internals.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.475031112 UTC

[section ""cstring" . lvl5_ra7Pl_bytes" {
     lvl5_ra7Pl_bytes:
         I8[] [104,97,110,100,108,101,32,105,115,32,102,105,110,97,108,105,122,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.477357072 UTC

[section ""data" . lvl6_ra7Pm_closure" {
     lvl6_ra7Pm_closure:
         const lvl6_ra7Pm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra7Pm_entry() //  [R1]
         { []
         }
     {offset
       cadrH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadrI; else goto cadrJ;
       cadrI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadrJ: // global
           (_cadrE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadrE::I64 == 0) goto cadrG; else goto cadrF;
       cadrG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadrF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadrE::I64;
           R2 = lvl5_ra7Pl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl6_ra7Pm_info" {
     lvl6_ra7Pm_info:
         const lvl6_ra7Pm_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.481583733 UTC

[section ""data" . GHC.IO.Handle.Internals.ioe_finalizedHandle_closure" {
     GHC.IO.Handle.Internals.ioe_finalizedHandle_closure:
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.ioe_finalizedHandle_entry() //  [R2]
         { []
         }
     {offset
       cadrY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cads2; else goto cads1;
       cads2: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cads1: // global
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = lvl6_ra7Pm_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.ioe_finalizedHandle_info" {
     GHC.IO.Handle.Internals.ioe_finalizedHandle_info:
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const Saded_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.487991511 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs1_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs1_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs1_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs1_entry() //  [R2]
         { []
         }
     {offset
       cadsq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadsr; else goto cadss;
       cadsr: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.closeTextCodecs1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadss: // global
           I64[Sp - 8] = block_cadsn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadtx; else goto cadso;
       uadtx: // global
           call _cadsn(R1) args: 0, res: 0, upd: 0;
       cadso: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.closeTextCodecs1_info" {
     GHC.IO.Handle.Internals.closeTextCodecs1_info:
         const GHC.IO.Handle.Internals.closeTextCodecs1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cadsn() //  [R1]
         { []
         }
     {offset
       cadsn: // global
           I64[Sp - 8] = block_cadsv_info;
           _sacHt::P64 = P64[R1 + 87];
           R1 = P64[R1 + 95];
           P64[Sp] = _sacHt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadtw; else goto cadsx;
       uadtw: // global
           call _cadsv(R1) args: 0, res: 0, upd: 0;
       cadsx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadsn_info" {
     block_cadsn_info:
         const _cadsn;
         const 0;
         const 30;
 },
 _cadsv() //  [R1]
         { []
         }
     {offset
       cadsv: // global
           if (R1 & 7 == 1) goto cadsE; else goto cadt0;
       cadsE: // global
           _sacHt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadsB_info;
           R1 = _sacHt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uadty; else goto cadsF;
       uadty: // global
           call _cadsB(R1) args: 0, res: 0, upd: 0;
       cadsF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cadt0: // global
           I64[Sp] = block_cadsY_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadtz; else goto cadt1;
       uadtz: // global
           call _cadsY(R1) args: 0, res: 0, upd: 0;
       cadt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadsv_info" {
     block_cadsv_info:
         const _cadsv;
         const 1;
         const 30;
 },
 _cadsB() //  [R1]
         { []
         }
     {offset
       cadsB: // global
           if (R1 & 7 == 1) goto uadtv; else goto cadsQ;
       uadtv: // global
           Sp = Sp + 8;
           call _cadtg() args: 0, res: 0, upd: 0;
       cadsQ: // global
           I64[Sp] = block_cadsO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadtA; else goto cadsR;
       uadtA: // global
           call _cadsO(R1) args: 0, res: 0, upd: 0;
       cadsR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadsB_info" {
     block_cadsB_info:
         const _cadsB;
         const 0;
         const 30;
 },
 _cadsO() //  [R1]
         { []
         }
     {offset
       cadsO: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadsO_info" {
     block_cadsO_info:
         const _cadsO;
         const 0;
         const 30;
 },
 _cadsY() //  [R1]
         { []
         }
     {offset
       cadsY: // global
           I64[Sp] = block_cadt5_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadsY_info" {
     block_cadsY_info:
         const _cadsY;
         const 1;
         const 30;
 },
 _cadt5() //  []
         { []
         }
     {offset
       cadt5: // global
           _sacHt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadt7_info;
           R1 = _sacHt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uadtC; else goto cadta;
       uadtC: // global
           call _cadt7(R1) args: 0, res: 0, upd: 0;
       cadta: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadt5_info" {
     block_cadt5_info:
         const _cadt5;
         const 1;
         const 30;
 },
 _cadt7() //  [R1]
         { []
         }
     {offset
       cadt7: // global
           if (R1 & 7 == 1) goto uadtu; else goto cadtl;
       uadtu: // global
           Sp = Sp + 8;
           call _cadtg() args: 0, res: 0, upd: 0;
       cadtl: // global
           I64[Sp] = block_cadtj_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadtD; else goto cadtm;
       uadtD: // global
           call _cadtj(R1) args: 0, res: 0, upd: 0;
       cadtm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadt7_info" {
     block_cadt7_info:
         const _cadt7;
         const 0;
         const 30;
 },
 _cadtg() //  []
         { []
         }
     {offset
       cadtg: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadtj() //  [R1]
         { []
         }
     {offset
       cadtj: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadtj_info" {
     block_cadtj_info:
         const _cadtj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.505523664 UTC

[section ""data" . GHC.IO.Handle.Internals.closeTextCodecs_closure" {
     GHC.IO.Handle.Internals.closeTextCodecs_closure:
         const GHC.IO.Handle.Internals.closeTextCodecs_info;
 },
 GHC.IO.Handle.Internals.closeTextCodecs_entry() //  [R2]
         { []
         }
     {offset
       caduB: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.closeTextCodecs1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.closeTextCodecs_info" {
     GHC.IO.Handle.Internals.closeTextCodecs_info:
         const GHC.IO.Handle.Internals.closeTextCodecs_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.512612587 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding1_closure" {
     GHC.IO.Handle.Internals.openTextEncoding1_closure:
         const GHC.IO.Handle.Internals.openTextEncoding1_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caduT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caduU; else goto caduV;
       caduU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.openTextEncoding1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caduV: // global
           I64[Sp - 24] = block_caduM_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadwr; else goto caduN;
       uadwr: // global
           call _caduM(R1) args: 0, res: 0, upd: 0;
       caduN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.openTextEncoding1_info" {
     GHC.IO.Handle.Internals.openTextEncoding1_info:
         const GHC.IO.Handle.Internals.openTextEncoding1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _caduM() //  [R1]
         { []
         }
     {offset
       caduM: // global
           if (R1 & 7 == 1) goto caduQ; else goto caduR;
       caduQ: // global
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       caduR: // global
           I64[Sp] = block_cadv1_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadwq; else goto cadv3;
       uadwq: // global
           call _cadv1(R1) args: 0, res: 0, upd: 0;
       cadv3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caduM_info" {
     block_caduM_info:
         const _caduM;
         const 2;
         const 30;
 },
 _cadv1() //  [R1]
         { []
         }
     {offset
       cadv1: // global
           I64[Sp - 16] = block_cadv9_info;
           _sacI8::P64 = P64[R1 + 15];
           _sacI9::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _sacI9::P64;
           P64[Sp] = _sacI8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadws; else goto cadvR;
       uadws: // global
           call _cadv9(R1) args: 0, res: 0, upd: 0;
       cadvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadv1_info" {
     block_cadv1_info:
         const _cadv1;
         const 2;
         const 30;
 },
 _cadv9() //  [R1]
         { []
         }
     {offset
       cadv9: // global
           _sacI8::P64 = P64[Sp + 16];
           _cadwg::P64 = R1 & 7;
           if (_cadwg::P64 != 3) goto uadwk; else goto cadw2;
       uadwk: // global
           if (_cadwg::P64 != 6) goto cadvX; else goto cadwb;
       cadvX: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sacIa() args: 0, res: 0, upd: 0;
       cadwb: // global
           I64[Sp] = block_cadw9_info;
           R1 = _sacI8::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cadw2: // global
           I64[Sp] = block_cadw0_info;
           R1 = _sacI8::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadv9_info" {
     block_cadv9_info:
         const _cadv9;
         const 4;
         const 30;
 },
 _cadw9() //  [R1]
         { []
         }
     {offset
       cadw9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadwf; else goto cadwe;
       cadwf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadwe: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sacIa() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadw9_info" {
     block_cadw9_info:
         const _cadw9;
         const 132;
         const 30;
 },
 _cadw0() //  [R1]
         { []
         }
     {offset
       cadw0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadw6; else goto cadw5;
       cadw6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadw5: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sacIa() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadw0_info" {
     block_cadw0_info:
         const _cadw0;
         const 132;
         const 30;
 },
 _sacIa() //  []
         { []
         }
     {offset
       sacIa: // global
           I64[Sp - 8] = block_cadve_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadww; else goto cadvg;
       uadww: // global
           call _cadve(R1) args: 0, res: 0, upd: 0;
       cadvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadve() //  [R1]
         { []
         }
     {offset
       cadve: // global
           _sacI9::P64 = P64[Sp + 8];
           _cadwj::P64 = R1 & 7;
           if (_cadwj::P64 < 5) goto uadwl; else goto uadwm;
       uadwl: // global
           if (_cadwj::P64 < 4) goto cadvm; else goto cadvt;
       cadvm: // global
           R3 = P64[Sp + 16];
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cadvt: // global
           I64[Sp + 8] = block_cadvp_info;
           R1 = _sacI9::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       uadwm: // global
           if (_cadwj::P64 < 6) goto cadvD; else goto cadvN;
       cadvD: // global
           I64[Sp + 8] = block_cadvz_info;
           R1 = _sacI9::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cadvN: // global
           I64[Sp + 8] = block_cadvJ_info;
           R1 = _sacI9::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadve_info" {
     block_cadve_info:
         const _cadve;
         const 260;
         const 30;
 },
 _cadvp() //  [R1]
         { []
         }
     {offset
       cadvp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadvw; else goto cadvv;
       cadvw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadvv: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadvp_info" {
     block_cadvp_info:
         const _cadvp;
         const 131;
         const 30;
 },
 _cadvz() //  [R1]
         { []
         }
     {offset
       cadvz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadvG; else goto cadvF;
       cadvG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadvF: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadvz_info" {
     block_cadvz_info:
         const _cadvz;
         const 131;
         const 30;
 },
 _cadvJ() //  [R1]
         { []
         }
     {offset
       cadvJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadvQ; else goto cadvP;
       cadvQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadvP: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R3 = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadvJ_info" {
     block_cadvJ_info:
         const _cadvJ;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.533065988 UTC

[section ""data" . GHC.IO.Handle.Internals.openTextEncoding_closure" {
     GHC.IO.Handle.Internals.openTextEncoding_closure:
         const GHC.IO.Handle.Internals.openTextEncoding_info;
 },
 GHC.IO.Handle.Internals.openTextEncoding_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cadxC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.openTextEncoding1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.openTextEncoding_info" {
     GHC.IO.Handle.Internals.openTextEncoding_info:
         const GHC.IO.Handle.Internals.openTextEncoding_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.537877974 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry() //  [R2]
         { []
         }
     {offset
       cadxQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cadxU; else goto cadxV;
       cadxU: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushByteWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadxV: // global
           I64[Sp - 8] = block_cadxN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadyf; else goto cadxO;
       uadyf: // global
           call _cadxN(R1) args: 0, res: 0, upd: 0;
       cadxO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushByteWriteBuffer1_info" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer1_info:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cadxN() //  [R1]
         { []
         }
     {offset
       cadxN: // global
           I64[Sp - 24] = block_cadxT_info;
           _sacID::P64 = P64[R1 + 15];
           _sacIF::P64 = P64[R1 + 31];
           _sacIH::P64 = P64[R1 + 47];
           R1 = P64[_sacIH::P64 + 8];
           P64[Sp - 16] = _sacIF::P64;
           P64[Sp - 8] = _sacIH::P64;
           P64[Sp] = _sacID::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadye; else goto cadxX;
       uadye: // global
           call _cadxT(R1) args: 0, res: 0, upd: 0;
       cadxX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadxN_info" {
     block_cadxN_info:
         const _cadxN;
         const 0;
         const 30;
 },
 _cadxT() //  [R1]
         { []
         }
     {offset
       cadxT: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cadya; else goto cady7;
       cadya: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cady7: // global
           _sacIF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cady5_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sacIF::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadxT_info" {
     block_cadxT_info:
         const _cadxT;
         const 3;
         const 30;
 },
 _cady5() //  [R1]
         { []
         }
     {offset
       cady5: // global
           _sacIH::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacIH::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacIH::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cady5_info" {
     block_cady5_info:
         const _cady5;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.547373601 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushByteWriteBuffer_entry() //  [R2]
         { []
         }
     {offset
       cadyK: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushByteWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushByteWriteBuffer_info" {
     GHC.IO.Handle.Internals.flushByteWriteBuffer_info:
         const GHC.IO.Handle.Internals.flushByteWriteBuffer_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.552663 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer1_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer1_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer1_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer1_entry() //  [R2]
         { []
         }
     {offset
       cadyY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cadz2; else goto cadz3;
       cadz2: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cadz3: // global
           I64[Sp - 8] = block_cadyV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadzI; else goto cadyW;
       uadzI: // global
           call _cadyV(R1) args: 0, res: 0, upd: 0;
       cadyW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushWriteBuffer1_info" {
     GHC.IO.Handle.Internals.flushWriteBuffer1_info:
         const GHC.IO.Handle.Internals.flushWriteBuffer1_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cadyV() //  [R1]
         { []
         }
     {offset
       cadyV: // global
           I64[Sp - 24] = block_cadz1_info;
           _sacJb::P64 = P64[R1 + 15];
           _sacJd::P64 = P64[R1 + 31];
           _sacJf::P64 = P64[R1 + 47];
           R1 = P64[_sacJf::P64 + 8];
           P64[Sp - 16] = _sacJd::P64;
           P64[Sp - 8] = _sacJf::P64;
           P64[Sp] = _sacJb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadzH; else goto cadz5;
       uadzH: // global
           call _cadz1(R1) args: 0, res: 0, upd: 0;
       cadz5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadyV_info" {
     block_cadyV_info:
         const _cadyV;
         const 0;
         const 30;
 },
 _cadz1() //  [R1]
         { []
         }
     {offset
       cadz1: // global
           I64[Sp] = block_cadz9_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uadzJ; else goto cadzb;
       uadzJ: // global
           call _cadz9(R1) args: 0, res: 0, upd: 0;
       cadzb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadz1_info" {
     block_cadz1_info:
         const _cadz1;
         const 3;
         const 30;
 },
 _cadz9() //  [R1]
         { []
         }
     {offset
       cadz9: // global
           if (R1 & 7 == 1) goto uadzF; else goto cadzm;
       uadzF: // global
           Sp = Sp + 32;
           call _cadzA() args: 0, res: 0, upd: 0;
       cadzm: // global
           _sacJD::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cadzk_info;
           R1 = _sacJD::P64;
           if (R1 & 7 != 0) goto uadzK; else goto cadzn;
       uadzK: // global
           call _cadzk(R1) args: 0, res: 0, upd: 0;
       cadzn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadz9_info" {
     block_cadz9_info:
         const _cadz9;
         const 3;
         const 30;
 },
 _cadzk() //  [R1]
         { []
         }
     {offset
       cadzk: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uadzG; else goto cadzx;
       uadzG: // global
           Sp = Sp + 32;
           call _cadzA() args: 0, res: 0, upd: 0;
       cadzx: // global
           _sacJd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadzv_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sacJd::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadzk_info" {
     block_cadzk_info:
         const _cadzk;
         const 3;
         const 30;
 },
 _cadzA() //  []
         { []
         }
     {offset
       cadzA: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cadzv() //  [R1]
         { []
         }
     {offset
       cadzv: // global
           _sacJf::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacJf::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacJf::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadzv_info" {
     block_cadzv_info:
         const _cadzv;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.565631162 UTC

[section ""data" . GHC.IO.Handle.Internals.flushWriteBuffer_closure" {
     GHC.IO.Handle.Internals.flushWriteBuffer_closure:
         const GHC.IO.Handle.Internals.flushWriteBuffer_info;
 },
 GHC.IO.Handle.Internals.flushWriteBuffer_entry() //  [R2]
         { []
         }
     {offset
       cadAw: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushWriteBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushWriteBuffer_info" {
     GHC.IO.Handle.Internals.flushWriteBuffer_info:
         const GHC.IO.Handle.Internals.flushWriteBuffer_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.568632538 UTC

[section ""cstring" . lvl7_ra7Pn_bytes" {
     lvl7_ra7Pn_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.571110382 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf2_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf2_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf2_entry() //  [R1]
         { []
         }
     {offset
       cadAM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadAN; else goto cadAO;
       cadAN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadAO: // global
           (_cadAH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cadAH::I64 == 0) goto cadAJ; else goto cadAI;
       cadAJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cadAI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cadAH::I64;
           I64[Sp - 24] = block_cadAK_info;
           R2 = lvl7_ra7Pn_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.decodeByteBuf2_info" {
     GHC.IO.Handle.Internals.decodeByteBuf2_info:
         const GHC.IO.Handle.Internals.decodeByteBuf2_entry;
         const 0;
         const 4294967317;
         const Saded_srt+184;
 },
 _cadAK() //  [R1]
         { []
         }
     {offset
       cadAK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadAK_info" {
     block_cadAK_info:
         const _cadAK;
         const 0;
         const 4294967326;
         const Saded_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.580320032 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf1_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf1_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf1_entry() //  [R2, R3]
         { []
         }
     {offset
       cadBb: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cadBc; else goto cadBd;
       cadBc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.decodeByteBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cadBd: // global
           I64[Sp - 16] = block_cadB8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadCe; else goto cadB9;
       uadCe: // global
           call _cadB8(R1) args: 0, res: 0, upd: 0;
       cadB9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.decodeByteBuf1_info" {
     GHC.IO.Handle.Internals.decodeByteBuf1_info:
         const GHC.IO.Handle.Internals.decodeByteBuf1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const Saded_srt+192;
 },
 _cadB8() //  [R1]
         { []
         }
     {offset
       cadB8: // global
           I64[Sp - 24] = block_cadBg_info;
           _sacK0::P64 = P64[R1 + 47];
           _sacK2::P64 = P64[R1 + 63];
           R1 = P64[R1 + 95];
           P64[Sp - 16] = _sacK2::P64;
           P64[Sp - 8] = P64[_sacK0::P64 + 8];
           P64[Sp] = _sacK0::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadCd; else goto cadBi;
       uadCd: // global
           call _cadBg(R1) args: 0, res: 0, upd: 0;
       cadBi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadB8_info" {
     block_cadB8_info:
         const _cadB8;
         const 1;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadBg() //  [R1]
         { []
         }
     {offset
       cadBg: // global
           if (R1 & 7 == 1) goto cadBu; else goto cadBV;
       cadBu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadBx; else goto cadBw;
       cadBx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadBw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sacKd::P64 = P64[Sp + 16];
           P64[Hp] = _sacKd::P64;
           _sacJS::P64 = P64[Sp + 32];
           _sacK2::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacK2::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacK2::P64);
           I64[Sp + 16] = block_cadBq_info;
           R3 = _sacJS::P64;
           R2 = _sacKd::P64;
           Sp = Sp + 16;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cadBV: // global
           I64[Sp] = block_cadBG_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadCf; else goto cadBH;
       uadCf: // global
           call _cadBG(R1) args: 0, res: 0, upd: 0;
       cadBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadBg_info" {
     block_cadBg_info:
         const _cadBg;
         const 4;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadBq() //  [R1]
         { []
         }
     {offset
       cadBq: // global
           I64[Sp] = block_cadBs_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadCg; else goto cadBz;
       uadCg: // global
           call _cadBs(R1) args: 0, res: 0, upd: 0;
       cadBz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadBq_info" {
     block_cadBq_info:
         const _cadBq;
         const 130;
         const 30;
 },
 _cadBs() //  [R1]
         { []
         }
     {offset
       cadBs: // global
           _sacK0::P64 = P64[Sp + 8];
           _sacKm::P64 = P64[R1 + 15];
           _sacKn::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sacK0::P64 + 8] = _sacKm::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacK0::P64);
           R1 = _sacKn::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadBs_info" {
     block_cadBs_info:
         const _cadBs;
         const 130;
         const 30;
 },
 _cadBG() //  [R1]
         { []
         }
     {offset
       cadBG: // global
           I64[Sp - 16] = block_cadBL_info;
           _sacKr::P64 = P64[R1 + 7];
           _sacKs::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sacKs::P64;
           P64[Sp] = _sacKr::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadBG_info" {
     block_cadBG_info:
         const _cadBG;
         const 4;
         const 30;
 },
 _cadBL() //  [R1]
         { []
         }
     {offset
       cadBL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadBZ; else goto cadBY;
       cadBZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadBY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sacKd::P64 = P64[Sp + 32];
           P64[Hp] = _sacKd::P64;
           _sacJS::P64 = P64[Sp + 48];
           _sacK2::P64 = P64[Sp + 24];
           _sacKr::P64 = P64[Sp + 16];
           _sacKs::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacK2::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacK2::P64);
           I64[Sp + 32] = block_cadBR_info;
           R5 = _sacJS::P64;
           R4 = _sacKd::P64;
           R3 = _sacKs::P64;
           R2 = _sacKr::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadBL_info" {
     block_cadBL_info:
         const _cadBL;
         const 6;
         const 30;
 },
 _cadBR() //  [R1]
         { []
         }
     {offset
       cadBR: // global
           I64[Sp] = block_cadBT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadCh; else goto cadC1;
       uadCh: // global
           call _cadBT(R1) args: 0, res: 0, upd: 0;
       cadC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadBR_info" {
     block_cadBR_info:
         const _cadBR;
         const 130;
         const 30;
 },
 _cadBT() //  [R1]
         { []
         }
     {offset
       cadBT: // global
           _sacK0::P64 = P64[Sp + 8];
           _sacKF::P64 = P64[R1 + 7];
           _sacKG::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sacK0::P64 + 8] = _sacKF::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacK0::P64);
           R1 = _sacKG::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadBT_info" {
     block_cadBT_info:
         const _cadBT;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.5983988 UTC

[section ""data" . GHC.IO.Handle.Internals.decodeByteBuf_closure" {
     GHC.IO.Handle.Internals.decodeByteBuf_closure:
         const GHC.IO.Handle.Internals.decodeByteBuf_info;
         const 0;
 },
 GHC.IO.Handle.Internals.decodeByteBuf_entry() //  [R2, R3]
         { []
         }
     {offset
       cadDg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.decodeByteBuf_info" {
     GHC.IO.Handle.Internals.decodeByteBuf_info:
         const GHC.IO.Handle.Internals.decodeByteBuf_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Saded_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.603919674 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry() //  [R2,
                                                                 R3]
         { []
         }
     {offset
       cadDu: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cadDy; else goto cadDz;
       cadDy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cadDz: // global
           I64[Sp - 16] = block_cadDr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadEd; else goto cadDs;
       uadEd: // global
           call _cadDr(R1) args: 0, res: 0, upd: 0;
       cadDs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_info:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry;
         const 0;
         const 2814754062073870;
         const 12884901903;
         const Saded_srt+56;
 },
 _cadDr() //  [R1]
         { []
         }
     {offset
       cadDr: // global
           I64[Sp - 32] = block_cadDx_info;
           _sacKL::P64 = R1;
           _sacKN::P64 = P64[R1 + 15];
           _sacKP::P64 = P64[R1 + 31];
           _sacKR::P64 = P64[R1 + 47];
           R1 = P64[_sacKR::P64 + 8];
           P64[Sp - 24] = _sacKN::P64;
           P64[Sp - 16] = _sacKP::P64;
           P64[Sp - 8] = _sacKR::P64;
           P64[Sp] = _sacKL::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uadEc; else goto cadDB;
       uadEc: // global
           call _cadDx(R1) args: 0, res: 0, upd: 0;
       cadDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadDr_info" {
     block_cadDr_info:
         const _cadDr;
         const 1;
         const 562954248388638;
         const Saded_srt+56;
 },
 _cadDx() //  [R1]
         { []
         }
     {offset
       cadDx: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cadDP; else goto cadDJ;
       cadDP: // global
           _sacKP::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cadDM_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacKP::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
       cadDJ: // global
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadDx_info" {
     block_cadDx_info:
         const _cadDx;
         const 5;
         const 562954248388638;
         const Saded_srt+56;
 },
 _cadDM() //  [R1]
         { []
         }
     {offset
       cadDM: // global
           I64[Sp] = block_cadDO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadEe; else goto cadDR;
       uadEe: // global
           call _cadDO(R1) args: 0, res: 0, upd: 0;
       cadDR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadDM_info" {
     block_cadDM_info:
         const _cadDM;
         const 3;
         const 562954248388638;
         const Saded_srt+56;
 },
 _cadDO() //  [R1]
         { []
         }
     {offset
       cadDO: // global
           I64[Sp - 8] = block_cadDV_info;
           _sacLi::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sacLi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadEf; else goto cadDX;
       uadEf: // global
           call _cadDV(R1) args: 0, res: 0, upd: 0;
       cadDX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadDO_info" {
     block_cadDO_info:
         const _cadDO;
         const 3;
         const 562954248388638;
         const Saded_srt+56;
 },
 _cadDV() //  [R1]
         { []
         }
     {offset
       cadDV: // global
           if (R1 & 7 == 1) goto cadE3; else goto cadE7;
       cadE3: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cadE7: // global
           _sacKJ::P64 = P64[Sp + 32];
           _sacKL::P64 = P64[Sp + 24];
           _sacKR::P64 = P64[Sp + 16];
           _sacLi::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacKR::P64 + 8] = _sacLi::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacKR::P64);
           R3 = _sacKJ::P64;
           R2 = _sacKL::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.decodeByteBuf1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadDV_info" {
     block_cadDV_info:
         const _cadDV;
         const 4;
         const 562954248388638;
         const Saded_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.617398374 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking_closure:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDeviceNonBlocking_entry() //  [R2,
                                                                R3]
         { []
         }
     {offset
       cadES: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_entry(R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info" {
     GHC.IO.Handle.Internals.readTextDeviceNonBlocking_info:
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Saded_srt+208;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.630676812 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle2_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle2_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle2_info;
         const 0;
 },
 sat_sacMj_entry() //  [R1]
         { []
         }
     {offset
       cadFQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadFU; else goto cadFV;
       cadFU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadFV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadFN_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadFZ; else goto cadFO;
       uadFZ: // global
           call _cadFN(R1) args: 0, res: 0, upd: 0;
       cadFO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacMj_info" {
     sat_sacMj_info:
         const sat_sacMj_entry;
         const 1;
         const 16;
 },
 _cadFN() //  [R1]
         { []
         }
     {offset
       cadFN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadFY; else goto cadFX;
       cadFY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadFX: // global
           _sacMe::P64 = P64[R1 + 7];
           _sacMd::I64 = I64[R1 + 23];
           _sacMg::I64 = I64[R1 + 31];
           _sacMh::I64 = I64[R1 + 39];
           _sacMi::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacMe::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMd::I64;
           I64[Hp - 16] = _sacMg::I64;
           I64[Hp - 8] = _sacMh::I64;
           I64[Hp] = _sacMi::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadFN_info" {
     block_cadFN_info:
         const _cadFN;
         const 0;
         const 30;
 },
 sat_sacMv_entry() //  [R1]
         { []
         }
     {offset
       cadGa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadGe; else goto cadGf;
       cadGe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadGf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadG7_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadGj; else goto cadG8;
       uadGj: // global
           call _cadG7(R1) args: 0, res: 0, upd: 0;
       cadG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacMv_info" {
     sat_sacMv_info:
         const sat_sacMv_entry;
         const 1;
         const 16;
 },
 _cadG7() //  [R1]
         { []
         }
     {offset
       cadG7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadGi; else goto cadGh;
       cadGi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadGh: // global
           _sacMq::P64 = P64[R1 + 7];
           _sacMp::I64 = I64[R1 + 23];
           _sacMs::I64 = I64[R1 + 31];
           _sacMt::I64 = I64[R1 + 39];
           _sacMu::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacMq::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMp::I64;
           I64[Hp - 16] = _sacMs::I64;
           I64[Hp - 8] = _sacMt::I64;
           I64[Hp] = _sacMu::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadG7_info" {
     block_cadG7_info:
         const _cadG7;
         const 0;
         const 30;
 },
 sat_sacMH_entry() //  [R1]
         { []
         }
     {offset
       cadGs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadGw; else goto cadGx;
       cadGw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadGx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadGp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadGB; else goto cadGq;
       uadGB: // global
           call _cadGp(R1) args: 0, res: 0, upd: 0;
       cadGq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacMH_info" {
     sat_sacMH_info:
         const sat_sacMH_entry;
         const 1;
         const 16;
 },
 _cadGp() //  [R1]
         { []
         }
     {offset
       cadGp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadGA; else goto cadGz;
       cadGA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadGz: // global
           _sacMC::P64 = P64[R1 + 7];
           _sacMB::I64 = I64[R1 + 23];
           _sacME::I64 = I64[R1 + 31];
           _sacMF::I64 = I64[R1 + 39];
           _sacMG::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacMC::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMB::I64;
           I64[Hp - 16] = _sacME::I64;
           I64[Hp - 8] = _sacMF::I64;
           I64[Hp] = _sacMG::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadGp_info" {
     block_cadGp_info:
         const _cadGp;
         const 0;
         const 30;
 },
 sat_sacMT_entry() //  [R1]
         { []
         }
     {offset
       cadGM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadGQ; else goto cadGR;
       cadGQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadGR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadGJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadGV; else goto cadGK;
       uadGV: // global
           call _cadGJ(R1) args: 0, res: 0, upd: 0;
       cadGK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacMT_info" {
     sat_sacMT_info:
         const sat_sacMT_entry;
         const 1;
         const 16;
 },
 _cadGJ() //  [R1]
         { []
         }
     {offset
       cadGJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadGU; else goto cadGT;
       cadGU: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadGT: // global
           _sacMO::P64 = P64[R1 + 7];
           _sacMN::I64 = I64[R1 + 23];
           _sacMQ::I64 = I64[R1 + 31];
           _sacMR::I64 = I64[R1 + 39];
           _sacMS::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacMO::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMN::I64;
           I64[Hp - 16] = _sacMQ::I64;
           I64[Hp - 8] = _sacMR::I64;
           I64[Hp] = _sacMS::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadGJ_info" {
     block_cadGJ_info:
         const _cadGJ;
         const 0;
         const 30;
 },
 sat_sacN5_entry() //  [R1]
         { []
         }
     {offset
       cadH4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadH8; else goto cadH9;
       cadH8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadH9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadH1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadHd; else goto cadH2;
       uadHd: // global
           call _cadH1(R1) args: 0, res: 0, upd: 0;
       cadH2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacN5_info" {
     sat_sacN5_info:
         const sat_sacN5_entry;
         const 1;
         const 16;
 },
 _cadH1() //  [R1]
         { []
         }
     {offset
       cadH1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadHc; else goto cadHb;
       cadHc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadHb: // global
           _sacN0::P64 = P64[R1 + 7];
           _sacMZ::I64 = I64[R1 + 23];
           _sacN2::I64 = I64[R1 + 31];
           _sacN3::I64 = I64[R1 + 39];
           _sacN4::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacN0::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacMZ::I64;
           I64[Hp - 16] = _sacN2::I64;
           I64[Hp - 8] = _sacN3::I64;
           I64[Hp] = _sacN4::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadH1_info" {
     block_cadH1_info:
         const _cadH1;
         const 0;
         const 30;
 },
 sat_sacNh_entry() //  [R1]
         { []
         }
     {offset
       cadHo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadHs; else goto cadHt;
       cadHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadHt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadHl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadHx; else goto cadHm;
       uadHx: // global
           call _cadHl(R1) args: 0, res: 0, upd: 0;
       cadHm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacNh_info" {
     sat_sacNh_info:
         const sat_sacNh_entry;
         const 1;
         const 16;
 },
 _cadHl() //  [R1]
         { []
         }
     {offset
       cadHl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadHw; else goto cadHv;
       cadHw: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadHv: // global
           _sacNc::P64 = P64[R1 + 7];
           _sacNb::I64 = I64[R1 + 23];
           _sacNe::I64 = I64[R1 + 31];
           _sacNf::I64 = I64[R1 + 39];
           _sacNg::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacNc::P64;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = _sacNb::I64;
           I64[Hp - 16] = _sacNe::I64;
           I64[Hp - 8] = _sacNf::I64;
           I64[Hp] = _sacNg::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadHl_info" {
     block_cadHl_info:
         const _cadHl;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.wantReadableHandle2_entry() //  [R2, R3]
         { []
         }
     {offset
       cadHy: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cadHz; else goto cadHA;
       cadHz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cadHA: // global
           I64[Sp - 16] = block_cadF3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadIy; else goto cadF4;
       uadIy: // global
           call _cadF3(R1) args: 0, res: 0, upd: 0;
       cadF4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle2_info" {
     GHC.IO.Handle.Internals.wantReadableHandle2_info:
         const GHC.IO.Handle.Internals.wantReadableHandle2_entry;
         const 0;
         const 144116326242189326;
         const 12884901903;
         const Saded_srt+16;
 },
 _cadF3() //  [R1]
         { []
         }
     {offset
       cadF3: // global
           I64[Sp - 40] = block_cadF8_info;
           _sacLq::P64 = R1;
           _sacLs::P64 = P64[R1 + 15];
           _sacLu::P64 = P64[R1 + 31];
           _sacLw::P64 = P64[R1 + 47];
           _sacLz::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sacLs::P64;
           P64[Sp - 24] = _sacLu::P64;
           P64[Sp - 16] = _sacLw::P64;
           P64[Sp - 8] = _sacLz::P64;
           P64[Sp] = _sacLq::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uadIs; else goto cadF9;
       uadIs: // global
           call _cadF8(R1) args: 0, res: 0, upd: 0;
       cadF9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadF3_info" {
     block_cadF3_info:
         const _cadF3;
         const 1;
         const 1138166333470;
         const Saded_srt+16;
 },
 _cadF8() //  [R1]
         { []
         }
     {offset
       cadF8: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto cadHF;
               case 2 : goto cadHI;
               case 3 : goto uadIq;
               case 4, 5 : goto cadHR;
               case 6 : goto cadHT;
           }
       cadHT: // global
           _sacLK::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cadFi_info;
           R1 = _sacLK::P64;
           if (R1 & 7 != 0) goto uadIt; else goto cadFj;
       uadIt: // global
           call _cadFi(R1) args: 0, res: 0, upd: 0;
       cadFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cadHR: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uadIq: // global
           Sp = Sp + 40;
           call _cadHY() args: 0, res: 0, upd: 0;
       cadHI: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cadHF: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadF8_info" {
     block_cadF8_info:
         const _cadF8;
         const 6;
         const 1138166333470;
         const Saded_srt+16;
 },
 _cadFi() //  [R1]
         { []
         }
     {offset
       cadFi: // global
           I64[Sp - 16] = block_cadFn_info;
           _sacLQ::I64 = I64[R1 + 39];
           _sacLR::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sacLR::I64;
           I64[Sp] = _sacLQ::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadIv; else goto cadFo;
       uadIv: // global
           call _cadFn(R1) args: 0, res: 0, upd: 0;
       cadFo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadFi_info" {
     block_cadFi_info:
         const _cadFi;
         const 6;
         const 30;
 },
 _cadFn() //  [R1]
         { []
         }
     {offset
       cadFn: // global
           if (R1 & 7 == 1) goto uadIr; else goto cadHZ;
       uadIr: // global
           Sp = Sp + 56;
           call _cadHY() args: 0, res: 0, upd: 0;
       cadHZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cadI2; else goto cadI1;
       cadI2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadI1: // global
           _sacLw::P64 = P64[Sp + 40];
           if (I64[Sp + 16] == I64[Sp + 8]) goto cadIe; else goto cadI4;
       cadIe: // global
           _sacLz::P64 = P64[Sp + 48];
           _sacMX::P64 = P64[_sacLz::P64 + 8];
           I64[Hp - 40] = sat_sacN5_info;
           P64[Hp - 24] = _sacMX::P64;
           _sacLn::P64 = P64[Sp + 64];
           _sacLq::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sacLz::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLz::P64);
           _sacN9::P64 = P64[_sacLw::P64 + 8];
           I64[Hp - 16] = sat_sacNh_info;
           P64[Hp] = _sacN9::P64;
           call MO_WriteBarrier();
           P64[_sacLw::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLw::P64);
           R2 = _sacLq::P64;
           R1 = _sacLn::P64;
           Sp = Sp + 72;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cadI4: // global
           _sacLW::P64 = P64[_sacLw::P64 + 8];
           Hp = Hp - 48;
           I64[Sp + 16] = block_cadFw_info;
           R1 = _sacLW::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uadIw; else goto cadFx;
       uadIw: // global
           call _cadFw(R1) args: 0, res: 0, upd: 0;
       cadFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadFn_info" {
     block_cadFn_info:
         const _cadFn;
         const 200;
         const 30;
 },
 _cadFw() //  [R1]
         { []
         }
     {offset
       cadFw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cadI7; else goto cadI6;
       cadI7: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadI6: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cadId; else goto cadI9;
       cadId: // global
           _sacLz::P64 = P64[Sp + 32];
           _sacMz::P64 = P64[_sacLz::P64 + 8];
           I64[Hp - 40] = sat_sacMH_info;
           P64[Hp - 24] = _sacMz::P64;
           _sacLn::P64 = P64[Sp + 48];
           _sacLq::P64 = P64[Sp + 40];
           _sacLw::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sacLz::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLz::P64);
           _sacML::P64 = P64[_sacLw::P64 + 8];
           I64[Hp - 16] = sat_sacMT_info;
           P64[Hp] = _sacML::P64;
           call MO_WriteBarrier();
           P64[_sacLw::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLw::P64);
           R2 = _sacLq::P64;
           R1 = _sacLn::P64;
           Sp = Sp + 56;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cadI9: // global
           Hp = Hp - 48;
           _sacLu::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cadFE_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacLu::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadFw_info" {
     block_cadFw_info:
         const _cadFw;
         const 6;
         const 30;
 },
 _cadFE() //  [R1]
         { []
         }
     {offset
       cadFE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cadIc; else goto cadIb;
       cadIc: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadIb: // global
           _sacLn::P64 = P64[Sp + 32];
           _sacLq::P64 = P64[Sp + 24];
           _sacLw::P64 = P64[Sp + 8];
           _sacLz::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sacLw::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLw::P64);
           _sacMb::P64 = P64[_sacLz::P64 + 8];
           I64[Hp - 40] = sat_sacMj_info;
           P64[Hp - 24] = _sacMb::P64;
           call MO_WriteBarrier();
           P64[_sacLz::P64 + 8] = Hp - 40;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLz::P64);
           _sacMn::P64 = P64[_sacLw::P64 + 8];
           I64[Hp - 16] = sat_sacMv_info;
           P64[Hp] = _sacMn::P64;
           call MO_WriteBarrier();
           P64[_sacLw::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacLw::P64);
           R2 = _sacLq::P64;
           R1 = _sacLn::P64;
           Sp = Sp + 40;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadFE_info" {
     block_cadFE_info:
         const _cadFE;
         const 4;
         const 30;
 },
 _cadHY() //  []
         { []
         }
     {offset
       cadHY: // global
           R2 = P64[Sp];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.669855509 UTC

[section ""data" . lvl8_ra7Po_closure" {
     lvl8_ra7Po_closure:
         const GHC.IO.Handle.Types.BlockBuffering_con_info;
         const GHC.Base.Nothing_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.68841396 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle5_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle5_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle5_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_slow() //  [R1]
         { []
         }
     {offset
       cadL1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 56, res: 0, upd: 8;
     }
 },
 buf_state_sacNz_entry() //  [R1]
         { []
         }
     {offset
       cadMC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadMD; else goto cadME;
       cadMD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadME: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadMv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadML; else goto cadMw;
       uadML: // global
           call _cadMv(R1) args: 0, res: 0, upd: 0;
       cadMw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . buf_state_sacNz_info" {
     buf_state_sacNz_info:
         const buf_state_sacNz_entry;
         const 1;
         const 16;
 },
 _cadMv() //  [R1]
         { []
         }
     {offset
       cadMv: // global
           if (R1 & 7 == 3) goto cadMA; else goto cadMz;
       cadMA: // global
           R1 = GHC.IO.Buffer.ReadBuffer_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cadMz: // global
           R1 = GHC.IO.Buffer.WriteBuffer_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadMv_info" {
     block_cadMv_info:
         const _cadMv;
         const 0;
         const 30;
 },
 sat_sacNZ_entry() //  [R1]
         { []
         }
     {offset
       cadN8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadN9; else goto cadNa;
       cadN9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.outputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacNZ_info" {
     sat_sacNZ_info:
         const sat_sacNZ_entry;
         const 1;
         const 16;
 },
 sat_sacNY_entry() //  [R1]
         { []
         }
     {offset
       cadNf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cadNg; else goto cadNh;
       cadNg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Handle.Types.inputNL_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacNY_info" {
     sat_sacNY_info:
         const sat_sacNY_entry;
         const 1;
         const 16;
 },
 sat_sacO0_entry() //  [R1]
         { []
         }
     {offset
       cadNi: // global
           if ((Sp + -136) < SpLim) (likely: False) goto cadNk; else goto cadNl;
       cadNk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_cadMX_info;
           _sacNj::P64 = P64[R1 + 16];
           _sacNk::P64 = P64[R1 + 24];
           _sacNl::P64 = P64[R1 + 32];
           _sacNo::P64 = P64[R1 + 48];
           _sacNq::P64 = P64[R1 + 56];
           _sacNr::P64 = P64[R1 + 64];
           _sacNt::P64 = P64[R1 + 72];
           _sacNw::P64 = P64[R1 + 80];
           _sacNx::P64 = P64[R1 + 88];
           _sacNG::P64 = P64[R1 + 96];
           _sacNK::P64 = P64[R1 + 104];
           _sacNN::P64 = P64[R1 + 112];
           _sacNO::P64 = P64[R1 + 120];
           _sacNR::P64 = P64[R1 + 128];
           R1 = P64[R1 + 40];
           P64[Sp - 128] = _sacNj::P64;
           P64[Sp - 120] = _sacNk::P64;
           P64[Sp - 112] = _sacNl::P64;
           P64[Sp - 104] = _sacNo::P64;
           P64[Sp - 96] = _sacNq::P64;
           P64[Sp - 88] = _sacNr::P64;
           P64[Sp - 80] = _sacNt::P64;
           P64[Sp - 72] = _sacNw::P64;
           P64[Sp - 64] = _sacNx::P64;
           P64[Sp - 56] = _sacNG::P64;
           P64[Sp - 48] = _sacNK::P64;
           P64[Sp - 40] = _sacNN::P64;
           P64[Sp - 32] = _sacNO::P64;
           P64[Sp - 24] = _sacNR::P64;
           Sp = Sp - 136;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacO0_info" {
     sat_sacO0_info:
         const sat_sacO0_entry;
         const 15;
         const 15;
 },
 _cadMX() //  [R1]
         { []
         }
     {offset
       cadMX: // global
           I64[Sp] = block_cadMZ_info;
           _sacNV::P64 = R1;
           R1 = P64[Sp + 96];
           P64[Sp + 96] = _sacNV::P64;
           if (R1 & 7 != 0) goto uadNq; else goto cadN0;
       uadNq: // global
           call _cadMZ(R1) args: 0, res: 0, upd: 0;
       cadN0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cadMX_info" {
     block_cadMX_info:
         const _cadMX;
         const 14;
         const 30;
 },
 _cadMZ() //  [R1]
         { []
         }
     {offset
       cadMZ: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cadNp; else goto cadNo;
       cadNp: // global
           HpAlloc = 184;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cadNo: // global
           _sacNX::P64 = P64[R1 + 7];
           I64[Hp - 176] = sat_sacNZ_info;
           _sacNr::P64 = P64[Sp + 48];
           P64[Hp - 160] = _sacNr::P64;
           I64[Hp - 152] = sat_sacNY_info;
           P64[Hp - 136] = _sacNr::P64;
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 96];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 104];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = _sacNX::P64;
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = Hp - 152;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 127;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadMZ_info" {
     block_cadMZ_info:
         const _cadMZ;
         const 14;
         const 30;
 },
 sat_sacO6_entry() //  [R1]
         { []
         }
     {offset
       cadNE: // global
           _sacO6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cadNF; else goto cadNG;
       cadNG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadNI; else goto cadNH;
       cadNI: // global
           HpAlloc = 16;
           goto cadNF;
       cadNF: // global
           R1 = _sacO6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sacO6::P64;
           _sacNn::P64 = P64[_sacO6::P64 + 16];
           _sacNU::P64 = P64[_sacO6::P64 + 24];
           _sacO4::P64 = P64[_sacO6::P64 + 32];
           I64[Hp - 8] = GHC.MVar.MVar_con_info;
           P64[Hp] = _sacNU::P64;
           R3 = Hp - 7;
           R2 = _sacNn::P64;
           R1 = _sacO4::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacO6_info" {
     sat_sacO6_info:
         const sat_sacO6_entry;
         const 3;
         const 15;
 },
 sat_sacOG_entry() //  [R1]
         { []
         }
     {offset
       cadNS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cadNT; else goto cadNU;
       cadNT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadNU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cadNL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uadO1; else goto cadNM;
       uadO1: // global
           call _cadNL(R1) args: 0, res: 0, upd: 0;
       cadNM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacOG_info" {
     sat_sacOG_info:
         const sat_sacOG_entry;
         const 1;
         const 16;
 },
 _cadNL() //  [R1]
         { []
         }
     {offset
       cadNL: // global
           if (R1 & 7 == 1) goto cadNP; else goto cadNQ;
       cadNP: // global
           R1 = lvl8_ra7Po_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cadNQ: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cadNL_info" {
     block_cadNL_info:
         const _cadNL;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle5_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { []
         }
     {offset
       cadO6: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cadO7; else goto cadO8;
       cadO7: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 96, res: 0, upd: 8;
       cadO8: // global
           I64[Sp - 48] = block_cadLU_info;
           R1 = P64[Sp + 16];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uadQi; else goto cadLV;
       uadQi: // global
           call _cadLU(R1) args: 0, res: 0, upd: 0;
       cadLV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle5_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle5_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle5_entry;
         const 0;
         const 38654705678;
         const 51539607552;
         const Saded_srt+200;
         const 11;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_slow;
 },
 _cadLU() //  [R1]
         { []
         }
     {offset
       cadLU: // global
           if (R1 & 7 == 1) goto cadO3; else goto cadO4;
       cadO3: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _cadL8() args: 0, res: 0, upd: 0;
       cadO4: // global
           I64[Sp] = block_cadM0_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadQa; else goto cadM1;
       uadQa: // global
           call _cadM0(R1) args: 0, res: 0, upd: 0;
       cadM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLU_info" {
     block_cadLU_info:
         const _cadLU;
         const 11;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadM0() //  [R1]
         { []
         }
     {offset
       cadM0: // global
           I64[Sp - 16] = block_cadP1_info;
           _sacOL::P64 = P64[R1 + 15];
           _sacOM::P64 = P64[R1 + 23];
           R1 = P64[Sp + 48];
           P64[Sp - 8] = _sacOM::P64;
           P64[Sp] = _sacOL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uadQc; else goto cadPn;
       uadQc: // global
           call _cadP1(R1) args: 0, res: 0, upd: 0;
       cadPn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadM0_info" {
     block_cadM0_info:
         const _cadM0;
         const 11;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadP1() //  [R1]
         { []
         }
     {offset
       cadP1: // global
           _sacOL::P64 = P64[Sp + 16];
           _cadPM::P64 = R1 & 7;
           if (_cadPM::P64 != 3) goto uadPU; else goto cadPy;
       uadPU: // global
           if (_cadPM::P64 != 6) goto cadPt; else goto cadPH;
       cadPt: // global
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sacON() args: 0, res: 0, upd: 0;
       cadPH: // global
           I64[Sp] = block_cadPF_info;
           R1 = _sacOL::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cadPy: // global
           I64[Sp] = block_cadPw_info;
           R1 = _sacOL::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadP1_info" {
     block_cadP1_info:
         const _cadP1;
         const 13;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadPF() //  [R1]
         { []
         }
     {offset
       cadPF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPL; else goto cadPK;
       cadPL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPK: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sacON() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadPF_info" {
     block_cadPF_info:
         const _cadPF;
         const 141;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadPw() //  [R1]
         { []
         }
     {offset
       cadPw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPC; else goto cadPB;
       cadPC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPB: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 6;
           Sp = Sp + 8;
           call _sacON() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadPw_info" {
     block_cadPw_info:
         const _cadPw;
         const 141;
         const 4294967326;
         const Saded_srt+200;
 },
 _sacON() //  []
         { []
         }
     {offset
       sacON: // global
           I64[Sp - 8] = block_cadMa_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadQm; else goto cadMb;
       uadQm: // global
           call _cadMa(R1) args: 0, res: 0, upd: 0;
       cadMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadMa() //  [R1]
         { []
         }
     {offset
       cadMa: // global
           _sacOM::P64 = P64[Sp + 8];
           _cadPP::P64 = R1 & 7;
           if (_cadPP::P64 < 5) goto uadPS; else goto uadPT;
       uadPS: // global
           if (_cadPP::P64 < 4) goto cadP7; else goto cadP9;
       cadP7: // global
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _cadL8() args: 0, res: 0, upd: 0;
       cadP9: // global
           I64[Sp + 8] = block_cadMg_info;
           R1 = _sacOM::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       uadPT: // global
           if (_cadPP::P64 < 6) goto cadPe; else goto cadPj;
       cadPe: // global
           I64[Sp + 8] = block_cadMl_info;
           R1 = _sacOM::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cadPj: // global
           I64[Sp + 8] = block_cadMq_info;
           R1 = _sacOM::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadMa_info" {
     block_cadMa_info:
         const _cadMa;
         const 13;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadMg() //  [R1]
         { []
         }
     {offset
       cadMg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPc; else goto cadPb;
       cadPc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPb: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sacNx::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sacNx::P64;
           call _cadL8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadMg_info" {
     block_cadMg_info:
         const _cadMg;
         const 12;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadMl() //  [R1]
         { []
         }
     {offset
       cadMl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPh; else goto cadPg;
       cadPh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPg: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sacNx::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sacNx::P64;
           call _cadL8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadMl_info" {
     block_cadMl_info:
         const _cadMl;
         const 12;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadMq() //  [R1]
         { []
         }
     {offset
       cadMq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadPm; else goto cadPl;
       cadPm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadPl: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           _sacNx::P64 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 6;
           P64[Sp] = _sacNx::P64;
           call _cadL8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadMq_info" {
     block_cadMq_info:
         const _cadMq;
         const 12;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadL8() //  []
         { []
         }
     {offset
       cadL8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadOb; else goto cadOa;
       cadOb: // global
           HpAlloc = 24;
           _sacNw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadL7_info;
           R2 = P64[Sp];
           R1 = _sacNw::P64;
           Sp = Sp + 8;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cadOa: // global
           I64[Hp - 16] = buf_state_sacNz_info;
           P64[Hp] = P64[Sp + 56];
           I64[Sp - 16] = block_cadLc_info;
           R2 = P64[Sp + 24];
           I64[Sp - 40] = stg_ap_ppv_info;
           P64[Sp - 32] = P64[Sp + 40];
           _cadLa::P64 = Hp - 16;
           P64[Sp - 24] = _cadLa::P64;
           P64[Sp - 8] = _cadLa::P64;
           Sp = Sp - 40;
           call GHC.IO.BufferedIO.newBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cadL7() //  [R1, R2]
         { []
         }
     {offset
       cadL7: // global
           P64[Sp] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cadL8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadL7_info" {
     block_cadL7_info:
         const _cadL7;
         const 11;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadLc() //  [R1]
         { []
         }
     {offset
       cadLc: // global
           I64[Sp - 8] = block_cadLe_info;
           _sacND::P64 = R1;
           R1 = R1;
           P64[Sp] = _sacND::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLc_info" {
     block_cadLc_info:
         const _cadLc;
         const 14;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadLe() //  [R1]
         { []
         }
     {offset
       cadLe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadOf; else goto cadOe;
       cadOf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOe: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cadLh_info;
           _sacNG::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _sacNG::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLe_info" {
     block_cadLe_info:
         const _cadLe;
         const 15;
         const 4294967326;
         const Saded_srt+200;
 },
 _cadLh() //  [R1]
         { []
         }
     {offset
       cadLh: // global
           I64[Sp] = block_cadLl_info;
           _sacNK::P64 = R1;
           R1 = P64[Sp + 88];
           P64[Sp + 88] = _sacNK::P64;
           if (R1 & 7 != 0) goto uadQ7; else goto cadLm;
       uadQ7: // global
           call _cadLl(R1) args: 0, res: 0, upd: 0;
       cadLm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLh_info" {
     block_cadLh_info:
         const _cadLh;
         const 15;
         const 30;
 },
 _cadLl() //  [R1]
         { []
         }
     {offset
       cadLl: // global
           if (R1 & 7 == 1) goto cadOG; else goto cadOP;
       cadOG: // global
           I64[Sp] = block_cadLq_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cadOP: // global
           I64[Sp] = block_cadLE_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLl_info" {
     block_cadLl_info:
         const _cadLl;
         const 15;
         const 30;
 },
 _cadLq() //  [R1]
         { []
         }
     {offset
       cadLq: // global
           I64[Sp - 8] = block_cadLs_info;
           _sacOe::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sacOe::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLq_info" {
     block_cadLq_info:
         const _cadLq;
         const 15;
         const 30;
 },
 _cadLs() //  [R1]
         { []
         }
     {offset
       cadLs: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadOK; else goto cadOJ;
       cadOK: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOJ: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_cadLz_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLs_info" {
     block_cadLs_info:
         const _cadLs;
         const 16;
         const 30;
 },
 _cadLz() //  [R1]
         { []
         }
     {offset
       cadLz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cadON; else goto cadOM;
       cadON: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOM: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           P64[Sp + 16] = Hp - 7;
           P64[Sp] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           call _sacNL() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadLz_info" {
     block_cadLz_info:
         const _cadLz;
         const 143;
         const 30;
 },
 _cadLE() //  [R1]
         { []
         }
     {offset
       cadLE: // global
           I64[Sp - 8] = block_cadLG_info;
           _sacOr::P64 = R1;
           R1 = 8192;
           P64[Sp] = _sacOr::P64;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLE_info" {
     block_cadLE_info:
         const _cadLE;
         const 15;
         const 30;
 },
 _cadLG() //  [R1]
         { []
         }
     {offset
       cadLG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cadOT; else goto cadOS;
       cadOT: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOS: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = 2048;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 8] = block_cadLN_info;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLG_info" {
     block_cadLG_info:
         const _cadLG;
         const 16;
         const 30;
 },
 _cadLN() //  [R1]
         { []
         }
     {offset
       cadLN: // global
           I64[Sp] = block_cadLP_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 64];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadLN_info" {
     block_cadLN_info:
         const _cadLN;
         const 143;
         const 30;
 },
 _cadLP() //  [R1]
         { []
         }
     {offset
       cadLP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cadOX; else goto cadOW;
       cadOX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOW: // global
           I64[Hp - 32] = sat_sacOG_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp] = Hp - 32;
           P64[Sp + 16] = Hp - 7;
           call _sacNL() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadLP_info" {
     block_cadLP_info:
         const _cadLP;
         const 15;
         const 30;
 },
 _sacNL() //  []
         { []
         }
     {offset
       sacNL: // global
           I64[Sp - 8] = block_cadMP_info;
           R1 = GHC.IO.Handle.Types.BufferListNil_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadMP() //  [R1]
         { []
         }
     {offset
       cadMP: // global
           I64[Sp - 8] = block_cadMR_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadMP_info" {
     block_cadMP_info:
         const _cadMP;
         const 16;
         const 30;
 },
 _cadMR() //  [R1]
         { []
         }
     {offset
       cadMR: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cadOl; else goto cadOk;
       cadOl: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOk: // global
           I64[Hp - 128] = sat_sacO0_info;
           P64[Hp - 112] = P64[Sp + 56];
           P64[Hp - 104] = P64[Sp + 64];
           P64[Hp - 96] = P64[Sp + 72];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 112];
           P64[Hp - 64] = P64[Sp + 120];
           P64[Hp - 56] = P64[Sp + 136];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 104];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 80] = block_cadNr_info;
           R2 = Hp - 128;
           _sacNU::P64 = R1;
           R1 = R1;
           P64[Sp + 136] = _sacNU::P64;
           Sp = Sp + 80;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadMR_info" {
     block_cadMR_info:
         const _cadMR;
         const 17;
         const 30;
 },
 _cadNr() //  []
         { []
         }
     {offset
       cadNr: // global
           I64[Sp] = block_cadNt_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uadQh; else goto cadNu;
       uadQh: // global
           call _cadNt(R1) args: 0, res: 0, upd: 0;
       cadNu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadNr_info" {
     block_cadNr_info:
         const _cadNr;
         const 1927;
         const 30;
 },
 _cadNt() //  [R1]
         { []
         }
     {offset
       cadNt: // global
           _sacNn::P64 = P64[Sp + 8];
           _sacNU::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cadOq; else goto cadOx;
       cadOq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadOt; else goto cadOs;
       cadOt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOs: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = _sacNn::P64;
           P64[Hp] = _sacNU::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cadOx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cadOA; else goto cadOz;
       cadOA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOz: // global
           _sacO4::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_sacO6_info;
           P64[Hp - 16] = _sacNn::P64;
           P64[Hp - 8] = _sacNU::P64;
           P64[Hp] = _sacO4::P64;
           I64[Sp] = block_cadOu_info;
           R3 = Hp - 32;
           R2 = GHC.Tuple.()_closure+1;
           R1 = _sacNU::P64;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadNt_info" {
     block_cadNt_info:
         const _cadNt;
         const 3975;
         const 30;
 },
 _cadOu() //  [R1]
         { []
         }
     {offset
       cadOu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cadOD; else goto cadOC;
       cadOD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadOC: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cadOu_info" {
     block_cadOu_info:
         const _cadOu;
         const 3975;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.759268804 UTC

[section ""data" . GHC.IO.Handle.Internals.mkHandle_closure" {
     GHC.IO.Handle.Internals.mkHandle_closure:
         const GHC.IO.Handle.Internals.mkHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkHandle_slow() //  [R1]
         { []
         }
     {offset
       cadV1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkHandle_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 56, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkHandle_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cadV5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkHandle_info" {
     GHC.IO.Handle.Internals.mkHandle_info:
         const GHC.IO.Handle.Internals.mkHandle_entry;
         const 0;
         const 4294967310;
         const 51539607552;
         const Saded_srt+224;
         const 11;
         const GHC.IO.Handle.Internals.mkHandle_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.763506416 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO1_closure" {
     GHC.IO.Handle.Internals.debugIO1_closure:
         const GHC.IO.Handle.Internals.debugIO1_info;
 },
 GHC.IO.Handle.Internals.debugIO1_entry() //  []
         { []
         }
     {offset
       cadVi: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.debugIO1_info" {
     GHC.IO.Handle.Internals.debugIO1_info:
         const GHC.IO.Handle.Internals.debugIO1_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.767338528 UTC

[section ""data" . GHC.IO.Handle.Internals.debugIO_closure" {
     GHC.IO.Handle.Internals.debugIO_closure:
         const GHC.IO.Handle.Internals.debugIO_info;
 },
 GHC.IO.Handle.Internals.debugIO_entry() //  [R2]
         { []
         }
     {offset
       cadVv: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.debugIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.debugIO_info" {
     GHC.IO.Handle.Internals.debugIO_info:
         const GHC.IO.Handle.Internals.debugIO_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.780692157 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwriteCharBuffer_closure" {
     GHC.IO.Handle.Internals.$wwriteCharBuffer_closure:
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_info;
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_slow() //  [R1]
         { []
         }
     {offset
       cadVD: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.$wwriteCharBuffer_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { []
         }
     {offset
       cadVK: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cadVL; else goto uadYQ;
       cadVL: // global
           R1 = GHC.IO.Handle.Internals.$wwriteCharBuffer_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       uadYQ: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cadVE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wwriteCharBuffer_info" {
     GHC.IO.Handle.Internals.$wwriteCharBuffer_info:
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_entry;
         const 0;
         const 14;
         const 34359738368;
         const 0;
         const 7303;
         const GHC.IO.Handle.Internals.$wwriteCharBuffer_slow;
 },
 _cadVE() //  []
         { []
         }
     {offset
       cadVE: // global
           _sacPe::P64 = P64[Sp];
           I64[Sp] = block_cadVH_info;
           R1 = _sacPe::P64;
           if (R1 & 7 != 0) goto uadZ6; else goto cadVI;
       uadZ6: // global
           call _cadVH(R1) args: 0, res: 0, upd: 0;
       cadVI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadVH() //  [R1]
         { []
         }
     {offset
       cadVH: // global
           I64[Sp - 48] = block_cadVR_info;
           _sacPm::P64 = R1;
           _sacPo::P64 = P64[R1 + 15];
           _sacPq::P64 = P64[R1 + 31];
           _sacPs::P64 = P64[R1 + 47];
           _sacPt::P64 = P64[R1 + 55];
           R1 = P64[R1 + 87];
           P64[Sp - 40] = _sacPo::P64;
           P64[Sp - 32] = _sacPq::P64;
           P64[Sp - 24] = _sacPs::P64;
           P64[Sp - 16] = _sacPt::P64;
           P64[Sp - 8] = P64[_sacPs::P64 + 8];
           P64[Sp] = _sacPm::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uadZ7; else goto cadXV;
       uadZ7: // global
           call _cadVR(R1) args: 0, res: 0, upd: 0;
       cadXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadVH_info" {
     block_cadVH_info:
         const _cadVH;
         const 3654;
         const 30;
 },
 _cadVR() //  [R1]
         { []
         }
     {offset
       cadVR: // global
           if (R1 & 7 == 1) goto cadY9; else goto cadYB;
       cadY9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadYc; else goto cadYb;
       cadYc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadYb: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_cadY0_info;
           R3 = P64[Sp + 40];
           R2 = Hp - 47;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cadYB: // global
           I64[Sp] = block_cadYm_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadZ9; else goto cadYn;
       uadZ9: // global
           call _cadYm(R1) args: 0, res: 0, upd: 0;
       cadYn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadVR_info" {
     block_cadVR_info:
         const _cadVR;
         const 233484;
         const 30;
 },
 _cadY0() //  [R1]
         { []
         }
     {offset
       cadY0: // global
           I64[Sp] = block_cadY2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadZs; else goto cadY3;
       uadZs: // global
           call _cadY2(R1) args: 0, res: 0, upd: 0;
       cadY3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadY0_info" {
     block_cadY0_info:
         const _cadY0;
         const 259084;
         const 30;
 },
 _cadY2() //  [R1]
         { []
         }
     {offset
       cadY2: // global
           I64[Sp] = block_cadY7_info;
           _sacQz::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp + 96] = _sacQz::P64;
           if (R1 & 7 != 0) goto uadZt; else goto cadYf;
       uadZt: // global
           call _cadY7(R1) args: 0, res: 0, upd: 0;
       cadYf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadY2_info" {
     block_cadY2_info:
         const _cadY2;
         const 259084;
         const 30;
 },
 _cadY7() //  [R1]
         { []
         }
     {offset
       cadY7: // global
           P64[Sp + 96] = P64[Sp + 96];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 72] = P64[R1 + 7];
           P64[Sp + 64] = P64[R1 + 15];
           I64[Sp + 56] = I64[R1 + 31];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 8;
           call _cadVT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadY7_info" {
     block_cadY7_info:
         const _cadY7;
         const 128012;
         const 30;
 },
 _cadYm() //  [R1]
         { []
         }
     {offset
       cadYm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadYE; else goto cadYD;
       cadYE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cadYD: // global
           _sacQK::P64 = P64[R1 + 7];
           _sacQL::P64 = P64[R1 + 15];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 80];
           I64[Hp - 8] = I64[Sp + 88];
           I64[Hp] = I64[Sp + 96];
           I64[Sp] = block_cadYs_info;
           R5 = P64[Sp + 40];
           R4 = Hp - 47;
           R3 = _sacQL::P64;
           R2 = _sacQK::P64;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadYm_info" {
     block_cadYm_info:
         const _cadYm;
         const 233484;
         const 30;
 },
 _cadYs() //  [R1]
         { []
         }
     {offset
       cadYs: // global
           I64[Sp] = block_cadYu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uadZv; else goto cadYv;
       uadZv: // global
           call _cadYu(R1) args: 0, res: 0, upd: 0;
       cadYv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadYs_info" {
     block_cadYs_info:
         const _cadYs;
         const 259084;
         const 30;
 },
 _cadYu() //  [R1]
         { []
         }
     {offset
       cadYu: // global
           I64[Sp] = block_cadYz_info;
           _sacQU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 96] = _sacQU::P64;
           if (R1 & 7 != 0) goto uadZw; else goto cadYH;
       uadZw: // global
           call _cadYz(R1) args: 0, res: 0, upd: 0;
       cadYH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadYu_info" {
     block_cadYu_info:
         const _cadYu;
         const 259084;
         const 30;
 },
 _cadYz() //  [R1]
         { []
         }
     {offset
       cadYz: // global
           I64[Sp] = I64[R1 + 47];
           I64[Sp + 40] = I64[R1 + 39];
           I64[Sp + 56] = I64[R1 + 31];
           P64[Sp + 64] = P64[R1 + 15];
           P64[Sp + 72] = P64[R1 + 7];
           I64[Sp + 80] = I64[R1 + 23];
           P64[Sp + 96] = P64[Sp + 96];
           Sp = Sp - 8;
           call _cadVT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadYz_info" {
     block_cadYz_info:
         const _cadYz;
         const 128012;
         const 30;
 },
 _cadVT() //  []
         { []
         }
     {offset
       cadVT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cadVY; else goto cadVX;
       cadVY: // global
           HpAlloc = 56;
           I64[Sp] = block_cadVT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cadVX: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 72];
           I64[Hp - 24] = I64[Sp + 88];
           _sacPM::I64 = I64[Sp + 64];
           I64[Hp - 16] = _sacPM::I64;
           I64[Hp - 8] = I64[Sp + 48];
           _sacPO::I64 = I64[Sp + 8];
           I64[Hp] = _sacPO::I64;
           _cadVZ::P64 = Hp - 47;
           if (_sacPM::I64 == _sacPO::I64) goto uadYT; else goto cadWs;
       uadYT: // global
           P64[Sp + 96] = _cadVZ::P64;
           Sp = Sp + 16;
           call _sacPQ() args: 0, res: 0, upd: 0;
       cadWs: // global
           I64[Sp] = block_cadWq_info;
           R1 = P64[Sp + 104];
           P64[Sp + 88] = _cadVZ::P64;
           if (R1 & 7 != 0) goto uadZa; else goto cadWt;
       uadZa: // global
           call _cadWq(R1) args: 0, res: 0, upd: 0;
       cadWt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadVT_info" {
     block_cadVT_info:
         const _cadVT;
         const 206925;
         const 30;
 },
 _cadWq() //  [R1]
         { []
         }
     {offset
       cadWq: // global
           _sacPt::P64 = P64[Sp + 40];
           _sacQ6::P64 = P64[R1 + 7];
           _sacQ7::P64 = P64[R1 + 15];
           _sacQ5::I64 = I64[R1 + 23];
           _sacQ8::I64 = I64[R1 + 31];
           _sacQ9::I64 = I64[R1 + 39];
           _sacQa::I64 = I64[R1 + 47];
           if (_sacQ9::I64 == _sacQa::I64) goto sacQb; else goto cadXS;
       cadXS: // global
           if (_sacQ9::I64 != I64[Sp + 96]) goto sacQb; else goto uadYU;
       sacQb: // global
           I64[Sp - 8] = block_cadWD_info;
           R1 = _sacPt::P64;
           I64[Sp] = _sacQa::I64;
           I64[Sp + 40] = _sacQ9::I64;
           I64[Sp + 64] = _sacQ8::I64;
           P64[Sp + 72] = _sacQ7::P64;
           P64[Sp + 80] = _sacQ6::P64;
           I64[Sp + 96] = _sacQ5::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadZf; else goto cadWF;
       uadZf: // global
           call _cadWD(R1) args: 0, res: 0, upd: 0;
       cadWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uadYU: // global
           P64[Sp + 96] = P64[Sp + 88];
           Sp = Sp + 16;
           call _sacPQ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadWq_info" {
     block_cadWq_info:
         const _cadWq;
         const 190541;
         const 30;
 },
 _cadWD() //  [R1]
         { []
         }
     {offset
       cadWD: // global
           _cadYN::P64 = R1 & 7;
           if (_cadYN::P64 < 3) goto uadYP; else goto cadX2;
       uadYP: // global
           _cadVZ::P64 = P64[Sp + 96];
           if (_cadYN::P64 < 2) goto uadYV; else goto cadWX;
       uadYV: // global
           P64[Sp + 104] = _cadVZ::P64;
           Sp = Sp + 24;
           call _sacPQ() args: 0, res: 0, upd: 0;
       cadWX: // global
           _sacPs::P64 = P64[Sp + 40];
           _sacQ9::I64 = I64[Sp + 48];
           _sacQa::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacPs::P64 + 8] = _cadVZ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacPs::P64);
           if (_sacQ9::I64 == _sacQa::I64) goto uadYW; else goto uadYX;
       uadYW: // global
           Sp = Sp + 120;
           call _cadXF() args: 0, res: 0, upd: 0;
       uadYX: // global
           Sp = Sp + 8;
           call _cadXE() args: 0, res: 0, upd: 0;
       cadX2: // global
           I64[Sp] = block_cadX0_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto uadZh; else goto cadX3;
       uadZh: // global
           call _cadX0(R1) args: 0, res: 0, upd: 0;
       cadX3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadWD_info" {
     block_cadWD_info:
         const _cadWD;
         const 284878;
         const 30;
 },
 _cadX0() //  [R1]
         { []
         }
     {offset
       cadX0: // global
           if (R1 & 7 == 1) goto cadXh; else goto cadXm;
       cadXh: // global
           _cadVZ::P64 = P64[Sp + 96];
           _sacPs::P64 = P64[Sp + 40];
           _sacQ9::I64 = I64[Sp + 48];
           _sacQa::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacPs::P64 + 8] = _cadVZ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacPs::P64);
           if (_sacQ9::I64 == _sacQa::I64) goto uadZ1; else goto uadZ2;
       uadZ1: // global
           Sp = Sp + 120;
           call _cadXF() args: 0, res: 0, upd: 0;
       uadZ2: // global
           Sp = Sp + 8;
           call _cadXE() args: 0, res: 0, upd: 0;
       cadXm: // global
           I64[Sp] = block_cadXk_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uadZl; else goto cadXn;
       uadZl: // global
           call _cadXk(R1) args: 0, res: 0, upd: 0;
       cadXn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadX0_info" {
     block_cadX0_info:
         const _cadX0;
         const 284878;
         const 30;
 },
 _cadXk() //  [R1]
         { []
         }
     {offset
       cadXk: // global
           _cadVZ::P64 = P64[Sp + 96];
           if (%MO_S_Lt_W64(I64[Sp + 16] - I64[Sp + 56],
                            I64[R1 + 7])) goto cadXH; else goto uadYY;
       cadXH: // global
           _sacPs::P64 = P64[Sp + 40];
           _sacQ9::I64 = I64[Sp + 48];
           _sacQa::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacPs::P64 + 8] = _cadVZ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacPs::P64);
           if (_sacQ9::I64 == _sacQa::I64) goto uadYZ; else goto uadZ0;
       uadYZ: // global
           Sp = Sp + 120;
           call _cadXF() args: 0, res: 0, upd: 0;
       uadZ0: // global
           Sp = Sp + 8;
           call _cadXE() args: 0, res: 0, upd: 0;
       uadYY: // global
           P64[Sp + 104] = _cadVZ::P64;
           Sp = Sp + 24;
           call _sacPQ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadXk_info" {
     block_cadXk_info:
         const _cadXk;
         const 284878;
         const 30;
 },
 _cadXE() //  []
         { []
         }
     {offset
       cadXE: // global
           P64[Sp + 56] = P64[Sp + 56];
           _sacPi::I64 = I64[Sp + 64];
           I64[Sp + 64] = I64[Sp + 96];
           _sacPh::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sacPh::P64;
           I64[Sp + 88] = _sacPi::I64;
           I64[Sp + 96] = I64[Sp + 40];
           I64[Sp + 104] = I64[Sp];
           Sp = Sp + 56;
           call _cadVE() args: 0, res: 0, upd: 0;
     }
 },
 _sacPQ() //  []
         { []
         }
     {offset
       sacPQ: // global
           _sacPq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadW5_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sacPq::P64;
           P64[Sp] = P64[Sp + 80];
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cadW5() //  [R1]
         { []
         }
     {offset
       cadW5: // global
           _sacPs::P64 = P64[Sp + 8];
           _sacPI::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sacPs::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacPs::P64);
           I64[Sp + 24] = block_cadWa_info;
           R1 = _sacPI::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uadZc; else goto cadWd;
       uadZc: // global
           call _cadWa(R1) args: 0, res: 0, upd: 0;
       cadWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cadW5_info" {
     block_cadW5_info:
         const _cadW5;
         const 32138;
         const 30;
 },
 _cadWa() //  [R1]
         { []
         }
     {offset
       cadWa: // global
           _sacQ0::I64 = I64[R1 + 39];
           _sacQ1::I64 = I64[R1 + 47];
           if (_sacQ0::I64 == _sacQ1::I64) goto uadZ4; else goto cadWl;
       uadZ4: // global
           Sp = Sp + 64;
           call _cadXF() args: 0, res: 0, upd: 0;
       cadWl: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 40] = I64[R1 + 31];
           I64[Sp + 48] = _sacQ0::I64;
           I64[Sp + 56] = _sacQ1::I64;
           Sp = Sp + 8;
           call _cadVE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cadWa_info" {
     block_cadWa_info:
         const _cadWa;
         const 8071;
         const 30;
 },
 _cadXF() //  []
         { []
         }
     {offset
       cadXF: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.818904535 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer1_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer1_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer1_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer1_entry() //  [R2, R3]
         { []
         }
     {offset
       cae26: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae27; else goto cae28;
       cae27: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.writeCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cae28: // global
           I64[Sp - 16] = block_cae23_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uae2c; else goto cae24;
       uae2c: // global
           call _cae23(R1) args: 0, res: 0, upd: 0;
       cae24: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.writeCharBuffer1_info" {
     GHC.IO.Handle.Internals.writeCharBuffer1_info:
         const GHC.IO.Handle.Internals.writeCharBuffer1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cae23() //  [R1]
         { []
         }
     {offset
       cae23: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cae23_info" {
     block_cae23_info:
         const _cae23;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.824222489 UTC

[section ""data" . GHC.IO.Handle.Internals.writeCharBuffer_closure" {
     GHC.IO.Handle.Internals.writeCharBuffer_closure:
         const GHC.IO.Handle.Internals.writeCharBuffer_info;
 },
 GHC.IO.Handle.Internals.writeCharBuffer_entry() //  [R2, R3]
         { []
         }
     {offset
       cae2t: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.writeCharBuffer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.writeCharBuffer_info" {
     GHC.IO.Handle.Internals.writeCharBuffer_info:
         const GHC.IO.Handle.Internals.writeCharBuffer_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.83436539 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer3_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer3_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer3_info;
 },
 sat_sacRY_entry() //  [R1]
         { []
         }
     {offset
       cae38: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cae3c; else goto cae3d;
       cae3c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae3d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cae35_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uae3h; else goto cae36;
       uae3h: // global
           call _cae35(R1) args: 0, res: 0, upd: 0;
       cae36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacRY_info" {
     sat_sacRY_info:
         const sat_sacRY_entry;
         const 1;
         const 16;
 },
 _cae35() //  [R1]
         { []
         }
     {offset
       cae35: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cae3g; else goto cae3f;
       cae3g: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cae3f: // global
           _sacRT::P64 = P64[R1 + 7];
           _sacRU::P64 = P64[R1 + 15];
           _sacRS::I64 = I64[R1 + 23];
           _sacRV::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacRT::P64;
           P64[Hp - 32] = _sacRU::P64;
           I64[Hp - 24] = _sacRS::I64;
           I64[Hp - 16] = _sacRV::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cae35_info" {
     block_cae35_info:
         const _cae35;
         const 0;
         const 30;
 },
 sat_sacSh_entry() //  [R1]
         { []
         }
     {offset
       cae3E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cae3L; else goto cae3M;
       cae3L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae3M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cae3B_info;
           _sacS7::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sacS7::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uae3Q; else goto cae3C;
       uae3Q: // global
           call _cae3B(R1) args: 0, res: 0, upd: 0;
       cae3C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacSh_info" {
     sat_sacSh_info:
         const sat_sacSh_entry;
         const 4294967297;
         const 19;
 },
 _cae3B() //  [R1]
         { []
         }
     {offset
       cae3B: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cae3P; else goto cae3O;
       cae3P: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cae3O: // global
           _sacSb::P64 = P64[R1 + 7];
           _sacSc::P64 = P64[R1 + 15];
           _sacSa::I64 = I64[R1 + 23];
           _sacSd::I64 = I64[R1 + 31];
           _sacSf::I64 = I64[R1 + 47];
           _sacSg::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacSb::P64;
           P64[Hp - 32] = _sacSc::P64;
           I64[Hp - 24] = _sacSa::I64;
           I64[Hp - 16] = _sacSd::I64;
           I64[Hp - 8] = _sacSg::I64;
           I64[Hp] = _sacSf::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cae3B_info" {
     block_cae3B_info:
         const _cae3B;
         const 65;
         const 30;
 },
 GHC.IO.Handle.Internals.flushCharBuffer3_entry() //  [R2]
         { []
         }
     {offset
       cae3R: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cae3S; else goto cae3T;
       cae3S: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cae3T: // global
           I64[Sp - 8] = block_cae2E_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uae4Z; else goto cae2F;
       uae4Z: // global
           call _cae2E(R1) args: 0, res: 0, upd: 0;
       cae2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharBuffer3_info" {
     GHC.IO.Handle.Internals.flushCharBuffer3_info:
         const GHC.IO.Handle.Internals.flushCharBuffer3_entry;
         const 0;
         const 14;
         const 8589934597;
 },
 _cae2E() //  [R1]
         { []
         }
     {offset
       cae2E: // global
           I64[Sp - 32] = block_cae2J_info;
           _sacRl::P64 = P64[R1 + 47];
           _sacRn::P64 = P64[R1 + 63];
           _sacRo::P64 = P64[R1 + 71];
           _sacRr::P64 = P64[R1 + 95];
           R1 = P64[_sacRo::P64 + 8];
           P64[Sp - 24] = _sacRn::P64;
           P64[Sp - 16] = _sacRo::P64;
           P64[Sp - 8] = _sacRr::P64;
           P64[Sp] = _sacRl::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uae4T; else goto cae2K;
       uae4T: // global
           call _cae2J(R1) args: 0, res: 0, upd: 0;
       cae2K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae2E_info" {
     block_cae2E_info:
         const _cae2E;
         const 0;
         const 30;
 },
 _cae2J() //  [R1]
         { []
         }
     {offset
       cae2J: // global
           I64[Sp - 16] = block_cae2O_info;
           _sacRE::I64 = I64[R1 + 39];
           _sacRF::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sacRF::I64;
           I64[Sp] = _sacRE::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uae4U; else goto cae2P;
       uae4U: // global
           call _cae2O(R1) args: 0, res: 0, upd: 0;
       cae2P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae2J_info" {
     block_cae2J_info:
         const _cae2J;
         const 4;
         const 30;
 },
 _cae2O() //  [R1]
         { []
         }
     {offset
       cae2O: // global
           if (R1 & 7 != 1) goto cae4G; else goto cae4C;
       cae4C: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cae4G; else goto cae3Y;
       cae4G: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cae3Y: // global
           _sacRK::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp + 24] = block_cae2W_info;
           R1 = _sacRK::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uae4V; else goto cae2X;
       uae4V: // global
           call _cae2W(R1) args: 0, res: 0, upd: 0;
       cae2X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae2O_info" {
     block_cae2O_info:
         const _cae2O;
         const 198;
         const 30;
 },
 _cae2W() //  [R1]
         { []
         }
     {offset
       cae2W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cae41; else goto cae40;
       cae41: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cae40: // global
           _sacRo::P64 = P64[Sp + 8];
           _sacRM::P64 = P64[R1 + 7];
           _sacRN::P64 = P64[R1 + 15];
           _sacRQ::P64 = P64[_sacRo::P64 + 8];
           I64[Hp - 16] = sat_sacRY_info;
           P64[Hp] = _sacRQ::P64;
           call MO_WriteBarrier();
           P64[_sacRo::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacRo::P64);
           I64[Sp - 8] = block_cae3l_info;
           R1 = _sacRQ::P64;
           P64[Sp] = _sacRN::P64;
           P64[Sp + 8] = _sacRM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uae4W; else goto cae3m;
       uae4W: // global
           call _cae3l(R1) args: 0, res: 0, upd: 0;
       cae3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae2W_info" {
     block_cae2W_info:
         const _cae2W;
         const 3;
         const 30;
 },
 _cae3l() //  [R1]
         { []
         }
     {offset
       cae3l: // global
           _sacS7::I64 = I64[R1 + 39];
           if (_sacS7::I64 != 0) goto cae44; else goto cae4z;
       cae44: // global
           I64[Sp - 24] = block_cae3s_info;
           _sacS2::P64 = P64[R1 + 7];
           _sacS3::P64 = P64[R1 + 15];
           _sacS1::I64 = I64[R1 + 23];
           R1 = P64[Sp + 24];
           P64[Sp - 16] = _sacS3::P64;
           I64[Sp - 8] = _sacS7::I64;
           P64[Sp] = _sacS2::P64;
           I64[Sp + 24] = _sacS1::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uae4X; else goto cae3t;
       uae4X: // global
           call _cae3s(R1) args: 0, res: 0, upd: 0;
       cae3t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cae4z: // global
           _sacRl::P64 = P64[Sp + 32];
           _sacRN::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacRl::P64 + 8] = _sacRN::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacRl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cae3l_info" {
     block_cae3l_info:
         const _cae3l;
         const 4;
         const 30;
 },
 _cae3s() //  [R1]
         { []
         }
     {offset
       cae3s: // global
           if (R1 & 7 == 1) goto cae46; else goto cae4o;
       cae46: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cae49; else goto cae48;
       cae49: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cae48: // global
           I64[Hp - 24] = sat_sacSh_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sacRl::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sacRl::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacRl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cae4o: // global
           I64[Sp] = block_cae4c_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uae4Y; else goto cae4d;
       uae4Y: // global
           call _cae4c(R1) args: 0, res: 0, upd: 0;
       cae4d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae3s_info" {
     block_cae3s_info:
         const _cae3s;
         const 2183;
         const 30;
 },
 _cae4c() //  [R1]
         { []
         }
     {offset
       cae4c: // global
           I64[Sp - 8] = block_cae4h_info;
           R2 = P64[Sp + 40];
           _sacSl::P64 = P64[R1 + 7];
           _sacSm::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sacSm::P64;
           P64[Sp + 40] = _sacSl::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae4c_info" {
     block_cae4c_info:
         const _cae4c;
         const 2183;
         const 30;
 },
 _cae4h() //  [R1]
         { []
         }
     {offset
       cae4h: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cae4s; else goto cae4r;
       cae4s: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cae4r: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 56] = block_cae4k_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 48];
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae4h_info" {
     block_cae4h_info:
         const _cae4h;
         const 4360;
         const 30;
 },
 _cae4k() //  [R1]
         { []
         }
     {offset
       cae4k: // global
           I64[Sp] = block_cae4m_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uae50; else goto cae4u;
       uae50: // global
           call _cae4m(R1) args: 0, res: 0, upd: 0;
       cae4u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae4k_info" {
     block_cae4k_info:
         const _cae4k;
         const 1;
         const 30;
 },
 _cae4m() //  [R1]
         { []
         }
     {offset
       cae4m: // global
           _sacRl::P64 = P64[Sp + 8];
           _sacSy::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sacRl::P64 + 8] = _sacSy::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacRl::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cae4m_info" {
     block_cae4m_info:
         const _cae4m;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.864063861 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharReadBuffer_info;
 },
 GHC.IO.Handle.Internals.flushCharReadBuffer_entry() //  [R2]
         { []
         }
     {offset
       cae6O: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharReadBuffer_info" {
     GHC.IO.Handle.Internals.flushCharReadBuffer_info:
         const GHC.IO.Handle.Internals.flushCharReadBuffer_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.867509654 UTC

[section ""cstring" . lvl9_ra7Pp_bytes" {
     lvl9_ra7Pp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.869852092 UTC

[section ""data" . lvl10_ra7Pq_closure" {
     lvl10_ra7Pq_closure:
         const lvl10_ra7Pq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ra7Pq_entry() //  [R1]
         { []
         }
     {offset
       cae72: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae73; else goto cae74;
       cae73: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae74: // global
           (_cae6Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae6Z::I64 == 0) goto cae71; else goto cae70;
       cae71: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae70: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae6Z::I64;
           R2 = lvl9_ra7Pp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl10_ra7Pq_info" {
     lvl10_ra7Pq_info:
         const lvl10_ra7Pq_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.87383515 UTC

[section ""data" . lvl11_ra7Pr_closure" {
     lvl11_ra7Pr_closure:
         const lvl11_ra7Pr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_ra7Pr_entry() //  [R1]
         { []
         }
     {offset
       cae7j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae7k; else goto cae7l;
       cae7k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae7l: // global
           (_cae7g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae7g::I64 == 0) goto cae7i; else goto cae7h;
       cae7i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae7h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae7g::I64;
           R2 = GHC.IO.Handle.Internals.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl11_ra7Pr_info" {
     lvl11_ra7Pr_info:
         const lvl11_ra7Pr_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.877836878 UTC

[section ""data" . lvl12_ra7Ps_closure" {
     lvl12_ra7Ps_closure:
         const lvl12_ra7Ps_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ra7Ps_entry() //  [R1]
         { []
         }
     {offset
       cae7A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae7B; else goto cae7C;
       cae7B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae7C: // global
           (_cae7x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae7x::I64 == 0) goto cae7z; else goto cae7y;
       cae7z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae7y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae7x::I64;
           R2 = GHC.IO.Handle.Internals.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl12_ra7Ps_info" {
     lvl12_ra7Ps_info:
         const lvl12_ra7Ps_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.882306148 UTC

[section ""cstring" . lvl13_ra7Pt_bytes" {
     lvl13_ra7Pt_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.884441138 UTC

[section ""data" . lvl14_ra7Pu_closure" {
     lvl14_ra7Pu_closure:
         const lvl14_ra7Pu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ra7Pu_entry() //  [R1]
         { []
         }
     {offset
       cae7S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cae7T; else goto cae7U;
       cae7T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae7U: // global
           (_cae7P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae7P::I64 == 0) goto cae7R; else goto cae7Q;
       cae7R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae7Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae7P::I64;
           R2 = lvl13_ra7Pt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl14_ra7Pu_info" {
     lvl14_ra7Pu_info:
         const lvl14_ra7Pu_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.88792819 UTC

[section ""data" . lvl15_ra7Pv_closure" {
     lvl15_ra7Pv_closure:
         const GHC.Types.I#_con_info;
         const 487;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.889603941 UTC

[section ""data" . lvl16_ra7Pw_closure" {
     lvl16_ra7Pw_closure:
         const GHC.Types.I#_con_info;
         const 12;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.891344348 UTC

[section ""data" . lvl17_ra7Px_closure" {
     lvl17_ra7Px_closure:
         const GHC.Types.I#_con_info;
         const 68;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.893081368 UTC

[section ""data" . lvl18_ra7Py_closure" {
     lvl18_ra7Py_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl11_ra7Pr_closure;
         const lvl12_ra7Ps_closure;
         const lvl14_ra7Pu_closure;
         const lvl15_ra7Pv_closure+1;
         const lvl16_ra7Pw_closure+1;
         const lvl15_ra7Pv_closure+1;
         const lvl17_ra7Px_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.895232767 UTC

[section ""data" . lvl19_ra7Pz_closure" {
     lvl19_ra7Pz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl10_ra7Pq_closure;
         const lvl18_ra7Py_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.896947673 UTC

[section ""cstring" . lvl20_ra7PA_bytes" {
     lvl20_ra7PA_bytes:
         I8[] [105,110,116,101,114,110,97,108,32,73,79,32,108,105,98,114,97,114,121,32,101,114,114,111,114,58,32,67,104,97,114,32,98,117,102,102,101,114,32,110,111,110,45,101,109,112,116,121]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.899580354 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer2_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer2_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer2_entry() //  [R1]
         { []
         }
     {offset
       cae8h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cae8i; else goto cae8j;
       cae8i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cae8j: // global
           (_cae8c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cae8c::I64 == 0) goto cae8e; else goto cae8d;
       cae8e: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cae8d: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cae8c::I64;
           I64[Sp - 24] = block_cae8f_info;
           R2 = lvl20_ra7PA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharBuffer2_info" {
     GHC.IO.Handle.Internals.flushCharBuffer2_info:
         const GHC.IO.Handle.Internals.flushCharBuffer2_entry;
         const 0;
         const 12884901909;
         const Saded_srt+232;
 },
 _cae8f() //  [R1]
         { []
         }
     {offset
       cae8f: // global
           R3 = R1;
           R2 = lvl19_ra7Pz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cae8f_info" {
     block_cae8f_info:
         const _cae8f;
         const 0;
         const 12884901918;
         const Saded_srt+232;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.906492002 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer1_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer1_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer1_entry() //  [R2]
         { []
         }
     {offset
       cae8G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cae8K; else goto cae8L;
       cae8K: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushCharBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cae8L: // global
           I64[Sp - 8] = block_cae8D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uae9b; else goto cae8E;
       uae9b: // global
           call _cae8D(R1) args: 0, res: 0, upd: 0;
       cae8E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharBuffer1_info" {
     GHC.IO.Handle.Internals.flushCharBuffer1_info:
         const GHC.IO.Handle.Internals.flushCharBuffer1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Saded_srt+248;
 },
 _cae8D() //  [R1]
         { []
         }
     {offset
       cae8D: // global
           _sacSY::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_cae8J_info;
           _sacSF::P64 = R1;
           R1 = _sacSY::P64;
           P64[Sp] = _sacSF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uae9a; else goto cae8N;
       uae9a: // global
           call _cae8J(R1) args: 0, res: 0, upd: 0;
       cae8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae8D_info" {
     block_cae8D_info:
         const _cae8D;
         const 0;
         const 4294967326;
         const Saded_srt+256;
 },
 _cae8J() //  [R1]
         { []
         }
     {offset
       cae8J: // global
           I64[Sp - 16] = block_cae8R_info;
           _sacT4::I64 = I64[R1 + 39];
           _sacT5::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sacT5::I64;
           I64[Sp] = _sacT4::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uae9c; else goto cae8T;
       uae9c: // global
           call _cae8R(R1) args: 0, res: 0, upd: 0;
       cae8T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae8J_info" {
     block_cae8J_info:
         const _cae8J;
         const 1;
         const 4294967326;
         const Saded_srt+256;
 },
 _cae8R() //  [R1]
         { []
         }
     {offset
       cae8R: // global
           if (R1 & 7 == 1) goto cae8Z; else goto cae98;
       cae8Z: // global
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.flushCharBuffer3_entry(R2) args: 8, res: 0, upd: 8;
       cae98: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto cae97; else goto cae96;
       cae97: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cae96: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cae8R_info" {
     block_cae8R_info:
         const _cae8R;
         const 195;
         const 4294967326;
         const Saded_srt+256;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.915713835 UTC

[section ""data" . GHC.IO.Handle.Internals.flushCharBuffer_closure" {
     GHC.IO.Handle.Internals.flushCharBuffer_closure:
         const GHC.IO.Handle.Internals.flushCharBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushCharBuffer_entry() //  [R2]
         { []
         }
     {offset
       cae9H: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushCharBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushCharBuffer_info" {
     GHC.IO.Handle.Internals.flushCharBuffer_info:
         const GHC.IO.Handle.Internals.flushCharBuffer_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Saded_srt+248;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.922329764 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer2_closure" {
     GHC.IO.Handle.Internals.flushBuffer2_closure:
         const GHC.IO.Handle.Internals.flushBuffer2_info;
         const 0;
 },
 sat_sacTJ_entry() //  [R1]
         { []
         }
     {offset
       caeaj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeak; else goto caeal;
       caeak: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeal: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -(I64[R1 + 24] - I64[R1 + 16]);
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacTJ_info" {
     sat_sacTJ_info:
         const sat_sacTJ_entry;
         const 8589934592;
         const 20;
 },
 GHC.IO.Handle.Internals.flushBuffer2_entry() //  [R2]
         { []
         }
     {offset
       caeao: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caeap; else goto caeaq;
       caeap: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeaq: // global
           I64[Sp - 8] = block_cae9S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaeaR; else goto cae9T;
       uaeaR: // global
           call _cae9S(R1) args: 0, res: 0, upd: 0;
       cae9T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer2_info" {
     GHC.IO.Handle.Internals.flushBuffer2_info:
         const GHC.IO.Handle.Internals.flushBuffer2_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Saded_srt+264;
 },
 _cae9S() //  [R1]
         { []
         }
     {offset
       cae9S: // global
           I64[Sp - 24] = block_cae9X_info;
           _sacTc::P64 = P64[R1 + 7];
           _sacTf::P64 = P64[R1 + 31];
           _sacTh::P64 = P64[R1 + 47];
           R1 = P64[_sacTh::P64 + 8];
           P64[Sp - 16] = _sacTf::P64;
           P64[Sp - 8] = _sacTh::P64;
           P64[Sp] = _sacTc::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeaP; else goto cae9Y;
       uaeaP: // global
           call _cae9X(R1) args: 0, res: 0, upd: 0;
       cae9Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae9S_info" {
     block_cae9S_info:
         const _cae9S;
         const 0;
         const 4294967326;
         const Saded_srt+272;
 },
 _cae9X() //  [R1]
         { []
         }
     {offset
       cae9X: // global
           _sacTA::I64 = I64[R1 + 39];
           _sacTB::I64 = I64[R1 + 47];
           if (_sacTA::I64 == _sacTB::I64) goto caeaJ; else goto caeau;
       caeaJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caeau: // global
           I64[Sp - 48] = block_caea5_info;
           R2 = P64[Sp + 24];
           I64[Sp - 64] = stg_ap_pv_info;
           P64[Sp - 56] = P64[Sp + 8];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sacTA::I64;
           I64[Sp - 8] = _sacTB::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cae9X_info" {
     block_cae9X_info:
         const _cae9X;
         const 3;
         const 4294967326;
         const Saded_srt+272;
 },
 _caea5() //  [R1]
         { []
         }
     {offset
       caea5: // global
           I64[Sp] = block_caea7_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeaQ; else goto caea8;
       uaeaQ: // global
           call _caea7(R1) args: 0, res: 0, upd: 0;
       caea8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caea5_info" {
     block_caea5_info:
         const _caea5;
         const 3849;
         const 4294967326;
         const Saded_srt+272;
 },
 _caea7() //  [R1]
         { []
         }
     {offset
       caea7: // global
           if (R1 & 7 == 1) goto caeaz; else goto caeaB;
       caeaz: // global
           R1 = GHC.IO.Handle.Internals.flushBuffer3_closure;
           Sp = Sp + 80;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caeaB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caeaE; else goto caeaD;
       caeaE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeaD: // global
           I64[Hp - 24] = sat_sacTJ_info;
           I64[Hp - 8] = I64[Sp + 32];
           I64[Hp] = I64[Sp + 40];
           I64[Sp] = block_caeaA_info;
           R2 = P64[Sp + 72];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 16] = GHC.IO.Device.RelativeSeek_closure+2;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caea7_info" {
     block_caea7_info:
         const _caea7;
         const 3849;
         const 4294967326;
         const Saded_srt+272;
 },
 _caeaA() //  [R1]
         { []
         }
     {offset
       caeaA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caeaI; else goto caeaH;
       caeaI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeaH: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sacTh::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sacTh::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTh::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeaA_info" {
     block_caeaA_info:
         const _caeaA;
         const 24329;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.936724457 UTC

[section ""data" . GHC.IO.Handle.Internals.flushByteReadBuffer_closure" {
     GHC.IO.Handle.Internals.flushByteReadBuffer_closure:
         const GHC.IO.Handle.Internals.flushByteReadBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushByteReadBuffer_entry() //  [R2]
         { []
         }
     {offset
       caebW: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushByteReadBuffer_info" {
     GHC.IO.Handle.Internals.flushByteReadBuffer_info:
         const GHC.IO.Handle.Internals.flushByteReadBuffer_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Saded_srt+264;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.948286849 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer1_closure" {
     GHC.IO.Handle.Internals.flushBuffer1_closure:
         const GHC.IO.Handle.Internals.flushBuffer1_info;
         const 0;
 },
 sat_sacUL_entry() //  [R1]
         { []
         }
     {offset
       caecL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caecP; else goto caecQ;
       caecP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caecQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caecI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaecU; else goto caecJ;
       uaecU: // global
           call _caecI(R1) args: 0, res: 0, upd: 0;
       caecJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacUL_info" {
     sat_sacUL_info:
         const sat_sacUL_entry;
         const 1;
         const 16;
 },
 _caecI() //  [R1]
         { []
         }
     {offset
       caecI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caecT; else goto caecS;
       caecT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caecS: // global
           _sacUG::P64 = P64[R1 + 7];
           _sacUH::P64 = P64[R1 + 15];
           _sacUF::I64 = I64[R1 + 23];
           _sacUI::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacUG::P64;
           P64[Hp - 32] = _sacUH::P64;
           I64[Hp - 24] = _sacUF::I64;
           I64[Hp - 16] = _sacUI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caecI_info" {
     block_caecI_info:
         const _caecI;
         const 0;
         const 30;
 },
 sat_sacV4_entry() //  [R1]
         { []
         }
     {offset
       caedh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caedo; else goto caedp;
       caedo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caedp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caede_info;
           _sacUU::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sacUU::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaedt; else goto caedf;
       uaedt: // global
           call _caede(R1) args: 0, res: 0, upd: 0;
       caedf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sacV4_info" {
     sat_sacV4_info:
         const sat_sacV4_entry;
         const 4294967297;
         const 19;
 },
 _caede() //  [R1]
         { []
         }
     {offset
       caede: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caeds; else goto caedr;
       caeds: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caedr: // global
           _sacUY::P64 = P64[R1 + 7];
           _sacUZ::P64 = P64[R1 + 15];
           _sacUX::I64 = I64[R1 + 23];
           _sacV0::I64 = I64[R1 + 31];
           _sacV2::I64 = I64[R1 + 47];
           _sacV3::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacUY::P64;
           P64[Hp - 32] = _sacUZ::P64;
           I64[Hp - 24] = _sacUX::I64;
           I64[Hp - 16] = _sacV0::I64;
           I64[Hp - 8] = _sacV3::I64;
           I64[Hp] = _sacV2::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caede_info" {
     block_caede_info:
         const _caede;
         const 65;
         const 30;
 },
 GHC.IO.Handle.Internals.flushBuffer1_entry() //  [R2]
         { []
         }
     {offset
       caedu: // global
           if ((Sp + -80) < SpLim) (likely: False) goto caedv; else goto caedw;
       caedv: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.flushBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caedw: // global
           I64[Sp - 8] = block_caec7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaef6; else goto caec8;
       uaef6: // global
           call _caec7(R1) args: 0, res: 0, upd: 0;
       caec8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer1_info" {
     GHC.IO.Handle.Internals.flushBuffer1_info:
         const GHC.IO.Handle.Internals.flushBuffer1_entry;
         const 0;
         const 21474836494;
         const 8589934597;
         const Saded_srt+264;
 },
 _caec7() //  [R1]
         { []
         }
     {offset
       caec7: // global
           I64[Sp - 56] = block_caecc_info;
           _sacTR::P64 = R1;
           _sacTT::P64 = P64[R1 + 15];
           _sacTV::P64 = P64[R1 + 31];
           _sacTX::P64 = P64[R1 + 47];
           _sacTZ::P64 = P64[R1 + 63];
           _sacU0::P64 = P64[R1 + 71];
           _sacU3::P64 = P64[R1 + 95];
           R1 = P64[_sacU0::P64 + 8];
           P64[Sp - 48] = _sacTT::P64;
           P64[Sp - 40] = _sacTV::P64;
           P64[Sp - 32] = _sacTX::P64;
           P64[Sp - 24] = _sacTZ::P64;
           P64[Sp - 16] = _sacU0::P64;
           P64[Sp - 8] = _sacU3::P64;
           P64[Sp] = _sacTR::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaeeX; else goto caecd;
       uaeeX: // global
           call _caecc(R1) args: 0, res: 0, upd: 0;
       caecd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caec7_info" {
     block_caec7_info:
         const _caec7;
         const 0;
         const 4294967326;
         const Saded_srt+264;
 },
 _caecc() //  [R1]
         { []
         }
     {offset
       caecc: // global
           I64[Sp] = block_caech_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaeeY; else goto caeci;
       uaeeY: // global
           call _caech(R1) args: 0, res: 0, upd: 0;
       caeci: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caecc_info" {
     block_caecc_info:
         const _caecc;
         const 7;
         const 4294967326;
         const Saded_srt+264;
 },
 _caech() //  [R1]
         { []
         }
     {offset
       caech: // global
           if (R1 & 7 == 1) goto caedB; else goto caees;
       caedB: // global
           _sacUl::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_caecm_info;
           R1 = _sacUl::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaeeZ; else goto caecn;
       uaeeZ: // global
           call _caecm(R1) args: 0, res: 0, upd: 0;
       caecn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caees: // global
           _sacVr::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_caeeq_info;
           R1 = _sacVr::P64;
           if (R1 & 7 != 0) goto uaef0; else goto caeet;
       uaef0: // global
           call _caeeq(R1) args: 0, res: 0, upd: 0;
       caeet: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caech_info" {
     block_caech_info:
         const _caech;
         const 7;
         const 4294967326;
         const Saded_srt+264;
 },
 _caecm() //  [R1]
         { []
         }
     {offset
       caecm: // global
           I64[Sp - 16] = block_caecr_info;
           _sacUr::I64 = I64[R1 + 39];
           _sacUs::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sacUs::I64;
           I64[Sp] = _sacUr::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaef1; else goto caecs;
       uaef1: // global
           call _caecr(R1) args: 0, res: 0, upd: 0;
       caecs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caecm_info" {
     block_caecm_info:
         const _caecm;
         const 5;
         const 4294967326;
         const Saded_srt+264;
 },
 _caecr() //  [R1]
         { []
         }
     {offset
       caecr: // global
           _sacTR::P64 = P64[Sp + 56];
           if (R1 & 7 != 1) goto caeen; else goto caeej;
       caeej: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto caeen; else goto caedF;
       caeen: // global
           R2 = _sacTR::P64;
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       caedF: // global
           _sacUx::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_caecz_info;
           R1 = _sacUx::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaef2; else goto caecA;
       uaef2: // global
           call _caecz(R1) args: 0, res: 0, upd: 0;
       caecA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caecr_info" {
     block_caecr_info:
         const _caecr;
         const 199;
         const 4294967326;
         const Saded_srt+264;
 },
 _caecz() //  [R1]
         { []
         }
     {offset
       caecz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caedI; else goto caedH;
       caedI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caedH: // global
           _sacU0::P64 = P64[Sp + 24];
           _sacUz::P64 = P64[R1 + 7];
           _sacUA::P64 = P64[R1 + 15];
           _sacUD::P64 = P64[_sacU0::P64 + 8];
           I64[Hp - 16] = sat_sacUL_info;
           P64[Hp] = _sacUD::P64;
           call MO_WriteBarrier();
           P64[_sacU0::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacU0::P64);
           I64[Sp] = block_caecY_info;
           R1 = _sacUD::P64;
           P64[Sp + 16] = _sacUA::P64;
           P64[Sp + 24] = _sacUz::P64;
           if (R1 & 7 != 0) goto uaef3; else goto caecZ;
       uaef3: // global
           call _caecY(R1) args: 0, res: 0, upd: 0;
       caecZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caecz_info" {
     block_caecz_info:
         const _caecz;
         const 133;
         const 4294967326;
         const Saded_srt+264;
 },
 _caecY() //  [R1]
         { []
         }
     {offset
       caecY: // global
           _sacUU::I64 = I64[R1 + 39];
           if (_sacUU::I64 != 0) goto caedL; else goto caeeg;
       caedL: // global
           I64[Sp - 24] = block_caed5_info;
           _sacUP::P64 = P64[R1 + 7];
           _sacUQ::P64 = P64[R1 + 15];
           _sacUO::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sacUQ::P64;
           I64[Sp - 8] = _sacUU::I64;
           P64[Sp] = _sacUP::P64;
           I64[Sp + 32] = _sacUO::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaef4; else goto caed6;
       uaef4: // global
           call _caed5(R1) args: 0, res: 0, upd: 0;
       caed6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caeeg: // global
           _sacTR::P64 = P64[Sp + 40];
           _sacTX::P64 = P64[Sp + 8];
           _sacUA::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sacTX::P64 + 8] = _sacUA::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTX::P64);
           R2 = _sacTR::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caecY_info" {
     block_caecY_info:
         const _caecY;
         const 5;
         const 4294967326;
         const Saded_srt+264;
 },
 _caed5() //  [R1]
         { []
         }
     {offset
       caed5: // global
           if (R1 & 7 == 1) goto caedN; else goto caee5;
       caedN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caedQ; else goto caedP;
       caedQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caedP: // global
           I64[Hp - 24] = sat_sacV4_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sacTR::P64 = P64[Sp + 64];
           _sacTX::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sacTX::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTX::P64);
           R2 = _sacTR::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
       caee5: // global
           I64[Sp] = block_caedT_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaef5; else goto caedU;
       uaef5: // global
           call _caedT(R1) args: 0, res: 0, upd: 0;
       caedU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caed5_info" {
     block_caed5_info:
         const _caed5;
         const 4232;
         const 4294967326;
         const Saded_srt+264;
 },
 _caedT() //  [R1]
         { []
         }
     {offset
       caedT: // global
           I64[Sp - 8] = block_caedY_info;
           R2 = P64[Sp + 48];
           _sacV8::P64 = P64[R1 + 7];
           _sacV9::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sacV9::P64;
           P64[Sp + 48] = _sacV8::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caedT_info" {
     block_caedT_info:
         const _caedT;
         const 4232;
         const 4294967326;
         const Saded_srt+264;
 },
 _caedY() //  [R1]
         { []
         }
     {offset
       caedY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caee9; else goto caee8;
       caee9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caee8: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_caee1_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caedY_info" {
     block_caedY_info:
         const _caedY;
         const 8457;
         const 4294967326;
         const Saded_srt+264;
 },
 _caee1() //  [R1]
         { []
         }
     {offset
       caee1: // global
           I64[Sp] = block_caee3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaef7; else goto caeeb;
       uaef7: // global
           call _caee3(R1) args: 0, res: 0, upd: 0;
       caeeb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caee1_info" {
     block_caee1_info:
         const _caee1;
         const 901;
         const 4294967326;
         const Saded_srt+264;
 },
 _caee3() //  [R1]
         { []
         }
     {offset
       caee3: // global
           _sacTR::P64 = P64[Sp + 40];
           _sacTX::P64 = P64[Sp + 8];
           _sacVl::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sacTX::P64 + 8] = _sacVl::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTX::P64);
           R2 = _sacTR::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caee3_info" {
     block_caee3_info:
         const _caee3;
         const 901;
         const 4294967326;
         const Saded_srt+264;
 },
 _caeeq() //  [R1]
         { []
         }
     {offset
       caeeq: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto caeeG; else goto caeeD;
       caeeG: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caeeD: // global
           _sacTV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caeeB_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacTV::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeeq_info" {
     block_caeeq_info:
         const _caeeq;
         const 7687;
         const 30;
 },
 _caeeB() //  [R1]
         { []
         }
     {offset
       caeeB: // global
           _sacTX::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacTX::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacTX::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeeB_info" {
     block_caeeB_info:
         const _caeeB;
         const 1925;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.984842295 UTC

[section ""data" . GHC.IO.Handle.Internals.flushBuffer_closure" {
     GHC.IO.Handle.Internals.flushBuffer_closure:
         const GHC.IO.Handle.Internals.flushBuffer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.flushBuffer_entry() //  [R2]
         { []
         }
     {offset
       caehh: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.flushBuffer_info" {
     GHC.IO.Handle.Internals.flushBuffer_info:
         const GHC.IO.Handle.Internals.flushBuffer_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Saded_srt+280;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.987835325 UTC

[section ""cstring" . lvl21_ra7PB_bytes" {
     lvl21_ra7PB_bytes:
         I8[] [71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,56,56,49,58,55,45,51,48,124,74,117,115,116,32,100,101,99,111,100,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:15.990017832 UTC

[section ""data" . lvl22_ra7PC_closure" {
     lvl22_ra7PC_closure:
         const lvl22_ra7PC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ra7PC_entry() //  [R1]
         { []
         }
     {offset
       caehv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caehw; else goto caehx;
       caehw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caehx: // global
           (_caehs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caehs::I64 == 0) goto caehu; else goto caeht;
       caehu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caeht: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caehs::I64;
           R2 = lvl21_ra7PB_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl22_ra7PC_info" {
     lvl22_ra7PC_info:
         const lvl22_ra7PC_entry;
         const 0;
         const 4294967317;
         const Saded_srt+288;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.01039629 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_2_closure" {
     GHC.IO.Handle.Internals.hLookAhead_2_closure:
         const GHC.IO.Handle.Internals.hLookAhead_2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_2_entry() //  [R2, R3]
         { []
         }
     {offset
       caehN: // global
           if ((Sp + -72) < SpLim) (likely: False) goto caehR; else goto caehS;
       caehR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caehS: // global
           I64[Sp - 16] = block_caehK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaeki; else goto caehL;
       uaeki: // global
           call _caehK(R1) args: 0, res: 0, upd: 0;
       caehL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hLookAhead_2_info" {
     GHC.IO.Handle.Internals.hLookAhead_2_info:
         const GHC.IO.Handle.Internals.hLookAhead_2_entry;
         const 0;
         const 13836183959483973646;
         const 12884901903;
         const Saded_srt+56;
 },
 _caehK() //  [R1]
         { []
         }
     {offset
       caehK: // global
           I64[Sp - 48] = block_caehQ_info;
           _sacVH::P64 = R1;
           _sacVJ::P64 = P64[R1 + 15];
           _sacVL::P64 = P64[R1 + 31];
           _sacVN::P64 = P64[R1 + 47];
           _sacVP::P64 = P64[R1 + 63];
           _sacVT::P64 = P64[R1 + 95];
           R1 = P64[_sacVN::P64 + 8];
           P64[Sp - 40] = _sacVJ::P64;
           P64[Sp - 32] = _sacVL::P64;
           P64[Sp - 24] = _sacVN::P64;
           P64[Sp - 16] = _sacVP::P64;
           P64[Sp - 8] = _sacVT::P64;
           P64[Sp] = _sacVH::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uaekh; else goto caehU;
       uaekh: // global
           call _caehQ(R1) args: 0, res: 0, upd: 0;
       caehU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caehK_info" {
     block_caehK_info:
         const _caehK;
         const 1;
         const 9224497941056585758;
         const Saded_srt+56;
 },
 _caehQ() //  [R1]
         { []
         }
     {offset
       caehQ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto caek2; else goto caejR;
       caek2: // global
           _sacVL::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caejU_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacVL::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       caejR: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sacW8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caehQ_info" {
     block_caehQ_info:
         const _caehQ;
         const 7;
         const 9224497941056585758;
         const Saded_srt+56;
 },
 _caejU() //  [R1]
         { []
         }
     {offset
       caejU: // global
           I64[Sp] = block_caejW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaekt; else goto caejX;
       uaekt: // global
           call _caejW(R1) args: 0, res: 0, upd: 0;
       caejX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caejU_info" {
     block_caejU_info:
         const _caejU;
         const 5;
         const 9224497941056585758;
         const Saded_srt+56;
 },
 _caejW() //  [R1]
         { []
         }
     {offset
       caejW: // global
           I64[Sp - 8] = block_caek1_info;
           _sacXt::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sacXt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaeku; else goto caek5;
       uaeku: // global
           call _caek1(R1) args: 0, res: 0, upd: 0;
       caek5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caejW_info" {
     block_caejW_info:
         const _caejW;
         const 5;
         const 9224497941056585758;
         const Saded_srt+56;
 },
 _caek1() //  [R1]
         { []
         }
     {offset
       caek1: // global
           if (I64[R1 + 7] == 0) goto caekd; else goto caekc;
       caekd: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 56;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caekc: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _sacW8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caek1_info" {
     block_caek1_info:
         const _caek1;
         const 6;
         const 9224497941056585758;
         const Saded_srt+56;
 },
 _sacW8() //  []
         { []
         }
     {offset
       sacW8: // global
           I64[Sp - 8] = block_caei4_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaekw; else goto caei6;
       uaekw: // global
           call _caei4(R1) args: 0, res: 0, upd: 0;
       caei6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caei4() //  [R1]
         { []
         }
     {offset
       caei4: // global
           if (R1 & 7 == 1) goto caeiv; else goto caejo;
       caeiv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeiy; else goto caeix;
       caeiy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeix: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sacWa::P64 = P64[Sp + 8];
           P64[Hp] = _sacWa::P64;
           _sacVF::P64 = P64[Sp + 48];
           _sacVP::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sacVP::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacVP::P64);
           I64[Sp + 8] = block_caeie_info;
           R3 = _sacVF::P64;
           R2 = _sacWa::P64;
           Sp = Sp + 8;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       caejo: // global
           I64[Sp] = block_caeiW_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaekk; else goto caeiX;
       uaekk: // global
           call _caeiW(R1) args: 0, res: 0, upd: 0;
       caeiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caei4_info" {
     block_caei4_info:
         const _caei4;
         const 518;
         const 35188667056158;
         const Saded_srt+200;
 },
 _caeie() //  [R1]
         { []
         }
     {offset
       caeie: // global
           I64[Sp] = block_caeig_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaekl; else goto caeih;
       uaekl: // global
           call _caeig(R1) args: 0, res: 0, upd: 0;
       caeih: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeie_info" {
     block_caeie_info:
         const _caeie;
         const 389;
         const 4294967326;
         const Saded_srt+304;
 },
 _caeig() //  [R1]
         { []
         }
     {offset
       caeig: // global
           _sacVN::P64 = P64[Sp + 8];
           _sacWj::P64 = P64[R1 + 15];
           _sacWk::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sacVN::P64 + 8] = _sacWj::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacVN::P64);
           I64[Sp + 16] = block_caeio_info;
           R1 = _sacWk::P64;
           P64[Sp + 24] = _sacWj::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaekm; else goto caeip;
       uaekm: // global
           call _caeio(R1) args: 0, res: 0, upd: 0;
       caeip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeig_info" {
     block_caeig_info:
         const _caeig;
         const 389;
         const 4294967326;
         const Saded_srt+304;
 },
 _caeio() //  [R1]
         { []
         }
     {offset
       caeio: // global
           I64[Sp - 8] = block_caeit_info;
           _sacWm::P64 = R1;
           _sacWs::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sacWs::I64;
           P64[Sp + 24] = _sacWm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaekn; else goto caeiC;
       uaekn: // global
           call _caeit(R1) args: 0, res: 0, upd: 0;
       caeiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeio_info" {
     block_caeio_info:
         const _caeio;
         const 3;
         const 4294967326;
         const Saded_srt+304;
 },
 _caeit() //  [R1]
         { []
         }
     {offset
       caeit: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto caeiO; else goto caeiK;
       caeiO: // global
           _sacWj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caeiN_info;
           _sacWt::P64 = R1;
           R1 = _sacWj::P64;
           P64[Sp + 32] = _sacWt::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaeko; else goto caeiP;
       uaeko: // global
           call _caeiN(R1) args: 0, res: 0, upd: 0;
       caeiP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caeiK: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeit_info" {
     block_caeit_info:
         const _caeit;
         const 68;
         const 4294967326;
         const Saded_srt+304;
 },
 _caeiN() //  [R1]
         { []
         }
     {offset
       caeiN: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeiN_info" {
     block_caeiN_info:
         const _caeiN;
         const 2;
         const 4294967326;
         const Saded_srt+304;
 },
 _caeiW() //  [R1]
         { []
         }
     {offset
       caeiW: // global
           I64[Sp - 8] = block_caej1_info;
           _sacWK::P64 = P64[R1 + 7];
           _sacWL::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sacWL::P64;
           P64[Sp + 32] = _sacWK::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeiW_info" {
     block_caeiW_info:
         const _caeiW;
         const 518;
         const 4294967326;
         const Saded_srt+304;
 },
 _caej1() //  [R1]
         { []
         }
     {offset
       caej1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caejs; else goto caejr;
       caejs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caejr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sacWa::P64 = P64[Sp + 16];
           P64[Hp] = _sacWa::P64;
           _sacVF::P64 = P64[Sp + 56];
           _sacVP::P64 = P64[Sp + 32];
           _sacWK::P64 = P64[Sp + 40];
           _sacWL::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacVP::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacVP::P64);
           I64[Sp + 16] = block_caej7_info;
           R5 = _sacVF::P64;
           R4 = _sacWa::P64;
           R3 = _sacWL::P64;
           R2 = _sacWK::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caej1_info" {
     block_caej1_info:
         const _caej1;
         const 7;
         const 4294967326;
         const Saded_srt+304;
 },
 _caej7() //  [R1]
         { []
         }
     {offset
       caej7: // global
           I64[Sp] = block_caej9_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaekp; else goto caeja;
       uaekp: // global
           call _caej9(R1) args: 0, res: 0, upd: 0;
       caeja: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caej7_info" {
     block_caej7_info:
         const _caej7;
         const 389;
         const 4294967326;
         const Saded_srt+304;
 },
 _caej9() //  [R1]
         { []
         }
     {offset
       caej9: // global
           _sacVN::P64 = P64[Sp + 8];
           _sacWY::P64 = P64[R1 + 7];
           _sacWZ::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sacVN::P64 + 8] = _sacWY::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacVN::P64);
           I64[Sp + 16] = block_caejh_info;
           R1 = _sacWZ::P64;
           P64[Sp + 24] = _sacWY::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaekq; else goto caeji;
       uaekq: // global
           call _caejh(R1) args: 0, res: 0, upd: 0;
       caeji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caej9_info" {
     block_caej9_info:
         const _caej9;
         const 389;
         const 4294967326;
         const Saded_srt+304;
 },
 _caejh() //  [R1]
         { []
         }
     {offset
       caejh: // global
           I64[Sp - 8] = block_caejm_info;
           _sacX1::P64 = R1;
           _sacX7::I64 = I64[R1 + 47];
           R1 = P64[Sp + 24];
           I64[Sp] = _sacX7::I64;
           P64[Sp + 24] = _sacX1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaekr; else goto caejw;
       uaekr: // global
           call _caejm(R1) args: 0, res: 0, upd: 0;
       caejw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caejh_info" {
     block_caejh_info:
         const _caejh;
         const 3;
         const 4294967326;
         const Saded_srt+304;
 },
 _caejm() //  [R1]
         { []
         }
     {offset
       caejm: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto caejI; else goto caejE;
       caejI: // global
           _sacWY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caejH_info;
           _sacX8::P64 = R1;
           R1 = _sacWY::P64;
           P64[Sp + 32] = _sacX8::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaeks; else goto caejJ;
       uaeks: // global
           call _caejH(R1) args: 0, res: 0, upd: 0;
       caejJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caejE: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caejm_info" {
     block_caejm_info:
         const _caejm;
         const 68;
         const 4294967326;
         const Saded_srt+304;
 },
 _caejH() //  [R1]
         { []
         }
     {offset
       caejH: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caejH_info" {
     block_caejH_info:
         const _caejH;
         const 2;
         const 4294967326;
         const Saded_srt+304;
 },
 section ""data" . GHC.IO.Handle.Internals.$wreadTextDevice'_closure" {
     GHC.IO.Handle.Internals.$wreadTextDevice'_closure:
         const GHC.IO.Handle.Internals.$wreadTextDevice'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_slow() //  [R1]
         { []
         }
     {offset
       caeky: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wreadTextDevice'_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaenL_srtd" {
     uaenL_srtd:
         const Saded_srt+56;
         const 33;
         const 7516192769;
 },
 GHC.IO.Handle.Internals.$wreadTextDevice'_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { []
         }
     {offset
       caekF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cael5; else goto uaeno;
       cael5: // global
           R1 = GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       uaeno: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _caekz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wreadTextDevice'_info" {
     GHC.IO.Handle.Internals.$wreadTextDevice'_info:
         const GHC.IO.Handle.Internals.$wreadTextDevice'_entry;
         const 0;
         const 18446744069414584334;
         const 38654705664;
         const uaenL_srtd;
         const 7304;
         const GHC.IO.Handle.Internals.$wreadTextDevice'_slow;
 },
 _caekz() //  []
         { []
         }
     {offset
       caekz: // global
           _sacXy::P64 = P64[Sp];
           I64[Sp] = block_caekC_info;
           R1 = _sacXy::P64;
           if (R1 & 7 != 0) goto uaens; else goto caekD;
       uaens: // global
           call _caekC(R1) args: 0, res: 0, upd: 0;
       caekD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uaenM_srtd" {
     uaenM_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caekC() //  [R1]
         { []
         }
     {offset
       caekC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cael9; else goto cael8;
       cael9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cael8: // global
           _sacXz::I64 = I64[Sp + 8];
           _sacXA::P64 = P64[Sp + 16];
           _sacXB::P64 = P64[Sp + 24];
           _sacXC::I64 = I64[Sp + 32];
           _sacXD::I64 = I64[Sp + 40];
           _sacXJ::P64 = P64[R1 + 15];
           _sacXL::P64 = P64[R1 + 31];
           _sacXN::P64 = P64[R1 + 47];
           _sacXP::P64 = P64[R1 + 63];
           _sacXT::P64 = P64[R1 + 95];
           _sacXY::I64 = I64[Sp + 48] - _sacXD::I64;
           (_sacY4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_sacXz::I64, _sacXz::I64 + _sacXD::I64, _sacXY::I64);
           call MO_Touch(_sacXA::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sacXA::P64;
           P64[Hp - 32] = _sacXB::P64;
           I64[Hp - 24] = _sacXz::I64;
           I64[Hp - 16] = _sacXC::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sacXY::I64;
           I64[Sp + 16] = block_caekX_info;
           R2 = _sacXJ::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sacXL::P64;
           P64[Sp + 8] = Hp - 47;
           P64[Sp + 24] = _sacXT::P64;
           P64[Sp + 32] = _sacXP::P64;
           P64[Sp + 40] = _sacXN::P64;
           P64[Sp + 48] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caekC_info" {
     block_caekC_info:
         const _caekC;
         const 3655;
         const 18446744069414584350;
         const uaenM_srtd;
 },
 section ""relreadonly" . uaenN_srtd" {
     uaenN_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caekX() //  [R1]
         { []
         }
     {offset
       caekX: // global
           I64[Sp] = block_caekZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaenu; else goto cael0;
       uaenu: // global
           call _caekZ(R1) args: 0, res: 0, upd: 0;
       cael0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caekX_info" {
     block_caekX_info:
         const _caekX;
         const 5;
         const 18446744069414584350;
         const uaenN_srtd;
 },
 section ""relreadonly" . uaenO_srtd" {
     uaenO_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caekZ() //  [R1]
         { []
         }
     {offset
       caekZ: // global
           I64[Sp - 8] = block_cael4_info;
           _sacYc::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sacYc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaenv; else goto caelc;
       uaenv: // global
           call _cael4(R1) args: 0, res: 0, upd: 0;
       caelc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caekZ_info" {
     block_caekZ_info:
         const _caekZ;
         const 5;
         const 18446744069414584350;
         const uaenO_srtd;
 },
 section ""relreadonly" . uaenP_srtd" {
     uaenP_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _cael4() //  [R1]
         { []
         }
     {offset
       cael4: // global
           if (I64[R1 + 7] == 0) goto caemp; else goto caell;
       caemp: // global
           _sacYc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caemo_info;
           R1 = _sacYc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaenx; else goto caemq;
       uaenx: // global
           call _caemo(R1) args: 0, res: 0, upd: 0;
       caemq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caell: // global
           I64[Sp] = block_caelj_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto uaenw; else goto caelm;
       uaenw: // global
           call _caelj(R1) args: 0, res: 0, upd: 0;
       caelm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cael4_info" {
     block_cael4_info:
         const _cael4;
         const 6;
         const 18446744069414584350;
         const uaenP_srtd;
 },
 section ""relreadonly" . uaenQ_srtd" {
     uaenQ_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caemo() //  [R1]
         { []
         }
     {offset
       caemo: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto caenl; else goto caemA;
       caenl: // global
           R1 = GHC.IO.Handle.Internals.hLookAhead_3_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caemA: // global
           _sacXT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caemy_info;
           _sacYX::P64 = R1;
           R1 = _sacXT::P64;
           P64[Sp + 16] = _sacYX::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaenF; else goto caemB;
       uaenF: // global
           call _caemy(R1) args: 0, res: 0, upd: 0;
       caemB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caemo_info" {
     block_caemo_info:
         const _caemo;
         const 133;
         const 18446744069414584350;
         const uaenQ_srtd;
 },
 _caemy() //  [R1]
         { []
         }
     {offset
       caemy: // global
           if (R1 & 7 == 1) goto uaenr; else goto caen6;
       uaenr: // global
           Sp = Sp + 40;
           call _caemH() args: 0, res: 0, upd: 0;
       caen6: // global
           I64[Sp] = block_caemK_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaenG; else goto caemL;
       uaenG: // global
           call _caemK(R1) args: 0, res: 0, upd: 0;
       caemL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caemy_info" {
     block_caemy_info:
         const _caemy;
         const 4;
         const 21474836510;
         const Saded_srt+296;
 },
 _caemK() //  [R1]
         { []
         }
     {offset
       caemK: // global
           _sacYX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caemP_info;
           R3 = P64[Sp + 32];
           R2 = _sacYX::P64;
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caemK_info" {
     block_caemK_info:
         const _caemK;
         const 4;
         const 4294967326;
         const Saded_srt+296;
 },
 _caemP() //  [R1]
         { []
         }
     {offset
       caemP: // global
           I64[Sp] = block_caemR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaenI; else goto caemS;
       uaenI: // global
           call _caemR(R1) args: 0, res: 0, upd: 0;
       caemS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caemP_info" {
     block_caemP_info:
         const _caemP;
         const 3;
         const 4294967326;
         const Saded_srt+296;
 },
 _caemR() //  [R1]
         { []
         }
     {offset
       caemR: // global
           _sacXN::P64 = P64[Sp + 8];
           _sacZi::P64 = P64[R1 + 7];
           _sacZj::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sacXN::P64 + 8] = _sacZi::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacXN::P64);
           I64[Sp + 8] = block_caemZ_info;
           R1 = _sacZj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaenJ; else goto caen0;
       uaenJ: // global
           call _caemZ(R1) args: 0, res: 0, upd: 0;
       caen0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caemR_info" {
     block_caemR_info:
         const _caemR;
         const 3;
         const 4294967326;
         const Saded_srt+296;
 },
 _caemZ() //  [R1]
         { []
         }
     {offset
       caemZ: // global
           I64[Sp - 8] = block_caen4_info;
           _sacZl::P64 = R1;
           _sacZr::I64 = I64[R1 + 47];
           R1 = P64[Sp + 16];
           I64[Sp] = _sacZr::I64;
           P64[Sp + 16] = _sacZl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaenK; else goto caenb;
       uaenK: // global
           call _caen4(R1) args: 0, res: 0, upd: 0;
       caenb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caemZ_info" {
     block_caemZ_info:
         const _caemZ;
         const 2;
         const 4294967326;
         const Saded_srt+296;
 },
 _caen4() //  [R1]
         { []
         }
     {offset
       caen4: // global
           _sacZl::P64 = P64[Sp + 24];
           if (I64[Sp + 8] == I64[R1 + 47]) goto caenk; else goto caenj;
       caenk: // global
           R3 = _sacZl::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
       caenj: // global
           R1 = _sacZl::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caen4_info" {
     block_caen4_info:
         const _caen4;
         const 67;
         const 4294967326;
         const Saded_srt+296;
 },
 section ""relreadonly" . uaenR_srtd" {
     uaenR_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelj() //  [R1]
         { []
         }
     {offset
       caelj: // global
           if (R1 & 7 == 1) goto uaenp; else goto caelX;
       uaenp: // global
           Sp = Sp + 56;
           call _caemH() args: 0, res: 0, upd: 0;
       caelX: // global
           I64[Sp] = block_caelv_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaeny; else goto caelw;
       uaeny: // global
           call _caelv(R1) args: 0, res: 0, upd: 0;
       caelw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caelj_info" {
     block_caelj_info:
         const _caelj;
         const 134;
         const 18446744069414584350;
         const uaenR_srtd;
 },
 _caemH() //  []
         { []
         }
     {offset
       caemH: // global
           R1 = lvl22_ra7PC_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uaenS_srtd" {
     uaenS_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelv() //  [R1]
         { []
         }
     {offset
       caelv: // global
           I64[Sp - 8] = block_caelA_info;
           _sacYk::P64 = P64[R1 + 7];
           _sacYl::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp] = _sacYl::P64;
           P64[Sp + 16] = _sacYk::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caelv_info" {
     block_caelv_info:
         const _caelv;
         const 134;
         const 18446744069414584350;
         const uaenS_srtd;
 },
 section ""relreadonly" . uaenT_srtd" {
     uaenT_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelA() //  [R1]
         { []
         }
     {offset
       caelA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caem1; else goto caem0;
       caem1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caem0: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sacYc::P64 = P64[Sp + 16];
           P64[Hp] = _sacYc::P64;
           _sacXF::P64 = P64[Sp + 56];
           _sacXP::P64 = P64[Sp + 32];
           _sacYk::P64 = P64[Sp + 24];
           _sacYl::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacXP::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacXP::P64);
           I64[Sp + 32] = block_caelG_info;
           R5 = _sacXF::P64;
           R4 = _sacYc::P64;
           R3 = _sacYl::P64;
           R2 = _sacYk::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caelA_info" {
     block_caelA_info:
         const _caelA;
         const 7;
         const 18446744069414584350;
         const uaenT_srtd;
 },
 section ""relreadonly" . uaenU_srtd" {
     uaenU_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelG() //  [R1]
         { []
         }
     {offset
       caelG: // global
           I64[Sp] = block_caelI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaenA; else goto caelJ;
       uaenA: // global
           call _caelI(R1) args: 0, res: 0, upd: 0;
       caelJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caelG_info" {
     block_caelG_info:
         const _caelG;
         const 3;
         const 18446744069414584350;
         const uaenU_srtd;
 },
 section ""relreadonly" . uaenV_srtd" {
     uaenV_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelI() //  [R1]
         { []
         }
     {offset
       caelI: // global
           _sacXF::P64 = P64[Sp + 24];
           _sacXN::P64 = P64[Sp + 8];
           _sacYy::P64 = P64[R1 + 7];
           _sacYz::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sacXN::P64 + 8] = _sacYy::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacXN::P64);
           I64[Sp] = block_caelQ_info;
           R1 = _sacXF::P64;
           P64[Sp + 8] = _sacYz::P64;
           P64[Sp + 24] = _sacYy::P64;
           if (R1 & 7 != 0) goto uaenB; else goto caelR;
       uaenB: // global
           call _caelQ(R1) args: 0, res: 0, upd: 0;
       caelR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caelI_info" {
     block_caelI_info:
         const _caelI;
         const 3;
         const 18446744069414584350;
         const uaenV_srtd;
 },
 section ""relreadonly" . uaenW_srtd" {
     uaenW_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelQ() //  [R1]
         { []
         }
     {offset
       caelQ: // global
           I64[Sp] = block_caelV_info;
           _sacYH::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sacYH::I64;
           if (R1 & 7 != 0) goto uaenC; else goto caem5;
       uaenC: // global
           call _caelV(R1) args: 0, res: 0, upd: 0;
       caem5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caelQ_info" {
     block_caelQ_info:
         const _caelQ;
         const 3;
         const 18446744069414584350;
         const uaenW_srtd;
 },
 section ""relreadonly" . uaenX_srtd" {
     uaenX_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caelV() //  [R1]
         { []
         }
     {offset
       caelV: // global
           if (I64[Sp + 8] == I64[R1 + 47]) goto caemh; else goto caemd;
       caemh: // global
           I64[Sp + 8] = block_caemg_info;
           _sacYI::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sacYI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaenD; else goto caemi;
       uaenD: // global
           call _caemg(R1) args: 0, res: 0, upd: 0;
       caemi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caemd: // global
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caelV_info" {
     block_caelV_info:
         const _caelV;
         const 67;
         const 18446744069414584350;
         const uaenX_srtd;
 },
 section ""relreadonly" . uaenY_srtd" {
     uaenY_srtd:
         const Saded_srt+56;
         const 33;
         const 5368709121;
 },
 _caemg() //  [R1]
         { []
         }
     {offset
       caemg: // global
           P64[Sp - 40] = P64[Sp + 8];
           I64[Sp - 32] = I64[R1 + 23];
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 8] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 40;
           call _caekz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caemg_info" {
     block_caemg_info:
         const _caemg;
         const 2;
         const 18446744069414584350;
         const uaenY_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.092953718 UTC

[section ""data" . GHC.IO.Handle.Internals.readTextDevice_closure" {
     GHC.IO.Handle.Internals.readTextDevice_closure:
         const GHC.IO.Handle.Internals.readTextDevice_info;
         const 0;
 },
 GHC.IO.Handle.Internals.readTextDevice_entry() //  [R2, R3]
         { []
         }
     {offset
       caesg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.readTextDevice_info" {
     GHC.IO.Handle.Internals.readTextDevice_info:
         const GHC.IO.Handle.Internals.readTextDevice_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Saded_srt+296;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.098308111 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead_1_closure" {
     GHC.IO.Handle.Internals.hLookAhead_1_closure:
         const GHC.IO.Handle.Internals.hLookAhead_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead_1_entry() //  [R2]
         { []
         }
     {offset
       caesu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caesy; else goto caesz;
       caesy: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hLookAhead_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caesz: // global
           I64[Sp - 8] = block_caesr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaet5; else goto caess;
       uaet5: // global
           call _caesr(R1) args: 0, res: 0, upd: 0;
       caess: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hLookAhead_1_info" {
     GHC.IO.Handle.Internals.hLookAhead_1_info:
         const GHC.IO.Handle.Internals.hLookAhead_1_entry;
         const 0;
         const 38654705678;
         const 8589934597;
         const Saded_srt+296;
 },
 _caesr() //  [R1]
         { []
         }
     {offset
       caesr: // global
           I64[Sp - 16] = block_caesx_info;
           _sacZC::P64 = R1;
           _sacZL::P64 = P64[R1 + 71];
           R1 = P64[_sacZL::P64 + 8];
           P64[Sp - 8] = _sacZL::P64;
           P64[Sp] = _sacZC::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaet4; else goto caesB;
       uaet4: // global
           call _caesx(R1) args: 0, res: 0, upd: 0;
       caesB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caesr_info" {
     block_caesr_info:
         const _caesr;
         const 0;
         const 4294967326;
         const Saded_srt+296;
 },
 _caesx() //  [R1]
         { []
         }
     {offset
       caesx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caesH; else goto caesG;
       caesH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caesG: // global
           _sacZY::P64 = P64[R1 + 7];
           _sacZX::I64 = I64[R1 + 23];
           _sad01::I64 = I64[R1 + 39];
           if (_sad01::I64 == I64[R1 + 47]) goto caet0; else goto caesR;
       caet0: // global
           Hp = Hp - 16;
           I64[Sp - 16] = block_caesT_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           I64[Sp - 8] = _sad01::I64;
           P64[Sp] = _sacZY::P64;
           I64[Sp + 16] = _sacZX::I64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       caesR: // global
           _sacZL::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacZL::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacZL::P64);
           _sad07::I64 = %MO_UU_Conv_W32_W64(I32[_sacZX::I64 + (_sad01::I64 << 2)]);
           call MO_Touch(_sacZY::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sad07::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caesx_info" {
     block_caesx_info:
         const _caesx;
         const 2;
         const 4294967326;
         const Saded_srt+296;
 },
 _caesT() //  [R1]
         { []
         }
     {offset
       caesT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caet3; else goto caet2;
       caet3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caet2: // global
           _sacZL::P64 = P64[Sp + 24];
           _sacZX::I64 = I64[Sp + 32];
           _sacZY::P64 = P64[Sp + 16];
           _sad01::I64 = I64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sacZL::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sacZL::P64);
           _sad0g::I64 = %MO_UU_Conv_W32_W64(I32[_sacZX::I64 + (_sad01::I64 << 2)]);
           call MO_Touch(_sacZY::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sad0g::I64;
           R1 = Hp - 7;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caesT_info" {
     block_caesT_info:
         const _caesT;
         const 580;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.108219494 UTC

[section ""data" . GHC.IO.Handle.Internals.hLookAhead__closure" {
     GHC.IO.Handle.Internals.hLookAhead__closure:
         const GHC.IO.Handle.Internals.hLookAhead__info;
         const 0;
 },
 GHC.IO.Handle.Internals.hLookAhead__entry() //  [R2]
         { []
         }
     {offset
       caetz: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hLookAhead_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hLookAhead__info" {
     GHC.IO.Handle.Internals.hLookAhead__info:
         const GHC.IO.Handle.Internals.hLookAhead__entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Saded_srt+320;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.111693717 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help2_closure" {
     GHC.IO.Handle.Internals.hClose_help2_closure:
         const GHC.IO.Handle.Internals.hClose_help2_info;
 },
 GHC.IO.Handle.Internals.hClose_help2_entry() //  [R2]
         { []
         }
     {offset
       caetL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caetP; else goto caetO;
       caetP: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caetO: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hClose_help2_info" {
     GHC.IO.Handle.Internals.hClose_help2_info:
         const GHC.IO.Handle.Internals.hClose_help2_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.126416446 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help1_closure" {
     GHC.IO.Handle.Internals.hClose_help1_closure:
         const GHC.IO.Handle.Internals.hClose_help1_info;
         const 0;
 },
 sat_sad17_entry() //  [R1]
         { []
         }
     {offset
       caeui: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeuj; else goto caeuk;
       caeuj: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeuk: // global
           I64[Sp - 32] = block_caeuf_info;
           _sad0q::P64 = P64[R1 + 7];
           _sad0s::P64 = P64[R1 + 15];
           _sad0u::P64 = P64[R1 + 23];
           R1 = P64[_sad0u::P64 + 8];
           P64[Sp - 24] = _sad0q::P64;
           P64[Sp - 16] = _sad0s::P64;
           P64[Sp - 8] = _sad0u::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeuW; else goto caeug;
       uaeuW: // global
           call _caeuf(R1) args: 0, res: 0, upd: 0;
       caeug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad17_info" {
     sat_sad17_info:
         const sat_sad17_entry;
         const 3;
         const 8;
         const 4294967299;
 },
 _caeuf() //  [R1]
         { []
         }
     {offset
       caeuf: // global
           I64[Sp] = block_caeun_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaeuV; else goto caeup;
       uaeuV: // global
           call _caeun(R1) args: 0, res: 0, upd: 0;
       caeup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeuf_info" {
     block_caeuf_info:
         const _caeuf;
         const 3;
         const 30;
 },
 _caeun() //  [R1]
         { []
         }
     {offset
       caeun: // global
           if (R1 & 7 == 1) goto uaeuT; else goto caeuA;
       uaeuT: // global
           Sp = Sp + 32;
           call _caeuO() args: 0, res: 0, upd: 0;
       caeuA: // global
           _sad0U::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_caeuy_info;
           R1 = _sad0U::P64;
           if (R1 & 7 != 0) goto uaeuX; else goto caeuB;
       uaeuX: // global
           call _caeuy(R1) args: 0, res: 0, upd: 0;
       caeuB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeun_info" {
     block_caeun_info:
         const _caeun;
         const 3;
         const 30;
 },
 _caeuy() //  [R1]
         { []
         }
     {offset
       caeuy: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uaeuU; else goto caeuL;
       uaeuU: // global
           Sp = Sp + 32;
           call _caeuO() args: 0, res: 0, upd: 0;
       caeuL: // global
           _sad0s::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caeuJ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sad0s::P64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeuy_info" {
     block_caeuy_info:
         const _caeuy;
         const 3;
         const 30;
 },
 _caeuO() //  []
         { []
         }
     {offset
       caeuO: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caeuJ() //  [R1]
         { []
         }
     {offset
       caeuJ: // global
           _sad0u::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sad0u::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad0u::P64);
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeuJ_info" {
     block_caeuJ_info:
         const _caeuJ;
         const 1;
         const 30;
 },
 sat_sad1n_entry() //  [R1]
         { []
         }
     {offset
       caevB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caevC; else goto caevD;
       caevC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caevD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caevu_info;
           _sad1d::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sad1d::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaevK; else goto caevv;
       uaevK: // global
           call _caevu(R1) args: 0, res: 0, upd: 0;
       caevv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sad1n_info" {
     sat_sad1n_info:
         const sat_sad1n_entry;
         const 2;
         const 18;
 },
 _caevu() //  [R1]
         { []
         }
     {offset
       caevu: // global
           if (R1 & 7 == 1) goto caevy; else goto caevz;
       caevy: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caevz: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caevu_info" {
     block_caevu_info:
         const _caevu;
         const 1;
         const 30;
 },
 sat_sad1C_entry() //  [R1]
         { []
         }
     {offset
       caew5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caew6; else goto caew7;
       caew6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caew7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caevY_info;
           _sad1d::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sad1d::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaewe; else goto caevZ;
       uaewe: // global
           call _caevY(R1) args: 0, res: 0, upd: 0;
       caevZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sad1C_info" {
     sat_sad1C_info:
         const sat_sad1C_entry;
         const 2;
         const 18;
 },
 _caevY() //  [R1]
         { []
         }
     {offset
       caevY: // global
           if (R1 & 7 == 1) goto caew2; else goto caew3;
       caew2: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       caew3: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caevY_info" {
     block_caevY_info:
         const _caevY;
         const 1;
         const 30;
 },
 sat_sad1U_entry() //  [R1]
         { []
         }
     {offset
       caewr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caews; else goto caewt;
       caews: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caewt: // global
           I64[Sp - 8] = block_caewp_info;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.IO.Device.close_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad1U_info" {
     sat_sad1U_info:
         const sat_sad1U_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _caewp() //  []
         { []
         }
     {offset
       caewp: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caewp_info" {
     block_caewp_info:
         const _caewp;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.hClose_help1_entry() //  [R2]
         { []
         }
     {offset
       caewv: // global
           if ((Sp + -144) < SpLim) (likely: False) goto caeww; else goto caewx;
       caeww: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.hClose_help1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caewx: // global
           I64[Sp - 8] = block_caeu0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaexM; else goto caeu1;
       uaexM: // global
           call _caeu0(R1) args: 0, res: 0, upd: 0;
       caeu1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hClose_help1_info" {
     GHC.IO.Handle.Internals.hClose_help1_info:
         const GHC.IO.Handle.Internals.hClose_help1_entry;
         const 0;
         const 30064771086;
         const 8589934597;
         const Saded_srt+328;
 },
 _caeu0() //  [R1]
         { []
         }
     {offset
       caeu0: // global
           I64[Sp - 128] = block_caeu5_info;
           _sad0o::P64 = R1;
           _sad0p::P64 = P64[R1 + 7];
           _sad0q::P64 = P64[R1 + 15];
           _sad0r::P64 = P64[R1 + 23];
           _sad0s::P64 = P64[R1 + 31];
           _sad0u::P64 = P64[R1 + 47];
           _sad0v::P64 = P64[R1 + 55];
           _sad0w::P64 = P64[R1 + 63];
           _sad0x::P64 = P64[R1 + 71];
           _sad0y::P64 = P64[R1 + 79];
           _sad0z::P64 = P64[R1 + 87];
           _sad0A::P64 = P64[R1 + 95];
           _sad0B::P64 = P64[R1 + 103];
           _sad0C::P64 = P64[R1 + 111];
           _sad0D::P64 = P64[R1 + 119];
           _sad0E::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sad0p::P64;
           P64[Sp - 112] = _sad0q::P64;
           P64[Sp - 104] = _sad0r::P64;
           P64[Sp - 96] = _sad0s::P64;
           P64[Sp - 88] = _sad0u::P64;
           P64[Sp - 80] = _sad0v::P64;
           P64[Sp - 72] = _sad0w::P64;
           P64[Sp - 64] = _sad0x::P64;
           P64[Sp - 56] = _sad0y::P64;
           P64[Sp - 48] = _sad0z::P64;
           P64[Sp - 40] = _sad0A::P64;
           P64[Sp - 32] = _sad0B::P64;
           P64[Sp - 24] = _sad0C::P64;
           P64[Sp - 16] = _sad0D::P64;
           P64[Sp - 8] = _sad0E::P64;
           P64[Sp] = _sad0o::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto uaexI; else goto caeu6;
       uaexI: // global
           call _caeu5(R1) args: 0, res: 0, upd: 0;
       caeu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeu0_info" {
     block_caeu0_info:
         const _caeu0;
         const 0;
         const 12884901918;
         const Saded_srt+328;
 },
 _caeu5() //  [R1]
         { []
         }
     {offset
       caeu5: // global
           if (R1 & 7 == 1) goto caexw; else goto caewA;
       caexw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caexz; else goto caexy;
       caexz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caexy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caewA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caewD; else goto caewC;
       caewD: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caewC: // global
           I64[Hp - 24] = sat_sad17_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp] = block_caev0_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 23;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeu5_info" {
     block_caeu5_info:
         const _caeu5;
         const 16;
         const 12884901918;
         const Saded_srt+328;
 },
 _caev0() //  [R1]
         { []
         }
     {offset
       caev0: // global
           I64[Sp] = block_caewf_info;
           _sad1a::P64 = R1;
           R1 = P64[Sp + 120];
           P64[Sp + 128] = _sad1a::P64;
           if (R1 & 7 != 0) goto uaexJ; else goto caewg;
       uaexJ: // global
           call _caewf(R1) args: 0, res: 0, upd: 0;
       caewg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caev0_info" {
     block_caev0_info:
         const _caev0;
         const 2097168;
         const 12884901918;
         const Saded_srt+328;
 },
 _caewf() //  [R1]
         { []
         }
     {offset
       caewf: // global
           if (R1 & 7 == 1) goto caexj; else goto caexs;
       caexj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caexm; else goto caexl;
       caexm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caexl: // global
           I64[Hp - 16] = sat_sad1U_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_caexh_info;
           R2 = GHC.IO.Handle.Internals.hClose_help2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       caexs: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _sad1b() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caewf_info" {
     block_caewf_info:
         const _caewf;
         const 16;
         const 12884901918;
         const Saded_srt+328;
 },
 _caexh() //  [R1]
         { []
         }
     {offset
       caexh: // global
           P64[Sp] = R1;
           call _sad1b() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caexh_info" {
     block_caexh_info:
         const _caexh;
         const 16;
         const 12884901918;
         const Saded_srt+328;
 },
 _sad1b() //  []
         { []
         }
     {offset
       sad1b: // global
           _sad0u::P64 = P64[Sp + 40];
           _sad0x::P64 = P64[Sp + 64];
           _sad0y::P64 = P64[Sp + 72];
           _sad0A::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sad0y::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad0y::P64);
           call MO_WriteBarrier();
           P64[_sad0x::P64 + 8] = GHC.IO.Handle.Internals.noCharBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad0x::P64);
           call MO_WriteBarrier();
           P64[_sad0u::P64 + 8] = GHC.IO.Handle.Internals.noByteBuffer_closure;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad0u::P64);
           I64[Sp - 8] = block_caewF_info;
           R1 = _sad0A::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaexR; else goto caewX;
       uaexR: // global
           call _caewF(R1) args: 0, res: 0, upd: 0;
       caewX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caewF() //  [R1]
         { []
         }
     {offset
       caewF: // global
           if (R1 & 7 == 1) goto uaexG; else goto caexd;
       uaexG: // global
           Sp = Sp + 8;
           call _sad1h() args: 0, res: 0, upd: 0;
       caexd: // global
           I64[Sp] = block_caex6_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaexN; else goto caex7;
       uaexN: // global
           call _caex6(R1) args: 0, res: 0, upd: 0;
       caex7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caewF_info" {
     block_caewF_info:
         const _caewF;
         const 17;
         const 30;
 },
 _caex6() //  [R1]
         { []
         }
     {offset
       caex6: // global
           I64[Sp] = block_caexb_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caex6_info" {
     block_caex6_info:
         const _caex6;
         const 17;
         const 30;
 },
 _caexb() //  []
         { []
         }
     {offset
       caexb: // global
           Sp = Sp + 8;
           call _sad1h() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caexb_info" {
     block_caexb_info:
         const _caexb;
         const 17;
         const 30;
 },
 _sad1h() //  []
         { []
         }
     {offset
       sad1h: // global
           I64[Sp - 8] = block_caevl_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaexS; else goto caevm;
       uaexS: // global
           call _caevl(R1) args: 0, res: 0, upd: 0;
       caevm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caevl() //  [R1]
         { []
         }
     {offset
       caevl: // global
           if (R1 & 7 == 1) goto caewL; else goto caewS;
       caewL: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto caewO; else goto caewN;
       caewO: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caewN: // global
           I64[Hp - 184] = sat_sad1n_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = GHC.Base.Nothing_closure+1;
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caewS: // global
           I64[Sp] = block_caevN_info;
           _sad1j::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 88] = _sad1j::P64;
           if (R1 & 7 != 0) goto uaexK; else goto caevO;
       uaexK: // global
           call _caevN(R1) args: 0, res: 0, upd: 0;
       caevO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caevl_info" {
     block_caevl_info:
         const _caevl;
         const 65553;
         const 30;
 },
 _caevN() //  [R1]
         { []
         }
     {offset
       caevN: // global
           I64[Sp] = block_caevS_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caevN_info" {
     block_caevN_info:
         const _caevN;
         const 17;
         const 30;
 },
 _caevS() //  [R1]
         { []
         }
     {offset
       caevS: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto caewW; else goto caewV;
       caewW: // global
           HpAlloc = 192;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caewV: // global
           I64[Hp - 184] = sat_sad1C_info;
           P64[Hp - 168] = P64[Sp + 136];
           P64[Hp - 160] = P64[Sp + 8];
           I64[Hp - 152] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = GHC.IO.Handle.Types.ClosedHandle_closure+1;
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 151;
           P64[Hp] = Hp - 184;
           R1 = Hp - 15;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caevS_info" {
     block_caevS_info:
         const _caevS;
         const 17;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.172039576 UTC

[section ""data" . GHC.IO.Handle.Internals.hClose_help_closure" {
     GHC.IO.Handle.Internals.hClose_help_closure:
         const GHC.IO.Handle.Internals.hClose_help_info;
         const 0;
 },
 GHC.IO.Handle.Internals.hClose_help_entry() //  [R2]
         { []
         }
     {offset
       caeBu: // global
           R2 = R2;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.hClose_help_info" {
     GHC.IO.Handle.Internals.hClose_help_info:
         const GHC.IO.Handle.Internals.hClose_help_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Saded_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.176704566 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer1_closure" {
     GHC.IO.Handle.Internals.handleFinalizer1_closure:
         const GHC.IO.Handle.Internals.handleFinalizer1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer1_entry() //  [R2, R3]
         { []
         }
     {offset
       caeBI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeBV; else goto caeBW;
       caeBV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.handleFinalizer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caeBW: // global
           I64[Sp - 8] = block_caeBF_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaeC3; else goto caeBG;
       uaeC3: // global
           call _caeBF(R1) args: 0, res: 0, upd: 0;
       caeBG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.handleFinalizer1_info" {
     GHC.IO.Handle.Internals.handleFinalizer1_info:
         const GHC.IO.Handle.Internals.handleFinalizer1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const Saded_srt+344;
 },
 _caeBF() //  [R1]
         { []
         }
     {offset
       caeBF: // global
           I64[Sp - 8] = block_caeBL_info;
           _sad24::P64 = P64[R1 + 7];
           R1 = _sad24::P64;
           P64[Sp] = _sad24::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeBF_info" {
     block_caeBF_info:
         const _caeBF;
         const 0;
         const 4294967326;
         const Saded_srt+344;
 },
 _caeBL() //  [R1]
         { []
         }
     {offset
       caeBL: // global
           I64[Sp] = block_caeBN_info;
           R2 = R1;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeBL_info" {
     block_caeBL_info:
         const _caeBL;
         const 1;
         const 4294967326;
         const Saded_srt+344;
 },
 _caeBN() //  [R1]
         { []
         }
     {offset
       caeBN: // global
           I64[Sp] = block_caeBP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeC4; else goto caeBQ;
       uaeC4: // global
           call _caeBP(R1) args: 0, res: 0, upd: 0;
       caeBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeBN_info" {
     block_caeBN_info:
         const _caeBN;
         const 1;
         const 30;
 },
 _caeBP() //  [R1]
         { []
         }
     {offset
       caeBP: // global
           _sad24::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeBU_info;
           R2 = P64[R1 + 7];
           R1 = _sad24::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeBP_info" {
     block_caeBP_info:
         const _caeBP;
         const 1;
         const 30;
 },
 _caeBU() //  []
         { []
         }
     {offset
       caeBU: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeBU_info" {
     block_caeBU_info:
         const _caeBU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.187918333 UTC

[section ""data" . GHC.IO.Handle.Internals.handleFinalizer_closure" {
     GHC.IO.Handle.Internals.handleFinalizer_closure:
         const GHC.IO.Handle.Internals.handleFinalizer_info;
         const 0;
 },
 GHC.IO.Handle.Internals.handleFinalizer_entry() //  [R2, R3]
         { []
         }
     {offset
       caeCC: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.handleFinalizer1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.handleFinalizer_info" {
     GHC.IO.Handle.Internals.handleFinalizer_info:
         const GHC.IO.Handle.Internals.handleFinalizer_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Saded_srt+352;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.190988965 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle4_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.194839847 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle1_closure" {
     GHC.IO.Handle.Internals.mkFileHandle1_closure:
         const GHC.IO.Handle.Internals.mkFileHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle1_slow() //  [R1]
         { []
         }
     {offset
       caeCL: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2,
                                                            R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sad2p_entry() //  [R1]
         { []
         }
     {offset
       caeD2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caeD3; else goto caeD4;
       caeD3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeD4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caeCT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeDj; else goto caeCU;
       uaeDj: // global
           call _caeCT(R1) args: 0, res: 0, upd: 0;
       caeCU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sad2p_info" {
     sat_sad2p_info:
         const sat_sad2p_entry;
         const 1;
         const 16;
 },
 _caeCT() //  [R1]
         { []
         }
     {offset
       caeCT: // global
           _caeD1::P64 = R1 & 7;
           if (_caeD1::P64 < 3) goto uaeDh; else goto uaeDi;
       uaeDh: // global
           if (_caeD1::P64 < 2) goto caeCX; else goto caeCY;
       caeCX: // global
           R1 = GHC.IO.Handle.Types.ReadHandle_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caeCY: // global
           R1 = GHC.IO.Handle.Types.WriteHandle_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uaeDi: // global
           if (_caeD1::P64 < 4) goto caeCZ; else goto caeD0;
       caeCZ: // global
           R1 = GHC.IO.Handle.Types.AppendHandle_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caeD0: // global
           R1 = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caeCT_info" {
     block_caeCT_info:
         const _caeCT;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.mkFileHandle1_entry() //  [R2, R3, R4, R5,
                                                    R6]
         { []
         }
     {offset
       caeDk: // global
           _sad2j::P64 = R6;
           _sad2i::P64 = R5;
           _sad2h::P64 = R4;
           _sad2g::P64 = R3;
           _sad2f::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto caeDl; else goto caeDm;
       caeDm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeDo; else goto caeDn;
       caeDo: // global
           HpAlloc = 24;
           goto caeDl;
       caeDl: // global
           R1 = GHC.IO.Handle.Internals.mkFileHandle1_closure;
           P64[Sp - 40] = _sad2f::P64;
           P64[Sp - 32] = _sad2g::P64;
           P64[Sp - 24] = _sad2h::P64;
           P64[Sp - 16] = _sad2i::P64;
           P64[Sp - 8] = _sad2j::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       caeDn: // global
           I64[Hp - 16] = sat_sad2p_info;
           P64[Hp] = P64[Sp];
           R6 = _sad2j::P64;
           R5 = _sad2i::P64;
           R4 = _sad2h::P64;
           R3 = _sad2g::P64;
           R2 = _sad2f::P64;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = GHC.Types.True_closure+2;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 8] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkFileHandle1_info" {
     GHC.IO.Handle.Internals.mkFileHandle1_info:
         const GHC.IO.Handle.Internals.mkFileHandle1_entry;
         const 0;
         const 1688854155231246;
         const 38654705664;
         const Saded_srt+224;
         const 8;
         const GHC.IO.Handle.Internals.mkFileHandle1_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.204973079 UTC

[section ""data" . GHC.IO.Handle.Internals.mkFileHandle_closure" {
     GHC.IO.Handle.Internals.mkFileHandle_closure:
         const GHC.IO.Handle.Internals.mkFileHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkFileHandle_slow() //  [R1]
         { []
         }
     {offset
       caeE0: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkFileHandle_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkFileHandle_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { []
         }
     {offset
       caeE4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkFileHandle1_entry(R6,
                                                            R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkFileHandle_info" {
     GHC.IO.Handle.Internals.mkFileHandle_info:
         const GHC.IO.Handle.Internals.mkFileHandle_entry;
         const 0;
         const 4294967310;
         const 38654705664;
         const Saded_srt+368;
         const 8;
         const GHC.IO.Handle.Internals.mkFileHandle_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.209049732 UTC

[section ""cstring" . lvl23_ra7PD_bytes" {
     lvl23_ra7PD_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,54,58,51,45,51,51]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.21165645 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle3_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle3_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle3_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle3_entry() //  []
         { []
         }
     {offset
       caeEk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caeEl; else goto caeEm;
       caeEl: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeEm: // global
           I64[Sp - 8] = block_caeEi_info;
           R2 = lvl23_ra7PD_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle3_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle3_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle3_entry;
         const 0;
         const 12884901902;
         const 4294967299;
         const Saded_srt+376;
 },
 _caeEi() //  [R1]
         { []
         }
     {offset
       caeEi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeEi_info" {
     block_caeEi_info:
         const _caeEi;
         const 0;
         const 4294967326;
         const Saded_srt+376;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.216337799 UTC

[section ""cstring" . lvl24_ra7PE_bytes" {
     lvl24_ra7PE_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,47,73,110,116,101,114,110,97,108,115,46,104,115,58,54,56,48,58,51,45,51,53]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.218639095 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle2_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle2_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle2_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle2_entry() //  []
         { []
         }
     {offset
       caeEG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caeEH; else goto caeEI;
       caeEH: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeEI: // global
           I64[Sp - 8] = block_caeEE_info;
           R2 = lvl24_ra7PE_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle2_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle2_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle2_entry;
         const 0;
         const 21474836494;
         const 4294967299;
         const Saded_srt+376;
 },
 _caeEE() //  [R1]
         { []
         }
     {offset
       caeEE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeEE_info" {
     block_caeEE_info:
         const _caeEE;
         const 0;
         const 4294967326;
         const Saded_srt+376;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.226333106 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle1_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle1_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_slow() //  [R1]
         { []
         }
     {offset
       caeEW: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2,
                                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle1_entry() //  [R2, R3, R4,
                                                      R5, R6]
         { []
         }
     {offset
       caeF9: // global
           if ((Sp + -96) < SpLim) (likely: False) goto caeFa; else goto caeFb;
       caeFa: // global
           R1 = GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       caeFb: // global
           I64[Sp - 48] = block_caeF0_info;
           _sad2y::P64 = R6;
           R6 = R6;
           _sad2x::P64 = R5;
           R5 = R5;
           _sad2w::P64 = R4;
           R4 = R4;
           _sad2v::P64 = R3;
           R3 = R3;
           _sad2u::P64 = R2;
           R2 = R2;
           P64[Sp - 96] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Sp - 88] = GHC.Types.True_closure+2;
           P64[Sp - 80] = P64[Sp];
           P64[Sp - 72] = P64[Sp + 8];
           P64[Sp - 64] = GHC.IO.Handle.Internals.mkDuplexHandle4_closure+2;
           P64[Sp - 56] = GHC.Base.Nothing_closure+1;
           P64[Sp - 40] = _sad2u::P64;
           P64[Sp - 32] = _sad2v::P64;
           P64[Sp - 24] = _sad2w::P64;
           P64[Sp - 16] = _sad2x::P64;
           P64[Sp - 8] = _sad2y::P64;
           Sp = Sp - 96;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle1_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle1_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle1_entry;
         const 0;
         const 32088151639982094;
         const 34359738368;
         const Saded_srt+224;
         const 7;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_slow;
 },
 _caeF0() //  [R1]
         { []
         }
     {offset
       caeF0: // global
           I64[Sp] = block_caeF2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeFG; else goto caeF3;
       uaeFG: // global
           call _caeF2(R1) args: 0, res: 0, upd: 0;
       caeF3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeF0_info" {
     block_caeF0_info:
         const _caeF0;
         const 7;
         const 13510803177078814;
         const Saded_srt+224;
 },
 _caeF2() //  [R1]
         { []
         }
     {offset
       caeF2: // global
           if (R1 & 7 == 1) goto caeF6; else goto caeF7;
       caeF6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caeFm; else goto caeFl;
       caeFm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeFl: // global
           _sad2H::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = _sad2H::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           _sad2x::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_caeFh_info;
           R6 = P64[Sp + 40];
           R5 = _sad2x::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp - 16] = GHC.IO.Handle.Types.ReadHandle_closure+3;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           P64[Sp] = P64[Sp + 48];
           P64[Sp + 8] = P64[Sp + 56];
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = Hp - 6;
           P64[Sp + 56] = _sad2H::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 8, upd: 8;
       caeF7: // global
           Sp = Sp + 64;
           call GHC.IO.Handle.Internals.mkDuplexHandle2_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeF2_info" {
     block_caeF2_info:
         const _caeF2;
         const 7;
         const 13510803177078814;
         const Saded_srt+224;
 },
 _caeFh() //  [R1]
         { []
         }
     {offset
       caeFh: // global
           I64[Sp] = block_caeFj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeFH; else goto caeFo;
       uaeFH: // global
           call _caeFj(R1) args: 0, res: 0, upd: 0;
       caeFo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeFh_info" {
     block_caeFh_info:
         const _caeFh;
         const 131;
         const 4294967326;
         const Saded_srt+384;
 },
 _caeFj() //  [R1]
         { []
         }
     {offset
       caeFj: // global
           if (R1 & 7 == 1) goto caeFu; else goto caeFB;
       caeFu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caeFx; else goto caeFw;
       caeFx: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeFw: // global
           _sad2P::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sad2P::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caeFB: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.mkDuplexHandle3_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeFj_info" {
     block_caeFj_info:
         const _caeFj;
         const 131;
         const 4294967326;
         const Saded_srt+384;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.239244164 UTC

[section ""data" . GHC.IO.Handle.Internals.mkDuplexHandle_closure" {
     GHC.IO.Handle.Internals.mkDuplexHandle_closure:
         const GHC.IO.Handle.Internals.mkDuplexHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_slow() //  [R1]
         { []
         }
     {offset
       caeGB: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2,
                                                             R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Internals.mkDuplexHandle_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { []
         }
     {offset
       caeGF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.mkDuplexHandle1_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.mkDuplexHandle_info" {
     GHC.IO.Handle.Internals.mkDuplexHandle_info:
         const GHC.IO.Handle.Internals.mkDuplexHandle_entry;
         const 0;
         const 4294967310;
         const 34359738368;
         const Saded_srt+400;
         const 7;
         const GHC.IO.Handle.Internals.mkDuplexHandle_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.246687146 UTC

[section ""data" . $wlvl_ra7PF_closure" {
     $wlvl_ra7PF_closure:
         const $wlvl_ra7PF_info;
         const 0;
 },
 sat_sad3d_entry() //  [R1]
         { []
         }
     {offset
       caeH7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeH8; else goto caeH9;
       caeH8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeH9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caeH0_info;
           _sad32::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sad32::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeHA; else goto caeH1;
       uaeHA: // global
           call _caeH0(R1) args: 0, res: 0, upd: 0;
       caeH1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sad3d_info" {
     sat_sad3d_info:
         const sat_sad3d_entry;
         const 2;
         const 18;
 },
 _caeH0() //  [R1]
         { []
         }
     {offset
       caeH0: // global
           if (R1 & 7 == 1) goto caeH4; else goto caeH5;
       caeH4: // global
           _sad32::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeHc_info;
           R1 = _sad32::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaeHz; else goto caeHe;
       uaeHz: // global
           call _caeHc(R1) args: 0, res: 0, upd: 0;
       caeHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       caeH5: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caeH0_info" {
     block_caeH0_info:
         const _caeH0;
         const 1;
         const 30;
 },
 _caeHc() //  [R1]
         { []
         }
     {offset
       caeHc: // global
           if (R1 & 7 == 1) goto caeHk; else goto caeHr;
       caeHk: // global
           Hp = Hp + 16;
           _sad36::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caeHu; else goto caeHm;
       caeHm: // global
           _sad37::P64 = P64[_sad36::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sad37::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caeHr: // global
           Hp = Hp + 16;
           _sad36::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caeHu; else goto caeHt;
       caeHu: // global
           HpAlloc = 16;
           R1 = _sad36::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caeHt: // global
           _sad39::P64 = P64[_sad36::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sad39::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caeHc_info" {
     block_caeHc_info:
         const _caeHc;
         const 0;
         const 30;
 },
 sat_sad3f_entry() //  [R1]
         { []
         }
     {offset
       caeHD: // global
           _sad3f::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeHE; else goto caeHF;
       caeHF: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto caeHH; else goto caeHG;
       caeHH: // global
           HpAlloc = 104;
           goto caeHE;
       caeHE: // global
           R1 = _sad3f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeHG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sad3f::P64;
           _sad2X::P64 = P64[_sad3f::P64 + 16];
           _sad2Y::P64 = P64[_sad3f::P64 + 24];
           _sad2Z::P64 = P64[_sad3f::P64 + 32];
           _sad30::P64 = P64[_sad3f::P64 + 40];
           _sad31::P64 = P64[_sad3f::P64 + 48];
           _sad32::P64 = P64[_sad3f::P64 + 56];
           I64[Hp - 96] = sat_sad3d_info;
           P64[Hp - 80] = _sad30::P64;
           P64[Hp - 72] = _sad32::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sad32::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sad2X::P64;
           P64[Hp - 24] = _sad31::P64;
           P64[Hp - 16] = _sad2Y::P64;
           P64[Hp - 8] = _sad2Z::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sad3f_info" {
     sat_sad3f_info:
         const sat_sad3f_entry;
         const 6;
         const 4294967311;
         const Saded_srt+408;
 },
 $wlvl_ra7PF_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       caeHI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caeHM; else goto caeHL;
       caeHM: // global
           HpAlloc = 64;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_ra7PF_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caeHL: // global
           I64[Hp - 56] = sat_sad3f_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 56;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wlvl_ra7PF_info" {
     $wlvl_ra7PF_info:
         const $wlvl_ra7PF_entry;
         const 0;
         const 12884901902;
         const 30064771098;
         const Saded_srt+408;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.262074017 UTC

[section ""data" . GHC.IO.Handle.Internals.$wdo_operation_closure" {
     GHC.IO.Handle.Internals.$wdo_operation_closure:
         const GHC.IO.Handle.Internals.$wdo_operation_info;
         const 0;
 },
 sat_sad3K_entry() //  [R1, R2]
         { []
         }
     {offset
       caeIK: // global
           if ((Sp + -64) < SpLim) (likely: False) goto caeIO; else goto caeIP;
       caeIO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeIP: // global
           I64[Sp - 48] = block_caeIF_info;
           _sad3p::P64 = R2;
           R2 = P64[R1 + 38];
           _sad3g::P64 = P64[R1 + 6];
           _sad3h::P64 = P64[R1 + 14];
           _sad3i::P64 = P64[R1 + 22];
           _sad3j::P64 = P64[R1 + 30];
           R1 = _sad3j::P64;
           P64[Sp - 40] = _sad3g::P64;
           P64[Sp - 32] = _sad3h::P64;
           P64[Sp - 24] = _sad3i::P64;
           P64[Sp - 16] = _sad3j::P64;
           P64[Sp - 8] = _sad3p::P64;
           Sp = Sp - 48;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad3K_info" {
     sat_sad3K_info:
         const sat_sad3K_entry;
         const 5;
         const 133143986184;
         const 8589934597;
         const Saded_srt+416;
 },
 _caeIF() //  []
         { []
         }
     {offset
       caeIF: // global
           I64[Sp] = block_caeIH_info;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto uaeJx; else goto caeII;
       uaeJx: // global
           call _caeIH(R1) args: 0, res: 0, upd: 0;
       caeII: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeIF_info" {
     block_caeIF_info:
         const _caeIF;
         const 5;
         const 133143986206;
         const Saded_srt+416;
 },
 _caeIH() //  [R1]
         { []
         }
     {offset
       caeIH: // global
           I64[Sp - 16] = block_caeIN_info;
           _sad3t::P64 = P64[R1 + 7];
           R2 = _sad3t::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sad3t::P64;
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeIH_info" {
     block_caeIH_info:
         const _caeIH;
         const 1029;
         const 133143986206;
         const Saded_srt+416;
 },
 _caeIN() //  [R1]
         { []
         }
     {offset
       caeIN: // global
           I64[Sp] = block_caeIV_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeIN_info" {
     block_caeIN_info:
         const _caeIN;
         const 7;
         const 133143986206;
         const Saded_srt+416;
 },
 _caeIV() //  [R1]
         { []
         }
     {offset
       caeIV: // global
           if (R1 & 7 == 1) goto caeJ3; else goto caeJq;
       caeJ3: // global
           _sad3t::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caeJ0_info;
           R2 = _sad3t::P64;
           Sp = Sp + 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       caeJq: // global
           I64[Sp + 16] = block_caeJo_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeIV_info" {
     block_caeIV_info:
         const _caeIV;
         const 7;
         const 98784247838;
         const Saded_srt+416;
 },
 _caeJ0() //  [R1]
         { []
         }
     {offset
       caeJ0: // global
           I64[Sp] = block_caeJ7_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeJ0_info" {
     block_caeJ0_info:
         const _caeJ0;
         const 5;
         const 47244640286;
         const Saded_srt+424;
 },
 _caeJ7() //  [R1]
         { []
         }
     {offset
       caeJ7: // global
           _sad3s::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto caeJe; else goto caeJj;
       caeJe: // global
           R1 = _sad3s::P64;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caeJj: // global
           I64[Sp] = block_caeJh_info;
           R2 = _sad3s::P64;
           R1 = CurrentTSO;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeJ7_info" {
     block_caeJ7_info:
         const _caeJ7;
         const 5;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeJh() //  []
         { []
         }
     {offset
       caeJh: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeJh_info" {
     block_caeJh_info:
         const _caeJh;
         const 1029;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeJo() //  [R1]
         { []
         }
     {offset
       caeJo: // global
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 47];
           R4 = P64[R1 + 39];
           R3 = P64[R1 + 31];
           R2 = P64[R1 + 15];
           P64[Sp + 40] = P64[Sp + 16];
           Sp = Sp + 40;
           call $wlvl_ra7PF_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeJo_info" {
     block_caeJo_info:
         const _caeJo;
         const 1797;
         const 4294967326;
         const Saded_srt+416;
 },
 GHC.IO.Handle.Internals.$wdo_operation_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caeJy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caeJz; else goto caeJA;
       caeJz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wdo_operation_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeJA: // global
           I64[Sp - 40] = block_caeIw_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wdo_operation_info" {
     GHC.IO.Handle.Internals.$wdo_operation_info:
         const GHC.IO.Handle.Internals.$wdo_operation_entry;
         const 0;
         const 133143986190;
         const 21474836504;
         const Saded_srt+416;
 },
 _caeIw() //  [R1]
         { []
         }
     {offset
       caeIw: // global
           I64[Sp - 8] = block_caeIy_info;
           R2 = R1;
           _sad3n::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp] = _sad3n::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeIw_info" {
     block_caeIw_info:
         const _caeIw;
         const 4;
         const 133143986206;
         const Saded_srt+416;
 },
 _caeIy() //  [R1]
         { []
         }
     {offset
       caeIy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caeJE; else goto caeJD;
       caeJE: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeJD: // global
           I64[Hp - 40] = sat_sad3K_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 38;
           R1 = R1;
           Sp = Sp + 48;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeIy_info" {
     block_caeIy_info:
         const _caeIy;
         const 5;
         const 133143986206;
         const Saded_srt+416;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.28413622 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_1_closure" {
     GHC.IO.Handle.Internals.withHandle_1_closure:
         const GHC.IO.Handle.Internals.withHandle_1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caeKM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeKN; else goto caeKO;
       caeKN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeKO: // global
           I64[Sp - 32] = block_caeKJ_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeKS; else goto caeKK;
       uaeKS: // global
           call _caeKJ(R1) args: 0, res: 0, upd: 0;
       caeKK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle_1_info" {
     GHC.IO.Handle.Internals.withHandle_1_info:
         const GHC.IO.Handle.Internals.withHandle_1_entry;
         const 0;
         const 12884901902;
         const 21474836504;
         const Saded_srt+448;
 },
 _caeKJ() //  [R1]
         { []
         }
     {offset
       caeKJ: // global
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeKJ_info" {
     block_caeKJ_info:
         const _caeKJ;
         const 3;
         const 4294967326;
         const Saded_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.29137205 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle__'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle__'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle__'_info;
         const 0;
 },
 sat_sad4a_entry() //  [R1]
         { []
         }
     {offset
       caeLl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeLm; else goto caeLn;
       caeLm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeLn: // global
           I64[Sp - 16] = block_caeLh_info;
           _sad3U::P64 = P64[R1 + 23];
           R5 = _sad3U::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad3U::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad4a_info" {
     sat_sad4a_info:
         const sat_sad4a_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Saded_srt+448;
 },
 _caeLh() //  [R1]
         { []
         }
     {offset
       caeLh: // global
           _sad3U::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeLj_info;
           R2 = R1;
           R1 = _sad3U::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeLh_info" {
     block_caeLh_info:
         const _caeLh;
         const 1;
         const 30;
 },
 _caeLj() //  []
         { []
         }
     {offset
       caeLj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeLj_info" {
     block_caeLj_info:
         const _caeLj;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.$wwithHandle__'_entry() //  [R2, R3, R4,
                                                      R5]
         { []
         }
     {offset
       caeLt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeLu; else goto caeLv;
       caeLu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle__'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeLv: // global
           I64[Sp - 40] = block_caeL7_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wwithHandle__'_info" {
     GHC.IO.Handle.Internals.$wwithHandle__'_info:
         const GHC.IO.Handle.Internals.$wwithHandle__'_entry;
         const 0;
         const 21474836494;
         const 21474836504;
         const Saded_srt+448;
 },
 _caeL7() //  [R1]
         { []
         }
     {offset
       caeL7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeLy; else goto caeLx;
       caeLy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeLx: // global
           _sad3S::P64 = P64[Sp + 8];
           _sad3T::P64 = P64[Sp + 16];
           _sad3U::P64 = P64[Sp + 24];
           _sad3V::P64 = P64[Sp + 32];
           if (R1 == 0) goto caeLs; else goto caeLr;
       caeLs: // global
           I64[Hp - 32] = sat_sad4a_info;
           P64[Hp - 24] = _sad3S::P64;
           P64[Hp - 16] = _sad3T::P64;
           P64[Hp - 8] = _sad3U::P64;
           P64[Hp] = _sad3V::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeLr: // global
           Hp = Hp - 40;
           I64[Sp + 16] = block_caeLz_info;
           R5 = _sad3U::P64;
           R4 = _sad3V::P64;
           R3 = _sad3T::P64;
           R2 = _sad3S::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeL7_info" {
     block_caeL7_info:
         const _caeL7;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeLz() //  [R1]
         { []
         }
     {offset
       caeLz: // global
           I64[Sp + 16] = block_caeLB_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeLz_info" {
     block_caeLz_info:
         const _caeLz;
         const 130;
         const 30;
 },
 _caeLB() //  []
         { []
         }
     {offset
       caeLB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeLB_info" {
     block_caeLB_info:
         const _caeLB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.304988762 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'1_closure" {
     GHC.IO.Handle.Internals.withHandle__'1_closure:
         const GHC.IO.Handle.Internals.withHandle__'1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caeMk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeMl; else goto caeMm;
       caeMl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle__'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeMm: // global
           I64[Sp - 32] = block_caeMh_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeMq; else goto caeMi;
       uaeMq: // global
           call _caeMh(R1) args: 0, res: 0, upd: 0;
       caeMi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle__'1_info" {
     GHC.IO.Handle.Internals.withHandle__'1_info:
         const GHC.IO.Handle.Internals.withHandle__'1_entry;
         const 0;
         const 12884901902;
         const 21474836504;
         const Saded_srt+464;
 },
 _caeMh() //  [R1]
         { []
         }
     {offset
       caeMh: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeMh_info" {
     block_caeMh_info:
         const _caeMh;
         const 3;
         const 4294967326;
         const Saded_srt+464;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.310622256 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__'_closure" {
     GHC.IO.Handle.Internals.withHandle__'_closure:
         const GHC.IO.Handle.Internals.withHandle__'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__'_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caeMF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle__'1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle__'_info" {
     GHC.IO.Handle.Internals.withHandle__'_info:
         const GHC.IO.Handle.Internals.withHandle__'_entry;
         const 0;
         const 4294967310;
         const 21474836504;
         const Saded_srt+472;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.320152597 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles__1_closure" {
     GHC.IO.Handle.Internals.withAllHandles__1_closure:
         const GHC.IO.Handle.Internals.withAllHandles__1_info;
         const 0;
 },
 sat_sad4C_entry() //  [R1]
         { []
         }
     {offset
       caeN9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeNa; else goto caeNb;
       caeNa: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeNb: // global
           I64[Sp - 16] = block_caeN5_info;
           _sad4o::P64 = P64[R1 + 31];
           R5 = _sad4o::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad4o::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad4C_info" {
     sat_sad4C_info:
         const sat_sad4C_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Saded_srt+448;
 },
 _caeN5() //  [R1]
         { []
         }
     {offset
       caeN5: // global
           _sad4o::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeN7_info;
           R2 = R1;
           R1 = _sad4o::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeN5_info" {
     block_caeN5_info:
         const _caeN5;
         const 1;
         const 30;
 },
 _caeN7() //  []
         { []
         }
     {offset
       caeN7: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeN7_info" {
     block_caeN7_info:
         const _caeN7;
         const 0;
         const 30;
 },
 sat_sad4Y_entry() //  [R1]
         { []
         }
     {offset
       caeNB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeNC; else goto caeND;
       caeNC: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeND: // global
           I64[Sp - 16] = block_caeNx_info;
           _sad4F::P64 = P64[R1 + 31];
           R5 = _sad4F::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad4F::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad4Y_info" {
     sat_sad4Y_info:
         const sat_sad4Y_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Saded_srt+448;
 },
 _caeNx() //  [R1]
         { []
         }
     {offset
       caeNx: // global
           _sad4F::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeNz_info;
           R2 = R1;
           R1 = _sad4F::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeNx_info" {
     block_caeNx_info:
         const _caeNx;
         const 1;
         const 30;
 },
 _caeNz() //  []
         { []
         }
     {offset
       caeNz: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeNz_info" {
     block_caeNz_info:
         const _caeNz;
         const 0;
         const 30;
 },
 sat_sad59_entry() //  [R1]
         { []
         }
     {offset
       caeNS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeNT; else goto caeNU;
       caeNT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeNU: // global
           I64[Sp - 16] = block_caeNO_info;
           _sad4E::P64 = P64[R1 + 31];
           R5 = _sad4E::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad4E::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad59_info" {
     sat_sad59_info:
         const sat_sad59_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Saded_srt+448;
 },
 _caeNO() //  [R1]
         { []
         }
     {offset
       caeNO: // global
           _sad4E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caeNQ_info;
           R2 = R1;
           R1 = _sad4E::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeNO_info" {
     block_caeNO_info:
         const _caeNO;
         const 1;
         const 30;
 },
 _caeNQ() //  []
         { []
         }
     {offset
       caeNQ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeNQ_info" {
     block_caeNQ_info:
         const _caeNQ;
         const 0;
         const 30;
 },
 GHC.IO.Handle.Internals.withAllHandles__1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caeO1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caeO2; else goto caeO3;
       caeO2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withAllHandles__1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeO3: // global
           I64[Sp - 24] = block_caeMQ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeOK; else goto caeMR;
       uaeOK: // global
           call _caeMQ(R1) args: 0, res: 0, upd: 0;
       caeMR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withAllHandles__1_info" {
     GHC.IO.Handle.Internals.withAllHandles__1_info:
         const GHC.IO.Handle.Internals.withAllHandles__1_entry;
         const 0;
         const 73014444046;
         const 17179869207;
         const Saded_srt+448;
 },
 _caeMQ() //  [R1]
         { []
         }
     {offset
       caeMQ: // global
           if (R1 & 7 == 1) goto caeNY; else goto caeNZ;
       caeNY: // global
           I64[Sp - 16] = block_caeMV_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caeNZ: // global
           I64[Sp - 24] = block_caeNg_info;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeMQ_info" {
     block_caeMQ_info:
         const _caeMQ;
         const 2;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeMV() //  [R1]
         { []
         }
     {offset
       caeMV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeO7; else goto caeO6;
       caeO7: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeO6: // global
           _sad4i::P64 = P64[Sp + 24];
           _sad4k::P64 = P64[Sp + 32];
           _sad4m::P64 = P64[Sp + 16];
           _sad4o::P64 = P64[Sp + 8];
           if (R1 == 0) goto caeOg; else goto caeOc;
       caeOg: // global
           I64[Hp - 32] = sat_sad4C_info;
           P64[Hp - 24] = _sad4i::P64;
           P64[Hp - 16] = _sad4k::P64;
           P64[Hp - 8] = _sad4m::P64;
           P64[Hp] = _sad4o::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeOc: // global
           Hp = Hp - 40;
           I64[Sp] = block_caeO8_info;
           R5 = _sad4o::P64;
           R4 = _sad4k::P64;
           R3 = _sad4m::P64;
           R2 = _sad4i::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeMV_info" {
     block_caeMV_info:
         const _caeMV;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeO8() //  [R1]
         { []
         }
     {offset
       caeO8: // global
           I64[Sp + 32] = block_caeOr_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeO8_info" {
     block_caeO8_info:
         const _caeO8;
         const 900;
         const 30;
 },
 _caeNg() //  [R1]
         { []
         }
     {offset
       caeNg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeOk; else goto caeOj;
       caeOk: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeOj: // global
           _sad4i::P64 = P64[Sp + 32];
           _sad4k::P64 = P64[Sp + 40];
           _sad4m::P64 = P64[Sp + 24];
           _sad4E::P64 = P64[Sp + 8];
           if (R1 == 0) goto caeOH; else goto caeOC;
       caeOH: // global
           I64[Hp - 32] = sat_sad59_info;
           P64[Hp - 24] = _sad4i::P64;
           P64[Hp - 16] = _sad4k::P64;
           P64[Hp - 8] = _sad4m::P64;
           P64[Hp] = _sad4E::P64;
           I64[Sp + 8] = block_caeOG_info;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 8, upd: 8;
       caeOC: // global
           Hp = Hp - 40;
           I64[Sp] = block_caeOy_info;
           R5 = _sad4E::P64;
           R4 = _sad4k::P64;
           R3 = _sad4m::P64;
           R2 = _sad4i::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeNg_info" {
     block_caeNg_info:
         const _caeNg;
         const 5;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeOG() //  []
         { []
         }
     {offset
       caeOG: // global
           call _sad4J() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caeOG_info" {
     block_caeOG_info:
         const _caeOG;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeOy() //  [R1]
         { []
         }
     {offset
       caeOy: // global
           _sad4E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_sad4J_info;
           R2 = R1;
           R1 = _sad4E::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeOy_info" {
     block_caeOy_info:
         const _caeOy;
         const 5;
         const 4294967326;
         const Saded_srt+448;
 },
 _sad4J() //  []
         { []
         }
     {offset
       sad4J: // global
           I64[Sp] = block_caeNn_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_sad4J_info" {
     block_sad4J_info:
         const _sad4J;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeNn() //  [R1]
         { []
         }
     {offset
       caeNn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeOo; else goto caeOn;
       caeOo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeOn: // global
           _sad4i::P64 = P64[Sp + 24];
           _sad4k::P64 = P64[Sp + 32];
           _sad4m::P64 = P64[Sp + 16];
           _sad4F::P64 = P64[Sp + 8];
           if (R1 == 0) goto caeOx; else goto caeOt;
       caeOx: // global
           I64[Hp - 32] = sat_sad4Y_info;
           P64[Hp - 24] = _sad4i::P64;
           P64[Hp - 16] = _sad4k::P64;
           P64[Hp - 8] = _sad4m::P64;
           P64[Hp] = _sad4F::P64;
           R1 = Hp - 31;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeOt: // global
           Hp = Hp - 40;
           I64[Sp] = block_caeOp_info;
           R5 = _sad4F::P64;
           R4 = _sad4k::P64;
           R3 = _sad4m::P64;
           R2 = _sad4i::P64;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeNn_info" {
     block_caeNn_info:
         const _caeNn;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeOp() //  [R1]
         { []
         }
     {offset
       caeOp: // global
           I64[Sp + 32] = block_caeOr_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeOp_info" {
     block_caeOp_info:
         const _caeOp;
         const 900;
         const 30;
 },
 _caeOr() //  []
         { []
         }
     {offset
       caeOr: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeOr_info" {
     block_caeOr_info:
         const _caeOr;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.353965965 UTC

[section ""data" . GHC.IO.Handle.Internals.withAllHandles___closure" {
     GHC.IO.Handle.Internals.withAllHandles___closure:
         const GHC.IO.Handle.Internals.withAllHandles___info;
         const 0;
 },
 GHC.IO.Handle.Internals.withAllHandles___entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caeQr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withAllHandles___info" {
     GHC.IO.Handle.Internals.withAllHandles___info:
         const GHC.IO.Handle.Internals.withAllHandles___entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Saded_srt+480;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.359815181 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwithHandle'_closure" {
     GHC.IO.Handle.Internals.$wwithHandle'_closure:
         const GHC.IO.Handle.Internals.$wwithHandle'_info;
         const 0;
 },
 io_sad5l_entry() //  [R1]
         { []
         }
     {offset
       caeQO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeQS; else goto caeQT;
       caeQS: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeQT: // global
           I64[Sp - 16] = block_caeQJ_info;
           _sad5f::P64 = P64[R1 + 23];
           R5 = _sad5f::P64;
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sad5f::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sad5l_info" {
     io_sad5l_info:
         const io_sad5l_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Saded_srt+448;
 },
 _caeQJ() //  [R1]
         { []
         }
     {offset
       caeQJ: // global
           I64[Sp] = block_caeQL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeQY; else goto caeQM;
       uaeQY: // global
           call _caeQL(R1) args: 0, res: 0, upd: 0;
       caeQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeQJ_info" {
     block_caeQJ_info:
         const _caeQJ;
         const 1;
         const 30;
 },
 _caeQL() //  [R1]
         { []
         }
     {offset
       caeQL: // global
           I64[Sp] = block_caeQR_info;
           R2 = P64[R1 + 7];
           _sad5s::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad5s::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeQL_info" {
     block_caeQL_info:
         const _caeQL;
         const 1;
         const 30;
 },
 _caeQR() //  []
         { []
         }
     {offset
       caeQR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeQR_info" {
     block_caeQR_info:
         const _caeQR;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.$wwithHandle'_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caeR3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeR4; else goto caeR5;
       caeR4: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwithHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeR5: // global
           I64[Sp - 40] = block_caeQC_info;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wwithHandle'_info" {
     GHC.IO.Handle.Internals.$wwithHandle'_info:
         const GHC.IO.Handle.Internals.$wwithHandle'_entry;
         const 0;
         const 141733920782;
         const 21474836504;
         const Saded_srt+448;
 },
 _caeQC() //  [R1]
         { []
         }
     {offset
       caeQC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeR8; else goto caeR7;
       caeR8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeR7: // global
           I64[Hp - 32] = io_sad5l_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           _caeQE::P64 = Hp - 31;
           if (R1 == 0) goto caeR2; else goto caeR1;
       caeR2: // global
           R1 = _caeQE::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeR1: // global
           R1 = _caeQE::P64;
           Sp = Sp + 40;
           call io_sad5l_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeQC_info" {
     block_caeQC_info:
         const _caeQC;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.372053396 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle1_closure" {
     GHC.IO.Handle.Internals.withHandle1_closure:
         const GHC.IO.Handle.Internals.withHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caeRM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeRN; else goto caeRO;
       caeRN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeRO: // global
           I64[Sp - 32] = block_caeRJ_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeRS; else goto caeRK;
       uaeRS: // global
           call _caeRJ(R1) args: 0, res: 0, upd: 0;
       caeRK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle1_info" {
     GHC.IO.Handle.Internals.withHandle1_info:
         const GHC.IO.Handle.Internals.withHandle1_entry;
         const 0;
         const 12884901902;
         const 21474836504;
         const Saded_srt+488;
 },
 _caeRJ() //  [R1]
         { []
         }
     {offset
       caeRJ: // global
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeRJ_info" {
     block_caeRJ_info:
         const _caeRJ;
         const 3;
         const 4294967326;
         const Saded_srt+488;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.377584654 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle'_closure" {
     GHC.IO.Handle.Internals.withHandle'_closure:
         const GHC.IO.Handle.Internals.withHandle'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle'_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caeS7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle1_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle'_info" {
     GHC.IO.Handle.Internals.withHandle'_info:
         const GHC.IO.Handle.Internals.withHandle'_entry;
         const 0;
         const 4294967310;
         const 21474836504;
         const Saded_srt+496;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.382486027 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'1_closure" {
     GHC.IO.Handle.Internals.withHandle_'1_closure:
         const GHC.IO.Handle.Internals.withHandle_'1_info;
         const 0;
 },
 sat_sad5P_entry() //  [R1, R2]
         { []
         }
     {offset
       caeSv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeSw; else goto caeSx;
       caeSw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeSx: // global
           I64[Sp - 16] = block_caeSs_info;
           _sad5J::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sad5J::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad5P_info" {
     sat_sad5P_info:
         const sat_sad5P_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 _caeSs() //  [R1]
         { []
         }
     {offset
       caeSs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeSA; else goto caeSz;
       caeSA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeSz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeSs_info" {
     block_caeSs_info:
         const _caeSs;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.withHandle_'1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caeSB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caeSC; else goto caeSD;
       caeSC: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.withHandle_'1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeSD: // global
           I64[Sp - 32] = block_caeSi_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaeSH; else goto caeSj;
       uaeSH: // global
           call _caeSi(R1) args: 0, res: 0, upd: 0;
       caeSj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle_'1_info" {
     GHC.IO.Handle.Internals.withHandle_'1_info:
         const GHC.IO.Handle.Internals.withHandle_'1_entry;
         const 0;
         const 21474836494;
         const 21474836504;
         const Saded_srt+488;
 },
 _caeSi() //  [R1]
         { []
         }
     {offset
       caeSi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeSG; else goto caeSF;
       caeSG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeSF: // global
           _sad5I::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sad5P_info;
           P64[Hp] = P64[Sp + 24];
           R5 = Hp - 6;
           R4 = _sad5I::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeSi_info" {
     block_caeSi_info:
         const _caeSi;
         const 3;
         const 4294967326;
         const Saded_srt+488;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.391675939 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_'_closure" {
     GHC.IO.Handle.Internals.withHandle_'_closure:
         const GHC.IO.Handle.Internals.withHandle_'_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_'_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       caeT9: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.withHandle_'1_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle_'_info" {
     GHC.IO.Handle.Internals.withHandle_'_info:
         const GHC.IO.Handle.Internals.withHandle_'_entry;
         const 0;
         const 4294967310;
         const 21474836504;
         const Saded_srt+504;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.401176378 UTC

[section ""data" . withHandle_2_ra7PG_closure" {
     withHandle_2_ra7PG_closure:
         const withHandle_2_ra7PG_info;
         const 0;
 },
 sat_sad68_entry() //  [R1, R2]
         { []
         }
     {offset
       caeTE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeTF; else goto caeTG;
       caeTF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeTG: // global
           I64[Sp - 16] = block_caeTB_info;
           _sad62::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sad62::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad68_info" {
     sat_sad68_info:
         const sat_sad68_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 _caeTB() //  [R1]
         { []
         }
     {offset
       caeTB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeTJ; else goto caeTI;
       caeTJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeTI: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeTB_info" {
     block_caeTB_info:
         const _caeTB;
         const 1;
         const 30;
 },
 io_sad60_entry() //  [R1]
         { []
         }
     {offset
       caeTP: // global
           _sad60::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeTT; else goto caeTU;
       caeTU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeTW; else goto caeTV;
       caeTW: // global
           HpAlloc = 16;
           goto caeTT;
       caeTT: // global
           R1 = _sad60::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeTV: // global
           _sad5Q::P64 = P64[_sad60::P64 + 7];
           _sad5S::P64 = P64[_sad60::P64 + 15];
           _sad5U::P64 = P64[_sad60::P64 + 23];
           _sad5W::P64 = P64[_sad60::P64 + 31];
           I64[Hp - 8] = sat_sad68_info;
           P64[Hp] = _sad5S::P64;
           I64[Sp - 16] = block_caeTK_info;
           R5 = _sad5W::P64;
           R4 = Hp - 6;
           R3 = _sad5U::P64;
           R2 = _sad5Q::P64;
           P64[Sp - 8] = _sad5W::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sad60_info" {
     io_sad60_info:
         const io_sad60_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Saded_srt+448;
 },
 _caeTK() //  [R1]
         { []
         }
     {offset
       caeTK: // global
           I64[Sp] = block_caeTM_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeU1; else goto caeTN;
       uaeU1: // global
           call _caeTM(R1) args: 0, res: 0, upd: 0;
       caeTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeTK_info" {
     block_caeTK_info:
         const _caeTK;
         const 1;
         const 30;
 },
 _caeTM() //  [R1]
         { []
         }
     {offset
       caeTM: // global
           I64[Sp] = block_caeTS_info;
           R2 = P64[R1 + 7];
           _sad6e::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad6e::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeTM_info" {
     block_caeTM_info:
         const _caeTM;
         const 1;
         const 30;
 },
 _caeTS() //  []
         { []
         }
     {offset
       caeTS: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeTS_info" {
     block_caeTS_info:
         const _caeTS;
         const 1;
         const 30;
 },
 sat_sad6v_entry() //  [R1, R2]
         { []
         }
     {offset
       caeUj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeUk; else goto caeUl;
       caeUk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeUl: // global
           I64[Sp - 16] = block_caeUg_info;
           _sad6p::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sad6p::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad6v_info" {
     sat_sad6v_info:
         const sat_sad6v_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 _caeUg() //  [R1]
         { []
         }
     {offset
       caeUg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeUo; else goto caeUn;
       caeUo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeUn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeUg_info" {
     block_caeUg_info:
         const _caeUg;
         const 1;
         const 30;
 },
 io_sad6n_entry() //  [R1]
         { []
         }
     {offset
       caeUu: // global
           _sad6n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeUy; else goto caeUz;
       caeUz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeUB; else goto caeUA;
       caeUB: // global
           HpAlloc = 16;
           goto caeUy;
       caeUy: // global
           R1 = _sad6n::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeUA: // global
           _sad5Q::P64 = P64[_sad6n::P64 + 7];
           _sad5S::P64 = P64[_sad6n::P64 + 15];
           _sad5U::P64 = P64[_sad6n::P64 + 23];
           _sad6i::P64 = P64[_sad6n::P64 + 31];
           I64[Hp - 8] = sat_sad6v_info;
           P64[Hp] = _sad5S::P64;
           I64[Sp - 16] = block_caeUp_info;
           R5 = _sad6i::P64;
           R4 = Hp - 6;
           R3 = _sad5U::P64;
           R2 = _sad5Q::P64;
           P64[Sp - 8] = _sad6i::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sad6n_info" {
     io_sad6n_info:
         const io_sad6n_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Saded_srt+448;
 },
 _caeUp() //  [R1]
         { []
         }
     {offset
       caeUp: // global
           I64[Sp] = block_caeUr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeUG; else goto caeUs;
       uaeUG: // global
           call _caeUr(R1) args: 0, res: 0, upd: 0;
       caeUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeUp_info" {
     block_caeUp_info:
         const _caeUp;
         const 1;
         const 30;
 },
 _caeUr() //  [R1]
         { []
         }
     {offset
       caeUr: // global
           I64[Sp] = block_caeUx_info;
           R2 = P64[R1 + 7];
           _sad6B::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad6B::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeUr_info" {
     block_caeUr_info:
         const _caeUr;
         const 1;
         const 30;
 },
 _caeUx() //  []
         { []
         }
     {offset
       caeUx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeUx_info" {
     block_caeUx_info:
         const _caeUx;
         const 1;
         const 30;
 },
 withHandle_2_ra7PG_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caeUL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeUM; else goto caeUN;
       caeUM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle_2_ra7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeUN: // global
           I64[Sp - 24] = block_caeTk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeV4; else goto caeTl;
       uaeV4: // global
           call _caeTk(R1) args: 0, res: 0, upd: 0;
       caeTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . withHandle_2_ra7PG_info" {
     withHandle_2_ra7PG_info:
         const withHandle_2_ra7PG_entry;
         const 0;
         const 1103806595086;
         const 17179869207;
         const Saded_srt+448;
 },
 _caeTk() //  [R1]
         { []
         }
     {offset
       caeTk: // global
           if (R1 & 7 == 1) goto caeUI; else goto caeUJ;
       caeUI: // global
           I64[Sp - 16] = block_caeTp_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caeUJ: // global
           I64[Sp - 16] = block_caeU4_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeTk_info" {
     block_caeTk_info:
         const _caeTk;
         const 2;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeTp() //  [R1]
         { []
         }
     {offset
       caeTp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeUR; else goto caeUQ;
       caeUR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeUQ: // global
           I64[Hp - 32] = io_sad60_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caeTr::P64 = Hp - 31;
           if (R1 == 0) goto caeUV; else goto caeUU;
       caeUV: // global
           R1 = _caeTr::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeUU: // global
           R1 = _caeTr::P64;
           Sp = Sp + 40;
           call io_sad60_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeTp_info" {
     block_caeTp_info:
         const _caeTp;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 },
 _caeU4() //  [R1]
         { []
         }
     {offset
       caeU4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeUZ; else goto caeUY;
       caeUZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeUY: // global
           I64[Hp - 32] = io_sad6n_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caeU6::P64 = Hp - 31;
           if (R1 == 0) goto caeV3; else goto caeV2;
       caeV3: // global
           R1 = _caeU6::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeV2: // global
           R1 = _caeU6::P64;
           Sp = Sp + 40;
           call io_sad6n_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeU4_info" {
     block_caeU4_info:
         const _caeU4;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.429898261 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle__closure" {
     GHC.IO.Handle.Internals.withHandle__closure:
         const GHC.IO.Handle.Internals.withHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle__entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caeWD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle_2_ra7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle__info" {
     GHC.IO.Handle.Internals.withHandle__info:
         const GHC.IO.Handle.Internals.withHandle__entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Saded_srt+512;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.438716259 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_1_info;
         const 0;
 },
 sat_sad6W_entry() //  [R1, R2]
         { []
         }
     {offset
       caeX8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeX9; else goto caeXa;
       caeX9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeXa: // global
           I64[Sp - 16] = block_caeX5_info;
           R3 = R2;
           _sad6Q::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sad6Q::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad6W_info" {
     sat_sad6W_info:
         const sat_sad6W_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const Saded_srt+520;
 },
 _caeX5() //  [R1]
         { []
         }
     {offset
       caeX5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeXd; else goto caeXc;
       caeXd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeXc: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeX5_info" {
     block_caeX5_info:
         const _caeX5;
         const 1;
         const 30;
 },
 io_sad6O_entry() //  [R1]
         { []
         }
     {offset
       caeXj: // global
           _sad6O::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeXn; else goto caeXo;
       caeXo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeXq; else goto caeXp;
       caeXq: // global
           HpAlloc = 16;
           goto caeXn;
       caeXn: // global
           R1 = _sad6O::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeXp: // global
           _sad6E::P64 = P64[_sad6O::P64 + 7];
           _sad6G::P64 = P64[_sad6O::P64 + 15];
           _sad6I::P64 = P64[_sad6O::P64 + 23];
           _sad6K::P64 = P64[_sad6O::P64 + 31];
           I64[Hp - 8] = sat_sad6W_info;
           P64[Hp] = _sad6G::P64;
           I64[Sp - 16] = block_caeXe_info;
           R5 = _sad6K::P64;
           R4 = Hp - 6;
           R3 = _sad6I::P64;
           R2 = _sad6E::P64;
           P64[Sp - 8] = _sad6K::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sad6O_info" {
     io_sad6O_info:
         const io_sad6O_entry;
         const 4;
         const 2203318222856;
         const 4294967299;
         const Saded_srt+448;
 },
 _caeXe() //  [R1]
         { []
         }
     {offset
       caeXe: // global
           I64[Sp] = block_caeXg_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeXv; else goto caeXh;
       uaeXv: // global
           call _caeXg(R1) args: 0, res: 0, upd: 0;
       caeXh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeXe_info" {
     block_caeXe_info:
         const _caeXe;
         const 1;
         const 30;
 },
 _caeXg() //  [R1]
         { []
         }
     {offset
       caeXg: // global
           I64[Sp] = block_caeXm_info;
           R2 = P64[R1 + 7];
           _sad72::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad72::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeXg_info" {
     block_caeXg_info:
         const _caeXg;
         const 1;
         const 30;
 },
 _caeXm() //  []
         { []
         }
     {offset
       caeXm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeXm_info" {
     block_caeXm_info:
         const _caeXm;
         const 1;
         const 30;
 },
 sat_sad7j_entry() //  [R1, R2]
         { []
         }
     {offset
       caeXN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caeXO; else goto caeXP;
       caeXO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caeXP: // global
           I64[Sp - 16] = block_caeXK_info;
           R3 = R2;
           _sad7d::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sad7d::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad7j_info" {
     sat_sad7j_info:
         const sat_sad7j_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const Saded_srt+520;
 },
 _caeXK() //  [R1]
         { []
         }
     {offset
       caeXK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caeXS; else goto caeXR;
       caeXS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caeXR: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeXK_info" {
     block_caeXK_info:
         const _caeXK;
         const 1;
         const 30;
 },
 io_sad7b_entry() //  [R1]
         { []
         }
     {offset
       caeXY: // global
           _sad7b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caeY2; else goto caeY3;
       caeY3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caeY5; else goto caeY4;
       caeY5: // global
           HpAlloc = 16;
           goto caeY2;
       caeY2: // global
           R1 = _sad7b::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caeY4: // global
           _sad6E::P64 = P64[_sad7b::P64 + 7];
           _sad6G::P64 = P64[_sad7b::P64 + 15];
           _sad6I::P64 = P64[_sad7b::P64 + 23];
           _sad76::P64 = P64[_sad7b::P64 + 31];
           I64[Hp - 8] = sat_sad7j_info;
           P64[Hp] = _sad6G::P64;
           I64[Sp - 16] = block_caeXT_info;
           R5 = _sad76::P64;
           R4 = Hp - 6;
           R3 = _sad6I::P64;
           R2 = _sad6E::P64;
           P64[Sp - 8] = _sad76::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sad7b_info" {
     io_sad7b_info:
         const io_sad7b_entry;
         const 4;
         const 2203318222856;
         const 4294967299;
         const Saded_srt+448;
 },
 _caeXT() //  [R1]
         { []
         }
     {offset
       caeXT: // global
           I64[Sp] = block_caeXV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaeYa; else goto caeXW;
       uaeYa: // global
           call _caeXV(R1) args: 0, res: 0, upd: 0;
       caeXW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeXT_info" {
     block_caeXT_info:
         const _caeXT;
         const 1;
         const 30;
 },
 _caeXV() //  [R1]
         { []
         }
     {offset
       caeXV: // global
           I64[Sp] = block_caeY1_info;
           R2 = P64[R1 + 7];
           _sad7p::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad7p::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeXV_info" {
     block_caeXV_info:
         const _caeXV;
         const 1;
         const 30;
 },
 _caeY1() //  []
         { []
         }
     {offset
       caeY1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeY1_info" {
     block_caeY1_info:
         const _caeY1;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.wantReadableHandle_1_entry() //  [R2, R3,
                                                           R4]
         { []
         }
     {offset
       caeYf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caeYg; else goto caeYh;
       caeYg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caeYh: // global
           I64[Sp - 24] = block_caeWO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaeYy; else goto caeWP;
       uaeYy: // global
           call _caeWO(R1) args: 0, res: 0, upd: 0;
       caeWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle_1_info" {
     GHC.IO.Handle.Internals.wantReadableHandle_1_info:
         const GHC.IO.Handle.Internals.wantReadableHandle_1_entry;
         const 0;
         const 6601364733966;
         const 17179869207;
         const Saded_srt+448;
 },
 _caeWO() //  [R1]
         { []
         }
     {offset
       caeWO: // global
           if (R1 & 7 == 1) goto caeYc; else goto caeYd;
       caeYc: // global
           I64[Sp - 16] = block_caeWT_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caeYd: // global
           I64[Sp - 16] = block_caeXy_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caeWO_info" {
     block_caeWO_info:
         const _caeWO;
         const 2;
         const 2203318222878;
         const Saded_srt+448;
 },
 _caeWT() //  [R1]
         { []
         }
     {offset
       caeWT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeYl; else goto caeYk;
       caeYl: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeYk: // global
           I64[Hp - 32] = io_sad6O_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caeWV::P64 = Hp - 31;
           if (R1 == 0) goto caeYp; else goto caeYo;
       caeYp: // global
           R1 = _caeWV::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeYo: // global
           R1 = _caeWV::P64;
           Sp = Sp + 40;
           call io_sad6O_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeWT_info" {
     block_caeWT_info:
         const _caeWT;
         const 4;
         const 2203318222878;
         const Saded_srt+448;
 },
 _caeXy() //  [R1]
         { []
         }
     {offset
       caeXy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caeYt; else goto caeYs;
       caeYt: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caeYs: // global
           I64[Hp - 32] = io_sad7b_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caeXA::P64 = Hp - 31;
           if (R1 == 0) goto caeYx; else goto caeYw;
       caeYx: // global
           R1 = _caeXA::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caeYw: // global
           R1 = _caeXA::P64;
           Sp = Sp + 40;
           call io_sad7b_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caeXy_info" {
     block_caeXy_info:
         const _caeXy;
         const 4;
         const 2203318222878;
         const Saded_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.468272488 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle__closure" {
     GHC.IO.Handle.Internals.wantReadableHandle__closure:
         const GHC.IO.Handle.Internals.wantReadableHandle__info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle__entry() //  [R2, R3,
                                                          R4]
         { []
         }
     {offset
       caf07: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle__info" {
     GHC.IO.Handle.Internals.wantReadableHandle__info:
         const GHC.IO.Handle.Internals.wantReadableHandle__entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Saded_srt+528;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.47256662 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle2_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle2_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle2_info;
         const 0;
 },
 sat_sad7x_entry() //  [R1]
         { []
         }
     {offset
       caf0o: // global
           _sad7x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caf0p; else goto caf0q;
       caf0q: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caf0s; else goto caf0r;
       caf0s: // global
           HpAlloc = 72;
           goto caf0p;
       caf0p: // global
           R1 = _sad7x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caf0r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sad7x::P64;
           _sad7s::P64 = P64[_sad7x::P64 + 16];
           _sad7t::P64 = P64[_sad7x::P64 + 24];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sad7t::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = _sad7s::P64;
           P64[Hp - 16] = GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sad7x_info" {
     sat_sad7x_info:
         const sat_sad7x_entry;
         const 2;
         const 281479271677970;
         const Saded_srt+408;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle2_entry() //  [R2, R3]
         { []
         }
     {offset
       caf0t: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caf0x; else goto caf0w;
       caf0x: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caf0w: // global
           I64[Hp - 24] = sat_sad7x_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle2_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle2_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle2_entry;
         const 0;
         const 844429225099278;
         const 12884901903;
         const Saded_srt+408;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.483725179 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle1_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle1_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle1_info;
         const 0;
 },
 sat_sad8g_entry() //  [R1, R2]
         { []
         }
     {offset
       caf1g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caf1h; else goto caf1i;
       caf1h: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caf1i: // global
           I64[Sp - 16] = block_caf1d_info;
           _sad7A::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sad7A::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaf28; else goto caf1e;
       uaf28: // global
           call _caf1d(R1) args: 0, res: 0, upd: 0;
       caf1e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sad8g_info" {
     sat_sad8g_info:
         const sat_sad8g_entry;
         const 1;
         const 30064771081;
         const 8589934597;
         const Saded_srt+552;
 },
 _caf1d() //  [R1]
         { []
         }
     {offset
       caf1d: // global
           I64[Sp - 24] = block_caf1l_info;
           _sad7M::P64 = R1;
           _sad7N::P64 = P64[R1 + 7];
           _sad7Q::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sad7N::P64;
           P64[Sp - 8] = _sad7Q::P64;
           P64[Sp] = _sad7M::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf27; else goto caf1n;
       uaf27: // global
           call _caf1l(R1) args: 0, res: 0, upd: 0;
       caf1n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf1d_info" {
     block_caf1d_info:
         const _caf1d;
         const 1;
         const 30064771102;
         const Saded_srt+552;
 },
 _caf1l() //  [R1]
         { []
         }
     {offset
       caf1l: // global
           _caf21::P64 = R1 & 7;
           if (_caf21::P64 < 3) goto uaf23; else goto uaf24;
       uaf23: // global
           if (_caf21::P64 < 2) goto caf1S; else goto caf1W;
       caf1S: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caf1W: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uaf24: // global
           if (_caf21::P64 != 5) goto caf1w; else goto uaf25;
       caf1w: // global
           _sad7Q::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_caf1r_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sad7Q::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
       uaf25: // global
           Sp = Sp + 40;
           call _caf20() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caf1l_info" {
     block_caf1l_info:
         const _caf1l;
         const 4;
         const 30064771102;
         const Saded_srt+552;
 },
 _caf1r() //  [R1]
         { []
         }
     {offset
       caf1r: // global
           I64[Sp] = block_caf1t_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaf2a; else goto caf1y;
       uaf2a: // global
           call _caf1t(R1) args: 0, res: 0, upd: 0;
       caf1y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf1r_info" {
     block_caf1r_info:
         const _caf1r;
         const 2;
         const 4294967326;
         const Saded_srt+552;
 },
 _caf1t() //  [R1]
         { []
         }
     {offset
       caf1t: // global
           if (R1 & 7 == 1) goto uaf26; else goto caf1L;
       uaf26: // global
           Sp = Sp + 24;
           call _caf20() args: 0, res: 0, upd: 0;
       caf1L: // global
           I64[Sp] = block_caf1H_info;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf1t_info" {
     block_caf1t_info:
         const _caf1t;
         const 2;
         const 4294967326;
         const Saded_srt+552;
 },
 _caf1H() //  [R1]
         { []
         }
     {offset
       caf1H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf1O; else goto caf1N;
       caf1O: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf1N: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caf1H_info" {
     block_caf1H_info:
         const _caf1H;
         const 130;
         const 30;
 },
 _caf20() //  []
         { []
         }
     {offset
       caf20: // global
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sad7I_entry() //  [R1]
         { []
         }
     {offset
       caf2h: // global
           _sad7I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caf2l; else goto caf2m;
       caf2m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caf2o; else goto caf2n;
       caf2o: // global
           HpAlloc = 16;
           goto caf2l;
       caf2l: // global
           R1 = _sad7I::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caf2n: // global
           _sad7y::P64 = P64[_sad7I::P64 + 7];
           _sad7A::P64 = P64[_sad7I::P64 + 15];
           _sad7C::P64 = P64[_sad7I::P64 + 23];
           _sad7E::P64 = P64[_sad7I::P64 + 31];
           I64[Hp - 8] = sat_sad8g_info;
           P64[Hp] = _sad7A::P64;
           I64[Sp - 16] = block_caf2c_info;
           R5 = _sad7E::P64;
           R4 = Hp - 6;
           R3 = _sad7C::P64;
           R2 = _sad7y::P64;
           P64[Sp - 8] = _sad7E::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sad7I_info" {
     io_sad7I_info:
         const io_sad7I_entry;
         const 4;
         const 246294899589128;
         const 4294967299;
         const Saded_srt+448;
 },
 _caf2c() //  [R1]
         { []
         }
     {offset
       caf2c: // global
           I64[Sp] = block_caf2e_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaf2t; else goto caf2f;
       uaf2t: // global
           call _caf2e(R1) args: 0, res: 0, upd: 0;
       caf2f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf2c_info" {
     block_caf2c_info:
         const _caf2c;
         const 1;
         const 30;
 },
 _caf2e() //  [R1]
         { []
         }
     {offset
       caf2e: // global
           I64[Sp] = block_caf2k_info;
           R2 = P64[R1 + 7];
           _sad8m::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sad8m::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf2e_info" {
     block_caf2e_info:
         const _caf2e;
         const 1;
         const 30;
 },
 _caf2k() //  []
         { []
         }
     {offset
       caf2k: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caf2k_info" {
     block_caf2k_info:
         const _caf2k;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle1_entry() //  [R2, R3,
                                                          R4]
         { []
         }
     {offset
       caf2y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caf2z; else goto caf2A;
       caf2z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caf2A: // global
           I64[Sp - 24] = block_caf0W_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf2M; else goto caf0X;
       uaf2M: // global
           call _caf0W(R1) args: 0, res: 0, upd: 0;
       caf0X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle1_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle1_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle1_entry;
         const 0;
         const 545362062344206;
         const 17179869207;
         const Saded_srt+448;
 },
 _caf0W() //  [R1]
         { []
         }
     {offset
       caf0W: // global
           if (R1 & 7 == 1) goto caf2v; else goto caf2w;
       caf2v: // global
           I64[Sp - 16] = block_caf11_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       caf2w: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.wantSeekableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caf0W_info" {
     block_caf0W_info:
         const _caf0W;
         const 2;
         const 263887085633566;
         const Saded_srt+448;
 },
 _caf11() //  [R1]
         { []
         }
     {offset
       caf11: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caf2E; else goto caf2D;
       caf2E: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       caf2D: // global
           I64[Hp - 32] = io_sad7I_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caf13::P64 = Hp - 31;
           if (R1 == 0) goto caf2I; else goto caf2H;
       caf2I: // global
           R1 = _caf13::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       caf2H: // global
           R1 = _caf13::P64;
           Sp = Sp + 40;
           call io_sad7I_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caf11_info" {
     block_caf11_info:
         const _caf11;
         const 4;
         const 246294899589150;
         const Saded_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.508239688 UTC

[section ""data" . GHC.IO.Handle.Internals.wantSeekableHandle_closure" {
     GHC.IO.Handle.Internals.wantSeekableHandle_closure:
         const GHC.IO.Handle.Internals.wantSeekableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantSeekableHandle_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       caf46: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantSeekableHandle_info" {
     GHC.IO.Handle.Internals.wantSeekableHandle_info:
         const GHC.IO.Handle.Internals.wantSeekableHandle_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Saded_srt+576;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.523626027 UTC

[section ""data" . GHC.IO.Handle.Internals.$wwantWritableHandle'_closure" {
     GHC.IO.Handle.Internals.$wwantWritableHandle'_closure:
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_info;
         const 0;
 },
 sat_sad9y_entry() //  [R1]
         { []
         }
     {offset
       caf53: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caf57; else goto caf58;
       caf57: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caf58: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caf50_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf5c; else goto caf51;
       uaf5c: // global
           call _caf50(R1) args: 0, res: 0, upd: 0;
       caf51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sad9y_info" {
     sat_sad9y_info:
         const sat_sad9y_entry;
         const 1;
         const 16;
 },
 _caf50() //  [R1]
         { []
         }
     {offset
       caf50: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caf5b; else goto caf5a;
       caf5b: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caf5a: // global
           _sad9t::P64 = P64[R1 + 7];
           _sad9s::I64 = I64[R1 + 23];
           _sad9v::I64 = I64[R1 + 31];
           _sad9w::I64 = I64[R1 + 39];
           _sad9x::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sad9t::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sad9s::I64;
           I64[Hp - 16] = _sad9v::I64;
           I64[Hp - 8] = _sad9w::I64;
           I64[Hp] = _sad9x::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caf50_info" {
     block_caf50_info:
         const _caf50;
         const 0;
         const 30;
 },
 sat_sada3_entry() //  [R1]
         { []
         }
     {offset
       caf5x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caf5B; else goto caf5C;
       caf5B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caf5C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caf5u_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf5G; else goto caf5v;
       uaf5G: // global
           call _caf5u(R1) args: 0, res: 0, upd: 0;
       caf5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sada3_info" {
     sat_sada3_info:
         const sat_sada3_entry;
         const 1;
         const 16;
 },
 _caf5u() //  [R1]
         { []
         }
     {offset
       caf5u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caf5F; else goto caf5E;
       caf5F: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caf5E: // global
           _sad9Y::P64 = P64[R1 + 7];
           _sad9Z::P64 = P64[R1 + 15];
           _sad9X::I64 = I64[R1 + 23];
           _sada0::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sad9Y::P64;
           P64[Hp - 32] = _sad9Z::P64;
           I64[Hp - 24] = _sad9X::I64;
           I64[Hp - 16] = _sada0::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caf5u_info" {
     block_caf5u_info:
         const _caf5u;
         const 0;
         const 30;
 },
 sat_sadam_entry() //  [R1]
         { []
         }
     {offset
       caf63: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caf6a; else goto caf6b;
       caf6a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caf6b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caf60_info;
           _sadac::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sadac::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaf6f; else goto caf61;
       uaf6f: // global
           call _caf60(R1) args: 0, res: 0, upd: 0;
       caf61: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sadam_info" {
     sat_sadam_info:
         const sat_sadam_entry;
         const 4294967297;
         const 19;
 },
 _caf60() //  [R1]
         { []
         }
     {offset
       caf60: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caf6e; else goto caf6d;
       caf6e: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caf6d: // global
           _sadag::P64 = P64[R1 + 7];
           _sadah::P64 = P64[R1 + 15];
           _sadaf::I64 = I64[R1 + 23];
           _sadai::I64 = I64[R1 + 31];
           _sadak::I64 = I64[R1 + 47];
           _sadal::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sadag::P64;
           P64[Hp - 32] = _sadah::P64;
           I64[Hp - 24] = _sadaf::I64;
           I64[Hp - 16] = _sadai::I64;
           I64[Hp - 8] = _sadal::I64;
           I64[Hp] = _sadak::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caf60_info" {
     block_caf60_info:
         const _caf60;
         const 65;
         const 30;
 },
 section ""relreadonly" . uaf8F_srtd" {
     uaf8F_srtd:
         const Saded_srt+104;
         const 59;
         const 432345564228616193;
 },
 sat_sadaL_entry() //  [R1, R2]
         { []
         }
     {offset
       caf6g: // global
           if ((Sp + -112) < SpLim) (likely: False) goto caf6h; else goto caf6i;
       caf6h: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caf6i: // global
           I64[Sp - 16] = block_caf4m_info;
           _sad8v::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sad8v::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaf8x; else goto caf4n;
       uaf8x: // global
           call _caf4m(R1) args: 0, res: 0, upd: 0;
       caf4n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sadaL_info" {
     sat_sadaL_info:
         const sat_sadaL_entry;
         const 1;
         const 18446744069414584329;
         const 8589934597;
         const uaf8F_srtd;
 },
 section ""relreadonly" . uaf8G_srtd" {
     uaf8G_srtd:
         const Saded_srt+104;
         const 59;
         const 432345564228616193;
 },
 _caf4m() //  [R1]
         { []
         }
     {offset
       caf4m: // global
           I64[Sp - 56] = block_caf4r_info;
           _sad8z::P64 = R1;
           _sad8B::P64 = P64[R1 + 15];
           _sad8D::P64 = P64[R1 + 31];
           _sad8F::P64 = P64[R1 + 47];
           _sad8H::P64 = P64[R1 + 63];
           _sad8I::P64 = P64[R1 + 71];
           _sad8L::P64 = P64[R1 + 95];
           R1 = P64[R1 + 39];
           P64[Sp - 48] = _sad8B::P64;
           P64[Sp - 40] = _sad8D::P64;
           P64[Sp - 32] = _sad8F::P64;
           P64[Sp - 24] = _sad8H::P64;
           P64[Sp - 16] = _sad8I::P64;
           P64[Sp - 8] = _sad8L::P64;
           P64[Sp] = _sad8z::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uaf8k; else goto caf4s;
       uaf8k: // global
           call _caf4r(R1) args: 0, res: 0, upd: 0;
       caf4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf4m_info" {
     block_caf4m_info:
         const _caf4m;
         const 1;
         const 18446744069414584350;
         const uaf8G_srtd;
 },
 section ""relreadonly" . uaf8H_srtd" {
     uaf8H_srtd:
         const Saded_srt+104;
         const 59;
         const 432345564228616193;
 },
 _caf4r() //  [R1]
         { []
         }
     {offset
       caf4r: // global
           _caf7Y::P64 = R1 & 7;
           if (_caf7Y::P64 < 4) goto uaf8c; else goto uaf8e;
       uaf8c: // global
           if (_caf7Y::P64 < 3) goto uaf8d; else goto caf6C;
       uaf8d: // global
           if (_caf7Y::P64 < 2) goto caf6w; else goto caf6z;
       caf6w: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle11_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caf6z: // global
           R1 = GHC.IO.Handle.Internals.wantReadableHandle7_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       caf6C: // global
           R1 = GHC.IO.Handle.Internals.wantWritableHandle2_closure;
           Sp = Sp + 72;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       uaf8e: // global
           if (_caf7Y::P64 < 6) goto caf6q; else goto caf6E;
       caf6q: // global
           I64[Sp + 48] = block_caf6l_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       caf6E: // global
           _sad90::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_caf4A_info;
           R1 = _sad90::P64;
           if (R1 & 7 != 0) goto uaf8l; else goto caf4B;
       uaf8l: // global
           call _caf4A(R1) args: 0, res: 0, upd: 0;
       caf4B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf4r_info" {
     block_caf4r_info:
         const _caf4r;
         const 8;
         const 18446744069414584350;
         const uaf8H_srtd;
 },
 _caf6l() //  [R1]
         { []
         }
     {offset
       caf6l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf6t; else goto caf6s;
       caf6t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf6s: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caf6l_info" {
     block_caf6l_info:
         const _caf6l;
         const 130;
         const 30;
 },
 _caf4A() //  [R1]
         { []
         }
     {offset
       caf4A: // global
           I64[Sp] = block_caf4F_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uaf8m; else goto caf4G;
       uaf8m: // global
           call _caf4F(R1) args: 0, res: 0, upd: 0;
       caf4G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf4A_info" {
     block_caf4A_info:
         const _caf4A;
         const 8;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf4F() //  [R1]
         { []
         }
     {offset
       caf4F: // global
           if (R1 & 7 == 1) goto caf6I; else goto caf7U;
       caf6I: // global
           _sad9b::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_caf4K_info;
           R1 = _sad9b::P64;
           if (R1 & 7 != 0) goto uaf8n; else goto caf4L;
       uaf8n: // global
           call _caf4K(R1) args: 0, res: 0, upd: 0;
       caf4L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caf7U: // global
           I64[Sp + 48] = block_caf7Q_info;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 64];
           Sp = Sp + 48;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf4F_info" {
     block_caf4F_info:
         const _caf4F;
         const 8;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf4K() //  [R1]
         { []
         }
     {offset
       caf4K: // global
           I64[Sp - 16] = block_caf5d_info;
           _sad9h::I64 = I64[R1 + 39];
           _sad9i::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sad9i::I64;
           I64[Sp] = _sad9h::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaf8o; else goto caf5e;
       uaf8o: // global
           call _caf5d(R1) args: 0, res: 0, upd: 0;
       caf5e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf4K_info" {
     block_caf4K_info:
         const _caf4K;
         const 8;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf5d() //  [R1]
         { []
         }
     {offset
       caf5d: // global
           if (R1 & 7 == 1) goto caf7J; else goto uaf8f;
       caf7J: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto uaf8g; else goto caf75;
       uaf8g: // global
           Sp = Sp + 24;
           goto uaf8r;
       caf75: // global
           _sad9P::P64 = P64[P64[Sp + 48] + 8];
           I64[Sp + 16] = block_caf5l_info;
           R1 = _sad9P::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uaf8p; else goto caf5m;
       uaf8p: // global
           call _caf5l(R1) args: 0, res: 0, upd: 0;
       caf5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uaf8f: // global
           Sp = Sp + 24;
           goto uaf8r;
       uaf8r: // global
           call _sad9j() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caf5d_info" {
     block_caf5d_info:
         const _caf5d;
         const 202;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf5l() //  [R1]
         { []
         }
     {offset
       caf5l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf78; else goto caf77;
       caf78: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf77: // global
           _sad8I::P64 = P64[Sp + 40];
           _sad9R::P64 = P64[R1 + 7];
           _sad9S::P64 = P64[R1 + 15];
           _sad9V::P64 = P64[_sad8I::P64 + 8];
           I64[Hp - 16] = sat_sada3_info;
           P64[Hp] = _sad9V::P64;
           call MO_WriteBarrier();
           P64[_sad8I::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8I::P64);
           I64[Sp - 8] = block_caf5K_info;
           R1 = _sad9V::P64;
           P64[Sp] = _sad9S::P64;
           P64[Sp + 32] = _sad9R::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaf8s; else goto caf5L;
       uaf8s: // global
           call _caf5K(R1) args: 0, res: 0, upd: 0;
       caf5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf5l_info" {
     block_caf5l_info:
         const _caf5l;
         const 520;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf5K() //  [R1]
         { []
         }
     {offset
       caf5K: // global
           _sadac::I64 = I64[R1 + 39];
           if (_sadac::I64 != 0) goto caf7b; else goto caf7G;
       caf7b: // global
           I64[Sp - 24] = block_caf5R_info;
           _sada7::P64 = P64[R1 + 7];
           _sada8::P64 = P64[R1 + 15];
           _sada6::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           P64[Sp - 16] = _sada8::P64;
           I64[Sp - 8] = _sadac::I64;
           P64[Sp] = _sada7::P64;
           I64[Sp + 56] = _sada6::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaf8t; else goto caf5S;
       uaf8t: // global
           call _caf5R(R1) args: 0, res: 0, upd: 0;
       caf5S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caf7G: // global
           _sad8F::P64 = P64[Sp + 32];
           _sad9S::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sad8F::P64 + 8] = _sad9S::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8F::P64);
           Sp = Sp + 16;
           call _sad9j() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caf5K_info" {
     block_caf5K_info:
         const _caf5K;
         const 9;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf5R() //  [R1]
         { []
         }
     {offset
       caf5R: // global
           if (R1 & 7 == 1) goto caf7d; else goto caf7v;
       caf7d: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caf7g; else goto caf7f;
       caf7g: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf7f: // global
           I64[Hp - 24] = sat_sadam_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sad8F::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sad8F::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8F::P64);
           Sp = Sp + 40;
           call _sad9j() args: 0, res: 0, upd: 0;
       caf7v: // global
           I64[Sp] = block_caf7j_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uaf8v; else goto caf7k;
       uaf8v: // global
           call _caf7j(R1) args: 0, res: 0, upd: 0;
       caf7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf5R_info" {
     block_caf5R_info:
         const _caf5R;
         const 32908;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf7j() //  [R1]
         { []
         }
     {offset
       caf7j: // global
           I64[Sp - 8] = block_caf7o_info;
           R2 = P64[Sp + 64];
           _sadaq::P64 = P64[R1 + 7];
           _sadar::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sadar::P64;
           P64[Sp + 64] = _sadaq::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf7j_info" {
     block_caf7j_info:
         const _caf7j;
         const 32908;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf7o() //  [R1]
         { []
         }
     {offset
       caf7o: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caf7z; else goto caf7y;
       caf7z: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf7y: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sad9S::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_caf7r_info;
           R5 = Hp - 47;
           R4 = _sad9S::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 72];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf7o_info" {
     block_caf7o_info:
         const _caf7o;
         const 65805;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf7r() //  [R1]
         { []
         }
     {offset
       caf7r: // global
           I64[Sp] = block_caf7t_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaf8y; else goto caf7B;
       uaf8y: // global
           call _caf7t(R1) args: 0, res: 0, upd: 0;
       caf7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf7r_info" {
     block_caf7r_info:
         const _caf7r;
         const 2568;
         const 4294967326;
         const Saded_srt+584;
 },
 _caf7t() //  [R1]
         { []
         }
     {offset
       caf7t: // global
           _sad8F::P64 = P64[Sp + 24];
           _sadaD::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sad8F::P64 + 8] = _sadaD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8F::P64);
           Sp = Sp + 8;
           call _sad9j() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_caf7t_info" {
     block_caf7t_info:
         const _caf7t;
         const 2568;
         const 4294967326;
         const Saded_srt+584;
 },
 _sad9j() //  []
         { []
         }
     {offset
       sad9j: // global
           I64[Sp - 8] = block_caf4U_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _caf4U() //  [R1]
         { []
         }
     {offset
       caf4U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf6Y; else goto caf6X;
       caf6Y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf6X: // global
           _sad8I::P64 = P64[Sp + 40];
           _sad9q::P64 = P64[_sad8I::P64 + 8];
           I64[Hp - 16] = sat_sad9y_info;
           P64[Hp] = _sad9q::P64;
           _sad8B::P64 = P64[Sp + 8];
           _sad8D::P64 = P64[Sp + 16];
           _sad8F::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sad8I::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8I::P64);
           I64[Sp + 16] = block_caf6N_info;
           R2 = _sad8B::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sad8D::P64;
           P64[Sp + 8] = P64[_sad8F::P64 + 8];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.emptyWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf4U_info" {
     block_caf4U_info:
         const _caf4U;
         const 2568;
         const 30;
 },
 _caf6N() //  [R1]
         { []
         }
     {offset
       caf6N: // global
           _sad8v::P64 = P64[Sp + 48];
           _sad8z::P64 = P64[Sp + 40];
           _sad8F::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sad8F::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sad8F::P64);
           I64[Sp + 32] = block_caf6S_info;
           R2 = _sad8z::P64;
           R1 = _sad8v::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caf6N_info" {
     block_caf6N_info:
         const _caf6N;
         const 902;
         const 30;
 },
 _caf6S() //  [R1]
         { []
         }
     {offset
       caf6S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf72; else goto caf71;
       caf72: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf71: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caf6S_info" {
     block_caf6S_info:
         const _caf6S;
         const 130;
         const 30;
 },
 _caf7Q() //  [R1]
         { []
         }
     {offset
       caf7Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caf7X; else goto caf7W;
       caf7X: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caf7W: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caf7Q_info" {
     block_caf7Q_info:
         const _caf7Q;
         const 130;
         const 30;
 },
 section ""relreadonly" . uaf8I_srtd" {
     uaf8I_srtd:
         const Saded_srt+104;
         const 62;
         const 3891391553024819201;
 },
 GHC.IO.Handle.Internals.$wwantWritableHandle'_entry() //  [R2, R3,
                                                            R4, R5]
         { []
         }
     {offset
       caf8A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caf8E; else goto caf8D;
       caf8E: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caf8D: // global
           I64[Hp - 8] = sat_sadaL_info;
           P64[Hp] = R5;
           R5 = Hp - 6;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.$wwantWritableHandle'_info" {
     GHC.IO.Handle.Internals.$wwantWritableHandle'_info:
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_entry;
         const 0;
         const 18446744069414584334;
         const 21474836504;
         const uaf8I_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.578322936 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle1_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle1_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle1_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle1_entry() //  [R2, R3,
                                                          R4]
         { []
         }
     {offset
       cafbM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cafbN; else goto cafbO;
       cafbN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantWritableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cafbO: // global
           I64[Sp - 24] = block_cafbF_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafbV; else goto cafbG;
       uafbV: // global
           call _cafbF(R1) args: 0, res: 0, upd: 0;
       cafbG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantWritableHandle1_info" {
     GHC.IO.Handle.Internals.wantWritableHandle1_info:
         const GHC.IO.Handle.Internals.wantWritableHandle1_entry;
         const 0;
         const 12884901902;
         const 17179869207;
         const Saded_srt+592;
 },
 _cafbF() //  [R1]
         { []
         }
     {offset
       cafbF: // global
           _sadaM::P64 = P64[Sp + 8];
           _sadaO::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cafbJ; else goto cafbK;
       cafbJ: // global
           R5 = _sadaO::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = _sadaM::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cafbK: // global
           R5 = _sadaO::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = _sadaM::P64;
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cafbF_info" {
     block_cafbF_info:
         const _cafbF;
         const 2;
         const 4294967326;
         const Saded_srt+592;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.583925964 UTC

[section ""data" . GHC.IO.Handle.Internals.wantWritableHandle_closure" {
     GHC.IO.Handle.Internals.wantWritableHandle_closure:
         const GHC.IO.Handle.Internals.wantWritableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantWritableHandle_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cafcc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantWritableHandle_info" {
     GHC.IO.Handle.Internals.wantWritableHandle_info:
         const GHC.IO.Handle.Internals.wantWritableHandle_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Saded_srt+600;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.591505222 UTC

[section ""data" . withHandle2_ra7PH_closure" {
     withHandle2_ra7PH_closure:
         const withHandle2_ra7PH_info;
         const 0;
 },
 io_sadb6_entry() //  [R1]
         { []
         }
     {offset
       cafcE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cafcI; else goto cafcJ;
       cafcI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cafcJ: // global
           I64[Sp - 16] = block_cafcz_info;
           _sadb2::P64 = P64[R1 + 31];
           R5 = _sadb2::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sadb2::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sadb6_info" {
     io_sadb6_info:
         const io_sadb6_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Saded_srt+448;
 },
 _cafcz() //  [R1]
         { []
         }
     {offset
       cafcz: // global
           I64[Sp] = block_cafcB_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uafcO; else goto cafcC;
       uafcO: // global
           call _cafcB(R1) args: 0, res: 0, upd: 0;
       cafcC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cafcz_info" {
     block_cafcz_info:
         const _cafcz;
         const 1;
         const 30;
 },
 _cafcB() //  [R1]
         { []
         }
     {offset
       cafcB: // global
           I64[Sp] = block_cafcH_info;
           R2 = P64[R1 + 7];
           _sadbd::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sadbd::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cafcB_info" {
     block_cafcB_info:
         const _cafcB;
         const 1;
         const 30;
 },
 _cafcH() //  []
         { []
         }
     {offset
       cafcH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cafcH_info" {
     block_cafcH_info:
         const _cafcH;
         const 1;
         const 30;
 },
 io_sadbm_entry() //  [R1]
         { []
         }
     {offset
       cafd3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cafd7; else goto cafd8;
       cafd7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cafd8: // global
           I64[Sp - 16] = block_cafcY_info;
           _sadbh::P64 = P64[R1 + 31];
           R5 = _sadbh::P64;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 23];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sadbh::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sadbm_info" {
     io_sadbm_info:
         const io_sadbm_entry;
         const 4;
         const 4294967304;
         const 4294967299;
         const Saded_srt+448;
 },
 _cafcY() //  [R1]
         { []
         }
     {offset
       cafcY: // global
           I64[Sp] = block_cafd0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uafdd; else goto cafd1;
       uafdd: // global
           call _cafd0(R1) args: 0, res: 0, upd: 0;
       cafd1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cafcY_info" {
     block_cafcY_info:
         const _cafcY;
         const 1;
         const 30;
 },
 _cafd0() //  [R1]
         { []
         }
     {offset
       cafd0: // global
           I64[Sp] = block_cafd6_info;
           R2 = P64[R1 + 7];
           _sadbt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sadbt::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cafd0_info" {
     block_cafd0_info:
         const _cafd0;
         const 1;
         const 30;
 },
 _cafd6() //  []
         { []
         }
     {offset
       cafd6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cafd6_info" {
     block_cafd6_info:
         const _cafd6;
         const 1;
         const 30;
 },
 withHandle2_ra7PH_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cafdi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cafdj; else goto cafdk;
       cafdj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withHandle2_ra7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cafdk: // global
           I64[Sp - 24] = block_cafcn_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafdB; else goto cafco;
       uafdB: // global
           call _cafcn(R1) args: 0, res: 0, upd: 0;
       cafco: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . withHandle2_ra7PH_info" {
     withHandle2_ra7PH_info:
         const withHandle2_ra7PH_entry;
         const 0;
         const 4503603922337806;
         const 17179869207;
         const Saded_srt+448;
 },
 _cafcn() //  [R1]
         { []
         }
     {offset
       cafcn: // global
           if (R1 & 7 == 1) goto cafdf; else goto cafdg;
       cafdf: // global
           I64[Sp - 16] = block_cafcs_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cafdg: // global
           I64[Sp - 16] = block_cafcR_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cafcn_info" {
     block_cafcn_info:
         const _cafcn;
         const 2;
         const 4294967326;
         const Saded_srt+448;
 },
 _cafcs() //  [R1]
         { []
         }
     {offset
       cafcs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafdo; else goto cafdn;
       cafdo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cafdn: // global
           I64[Hp - 32] = io_sadb6_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cafcu::P64 = Hp - 31;
           if (R1 == 0) goto cafds; else goto cafdr;
       cafds: // global
           R1 = _cafcu::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cafdr: // global
           R1 = _cafcu::P64;
           Sp = Sp + 40;
           call io_sadb6_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cafcs_info" {
     block_cafcs_info:
         const _cafcs;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 },
 _cafcR() //  [R1]
         { []
         }
     {offset
       cafcR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafdw; else goto cafdv;
       cafdw: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cafdv: // global
           I64[Hp - 32] = io_sadbm_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cafcT::P64 = Hp - 31;
           if (R1 == 0) goto cafdA; else goto cafdz;
       cafdA: // global
           R1 = _cafcT::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cafdz: // global
           R1 = _cafcT::P64;
           Sp = Sp + 40;
           call io_sadbm_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cafcR_info" {
     block_cafcR_info:
         const _cafcR;
         const 4;
         const 4294967326;
         const Saded_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.614184571 UTC

[section ""data" . GHC.IO.Handle.Internals.withHandle_closure" {
     GHC.IO.Handle.Internals.withHandle_closure:
         const GHC.IO.Handle.Internals.withHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.withHandle_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cafeM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withHandle2_ra7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.withHandle_info" {
     GHC.IO.Handle.Internals.withHandle_info:
         const GHC.IO.Handle.Internals.withHandle_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Saded_srt+608;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.622106561 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle1_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle1_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle1_info;
         const 0;
 },
 sat_sadbI_entry() //  [R1, R2]
         { []
         }
     {offset
       caffe: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sadbI_info" {
     sat_sadbI_info:
         const sat_sadbI_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const Saded_srt+520;
 },
 io_sadbG_entry() //  [R1]
         { []
         }
     {offset
       caffm: // global
           _sadbG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caffq; else goto caffr;
       caffr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cafft; else goto caffs;
       cafft: // global
           HpAlloc = 16;
           goto caffq;
       caffq: // global
           R1 = _sadbG::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caffs: // global
           _sadbw::P64 = P64[_sadbG::P64 + 7];
           _sadby::P64 = P64[_sadbG::P64 + 15];
           _sadbA::P64 = P64[_sadbG::P64 + 23];
           _sadbC::P64 = P64[_sadbG::P64 + 31];
           I64[Hp - 8] = sat_sadbI_info;
           P64[Hp] = _sadby::P64;
           I64[Sp - 16] = block_caffh_info;
           R5 = _sadbC::P64;
           R4 = Hp - 6;
           R3 = _sadbA::P64;
           R2 = _sadbw::P64;
           P64[Sp - 8] = _sadbC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sadbG_info" {
     io_sadbG_info:
         const io_sadbG_entry;
         const 4;
         const 2203318222856;
         const 4294967299;
         const Saded_srt+448;
 },
 _caffh() //  [R1]
         { []
         }
     {offset
       caffh: // global
           I64[Sp] = block_caffj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaffy; else goto caffk;
       uaffy: // global
           call _caffj(R1) args: 0, res: 0, upd: 0;
       caffk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caffh_info" {
     block_caffh_info:
         const _caffh;
         const 1;
         const 30;
 },
 _caffj() //  [R1]
         { []
         }
     {offset
       caffj: // global
           I64[Sp] = block_caffp_info;
           R2 = P64[R1 + 7];
           _sadbO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sadbO::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caffj_info" {
     block_caffj_info:
         const _caffj;
         const 1;
         const 30;
 },
 _caffp() //  []
         { []
         }
     {offset
       caffp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caffp_info" {
     block_caffp_info:
         const _caffp;
         const 1;
         const 30;
 },
 sat_sadbZ_entry() //  [R1, R2]
         { []
         }
     {offset
       caffN: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.IO.Handle.Internals.wantReadableHandle2_entry(R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sadbZ_info" {
     sat_sadbZ_info:
         const sat_sadbZ_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const Saded_srt+520;
 },
 io_sadbX_entry() //  [R1]
         { []
         }
     {offset
       caffV: // global
           _sadbX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto caffZ; else goto cafg0;
       cafg0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cafg2; else goto cafg1;
       cafg2: // global
           HpAlloc = 16;
           goto caffZ;
       caffZ: // global
           R1 = _sadbX::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cafg1: // global
           _sadbw::P64 = P64[_sadbX::P64 + 7];
           _sadby::P64 = P64[_sadbX::P64 + 15];
           _sadbA::P64 = P64[_sadbX::P64 + 23];
           _sadbS::P64 = P64[_sadbX::P64 + 31];
           I64[Hp - 8] = sat_sadbZ_info;
           P64[Hp] = _sadby::P64;
           I64[Sp - 16] = block_caffQ_info;
           R5 = _sadbS::P64;
           R4 = Hp - 6;
           R3 = _sadbA::P64;
           R2 = _sadbw::P64;
           P64[Sp - 8] = _sadbS::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sadbX_info" {
     io_sadbX_info:
         const io_sadbX_entry;
         const 4;
         const 2203318222856;
         const 4294967299;
         const Saded_srt+448;
 },
 _caffQ() //  [R1]
         { []
         }
     {offset
       caffQ: // global
           I64[Sp] = block_caffS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uafg7; else goto caffT;
       uafg7: // global
           call _caffS(R1) args: 0, res: 0, upd: 0;
       caffT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caffQ_info" {
     block_caffQ_info:
         const _caffQ;
         const 1;
         const 30;
 },
 _caffS() //  [R1]
         { []
         }
     {offset
       caffS: // global
           I64[Sp] = block_caffY_info;
           R2 = P64[R1 + 7];
           _sadc5::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sadc5::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caffS_info" {
     block_caffS_info:
         const _caffS;
         const 1;
         const 30;
 },
 _caffY() //  []
         { []
         }
     {offset
       caffY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caffY_info" {
     block_caffY_info:
         const _caffY;
         const 1;
         const 30;
 },
 GHC.IO.Handle.Internals.wantReadableHandle1_entry() //  [R2, R3,
                                                          R4]
         { []
         }
     {offset
       cafgc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cafgd; else goto cafge;
       cafgd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Internals.wantReadableHandle1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cafge: // global
           I64[Sp - 24] = block_cafeX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafgv; else goto cafeY;
       uafgv: // global
           call _cafeX(R1) args: 0, res: 0, upd: 0;
       cafeY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle1_info" {
     GHC.IO.Handle.Internals.wantReadableHandle1_info:
         const GHC.IO.Handle.Internals.wantReadableHandle1_entry;
         const 0;
         const 9009402572963854;
         const 17179869207;
         const Saded_srt+448;
 },
 _cafeX() //  [R1]
         { []
         }
     {offset
       cafeX: // global
           if (R1 & 7 == 1) goto cafg9; else goto cafga;
       cafg9: // global
           I64[Sp - 16] = block_caff2_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cafga: // global
           I64[Sp - 16] = block_caffB_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cafeX_info" {
     block_cafeX_info:
         const _cafeX;
         const 2;
         const 2203318222878;
         const Saded_srt+448;
 },
 _caff2() //  [R1]
         { []
         }
     {offset
       caff2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafgi; else goto cafgh;
       cafgi: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cafgh: // global
           I64[Hp - 32] = io_sadbG_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caff4::P64 = Hp - 31;
           if (R1 == 0) goto cafgm; else goto cafgl;
       cafgm: // global
           R1 = _caff4::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cafgl: // global
           R1 = _caff4::P64;
           Sp = Sp + 40;
           call io_sadbG_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caff2_info" {
     block_caff2_info:
         const _caff2;
         const 4;
         const 2203318222878;
         const Saded_srt+448;
 },
 _caffB() //  [R1]
         { []
         }
     {offset
       caffB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafgq; else goto cafgp;
       cafgq: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cafgp: // global
           I64[Hp - 32] = io_sadbX_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _caffD::P64 = Hp - 31;
           if (R1 == 0) goto cafgu; else goto cafgt;
       cafgu: // global
           R1 = _caffD::P64;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cafgt: // global
           R1 = _caffD::P64;
           Sp = Sp + 40;
           call io_sadbX_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caffB_info" {
     block_caffB_info:
         const _caffB;
         const 4;
         const 2203318222878;
         const Saded_srt+448;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.648658735 UTC

[section ""data" . GHC.IO.Handle.Internals.wantReadableHandle_closure" {
     GHC.IO.Handle.Internals.wantReadableHandle_closure:
         const GHC.IO.Handle.Internals.wantReadableHandle_info;
         const 0;
 },
 GHC.IO.Handle.Internals.wantReadableHandle_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cafhO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Internals.wantReadableHandle_info" {
     GHC.IO.Handle.Internals.wantReadableHandle_info:
         const GHC.IO.Handle.Internals.wantReadableHandle_entry;
         const 0;
         const 4294967310;
         const 17179869207;
         const Saded_srt+616;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:16.652309121 UTC

[section ""relreadonly" . Saded_srt" {
     Saded_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle12_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const ioe_closedHandle2_ra7Pb_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle8_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const ioe_semiclosedHandle2_ra7Pc_closure;
         const GHC.IO.Handle.Internals.hLookAhead_3_closure;
         const ioe_EOF2_ra7Pd_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle4_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle3_closure;
         const ioe_notReadable2_ra7Pe_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle3_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle2_closure;
         const ioe_notWritable2_ra7Pf_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle4_closure;
         const GHC.IO.Handle.Internals.flushBuffer4_closure;
         const lvl1_ra7Ph_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_bufsiz1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Internals.ioe_finalizedHandle_closure;
         const lvl6_ra7Pm_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf1_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.readTextDeviceNonBlocking1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const GHC.Err.error_closure;
         const lvl19_ra7Pz_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer1_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.flushBuffer3_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Internals.$wreadTextDevice'_closure;
         const lvl22_ra7PC_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.noCharBuffer_closure;
         const GHC.IO.Handle.Internals.noByteBuffer_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle4_closure;
         const GHC.IO.Handle.Internals.mkFileHandle1_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle3_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle2_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const $wlvl_ra7PF_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.Internals.withHandle_1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.Internals.withHandle__'1_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.withHandle1_closure;
         const GHC.IO.Handle.Internals.withHandle_'1_closure;
         const withHandle_2_ra7PG_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle5_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle7_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle11_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const withHandle2_ra7PH_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
 }]

