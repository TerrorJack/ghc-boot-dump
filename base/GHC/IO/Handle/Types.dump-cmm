
==================== Output Cmm ====================
2018-03-16 16:03:16.526429839 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:16.528109113 UTC

[section ""data" . GHC.IO.Handle.Types.$WHandle___closure" {
     GHC.IO.Handle.Types.$WHandle___closure:
         const GHC.IO.Handle.Types.$WHandle___info;
 },
 GHC.IO.Handle.Types.$WHandle___slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aiw: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Types.$WHandle___entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 96, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$WHandle___entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8aiF,
                       label: GHC.IO.Handle.Types.$WHandle___info
                       rep:HeapRep static {
                             Fun {arity: 16
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aiF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8aiY; else goto c8aiZ;
       c8aiY: // global
           R1 = GHC.IO.Handle.Types.$WHandle___closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 136, res: 0, upd: 8;
       c8aiZ: // global
           I64[Sp - 40] = block_c8aiA_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aiA() //  [R1]
         { info_tbl: [(c8aiA,
                       label: block_c8aiA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aiA: // global
           I64[Sp] = block_c8aiC_info;
           _s8a6z::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s8a6z::P64;
           if (R1 & 7 != 0) goto u8aj7; else goto c8aiD;
       u8aj7: // global
           call _c8aiC(R1) args: 0, res: 0, upd: 0;
       c8aiD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aiC() //  [R1]
         { info_tbl: [(c8aiC,
                       label: block_c8aiC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aiC: // global
           I64[Sp] = block_c8aiI_info;
           _s8a6B::P64 = P64[R1 + 7];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _s8a6B::P64;
           if (R1 & 7 != 0) goto u8aj8; else goto c8aiJ;
       u8aj8: // global
           call _c8aiI(R1) args: 0, res: 0, upd: 0;
       c8aiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aiI() //  [R1]
         { info_tbl: [(c8aiI,
                       label: block_c8aiI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aiI: // global
           I64[Sp] = block_c8aiN_info;
           _s8a6D::P64 = P64[R1 + 7];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s8a6D::P64;
           if (R1 & 7 != 0) goto u8aj9; else goto c8aiO;
       u8aj9: // global
           call _c8aiN(R1) args: 0, res: 0, upd: 0;
       c8aiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aiN() //  [R1]
         { info_tbl: [(c8aiN,
                       label: block_c8aiN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aiN: // global
           I64[Sp] = block_c8aiS_info;
           _s8a6F::P64 = P64[R1 + 7];
           R1 = P64[Sp + 72];
           P64[Sp + 72] = _s8a6F::P64;
           if (R1 & 7 != 0) goto u8aja; else goto c8aiT;
       u8aja: // global
           call _c8aiS(R1) args: 0, res: 0, upd: 0;
       c8aiT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aiS() //  [R1]
         { info_tbl: [(c8aiS,
                       label: block_c8aiS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aiS: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8aj6; else goto c8aj5;
       c8aj6: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8aj5: // global
           _s8a6H::P64 = P64[R1 + 7];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 64];
           P64[Hp - 56] = P64[Sp + 72];
           P64[Hp - 48] = _s8a6H::P64;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = P64[Sp + 104];
           P64[Hp - 8] = P64[Sp + 112];
           P64[Hp] = P64[Sp + 120];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.530956752 UTC

[section ""data" . GHC.IO.Handle.Types.$WFileHandle_closure" {
     GHC.IO.Handle.Types.$WFileHandle_closure:
         const GHC.IO.Handle.Types.$WFileHandle_info;
 },
 GHC.IO.Handle.Types.$WFileHandle_entry() //  [R2, R3]
         { info_tbl: [(c8aji,
                       label: GHC.IO.Handle.Types.$WFileHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aji: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ajm; else goto c8ajn;
       c8ajm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$WFileHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ajn: // global
           I64[Sp - 16] = block_c8ajf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ajr; else goto c8ajg;
       u8ajr: // global
           call _c8ajf(R1) args: 0, res: 0, upd: 0;
       c8ajg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ajf() //  [R1]
         { info_tbl: [(c8ajf,
                       label: block_c8ajf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ajf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ajq; else goto c8ajp;
       c8ajq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ajp: // global
           _s8a6L::P64 = P64[R1 + 7];
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s8a6L::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.532428003 UTC

[section ""data" . GHC.IO.Handle.Types.$WDuplexHandle_closure" {
     GHC.IO.Handle.Types.$WDuplexHandle_closure:
         const GHC.IO.Handle.Types.$WDuplexHandle_info;
 },
 GHC.IO.Handle.Types.$WDuplexHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(c8ajz,
                       label: GHC.IO.Handle.Types.$WDuplexHandle_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ajz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ajI; else goto c8ajJ;
       c8ajI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$WDuplexHandle_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ajJ: // global
           I64[Sp - 24] = block_c8ajw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8ajP; else goto c8ajx;
       u8ajP: // global
           call _c8ajw(R1) args: 0, res: 0, upd: 0;
       c8ajx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ajw() //  [R1]
         { info_tbl: [(c8ajw,
                       label: block_c8ajw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ajw: // global
           I64[Sp] = block_c8ajC_info;
           _s8a6Q::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8a6Q::P64;
           if (R1 & 7 != 0) goto u8ajO; else goto c8ajD;
       u8ajO: // global
           call _c8ajC(R1) args: 0, res: 0, upd: 0;
       c8ajD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ajC() //  [R1]
         { info_tbl: [(c8ajC,
                       label: block_c8ajC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ajC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8ajN; else goto c8ajM;
       c8ajN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ajM: // global
           _s8a6S::P64 = P64[R1 + 7];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s8a6S::P64;
           R1 = Hp - 22;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.53381631 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType12_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType12_bytes:
         I8[] [99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.534540052 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType11_closure" {
     GHC.IO.Handle.Types.$fShowHandleType11_closure:
         const GHC.IO.Handle.Types.$fShowHandleType11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType11_entry() //  [R1]
         { info_tbl: [(c8ajW,
                       label: GHC.IO.Handle.Types.$fShowHandleType11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ajW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ajX; else goto c8ajY;
       c8ajX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ajY: // global
           (_c8ajT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ajT::I64 == 0) goto c8ajV; else goto c8ajU;
       c8ajV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ajU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ajT::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.535438621 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType10_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType10_bytes:
         I8[] [115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.536150286 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType9_closure" {
     GHC.IO.Handle.Types.$fShowHandleType9_closure:
         const GHC.IO.Handle.Types.$fShowHandleType9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType9_entry() //  [R1]
         { info_tbl: [(c8ak5,
                       label: GHC.IO.Handle.Types.$fShowHandleType9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ak5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ak6; else goto c8ak7;
       c8ak6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ak7: // global
           (_c8ak2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ak2::I64 == 0) goto c8ak4; else goto c8ak3;
       c8ak4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ak3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ak2::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.537036024 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType8_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType8_bytes:
         I8[] [114,101,97,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.53782074 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType7_closure" {
     GHC.IO.Handle.Types.$fShowHandleType7_closure:
         const GHC.IO.Handle.Types.$fShowHandleType7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType7_entry() //  [R1]
         { info_tbl: [(c8ake,
                       label: GHC.IO.Handle.Types.$fShowHandleType7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ake: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8akf; else goto c8akg;
       c8akf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8akg: // global
           (_c8akb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8akb::I64 == 0) goto c8akd; else goto c8akc;
       c8akd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8akc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8akb::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.538704573 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType6_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType6_bytes:
         I8[] [119,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.539418862 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType5_closure" {
     GHC.IO.Handle.Types.$fShowHandleType5_closure:
         const GHC.IO.Handle.Types.$fShowHandleType5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType5_entry() //  [R1]
         { info_tbl: [(c8akn,
                       label: GHC.IO.Handle.Types.$fShowHandleType5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8akn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ako; else goto c8akp;
       c8ako: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8akp: // global
           (_c8akk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8akk::I64 == 0) goto c8akm; else goto c8akl;
       c8akm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8akl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8akk::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.540326842 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType4_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType4_bytes:
         I8[] [119,114,105,116,97,98,108,101,32,40,97,112,112,101,110,100,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.541023301 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType3_closure" {
     GHC.IO.Handle.Types.$fShowHandleType3_closure:
         const GHC.IO.Handle.Types.$fShowHandleType3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType3_entry() //  [R1]
         { info_tbl: [(c8akw,
                       label: GHC.IO.Handle.Types.$fShowHandleType3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8akw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8akx; else goto c8aky;
       c8akx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aky: // global
           (_c8akt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8akt::I64 == 0) goto c8akv; else goto c8aku;
       c8akv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aku: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8akt::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.542006202 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType2_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType2_bytes:
         I8[] [114,101,97,100,45,119,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.542756977 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType1_closure" {
     GHC.IO.Handle.Types.$fShowHandleType1_closure:
         const GHC.IO.Handle.Types.$fShowHandleType1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType1_entry() //  [R1]
         { info_tbl: [(c8akF,
                       label: GHC.IO.Handle.Types.$fShowHandleType1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8akF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8akG; else goto c8akH;
       c8akG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8akH: // global
           (_c8akC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8akC::I64 == 0) goto c8akE; else goto c8akD;
       c8akE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8akD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8akC::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.544059407 UTC

[section ""data" . GHC.IO.Handle.Types.$w$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$w$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8akX,
                       label: GHC.IO.Handle.Types.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8akX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8akY; else goto c8akZ;
       c8akY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8akZ: // global
           I64[Sp - 16] = block_c8akM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ali; else goto c8akN;
       u8ali: // global
           call _c8akM(R1) args: 0, res: 0, upd: 0;
       c8akN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8akM() //  [R1]
         { info_tbl: [(c8akM,
                       label: block_c8akM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8akM: // global
           _s8a6U::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c8akQ;
               case 2 : goto c8akR;
               case 3 : goto c8akS;
               case 4 : goto c8akT;
               case 5 : goto c8akU;
               case 6 : goto c8akV;
           }
       c8akV: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8akU: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8akT: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8akS: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8akR: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8akQ: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.545597733 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_entry() //  [R3,
                                                               R4]
         { info_tbl: [(c8alo,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8alo: // global
           _s8a6X::P64 = R3;
           R3 = R4;
           R2 = _s8a6X::P64;
           call GHC.IO.Handle.Types.$w$cshowsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.546635163 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshow_entry() //  [R2]
         { info_tbl: [(c8alG,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8alG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8alH; else goto c8alI;
       c8alH: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8alI: // global
           I64[Sp - 8] = block_c8alv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8am1; else goto c8alw;
       u8am1: // global
           call _c8alv(R1) args: 0, res: 0, upd: 0;
       c8alw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8alv() //  [R1]
         { info_tbl: [(c8alv,
                       label: block_c8alv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8alv: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c8alz;
               case 2 : goto c8alA;
               case 3 : goto c8alB;
               case 4 : goto c8alC;
               case 5 : goto c8alD;
               case 6 : goto c8alE;
           }
       c8alE: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8alD: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8alC: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8alB: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8alA: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8alz: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.548048842 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshowList_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8am6,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8am6: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.548818174 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.550087949 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_$c==_closure" {
     GHC.IO.Handle.Types.$fEqHandle_$c==_closure:
         const GHC.IO.Handle.Types.$fEqHandle_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqHandle_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8amk,
                       label: GHC.IO.Handle.Types.$fEqHandle_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8amk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aml; else goto c8amm;
       c8aml: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqHandle_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8amm: // global
           I64[Sp - 16] = block_c8amd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8amZ; else goto c8ame;
       u8amZ: // global
           call _c8amd(R1) args: 0, res: 0, upd: 0;
       c8ame: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8amd() //  [R1]
         { info_tbl: [(c8amd,
                       label: block_c8amd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8amd: // global
           _s8a74::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8amh; else goto c8ami;
       c8amh: // global
           I64[Sp] = block_c8amp_info;
           _s8a77::P64 = P64[R1 + 15];
           R1 = _s8a74::P64;
           P64[Sp + 8] = _s8a77::P64;
           if (R1 & 7 != 0) goto u8amX; else goto c8amr;
       u8amX: // global
           call _c8amp(R1) args: 0, res: 0, upd: 0;
       c8amr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ami: // global
           I64[Sp] = block_c8amE_info;
           _s8a7g::P64 = P64[R1 + 14];
           R1 = _s8a74::P64;
           P64[Sp + 8] = _s8a7g::P64;
           if (R1 & 7 != 0) goto u8amY; else goto c8amG;
       u8amY: // global
           call _c8amE(R1) args: 0, res: 0, upd: 0;
       c8amG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8amp() //  [R1]
         { info_tbl: [(c8amp,
                       label: block_c8amp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8amp: // global
           if (R1 & 7 == 1) goto c8amx; else goto u8amW;
       c8amx: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8amW: // global
           Sp = Sp + 16;
           call _c8amM() args: 0, res: 0, upd: 0;
     }
 },
 _c8amE() //  [R1]
         { info_tbl: [(c8amE,
                       label: block_c8amE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8amE: // global
           if (R1 & 7 == 1) goto u8amV; else goto c8amQ;
       u8amV: // global
           Sp = Sp + 16;
           call _c8amM() args: 0, res: 0, upd: 0;
       c8amQ: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 14]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8amM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8amM: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.552504006 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqHandle_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqHandle_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqHandle_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8and,
                       label: GHC.IO.Handle.Types.$fEqHandle_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8and: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ane; else goto c8anf;
       c8ane: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqHandle_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8anf: // global
           I64[Sp - 16] = block_c8an6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aoo; else goto c8an7;
       u8aoo: // global
           call _c8an6(R1) args: 0, res: 0, upd: 0;
       c8an7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8an6() //  [R1]
         { info_tbl: [(c8an6,
                       label: block_c8an6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8an6: // global
           _s8a7q::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ana; else goto c8anb;
       c8ana: // global
           I64[Sp] = block_c8ani_info;
           _s8a7t::P64 = P64[R1 + 15];
           R1 = _s8a7q::P64;
           P64[Sp + 8] = _s8a7t::P64;
           if (R1 & 7 != 0) goto u8aom; else goto c8ank;
       u8aom: // global
           call _c8ani(R1) args: 0, res: 0, upd: 0;
       c8ank: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8anb: // global
           I64[Sp] = block_c8anM_info;
           _s8a7C::P64 = P64[R1 + 14];
           R1 = _s8a7q::P64;
           P64[Sp + 8] = _s8a7C::P64;
           if (R1 & 7 != 0) goto u8aon; else goto c8anO;
       u8aon: // global
           call _c8anM(R1) args: 0, res: 0, upd: 0;
       c8anO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ani() //  [R1]
         { info_tbl: [(c8ani,
                       label: block_c8ani_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ani: // global
           if (R1 & 7 == 1) goto c8anF; else goto u8aoj;
       c8anF: // global
           if (P64[Sp + 8] == P64[R1 + 15]) goto u8aok; else goto u8aol;
       u8aok: // global
           Sp = Sp + 16;
           call _c8ao9() args: 0, res: 0, upd: 0;
       u8aol: // global
           Sp = Sp + 16;
           goto u8aor;
       u8aoj: // global
           Sp = Sp + 16;
           goto u8aor;
       u8aor: // global
           call _c8ao3() args: 0, res: 0, upd: 0;
     }
 },
 _c8anM() //  [R1]
         { info_tbl: [(c8anM,
                       label: block_c8anM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8anM: // global
           if (R1 & 7 == 1) goto u8aog; else goto c8aod;
       u8aog: // global
           Sp = Sp + 16;
           goto u8aou;
       c8aod: // global
           if (P64[Sp + 8] == P64[R1 + 14]) goto u8aoh; else goto u8aoi;
       u8aoh: // global
           Sp = Sp + 16;
           call _c8ao9() args: 0, res: 0, upd: 0;
       u8aoi: // global
           Sp = Sp + 16;
           goto u8aou;
       u8aou: // global
           call _c8ao3() args: 0, res: 0, upd: 0;
     }
 },
 _c8ao9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ao9: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ao3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ao3: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.554321768 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_closure" {
     GHC.IO.Handle.Types.$fEqHandle_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqHandle_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqHandle_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.554910311 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewline11_bytes" {
     GHC.IO.Handle.Types.$fReadNewline11_bytes:
         I8[] [76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.555609862 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline10_closure" {
     GHC.IO.Handle.Types.$fReadNewline10_closure:
         const GHC.IO.Handle.Types.$fReadNewline10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline10_entry() //  [R1]
         { info_tbl: [(c8aoB,
                       label: GHC.IO.Handle.Types.$fReadNewline10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aoB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aoC; else goto c8aoD;
       c8aoC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aoD: // global
           (_c8aoy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8aoy::I64 == 0) goto c8aoA; else goto c8aoz;
       c8aoA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aoz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8aoy::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.556474798 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewline7_bytes" {
     GHC.IO.Handle.Types.$fReadNewline7_bytes:
         I8[] [67,82,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.557221828 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline6_closure" {
     GHC.IO.Handle.Types.$fReadNewline6_closure:
         const GHC.IO.Handle.Types.$fReadNewline6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline6_entry() //  [R1]
         { info_tbl: [(c8aoK,
                       label: GHC.IO.Handle.Types.$fReadNewline6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aoK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aoL; else goto c8aoM;
       c8aoL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aoM: // global
           (_c8aoH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8aoH::I64 == 0) goto c8aoJ; else goto c8aoI;
       c8aoJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aoI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8aoH::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.558466498 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c8aoY,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aoY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aoZ; else goto c8ap0;
       c8aoZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ap0: // global
           I64[Sp - 16] = block_c8aoR_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ap7; else goto c8aoS;
       u8ap7: // global
           call _c8aoR(R1) args: 0, res: 0, upd: 0;
       c8aoS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aoR() //  [R1]
         { info_tbl: [(c8aoR,
                       label: block_c8aoR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aoR: // global
           _s8a7N::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aoV; else goto c8aoW;
       c8aoV: // global
           R3 = _s8a7N::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8aoW: // global
           R3 = _s8a7N::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.559845342 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshow_entry() //  [R2]
         { info_tbl: [(c8apj,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8apj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8apk; else goto c8apl;
       c8apk: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8apl: // global
           I64[Sp - 8] = block_c8apc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aps; else goto c8apd;
       u8aps: // global
           call _c8apc(R1) args: 0, res: 0, upd: 0;
       c8apd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8apc() //  [R1]
         { info_tbl: [(c8apc,
                       label: block_c8apc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8apc: // global
           if (R1 & 7 == 1) goto c8apg; else goto c8aph;
       c8apg: // global
           R1 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8aph: // global
           R1 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.561208586 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline1_closure" {
     GHC.IO.Handle.Types.$fShowNewline1_closure:
         const GHC.IO.Handle.Types.$fShowNewline1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline1_entry() //  [R2, R3]
         { info_tbl: [(c8apE,
                       label: GHC.IO.Handle.Types.$fShowNewline1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8apE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8apF; else goto c8apG;
       c8apF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8apG: // global
           I64[Sp - 16] = block_c8apx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8apN; else goto c8apy;
       u8apN: // global
           call _c8apx(R1) args: 0, res: 0, upd: 0;
       c8apy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8apx() //  [R1]
         { info_tbl: [(c8apx,
                       label: block_c8apx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8apx: // global
           _s8a7S::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8apB; else goto c8apC;
       c8apB: // global
           R3 = _s8a7S::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8apC: // global
           R3 = _s8a7S::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.562533378 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8apS,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8apS: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowNewline1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.563319019 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_closure" {
     GHC.IO.Handle.Types.$fShowNewline_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.563954526 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode4_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode4_bytes:
         I8[] [78,101,119,108,105,110,101,77,111,100,101,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.564536361 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode3_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode3_bytes:
         I8[] [105,110,112,117,116,78,76,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.565095183 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode2_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode2_bytes:
         I8[] [111,117,116,112,117,116,78,76,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.56571499 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode5_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.568283092 UTC

[section ""data" . GHC.IO.Handle.Types.$w$cshowsPrec1_closure" {
     GHC.IO.Handle.Types.$w$cshowsPrec1_closure:
         const GHC.IO.Handle.Types.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$w$cshowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8apW: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a84_entry() //  [R1]
         { info_tbl: [(c8aqy,
                       label: sat_s8a84_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aqy: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a85_entry() //  [R1]
         { info_tbl: [(c8aqH,
                       label: sat_s8a85_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aqH: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a86_entry() //  [R1]
         { info_tbl: [(c8aqO,
                       label: sat_s8a86_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aqO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8aqP; else goto c8aqQ;
       c8aqP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aqQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8aqp_info;
           _s8a81::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8a81::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8aqX; else goto c8aqq;
       u8aqX: // global
           call _c8aqp(R1) args: 0, res: 0, upd: 0;
       c8aqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8aqp() //  [R1]
         { info_tbl: [(c8aqp,
                       label: block_c8aqp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aqp: // global
           _s8a81::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aqL; else goto c8aqM;
       c8aqL: // global
           Hp = Hp + 24;
           _s8a83::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8aqW; else goto c8aqS;
       c8aqS: // global
           I64[Hp - 16] = sat_s8a84_info;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c8aqM: // global
           Hp = Hp + 24;
           _s8a83::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8aqW; else goto c8aqV;
       c8aqW: // global
           HpAlloc = 24;
           R1 = _s8a83::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8aqV: // global
           I64[Hp - 16] = sat_s8a85_info;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8a87_entry() //  [R1]
         { info_tbl: [(c8aqY,
                       label: sat_s8a87_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aqY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8ar2; else goto c8ar1;
       c8ar2: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ar1: // global
           _s8a7Y::P64 = P64[R1 + 16];
           _s8a81::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8a86_info;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 karg_s8a82_entry() //  [R1]
         { info_tbl: [(c8ar3,
                       label: karg_s8a82_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ar3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8ar7; else goto c8ar6;
       c8ar7: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ar6: // global
           _s8a7Y::P64 = P64[R1 + 16];
           _s8a81::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8a87_info;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a89_entry() //  [R1]
         { info_tbl: [(c8arf,
                       label: sat_s8a89_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8arf: // global
           _s8a89::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8arg; else goto c8arh;
       c8arh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8arj; else goto c8ari;
       c8arj: // global
           HpAlloc = 32;
           goto c8arg;
       c8arg: // global
           R1 = _s8a89::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ari: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8a89::P64;
           _s8a7X::P64 = P64[_s8a89::P64 + 16];
           _s8a7Y::P64 = P64[_s8a89::P64 + 24];
           _s8a81::P64 = P64[_s8a89::P64 + 32];
           I64[Hp - 24] = karg_s8a82_info;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           I64[Sp - 32] = block_c8ar8_info;
           R1 = _s8a7X::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8arq; else goto c8ar9;
       u8arq: // global
           call _c8ar8(R1) args: 0, res: 0, upd: 0;
       c8ar9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8ar8() //  [R1]
         { info_tbl: [(c8ar8,
                       label: block_c8ar8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ar8: // global
           _c8aqd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8arc; else goto c8ard;
       c8arc: // global
           R3 = _c8aqd::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c8ard: // global
           R3 = _c8aqd::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8a8a_entry() //  [R1]
         { info_tbl: [(c8arr,
                       label: sat_s8a8a_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8arr: // global
           _s8a8a::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ars; else goto c8art;
       c8art: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8arv; else goto c8aru;
       c8arv: // global
           HpAlloc = 40;
           goto c8ars;
       c8ars: // global
           R1 = _s8a8a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8a8a::P64;
           _s8a7X::P64 = P64[_s8a8a::P64 + 16];
           _s8a7Y::P64 = P64[_s8a8a::P64 + 24];
           _s8a81::P64 = P64[_s8a8a::P64 + 32];
           I64[Hp - 32] = sat_s8a89_info;
           P64[Hp - 16] = _s8a7X::P64;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_s8a80_entry() //  [R1, R2]
         { info_tbl: [(c8arw,
                       label: p_s8a80_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8arw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8arA; else goto c8arz;
       c8arA: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8arz: // global
           _s8a7X::P64 = P64[R1 + 7];
           _s8a7Y::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s8a8a_info;
           P64[Hp - 16] = _s8a7X::P64;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8d_entry() //  [R1]
         { info_tbl: [(c8arK,
                       label: sat_s8a8d_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8arK: // global
           _s8a8d::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8arL; else goto c8arM;
       c8arM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8arO; else goto c8arN;
       c8arO: // global
           HpAlloc = 24;
           goto c8arL;
       c8arL: // global
           R1 = _s8a8d::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8arN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8a8d::P64;
           _s8a7Z::P64 = P64[_s8a8d::P64 + 16];
           _s8a80::P64 = P64[_s8a8d::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s8a7Z::P64;
           R2 = Hp - 14;
           R1 = _s8a80::P64;
           Sp = Sp - 16;
           call p_s8a80_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$w$cshowsPrec1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8arS,
                       label: GHC.IO.Handle.Types.$w$cshowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8arS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8arW; else goto c8arV;
       c8arW: // global
           HpAlloc = 80;
           R1 = GHC.IO.Handle.Types.$w$cshowsPrec1_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c8arV: // global
           I64[Hp - 72] = p_s8a80_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           _c8aq0::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto c8arQ; else goto c8arR;
       c8arQ: // global
           Hp = Hp - 56;
           R2 = R5;
           R1 = _c8aq0::P64;
           call p_s8a80_entry(R2, R1) args: 8, res: 0, upd: 8;
       c8arR: // global
           I64[Hp - 48] = sat_s8a8d_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _c8aq0::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.57309313 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c8as5,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8as5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8as9; else goto c8asa;
       c8as9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8asa: // global
           I64[Sp - 24] = block_c8as2_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8asi; else goto c8as3;
       u8asi: // global
           call _c8as2(R1) args: 0, res: 0, upd: 0;
       c8as3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8as2() //  [R1]
         { info_tbl: [(c8as2,
                       label: block_c8as2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8as2: // global
           I64[Sp] = block_c8as8_info;
           _s8a8i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8a8i::I64;
           if (R1 & 7 != 0) goto u8ash; else goto c8asc;
       u8ash: // global
           call _c8as8(R1) args: 0, res: 0, upd: 0;
       c8asc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8as8() //  [R1]
         { info_tbl: [(c8as8,
                       label: block_c8as8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8as8: // global
           R5 = P64[Sp + 16];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.574482549 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode2_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.575303339 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8asq,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8asq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8asr; else goto c8ass;
       c8asr: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ass: // global
           I64[Sp - 8] = block_c8asn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8asw; else goto c8aso;
       u8asw: // global
           call _c8asn(R1) args: 0, res: 0, upd: 0;
       c8aso: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8asn() //  [R1]
         { info_tbl: [(c8asn,
                       label: block_c8asn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8asn: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.576612493 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode1_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode1_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(c8asE,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8asE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8asF; else goto c8asG;
       c8asF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8asG: // global
           I64[Sp - 16] = block_c8asB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8asK; else goto c8asC;
       u8asK: // global
           call _c8asB(R1) args: 0, res: 0, upd: 0;
       c8asC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8asB() //  [R1]
         { info_tbl: [(c8asB,
                       label: block_c8asB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8asB: // global
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.579846332 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8asP,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8asP: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.58074316 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.581652102 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline9_closure" {
     GHC.IO.Handle.Types.$fReadNewline9_closure:
         const GHC.IO.Handle.Types.$fReadNewline9_info;
 },
 GHC.IO.Handle.Types.$fReadNewline9_entry() //  [R3]
         { info_tbl: [(c8asW,
                       label: GHC.IO.Handle.Types.$fReadNewline9_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8asW: // global
           R2 = GHC.IO.Handle.Types.LF_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.582503424 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline8_closure" {
     GHC.IO.Handle.Types.$fReadNewline8_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadNewline10_closure;
         const GHC.IO.Handle.Types.$fReadNewline9_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.583287076 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline5_closure" {
     GHC.IO.Handle.Types.$fReadNewline5_closure:
         const GHC.IO.Handle.Types.$fReadNewline5_info;
 },
 GHC.IO.Handle.Types.$fReadNewline5_entry() //  [R3]
         { info_tbl: [(c8at3,
                       label: GHC.IO.Handle.Types.$fReadNewline5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8at3: // global
           R2 = GHC.IO.Handle.Types.CRLF_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.58400607 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline4_closure" {
     GHC.IO.Handle.Types.$fReadNewline4_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadNewline6_closure;
         const GHC.IO.Handle.Types.$fReadNewline5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.584625155 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline3_closure" {
     GHC.IO.Handle.Types.$fReadNewline3_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadNewline4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.585235848 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_sps_closure" {
     GHC.IO.Handle.Types.$fReadNewline_sps_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadNewline8_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.586142354 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline2_closure" {
     GHC.IO.Handle.Types.$fReadNewline2_closure:
         const GHC.IO.Handle.Types.$fReadNewline2_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline2_entry() //  [R2]
         { info_tbl: [(c8ata,
                       label: GHC.IO.Handle.Types.$fReadNewline2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ata: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.587017419 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline1_closure" {
     GHC.IO.Handle.Types.$fReadNewline1_closure:
         const GHC.IO.Handle.Types.$fReadNewline1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline1_entry() //  [R2, R3]
         { info_tbl: [(c8ath,
                       label: GHC.IO.Handle.Types.$fReadNewline1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ath: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.588098556 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_info;
         const 0;
 },
 sat_s8a8D_entry() //  [R1]
         { info_tbl: [(c8ats,
                       label: sat_s8a8D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ats: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8att; else goto c8atu;
       c8att: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8atu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8atv,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8atv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8atz; else goto c8aty;
       c8atz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aty: // global
           I64[Hp - 16] = sat_s8a8D_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.589419023 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8atG,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8atG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8atH; else goto c8atI;
       c8atH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8atI: // global
           (_c8atD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8atD::I64 == 0) goto c8atF; else goto c8atE;
       c8atF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8atE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8atD::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.590535047 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline12_closure" {
     GHC.IO.Handle.Types.$fReadNewline12_closure:
         const GHC.IO.Handle.Types.$fReadNewline12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline12_entry() //  [R1]
         { info_tbl: [(c8atP,
                       label: GHC.IO.Handle.Types.$fReadNewline12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8atP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8atQ; else goto c8atR;
       c8atQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8atR: // global
           (_c8atM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8atM::I64 == 0) goto c8atO; else goto c8atN;
       c8atO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8atN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8atM::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.59161201 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadList_entry() //  [R2]
         { info_tbl: [(c8atW,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8atW: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.59234361 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_closure" {
     GHC.IO.Handle.Types.$fReadNewline_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline1_closure+2;
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.592972474 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode17_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode17_bytes:
         I8[] [78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.593801873 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode16_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode16_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode16_entry() //  [R1]
         { info_tbl: [(c8au5,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8au5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8au6; else goto c8au7;
       c8au6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8au7: // global
           (_c8au2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8au2::I64 == 0) goto c8au4; else goto c8au3;
       c8au4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8au3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8au2::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.594699278 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode16_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.595301251 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode15_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode15_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.596011825 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode14_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode14_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode14_entry() //  [R1]
         { info_tbl: [(c8aue,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aue: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8auf; else goto c8aug;
       c8auf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aug: // global
           (_c8aub::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8aub::I64 == 0) goto c8aud; else goto c8auc;
       c8aud: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8auc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8aub::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.596873263 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.597510279 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode13_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode13_bytes:
         I8[] [105,110,112,117,116,78,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.598212416 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode12_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode12_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode12_entry() //  [R1]
         { info_tbl: [(c8aun,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aun: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8auo; else goto c8aup;
       c8auo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aup: // global
           (_c8auk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8auk::I64 == 0) goto c8aum; else goto c8aul;
       c8aum: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aul: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8auk::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.599192853 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode11_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode11_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode11_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode11_entry() //  [R3]
         { info_tbl: [(c8auu,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8auu: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.599949162 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_n_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_n_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.600510656 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode10_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode10_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.601206367 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode9_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode9_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode9_entry() //  [R1]
         { info_tbl: [(c8auD,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8auD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8auE; else goto c8auF;
       c8auE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8auF: // global
           (_c8auA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8auA::I64 == 0) goto c8auC; else goto c8auB;
       c8auC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8auB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8auA::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.60215277 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode8_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode8_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode9_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.602687623 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode7_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode7_bytes:
         I8[] [111,117,116,112,117,116,78,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.603432608 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode6_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode6_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode6_entry() //  [R1]
         { info_tbl: [(c8auM,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8auM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8auN; else goto c8auO;
       c8auN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8auO: // global
           (_c8auJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8auJ::I64 == 0) goto c8auL; else goto c8auK;
       c8auL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8auK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8auJ::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.604461344 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode4_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode4_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode4_entry() //  [R1]
         { info_tbl: [(c8auV,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8auV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8auW; else goto c8auX;
       c8auW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8auX: // global
           (_c8auS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8auS::I64 == 0) goto c8auU; else goto c8auT;
       c8auU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8auT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8auS::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.605402666 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode3_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode3_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.607608746 UTC

[section ""data" . GHC.IO.Handle.Types.$w$creadPrec_closure" {
     GHC.IO.Handle.Types.$w$creadPrec_closure:
         const GHC.IO.Handle.Types.$w$creadPrec_info;
         const 0;
 },
 sat_s8a8Q_entry() //  [R1, R2]
         { info_tbl: [(c8avB,
                       label: sat_s8a8Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8avB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8avF; else goto c8avE;
       c8avF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8avE: // global
           _s8a8H::P64 = P64[R1 + 7];
           _s8a8L::P64 = P64[R1 + 15];
           _s8a8N::P64 = P64[R1 + 23];
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = _s8a8L::P64;
           P64[Hp] = _s8a8N::P64;
           R2 = Hp - 15;
           R1 = _s8a8H::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8T_entry() //  [R1, R2]
         { info_tbl: [(c8avJ,
                       label: sat_s8a8T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8avJ: // global
           _s8a8N::P64 = R2;
           _s8a8T::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8avK; else goto c8avL;
       c8avL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8avN; else goto c8avM;
       c8avN: // global
           HpAlloc = 32;
           goto c8avK;
       c8avK: // global
           R2 = _s8a8N::P64;
           R1 = _s8a8T::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8avM: // global
           _s8a8H::P64 = P64[_s8a8T::P64 + 7];
           _s8a8L::P64 = P64[_s8a8T::P64 + 15];
           I64[Hp - 24] = sat_s8a8Q_info;
           P64[Hp - 16] = _s8a8H::P64;
           P64[Hp - 8] = _s8a8L::P64;
           P64[Hp] = _s8a8N::P64;
           I64[Sp - 8] = block_c8avG_info;
           R3 = Hp - 23;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8avG() //  [R1]
         { info_tbl: [(c8avG,
                       label: block_c8avG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8avG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8avQ; else goto c8avP;
       c8avQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8avP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8U_entry() //  [R1, R2]
         { info_tbl: [(c8avR,
                       label: sat_s8a8U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8avR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8avV; else goto c8avU;
       c8avV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8avU: // global
           _s8a8H::P64 = P64[R1 + 7];
           _s8a8L::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8a8T_info;
           P64[Hp - 8] = _s8a8H::P64;
           P64[Hp] = _s8a8L::P64;
           R5 = Hp - 15;
           R4 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode11_closure+2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8X_entry() //  [R1, R2]
         { info_tbl: [(c8avZ,
                       label: sat_s8a8X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8avZ: // global
           _s8a8L::P64 = R2;
           _s8a8X::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8aw0; else goto c8aw1;
       c8aw1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8aw3; else goto c8aw2;
       c8aw3: // global
           HpAlloc = 24;
           goto c8aw0;
       c8aw0: // global
           R2 = _s8a8L::P64;
           R1 = _s8a8X::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aw2: // global
           _s8a8H::P64 = P64[_s8a8X::P64 + 7];
           I64[Hp - 16] = sat_s8a8U_info;
           P64[Hp - 8] = _s8a8H::P64;
           P64[Hp] = _s8a8L::P64;
           I64[Sp - 8] = block_c8avW_info;
           R3 = Hp - 15;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode8_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8avW() //  [R1]
         { info_tbl: [(c8avW,
                       label: block_c8avW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8avW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8aw6; else goto c8aw5;
       c8aw6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8aw5: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8Y_entry() //  [R1, R2]
         { info_tbl: [(c8aw7,
                       label: sat_s8a8Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aw7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8awb; else goto c8awa;
       c8awb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8awa: // global
           _s8a8H::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8a8X_info;
           P64[Hp] = _s8a8H::P64;
           R5 = Hp - 7;
           R4 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode11_closure+2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode12_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a91_entry() //  [R1, R2]
         { info_tbl: [(c8awf,
                       label: sat_s8a91_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8awf: // global
           _s8a8J::P64 = R2;
           _s8a91::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8awg; else goto c8awh;
       c8awh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8awj; else goto c8awi;
       c8awj: // global
           HpAlloc = 16;
           goto c8awg;
       c8awg: // global
           R2 = _s8a8J::P64;
           R1 = _s8a91::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8awi: // global
           _s8a8H::P64 = P64[_s8a91::P64 + 7];
           I64[Hp - 8] = sat_s8a8Y_info;
           P64[Hp] = _s8a8H::P64;
           I64[Sp - 8] = block_c8awc_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8awc() //  [R1]
         { info_tbl: [(c8awc,
                       label: block_c8awc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8awc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8awm; else goto c8awl;
       c8awm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8awl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(c8awq,
                       label: GHC.IO.Handle.Types.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8awq: // global
           _s8a8H::P64 = R3;
           _s8a8G::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c8awr; else goto c8aws;
       c8aws: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8awu; else goto c8awt;
       c8awu: // global
           HpAlloc = 16;
           goto c8awr;
       c8awr: // global
           R3 = _s8a8H::P64;
           R2 = _s8a8G::I64;
           R1 = GHC.IO.Handle.Types.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8awt: // global
           if (%MO_S_Gt_W64(_s8a8G::I64, 11)) goto c8awo; else goto c8awp;
       c8awo: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8awp: // global
           I64[Hp - 8] = sat_s8a91_info;
           P64[Hp] = _s8a8H::P64;
           I64[Sp - 8] = block_c8awv_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8awv() //  [R1]
         { info_tbl: [(c8awv,
                       label: block_c8awv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8awv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8awA; else goto c8awz;
       c8awA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8awz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.611754006 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode2_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode2_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode2_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode2_entry() //  [R2, R3]
         { info_tbl: [(c8awI,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8awI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8awJ; else goto c8awK;
       c8awJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8awK: // global
           I64[Sp - 16] = block_c8awF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8awO; else goto c8awG;
       u8awO: // global
           call _c8awF(R1) args: 0, res: 0, upd: 0;
       c8awG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8awF() //  [R1]
         { info_tbl: [(c8awF,
                       label: block_c8awF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8awF: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.$w$creadPrec_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.612958602 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode1_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode1_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(c8awT,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8awT: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.614198185 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_info;
         const 0;
 },
 sat_s8a99_entry() //  [R1]
         { info_tbl: [(c8ax4,
                       label: sat_s8a99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ax4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ax5; else goto c8ax6;
       c8ax5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ax6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8ax7,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ax7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8axb; else goto c8axa;
       c8axb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8axa: // global
           I64[Hp - 16] = sat_s8a99_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.615432967 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8axi,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8axi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8axj; else goto c8axk;
       c8axj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8axk: // global
           (_c8axf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8axf::I64 == 0) goto c8axh; else goto c8axg;
       c8axh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8axg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8axf::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.616519844 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode18_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode18_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode18_entry() //  [R1]
         { info_tbl: [(c8axr,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8axr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8axs; else goto c8axt;
       c8axs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8axt: // global
           (_c8axo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8axo::I64 == 0) goto c8axq; else goto c8axp;
       c8axq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8axp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8axo::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.61760147 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_entry() //  [R2]
         { info_tbl: [(c8axy,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8axy: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode18_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.618350028 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadNewlineMode1_closure+2;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.619371983 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8axM,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8axM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8axN; else goto c8axO;
       c8axN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8axO: // global
           I64[Sp - 16] = block_c8axF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ayg; else goto c8axG;
       u8ayg: // global
           call _c8axF(R1) args: 0, res: 0, upd: 0;
       c8axG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8axF() //  [R1]
         { info_tbl: [(c8axF,
                       label: block_c8axF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8axF: // global
           _s8a9b::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8axJ; else goto c8axK;
       c8axJ: // global
           I64[Sp + 8] = block_c8axR_info;
           R1 = _s8a9b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8aye; else goto c8axT;
       u8aye: // global
           call _c8axR(R1) args: 0, res: 0, upd: 0;
       c8axT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8axK: // global
           I64[Sp + 8] = block_c8ay6_info;
           R1 = _s8a9b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ayf; else goto c8ay8;
       u8ayf: // global
           call _c8ay6() args: 0, res: 0, upd: 0;
       c8ay8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8axR() //  [R1]
         { info_tbl: [(c8axR,
                       label: block_c8axR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8axR: // global
           if (R1 & 7 == 1) goto c8axZ; else goto c8ay3;
       c8axZ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ay3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ay6() //  []
         { info_tbl: [(c8ay6,
                       label: block_c8ay6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ay6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.622288365 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8ays,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ays: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ayt; else goto c8ayu;
       c8ayt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ayu: // global
           I64[Sp - 16] = block_c8ayl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8az5; else goto c8aym;
       u8az5: // global
           call _c8ayl(R1) args: 0, res: 0, upd: 0;
       c8aym: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ayl() //  [R1]
         { info_tbl: [(c8ayl,
                       label: block_c8ayl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ayl: // global
           _s8a9g::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ayp; else goto c8ayq;
       c8ayp: // global
           I64[Sp + 8] = block_c8ayx_info;
           R1 = _s8a9g::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8az3; else goto c8ayz;
       u8az3: // global
           call _c8ayx(R1) args: 0, res: 0, upd: 0;
       c8ayz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ayq: // global
           I64[Sp + 8] = block_c8ayM_info;
           R1 = _s8a9g::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8az4; else goto c8ayO;
       u8az4: // global
           call _c8ayM(R1) args: 0, res: 0, upd: 0;
       c8ayO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ayx() //  [R1]
         { info_tbl: [(c8ayx,
                       label: block_c8ayx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ayx: // global
           if (R1 & 7 == 1) goto u8az2; else goto c8ayJ;
       u8az2: // global
           Sp = Sp + 8;
           call _c8ayY() args: 0, res: 0, upd: 0;
       c8ayJ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ayM() //  [R1]
         { info_tbl: [(c8ayM,
                       label: block_c8ayM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ayM: // global
           if (R1 & 7 == 1) goto c8ayU; else goto u8az1;
       c8ayU: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8az1: // global
           Sp = Sp + 8;
           call _c8ayY() args: 0, res: 0, upd: 0;
     }
 },
 _c8ayY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ayY: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.624423367 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_$c==_closure" {
     GHC.IO.Handle.Types.$fEqNewline_$c==_closure:
         const GHC.IO.Handle.Types.$fEqNewline_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqNewline_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8azj,
                       label: GHC.IO.Handle.Types.$fEqNewline_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8azj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8azk; else goto c8azl;
       c8azk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewline_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8azl: // global
           I64[Sp - 16] = block_c8azc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8azY; else goto c8azd;
       u8azY: // global
           call _c8azc(R1) args: 0, res: 0, upd: 0;
       c8azd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8azc() //  [R1]
         { info_tbl: [(c8azc,
                       label: block_c8azc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8azc: // global
           _s8a9l::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8azg; else goto c8azh;
       c8azg: // global
           I64[Sp + 8] = block_c8azo_info;
           R1 = _s8a9l::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8azW; else goto c8azq;
       u8azW: // global
           call _c8azo(R1) args: 0, res: 0, upd: 0;
       c8azq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8azh: // global
           I64[Sp + 8] = block_c8azD_info;
           R1 = _s8a9l::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8azX; else goto c8azF;
       u8azX: // global
           call _c8azD(R1) args: 0, res: 0, upd: 0;
       c8azF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8azo() //  [R1]
         { info_tbl: [(c8azo,
                       label: block_c8azo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8azo: // global
           if (R1 & 7 == 1) goto u8azU; else goto u8azV;
       u8azU: // global
           Sp = Sp + 8;
           call _c8azP() args: 0, res: 0, upd: 0;
       u8azV: // global
           Sp = Sp + 8;
           call _c8azL() args: 0, res: 0, upd: 0;
     }
 },
 _c8azD() //  [R1]
         { info_tbl: [(c8azD,
                       label: block_c8azD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8azD: // global
           if (R1 & 7 == 1) goto u8azS; else goto u8azT;
       u8azS: // global
           Sp = Sp + 8;
           call _c8azL() args: 0, res: 0, upd: 0;
       u8azT: // global
           Sp = Sp + 8;
           call _c8azP() args: 0, res: 0, upd: 0;
     }
 },
 _c8azL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8azL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8azP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8azP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.62799934 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqNewline_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqNewline_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqNewline_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8aAe,
                       label: GHC.IO.Handle.Types.$fEqNewline_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aAe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aAf; else goto c8aAg;
       c8aAf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewline_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aAg: // global
           I64[Sp - 16] = block_c8aA7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aAT; else goto c8aA8;
       u8aAT: // global
           call _c8aA7(R1) args: 0, res: 0, upd: 0;
       c8aA8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aA7() //  [R1]
         { info_tbl: [(c8aA7,
                       label: block_c8aA7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aA7: // global
           _s8a9q::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aAb; else goto c8aAc;
       c8aAb: // global
           I64[Sp + 8] = block_c8aAj_info;
           R1 = _s8a9q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8aAR; else goto c8aAl;
       u8aAR: // global
           call _c8aAj(R1) args: 0, res: 0, upd: 0;
       c8aAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aAc: // global
           I64[Sp + 8] = block_c8aAy_info;
           R1 = _s8a9q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8aAS; else goto c8aAA;
       u8aAS: // global
           call _c8aAy(R1) args: 0, res: 0, upd: 0;
       c8aAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aAj() //  [R1]
         { info_tbl: [(c8aAj,
                       label: block_c8aAj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aAj: // global
           if (R1 & 7 == 1) goto u8aAP; else goto u8aAQ;
       u8aAP: // global
           Sp = Sp + 8;
           call _c8aAK() args: 0, res: 0, upd: 0;
       u8aAQ: // global
           Sp = Sp + 8;
           call _c8aAG() args: 0, res: 0, upd: 0;
     }
 },
 _c8aAy() //  [R1]
         { info_tbl: [(c8aAy,
                       label: block_c8aAy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aAy: // global
           if (R1 & 7 == 1) goto u8aAN; else goto u8aAO;
       u8aAN: // global
           Sp = Sp + 8;
           call _c8aAG() args: 0, res: 0, upd: 0;
       u8aAO: // global
           Sp = Sp + 8;
           call _c8aAK() args: 0, res: 0, upd: 0;
     }
 },
 _c8aAG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aAG: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aAK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aAK: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.629660575 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_closure" {
     GHC.IO.Handle.Types.$fEqNewline_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqNewline_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqNewline_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.630621791 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8aB9,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aB9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aBa; else goto c8aBb;
       c8aBa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aBb: // global
           I64[Sp - 16] = block_c8aB2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aBD; else goto c8aB3;
       u8aBD: // global
           call _c8aB2(R1) args: 0, res: 0, upd: 0;
       c8aB3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aB2() //  [R1]
         { info_tbl: [(c8aB2,
                       label: block_c8aB2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aB2: // global
           _s8a9u::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aB6; else goto c8aB7;
       c8aB6: // global
           I64[Sp + 8] = block_c8aBe_info;
           R1 = _s8a9u::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8aBB; else goto c8aBg;
       u8aBB: // global
           call _c8aBe(R1) args: 0, res: 0, upd: 0;
       c8aBg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aB7: // global
           I64[Sp + 8] = block_c8aBt_info;
           R1 = _s8a9u::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8aBC; else goto c8aBv;
       u8aBC: // global
           call _c8aBt() args: 0, res: 0, upd: 0;
       c8aBv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aBe() //  [R1]
         { info_tbl: [(c8aBe,
                       label: block_c8aBe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aBe: // global
           if (R1 & 7 == 1) goto c8aBm; else goto c8aBq;
       c8aBm: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8aBq: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aBt() //  []
         { info_tbl: [(c8aBt,
                       label: block_c8aBt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aBt: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.632420736 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8aBP,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aBP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aBQ; else goto c8aBR;
       c8aBQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aBR: // global
           I64[Sp - 16] = block_c8aBI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aC5; else goto c8aBJ;
       u8aC5: // global
           call _c8aBI(R1) args: 0, res: 0, upd: 0;
       c8aBJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aBI() //  [R1]
         { info_tbl: [(c8aBI,
                       label: block_c8aBI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aBI: // global
           _s8a9z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aBM; else goto c8aBN;
       c8aBM: // global
           R1 = _s8a9z::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8aBN: // global
           I64[Sp + 8] = block_c8aBX_info;
           R1 = _s8a9z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8aC4; else goto c8aBZ;
       u8aC4: // global
           call _c8aBX() args: 0, res: 0, upd: 0;
       c8aBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aBX() //  []
         { info_tbl: [(c8aBX,
                       label: block_c8aBX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aBX: // global
           R1 = GHC.IO.Handle.Types.CRLF_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.634071846 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8aCh,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aCh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aCi; else goto c8aCj;
       c8aCi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aCj: // global
           I64[Sp - 16] = block_c8aCa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aCL; else goto c8aCb;
       u8aCL: // global
           call _c8aCa(R1) args: 0, res: 0, upd: 0;
       c8aCb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aCa() //  [R1]
         { info_tbl: [(c8aCa,
                       label: block_c8aCa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aCa: // global
           _s8a9E::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aCe; else goto c8aCf;
       c8aCe: // global
           I64[Sp + 8] = block_c8aCm_info;
           R1 = _s8a9E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8aCJ; else goto c8aCo;
       u8aCJ: // global
           call _c8aCm(R1) args: 0, res: 0, upd: 0;
       c8aCo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aCf: // global
           I64[Sp + 8] = block_c8aCB_info;
           R1 = _s8a9E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8aCK; else goto c8aCD;
       u8aCK: // global
           call _c8aCB() args: 0, res: 0, upd: 0;
       c8aCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aCm() //  [R1]
         { info_tbl: [(c8aCm,
                       label: block_c8aCm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aCm: // global
           if (R1 & 7 == 1) goto c8aCu; else goto c8aCy;
       c8aCu: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8aCy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aCB() //  []
         { info_tbl: [(c8aCB,
                       label: block_c8aCB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aCB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.635648803 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8aCQ,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aCQ: // global
           _s8a9J::P64 = R3;
           R3 = R2;
           R2 = _s8a9J::P64;
           call GHC.IO.Handle.Types.$fOrdNewline_$c<_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.636737451 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8aD4,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aD4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aD5; else goto c8aD6;
       c8aD5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aD6: // global
           I64[Sp - 16] = block_c8aCX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aDk; else goto c8aCY;
       u8aDk: // global
           call _c8aCX(R1) args: 0, res: 0, upd: 0;
       c8aCY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aCX() //  [R1]
         { info_tbl: [(c8aCX,
                       label: block_c8aCX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aCX: // global
           _s8a9K::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aD1; else goto c8aD2;
       c8aD1: // global
           I64[Sp + 8] = block_c8aD9_info;
           R1 = _s8a9K::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8aDj; else goto c8aDb;
       u8aDj: // global
           call _c8aD9() args: 0, res: 0, upd: 0;
       c8aDb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aD2: // global
           R1 = _s8a9K::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aD9() //  []
         { info_tbl: [(c8aD9,
                       label: block_c8aD9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aD9: // global
           R1 = GHC.IO.Handle.Types.LF_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.63868772 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqNewline_closure+1;
         const GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.639823281 UTC

[section ""data" . GHC.IO.Handle.Types.$w$ccompare_closure" {
     GHC.IO.Handle.Types.$w$ccompare_closure:
         const GHC.IO.Handle.Types.$w$ccompare_info;
 },
 GHC.IO.Handle.Types.$w$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8aDw,
                       label: GHC.IO.Handle.Types.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aDw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8aDx; else goto c8aDy;
       c8aDx: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$ccompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aDy: // global
           I64[Sp - 32] = block_c8aDp_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8aE9; else goto c8aDq;
       u8aE9: // global
           call _c8aDp(R1) args: 0, res: 0, upd: 0;
       c8aDq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aDp() //  [R1]
         { info_tbl: [(c8aDp,
                       label: block_c8aDp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aDp: // global
           _s8a9Q::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8aDt; else goto c8aDu;
       c8aDt: // global
           I64[Sp] = block_c8aDB_info;
           R1 = _s8a9Q::P64;
           if (R1 & 7 != 0) goto u8aE7; else goto c8aDD;
       u8aE7: // global
           call _c8aDB(R1) args: 0, res: 0, upd: 0;
       c8aDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aDu: // global
           I64[Sp] = block_c8aDQ_info;
           R1 = _s8a9Q::P64;
           if (R1 & 7 != 0) goto u8aE8; else goto c8aDS;
       u8aE8: // global
           call _c8aDQ(R1) args: 0, res: 0, upd: 0;
       c8aDS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aDB() //  [R1]
         { info_tbl: [(c8aDB,
                       label: block_c8aDB_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aDB: // global
           if (R1 & 7 == 1) goto u8aE6; else goto c8aDN;
       u8aE6: // global
           Sp = Sp + 8;
           call _c8aE2() args: 0, res: 0, upd: 0;
       c8aDN: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aDQ() //  [R1]
         { info_tbl: [(c8aDQ,
                       label: block_c8aDQ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aDQ: // global
           if (R1 & 7 == 1) goto c8aDY; else goto u8aE5;
       c8aDY: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8aE5: // global
           Sp = Sp + 8;
           call _c8aE2() args: 0, res: 0, upd: 0;
     }
 },
 _c8aE2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aE2: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fOrdNewline_$ccompare_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.641861115 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8aEj,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aEj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8aEn; else goto c8aEo;
       c8aEn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aEo: // global
           I64[Sp - 16] = block_c8aEg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aEw; else goto c8aEh;
       u8aEw: // global
           call _c8aEg(R1) args: 0, res: 0, upd: 0;
       c8aEh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aEg() //  [R1]
         { info_tbl: [(c8aEg,
                       label: block_c8aEg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aEg: // global
           I64[Sp - 8] = block_c8aEm_info;
           _s8a9Y::P64 = P64[R1 + 7];
           _s8a9Z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8a9Z::P64;
           P64[Sp + 8] = _s8a9Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aEv; else goto c8aEq;
       u8aEv: // global
           call _c8aEm(R1) args: 0, res: 0, upd: 0;
       c8aEq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aEm() //  [R1]
         { info_tbl: [(c8aEm,
                       label: block_c8aEm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aEm: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$ccompare_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.643673955 UTC

[section ""data" . GHC.IO.Handle.Types.$w$c<_closure" {
     GHC.IO.Handle.Types.$w$c<_closure:
         const GHC.IO.Handle.Types.$w$c<_info;
 },
 GHC.IO.Handle.Types.$w$c<_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8aEI,
                       label: GHC.IO.Handle.Types.$w$c<_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aEI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8aEJ; else goto c8aEK;
       c8aEJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$c<_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aEK: // global
           I64[Sp - 32] = block_c8aEB_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8aFl; else goto c8aEC;
       u8aFl: // global
           call _c8aEB(R1) args: 0, res: 0, upd: 0;
       c8aEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aEB() //  [R1]
         { info_tbl: [(c8aEB,
                       label: block_c8aEB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aEB: // global
           _s8aa5::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8aEF; else goto c8aEG;
       c8aEF: // global
           I64[Sp] = block_c8aEN_info;
           R1 = _s8aa5::P64;
           if (R1 & 7 != 0) goto u8aFj; else goto c8aEP;
       u8aFj: // global
           call _c8aEN(R1) args: 0, res: 0, upd: 0;
       c8aEP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aEG: // global
           I64[Sp] = block_c8aF2_info;
           R1 = _s8aa5::P64;
           if (R1 & 7 != 0) goto u8aFk; else goto c8aF4;
       u8aFk: // global
           call _c8aF2(R1) args: 0, res: 0, upd: 0;
       c8aF4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aEN() //  [R1]
         { info_tbl: [(c8aEN,
                       label: block_c8aEN_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aEN: // global
           if (R1 & 7 == 1) goto u8aFi; else goto c8aEZ;
       u8aFi: // global
           Sp = Sp + 8;
           call _c8aFe() args: 0, res: 0, upd: 0;
       c8aEZ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aF2() //  [R1]
         { info_tbl: [(c8aF2,
                       label: block_c8aF2_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aF2: // global
           if (R1 & 7 == 1) goto c8aFa; else goto u8aFh;
       c8aFa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8aFh: // global
           Sp = Sp + 8;
           call _c8aFe() args: 0, res: 0, upd: 0;
     }
 },
 _c8aFe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aFe: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fOrdNewline_$c<_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.645646374 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8aFv,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aFv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8aFz; else goto c8aFA;
       c8aFz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aFA: // global
           I64[Sp - 16] = block_c8aFs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aFI; else goto c8aFt;
       u8aFI: // global
           call _c8aFs(R1) args: 0, res: 0, upd: 0;
       c8aFt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aFs() //  [R1]
         { info_tbl: [(c8aFs,
                       label: block_c8aFs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aFs: // global
           I64[Sp - 8] = block_c8aFy_info;
           _s8aad::P64 = P64[R1 + 7];
           _s8aae::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aae::P64;
           P64[Sp + 8] = _s8aad::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aFH; else goto c8aFC;
       u8aFH: // global
           call _c8aFy(R1) args: 0, res: 0, upd: 0;
       c8aFC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aFy() //  [R1]
         { info_tbl: [(c8aFy,
                       label: block_c8aFy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aFy: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$c<_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.647357622 UTC

[section ""data" . GHC.IO.Handle.Types.$w$c==_closure" {
     GHC.IO.Handle.Types.$w$c==_closure:
         const GHC.IO.Handle.Types.$w$c==_info;
 },
 GHC.IO.Handle.Types.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8aFU,
                       label: GHC.IO.Handle.Types.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aFU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8aFV; else goto c8aFW;
       c8aFV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aFW: // global
           I64[Sp - 32] = block_c8aFN_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8aGz; else goto c8aFO;
       u8aGz: // global
           call _c8aFN(R1) args: 0, res: 0, upd: 0;
       c8aFO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aFN() //  [R1]
         { info_tbl: [(c8aFN,
                       label: block_c8aFN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aFN: // global
           _s8aak::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8aFR; else goto c8aFS;
       c8aFR: // global
           I64[Sp] = block_c8aFZ_info;
           R1 = _s8aak::P64;
           if (R1 & 7 != 0) goto u8aGx; else goto c8aG1;
       u8aGx: // global
           call _c8aFZ(R1) args: 0, res: 0, upd: 0;
       c8aG1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aFS: // global
           I64[Sp] = block_c8aGe_info;
           R1 = _s8aak::P64;
           if (R1 & 7 != 0) goto u8aGy; else goto c8aGg;
       u8aGy: // global
           call _c8aGe(R1) args: 0, res: 0, upd: 0;
       c8aGg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aFZ() //  [R1]
         { info_tbl: [(c8aFZ,
                       label: block_c8aFZ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aFZ: // global
           if (R1 & 7 == 1) goto u8aGv; else goto u8aGw;
       u8aGv: // global
           Sp = Sp + 8;
           call _c8aGq() args: 0, res: 0, upd: 0;
       u8aGw: // global
           Sp = Sp + 32;
           call _c8aGm() args: 0, res: 0, upd: 0;
     }
 },
 _c8aGe() //  [R1]
         { info_tbl: [(c8aGe,
                       label: block_c8aGe_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aGe: // global
           if (R1 & 7 == 1) goto u8aGt; else goto u8aGu;
       u8aGt: // global
           Sp = Sp + 32;
           call _c8aGm() args: 0, res: 0, upd: 0;
       u8aGu: // global
           Sp = Sp + 8;
           call _c8aGq() args: 0, res: 0, upd: 0;
     }
 },
 _c8aGm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aGm: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aGq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aGq: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fEqNewline_$c==_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.649344441 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure:
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqNewlineMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8aGL,
                       label: GHC.IO.Handle.Types.$fEqNewlineMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aGL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8aGP; else goto c8aGQ;
       c8aGP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aGQ: // global
           I64[Sp - 16] = block_c8aGI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aGY; else goto c8aGJ;
       u8aGY: // global
           call _c8aGI(R1) args: 0, res: 0, upd: 0;
       c8aGJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aGI() //  [R1]
         { info_tbl: [(c8aGI,
                       label: block_c8aGI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aGI: // global
           I64[Sp - 8] = block_c8aGO_info;
           _s8aas::P64 = P64[R1 + 7];
           _s8aat::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aat::P64;
           P64[Sp + 8] = _s8aas::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aGX; else goto c8aGS;
       u8aGX: // global
           call _c8aGO(R1) args: 0, res: 0, upd: 0;
       c8aGS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aGO() //  [R1]
         { info_tbl: [(c8aGO,
                       label: block_c8aGO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aGO: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$c==_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.651867714 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8aH6,
                       label: GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aH6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8aHa; else goto c8aHb;
       c8aHa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aHb: // global
           I64[Sp - 16] = block_c8aH3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aJm; else goto c8aH4;
       u8aJm: // global
           call _c8aH3(R1) args: 0, res: 0, upd: 0;
       c8aH4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aH3() //  [R1]
         { info_tbl: [(c8aH3,
                       label: block_c8aH3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aH3: // global
           I64[Sp - 8] = block_c8aH9_info;
           _s8aaA::P64 = P64[R1 + 7];
           _s8aaB::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aaB::P64;
           P64[Sp + 8] = _s8aaA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aJl; else goto c8aHd;
       u8aJl: // global
           call _c8aH9(R1) args: 0, res: 0, upd: 0;
       c8aHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aH9() //  [R1]
         { info_tbl: [(c8aH9,
                       label: block_c8aH9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aH9: // global
           I64[Sp - 8] = block_c8aHh_info;
           _s8aaD::P64 = P64[R1 + 7];
           _s8aaE::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8aaE::P64;
           P64[Sp + 16] = _s8aaD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aJn; else goto c8aHj;
       u8aJn: // global
           call _c8aHh(R1) args: 0, res: 0, upd: 0;
       c8aHj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aHh() //  [R1]
         { info_tbl: [(c8aHh,
                       label: block_c8aHh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aHh: // global
           _s8aaD::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8aHq; else goto c8aIg;
       c8aHq: // global
           I64[Sp] = block_c8aHn_info;
           R1 = _s8aaD::P64;
           if (R1 & 7 != 0) goto u8aJo; else goto c8aHr;
       u8aJo: // global
           call _c8aHn(R1) args: 0, res: 0, upd: 0;
       c8aHr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aIg: // global
           I64[Sp] = block_c8aIe_info;
           R1 = _s8aaD::P64;
           if (R1 & 7 != 0) goto u8aJp; else goto c8aIh;
       u8aJp: // global
           call _c8aIe(R1) args: 0, res: 0, upd: 0;
       c8aIh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aHn() //  [R1]
         { info_tbl: [(c8aHn,
                       label: block_c8aHn_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aHn: // global
           if (R1 & 7 == 1) goto c8aHy; else goto u8aJg;
       c8aHy: // global
           I64[Sp] = block_c8aHv_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8aJq; else goto c8aHz;
       u8aJq: // global
           call _c8aHv(R1) args: 0, res: 0, upd: 0;
       c8aHz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8aJg: // global
           Sp = Sp + 32;
           call _c8aIX() args: 0, res: 0, upd: 0;
     }
 },
 _c8aHv() //  [R1]
         { info_tbl: [(c8aHv,
                       label: block_c8aHv_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aHv: // global
           _s8aaE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aHG; else goto c8aHW;
       c8aHG: // global
           I64[Sp + 24] = block_c8aHD_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aJs; else goto c8aHH;
       u8aJs: // global
           call _c8aHD(R1) args: 0, res: 0, upd: 0;
       c8aHH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aHW: // global
           I64[Sp + 24] = block_c8aHU_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aJt; else goto c8aHX;
       u8aJt: // global
           call _c8aHU(R1) args: 0, res: 0, upd: 0;
       c8aHX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aHD() //  [R1]
         { info_tbl: [(c8aHD,
                       label: block_c8aHD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aHD: // global
           if (R1 & 7 == 1) goto u8aJj; else goto u8aJk;
       u8aJj: // global
           Sp = Sp + 8;
           call _c8aJ1() args: 0, res: 0, upd: 0;
       u8aJk: // global
           Sp = Sp + 8;
           call _c8aIX() args: 0, res: 0, upd: 0;
     }
 },
 _c8aHU() //  [R1]
         { info_tbl: [(c8aHU,
                       label: block_c8aHU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aHU: // global
           if (R1 & 7 == 1) goto u8aJh; else goto u8aJi;
       u8aJh: // global
           Sp = Sp + 8;
           call _c8aIX() args: 0, res: 0, upd: 0;
       u8aJi: // global
           Sp = Sp + 8;
           call _c8aJ1() args: 0, res: 0, upd: 0;
     }
 },
 _c8aIe() //  [R1]
         { info_tbl: [(c8aIe,
                       label: block_c8aIe_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aIe: // global
           if (R1 & 7 == 1) goto u8aJb; else goto c8aIs;
       u8aJb: // global
           Sp = Sp + 32;
           call _c8aIX() args: 0, res: 0, upd: 0;
       c8aIs: // global
           I64[Sp] = block_c8aIq_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8aJy; else goto c8aIt;
       u8aJy: // global
           call _c8aIq(R1) args: 0, res: 0, upd: 0;
       c8aIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aIq() //  [R1]
         { info_tbl: [(c8aIq,
                       label: block_c8aIq_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aIq: // global
           _s8aaE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aIA; else goto c8aIQ;
       c8aIA: // global
           I64[Sp + 24] = block_c8aIx_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aJA; else goto c8aIB;
       u8aJA: // global
           call _c8aIx(R1) args: 0, res: 0, upd: 0;
       c8aIB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aIQ: // global
           I64[Sp + 24] = block_c8aIO_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aJB; else goto c8aIR;
       u8aJB: // global
           call _c8aIO(R1) args: 0, res: 0, upd: 0;
       c8aIR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aIx() //  [R1]
         { info_tbl: [(c8aIx,
                       label: block_c8aIx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aIx: // global
           if (R1 & 7 == 1) goto u8aJe; else goto u8aJf;
       u8aJe: // global
           Sp = Sp + 8;
           call _c8aJ1() args: 0, res: 0, upd: 0;
       u8aJf: // global
           Sp = Sp + 8;
           call _c8aIX() args: 0, res: 0, upd: 0;
     }
 },
 _c8aIO() //  [R1]
         { info_tbl: [(c8aIO,
                       label: block_c8aIO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aIO: // global
           if (R1 & 7 == 1) goto u8aJc; else goto u8aJd;
       u8aJc: // global
           Sp = Sp + 8;
           call _c8aIX() args: 0, res: 0, upd: 0;
       u8aJd: // global
           Sp = Sp + 8;
           call _c8aJ1() args: 0, res: 0, upd: 0;
     }
 },
 _c8aIX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aIX: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aJ1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aJ1: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.655266679 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.657040805 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8aJN,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aJN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8aJR; else goto c8aJS;
       c8aJR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aJS: // global
           I64[Sp - 16] = block_c8aJK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aLL; else goto c8aJL;
       u8aLL: // global
           call _c8aJK(R1) args: 0, res: 0, upd: 0;
       c8aJL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aJK() //  [R1]
         { info_tbl: [(c8aJK,
                       label: block_c8aJK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aJK: // global
           I64[Sp - 8] = block_c8aJQ_info;
           _s8aaR::P64 = P64[R1 + 7];
           _s8aaS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aaS::P64;
           P64[Sp + 8] = _s8aaR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aLK; else goto c8aJU;
       u8aLK: // global
           call _c8aJQ(R1) args: 0, res: 0, upd: 0;
       c8aJU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aJQ() //  [R1]
         { info_tbl: [(c8aJQ,
                       label: block_c8aJQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aJQ: // global
           I64[Sp - 8] = block_c8aJY_info;
           _s8aaU::P64 = P64[R1 + 7];
           _s8aaV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8aaV::P64;
           P64[Sp + 16] = _s8aaU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aLM; else goto c8aK0;
       u8aLM: // global
           call _c8aJY(R1) args: 0, res: 0, upd: 0;
       c8aK0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aJY() //  [R1]
         { info_tbl: [(c8aJY,
                       label: block_c8aJY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aJY: // global
           _s8aaU::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8aK7; else goto c8aKR;
       c8aK7: // global
           I64[Sp] = block_c8aK4_info;
           R1 = _s8aaU::P64;
           if (R1 & 7 != 0) goto u8aLN; else goto c8aK8;
       u8aLN: // global
           call _c8aK4(R1) args: 0, res: 0, upd: 0;
       c8aK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aKR: // global
           I64[Sp] = block_c8aKP_info;
           R1 = _s8aaU::P64;
           if (R1 & 7 != 0) goto u8aLO; else goto c8aKS;
       u8aLO: // global
           call _c8aKP(R1) args: 0, res: 0, upd: 0;
       c8aKS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aK4() //  [R1]
         { info_tbl: [(c8aK4,
                       label: block_c8aK4_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aK4: // global
           if (R1 & 7 == 1) goto c8aKf; else goto u8aLH;
       c8aKf: // global
           I64[Sp] = block_c8aKc_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8aLP; else goto c8aKg;
       u8aLP: // global
           call _c8aKc(R1) args: 0, res: 0, upd: 0;
       c8aKg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8aLH: // global
           Sp = Sp + 32;
           call _c8aLm() args: 0, res: 0, upd: 0;
     }
 },
 _c8aKc() //  [R1]
         { info_tbl: [(c8aKc,
                       label: block_c8aKc_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aKc: // global
           _s8aaV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aKn; else goto c8aKD;
       c8aKn: // global
           I64[Sp + 24] = block_c8aKk_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aLR; else goto c8aKo;
       u8aLR: // global
           call _c8aKk(R1) args: 0, res: 0, upd: 0;
       c8aKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aKD: // global
           I64[Sp + 24] = block_c8aKB_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aLS; else goto c8aKE;
       u8aLS: // global
           call _c8aKB() args: 0, res: 0, upd: 0;
       c8aKE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aKk() //  [R1]
         { info_tbl: [(c8aKk,
                       label: block_c8aKk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aKk: // global
           if (R1 & 7 == 1) goto u8aLI; else goto u8aLJ;
       u8aLI: // global
           Sp = Sp + 8;
           call _c8aLi() args: 0, res: 0, upd: 0;
       u8aLJ: // global
           Sp = Sp + 8;
           call _c8aLm() args: 0, res: 0, upd: 0;
     }
 },
 _c8aKB() //  []
         { info_tbl: [(c8aKB,
                       label: block_c8aKB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aKB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aKP() //  [R1]
         { info_tbl: [(c8aKP,
                       label: block_c8aKP_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aKP: // global
           if (R1 & 7 == 1) goto u8aLE; else goto c8aL3;
       u8aLE: // global
           Sp = Sp + 32;
           call _c8aLi() args: 0, res: 0, upd: 0;
       c8aL3: // global
           I64[Sp] = block_c8aL1_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8aLV; else goto c8aL4;
       u8aLV: // global
           call _c8aL1(R1) args: 0, res: 0, upd: 0;
       c8aL4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aL1() //  [R1]
         { info_tbl: [(c8aL1,
                       label: block_c8aL1_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aL1: // global
           _s8aaV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aLb; else goto c8aLr;
       c8aLb: // global
           I64[Sp + 24] = block_c8aL8_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aLX; else goto c8aLc;
       u8aLX: // global
           call _c8aL8(R1) args: 0, res: 0, upd: 0;
       c8aLc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aLr: // global
           I64[Sp + 24] = block_c8aLp_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aLY; else goto c8aLs;
       u8aLY: // global
           call _c8aLp() args: 0, res: 0, upd: 0;
       c8aLs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aL8() //  [R1]
         { info_tbl: [(c8aL8,
                       label: block_c8aL8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aL8: // global
           if (R1 & 7 == 1) goto u8aLF; else goto u8aLG;
       u8aLF: // global
           Sp = Sp + 8;
           call _c8aLi() args: 0, res: 0, upd: 0;
       u8aLG: // global
           Sp = Sp + 8;
           call _c8aLm() args: 0, res: 0, upd: 0;
     }
 },
 _c8aLi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aLi: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aLm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aLm: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aLp() //  []
         { info_tbl: [(c8aLp,
                       label: block_c8aLp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aLp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.661824081 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8aM8,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aM8: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8aMc; else goto c8aMd;
       c8aMc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aMd: // global
           I64[Sp - 16] = block_c8aM5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aO6; else goto c8aM6;
       u8aO6: // global
           call _c8aM5(R1) args: 0, res: 0, upd: 0;
       c8aM6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aM5() //  [R1]
         { info_tbl: [(c8aM5,
                       label: block_c8aM5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aM5: // global
           I64[Sp - 16] = block_c8aMb_info;
           _s8ab7::P64 = R1;
           _s8ab8::P64 = P64[R1 + 7];
           _s8ab9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s8ab9::P64;
           P64[Sp] = _s8ab8::P64;
           P64[Sp + 8] = _s8ab7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aO5; else goto c8aMf;
       u8aO5: // global
           call _c8aMb(R1) args: 0, res: 0, upd: 0;
       c8aMf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aMb() //  [R1]
         { info_tbl: [(c8aMb,
                       label: block_c8aMb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aMb: // global
           I64[Sp - 16] = block_c8aMj_info;
           _s8aba::P64 = R1;
           _s8abb::P64 = P64[R1 + 7];
           _s8abc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8abc::P64;
           P64[Sp] = _s8abb::P64;
           P64[Sp + 16] = _s8aba::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aO7; else goto c8aMl;
       u8aO7: // global
           call _c8aMj(R1) args: 0, res: 0, upd: 0;
       c8aMl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aMj() //  [R1]
         { info_tbl: [(c8aMj,
                       label: block_c8aMj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aMj: // global
           _s8abb::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8aMs; else goto c8aNc;
       c8aMs: // global
           I64[Sp] = block_c8aMp_info;
           R1 = _s8abb::P64;
           if (R1 & 7 != 0) goto u8aO8; else goto c8aMt;
       u8aO8: // global
           call _c8aMp(R1) args: 0, res: 0, upd: 0;
       c8aMt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aNc: // global
           I64[Sp] = block_c8aNa_info;
           R1 = _s8abb::P64;
           if (R1 & 7 != 0) goto u8aO9; else goto c8aNd;
       u8aO9: // global
           call _c8aNa(R1) args: 0, res: 0, upd: 0;
       c8aNd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aMp() //  [R1]
         { info_tbl: [(c8aMp,
                       label: block_c8aMp_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aMp: // global
           if (R1 & 7 == 1) goto c8aMA; else goto u8aO2;
       c8aMA: // global
           I64[Sp] = block_c8aMx_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8aOa; else goto c8aMB;
       u8aOa: // global
           call _c8aMx(R1) args: 0, res: 0, upd: 0;
       c8aMB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8aO2: // global
           Sp = Sp + 32;
           call _c8aNH() args: 0, res: 0, upd: 0;
     }
 },
 _c8aMx() //  [R1]
         { info_tbl: [(c8aMx,
                       label: block_c8aMx_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aMx: // global
           _s8abc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aMI; else goto c8aMY;
       c8aMI: // global
           I64[Sp + 24] = block_c8aMF_info;
           R1 = _s8abc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aOc; else goto c8aMJ;
       u8aOc: // global
           call _c8aMF(R1) args: 0, res: 0, upd: 0;
       c8aMJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aMY: // global
           I64[Sp + 32] = block_c8aMW_info;
           R1 = _s8abc::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8aOd; else goto c8aMZ;
       u8aOd: // global
           call _c8aMW() args: 0, res: 0, upd: 0;
       c8aMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aMF() //  [R1]
         { info_tbl: [(c8aMF,
                       label: block_c8aMF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aMF: // global
           if (R1 & 7 == 1) goto u8aO3; else goto u8aO4;
       u8aO3: // global
           Sp = Sp + 16;
           call _c8aND() args: 0, res: 0, upd: 0;
       u8aO4: // global
           Sp = Sp + 8;
           call _c8aNH() args: 0, res: 0, upd: 0;
     }
 },
 _c8aMW() //  []
         { info_tbl: [(c8aMW,
                       label: block_c8aMW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aMW: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aNa() //  [R1]
         { info_tbl: [(c8aNa,
                       label: block_c8aNa_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aNa: // global
           if (R1 & 7 == 1) goto u8aNZ; else goto c8aNo;
       u8aNZ: // global
           Sp = Sp + 40;
           call _c8aND() args: 0, res: 0, upd: 0;
       c8aNo: // global
           I64[Sp] = block_c8aNm_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8aOg; else goto c8aNp;
       u8aOg: // global
           call _c8aNm(R1) args: 0, res: 0, upd: 0;
       c8aNp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aNm() //  [R1]
         { info_tbl: [(c8aNm,
                       label: block_c8aNm_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aNm: // global
           _s8abc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aNw; else goto c8aNM;
       c8aNw: // global
           I64[Sp + 24] = block_c8aNt_info;
           R1 = _s8abc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aOi; else goto c8aNx;
       u8aOi: // global
           call _c8aNt(R1) args: 0, res: 0, upd: 0;
       c8aNx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aNM: // global
           I64[Sp + 32] = block_c8aNK_info;
           R1 = _s8abc::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8aOj; else goto c8aNN;
       u8aOj: // global
           call _c8aNK() args: 0, res: 0, upd: 0;
       c8aNN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aNt() //  [R1]
         { info_tbl: [(c8aNt,
                       label: block_c8aNt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aNt: // global
           if (R1 & 7 == 1) goto u8aO0; else goto u8aO1;
       u8aO0: // global
           Sp = Sp + 16;
           call _c8aND() args: 0, res: 0, upd: 0;
       u8aO1: // global
           Sp = Sp + 8;
           call _c8aNH() args: 0, res: 0, upd: 0;
     }
 },
 _c8aND() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aND: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aNH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aNH: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aNK() //  []
         { info_tbl: [(c8aNK,
                       label: block_c8aNK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aNK: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.668680437 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8aOt,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aOt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8aOx; else goto c8aOy;
       c8aOx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aOy: // global
           I64[Sp - 16] = block_c8aOq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aQr; else goto c8aOr;
       u8aQr: // global
           call _c8aOq(R1) args: 0, res: 0, upd: 0;
       c8aOr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aOq() //  [R1]
         { info_tbl: [(c8aOq,
                       label: block_c8aOq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aOq: // global
           I64[Sp - 8] = block_c8aOw_info;
           _s8abp::P64 = P64[R1 + 7];
           _s8abq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8abq::P64;
           P64[Sp + 8] = _s8abp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aQq; else goto c8aOA;
       u8aQq: // global
           call _c8aOw(R1) args: 0, res: 0, upd: 0;
       c8aOA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aOw() //  [R1]
         { info_tbl: [(c8aOw,
                       label: block_c8aOw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aOw: // global
           I64[Sp - 8] = block_c8aOE_info;
           _s8abs::P64 = P64[R1 + 7];
           _s8abt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8abt::P64;
           P64[Sp + 16] = _s8abs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aQs; else goto c8aOG;
       u8aQs: // global
           call _c8aOE(R1) args: 0, res: 0, upd: 0;
       c8aOG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aOE() //  [R1]
         { info_tbl: [(c8aOE,
                       label: block_c8aOE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aOE: // global
           _s8abs::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8aON; else goto c8aPx;
       c8aON: // global
           I64[Sp] = block_c8aOK_info;
           R1 = _s8abs::P64;
           if (R1 & 7 != 0) goto u8aQt; else goto c8aOO;
       u8aQt: // global
           call _c8aOK(R1) args: 0, res: 0, upd: 0;
       c8aOO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aPx: // global
           I64[Sp] = block_c8aPv_info;
           R1 = _s8abs::P64;
           if (R1 & 7 != 0) goto u8aQu; else goto c8aPy;
       u8aQu: // global
           call _c8aPv(R1) args: 0, res: 0, upd: 0;
       c8aPy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aOK() //  [R1]
         { info_tbl: [(c8aOK,
                       label: block_c8aOK_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aOK: // global
           if (R1 & 7 == 1) goto c8aOV; else goto u8aQn;
       c8aOV: // global
           I64[Sp] = block_c8aOS_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8aQv; else goto c8aOW;
       u8aQv: // global
           call _c8aOS(R1) args: 0, res: 0, upd: 0;
       c8aOW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8aQn: // global
           Sp = Sp + 32;
           call _c8aQ2() args: 0, res: 0, upd: 0;
     }
 },
 _c8aOS() //  [R1]
         { info_tbl: [(c8aOS,
                       label: block_c8aOS_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aOS: // global
           _s8abt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aP3; else goto c8aPj;
       c8aP3: // global
           I64[Sp + 24] = block_c8aP0_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aQx; else goto c8aP4;
       u8aQx: // global
           call _c8aP0(R1) args: 0, res: 0, upd: 0;
       c8aP4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aPj: // global
           I64[Sp + 24] = block_c8aPh_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aQy; else goto c8aPk;
       u8aQy: // global
           call _c8aPh() args: 0, res: 0, upd: 0;
       c8aPk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aP0() //  [R1]
         { info_tbl: [(c8aP0,
                       label: block_c8aP0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aP0: // global
           if (R1 & 7 == 1) goto u8aQo; else goto u8aQp;
       u8aQo: // global
           Sp = Sp + 8;
           call _c8aPY() args: 0, res: 0, upd: 0;
       u8aQp: // global
           Sp = Sp + 8;
           call _c8aQ2() args: 0, res: 0, upd: 0;
     }
 },
 _c8aPh() //  []
         { info_tbl: [(c8aPh,
                       label: block_c8aPh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aPh: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aPv() //  [R1]
         { info_tbl: [(c8aPv,
                       label: block_c8aPv_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aPv: // global
           if (R1 & 7 == 1) goto u8aQk; else goto c8aPJ;
       u8aQk: // global
           Sp = Sp + 32;
           call _c8aPY() args: 0, res: 0, upd: 0;
       c8aPJ: // global
           I64[Sp] = block_c8aPH_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8aQB; else goto c8aPK;
       u8aQB: // global
           call _c8aPH(R1) args: 0, res: 0, upd: 0;
       c8aPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aPH() //  [R1]
         { info_tbl: [(c8aPH,
                       label: block_c8aPH_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aPH: // global
           _s8abt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aPR; else goto c8aQ7;
       c8aPR: // global
           I64[Sp + 24] = block_c8aPO_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aQD; else goto c8aPS;
       u8aQD: // global
           call _c8aPO(R1) args: 0, res: 0, upd: 0;
       c8aPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aQ7: // global
           I64[Sp + 24] = block_c8aQ5_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aQE; else goto c8aQ8;
       u8aQE: // global
           call _c8aQ5() args: 0, res: 0, upd: 0;
       c8aQ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aPO() //  [R1]
         { info_tbl: [(c8aPO,
                       label: block_c8aPO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aPO: // global
           if (R1 & 7 == 1) goto u8aQl; else goto u8aQm;
       u8aQl: // global
           Sp = Sp + 8;
           call _c8aPY() args: 0, res: 0, upd: 0;
       u8aQm: // global
           Sp = Sp + 8;
           call _c8aQ2() args: 0, res: 0, upd: 0;
     }
 },
 _c8aPY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aPY: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aQ2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aQ2: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aQ5() //  []
         { info_tbl: [(c8aQ5,
                       label: block_c8aQ5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aQ5: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.672999456 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8aQL,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aQL: // global
           _s8abE::P64 = R3;
           R3 = R2;
           R2 = _s8abE::P64;
           call GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.675622288 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8aQV,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aQV: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8aQZ; else goto c8aR0;
       c8aQZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aR0: // global
           I64[Sp - 16] = block_c8aQS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aST; else goto c8aQT;
       u8aST: // global
           call _c8aQS(R1) args: 0, res: 0, upd: 0;
       c8aQT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aQS() //  [R1]
         { info_tbl: [(c8aQS,
                       label: block_c8aQS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aQS: // global
           I64[Sp - 16] = block_c8aQY_info;
           _s8abH::P64 = R1;
           _s8abI::P64 = P64[R1 + 7];
           _s8abJ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s8abJ::P64;
           P64[Sp] = _s8abI::P64;
           P64[Sp + 8] = _s8abH::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aSS; else goto c8aR2;
       u8aSS: // global
           call _c8aQY(R1) args: 0, res: 0, upd: 0;
       c8aR2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aQY() //  [R1]
         { info_tbl: [(c8aQY,
                       label: block_c8aQY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aQY: // global
           I64[Sp - 16] = block_c8aR6_info;
           _s8abK::P64 = R1;
           _s8abL::P64 = P64[R1 + 7];
           _s8abM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8abM::P64;
           P64[Sp] = _s8abL::P64;
           P64[Sp + 16] = _s8abK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aSU; else goto c8aR8;
       u8aSU: // global
           call _c8aR6(R1) args: 0, res: 0, upd: 0;
       c8aR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aR6() //  [R1]
         { info_tbl: [(c8aR6,
                       label: block_c8aR6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aR6: // global
           _s8abL::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8aRf; else goto c8aRZ;
       c8aRf: // global
           I64[Sp] = block_c8aRc_info;
           R1 = _s8abL::P64;
           if (R1 & 7 != 0) goto u8aSV; else goto c8aRg;
       u8aSV: // global
           call _c8aRc(R1) args: 0, res: 0, upd: 0;
       c8aRg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aRZ: // global
           I64[Sp] = block_c8aRX_info;
           R1 = _s8abL::P64;
           if (R1 & 7 != 0) goto u8aSW; else goto c8aS0;
       u8aSW: // global
           call _c8aRX(R1) args: 0, res: 0, upd: 0;
       c8aS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aRc() //  [R1]
         { info_tbl: [(c8aRc,
                       label: block_c8aRc_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aRc: // global
           if (R1 & 7 == 1) goto c8aRn; else goto u8aSP;
       c8aRn: // global
           I64[Sp] = block_c8aRk_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8aSX; else goto c8aRo;
       u8aSX: // global
           call _c8aRk(R1) args: 0, res: 0, upd: 0;
       c8aRo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8aSP: // global
           Sp = Sp + 40;
           call _c8aSu() args: 0, res: 0, upd: 0;
     }
 },
 _c8aRk() //  [R1]
         { info_tbl: [(c8aRk,
                       label: block_c8aRk_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aRk: // global
           _s8abM::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aRv; else goto c8aRL;
       c8aRv: // global
           I64[Sp + 24] = block_c8aRs_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aSZ; else goto c8aRw;
       u8aSZ: // global
           call _c8aRs(R1) args: 0, res: 0, upd: 0;
       c8aRw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aRL: // global
           I64[Sp + 24] = block_c8aRJ_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aT0; else goto c8aRM;
       u8aT0: // global
           call _c8aRJ() args: 0, res: 0, upd: 0;
       c8aRM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aRs() //  [R1]
         { info_tbl: [(c8aRs,
                       label: block_c8aRs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aRs: // global
           if (R1 & 7 == 1) goto u8aSQ; else goto u8aSR;
       u8aSQ: // global
           Sp = Sp + 8;
           call _c8aSq() args: 0, res: 0, upd: 0;
       u8aSR: // global
           Sp = Sp + 16;
           call _c8aSu() args: 0, res: 0, upd: 0;
     }
 },
 _c8aRJ() //  []
         { info_tbl: [(c8aRJ,
                       label: block_c8aRJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aRJ: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aRX() //  [R1]
         { info_tbl: [(c8aRX,
                       label: block_c8aRX_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aRX: // global
           if (R1 & 7 == 1) goto u8aSM; else goto c8aSb;
       u8aSM: // global
           Sp = Sp + 32;
           call _c8aSq() args: 0, res: 0, upd: 0;
       c8aSb: // global
           I64[Sp] = block_c8aS9_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8aT3; else goto c8aSc;
       u8aT3: // global
           call _c8aS9(R1) args: 0, res: 0, upd: 0;
       c8aSc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aS9() //  [R1]
         { info_tbl: [(c8aS9,
                       label: block_c8aS9_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aS9: // global
           _s8abM::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8aSj; else goto c8aSz;
       c8aSj: // global
           I64[Sp + 24] = block_c8aSg_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aT5; else goto c8aSk;
       u8aT5: // global
           call _c8aSg(R1) args: 0, res: 0, upd: 0;
       c8aSk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aSz: // global
           I64[Sp + 24] = block_c8aSx_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8aT6; else goto c8aSA;
       u8aT6: // global
           call _c8aSx() args: 0, res: 0, upd: 0;
       c8aSA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aSg() //  [R1]
         { info_tbl: [(c8aSg,
                       label: block_c8aSg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aSg: // global
           if (R1 & 7 == 1) goto u8aSN; else goto u8aSO;
       u8aSN: // global
           Sp = Sp + 8;
           call _c8aSq() args: 0, res: 0, upd: 0;
       u8aSO: // global
           Sp = Sp + 16;
           call _c8aSu() args: 0, res: 0, upd: 0;
     }
 },
 _c8aSq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aSq: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aSu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aSu: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8aSx() //  []
         { info_tbl: [(c8aSx,
                       label: block_c8aSx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aSx: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.680266673 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqNewlineMode_closure+1;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.681159863 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode13_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode13_bytes:
         I8[] [78,111,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.682172166 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode12_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode12_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode12_entry() //  [R1]
         { info_tbl: [(c8aTf,
                       label: GHC.IO.Handle.Types.$fReadBufferMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aTf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aTg; else goto c8aTh;
       c8aTg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aTh: // global
           (_c8aTc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8aTc::I64 == 0) goto c8aTe; else goto c8aTd;
       c8aTe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aTd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8aTc::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.683497639 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode6_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode6_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode6_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode6_entry() //  [R2]
         { info_tbl: [(c8aTm,
                       label: GHC.IO.Handle.Types.$fShowBufferMode6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aTm: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode12_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.684606341 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode9_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode9_bytes:
         I8[] [76,105,110,101,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.685733108 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode8_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode8_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode8_entry() //  [R1]
         { info_tbl: [(c8aTv,
                       label: GHC.IO.Handle.Types.$fReadBufferMode8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aTv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aTw; else goto c8aTx;
       c8aTw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aTx: // global
           (_c8aTs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8aTs::I64 == 0) goto c8aTu; else goto c8aTt;
       c8aTu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aTt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8aTs::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.687005976 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode5_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode5_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode5_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode5_entry() //  [R2]
         { info_tbl: [(c8aTC,
                       label: GHC.IO.Handle.Types.$fShowBufferMode5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aTC: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode8_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.688032312 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowBufferMode4_bytes" {
     GHC.IO.Handle.Types.$fShowBufferMode4_bytes:
         I8[] [66,108,111,99,107,66,117,102,102,101,114,105,110,103,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.688992361 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode3_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode3_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode3_entry() //  [R1]
         { info_tbl: [(c8aTL,
                       label: GHC.IO.Handle.Types.$fShowBufferMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aTL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aTM; else goto c8aTN;
       c8aTM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aTN: // global
           (_c8aTI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8aTI::I64 == 0) goto c8aTK; else goto c8aTJ;
       c8aTK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aTJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8aTI::I64;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.692138845 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_info;
         const 0;
 },
 g_s8ac2_entry() //  [R1]
         { info_tbl: [(c8aU8,
                       label: g_s8ac2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aU8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aU9; else goto c8aUa;
       c8aU9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aUa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 16];
           R3 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R2 = GHC.Show.$fShowInt_closure;
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ac5_entry() //  [R1]
         { info_tbl: [(c8aUn,
                       label: sat_s8ac5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aUn: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ac6_entry() //  [R1, R2]
         { info_tbl: [(c8aUq,
                       label: sat_s8ac6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aUq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8aUu; else goto c8aUt;
       c8aUu: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aUt: // global
           _s8ac2::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s8ac5_info;
           P64[Hp - 8] = _s8ac2::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ac9_entry() //  [R1]
         { info_tbl: [(c8aUK,
                       label: sat_s8ac9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aUK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8aUO; else goto c8aUN;
       c8aUO: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aUN: // global
           _s8ac2::P64 = P64[R1 + 16];
           _s8ac7::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s8ac7::P64;
           R2 = Hp - 14;
           R1 = _s8ac2::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8aca_entry() //  [R1]
         { info_tbl: [(c8aUP,
                       label: sat_s8aca_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aUP: // global
           _s8aca::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8aUQ; else goto c8aUR;
       c8aUR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8aUT; else goto c8aUS;
       c8aUT: // global
           HpAlloc = 32;
           goto c8aUQ;
       c8aUQ: // global
           R1 = _s8aca::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aUS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8aca::P64;
           _s8ac2::P64 = P64[_s8aca::P64 + 16];
           _s8ac7::P64 = P64[_s8aca::P64 + 24];
           I64[Hp - 24] = sat_s8ac9_info;
           P64[Hp - 8] = _s8ac2::P64;
           P64[Hp] = _s8ac7::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8acb_entry() //  [R1, R2]
         { info_tbl: [(c8aUV,
                       label: sat_s8acb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aUV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8aUZ; else goto c8aUY;
       c8aUZ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aUY: // global
           _s8ac2::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s8aca_info;
           P64[Hp - 32] = _s8ac2::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8aV5,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aV5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aV6; else goto c8aV7;
       c8aV6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aV7: // global
           I64[Sp - 16] = block_c8aTS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8aVl; else goto c8aTT;
       u8aVl: // global
           call _c8aTS(R1) args: 0, res: 0, upd: 0;
       c8aTT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aTS() //  [R1]
         { info_tbl: [(c8aTS,
                       label: block_c8aTS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aTS: // global
           _c8aV4::P64 = R1 & 7;
           if (_c8aV4::P64 < 3) goto u8aVj; else goto c8aV3;
       u8aVj: // global
           if (_c8aV4::P64 < 2) goto c8aV1; else goto c8aV2;
       c8aV1: // global
           R1 = GHC.IO.Handle.Types.$fShowBufferMode6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8aV2: // global
           R1 = GHC.IO.Handle.Types.$fShowBufferMode5_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8aV3: // global
           I64[Sp] = block_c8aTZ_info;
           _s8abZ::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8abZ::P64;
           if (R1 & 7 != 0) goto u8aVk; else goto c8aU0;
       u8aVk: // global
           call _c8aTZ(R1) args: 0, res: 0, upd: 0;
       c8aU0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aTZ() //  [R1]
         { info_tbl: [(c8aTZ,
                       label: block_c8aTZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aTZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8aVf; else goto c8aVe;
       c8aVf: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8aVe: // global
           _s8ac1::I64 = I64[R1 + 7];
           I64[Hp - 32] = g_s8ac2_info;
           P64[Hp - 16] = P64[Sp + 8];
           _c8aU4::P64 = Hp - 32;
           if (%MO_S_Lt_W64(_s8ac1::I64, 11)) goto c8aVh; else goto c8aVi;
       c8aVh: // global
           I64[Hp - 8] = sat_s8ac6_info;
           P64[Hp] = _c8aU4::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8aVi: // global
           I64[Hp - 8] = sat_s8acb_info;
           P64[Hp] = _c8aU4::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.696770065 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode7_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode7_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.698993216 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_info;
         const 0;
 },
 sat_s8acm_entry() //  [R1]
         { info_tbl: [(c8aVS,
                       label: sat_s8acm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aVS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8aVY; else goto c8aVZ;
       c8aVY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aVZ: // global
           I64[Sp - 8] = block_c8aVP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aW4; else goto c8aVQ;
       u8aW4: // global
           call _c8aVP(R1) args: 0, res: 0, upd: 0;
       c8aVQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aVP() //  [R1]
         { info_tbl: [(c8aVP,
                       label: block_c8aVP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aVP: // global
           I64[Sp] = block_c8aVV_info;
           R4 = GHC.IO.Handle.Types.$fShowBufferMode7_closure+2;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8aVV() //  [R1, R2]
         { info_tbl: [(c8aVV,
                       label: block_c8aVV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aVV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8aW3; else goto c8aW2;
       c8aW3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8aW2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8acn_entry() //  [R1]
         { info_tbl: [(c8aW5,
                       label: sat_s8acn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aW5: // global
           _s8acn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8aW6; else goto c8aW7;
       c8aW7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8aW9; else goto c8aW8;
       c8aW9: // global
           HpAlloc = 24;
           goto c8aW6;
       c8aW6: // global
           R1 = _s8acn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aW8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8acn::P64;
           _s8acg::P64 = P64[_s8acn::P64 + 16];
           I64[Hp - 16] = sat_s8acm_info;
           P64[Hp] = _s8acg::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8aco_entry() //  [R1]
         { info_tbl: [(c8aWe,
                       label: sat_s8aco_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aWe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8aWf; else goto c8aWg;
       c8aWf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aWg: // global
           I64[Sp - 8] = block_c8aVB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aWn; else goto c8aVC;
       u8aWn: // global
           call _c8aVB(R1) args: 0, res: 0, upd: 0;
       c8aVC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aVB() //  [R1]
         { info_tbl: [(c8aVB,
                       label: block_c8aVB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aVB: // global
           if (R1 & 7 == 1) goto c8aWb; else goto c8aWc;
       c8aWb: // global
           R1 = GHC.Show.$fShowMaybe4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8aWc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8aWm; else goto c8aWl;
       c8aWm: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8aWl: // global
           _s8acg::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_s8acn_info;
           P64[Hp - 24] = _s8acg::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8aWt,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aWt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8aWu; else goto c8aWv;
       c8aWu: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aWv: // global
           I64[Sp - 8] = block_c8aVq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8aWE; else goto c8aVr;
       u8aWE: // global
           call _c8aVq(R1) args: 0, res: 0, upd: 0;
       c8aVr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aVq() //  [R1]
         { info_tbl: [(c8aVq,
                       label: block_c8aVq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aVq: // global
           _c8aWs::P64 = R1 & 7;
           if (_c8aWs::P64 < 3) goto u8aWD; else goto c8aWr;
       u8aWD: // global
           if (_c8aWs::P64 < 2) goto c8aWp; else goto c8aWq;
       c8aWp: // global
           R1 = GHC.IO.Handle.Types.$fReadBufferMode12_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8aWq: // global
           R1 = GHC.IO.Handle.Types.$fReadBufferMode8_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8aWr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8aWC; else goto c8aWB;
       c8aWC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8aWB: // global
           _s8ace::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_s8aco_info;
           P64[Hp] = _s8ace::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.703045009 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode1_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode1_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode1_entry() //  [R2]
         { info_tbl: [(c8aWJ,
                       label: GHC.IO.Handle.Types.$fShowBufferMode1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aWJ: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode2_closure+1;
           call GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.704288454 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8aWQ,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aWQ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.705443267 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure+2;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.706595265 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode11_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode11_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode11_info;
 },
 GHC.IO.Handle.Types.$fReadBufferMode11_entry() //  [R3]
         { info_tbl: [(c8aWX,
                       label: GHC.IO.Handle.Types.$fReadBufferMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aWX: // global
           R2 = GHC.IO.Handle.Types.NoBuffering_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.707585853 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode10_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode10_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode12_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.70857846 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode7_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode7_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode7_info;
 },
 GHC.IO.Handle.Types.$fReadBufferMode7_entry() //  [R3]
         { info_tbl: [(c8aX4,
                       label: GHC.IO.Handle.Types.$fReadBufferMode7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aX4: // global
           R2 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.709639358 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode6_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode6_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode8_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.713075736 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode5_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode5_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.714009321 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_sps_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_sps_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode10_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.714769069 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode4_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode4_bytes:
         I8[] [66,108,111,99,107,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.715689681 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode3_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode3_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode3_entry() //  [R1]
         { info_tbl: [(c8aXd,
                       label: GHC.IO.Handle.Types.$fReadBufferMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aXd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aXe; else goto c8aXf;
       c8aXe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aXf: // global
           (_c8aXa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8aXa::I64 == 0) goto c8aXc; else goto c8aXb;
       c8aXc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aXb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8aXa::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.716780794 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.718942323 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode2_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode2_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode2_info;
         const 0;
 },
 ds2_s8acw_entry() //  [R1]
         { info_tbl: [(c8aXo,
                       label: ds2_s8acw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aXo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aXp; else goto c8aXq;
       c8aXp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aXq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadBufferMode_sps_closure+2;
           Sp = Sp - 16;
           call GHC.Read.choose2_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8acF_entry() //  [R1, R2]
         { info_tbl: [(c8aXU,
                       label: sat_s8acF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aXU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8aXY; else goto c8aXX;
       c8aXY: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aXX: // global
           _s8acx::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.IO.Handle.Types.BlockBuffering_con_info;
           P64[Hp] = R2;
           R2 = Hp - 5;
           R1 = _s8acx::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8acG_entry() //  [R1, R2]
         { info_tbl: [(c8aXZ,
                       label: sat_s8acG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aXZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8aY3; else goto c8aY2;
       c8aY3: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aY2: // global
           _s8acx::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8acF_info;
           P64[Hp] = _s8acx::P64;
           R4 = Hp - 7;
           R3 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R2 = GHC.Read.$fReadInt_closure;
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8acJ_entry() //  [R1]
         { info_tbl: [(c8aY4,
                       label: sat_s8acJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aY4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8aY5; else goto c8aY6;
       c8aY5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aY6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8aXA_info;
           _s8acx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8acx::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8aYj; else goto c8aXB;
       u8aYj: // global
           call _c8aXA(R1) args: 0, res: 0, upd: 0;
       c8aXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8aXA() //  [R1]
         { info_tbl: [(c8aXA,
                       label: block_c8aXA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aXA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8aY9; else goto c8aY8;
       c8aY9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8aY8: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto c8aYb; else goto c8aYf;
       c8aYb: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8aYf: // global
           I64[Hp - 8] = sat_s8acG_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8aYc_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8aYc() //  [R1]
         { info_tbl: [(c8aYc,
                       label: block_c8aYc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aYc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8aYi; else goto c8aYh;
       c8aYi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8aYh: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8acK_entry() //  [R1, R2]
         { info_tbl: [(c8aYm,
                       label: sat_s8acK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aYm: // global
           _s8acx::P64 = R2;
           _s8acK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8aYn; else goto c8aYo;
       c8aYo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8aYq; else goto c8aYp;
       c8aYq: // global
           HpAlloc = 32;
           goto c8aYn;
       c8aYn: // global
           R2 = _s8acx::P64;
           R1 = _s8acK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aYp: // global
           _s8acv::P64 = P64[_s8acK::P64 + 7];
           _s8acw::P64 = P64[_s8acK::P64 + 15];
           I64[Hp - 24] = sat_s8acJ_info;
           P64[Hp - 8] = _s8acv::P64;
           P64[Hp] = _s8acx::P64;
           I64[Sp - 16] = block_c8aYk_info;
           R2 = _s8acx::P64;
           R1 = _s8acw::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aYk() //  [R1]
         { info_tbl: [(c8aYk,
                       label: block_c8aYk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aYk: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u8aYz_srtd" {
     u8aYz_srtd:
         const S8alj_srt+216;
         const 33;
         const 8522825729;
 },
 GHC.IO.Handle.Types.$fReadBufferMode2_entry() //  [R2]
         { info_tbl: [(c8aYu,
                       label: GHC.IO.Handle.Types.$fReadBufferMode2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aYu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8aYy; else goto c8aYx;
       c8aYy: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aYx: // global
           I64[Hp - 40] = ds2_s8acw_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8acK_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.722472403 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode1_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode1_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode1_info;
         const 0;
 },
 section ""relreadonly" . u8aYH_srtd" {
     u8aYH_srtd:
         const S8alj_srt+160;
         const 40;
         const 549755813889;
 },
 GHC.IO.Handle.Types.$fReadBufferMode1_entry() //  [R2, R3]
         { info_tbl: [(c8aYE,
                       label: GHC.IO.Handle.Types.$fReadBufferMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aYE: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.723637332 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_info;
         const 0;
 },
 section ""relreadonly" . u8aYY_srtd" {
     u8aYY_srtd:
         const S8alj_srt+160;
         const 40;
         const 549755813889;
 },
 sat_s8acM_entry() //  [R1]
         { info_tbl: [(c8aYQ,
                       label: sat_s8acM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aYQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aYR; else goto c8aYS;
       c8aYR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aYS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadBufferMode2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u8aYZ_srtd" {
     u8aYZ_srtd:
         const S8alj_srt+160;
         const 41;
         const 1649267441665;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8aYT,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aYT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8aYX; else goto c8aYW;
       c8aYX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8aYW: // global
           I64[Hp - 16] = sat_s8acM_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.725184523 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8aZ6,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aZ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aZ7; else goto c8aZ8;
       c8aZ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aZ8: // global
           (_c8aZ3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8aZ3::I64 == 0) goto c8aZ5; else goto c8aZ4;
       c8aZ5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aZ4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8aZ3::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.726699048 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode14_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode14_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode14_entry() //  [R1]
         { info_tbl: [(c8aZf,
                       label: GHC.IO.Handle.Types.$fReadBufferMode14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aZf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aZg; else goto c8aZh;
       c8aZg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8aZh: // global
           (_c8aZc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8aZc::I64 == 0) goto c8aZe; else goto c8aZd;
       c8aZe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8aZd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8aZc::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.727985275 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadList_entry() //  [R2]
         { info_tbl: [(c8aZm,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aZm: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode14_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.728832067 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode1_closure+2;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.730770392 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8aZB,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aZB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8aZC; else goto c8aZD;
       c8aZC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8aZD: // global
           I64[Sp - 16] = block_c8aZt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8b1f; else goto c8aZu;
       u8b1f: // global
           call _c8aZt(R1) args: 0, res: 0, upd: 0;
       c8aZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aZt() //  [R1]
         { info_tbl: [(c8aZt,
                       label: block_c8aZt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aZt: // global
           _s8acO::P64 = P64[Sp + 8];
           _c8aZA::P64 = R1 & 7;
           if (_c8aZA::P64 < 3) goto u8b13; else goto c8aZz;
       u8b13: // global
           if (_c8aZA::P64 < 2) goto c8aZx; else goto c8aZy;
       c8aZx: // global
           I64[Sp + 8] = block_c8aZG_info;
           R1 = _s8acO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b1c; else goto c8aZI;
       u8b1c: // global
           call _c8aZG(R1) args: 0, res: 0, upd: 0;
       c8aZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aZy: // global
           I64[Sp + 8] = block_c8aZV_info;
           R1 = _s8acO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b1d; else goto c8aZX;
       u8b1d: // global
           call _c8aZV(R1) args: 0, res: 0, upd: 0;
       c8aZX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8aZz: // global
           I64[Sp] = block_c8b0a_info;
           _s8acT::P64 = P64[R1 + 5];
           R1 = _s8acO::P64;
           P64[Sp + 8] = _s8acT::P64;
           if (R1 & 7 != 0) goto u8b1e; else goto c8b0c;
       u8b1e: // global
           call _c8b0a(R1) args: 0, res: 0, upd: 0;
       c8b0c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8aZG() //  [R1]
         { info_tbl: [(c8aZG,
                       label: block_c8aZG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aZG: // global
           if (R1 & 7 == 1) goto u8b14; else goto u8b15;
       u8b14: // global
           Sp = Sp + 8;
           call _c8b0S() args: 0, res: 0, upd: 0;
       u8b15: // global
           Sp = Sp + 8;
           call _c8b0G() args: 0, res: 0, upd: 0;
     }
 },
 _c8aZV() //  [R1]
         { info_tbl: [(c8aZV,
                       label: block_c8aZV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8aZV: // global
           if (R1 & 7 == 3) goto u8b16; else goto u8b17;
       u8b16: // global
           Sp = Sp + 8;
           call _c8b0G() args: 0, res: 0, upd: 0;
       u8b17: // global
           Sp = Sp + 8;
           call _c8b0S() args: 0, res: 0, upd: 0;
     }
 },
 _c8b0a() //  [R1]
         { info_tbl: [(c8b0a,
                       label: block_c8b0a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b0a: // global
           if (R1 & 7 == 3) goto c8b0n; else goto u8b18;
       c8b0n: // global
           I64[Sp] = block_c8b0l_info;
           _s8acV::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8acV::P64;
           if (R1 & 7 != 0) goto u8b1k; else goto c8b0o;
       u8b1k: // global
           call _c8b0l(R1) args: 0, res: 0, upd: 0;
       c8b0o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8b18: // global
           Sp = Sp + 16;
           call _c8b0S() args: 0, res: 0, upd: 0;
     }
 },
 _c8b0l() //  [R1]
         { info_tbl: [(c8b0l,
                       label: block_c8b0l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b0l: // global
           _s8acV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8b0v; else goto c8b0L;
       c8b0v: // global
           I64[Sp + 8] = block_c8b0s_info;
           R1 = _s8acV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b1m; else goto c8b0w;
       u8b1m: // global
           call _c8b0s(R1) args: 0, res: 0, upd: 0;
       c8b0w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b0L: // global
           I64[Sp] = block_c8b0J_info;
           _s8acZ::P64 = P64[R1 + 6];
           R1 = _s8acV::P64;
           P64[Sp + 8] = _s8acZ::P64;
           if (R1 & 7 != 0) goto u8b1n; else goto c8b0M;
       u8b1n: // global
           call _c8b0J(R1) args: 0, res: 0, upd: 0;
       c8b0M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b0s() //  [R1]
         { info_tbl: [(c8b0s,
                       label: block_c8b0s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b0s: // global
           if (R1 & 7 == 1) goto u8b1a; else goto u8b1b;
       u8b1a: // global
           Sp = Sp + 8;
           call _c8b0S() args: 0, res: 0, upd: 0;
       u8b1b: // global
           Sp = Sp + 8;
           call _c8b0G() args: 0, res: 0, upd: 0;
     }
 },
 _c8b0G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b0G: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8b0J() //  [R1]
         { info_tbl: [(c8b0J,
                       label: block_c8b0J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b0J: // global
           if (R1 & 7 == 1) goto u8b19; else goto c8b0W;
       u8b19: // global
           Sp = Sp + 16;
           call _c8b0S() args: 0, res: 0, upd: 0;
       c8b0W: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.ltInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8b0S() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b0S: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.73508166 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8b1D,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b1D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8b1E; else goto c8b1F;
       c8b1E: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8b1F: // global
           I64[Sp - 16] = block_c8b1v_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8b3n; else goto c8b1w;
       u8b3n: // global
           call _c8b1v(R1) args: 0, res: 0, upd: 0;
       c8b1w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b1v() //  [R1]
         { info_tbl: [(c8b1v,
                       label: block_c8b1v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b1v: // global
           _s8ad3::P64 = P64[Sp + 8];
           _c8b1C::P64 = R1 & 7;
           if (_c8b1C::P64 < 3) goto u8b39; else goto c8b1B;
       u8b39: // global
           if (_c8b1C::P64 < 2) goto c8b1z; else goto c8b1A;
       c8b1z: // global
           I64[Sp + 8] = block_c8b1I_info;
           R1 = _s8ad3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b3k; else goto c8b1K;
       u8b3k: // global
           call _c8b1I(R1) args: 0, res: 0, upd: 0;
       c8b1K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b1A: // global
           I64[Sp + 8] = block_c8b1X_info;
           R1 = _s8ad3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b3l; else goto c8b1Z;
       u8b3l: // global
           call _c8b1X(R1) args: 0, res: 0, upd: 0;
       c8b1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b1B: // global
           I64[Sp] = block_c8b2g_info;
           _s8ad8::P64 = P64[R1 + 5];
           R1 = _s8ad3::P64;
           P64[Sp + 8] = _s8ad8::P64;
           if (R1 & 7 != 0) goto u8b3m; else goto c8b2i;
       u8b3m: // global
           call _c8b2g(R1) args: 0, res: 0, upd: 0;
       c8b2i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b1I() //  [R1]
         { info_tbl: [(c8b1I,
                       label: block_c8b1I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b1I: // global
           if (R1 & 7 == 1) goto u8b3b; else goto u8b3c;
       u8b3b: // global
           Sp = Sp + 8;
           call _c8b2I() args: 0, res: 0, upd: 0;
       u8b3c: // global
           Sp = Sp + 8;
           call _c8b2M() args: 0, res: 0, upd: 0;
     }
 },
 _c8b1X() //  [R1]
         { info_tbl: [(c8b1X,
                       label: block_c8b1X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b1X: // global
           _c8b37::P64 = R1 & 7;
           if (_c8b37::P64 < 3) goto u8b3a; else goto u8b3d;
       u8b3a: // global
           if (_c8b37::P64 < 2) goto u8b3f; else goto u8b3e;
       u8b3f: // global
           Sp = Sp + 8;
           call _c8b2Y() args: 0, res: 0, upd: 0;
       u8b3e: // global
           Sp = Sp + 8;
           call _c8b2I() args: 0, res: 0, upd: 0;
       u8b3d: // global
           Sp = Sp + 8;
           call _c8b2M() args: 0, res: 0, upd: 0;
     }
 },
 _c8b2g() //  [R1]
         { info_tbl: [(c8b2g,
                       label: block_c8b2g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b2g: // global
           if (R1 & 7 == 3) goto c8b2t; else goto u8b3g;
       c8b2t: // global
           I64[Sp] = block_c8b2r_info;
           _s8ada::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ada::P64;
           if (R1 & 7 != 0) goto u8b3t; else goto c8b2u;
       u8b3t: // global
           call _c8b2r(R1) args: 0, res: 0, upd: 0;
       c8b2u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8b3g: // global
           Sp = Sp + 16;
           call _c8b2Y() args: 0, res: 0, upd: 0;
     }
 },
 _c8b2r() //  [R1]
         { info_tbl: [(c8b2r,
                       label: block_c8b2r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b2r: // global
           _s8ada::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8b2B; else goto c8b2R;
       c8b2B: // global
           I64[Sp + 8] = block_c8b2y_info;
           R1 = _s8ada::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b3v; else goto c8b2C;
       u8b3v: // global
           call _c8b2y(R1) args: 0, res: 0, upd: 0;
       c8b2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b2R: // global
           I64[Sp] = block_c8b2P_info;
           _s8ade::P64 = P64[R1 + 6];
           R1 = _s8ada::P64;
           P64[Sp + 8] = _s8ade::P64;
           if (R1 & 7 != 0) goto u8b3w; else goto c8b2S;
       u8b3w: // global
           call _c8b2P(R1) args: 0, res: 0, upd: 0;
       c8b2S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b2y() //  [R1]
         { info_tbl: [(c8b2y,
                       label: block_c8b2y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b2y: // global
           if (R1 & 7 == 1) goto u8b3i; else goto u8b3j;
       u8b3i: // global
           Sp = Sp + 8;
           call _c8b2I() args: 0, res: 0, upd: 0;
       u8b3j: // global
           Sp = Sp + 8;
           call _c8b2M() args: 0, res: 0, upd: 0;
     }
 },
 _c8b2I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b2I: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8b2M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b2M: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8b2P() //  [R1]
         { info_tbl: [(c8b2P,
                       label: block_c8b2P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b2P: // global
           if (R1 & 7 == 1) goto u8b3h; else goto c8b32;
       u8b3h: // global
           Sp = Sp + 16;
           call _c8b2Y() args: 0, res: 0, upd: 0;
       c8b32: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.compareInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8b2Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b2Y: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.739740397 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure:
         const GHC.IO.Handle.Types.$fEqBufferMode_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqBufferMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8b3M,
                       label: GHC.IO.Handle.Types.$fEqBufferMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b3M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8b3N; else goto c8b3O;
       c8b3N: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8b3O: // global
           I64[Sp - 16] = block_c8b3E_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8b5q; else goto c8b3F;
       u8b5q: // global
           call _c8b3E(R1) args: 0, res: 0, upd: 0;
       c8b3F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b3E() //  [R1]
         { info_tbl: [(c8b3E,
                       label: block_c8b3E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b3E: // global
           _s8adi::P64 = P64[Sp + 8];
           _c8b3L::P64 = R1 & 7;
           if (_c8b3L::P64 < 3) goto u8b5e; else goto c8b3K;
       u8b5e: // global
           if (_c8b3L::P64 < 2) goto c8b3I; else goto c8b3J;
       c8b3I: // global
           I64[Sp + 8] = block_c8b3R_info;
           R1 = _s8adi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b5n; else goto c8b3T;
       u8b5n: // global
           call _c8b3R(R1) args: 0, res: 0, upd: 0;
       c8b3T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b3J: // global
           I64[Sp + 8] = block_c8b46_info;
           R1 = _s8adi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b5o; else goto c8b48;
       u8b5o: // global
           call _c8b46(R1) args: 0, res: 0, upd: 0;
       c8b48: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b3K: // global
           I64[Sp] = block_c8b4l_info;
           _s8adm::P64 = P64[R1 + 5];
           R1 = _s8adi::P64;
           P64[Sp + 8] = _s8adm::P64;
           if (R1 & 7 != 0) goto u8b5p; else goto c8b4n;
       u8b5p: // global
           call _c8b4l(R1) args: 0, res: 0, upd: 0;
       c8b4n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b3R() //  [R1]
         { info_tbl: [(c8b3R,
                       label: block_c8b3R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b3R: // global
           if (R1 & 7 == 1) goto u8b5f; else goto u8b5g;
       u8b5f: // global
           Sp = Sp + 8;
           call _c8b4N() args: 0, res: 0, upd: 0;
       u8b5g: // global
           Sp = Sp + 8;
           call _c8b53() args: 0, res: 0, upd: 0;
     }
 },
 _c8b46() //  [R1]
         { info_tbl: [(c8b46,
                       label: block_c8b46_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b46: // global
           if (R1 & 7 == 2) goto u8b5h; else goto u8b5i;
       u8b5h: // global
           Sp = Sp + 8;
           call _c8b4N() args: 0, res: 0, upd: 0;
       u8b5i: // global
           Sp = Sp + 8;
           call _c8b53() args: 0, res: 0, upd: 0;
     }
 },
 _c8b4l() //  [R1]
         { info_tbl: [(c8b4l,
                       label: block_c8b4l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b4l: // global
           if (R1 & 7 == 3) goto c8b4y; else goto u8b5j;
       c8b4y: // global
           I64[Sp] = block_c8b4w_info;
           _s8ado::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ado::P64;
           if (R1 & 7 != 0) goto u8b5v; else goto c8b4z;
       u8b5v: // global
           call _c8b4w(R1) args: 0, res: 0, upd: 0;
       c8b4z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8b5j: // global
           Sp = Sp + 16;
           call _c8b53() args: 0, res: 0, upd: 0;
     }
 },
 _c8b4w() //  [R1]
         { info_tbl: [(c8b4w,
                       label: block_c8b4w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b4w: // global
           _s8ado::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8b4G; else goto c8b4W;
       c8b4G: // global
           I64[Sp + 8] = block_c8b4D_info;
           R1 = _s8ado::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b5x; else goto c8b4H;
       u8b5x: // global
           call _c8b4D(R1) args: 0, res: 0, upd: 0;
       c8b4H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b4W: // global
           I64[Sp] = block_c8b4U_info;
           _s8ads::P64 = P64[R1 + 6];
           R1 = _s8ado::P64;
           P64[Sp + 8] = _s8ads::P64;
           if (R1 & 7 != 0) goto u8b5y; else goto c8b4X;
       u8b5y: // global
           call _c8b4U(R1) args: 0, res: 0, upd: 0;
       c8b4X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b4D() //  [R1]
         { info_tbl: [(c8b4D,
                       label: block_c8b4D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b4D: // global
           if (R1 & 7 == 1) goto u8b5l; else goto u8b5m;
       u8b5l: // global
           Sp = Sp + 8;
           call _c8b4N() args: 0, res: 0, upd: 0;
       u8b5m: // global
           Sp = Sp + 8;
           call _c8b53() args: 0, res: 0, upd: 0;
     }
 },
 _c8b4N() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b4N: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8b4U() //  [R1]
         { info_tbl: [(c8b4U,
                       label: block_c8b4U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b4U: // global
           if (R1 & 7 == 1) goto u8b5k; else goto c8b57;
       u8b5k: // global
           Sp = Sp + 16;
           call _c8b53() args: 0, res: 0, upd: 0;
       c8b57: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.eqInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8b53() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b53: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.744155084 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqBufferMode_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqBufferMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8b5O,
                       label: GHC.IO.Handle.Types.$fEqBufferMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b5O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8b5P; else goto c8b5Q;
       c8b5P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8b5Q: // global
           I64[Sp - 16] = block_c8b5G_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8b7L; else goto c8b5H;
       u8b7L: // global
           call _c8b5G(R1) args: 0, res: 0, upd: 0;
       c8b5H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b5G() //  [R1]
         { info_tbl: [(c8b5G,
                       label: block_c8b5G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b5G: // global
           _s8adw::P64 = P64[Sp + 8];
           _c8b5N::P64 = R1 & 7;
           if (_c8b5N::P64 < 3) goto u8b7x; else goto c8b5M;
       u8b7x: // global
           if (_c8b5N::P64 < 2) goto c8b5K; else goto c8b5L;
       c8b5K: // global
           I64[Sp + 8] = block_c8b5T_info;
           R1 = _s8adw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b7I; else goto c8b5V;
       u8b7I: // global
           call _c8b5T(R1) args: 0, res: 0, upd: 0;
       c8b5V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b5L: // global
           I64[Sp + 8] = block_c8b68_info;
           R1 = _s8adw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b7J; else goto c8b6a;
       u8b7J: // global
           call _c8b68(R1) args: 0, res: 0, upd: 0;
       c8b6a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b5M: // global
           I64[Sp] = block_c8b6n_info;
           _s8adA::P64 = P64[R1 + 5];
           R1 = _s8adw::P64;
           P64[Sp + 8] = _s8adA::P64;
           if (R1 & 7 != 0) goto u8b7K; else goto c8b6p;
       u8b7K: // global
           call _c8b6n(R1) args: 0, res: 0, upd: 0;
       c8b6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b5T() //  [R1]
         { info_tbl: [(c8b5T,
                       label: block_c8b5T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b5T: // global
           if (R1 & 7 == 1) goto u8b7y; else goto u8b7z;
       u8b7y: // global
           Sp = Sp + 8;
           call _c8b7q() args: 0, res: 0, upd: 0;
       u8b7z: // global
           Sp = Sp + 8;
           call _c8b7p() args: 0, res: 0, upd: 0;
     }
 },
 _c8b68() //  [R1]
         { info_tbl: [(c8b68,
                       label: block_c8b68_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b68: // global
           if (R1 & 7 == 2) goto u8b7A; else goto u8b7B;
       u8b7A: // global
           Sp = Sp + 8;
           call _c8b7q() args: 0, res: 0, upd: 0;
       u8b7B: // global
           Sp = Sp + 8;
           call _c8b7p() args: 0, res: 0, upd: 0;
     }
 },
 _c8b6n() //  [R1]
         { info_tbl: [(c8b6n,
                       label: block_c8b6n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b6n: // global
           if (R1 & 7 == 3) goto c8b6A; else goto u8b7C;
       c8b6A: // global
           I64[Sp] = block_c8b6y_info;
           _s8adC::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8adC::P64;
           if (R1 & 7 != 0) goto u8b7Q; else goto c8b6B;
       u8b7Q: // global
           call _c8b6y(R1) args: 0, res: 0, upd: 0;
       c8b6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8b7C: // global
           Sp = Sp + 16;
           call _c8b7p() args: 0, res: 0, upd: 0;
     }
 },
 _c8b6y() //  [R1]
         { info_tbl: [(c8b6y,
                       label: block_c8b6y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b6y: // global
           _s8adC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8b6I; else goto c8b6Y;
       c8b6I: // global
           I64[Sp + 8] = block_c8b6F_info;
           R1 = _s8adC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8b7S; else goto c8b6J;
       u8b7S: // global
           call _c8b6F(R1) args: 0, res: 0, upd: 0;
       c8b6J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b6Y: // global
           I64[Sp] = block_c8b6W_info;
           _s8adG::P64 = P64[R1 + 6];
           R1 = _s8adC::P64;
           P64[Sp + 8] = _s8adG::P64;
           if (R1 & 7 != 0) goto u8b7T; else goto c8b6Z;
       u8b7T: // global
           call _c8b6W(R1) args: 0, res: 0, upd: 0;
       c8b6Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b6F() //  [R1]
         { info_tbl: [(c8b6F,
                       label: block_c8b6F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b6F: // global
           if (R1 & 7 == 1) goto u8b7G; else goto u8b7H;
       u8b7G: // global
           Sp = Sp + 8;
           call _c8b7q() args: 0, res: 0, upd: 0;
       u8b7H: // global
           Sp = Sp + 8;
           call _c8b7p() args: 0, res: 0, upd: 0;
     }
 },
 _c8b6W() //  [R1]
         { info_tbl: [(c8b6W,
                       label: block_c8b6W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b6W: // global
           if (R1 & 7 == 1) goto u8b7D; else goto c8b7f;
       u8b7D: // global
           Sp = Sp + 16;
           call _c8b7p() args: 0, res: 0, upd: 0;
       c8b7f: // global
           I64[Sp] = block_c8b78_info;
           _s8adI::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8adI::P64;
           if (R1 & 7 != 0) goto u8b7W; else goto c8b79;
       u8b7W: // global
           call _c8b78(R1) args: 0, res: 0, upd: 0;
       c8b79: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b78() //  [R1]
         { info_tbl: [(c8b78,
                       label: block_c8b78_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b78: // global
           I64[Sp] = block_c8b7d_info;
           _s8adK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8adK::I64;
           if (R1 & 7 != 0) goto u8b7Y; else goto c8b7h;
       u8b7Y: // global
           call _c8b7d(R1) args: 0, res: 0, upd: 0;
       c8b7h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b7d() //  [R1]
         { info_tbl: [(c8b7d,
                       label: block_c8b7d_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b7d: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u8b7E; else goto u8b7F;
       u8b7E: // global
           Sp = Sp + 16;
           call _c8b7q() args: 0, res: 0, upd: 0;
       u8b7F: // global
           Sp = Sp + 16;
           call _c8b7p() args: 0, res: 0, upd: 0;
     }
 },
 _c8b7q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b7q: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8b7p() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b7p: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.747811797 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.750129127 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8b8d,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b8d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8b8e; else goto c8b8f;
       c8b8e: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8b8f: // global
           I64[Sp - 16] = block_c8b85_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8baa; else goto c8b86;
       u8baa: // global
           call _c8b85(R1) args: 0, res: 0, upd: 0;
       c8b86: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b85() //  [R1]
         { info_tbl: [(c8b85,
                       label: block_c8b85_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b85: // global
           _s8adO::P64 = P64[Sp + 8];
           _c8b8c::P64 = R1 & 7;
           if (_c8b8c::P64 < 3) goto u8b9W; else goto c8b8b;
       u8b9W: // global
           if (_c8b8c::P64 < 2) goto c8b89; else goto c8b8a;
       c8b89: // global
           I64[Sp + 8] = block_c8b8i_info;
           R1 = _s8adO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ba7; else goto c8b8k;
       u8ba7: // global
           call _c8b8i(R1) args: 0, res: 0, upd: 0;
       c8b8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b8a: // global
           I64[Sp + 8] = block_c8b8x_info;
           R1 = _s8adO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ba8; else goto c8b8z;
       u8ba8: // global
           call _c8b8x(R1) args: 0, res: 0, upd: 0;
       c8b8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b8b: // global
           I64[Sp] = block_c8b8M_info;
           _s8adU::P64 = P64[R1 + 5];
           R1 = _s8adO::P64;
           P64[Sp + 8] = _s8adU::P64;
           if (R1 & 7 != 0) goto u8ba9; else goto c8b8O;
       u8ba9: // global
           call _c8b8M(R1) args: 0, res: 0, upd: 0;
       c8b8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b8i() //  [R1]
         { info_tbl: [(c8b8i,
                       label: block_c8b8i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b8i: // global
           if (R1 & 7 == 1) goto u8b9X; else goto u8b9Y;
       u8b9X: // global
           Sp = Sp + 8;
           call _c8b9O() args: 0, res: 0, upd: 0;
       u8b9Y: // global
           Sp = Sp + 8;
           call _c8b9P() args: 0, res: 0, upd: 0;
     }
 },
 _c8b8x() //  [R1]
         { info_tbl: [(c8b8x,
                       label: block_c8b8x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b8x: // global
           if (R1 & 7 == 3) goto u8b9Z; else goto u8ba0;
       u8b9Z: // global
           Sp = Sp + 8;
           call _c8b9P() args: 0, res: 0, upd: 0;
       u8ba0: // global
           Sp = Sp + 8;
           call _c8b9O() args: 0, res: 0, upd: 0;
     }
 },
 _c8b8M() //  [R1]
         { info_tbl: [(c8b8M,
                       label: block_c8b8M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b8M: // global
           if (R1 & 7 == 3) goto c8b8Z; else goto u8ba1;
       c8b8Z: // global
           I64[Sp] = block_c8b8X_info;
           _s8adW::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8adW::P64;
           if (R1 & 7 != 0) goto u8baf; else goto c8b90;
       u8baf: // global
           call _c8b8X(R1) args: 0, res: 0, upd: 0;
       c8b90: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8ba1: // global
           Sp = Sp + 16;
           call _c8b9O() args: 0, res: 0, upd: 0;
     }
 },
 _c8b8X() //  [R1]
         { info_tbl: [(c8b8X,
                       label: block_c8b8X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b8X: // global
           _s8adW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8b97; else goto c8b9n;
       c8b97: // global
           I64[Sp + 8] = block_c8b94_info;
           R1 = _s8adW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bah; else goto c8b98;
       u8bah: // global
           call _c8b94(R1) args: 0, res: 0, upd: 0;
       c8b98: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8b9n: // global
           I64[Sp] = block_c8b9l_info;
           _s8ae0::P64 = P64[R1 + 6];
           R1 = _s8adW::P64;
           P64[Sp + 8] = _s8ae0::P64;
           if (R1 & 7 != 0) goto u8bai; else goto c8b9o;
       u8bai: // global
           call _c8b9l(R1) args: 0, res: 0, upd: 0;
       c8b9o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b94() //  [R1]
         { info_tbl: [(c8b94,
                       label: block_c8b94_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b94: // global
           if (R1 & 7 == 1) goto u8ba5; else goto u8ba6;
       u8ba5: // global
           Sp = Sp + 8;
           call _c8b9O() args: 0, res: 0, upd: 0;
       u8ba6: // global
           Sp = Sp + 8;
           call _c8b9P() args: 0, res: 0, upd: 0;
     }
 },
 _c8b9l() //  [R1]
         { info_tbl: [(c8b9l,
                       label: block_c8b9l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b9l: // global
           if (R1 & 7 == 1) goto u8ba2; else goto c8b9E;
       u8ba2: // global
           Sp = Sp + 16;
           call _c8b9O() args: 0, res: 0, upd: 0;
       c8b9E: // global
           I64[Sp] = block_c8b9x_info;
           _s8ae2::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ae2::P64;
           if (R1 & 7 != 0) goto u8bal; else goto c8b9y;
       u8bal: // global
           call _c8b9x(R1) args: 0, res: 0, upd: 0;
       c8b9y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b9x() //  [R1]
         { info_tbl: [(c8b9x,
                       label: block_c8b9x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b9x: // global
           I64[Sp] = block_c8b9C_info;
           _s8ae4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ae4::I64;
           if (R1 & 7 != 0) goto u8ban; else goto c8b9G;
       u8ban: // global
           call _c8b9C(R1) args: 0, res: 0, upd: 0;
       c8b9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8b9C() //  [R1]
         { info_tbl: [(c8b9C,
                       label: block_c8b9C_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b9C: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8ba4; else goto u8ba3;
       u8ba4: // global
           Sp = Sp + 16;
           call _c8b9O() args: 0, res: 0, upd: 0;
       u8ba3: // global
           Sp = Sp + 16;
           call _c8b9P() args: 0, res: 0, upd: 0;
     }
 },
 _c8b9P() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b9P: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8b9O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8b9O: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.75534256 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8baC,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8baC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8baD; else goto c8baE;
       c8baD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8baE: // global
           I64[Sp - 16] = block_c8bau_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bch; else goto c8bav;
       u8bch: // global
           call _c8bau(R1) args: 0, res: 0, upd: 0;
       c8bav: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bau() //  [R1]
         { info_tbl: [(c8bau,
                       label: block_c8bau_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bau: // global
           _s8ae8::P64 = P64[Sp + 8];
           _c8baB::P64 = R1 & 7;
           if (_c8baB::P64 < 3) goto u8bc8; else goto c8baA;
       u8bc8: // global
           if (_c8baB::P64 < 2) goto c8bay; else goto c8baz;
       c8bay: // global
           R1 = _s8ae8::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8baz: // global
           I64[Sp + 8] = block_c8baK_info;
           R1 = _s8ae8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bcf; else goto c8baM;
       u8bcf: // global
           call _c8baK(R1) args: 0, res: 0, upd: 0;
       c8baM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8baA: // global
           I64[Sp - 8] = block_c8baZ_info;
           _s8aea::P64 = R1;
           _s8aed::P64 = P64[R1 + 5];
           R1 = _s8ae8::P64;
           P64[Sp] = _s8aed::P64;
           P64[Sp + 8] = _s8aea::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bcg; else goto c8bb1;
       u8bcg: // global
           call _c8baZ(R1) args: 0, res: 0, upd: 0;
       c8bb1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8baK() //  [R1]
         { info_tbl: [(c8baK,
                       label: block_c8baK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8baK: // global
           if (R1 & 7 == 3) goto c8baW; else goto c8baS;
       c8baW: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8baS: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8baZ() //  [R1]
         { info_tbl: [(c8baZ,
                       label: block_c8baZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8baZ: // global
           if (R1 & 7 == 3) goto c8bbc; else goto u8bc9;
       c8bbc: // global
           I64[Sp - 8] = block_c8bba_info;
           _s8aee::P64 = R1;
           _s8aef::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aef::P64;
           P64[Sp + 8] = _s8aee::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bci; else goto c8bbd;
       u8bci: // global
           call _c8bba(R1) args: 0, res: 0, upd: 0;
       c8bbd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8bc9: // global
           Sp = Sp + 16;
           call _c8bc1() args: 0, res: 0, upd: 0;
     }
 },
 _c8bba() //  [R1]
         { info_tbl: [(c8bba,
                       label: block_c8bba_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bba: // global
           _s8aef::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bbk; else goto c8bbA;
       c8bbk: // global
           I64[Sp + 8] = block_c8bbh_info;
           R1 = _s8aef::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bck; else goto c8bbl;
       u8bck: // global
           call _c8bbh(R1) args: 0, res: 0, upd: 0;
       c8bbl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bbA: // global
           I64[Sp] = block_c8bby_info;
           _s8aej::P64 = P64[R1 + 6];
           R1 = _s8aef::P64;
           P64[Sp + 8] = _s8aej::P64;
           if (R1 & 7 != 0) goto u8bcl; else goto c8bbB;
       u8bcl: // global
           call _c8bby(R1) args: 0, res: 0, upd: 0;
       c8bbB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bbh() //  [R1]
         { info_tbl: [(c8bbh,
                       label: block_c8bbh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bbh: // global
           if (R1 & 7 == 1) goto u8bcd; else goto u8bce;
       u8bcd: // global
           Sp = Sp + 16;
           call _c8bc1() args: 0, res: 0, upd: 0;
       u8bce: // global
           Sp = Sp + 8;
           call _c8bc2() args: 0, res: 0, upd: 0;
     }
 },
 _c8bby() //  [R1]
         { info_tbl: [(c8bby,
                       label: block_c8bby_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bby: // global
           if (R1 & 7 == 1) goto u8bca; else goto c8bbR;
       u8bca: // global
           Sp = Sp + 24;
           call _c8bc1() args: 0, res: 0, upd: 0;
       c8bbR: // global
           I64[Sp] = block_c8bbK_info;
           _s8ael::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ael::P64;
           if (R1 & 7 != 0) goto u8bco; else goto c8bbL;
       u8bco: // global
           call _c8bbK(R1) args: 0, res: 0, upd: 0;
       c8bbL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bbK() //  [R1]
         { info_tbl: [(c8bbK,
                       label: block_c8bbK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bbK: // global
           I64[Sp] = block_c8bbP_info;
           _s8aen::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8aen::I64;
           if (R1 & 7 != 0) goto u8bcq; else goto c8bbT;
       u8bcq: // global
           call _c8bbP(R1) args: 0, res: 0, upd: 0;
       c8bbT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bbP() //  [R1]
         { info_tbl: [(c8bbP,
                       label: block_c8bbP_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bbP: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8bcc; else goto u8bcb;
       u8bcc: // global
           Sp = Sp + 24;
           call _c8bc1() args: 0, res: 0, upd: 0;
       u8bcb: // global
           Sp = Sp + 16;
           call _c8bc2() args: 0, res: 0, upd: 0;
     }
 },
 _c8bc2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bc2: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bc1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bc1: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.75977609 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8bcF,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bcF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bcG; else goto c8bcH;
       c8bcG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bcH: // global
           I64[Sp - 16] = block_c8bcx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8beC; else goto c8bcy;
       u8beC: // global
           call _c8bcx(R1) args: 0, res: 0, upd: 0;
       c8bcy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bcx() //  [R1]
         { info_tbl: [(c8bcx,
                       label: block_c8bcx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bcx: // global
           _s8aes::P64 = P64[Sp + 8];
           _c8bcE::P64 = R1 & 7;
           if (_c8bcE::P64 < 3) goto u8beo; else goto c8bcD;
       u8beo: // global
           if (_c8bcE::P64 < 2) goto c8bcB; else goto c8bcC;
       c8bcB: // global
           I64[Sp + 8] = block_c8bcK_info;
           R1 = _s8aes::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bez; else goto c8bcM;
       u8bez: // global
           call _c8bcK(R1) args: 0, res: 0, upd: 0;
       c8bcM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bcC: // global
           I64[Sp + 8] = block_c8bcZ_info;
           R1 = _s8aes::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8beA; else goto c8bd1;
       u8beA: // global
           call _c8bcZ(R1) args: 0, res: 0, upd: 0;
       c8bd1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bcD: // global
           I64[Sp] = block_c8bde_info;
           _s8aex::P64 = P64[R1 + 5];
           R1 = _s8aes::P64;
           P64[Sp + 8] = _s8aex::P64;
           if (R1 & 7 != 0) goto u8beB; else goto c8bdg;
       u8beB: // global
           call _c8bde(R1) args: 0, res: 0, upd: 0;
       c8bdg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bcK() //  [R1]
         { info_tbl: [(c8bcK,
                       label: block_c8bcK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bcK: // global
           if (R1 & 7 == 1) goto u8bep; else goto u8beq;
       u8bep: // global
           Sp = Sp + 8;
           call _c8beg() args: 0, res: 0, upd: 0;
       u8beq: // global
           Sp = Sp + 8;
           call _c8beh() args: 0, res: 0, upd: 0;
     }
 },
 _c8bcZ() //  [R1]
         { info_tbl: [(c8bcZ,
                       label: block_c8bcZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bcZ: // global
           if (R1 & 7 == 3) goto u8ber; else goto u8bes;
       u8ber: // global
           Sp = Sp + 8;
           call _c8beh() args: 0, res: 0, upd: 0;
       u8bes: // global
           Sp = Sp + 8;
           call _c8beg() args: 0, res: 0, upd: 0;
     }
 },
 _c8bde() //  [R1]
         { info_tbl: [(c8bde,
                       label: block_c8bde_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bde: // global
           if (R1 & 7 == 3) goto c8bdr; else goto u8bet;
       c8bdr: // global
           I64[Sp] = block_c8bdp_info;
           _s8aez::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8aez::P64;
           if (R1 & 7 != 0) goto u8beH; else goto c8bds;
       u8beH: // global
           call _c8bdp(R1) args: 0, res: 0, upd: 0;
       c8bds: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8bet: // global
           Sp = Sp + 16;
           call _c8beg() args: 0, res: 0, upd: 0;
     }
 },
 _c8bdp() //  [R1]
         { info_tbl: [(c8bdp,
                       label: block_c8bdp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bdp: // global
           _s8aez::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bdz; else goto c8bdP;
       c8bdz: // global
           I64[Sp + 8] = block_c8bdw_info;
           R1 = _s8aez::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8beJ; else goto c8bdA;
       u8beJ: // global
           call _c8bdw(R1) args: 0, res: 0, upd: 0;
       c8bdA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bdP: // global
           I64[Sp] = block_c8bdN_info;
           _s8aeD::P64 = P64[R1 + 6];
           R1 = _s8aez::P64;
           P64[Sp + 8] = _s8aeD::P64;
           if (R1 & 7 != 0) goto u8beK; else goto c8bdQ;
       u8beK: // global
           call _c8bdN(R1) args: 0, res: 0, upd: 0;
       c8bdQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bdw() //  [R1]
         { info_tbl: [(c8bdw,
                       label: block_c8bdw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bdw: // global
           if (R1 & 7 == 1) goto u8bex; else goto u8bey;
       u8bex: // global
           Sp = Sp + 8;
           call _c8beg() args: 0, res: 0, upd: 0;
       u8bey: // global
           Sp = Sp + 8;
           call _c8beh() args: 0, res: 0, upd: 0;
     }
 },
 _c8bdN() //  [R1]
         { info_tbl: [(c8bdN,
                       label: block_c8bdN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bdN: // global
           if (R1 & 7 == 1) goto u8beu; else goto c8be6;
       u8beu: // global
           Sp = Sp + 16;
           call _c8beg() args: 0, res: 0, upd: 0;
       c8be6: // global
           I64[Sp] = block_c8bdZ_info;
           _s8aeF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8aeF::P64;
           if (R1 & 7 != 0) goto u8beN; else goto c8be0;
       u8beN: // global
           call _c8bdZ(R1) args: 0, res: 0, upd: 0;
       c8be0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bdZ() //  [R1]
         { info_tbl: [(c8bdZ,
                       label: block_c8bdZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bdZ: // global
           I64[Sp] = block_c8be4_info;
           _s8aeH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8aeH::I64;
           if (R1 & 7 != 0) goto u8beP; else goto c8be8;
       u8beP: // global
           call _c8be4(R1) args: 0, res: 0, upd: 0;
       c8be8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8be4() //  [R1]
         { info_tbl: [(c8be4,
                       label: block_c8be4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8be4: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8bew; else goto u8bev;
       u8bew: // global
           Sp = Sp + 16;
           call _c8beg() args: 0, res: 0, upd: 0;
       u8bev: // global
           Sp = Sp + 16;
           call _c8beh() args: 0, res: 0, upd: 0;
     }
 },
 _c8beh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8beh: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8beg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8beg: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.76301251 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8beW,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8beW: // global
           _s8aeM::P64 = R3;
           R3 = R2;
           R2 = _s8aeM::P64;
           call GHC.IO.Handle.Types.$fOrdBufferMode_$c<_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.765022911 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8bfb,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bfb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8bfc; else goto c8bfd;
       c8bfc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bfd: // global
           I64[Sp - 16] = block_c8bf3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bgX; else goto c8bf4;
       u8bgX: // global
           call _c8bf3(R1) args: 0, res: 0, upd: 0;
       c8bf4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bf3() //  [R1]
         { info_tbl: [(c8bf3,
                       label: block_c8bf3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bf3: // global
           _s8aeN::P64 = P64[Sp + 8];
           _c8bfa::P64 = R1 & 7;
           if (_c8bfa::P64 < 3) goto u8bgN; else goto c8bf9;
       u8bgN: // global
           if (_c8bfa::P64 < 2) goto c8bf7; else goto c8bf8;
       c8bf7: // global
           I64[Sp + 8] = block_c8bfg_info;
           R1 = _s8aeN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bgU; else goto c8bfi;
       u8bgU: // global
           call _c8bfg() args: 0, res: 0, upd: 0;
       c8bfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bf8: // global
           I64[Sp + 8] = block_c8bfp_info;
           R1 = _s8aeN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bgV; else goto c8bfr;
       u8bgV: // global
           call _c8bfp(R1) args: 0, res: 0, upd: 0;
       c8bfr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bf9: // global
           I64[Sp - 8] = block_c8bfE_info;
           _s8aeP::P64 = R1;
           _s8aeT::P64 = P64[R1 + 5];
           R1 = _s8aeN::P64;
           P64[Sp] = _s8aeT::P64;
           P64[Sp + 8] = _s8aeP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bgW; else goto c8bfG;
       u8bgW: // global
           call _c8bfE(R1) args: 0, res: 0, upd: 0;
       c8bfG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bfg() //  []
         { info_tbl: [(c8bfg,
                       label: block_c8bfg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bfg: // global
           R1 = GHC.IO.Handle.Types.NoBuffering_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bfp() //  [R1]
         { info_tbl: [(c8bfp,
                       label: block_c8bfp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bfp: // global
           if (R1 & 7 == 3) goto c8bfB; else goto c8bfx;
       c8bfB: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8bfx: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bfE() //  [R1]
         { info_tbl: [(c8bfE,
                       label: block_c8bfE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bfE: // global
           if (R1 & 7 == 3) goto c8bfR; else goto u8bgO;
       c8bfR: // global
           I64[Sp - 8] = block_c8bfP_info;
           _s8aeU::P64 = R1;
           _s8aeV::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aeV::P64;
           P64[Sp + 8] = _s8aeU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bgY; else goto c8bfS;
       u8bgY: // global
           call _c8bfP(R1) args: 0, res: 0, upd: 0;
       c8bfS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8bgO: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8bgG() args: 0, res: 0, upd: 0;
     }
 },
 _c8bfP() //  [R1]
         { info_tbl: [(c8bfP,
                       label: block_c8bfP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bfP: // global
           _s8aeV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bfZ; else goto c8bgf;
       c8bfZ: // global
           I64[Sp + 8] = block_c8bfW_info;
           R1 = _s8aeV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bh0; else goto c8bg0;
       u8bh0: // global
           call _c8bfW(R1) args: 0, res: 0, upd: 0;
       c8bg0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bgf: // global
           I64[Sp] = block_c8bgd_info;
           _s8aeZ::P64 = P64[R1 + 6];
           R1 = _s8aeV::P64;
           P64[Sp + 8] = _s8aeZ::P64;
           if (R1 & 7 != 0) goto u8bh1; else goto c8bgg;
       u8bh1: // global
           call _c8bgd(R1) args: 0, res: 0, upd: 0;
       c8bgg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bfW() //  [R1]
         { info_tbl: [(c8bfW,
                       label: block_c8bfW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bfW: // global
           if (R1 & 7 == 1) goto u8bgS; else goto u8bgT;
       u8bgS: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8bgG() args: 0, res: 0, upd: 0;
       u8bgT: // global
           Sp = Sp + 16;
           call _c8bgH() args: 0, res: 0, upd: 0;
     }
 },
 _c8bgd() //  [R1]
         { info_tbl: [(c8bgd,
                       label: block_c8bgd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bgd: // global
           if (R1 & 7 == 1) goto u8bgP; else goto c8bgw;
       u8bgP: // global
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp + 24;
           call _c8bgG() args: 0, res: 0, upd: 0;
       c8bgw: // global
           I64[Sp] = block_c8bgp_info;
           _s8af1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8af1::P64;
           if (R1 & 7 != 0) goto u8bh4; else goto c8bgq;
       u8bh4: // global
           call _c8bgp(R1) args: 0, res: 0, upd: 0;
       c8bgq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bgp() //  [R1]
         { info_tbl: [(c8bgp,
                       label: block_c8bgp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bgp: // global
           I64[Sp] = block_c8bgu_info;
           _s8af3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8af3::I64;
           if (R1 & 7 != 0) goto u8bh6; else goto c8bgy;
       u8bh6: // global
           call _c8bgu(R1) args: 0, res: 0, upd: 0;
       c8bgy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bgu() //  [R1]
         { info_tbl: [(c8bgu,
                       label: block_c8bgu_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bgu: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8bgR; else goto u8bgQ;
       u8bgR: // global
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp + 24;
           call _c8bgG() args: 0, res: 0, upd: 0;
       u8bgQ: // global
           Sp = Sp + 24;
           call _c8bgH() args: 0, res: 0, upd: 0;
     }
 },
 _c8bgH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bgH: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bgG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bgG: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.768324597 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqBufferMode_closure+1;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.769280028 UTC

[section ""data" . GHC.IO.Handle.Types.haOtherSide_closure" {
     GHC.IO.Handle.Types.haOtherSide_closure:
         const GHC.IO.Handle.Types.haOtherSide_info;
 },
 GHC.IO.Handle.Types.haOtherSide_entry() //  [R2]
         { info_tbl: [(c8bhg,
                       label: GHC.IO.Handle.Types.haOtherSide_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bhg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bhh; else goto c8bhi;
       c8bhh: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haOtherSide_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bhi: // global
           I64[Sp - 8] = block_c8bhd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bhm; else goto c8bhe;
       u8bhm: // global
           call _c8bhd(R1) args: 0, res: 0, upd: 0;
       c8bhe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bhd() //  [R1]
         { info_tbl: [(c8bhd,
                       label: block_c8bhd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bhd: // global
           R1 = P64[R1 + 127] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.770518128 UTC

[section ""data" . GHC.IO.Handle.Types.haOutputNL_closure" {
     GHC.IO.Handle.Types.haOutputNL_closure:
         const GHC.IO.Handle.Types.haOutputNL_info;
 },
 GHC.IO.Handle.Types.haOutputNL_entry() //  [R2]
         { info_tbl: [(c8bhu,
                       label: GHC.IO.Handle.Types.haOutputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bhu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bhv; else goto c8bhw;
       c8bhv: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haOutputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bhw: // global
           I64[Sp - 8] = block_c8bhr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bhA; else goto c8bhs;
       u8bhA: // global
           call _c8bhr(R1) args: 0, res: 0, upd: 0;
       c8bhs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bhr() //  [R1]
         { info_tbl: [(c8bhr,
                       label: block_c8bhr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bhr: // global
           R1 = P64[R1 + 119] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.771734031 UTC

[section ""data" . GHC.IO.Handle.Types.haInputNL_closure" {
     GHC.IO.Handle.Types.haInputNL_closure:
         const GHC.IO.Handle.Types.haInputNL_info;
 },
 GHC.IO.Handle.Types.haInputNL_entry() //  [R2]
         { info_tbl: [(c8bhI,
                       label: GHC.IO.Handle.Types.haInputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bhI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bhJ; else goto c8bhK;
       c8bhJ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haInputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bhK: // global
           I64[Sp - 8] = block_c8bhF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bhO; else goto c8bhG;
       u8bhO: // global
           call _c8bhF(R1) args: 0, res: 0, upd: 0;
       c8bhG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bhF() //  [R1]
         { info_tbl: [(c8bhF,
                       label: block_c8bhF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bhF: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.772983633 UTC

[section ""data" . GHC.IO.Handle.Types.haCodec_closure" {
     GHC.IO.Handle.Types.haCodec_closure:
         const GHC.IO.Handle.Types.haCodec_info;
 },
 GHC.IO.Handle.Types.haCodec_entry() //  [R2]
         { info_tbl: [(c8bhW,
                       label: GHC.IO.Handle.Types.haCodec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bhW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bhX; else goto c8bhY;
       c8bhX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haCodec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bhY: // global
           I64[Sp - 8] = block_c8bhT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bi2; else goto c8bhU;
       u8bi2: // global
           call _c8bhT(R1) args: 0, res: 0, upd: 0;
       c8bhU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bhT() //  [R1]
         { info_tbl: [(c8bhT,
                       label: block_c8bhT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bhT: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.774025626 UTC

[section ""data" . GHC.IO.Handle.Types.haDecoder_closure" {
     GHC.IO.Handle.Types.haDecoder_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.77465537 UTC

[section ""data" . GHC.IO.Handle.Types.haEncoder_closure" {
     GHC.IO.Handle.Types.haEncoder_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.775520432 UTC

[section ""data" . GHC.IO.Handle.Types.haBuffers_closure" {
     GHC.IO.Handle.Types.haBuffers_closure:
         const GHC.IO.Handle.Types.haBuffers_info;
 },
 GHC.IO.Handle.Types.haBuffers_entry() //  [R2]
         { info_tbl: [(c8bia,
                       label: GHC.IO.Handle.Types.haBuffers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bia: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bie; else goto c8bif;
       c8bie: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haBuffers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bif: // global
           I64[Sp - 8] = block_c8bi7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bij; else goto c8bi8;
       u8bij: // global
           call _c8bi7(R1) args: 0, res: 0, upd: 0;
       c8bi8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bi7() //  [R1]
         { info_tbl: [(c8bi7,
                       label: block_c8bi7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bi7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bii; else goto c8bih;
       c8bii: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8bih: // global
           _s8ags::P64 = P64[R1 + 79];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8ags::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.776889262 UTC

[section ""data" . GHC.IO.Handle.Types.haCharBuffer_closure" {
     GHC.IO.Handle.Types.haCharBuffer_closure:
         const GHC.IO.Handle.Types.haCharBuffer_info;
 },
 GHC.IO.Handle.Types.haCharBuffer_entry() //  [R2]
         { info_tbl: [(c8bir,
                       label: GHC.IO.Handle.Types.haCharBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bir: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8biv; else goto c8biw;
       c8biv: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haCharBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8biw: // global
           I64[Sp - 8] = block_c8bio_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8biA; else goto c8bip;
       u8biA: // global
           call _c8bio(R1) args: 0, res: 0, upd: 0;
       c8bip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bio() //  [R1]
         { info_tbl: [(c8bio,
                       label: block_c8bio_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bio: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8biz; else goto c8biy;
       c8biz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8biy: // global
           _s8agJ::P64 = P64[R1 + 71];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8agJ::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.778144314 UTC

[section ""data" . GHC.IO.Handle.Types.haLastDecode_closure" {
     GHC.IO.Handle.Types.haLastDecode_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.778984226 UTC

[section ""data" . GHC.IO.Handle.Types.haBufferMode_closure" {
     GHC.IO.Handle.Types.haBufferMode_closure:
         const GHC.IO.Handle.Types.haBufferMode_info;
 },
 GHC.IO.Handle.Types.haBufferMode_entry() //  [R2]
         { info_tbl: [(c8biI,
                       label: GHC.IO.Handle.Types.haBufferMode_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8biI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8biJ; else goto c8biK;
       c8biJ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haBufferMode_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8biK: // global
           I64[Sp - 8] = block_c8biF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8biO; else goto c8biG;
       u8biO: // global
           call _c8biF(R1) args: 0, res: 0, upd: 0;
       c8biG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8biF() //  [R1]
         { info_tbl: [(c8biF,
                       label: block_c8biF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8biF: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.78030272 UTC

[section ""data" . GHC.IO.Handle.Types.haByteBuffer_closure" {
     GHC.IO.Handle.Types.haByteBuffer_closure:
         const GHC.IO.Handle.Types.haByteBuffer_info;
 },
 GHC.IO.Handle.Types.haByteBuffer_entry() //  [R2]
         { info_tbl: [(c8biW,
                       label: GHC.IO.Handle.Types.haByteBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8biW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bj0; else goto c8bj1;
       c8bj0: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haByteBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bj1: // global
           I64[Sp - 8] = block_c8biT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bj5; else goto c8biU;
       u8bj5: // global
           call _c8biT(R1) args: 0, res: 0, upd: 0;
       c8biU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8biT() //  [R1]
         { info_tbl: [(c8biT,
                       label: block_c8biT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8biT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bj4; else goto c8bj3;
       c8bj4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8bj3: // global
           _s8ahg::P64 = P64[R1 + 47];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8ahg::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.781622734 UTC

[section ""data" . GHC.IO.Handle.Types.haType_closure" {
     GHC.IO.Handle.Types.haType_closure:
         const GHC.IO.Handle.Types.haType_info;
 },
 GHC.IO.Handle.Types.haType_entry() //  [R2]
         { info_tbl: [(c8bjd,
                       label: GHC.IO.Handle.Types.haType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bjd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bje; else goto c8bjf;
       c8bje: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bjf: // global
           I64[Sp - 8] = block_c8bja_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bjj; else goto c8bjb;
       u8bjj: // global
           call _c8bja(R1) args: 0, res: 0, upd: 0;
       c8bjb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bja() //  [R1]
         { info_tbl: [(c8bja,
                       label: block_c8bja_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bja: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.782620767 UTC

[section ""data" . GHC.IO.Handle.Types.haDevice_closure" {
     GHC.IO.Handle.Types.haDevice_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.783442505 UTC

[section ""data" . GHC.IO.Handle.Types.outputNL_closure" {
     GHC.IO.Handle.Types.outputNL_closure:
         const GHC.IO.Handle.Types.outputNL_info;
 },
 GHC.IO.Handle.Types.outputNL_entry() //  [R2]
         { info_tbl: [(c8bjr,
                       label: GHC.IO.Handle.Types.outputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bjr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bjs; else goto c8bjt;
       c8bjs: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.outputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bjt: // global
           I64[Sp - 8] = block_c8bjo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bjx; else goto c8bjp;
       u8bjx: // global
           call _c8bjo(R1) args: 0, res: 0, upd: 0;
       c8bjp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bjo() //  [R1]
         { info_tbl: [(c8bjo,
                       label: block_c8bjo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bjo: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.784711464 UTC

[section ""data" . GHC.IO.Handle.Types.inputNL_closure" {
     GHC.IO.Handle.Types.inputNL_closure:
         const GHC.IO.Handle.Types.inputNL_info;
 },
 GHC.IO.Handle.Types.inputNL_entry() //  [R2]
         { info_tbl: [(c8bjF,
                       label: GHC.IO.Handle.Types.inputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bjF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bjG; else goto c8bjH;
       c8bjG: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.inputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bjH: // global
           I64[Sp - 8] = block_c8bjC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bjL; else goto c8bjD;
       u8bjL: // global
           call _c8bjC(R1) args: 0, res: 0, upd: 0;
       c8bjD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bjC() //  [R1]
         { info_tbl: [(c8bjC,
                       label: block_c8bjC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bjC: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.78612574 UTC

[section ""data" . GHC.IO.Handle.Types.isReadableHandleType_closure" {
     GHC.IO.Handle.Types.isReadableHandleType_closure:
         const GHC.IO.Handle.Types.isReadableHandleType_info;
 },
 GHC.IO.Handle.Types.isReadableHandleType_entry() //  [R2]
         { info_tbl: [(c8bjY,
                       label: GHC.IO.Handle.Types.isReadableHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bjY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bjZ; else goto c8bk0;
       c8bjZ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isReadableHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bk0: // global
           I64[Sp - 8] = block_c8bjQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bkb; else goto c8bjR;
       u8bkb: // global
           call _c8bjQ(R1) args: 0, res: 0, upd: 0;
       c8bjR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bjQ() //  [R1]
         { info_tbl: [(c8bjQ,
                       label: block_c8bjQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bjQ: // global
           _c8bjX::P64 = R1 & 7;
           if (_c8bjX::P64 == 3) goto c8bjW; else goto u8bka;
       u8bka: // global
           if (_c8bjX::P64 == 6) goto c8bjW; else goto c8bjU;
       c8bjW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8bjU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.787580142 UTC

[section ""data" . GHC.IO.Handle.Types.isWritableHandleType_closure" {
     GHC.IO.Handle.Types.isWritableHandleType_closure:
         const GHC.IO.Handle.Types.isWritableHandleType_info;
 },
 GHC.IO.Handle.Types.isWritableHandleType_entry() //  [R2]
         { info_tbl: [(c8bkp,
                       label: GHC.IO.Handle.Types.isWritableHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bkp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bkq; else goto c8bkr;
       c8bkq: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isWritableHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bkr: // global
           I64[Sp - 8] = block_c8bkg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bkF; else goto c8bkh;
       u8bkF: // global
           call _c8bkg(R1) args: 0, res: 0, upd: 0;
       c8bkh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bkg() //  [R1]
         { info_tbl: [(c8bkg,
                       label: block_c8bkg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bkg: // global
           _c8bko::P64 = R1 & 7;
           if (_c8bko::P64 < 4) goto c8bkk; else goto u8bkE;
       c8bkk: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8bkE: // global
           if (_c8bko::P64 != 5) goto c8bkn; else goto c8bkn;
       c8bkn: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.791496284 UTC

[section ""data" . GHC.IO.Handle.Types.isReadWriteHandleType_closure" {
     GHC.IO.Handle.Types.isReadWriteHandleType_closure:
         const GHC.IO.Handle.Types.isReadWriteHandleType_info;
 },
 GHC.IO.Handle.Types.isReadWriteHandleType_entry() //  [R2]
         { info_tbl: [(c8bkR,
                       label: GHC.IO.Handle.Types.isReadWriteHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bkR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bkS; else goto c8bkT;
       c8bkS: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isReadWriteHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bkT: // global
           I64[Sp - 8] = block_c8bkK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bl0; else goto c8bkL;
       u8bl0: // global
           call _c8bkK(R1) args: 0, res: 0, upd: 0;
       c8bkL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bkK() //  [R1]
         { info_tbl: [(c8bkK,
                       label: block_c8bkK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bkK: // global
           if (R1 & 7 == 6) goto c8bkP; else goto c8bkO;
       c8bkP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8bkO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.792555488 UTC

[section ""data" . GHC.IO.Handle.Types.nativeNewline_closure" {
     GHC.IO.Handle.Types.nativeNewline_closure:
         const GHC.IO.Handle.Types.LF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.793195278 UTC

[section ""data" . GHC.IO.Handle.Types.universalNewlineMode_closure" {
     GHC.IO.Handle.Types.universalNewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_con_info;
         const GHC.IO.Handle.Types.CRLF_closure+2;
         const GHC.IO.Handle.Types.LF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.79403319 UTC

[section ""data" . GHC.IO.Handle.Types.nativeNewlineMode_closure" {
     GHC.IO.Handle.Types.nativeNewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_con_info;
         const GHC.IO.Handle.Types.LF_closure+1;
         const GHC.IO.Handle.Types.LF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.794615847 UTC

[section ""data" . GHC.IO.Handle.Types.noNewlineTranslation_closure" {
     GHC.IO.Handle.Types.noNewlineTranslation_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Handle.Types.nativeNewlineMode_closure+1;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.795196727 UTC

[section ""cstring" . GHC.IO.Handle.Types.showHandle1_bytes" {
     GHC.IO.Handle.Types.showHandle1_bytes:
         I8[] [123,104,97,110,100,108,101,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.796218758 UTC

[section ""data" . GHC.IO.Handle.Types.showHandle_closure" {
     GHC.IO.Handle.Types.showHandle_closure:
         const GHC.IO.Handle.Types.showHandle_info;
 },
 sat_s8ahZ_entry() //  [R1]
         { info_tbl: [(c8bld,
                       label: sat_s8ahZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bld: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ai0_entry() //  [R1]
         { info_tbl: [(c8blg,
                       label: sat_s8ai0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8blg: // global
           _s8ai0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8blh; else goto c8bli;
       c8bli: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8blk; else goto c8blj;
       c8blk: // global
           HpAlloc = 24;
           goto c8blh;
       c8blh: // global
           R1 = _s8ai0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8blj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8ai0::P64;
           _s8ahX::P64 = P64[_s8ai0::P64 + 16];
           _s8ahY::P64 = P64[_s8ai0::P64 + 24];
           I64[Hp - 16] = sat_s8ahZ_info;
           P64[Hp] = _s8ahY::P64;
           R3 = Hp - 16;
           R2 = _s8ahX::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.showHandle_entry() //  [R2, R3]
         { info_tbl: [(c8bll,
                       label: GHC.IO.Handle.Types.showHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bll: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8blp; else goto c8blo;
       c8blp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.showHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8blo: // global
           I64[Hp - 24] = sat_s8ai0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.797919935 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_info;
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c8blB,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8blB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8blC; else goto c8blD;
       c8blC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8blD: // global
           I64[Sp - 16] = block_c8blu_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8blK; else goto c8blv;
       u8blK: // global
           call _c8blu(R1) args: 0, res: 0, upd: 0;
       c8blv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8blu() //  [R1]
         { info_tbl: [(c8blu,
                       label: block_c8blu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8blu: // global
           _s8ai3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bly; else goto c8blz;
       c8bly: // global
           R3 = _s8ai3::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c8blz: // global
           R3 = _s8ai3::P64;
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.799625549 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_info;
         const 0;
 },
 sat_s8aie_entry() //  [R1]
         { info_tbl: [(c8blY,
                       label: sat_s8aie_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8blY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8blZ; else goto c8bm0;
       c8blZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bm0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8aii_entry() //  [R1]
         { info_tbl: [(c8bm7,
                       label: sat_s8aii_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bm7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bm8; else goto c8bm9;
       c8bm8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bm9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshow_entry() //  [R2]
         { info_tbl: [(c8bme,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bme: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bmf; else goto c8bmg;
       c8bmf: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bmg: // global
           I64[Sp - 8] = block_c8blP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bmn; else goto c8blQ;
       u8bmn: // global
           call _c8blP(R1) args: 0, res: 0, upd: 0;
       c8blQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8blP() //  [R1]
         { info_tbl: [(c8blP,
                       label: block_c8blP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8blP: // global
           if (R1 & 7 == 1) goto c8bmb; else goto c8bmc;
       c8bmb: // global
           Hp = Hp + 24;
           _s8aib::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8bmm; else goto c8bmi;
       c8bmi: // global
           _s8aic::P64 = P64[_s8aib::P64 + 7];
           I64[Hp - 16] = sat_s8aie_info;
           P64[Hp] = _s8aic::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8bmc: // global
           Hp = Hp + 24;
           _s8aib::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8bmm; else goto c8bml;
       c8bmm: // global
           HpAlloc = 24;
           R1 = _s8aib::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8bml: // global
           _s8aif::P64 = P64[_s8aib::P64 + 6];
           I64[Hp - 16] = sat_s8aii_info;
           P64[Hp] = _s8aif::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.801652537 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle1_closure" {
     GHC.IO.Handle.Types.$fShowHandle1_closure:
         const GHC.IO.Handle.Types.$fShowHandle1_info;
 },
 GHC.IO.Handle.Types.$fShowHandle1_entry() //  [R2, R3]
         { info_tbl: [(c8bmz,
                       label: GHC.IO.Handle.Types.$fShowHandle1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bmz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bmA; else goto c8bmB;
       c8bmA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bmB: // global
           I64[Sp - 16] = block_c8bms_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bmI; else goto c8bmt;
       u8bmI: // global
           call _c8bms(R1) args: 0, res: 0, upd: 0;
       c8bmt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bms() //  [R1]
         { info_tbl: [(c8bms,
                       label: block_c8bms_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bms: // global
           _s8aik::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bmw; else goto c8bmx;
       c8bmw: // global
           R3 = _s8aik::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c8bmx: // global
           R3 = _s8aik::P64;
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.802830332 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshowList_info;
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8bmN,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bmN: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowHandle1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.803571726 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_closure" {
     GHC.IO.Handle.Types.$fShowHandle_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.804125843 UTC

[section ""cstring" . GHC.IO.Handle.Types.$trModule4_bytes" {
     GHC.IO.Handle.Types.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.804659388 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule3_closure" {
     GHC.IO.Handle.Types.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.805199927 UTC

[section ""cstring" . GHC.IO.Handle.Types.$trModule2_bytes" {
     GHC.IO.Handle.Types.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.806020725 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule1_closure" {
     GHC.IO.Handle.Types.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.806560502 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule_closure" {
     GHC.IO.Handle.Types.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Types.$trModule3_closure+1;
         const GHC.IO.Handle.Types.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.807170194 UTC

[section ""data" . $krep_r8a59_closure" {
     $krep_r8a59_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.807773867 UTC

[section ""data" . $krep1_r8a5a_closure" {
     $krep1_r8a5a_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcTextEncoding_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.808329862 UTC

[section ""data" . $krep2_r8a5b_closure" {
     $krep2_r8a5b_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.80894048 UTC

[section ""data" . $krep3_r8a5c_closure" {
     $krep3_r8a5c_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.809529776 UTC

[section ""data" . $krep4_r8a5d_closure" {
     $krep4_r8a5d_closure:
         const :_con_info;
         const $krep_r8a59_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.810112033 UTC

[section ""data" . $krep5_r8a5e_closure" {
     $krep5_r8a5e_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep4_r8a5d_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.810706387 UTC

[section ""data" . $krep6_r8a5f_closure" {
     $krep6_r8a5f_closure:
         const :_con_info;
         const $krep1_r8a5a_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.811283249 UTC

[section ""data" . $krep7_r8a5g_closure" {
     $krep7_r8a5g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r8a5f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.811880425 UTC

[section ""data" . $krep8_r8a5h_closure" {
     $krep8_r8a5h_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.812465849 UTC

[section ""data" . $krep9_r8a5i_closure" {
     $krep9_r8a5i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.813059266 UTC

[section ""data" . $krep10_r8a5j_closure" {
     $krep10_r8a5j_closure:
         const :_con_info;
         const $krep9_r8a5i_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.813726212 UTC

[section ""data" . $krep11_r8a5k_closure" {
     $krep11_r8a5k_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep10_r8a5j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.814301734 UTC

[section ""data" . $krep12_r8a5l_closure" {
     $krep12_r8a5l_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.81494827 UTC

[section ""data" . $krep13_r8a5m_closure" {
     $krep13_r8a5m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure;
         const $krep12_r8a5l_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.815521739 UTC

[section ""data" . $krep14_r8a5n_closure" {
     $krep14_r8a5n_closure:
         const :_con_info;
         const $krep13_r8a5m_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.816143294 UTC

[section ""data" . $krep15_r8a5o_closure" {
     $krep15_r8a5o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep14_r8a5n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.816679245 UTC

[section ""data" . $krep16_r8a5p_closure" {
     $krep16_r8a5p_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.817559977 UTC

[section ""data" . $krep17_r8a5q_closure" {
     $krep17_r8a5q_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.818121368 UTC

[section ""data" . $krep18_r8a5r_closure" {
     $krep18_r8a5r_closure:
         const :_con_info;
         const $krep17_r8a5q_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.818679075 UTC

[section ""data" . $krep19_r8a5s_closure" {
     $krep19_r8a5s_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const $krep18_r8a5r_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.819255061 UTC

[section ""data" . $krep20_r8a5t_closure" {
     $krep20_r8a5t_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const $krep19_r8a5s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.819883156 UTC

[section ""data" . $krep21_r8a5u_closure" {
     $krep21_r8a5u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcBufferCodec_closure;
         const $krep20_r8a5t_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.820496404 UTC

[section ""data" . $krep22_r8a5v_closure" {
     $krep22_r8a5v_closure:
         const :_con_info;
         const $krep21_r8a5u_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.821107168 UTC

[section ""data" . $krep23_r8a5w_closure" {
     $krep23_r8a5w_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep22_r8a5v_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.821740179 UTC

[section ""data" . $krep24_r8a5x_closure" {
     $krep24_r8a5x_closure:
         const :_con_info;
         const $krep17_r8a5q_closure+2;
         const $krep14_r8a5n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.823689108 UTC

[section ""data" . $krep25_r8a5y_closure" {
     $krep25_r8a5y_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep24_r8a5x_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.824408499 UTC

[section ""data" . $krep26_r8a5z_closure" {
     $krep26_r8a5z_closure:
         const :_con_info;
         const $krep25_r8a5y_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.825029886 UTC

[section ""data" . $krep27_r8a5A_closure" {
     $krep27_r8a5A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep26_r8a5z_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.825670713 UTC

[section ""data" . $krep28_r8a5B_closure" {
     $krep28_r8a5B_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.826286763 UTC

[section ""data" . $krep29_r8a5C_closure" {
     $krep29_r8a5C_closure:
         const :_con_info;
         const $krep28_r8a5B_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.826911102 UTC

[section ""data" . $krep30_r8a5D_closure" {
     $krep30_r8a5D_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const $krep29_r8a5C_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.82752876 UTC

[section ""data" . $krep31_r8a5E_closure" {
     $krep31_r8a5E_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const $krep30_r8a5D_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.82811343 UTC

[section ""data" . $krep32_r8a5F_closure" {
     $krep32_r8a5F_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcBufferCodec_closure;
         const $krep31_r8a5E_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.828718634 UTC

[section ""data" . $krep33_r8a5G_closure" {
     $krep33_r8a5G_closure:
         const :_con_info;
         const $krep32_r8a5F_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.829363769 UTC

[section ""data" . $krep34_r8a5H_closure" {
     $krep34_r8a5H_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep33_r8a5G_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.829970977 UTC

[section ""data" . $krep35_r8a5I_closure" {
     $krep35_r8a5I_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.830549158 UTC

[section ""data" . $krep36_r8a5J_closure" {
     $krep36_r8a5J_closure:
         const :_con_info;
         const $krep35_r8a5I_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.831158657 UTC

[section ""data" . $krep37_r8a5K_closure" {
     $krep37_r8a5K_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.831776164 UTC

[section ""data" . $krep38_r8a5L_closure" {
     $krep38_r8a5L_closure:
         const :_con_info;
         const GHC.Types.krep$*_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.832345886 UTC

[section ""data" . $krep39_r8a5M_closure" {
     $krep39_r8a5M_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Typeable.Internal.$tcTypeable_closure;
         const $krep38_r8a5L_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.832925659 UTC

[section ""data" . $krep40_r8a5N_closure" {
     $krep40_r8a5N_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Device.$tcIODevice_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.833845196 UTC

[section ""data" . $krep41_r8a5O_closure" {
     $krep41_r8a5O_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.BufferedIO.$tcBufferedIO_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.834429647 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcBufferList2_bytes" {
     GHC.IO.Handle.Types.$tcBufferList2_bytes:
         I8[] [66,117,102,102,101,114,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.834995765 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferList1_closure" {
     GHC.IO.Handle.Types.$tcBufferList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcBufferList2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.835576823 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferList_closure" {
     GHC.IO.Handle.Types.$tcBufferList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcBufferList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16602278556585116844;
         const 18164509953320487254;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.836216303 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil1_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferList_closure+1;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.836805323 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BufferListNil3_bytes" {
     GHC.IO.Handle.Types.$tc'BufferListNil3_bytes:
         I8[] [39,66,117,102,102,101,114,76,105,115,116,78,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.837395489 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil2_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListNil3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.837989921 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil2_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const 1776148480580179033;
         const 13181184993065174936;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.838611973 UTC

[section ""data" . $krep42_r8a5P_closure" {
     $krep42_r8a5P_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.839201454 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons1_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep37_r8a5K_closure+1;
         const $krep42_r8a5P_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.839770399 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BufferListCons3_bytes" {
     GHC.IO.Handle.Types.$tc'BufferListCons3_bytes:
         I8[] [39,66,117,102,102,101,114,76,105,115,116,67,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.840351703 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons2_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListCons3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.840937248 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListCons2_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListCons1_closure+4;
         const 17252346539814354939;
         const 274626690118510806;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.84180154 UTC

[section ""data" . $krep43_r8a5Q_closure" {
     $krep43_r8a5Q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferList_closure+1;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.842391724 UTC

[section ""data" . $krep44_r8a5R_closure" {
     $krep44_r8a5R_closure:
         const :_con_info;
         const $krep43_r8a5Q_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.842980576 UTC

[section ""data" . $krep45_r8a5S_closure" {
     $krep45_r8a5S_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep44_r8a5R_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.843539111 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandleType2_bytes" {
     GHC.IO.Handle.Types.$tcHandleType2_bytes:
         I8[] [72,97,110,100,108,101,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.844099029 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandleType1_closure" {
     GHC.IO.Handle.Types.$tcHandleType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandleType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.844715764 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandleType_closure" {
     GHC.IO.Handle.Types.$tcHandleType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandleType1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12652050740177317592;
         const 15012172050125063359;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.845341402 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle1_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandleType_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.845911313 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes:
         I8[] [39,67,108,111,115,101,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.846479428 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ClosedHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ClosedHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.847071677 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ClosedHandle_closure" {
     GHC.IO.Handle.Types.$tc'ClosedHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ClosedHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 3827246897052092772;
         const 908733983357893198;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.847684581 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes:
         I8[] [39,83,101,109,105,67,108,111,115,101,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.848252782 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.848830658 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'SemiClosedHandle_closure" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 9212351547956271402;
         const 6570718180183054490;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.849957091 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ReadHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ReadHandle2_bytes:
         I8[] [39,82,101,97,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.85128095 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ReadHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ReadHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.851936159 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadHandle_closure" {
     GHC.IO.Handle.Types.$tc'ReadHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ReadHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 269968663592081974;
         const 17473723309710900549;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.852693139 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'WriteHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'WriteHandle2_bytes:
         I8[] [39,87,114,105,116,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.853418938 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'WriteHandle1_closure" {
     GHC.IO.Handle.Types.$tc'WriteHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'WriteHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.854002264 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'WriteHandle_closure" {
     GHC.IO.Handle.Types.$tc'WriteHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'WriteHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 18024523813608199082;
         const 4783872735135983851;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.854613407 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'AppendHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'AppendHandle3_bytes:
         I8[] [39,65,112,112,101,110,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.855203962 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle2_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'AppendHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.855784604 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 18423480119042393547;
         const 8911069045719960050;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.856410231 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes:
         I8[] [39,82,101,97,100,87,114,105,116,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.856927674 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.857498914 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadWriteHandle_closure" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 6962298179673541916;
         const 7858738479804269456;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.858103934 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcBufferMode2_bytes" {
     GHC.IO.Handle.Types.$tcBufferMode2_bytes:
         I8[] [66,117,102,102,101,114,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.858649851 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferMode1_closure" {
     GHC.IO.Handle.Types.$tcBufferMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcBufferMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.859215236 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferMode_closure" {
     GHC.IO.Handle.Types.$tcBufferMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcBufferMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2181253694666364469;
         const 18094997560331273583;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.85984168 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.860411322 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'NoBuffering2_bytes" {
     GHC.IO.Handle.Types.$tc'NoBuffering2_bytes:
         I8[] [39,78,111,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.860927009 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NoBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'NoBuffering1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'NoBuffering2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.861939779 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NoBuffering_closure" {
     GHC.IO.Handle.Types.$tc'NoBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'NoBuffering1_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 1829914617507863771;
         const 11519122601481432262;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.862527945 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'LineBuffering3_bytes" {
     GHC.IO.Handle.Types.$tc'LineBuffering3_bytes:
         I8[] [39,76,105,110,101,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.863101573 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering2_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'LineBuffering3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.863678639 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering2_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 6417231512954421547;
         const 14761155862500981941;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.864307996 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r8a5e_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.864953248 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes" {
     GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes:
         I8[] [39,66,108,111,99,107,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.865528267 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering2_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.866137165 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BlockBuffering2_closure+1;
         const GHC.IO.Handle.Types.$tc'BlockBuffering1_closure+4;
         const 704611490471072872;
         const 15656058643765081689;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.866727678 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcNewline2_bytes" {
     GHC.IO.Handle.Types.$tcNewline2_bytes:
         I8[] [78,101,119,108,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.867265553 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewline1_closure" {
     GHC.IO.Handle.Types.$tcNewline1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcNewline2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.867873313 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewline_closure" {
     GHC.IO.Handle.Types.$tcNewline_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcNewline1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4144517894815066994;
         const 10872055347860317487;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.868523024 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF1_closure" {
     GHC.IO.Handle.Types.$tc'CRLF1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcNewline_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.869097664 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'LF2_bytes" {
     GHC.IO.Handle.Types.$tc'LF2_bytes:
         I8[] [39,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.869693029 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LF1_closure" {
     GHC.IO.Handle.Types.$tc'LF1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'LF2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.870273296 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LF_closure" {
     GHC.IO.Handle.Types.$tc'LF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'LF1_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const 8352565500432618804;
         const 14951155965269318914;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.870881503 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'CRLF3_bytes" {
     GHC.IO.Handle.Types.$tc'CRLF3_bytes:
         I8[] [39,67,82,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.871411614 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF2_closure" {
     GHC.IO.Handle.Types.$tc'CRLF2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.87203353 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF_closure" {
     GHC.IO.Handle.Types.$tc'CRLF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF2_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const 12041259567283068515;
         const 3210182148185771829;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.872640773 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandle__2_bytes" {
     GHC.IO.Handle.Types.$tcHandle__2_bytes:
         I8[] [72,97,110,100,108,101,95,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.873182612 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle__1_closure" {
     GHC.IO.Handle.Types.$tcHandle__1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandle__2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.873829192 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle___closure" {
     GHC.IO.Handle.Types.$tcHandle___closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandle__1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10675922960094776064;
         const 10563785792974977547;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.874432726 UTC

[section ""data" . $krep46_r8a5T_closure" {
     $krep46_r8a5T_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle___closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.875020238 UTC

[section ""data" . $krep47_r8a5U_closure" {
     $krep47_r8a5U_closure:
         const :_con_info;
         const $krep46_r8a5T_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.875527282 UTC

[section ""data" . $krep48_r8a5V_closure" {
     $krep48_r8a5V_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep47_r8a5U_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.876103651 UTC

[section ""data" . $krep49_r8a5W_closure" {
     $krep49_r8a5W_closure:
         const :_con_info;
         const $krep48_r8a5V_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.87667704 UTC

[section ""data" . $krep50_r8a5X_closure" {
     $krep50_r8a5X_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep49_r8a5W_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.877954828 UTC

[section ""data" . $krep51_r8a5Y_closure" {
     $krep51_r8a5Y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep50_r8a5X_closure+1;
         const $krep46_r8a5T_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.878561262 UTC

[section ""data" . $krep52_r8a5Z_closure" {
     $krep52_r8a5Z_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep51_r8a5Y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.879177081 UTC

[section ""data" . $krep53_r8a60_closure" {
     $krep53_r8a60_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep52_r8a5Z_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.879769609 UTC

[section ""data" . $krep54_r8a61_closure" {
     $krep54_r8a61_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r8a5g_closure+1;
         const $krep53_r8a60_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.880352454 UTC

[section ""data" . $krep55_r8a62_closure" {
     $krep55_r8a62_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep23_r8a5w_closure+1;
         const $krep54_r8a61_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.880936824 UTC

[section ""data" . $krep56_r8a63_closure" {
     $krep56_r8a63_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep34_r8a5H_closure+1;
         const $krep55_r8a62_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.881950773 UTC

[section ""data" . $krep57_r8a64_closure" {
     $krep57_r8a64_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep45_r8a5S_closure+1;
         const $krep56_r8a63_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.882548063 UTC

[section ""data" . $krep58_r8a65_closure" {
     $krep58_r8a65_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r8a5k_closure+1;
         const $krep57_r8a64_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.883133512 UTC

[section ""data" . $krep59_r8a66_closure" {
     $krep59_r8a66_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep27_r8a5A_closure+1;
         const $krep58_r8a65_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.883699986 UTC

[section ""data" . $krep60_r8a67_closure" {
     $krep60_r8a67_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const $krep59_r8a66_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.884293633 UTC

[section ""data" . $krep61_r8a68_closure" {
     $krep61_r8a68_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep15_r8a5o_closure+1;
         const $krep60_r8a67_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.884883404 UTC

[section ""data" . $krep62_r8a69_closure" {
     $krep62_r8a69_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const $krep61_r8a68_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.885518259 UTC

[section ""data" . $krep63_r8a6a_closure" {
     $krep63_r8a6a_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep35_r8a5I_closure+2;
         const $krep62_r8a69_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.886136968 UTC

[section ""data" . $krep64_r8a6b_closure" {
     $krep64_r8a6b_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep39_r8a5M_closure+1;
         const $krep63_r8a6a_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.886705159 UTC

[section ""data" . $krep65_r8a6c_closure" {
     $krep65_r8a6c_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep41_r8a5O_closure+1;
         const $krep64_r8a6b_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.887302769 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle__1_closure" {
     GHC.IO.Handle.Types.$tc'Handle__1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep40_r8a5N_closure+1;
         const $krep65_r8a6c_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.887855029 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'Handle__3_bytes" {
     GHC.IO.Handle.Types.$tc'Handle__3_bytes:
         I8[] [39,72,97,110,100,108,101,95,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.888394816 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle__2_closure" {
     GHC.IO.Handle.Types.$tc'Handle__2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'Handle__3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.888922592 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle___closure" {
     GHC.IO.Handle.Types.$tc'Handle___closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'Handle__2_closure+1;
         const GHC.IO.Handle.Types.$tc'Handle__1_closure+4;
         const 15400920814375205416;
         const 14458810719499819570;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.889521415 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandle2_bytes" {
     GHC.IO.Handle.Types.$tcHandle2_bytes:
         I8[] [72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.890076885 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle1_closure" {
     GHC.IO.Handle.Types.$tcHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.89066796 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle_closure" {
     GHC.IO.Handle.Types.$tcHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandle1_closure+1;
         const GHC.Types.krep$*_closure;
         const 6808292778723485333;
         const 9239299165073943659;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.891281331 UTC

[section ""data" . $krep66_r8a6d_closure" {
     $krep66_r8a6d_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.891884476 UTC

[section ""data" . $krep67_r8a6e_closure" {
     $krep67_r8a6e_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep48_r8a5V_closure+1;
         const $krep66_r8a6d_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.892464967 UTC

[section ""data" . $krep68_r8a6f_closure" {
     $krep68_r8a6f_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep48_r8a5V_closure+1;
         const $krep67_r8a6e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.893057391 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle1_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r8a5p_closure+1;
         const $krep68_r8a6f_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.893704126 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes:
         I8[] [39,68,117,112,108,101,120,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.894293361 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle2_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.894896022 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'DuplexHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'DuplexHandle1_closure+4;
         const 477065760828861081;
         const 4557316572761143129;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.895515252 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle1_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r8a5p_closure+1;
         const $krep67_r8a6e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.896064057 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'FileHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'FileHandle3_bytes:
         I8[] [39,70,105,108,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.896663873 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle2_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'FileHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.897224287 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'FileHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'FileHandle1_closure+4;
         const 5544613225695748436;
         const 8829945929965735507;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.897874051 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewlineMode1_closure" {
     GHC.IO.Handle.Types.$tcNewlineMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode17_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.898455094 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewlineMode_closure" {
     GHC.IO.Handle.Types.$tcNewlineMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcNewlineMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 17953040817059389032;
         const 12498949339099960838;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.899091554 UTC

[section ""data" . $krep69_r8a6g_closure" {
     $krep69_r8a6g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcNewlineMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.899692046 UTC

[section ""data" . $krep70_r8a6h_closure" {
     $krep70_r8a6h_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep69_r8a6g_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.900260428 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode1_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep70_r8a6h_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.900835033 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'NewlineMode3_bytes" {
     GHC.IO.Handle.Types.$tc'NewlineMode3_bytes:
         I8[] [39,78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.902081871 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode2_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'NewlineMode3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.902657461 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'NewlineMode2_closure+1;
         const GHC.IO.Handle.Types.$tc'NewlineMode1_closure+4;
         const 4266278501114659446;
         const 17947462423734457010;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.90352023 UTC

[section ""data" . GHC.IO.Handle.Types.checkHandleInvariants1_closure" {
     GHC.IO.Handle.Types.checkHandleInvariants1_closure:
         const GHC.IO.Handle.Types.checkHandleInvariants1_info;
 },
 GHC.IO.Handle.Types.checkHandleInvariants1_entry() //  []
         { info_tbl: [(c8bmU,
                       label: GHC.IO.Handle.Types.checkHandleInvariants1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bmU: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.905005715 UTC

[section ""data" . GHC.IO.Handle.Types.checkHandleInvariants_closure" {
     GHC.IO.Handle.Types.checkHandleInvariants_closure:
         const GHC.IO.Handle.Types.checkHandleInvariants_info;
 },
 GHC.IO.Handle.Types.checkHandleInvariants_entry() //  [R2]
         { info_tbl: [(c8bn1,
                       label: GHC.IO.Handle.Types.checkHandleInvariants_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bn1: // global
           R2 = R2;
           call GHC.IO.Handle.Types.checkHandleInvariants1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.905989698 UTC

[section ""data" . GHC.IO.Handle.Types.NewlineMode_closure" {
     GHC.IO.Handle.Types.NewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_info;
 },
 GHC.IO.Handle.Types.NewlineMode_entry() //  [R2, R3]
         { info_tbl: [(c8bn9,
                       label: GHC.IO.Handle.Types.NewlineMode_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bn9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bnd; else goto c8bnc;
       c8bnd: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.NewlineMode_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bnc: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.906872299 UTC

[section ""data" . GHC.IO.Handle.Types.LF_closure" {
     GHC.IO.Handle.Types.LF_closure:
         const GHC.IO.Handle.Types.LF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.907456186 UTC

[section ""data" . GHC.IO.Handle.Types.CRLF_closure" {
     GHC.IO.Handle.Types.CRLF_closure:
         const GHC.IO.Handle.Types.CRLF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.908031306 UTC

[section ""data" . GHC.IO.Handle.Types.NoBuffering_closure" {
     GHC.IO.Handle.Types.NoBuffering_closure:
         const GHC.IO.Handle.Types.NoBuffering_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.908579379 UTC

[section ""data" . GHC.IO.Handle.Types.LineBuffering_closure" {
     GHC.IO.Handle.Types.LineBuffering_closure:
         const GHC.IO.Handle.Types.LineBuffering_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.909329318 UTC

[section ""data" . GHC.IO.Handle.Types.BlockBuffering_closure" {
     GHC.IO.Handle.Types.BlockBuffering_closure:
         const GHC.IO.Handle.Types.BlockBuffering_info;
 },
 GHC.IO.Handle.Types.BlockBuffering_entry() //  [R2]
         { info_tbl: [(c8bnj,
                       label: GHC.IO.Handle.Types.BlockBuffering_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bnj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bnn; else goto c8bnm;
       c8bnn: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.BlockBuffering_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bnm: // global
           I64[Hp - 8] = GHC.IO.Handle.Types.BlockBuffering_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.910120604 UTC

[section ""data" . GHC.IO.Handle.Types.ClosedHandle_closure" {
     GHC.IO.Handle.Types.ClosedHandle_closure:
         const GHC.IO.Handle.Types.ClosedHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.910689845 UTC

[section ""data" . GHC.IO.Handle.Types.SemiClosedHandle_closure" {
     GHC.IO.Handle.Types.SemiClosedHandle_closure:
         const GHC.IO.Handle.Types.SemiClosedHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.91123085 UTC

[section ""data" . GHC.IO.Handle.Types.ReadHandle_closure" {
     GHC.IO.Handle.Types.ReadHandle_closure:
         const GHC.IO.Handle.Types.ReadHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.911771311 UTC

[section ""data" . GHC.IO.Handle.Types.WriteHandle_closure" {
     GHC.IO.Handle.Types.WriteHandle_closure:
         const GHC.IO.Handle.Types.WriteHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.912327617 UTC

[section ""data" . GHC.IO.Handle.Types.AppendHandle_closure" {
     GHC.IO.Handle.Types.AppendHandle_closure:
         const GHC.IO.Handle.Types.AppendHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.912928328 UTC

[section ""data" . GHC.IO.Handle.Types.ReadWriteHandle_closure" {
     GHC.IO.Handle.Types.ReadWriteHandle_closure:
         const GHC.IO.Handle.Types.ReadWriteHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.913474234 UTC

[section ""data" . GHC.IO.Handle.Types.BufferListNil_closure" {
     GHC.IO.Handle.Types.BufferListNil_closure:
         const GHC.IO.Handle.Types.BufferListNil_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.91423891 UTC

[section ""data" . GHC.IO.Handle.Types.BufferListCons_closure" {
     GHC.IO.Handle.Types.BufferListCons_closure:
         const GHC.IO.Handle.Types.BufferListCons_info;
 },
 GHC.IO.Handle.Types.BufferListCons_entry() //  [R2, R3]
         { info_tbl: [(c8bnt,
                       label: GHC.IO.Handle.Types.BufferListCons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bnt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bnx; else goto c8bnw;
       c8bnx: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.BufferListCons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bnw: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.915567599 UTC

[section ""data" . GHC.IO.Handle.Types.Handle___closure" {
     GHC.IO.Handle.Types.Handle___closure:
         const GHC.IO.Handle.Types.Handle___info;
 },
 GHC.IO.Handle.Types.Handle___slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bnz: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Types.Handle___entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 96, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.Handle___entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8bnE,
                       label: GHC.IO.Handle.Types.Handle___info
                       rep:HeapRep static {
                             Fun {arity: 16
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bnE: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8bnI; else goto c8bnH;
       c8bnI: // global
           HpAlloc = 136;
           R1 = GHC.IO.Handle.Types.Handle___closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 136, res: 0, upd: 8;
       c8bnH: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           P64[Hp - 88] = R6;
           P64[Hp - 80] = P64[Sp];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 56];
           P64[Hp - 16] = P64[Sp + 64];
           P64[Hp - 8] = P64[Sp + 72];
           P64[Hp] = P64[Sp + 80];
           R1 = Hp - 127;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.917036971 UTC

[section ""data" . GHC.IO.Handle.Types.FileHandle_closure" {
     GHC.IO.Handle.Types.FileHandle_closure:
         const GHC.IO.Handle.Types.FileHandle_info;
 },
 GHC.IO.Handle.Types.FileHandle_entry() //  [R2, R3]
         { info_tbl: [(c8bnO,
                       label: GHC.IO.Handle.Types.FileHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bnO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bnS; else goto c8bnR;
       c8bnS: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.FileHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bnR: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.918765261 UTC

[section ""data" . GHC.IO.Handle.Types.DuplexHandle_closure" {
     GHC.IO.Handle.Types.DuplexHandle_closure:
         const GHC.IO.Handle.Types.DuplexHandle_info;
 },
 GHC.IO.Handle.Types.DuplexHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(c8bnY,
                       label: GHC.IO.Handle.Types.DuplexHandle_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bnY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8bo2; else goto c8bo1;
       c8bo2: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.DuplexHandle_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bo1: // global
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 22;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.919661407 UTC

[GHC.IO.Handle.Types.NewlineMode_con_entry() //  [R1]
         { info_tbl: [(c8bo3,
                       label: GHC.IO.Handle.Types.NewlineMode_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,78,101,119,108,105,110,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bo3: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.920377213 UTC

[section ""relreadonly" . GHC.IO.Handle.Types.Newline_closure_tbl" {
     GHC.IO.Handle.Types.Newline_closure_tbl:
         const GHC.IO.Handle.Types.LF_closure+1;
         const GHC.IO.Handle.Types.CRLF_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.921014143 UTC

[GHC.IO.Handle.Types.LF_con_entry() //  [R1]
         { info_tbl: [(c8bo4,
                       label: GHC.IO.Handle.Types.LF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,76,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bo4: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.921762694 UTC

[GHC.IO.Handle.Types.CRLF_con_entry() //  [R1]
         { info_tbl: [(c8bo5,
                       label: GHC.IO.Handle.Types.CRLF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,67,82,76,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bo5: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.922481953 UTC

[GHC.IO.Handle.Types.NoBuffering_con_entry() //  [R1]
         { info_tbl: [(c8bo6,
                       label: GHC.IO.Handle.Types.NoBuffering_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,78,111,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bo6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.923165581 UTC

[GHC.IO.Handle.Types.LineBuffering_con_entry() //  [R1]
         { info_tbl: [(c8bo7,
                       label: GHC.IO.Handle.Types.LineBuffering_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,76,105,110,101,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bo7: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.923878997 UTC

[GHC.IO.Handle.Types.BlockBuffering_con_entry() //  [R1]
         { info_tbl: [(c8bo8,
                       label: GHC.IO.Handle.Types.BlockBuffering_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,108,111,99,107,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bo8: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.92452665 UTC

[section ""relreadonly" . GHC.IO.Handle.Types.HandleType_closure_tbl" {
     GHC.IO.Handle.Types.HandleType_closure_tbl:
         const GHC.IO.Handle.Types.ClosedHandle_closure+1;
         const GHC.IO.Handle.Types.SemiClosedHandle_closure+2;
         const GHC.IO.Handle.Types.ReadHandle_closure+3;
         const GHC.IO.Handle.Types.WriteHandle_closure+4;
         const GHC.IO.Handle.Types.AppendHandle_closure+5;
         const GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.925130586 UTC

[GHC.IO.Handle.Types.ClosedHandle_con_entry() //  [R1]
         { info_tbl: [(c8bo9,
                       label: GHC.IO.Handle.Types.ClosedHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,67,108,111,115,101,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bo9: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.925825654 UTC

[GHC.IO.Handle.Types.SemiClosedHandle_con_entry() //  [R1]
         { info_tbl: [(c8boa,
                       label: GHC.IO.Handle.Types.SemiClosedHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,83,101,109,105,67,108,111,115,101,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8boa: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.926521805 UTC

[GHC.IO.Handle.Types.ReadHandle_con_entry() //  [R1]
         { info_tbl: [(c8bob,
                       label: GHC.IO.Handle.Types.ReadHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,82,101,97,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bob: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.927224089 UTC

[GHC.IO.Handle.Types.WriteHandle_con_entry() //  [R1]
         { info_tbl: [(c8boc,
                       label: GHC.IO.Handle.Types.WriteHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,87,114,105,116,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8boc: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.927929189 UTC

[GHC.IO.Handle.Types.AppendHandle_con_entry() //  [R1]
         { info_tbl: [(c8bod,
                       label: GHC.IO.Handle.Types.AppendHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,65,112,112,101,110,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bod: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.92863922 UTC

[GHC.IO.Handle.Types.ReadWriteHandle_con_entry() //  [R1]
         { info_tbl: [(c8boe,
                       label: GHC.IO.Handle.Types.ReadWriteHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,82,101,97,100,87,114,105,116,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8boe: // global
           R1 = R1 + 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.929692312 UTC

[GHC.IO.Handle.Types.BufferListNil_con_entry() //  [R1]
         { info_tbl: [(c8bof,
                       label: GHC.IO.Handle.Types.BufferListNil_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,117,102,102,101,114,76,105,115,116,78,105,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bof: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.930393812 UTC

[GHC.IO.Handle.Types.BufferListCons_con_entry() //  [R1]
         { info_tbl: [(c8bog,
                       label: GHC.IO.Handle.Types.BufferListCons_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,117,102,102,101,114,76,105,115,116,67,111,110,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bog: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.931123912 UTC

[GHC.IO.Handle.Types.Handle___con_entry() //  [R1]
         { info_tbl: [(c8boh,
                       label: GHC.IO.Handle.Types.Handle___con_info
                       rep:HeapRep 16 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,72,97,110,100,108,101,95,95]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8boh: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.931854105 UTC

[GHC.IO.Handle.Types.FileHandle_con_entry() //  [R1]
         { info_tbl: [(c8boi,
                       label: GHC.IO.Handle.Types.FileHandle_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,70,105,108,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8boi: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.932563055 UTC

[GHC.IO.Handle.Types.DuplexHandle_con_entry() //  [R1]
         { info_tbl: [(c8boj,
                       label: GHC.IO.Handle.Types.DuplexHandle_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,68,117,112,108,101,120,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8boj: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.933284845 UTC

[section ""relreadonly" . S8alj_srt" {
     S8alj_srt:
         const GHC.IO.Handle.Types.$w$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowHandleType1_closure;
         const GHC.IO.Handle.Types.$fShowHandleType3_closure;
         const GHC.IO.Handle.Types.$fShowHandleType5_closure;
         const GHC.IO.Handle.Types.$fShowHandleType7_closure;
         const GHC.IO.Handle.Types.$fShowHandleType9_closure;
         const GHC.IO.Handle.Types.$fShowHandleType11_closure;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure;
         const GHC.IO.Handle.Types.$fReadNewline6_closure;
         const GHC.IO.Handle.Types.$fReadNewline10_closure;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowNewline1_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.IO.Handle.Types.$w$cshowsPrec1_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode1_closure;
         const GHC.Read.choose2_closure;
         const GHC.IO.Handle.Types.$fReadNewline_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.Handle.Types.$fReadNewline2_closure;
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Handle.Types.$fReadNewline1_closure;
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewline12_closure;
         const Text.Read.Lex.$wexpect_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode3_closure;
         const GHC.Read.readField_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode6_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode11_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode8_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode12_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure;
         const GHC.IO.Handle.Types.$w$creadPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode2_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode1_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode18_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode12_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode8_closure;
         const GHC.Show.$fShowMaybe_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode3_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode5_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode6_closure;
         const GHC.Show.$fShowMaybe1_closure;
         const GHC.Show.$fShowMaybe4_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode1_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_sps_closure;
         const GHC.Read.choose2_closure;
         const GHC.Read.$fReadInt_closure;
         const GHC.Read.$fReadMaybe1_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode2_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode1_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode14_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.934257895 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:16.935729196 UTC

[section ""data" . GHC.IO.Handle.Types.$WHandle___closure" {
     GHC.IO.Handle.Types.$WHandle___closure:
         const GHC.IO.Handle.Types.$WHandle___info;
 },
 GHC.IO.Handle.Types.$WHandle___slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bol: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Types.$WHandle___entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 96, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$WHandle___entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8bou,
                       label: GHC.IO.Handle.Types.$WHandle___info
                       rep:HeapRep static {
                             Fun {arity: 16
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bou: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8boN; else goto c8boO;
       c8boN: // global
           R1 = GHC.IO.Handle.Types.$WHandle___closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 136, res: 0, upd: 8;
       c8boO: // global
           I64[Sp - 40] = block_c8bop_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bop() //  [R1]
         { info_tbl: [(c8bop,
                       label: block_c8bop_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bop: // global
           I64[Sp] = block_c8bor_info;
           _s8a6z::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s8a6z::P64;
           if (R1 & 7 != 0) goto u8boW; else goto c8bos;
       u8boW: // global
           call _c8bor(R1) args: 0, res: 0, upd: 0;
       c8bos: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bor() //  [R1]
         { info_tbl: [(c8bor,
                       label: block_c8bor_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bor: // global
           I64[Sp] = block_c8box_info;
           _s8a6B::P64 = P64[R1 + 7];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _s8a6B::P64;
           if (R1 & 7 != 0) goto u8boX; else goto c8boy;
       u8boX: // global
           call _c8box(R1) args: 0, res: 0, upd: 0;
       c8boy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8box() //  [R1]
         { info_tbl: [(c8box,
                       label: block_c8box_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8box: // global
           I64[Sp] = block_c8boC_info;
           _s8a6D::P64 = P64[R1 + 7];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s8a6D::P64;
           if (R1 & 7 != 0) goto u8boY; else goto c8boD;
       u8boY: // global
           call _c8boC(R1) args: 0, res: 0, upd: 0;
       c8boD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8boC() //  [R1]
         { info_tbl: [(c8boC,
                       label: block_c8boC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8boC: // global
           I64[Sp] = block_c8boH_info;
           _s8a6F::P64 = P64[R1 + 7];
           R1 = P64[Sp + 72];
           P64[Sp + 72] = _s8a6F::P64;
           if (R1 & 7 != 0) goto u8boZ; else goto c8boI;
       u8boZ: // global
           call _c8boH(R1) args: 0, res: 0, upd: 0;
       c8boI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8boH() //  [R1]
         { info_tbl: [(c8boH,
                       label: block_c8boH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8boH: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8boV; else goto c8boU;
       c8boV: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8boU: // global
           _s8a6H::P64 = P64[R1 + 7];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 64];
           P64[Hp - 56] = P64[Sp + 72];
           P64[Hp - 48] = _s8a6H::P64;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = P64[Sp + 104];
           P64[Hp - 8] = P64[Sp + 112];
           P64[Hp] = P64[Sp + 120];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.938565285 UTC

[section ""data" . GHC.IO.Handle.Types.$WFileHandle_closure" {
     GHC.IO.Handle.Types.$WFileHandle_closure:
         const GHC.IO.Handle.Types.$WFileHandle_info;
 },
 GHC.IO.Handle.Types.$WFileHandle_entry() //  [R2, R3]
         { info_tbl: [(c8bp7,
                       label: GHC.IO.Handle.Types.$WFileHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bp7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bpb; else goto c8bpc;
       c8bpb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$WFileHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bpc: // global
           I64[Sp - 16] = block_c8bp4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bpg; else goto c8bp5;
       u8bpg: // global
           call _c8bp4(R1) args: 0, res: 0, upd: 0;
       c8bp5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bp4() //  [R1]
         { info_tbl: [(c8bp4,
                       label: block_c8bp4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bp4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bpf; else goto c8bpe;
       c8bpf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8bpe: // global
           _s8a6L::P64 = P64[R1 + 7];
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s8a6L::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.940090578 UTC

[section ""data" . GHC.IO.Handle.Types.$WDuplexHandle_closure" {
     GHC.IO.Handle.Types.$WDuplexHandle_closure:
         const GHC.IO.Handle.Types.$WDuplexHandle_info;
 },
 GHC.IO.Handle.Types.$WDuplexHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(c8bpo,
                       label: GHC.IO.Handle.Types.$WDuplexHandle_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bpo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8bpx; else goto c8bpy;
       c8bpx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$WDuplexHandle_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bpy: // global
           I64[Sp - 24] = block_c8bpl_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8bpE; else goto c8bpm;
       u8bpE: // global
           call _c8bpl(R1) args: 0, res: 0, upd: 0;
       c8bpm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bpl() //  [R1]
         { info_tbl: [(c8bpl,
                       label: block_c8bpl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bpl: // global
           I64[Sp] = block_c8bpr_info;
           _s8a6Q::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8a6Q::P64;
           if (R1 & 7 != 0) goto u8bpD; else goto c8bps;
       u8bpD: // global
           call _c8bpr(R1) args: 0, res: 0, upd: 0;
       c8bps: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bpr() //  [R1]
         { info_tbl: [(c8bpr,
                       label: block_c8bpr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bpr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8bpC; else goto c8bpB;
       c8bpC: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8bpB: // global
           _s8a6S::P64 = P64[R1 + 7];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s8a6S::P64;
           R1 = Hp - 22;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.941668085 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType12_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType12_bytes:
         I8[] [99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.943298374 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType11_closure" {
     GHC.IO.Handle.Types.$fShowHandleType11_closure:
         const GHC.IO.Handle.Types.$fShowHandleType11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType11_entry() //  [R1]
         { info_tbl: [(c8bpL,
                       label: GHC.IO.Handle.Types.$fShowHandleType11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bpL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bpM; else goto c8bpN;
       c8bpM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bpN: // global
           (_c8bpI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bpI::I64 == 0) goto c8bpK; else goto c8bpJ;
       c8bpK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bpJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bpI::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.944262899 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType10_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType10_bytes:
         I8[] [115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.945000691 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType9_closure" {
     GHC.IO.Handle.Types.$fShowHandleType9_closure:
         const GHC.IO.Handle.Types.$fShowHandleType9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType9_entry() //  [R1]
         { info_tbl: [(c8bpU,
                       label: GHC.IO.Handle.Types.$fShowHandleType9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bpU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bpV; else goto c8bpW;
       c8bpV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bpW: // global
           (_c8bpR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bpR::I64 == 0) goto c8bpT; else goto c8bpS;
       c8bpT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bpS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bpR::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.945971391 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType8_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType8_bytes:
         I8[] [114,101,97,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.946720155 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType7_closure" {
     GHC.IO.Handle.Types.$fShowHandleType7_closure:
         const GHC.IO.Handle.Types.$fShowHandleType7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType7_entry() //  [R1]
         { info_tbl: [(c8bq3,
                       label: GHC.IO.Handle.Types.$fShowHandleType7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bq3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bq4; else goto c8bq5;
       c8bq4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bq5: // global
           (_c8bq0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bq0::I64 == 0) goto c8bq2; else goto c8bq1;
       c8bq2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bq1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bq0::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.947599048 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType6_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType6_bytes:
         I8[] [119,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.948289813 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType5_closure" {
     GHC.IO.Handle.Types.$fShowHandleType5_closure:
         const GHC.IO.Handle.Types.$fShowHandleType5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType5_entry() //  [R1]
         { info_tbl: [(c8bqc,
                       label: GHC.IO.Handle.Types.$fShowHandleType5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bqc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bqd; else goto c8bqe;
       c8bqd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bqe: // global
           (_c8bq9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bq9::I64 == 0) goto c8bqb; else goto c8bqa;
       c8bqb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bqa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bq9::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.949183331 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType4_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType4_bytes:
         I8[] [119,114,105,116,97,98,108,101,32,40,97,112,112,101,110,100,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.949933196 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType3_closure" {
     GHC.IO.Handle.Types.$fShowHandleType3_closure:
         const GHC.IO.Handle.Types.$fShowHandleType3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType3_entry() //  [R1]
         { info_tbl: [(c8bql,
                       label: GHC.IO.Handle.Types.$fShowHandleType3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bql: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bqm; else goto c8bqn;
       c8bqm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bqn: // global
           (_c8bqi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bqi::I64 == 0) goto c8bqk; else goto c8bqj;
       c8bqk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bqj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bqi::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.95080795 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType2_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType2_bytes:
         I8[] [114,101,97,100,45,119,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.951505976 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType1_closure" {
     GHC.IO.Handle.Types.$fShowHandleType1_closure:
         const GHC.IO.Handle.Types.$fShowHandleType1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType1_entry() //  [R1]
         { info_tbl: [(c8bqu,
                       label: GHC.IO.Handle.Types.$fShowHandleType1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bqu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bqv; else goto c8bqw;
       c8bqv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bqw: // global
           (_c8bqr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bqr::I64 == 0) goto c8bqt; else goto c8bqs;
       c8bqt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bqs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bqr::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.952798738 UTC

[section ""data" . GHC.IO.Handle.Types.$w$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$w$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8bqM,
                       label: GHC.IO.Handle.Types.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bqM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bqN; else goto c8bqO;
       c8bqN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bqO: // global
           I64[Sp - 16] = block_c8bqB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8br7; else goto c8bqC;
       u8br7: // global
           call _c8bqB(R1) args: 0, res: 0, upd: 0;
       c8bqC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bqB() //  [R1]
         { info_tbl: [(c8bqB,
                       label: block_c8bqB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bqB: // global
           _s8a6U::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c8bqF;
               case 2 : goto c8bqG;
               case 3 : goto c8bqH;
               case 4 : goto c8bqI;
               case 5 : goto c8bqJ;
               case 6 : goto c8bqK;
           }
       c8bqK: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8bqJ: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8bqI: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8bqH: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8bqG: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8bqF: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.954362409 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_entry() //  [R3,
                                                               R4]
         { info_tbl: [(c8brc,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8brc: // global
           _s8a6X::P64 = R3;
           R3 = R4;
           R2 = _s8a6X::P64;
           call GHC.IO.Handle.Types.$w$cshowsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.955394101 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshow_entry() //  [R2]
         { info_tbl: [(c8bru,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bru: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8brv; else goto c8brw;
       c8brv: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8brw: // global
           I64[Sp - 8] = block_c8brj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8brP; else goto c8brk;
       u8brP: // global
           call _c8brj(R1) args: 0, res: 0, upd: 0;
       c8brk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8brj() //  [R1]
         { info_tbl: [(c8brj,
                       label: block_c8brj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8brj: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c8brn;
               case 2 : goto c8bro;
               case 3 : goto c8brp;
               case 4 : goto c8brq;
               case 5 : goto c8brr;
               case 6 : goto c8brs;
           }
       c8brs: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8brr: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8brq: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8brp: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8bro: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8brn: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.95678359 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshowList_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8brU,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8brU: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.958016755 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.959235088 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_$c==_closure" {
     GHC.IO.Handle.Types.$fEqHandle_$c==_closure:
         const GHC.IO.Handle.Types.$fEqHandle_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqHandle_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8bs8,
                       label: GHC.IO.Handle.Types.$fEqHandle_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bs8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bs9; else goto c8bsa;
       c8bs9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqHandle_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bsa: // global
           I64[Sp - 16] = block_c8bs1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bsN; else goto c8bs2;
       u8bsN: // global
           call _c8bs1(R1) args: 0, res: 0, upd: 0;
       c8bs2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bs1() //  [R1]
         { info_tbl: [(c8bs1,
                       label: block_c8bs1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bs1: // global
           _s8a74::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bs5; else goto c8bs6;
       c8bs5: // global
           I64[Sp] = block_c8bsd_info;
           _s8a77::P64 = P64[R1 + 15];
           R1 = _s8a74::P64;
           P64[Sp + 8] = _s8a77::P64;
           if (R1 & 7 != 0) goto u8bsL; else goto c8bsf;
       u8bsL: // global
           call _c8bsd(R1) args: 0, res: 0, upd: 0;
       c8bsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bs6: // global
           I64[Sp] = block_c8bss_info;
           _s8a7g::P64 = P64[R1 + 14];
           R1 = _s8a74::P64;
           P64[Sp + 8] = _s8a7g::P64;
           if (R1 & 7 != 0) goto u8bsM; else goto c8bsu;
       u8bsM: // global
           call _c8bss(R1) args: 0, res: 0, upd: 0;
       c8bsu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bsd() //  [R1]
         { info_tbl: [(c8bsd,
                       label: block_c8bsd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bsd: // global
           if (R1 & 7 == 1) goto c8bsl; else goto u8bsK;
       c8bsl: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8bsK: // global
           Sp = Sp + 16;
           call _c8bsA() args: 0, res: 0, upd: 0;
     }
 },
 _c8bss() //  [R1]
         { info_tbl: [(c8bss,
                       label: block_c8bss_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bss: // global
           if (R1 & 7 == 1) goto u8bsJ; else goto c8bsE;
       u8bsJ: // global
           Sp = Sp + 16;
           call _c8bsA() args: 0, res: 0, upd: 0;
       c8bsE: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 14]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bsA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bsA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.961662999 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqHandle_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqHandle_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqHandle_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8bt1,
                       label: GHC.IO.Handle.Types.$fEqHandle_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bt1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bt2; else goto c8bt3;
       c8bt2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqHandle_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bt3: // global
           I64[Sp - 16] = block_c8bsU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8buc; else goto c8bsV;
       u8buc: // global
           call _c8bsU(R1) args: 0, res: 0, upd: 0;
       c8bsV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bsU() //  [R1]
         { info_tbl: [(c8bsU,
                       label: block_c8bsU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bsU: // global
           _s8a7q::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bsY; else goto c8bsZ;
       c8bsY: // global
           I64[Sp] = block_c8bt6_info;
           _s8a7t::P64 = P64[R1 + 15];
           R1 = _s8a7q::P64;
           P64[Sp + 8] = _s8a7t::P64;
           if (R1 & 7 != 0) goto u8bua; else goto c8bt8;
       u8bua: // global
           call _c8bt6(R1) args: 0, res: 0, upd: 0;
       c8bt8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bsZ: // global
           I64[Sp] = block_c8btA_info;
           _s8a7C::P64 = P64[R1 + 14];
           R1 = _s8a7q::P64;
           P64[Sp + 8] = _s8a7C::P64;
           if (R1 & 7 != 0) goto u8bub; else goto c8btC;
       u8bub: // global
           call _c8btA(R1) args: 0, res: 0, upd: 0;
       c8btC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bt6() //  [R1]
         { info_tbl: [(c8bt6,
                       label: block_c8bt6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bt6: // global
           if (R1 & 7 == 1) goto c8btt; else goto u8bu7;
       c8btt: // global
           if (P64[Sp + 8] == P64[R1 + 15]) goto u8bu8; else goto u8bu9;
       u8bu8: // global
           Sp = Sp + 16;
           call _c8btX() args: 0, res: 0, upd: 0;
       u8bu9: // global
           Sp = Sp + 16;
           goto u8buf;
       u8bu7: // global
           Sp = Sp + 16;
           goto u8buf;
       u8buf: // global
           call _c8btR() args: 0, res: 0, upd: 0;
     }
 },
 _c8btA() //  [R1]
         { info_tbl: [(c8btA,
                       label: block_c8btA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8btA: // global
           if (R1 & 7 == 1) goto u8bu4; else goto c8bu1;
       u8bu4: // global
           Sp = Sp + 16;
           goto u8bui;
       c8bu1: // global
           if (P64[Sp + 8] == P64[R1 + 14]) goto u8bu5; else goto u8bu6;
       u8bu5: // global
           Sp = Sp + 16;
           call _c8btX() args: 0, res: 0, upd: 0;
       u8bu6: // global
           Sp = Sp + 16;
           goto u8bui;
       u8bui: // global
           call _c8btR() args: 0, res: 0, upd: 0;
     }
 },
 _c8btX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8btX: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8btR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8btR: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.963425707 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_closure" {
     GHC.IO.Handle.Types.$fEqHandle_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqHandle_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqHandle_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.963995093 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewline11_bytes" {
     GHC.IO.Handle.Types.$fReadNewline11_bytes:
         I8[] [76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.964730053 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline10_closure" {
     GHC.IO.Handle.Types.$fReadNewline10_closure:
         const GHC.IO.Handle.Types.$fReadNewline10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline10_entry() //  [R1]
         { info_tbl: [(c8bup,
                       label: GHC.IO.Handle.Types.$fReadNewline10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bup: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8buq; else goto c8bur;
       c8buq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bur: // global
           (_c8bum::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bum::I64 == 0) goto c8buo; else goto c8bun;
       c8buo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bun: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bum::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.965644839 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewline7_bytes" {
     GHC.IO.Handle.Types.$fReadNewline7_bytes:
         I8[] [67,82,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.966362782 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline6_closure" {
     GHC.IO.Handle.Types.$fReadNewline6_closure:
         const GHC.IO.Handle.Types.$fReadNewline6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline6_entry() //  [R1]
         { info_tbl: [(c8buy,
                       label: GHC.IO.Handle.Types.$fReadNewline6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8buy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8buz; else goto c8buA;
       c8buz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8buA: // global
           (_c8buv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8buv::I64 == 0) goto c8bux; else goto c8buw;
       c8bux: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8buw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8buv::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.967511045 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c8buM,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8buM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8buN; else goto c8buO;
       c8buN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8buO: // global
           I64[Sp - 16] = block_c8buF_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8buV; else goto c8buG;
       u8buV: // global
           call _c8buF(R1) args: 0, res: 0, upd: 0;
       c8buG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8buF() //  [R1]
         { info_tbl: [(c8buF,
                       label: block_c8buF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8buF: // global
           _s8a7N::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8buJ; else goto c8buK;
       c8buJ: // global
           R3 = _s8a7N::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8buK: // global
           R3 = _s8a7N::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.968849394 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshow_entry() //  [R2]
         { info_tbl: [(c8bv7,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bv7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8bv8; else goto c8bv9;
       c8bv8: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bv9: // global
           I64[Sp - 8] = block_c8bv0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bvg; else goto c8bv1;
       u8bvg: // global
           call _c8bv0(R1) args: 0, res: 0, upd: 0;
       c8bv1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bv0() //  [R1]
         { info_tbl: [(c8bv0,
                       label: block_c8bv0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bv0: // global
           if (R1 & 7 == 1) goto c8bv4; else goto c8bv5;
       c8bv4: // global
           R1 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8bv5: // global
           R1 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.970223596 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline1_closure" {
     GHC.IO.Handle.Types.$fShowNewline1_closure:
         const GHC.IO.Handle.Types.$fShowNewline1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline1_entry() //  [R2, R3]
         { info_tbl: [(c8bvs,
                       label: GHC.IO.Handle.Types.$fShowNewline1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bvs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bvt; else goto c8bvu;
       c8bvt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bvu: // global
           I64[Sp - 16] = block_c8bvl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bvB; else goto c8bvm;
       u8bvB: // global
           call _c8bvl(R1) args: 0, res: 0, upd: 0;
       c8bvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bvl() //  [R1]
         { info_tbl: [(c8bvl,
                       label: block_c8bvl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bvl: // global
           _s8a7S::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bvp; else goto c8bvq;
       c8bvp: // global
           R3 = _s8a7S::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8bvq: // global
           R3 = _s8a7S::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.971450486 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8bvG,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bvG: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowNewline1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.972206666 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_closure" {
     GHC.IO.Handle.Types.$fShowNewline_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.972826162 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode4_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode4_bytes:
         I8[] [78,101,119,108,105,110,101,77,111,100,101,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.974885299 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode3_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode3_bytes:
         I8[] [105,110,112,117,116,78,76,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.975561589 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode2_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode2_bytes:
         I8[] [111,117,116,112,117,116,78,76,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.976226852 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode5_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.979490854 UTC

[section ""data" . GHC.IO.Handle.Types.$w$cshowsPrec1_closure" {
     GHC.IO.Handle.Types.$w$cshowsPrec1_closure:
         const GHC.IO.Handle.Types.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$w$cshowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bvK: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a84_entry() //  [R1]
         { info_tbl: [(c8bwm,
                       label: sat_s8a84_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bwm: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a85_entry() //  [R1]
         { info_tbl: [(c8bwv,
                       label: sat_s8a85_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bwv: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a86_entry() //  [R1]
         { info_tbl: [(c8bwC,
                       label: sat_s8a86_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bwC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8bwD; else goto c8bwE;
       c8bwD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bwE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8bwd_info;
           _s8a81::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8a81::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8bwL; else goto c8bwe;
       u8bwL: // global
           call _c8bwd(R1) args: 0, res: 0, upd: 0;
       c8bwe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8bwd() //  [R1]
         { info_tbl: [(c8bwd,
                       label: block_c8bwd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bwd: // global
           _s8a81::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bwz; else goto c8bwA;
       c8bwz: // global
           Hp = Hp + 24;
           _s8a83::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8bwK; else goto c8bwG;
       c8bwG: // global
           I64[Hp - 16] = sat_s8a84_info;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c8bwA: // global
           Hp = Hp + 24;
           _s8a83::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8bwK; else goto c8bwJ;
       c8bwK: // global
           HpAlloc = 24;
           R1 = _s8a83::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8bwJ: // global
           I64[Hp - 16] = sat_s8a85_info;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8a87_entry() //  [R1]
         { info_tbl: [(c8bwM,
                       label: sat_s8a87_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bwM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8bwQ; else goto c8bwP;
       c8bwQ: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bwP: // global
           _s8a7Y::P64 = P64[R1 + 16];
           _s8a81::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8a86_info;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 karg_s8a82_entry() //  [R1]
         { info_tbl: [(c8bwR,
                       label: karg_s8a82_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bwR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8bwV; else goto c8bwU;
       c8bwV: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bwU: // global
           _s8a7Y::P64 = P64[R1 + 16];
           _s8a81::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8a87_info;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a89_entry() //  [R1]
         { info_tbl: [(c8bx3,
                       label: sat_s8a89_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bx3: // global
           _s8a89::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8bx4; else goto c8bx5;
       c8bx5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8bx7; else goto c8bx6;
       c8bx7: // global
           HpAlloc = 32;
           goto c8bx4;
       c8bx4: // global
           R1 = _s8a89::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bx6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8a89::P64;
           _s8a7X::P64 = P64[_s8a89::P64 + 16];
           _s8a7Y::P64 = P64[_s8a89::P64 + 24];
           _s8a81::P64 = P64[_s8a89::P64 + 32];
           I64[Hp - 24] = karg_s8a82_info;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           I64[Sp - 32] = block_c8bwW_info;
           R1 = _s8a7X::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8bxe; else goto c8bwX;
       u8bxe: // global
           call _c8bwW(R1) args: 0, res: 0, upd: 0;
       c8bwX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8bwW() //  [R1]
         { info_tbl: [(c8bwW,
                       label: block_c8bwW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bwW: // global
           _c8bw1::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bx0; else goto c8bx1;
       c8bx0: // global
           R3 = _c8bw1::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c8bx1: // global
           R3 = _c8bw1::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8a8a_entry() //  [R1]
         { info_tbl: [(c8bxf,
                       label: sat_s8a8a_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bxf: // global
           _s8a8a::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8bxg; else goto c8bxh;
       c8bxh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8bxj; else goto c8bxi;
       c8bxj: // global
           HpAlloc = 40;
           goto c8bxg;
       c8bxg: // global
           R1 = _s8a8a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bxi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8a8a::P64;
           _s8a7X::P64 = P64[_s8a8a::P64 + 16];
           _s8a7Y::P64 = P64[_s8a8a::P64 + 24];
           _s8a81::P64 = P64[_s8a8a::P64 + 32];
           I64[Hp - 32] = sat_s8a89_info;
           P64[Hp - 16] = _s8a7X::P64;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_s8a80_entry() //  [R1, R2]
         { info_tbl: [(c8bxk,
                       label: p_s8a80_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bxk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8bxo; else goto c8bxn;
       c8bxo: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bxn: // global
           _s8a7X::P64 = P64[R1 + 7];
           _s8a7Y::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s8a8a_info;
           P64[Hp - 16] = _s8a7X::P64;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8d_entry() //  [R1]
         { info_tbl: [(c8bxy,
                       label: sat_s8a8d_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bxy: // global
           _s8a8d::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8bxz; else goto c8bxA;
       c8bxA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bxC; else goto c8bxB;
       c8bxC: // global
           HpAlloc = 24;
           goto c8bxz;
       c8bxz: // global
           R1 = _s8a8d::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bxB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8a8d::P64;
           _s8a7Z::P64 = P64[_s8a8d::P64 + 16];
           _s8a80::P64 = P64[_s8a8d::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s8a7Z::P64;
           R2 = Hp - 14;
           R1 = _s8a80::P64;
           Sp = Sp - 16;
           call p_s8a80_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$w$cshowsPrec1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8bxG,
                       label: GHC.IO.Handle.Types.$w$cshowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bxG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8bxK; else goto c8bxJ;
       c8bxK: // global
           HpAlloc = 80;
           R1 = GHC.IO.Handle.Types.$w$cshowsPrec1_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c8bxJ: // global
           I64[Hp - 72] = p_s8a80_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           _c8bvO::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto c8bxE; else goto c8bxF;
       c8bxE: // global
           Hp = Hp - 56;
           R2 = R5;
           R1 = _c8bvO::P64;
           call p_s8a80_entry(R2, R1) args: 8, res: 0, upd: 8;
       c8bxF: // global
           I64[Hp - 48] = sat_s8a8d_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _c8bvO::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.985208771 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c8bxT,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bxT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8bxX; else goto c8bxY;
       c8bxX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bxY: // global
           I64[Sp - 24] = block_c8bxQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8by6; else goto c8bxR;
       u8by6: // global
           call _c8bxQ(R1) args: 0, res: 0, upd: 0;
       c8bxR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bxQ() //  [R1]
         { info_tbl: [(c8bxQ,
                       label: block_c8bxQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bxQ: // global
           I64[Sp] = block_c8bxW_info;
           _s8a8i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8a8i::I64;
           if (R1 & 7 != 0) goto u8by5; else goto c8by0;
       u8by5: // global
           call _c8bxW(R1) args: 0, res: 0, upd: 0;
       c8by0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bxW() //  [R1]
         { info_tbl: [(c8bxW,
                       label: block_c8bxW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bxW: // global
           R5 = P64[Sp + 16];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.986759065 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode2_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.987615311 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8bye,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bye: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8byf; else goto c8byg;
       c8byf: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8byg: // global
           I64[Sp - 8] = block_c8byb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8byk; else goto c8byc;
       u8byk: // global
           call _c8byb(R1) args: 0, res: 0, upd: 0;
       c8byc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8byb() //  [R1]
         { info_tbl: [(c8byb,
                       label: block_c8byb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8byb: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.989041365 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode1_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode1_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(c8bys,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bys: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8byt; else goto c8byu;
       c8byt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8byu: // global
           I64[Sp - 16] = block_c8byp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8byy; else goto c8byq;
       u8byy: // global
           call _c8byp(R1) args: 0, res: 0, upd: 0;
       c8byq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8byp() //  [R1]
         { info_tbl: [(c8byp,
                       label: block_c8byp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8byp: // global
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.990338957 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8byD,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8byD: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.991204404 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.991985 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline9_closure" {
     GHC.IO.Handle.Types.$fReadNewline9_closure:
         const GHC.IO.Handle.Types.$fReadNewline9_info;
 },
 GHC.IO.Handle.Types.$fReadNewline9_entry() //  [R3]
         { info_tbl: [(c8byK,
                       label: GHC.IO.Handle.Types.$fReadNewline9_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8byK: // global
           R2 = GHC.IO.Handle.Types.LF_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.99276552 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline8_closure" {
     GHC.IO.Handle.Types.$fReadNewline8_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadNewline10_closure;
         const GHC.IO.Handle.Types.$fReadNewline9_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.993894827 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline5_closure" {
     GHC.IO.Handle.Types.$fReadNewline5_closure:
         const GHC.IO.Handle.Types.$fReadNewline5_info;
 },
 GHC.IO.Handle.Types.$fReadNewline5_entry() //  [R3]
         { info_tbl: [(c8byR,
                       label: GHC.IO.Handle.Types.$fReadNewline5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8byR: // global
           R2 = GHC.IO.Handle.Types.CRLF_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.994709249 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline4_closure" {
     GHC.IO.Handle.Types.$fReadNewline4_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadNewline6_closure;
         const GHC.IO.Handle.Types.$fReadNewline5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.997137112 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline3_closure" {
     GHC.IO.Handle.Types.$fReadNewline3_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadNewline4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.997889937 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_sps_closure" {
     GHC.IO.Handle.Types.$fReadNewline_sps_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadNewline8_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.998785695 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline2_closure" {
     GHC.IO.Handle.Types.$fReadNewline2_closure:
         const GHC.IO.Handle.Types.$fReadNewline2_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline2_entry() //  [R2]
         { info_tbl: [(c8byY,
                       label: GHC.IO.Handle.Types.$fReadNewline2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8byY: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:16.999689295 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline1_closure" {
     GHC.IO.Handle.Types.$fReadNewline1_closure:
         const GHC.IO.Handle.Types.$fReadNewline1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline1_entry() //  [R2, R3]
         { info_tbl: [(c8bz5,
                       label: GHC.IO.Handle.Types.$fReadNewline1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bz5: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.000836197 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_info;
         const 0;
 },
 sat_s8a8D_entry() //  [R1]
         { info_tbl: [(c8bzg,
                       label: sat_s8a8D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bzg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bzh; else goto c8bzi;
       c8bzh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bzi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8bzj,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bzj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bzn; else goto c8bzm;
       c8bzn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bzm: // global
           I64[Hp - 16] = sat_s8a8D_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.002370466 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8bzu,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bzu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bzv; else goto c8bzw;
       c8bzv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bzw: // global
           (_c8bzr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bzr::I64 == 0) goto c8bzt; else goto c8bzs;
       c8bzt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bzs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bzr::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.00363365 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline12_closure" {
     GHC.IO.Handle.Types.$fReadNewline12_closure:
         const GHC.IO.Handle.Types.$fReadNewline12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline12_entry() //  [R1]
         { info_tbl: [(c8bzD,
                       label: GHC.IO.Handle.Types.$fReadNewline12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bzD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bzE; else goto c8bzF;
       c8bzE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bzF: // global
           (_c8bzA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bzA::I64 == 0) goto c8bzC; else goto c8bzB;
       c8bzC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bzB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bzA::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.004923588 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadList_entry() //  [R2]
         { info_tbl: [(c8bzK,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bzK: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.005881073 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_closure" {
     GHC.IO.Handle.Types.$fReadNewline_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline1_closure+2;
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.006559707 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode17_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode17_bytes:
         I8[] [78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.007429583 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode16_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode16_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode16_entry() //  [R1]
         { info_tbl: [(c8bzT,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bzT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bzU; else goto c8bzV;
       c8bzU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bzV: // global
           (_c8bzQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bzQ::I64 == 0) goto c8bzS; else goto c8bzR;
       c8bzS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bzR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bzQ::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.008607735 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode16_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.009486397 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode15_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode15_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.010293083 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode14_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode14_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode14_entry() //  [R1]
         { info_tbl: [(c8bA2,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bA2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bA3; else goto c8bA4;
       c8bA3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bA4: // global
           (_c8bzZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bzZ::I64 == 0) goto c8bA1; else goto c8bA0;
       c8bA1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bA0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bzZ::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.011396498 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.012086785 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode13_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode13_bytes:
         I8[] [105,110,112,117,116,78,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.012888508 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode12_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode12_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode12_entry() //  [R1]
         { info_tbl: [(c8bAb,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bAb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bAc; else goto c8bAd;
       c8bAc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bAd: // global
           (_c8bA8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bA8::I64 == 0) goto c8bAa; else goto c8bA9;
       c8bAa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bA9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bA8::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.014109823 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode11_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode11_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode11_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode11_entry() //  [R3]
         { info_tbl: [(c8bAi,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bAi: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.014982793 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_n_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_n_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.01568449 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode10_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode10_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.016494705 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode9_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode9_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode9_entry() //  [R1]
         { info_tbl: [(c8bAr,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bAr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bAs; else goto c8bAt;
       c8bAs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bAt: // global
           (_c8bAo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bAo::I64 == 0) goto c8bAq; else goto c8bAp;
       c8bAq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bAp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bAo::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.017574996 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode8_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode8_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode9_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.018249456 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode7_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode7_bytes:
         I8[] [111,117,116,112,117,116,78,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.018987018 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode6_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode6_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode6_entry() //  [R1]
         { info_tbl: [(c8bAA,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bAA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bAB; else goto c8bAC;
       c8bAB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bAC: // global
           (_c8bAx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bAx::I64 == 0) goto c8bAz; else goto c8bAy;
       c8bAz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bAy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bAx::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.020216482 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode4_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode4_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode4_entry() //  [R1]
         { info_tbl: [(c8bAJ,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bAJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bAK; else goto c8bAL;
       c8bAK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bAL: // global
           (_c8bAG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bAG::I64 == 0) goto c8bAI; else goto c8bAH;
       c8bAI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bAH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bAG::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.021272128 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode3_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode3_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.02362163 UTC

[section ""data" . GHC.IO.Handle.Types.$w$creadPrec_closure" {
     GHC.IO.Handle.Types.$w$creadPrec_closure:
         const GHC.IO.Handle.Types.$w$creadPrec_info;
         const 0;
 },
 sat_s8a8Q_entry() //  [R1, R2]
         { info_tbl: [(c8bBp,
                       label: sat_s8a8Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bBp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bBt; else goto c8bBs;
       c8bBt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bBs: // global
           _s8a8H::P64 = P64[R1 + 7];
           _s8a8L::P64 = P64[R1 + 15];
           _s8a8N::P64 = P64[R1 + 23];
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = _s8a8L::P64;
           P64[Hp] = _s8a8N::P64;
           R2 = Hp - 15;
           R1 = _s8a8H::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8T_entry() //  [R1, R2]
         { info_tbl: [(c8bBx,
                       label: sat_s8a8T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bBx: // global
           _s8a8N::P64 = R2;
           _s8a8T::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8bBy; else goto c8bBz;
       c8bBz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8bBB; else goto c8bBA;
       c8bBB: // global
           HpAlloc = 32;
           goto c8bBy;
       c8bBy: // global
           R2 = _s8a8N::P64;
           R1 = _s8a8T::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bBA: // global
           _s8a8H::P64 = P64[_s8a8T::P64 + 7];
           _s8a8L::P64 = P64[_s8a8T::P64 + 15];
           I64[Hp - 24] = sat_s8a8Q_info;
           P64[Hp - 16] = _s8a8H::P64;
           P64[Hp - 8] = _s8a8L::P64;
           P64[Hp] = _s8a8N::P64;
           I64[Sp - 8] = block_c8bBu_info;
           R3 = Hp - 23;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8bBu() //  [R1]
         { info_tbl: [(c8bBu,
                       label: block_c8bBu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bBu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bBE; else goto c8bBD;
       c8bBE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8bBD: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8U_entry() //  [R1, R2]
         { info_tbl: [(c8bBF,
                       label: sat_s8a8U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bBF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bBJ; else goto c8bBI;
       c8bBJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bBI: // global
           _s8a8H::P64 = P64[R1 + 7];
           _s8a8L::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8a8T_info;
           P64[Hp - 8] = _s8a8H::P64;
           P64[Hp] = _s8a8L::P64;
           R5 = Hp - 15;
           R4 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode11_closure+2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8X_entry() //  [R1, R2]
         { info_tbl: [(c8bBN,
                       label: sat_s8a8X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bBN: // global
           _s8a8L::P64 = R2;
           _s8a8X::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8bBO; else goto c8bBP;
       c8bBP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bBR; else goto c8bBQ;
       c8bBR: // global
           HpAlloc = 24;
           goto c8bBO;
       c8bBO: // global
           R2 = _s8a8L::P64;
           R1 = _s8a8X::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bBQ: // global
           _s8a8H::P64 = P64[_s8a8X::P64 + 7];
           I64[Hp - 16] = sat_s8a8U_info;
           P64[Hp - 8] = _s8a8H::P64;
           P64[Hp] = _s8a8L::P64;
           I64[Sp - 8] = block_c8bBK_info;
           R3 = Hp - 15;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode8_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8bBK() //  [R1]
         { info_tbl: [(c8bBK,
                       label: block_c8bBK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bBK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bBU; else goto c8bBT;
       c8bBU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8bBT: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8Y_entry() //  [R1, R2]
         { info_tbl: [(c8bBV,
                       label: sat_s8a8Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bBV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bBZ; else goto c8bBY;
       c8bBZ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bBY: // global
           _s8a8H::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8a8X_info;
           P64[Hp] = _s8a8H::P64;
           R5 = Hp - 7;
           R4 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode11_closure+2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode12_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a91_entry() //  [R1, R2]
         { info_tbl: [(c8bC3,
                       label: sat_s8a91_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bC3: // global
           _s8a8J::P64 = R2;
           _s8a91::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8bC4; else goto c8bC5;
       c8bC5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bC7; else goto c8bC6;
       c8bC7: // global
           HpAlloc = 16;
           goto c8bC4;
       c8bC4: // global
           R2 = _s8a8J::P64;
           R1 = _s8a91::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bC6: // global
           _s8a8H::P64 = P64[_s8a91::P64 + 7];
           I64[Hp - 8] = sat_s8a8Y_info;
           P64[Hp] = _s8a8H::P64;
           I64[Sp - 8] = block_c8bC0_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8bC0() //  [R1]
         { info_tbl: [(c8bC0,
                       label: block_c8bC0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bC0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bCa; else goto c8bC9;
       c8bCa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8bC9: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(c8bCe,
                       label: GHC.IO.Handle.Types.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bCe: // global
           _s8a8H::P64 = R3;
           _s8a8G::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c8bCf; else goto c8bCg;
       c8bCg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bCi; else goto c8bCh;
       c8bCi: // global
           HpAlloc = 16;
           goto c8bCf;
       c8bCf: // global
           R3 = _s8a8H::P64;
           R2 = _s8a8G::I64;
           R1 = GHC.IO.Handle.Types.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bCh: // global
           if (%MO_S_Gt_W64(_s8a8G::I64, 11)) goto c8bCc; else goto c8bCd;
       c8bCc: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8bCd: // global
           I64[Hp - 8] = sat_s8a91_info;
           P64[Hp] = _s8a8H::P64;
           I64[Sp - 8] = block_c8bCj_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8bCj() //  [R1]
         { info_tbl: [(c8bCj,
                       label: block_c8bCj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bCj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8bCo; else goto c8bCn;
       c8bCo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8bCn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.028480563 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode2_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode2_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode2_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode2_entry() //  [R2, R3]
         { info_tbl: [(c8bCw,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bCw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bCx; else goto c8bCy;
       c8bCx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bCy: // global
           I64[Sp - 16] = block_c8bCt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bCC; else goto c8bCu;
       u8bCC: // global
           call _c8bCt(R1) args: 0, res: 0, upd: 0;
       c8bCu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bCt() //  [R1]
         { info_tbl: [(c8bCt,
                       label: block_c8bCt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bCt: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.$w$creadPrec_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.029885913 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode1_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode1_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(c8bCH,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bCH: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.031093328 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_info;
         const 0;
 },
 sat_s8a99_entry() //  [R1]
         { info_tbl: [(c8bCS,
                       label: sat_s8a99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bCS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bCT; else goto c8bCU;
       c8bCT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bCU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8bCV,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bCV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8bCZ; else goto c8bCY;
       c8bCZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8bCY: // global
           I64[Hp - 16] = sat_s8a99_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.032451128 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8bD6,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bD6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bD7; else goto c8bD8;
       c8bD7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bD8: // global
           (_c8bD3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bD3::I64 == 0) goto c8bD5; else goto c8bD4;
       c8bD5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bD4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bD3::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.033710596 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode18_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode18_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode18_entry() //  [R1]
         { info_tbl: [(c8bDf,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bDf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bDg; else goto c8bDh;
       c8bDg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bDh: // global
           (_c8bDc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bDc::I64 == 0) goto c8bDe; else goto c8bDd;
       c8bDe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bDd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bDc::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.03475898 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_entry() //  [R2]
         { info_tbl: [(c8bDm,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bDm: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode18_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.035481122 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadNewlineMode1_closure+2;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.036497811 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8bDA,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bDA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bDB; else goto c8bDC;
       c8bDB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bDC: // global
           I64[Sp - 16] = block_c8bDt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bE4; else goto c8bDu;
       u8bE4: // global
           call _c8bDt(R1) args: 0, res: 0, upd: 0;
       c8bDu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bDt() //  [R1]
         { info_tbl: [(c8bDt,
                       label: block_c8bDt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bDt: // global
           _s8a9b::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bDx; else goto c8bDy;
       c8bDx: // global
           I64[Sp + 8] = block_c8bDF_info;
           R1 = _s8a9b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bE2; else goto c8bDH;
       u8bE2: // global
           call _c8bDF(R1) args: 0, res: 0, upd: 0;
       c8bDH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bDy: // global
           I64[Sp + 8] = block_c8bDU_info;
           R1 = _s8a9b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bE3; else goto c8bDW;
       u8bE3: // global
           call _c8bDU() args: 0, res: 0, upd: 0;
       c8bDW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bDF() //  [R1]
         { info_tbl: [(c8bDF,
                       label: block_c8bDF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bDF: // global
           if (R1 & 7 == 1) goto c8bDN; else goto c8bDR;
       c8bDN: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8bDR: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bDU() //  []
         { info_tbl: [(c8bDU,
                       label: block_c8bDU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bDU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.038669044 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8bEg,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bEg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bEh; else goto c8bEi;
       c8bEh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bEi: // global
           I64[Sp - 16] = block_c8bE9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bET; else goto c8bEa;
       u8bET: // global
           call _c8bE9(R1) args: 0, res: 0, upd: 0;
       c8bEa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bE9() //  [R1]
         { info_tbl: [(c8bE9,
                       label: block_c8bE9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bE9: // global
           _s8a9g::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bEd; else goto c8bEe;
       c8bEd: // global
           I64[Sp + 8] = block_c8bEl_info;
           R1 = _s8a9g::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bER; else goto c8bEn;
       u8bER: // global
           call _c8bEl(R1) args: 0, res: 0, upd: 0;
       c8bEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bEe: // global
           I64[Sp + 8] = block_c8bEA_info;
           R1 = _s8a9g::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bES; else goto c8bEC;
       u8bES: // global
           call _c8bEA(R1) args: 0, res: 0, upd: 0;
       c8bEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bEl() //  [R1]
         { info_tbl: [(c8bEl,
                       label: block_c8bEl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bEl: // global
           if (R1 & 7 == 1) goto u8bEQ; else goto c8bEx;
       u8bEQ: // global
           Sp = Sp + 8;
           call _c8bEM() args: 0, res: 0, upd: 0;
       c8bEx: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bEA() //  [R1]
         { info_tbl: [(c8bEA,
                       label: block_c8bEA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bEA: // global
           if (R1 & 7 == 1) goto c8bEI; else goto u8bEP;
       c8bEI: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8bEP: // global
           Sp = Sp + 8;
           call _c8bEM() args: 0, res: 0, upd: 0;
     }
 },
 _c8bEM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bEM: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.040739545 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_$c==_closure" {
     GHC.IO.Handle.Types.$fEqNewline_$c==_closure:
         const GHC.IO.Handle.Types.$fEqNewline_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqNewline_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8bF7,
                       label: GHC.IO.Handle.Types.$fEqNewline_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bF7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bF8; else goto c8bF9;
       c8bF8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewline_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bF9: // global
           I64[Sp - 16] = block_c8bF0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bFM; else goto c8bF1;
       u8bFM: // global
           call _c8bF0(R1) args: 0, res: 0, upd: 0;
       c8bF1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bF0() //  [R1]
         { info_tbl: [(c8bF0,
                       label: block_c8bF0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bF0: // global
           _s8a9l::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bF4; else goto c8bF5;
       c8bF4: // global
           I64[Sp + 8] = block_c8bFc_info;
           R1 = _s8a9l::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bFK; else goto c8bFe;
       u8bFK: // global
           call _c8bFc(R1) args: 0, res: 0, upd: 0;
       c8bFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bF5: // global
           I64[Sp + 8] = block_c8bFr_info;
           R1 = _s8a9l::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bFL; else goto c8bFt;
       u8bFL: // global
           call _c8bFr(R1) args: 0, res: 0, upd: 0;
       c8bFt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bFc() //  [R1]
         { info_tbl: [(c8bFc,
                       label: block_c8bFc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bFc: // global
           if (R1 & 7 == 1) goto u8bFI; else goto u8bFJ;
       u8bFI: // global
           Sp = Sp + 8;
           call _c8bFD() args: 0, res: 0, upd: 0;
       u8bFJ: // global
           Sp = Sp + 8;
           call _c8bFz() args: 0, res: 0, upd: 0;
     }
 },
 _c8bFr() //  [R1]
         { info_tbl: [(c8bFr,
                       label: block_c8bFr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bFr: // global
           if (R1 & 7 == 1) goto u8bFG; else goto u8bFH;
       u8bFG: // global
           Sp = Sp + 8;
           call _c8bFz() args: 0, res: 0, upd: 0;
       u8bFH: // global
           Sp = Sp + 8;
           call _c8bFD() args: 0, res: 0, upd: 0;
     }
 },
 _c8bFz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bFz: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bFD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bFD: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.042905657 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqNewline_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqNewline_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqNewline_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8bG2,
                       label: GHC.IO.Handle.Types.$fEqNewline_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bG2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bG3; else goto c8bG4;
       c8bG3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewline_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bG4: // global
           I64[Sp - 16] = block_c8bFV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bGH; else goto c8bFW;
       u8bGH: // global
           call _c8bFV(R1) args: 0, res: 0, upd: 0;
       c8bFW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bFV() //  [R1]
         { info_tbl: [(c8bFV,
                       label: block_c8bFV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bFV: // global
           _s8a9q::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bFZ; else goto c8bG0;
       c8bFZ: // global
           I64[Sp + 8] = block_c8bG7_info;
           R1 = _s8a9q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bGF; else goto c8bG9;
       u8bGF: // global
           call _c8bG7(R1) args: 0, res: 0, upd: 0;
       c8bG9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bG0: // global
           I64[Sp + 8] = block_c8bGm_info;
           R1 = _s8a9q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bGG; else goto c8bGo;
       u8bGG: // global
           call _c8bGm(R1) args: 0, res: 0, upd: 0;
       c8bGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bG7() //  [R1]
         { info_tbl: [(c8bG7,
                       label: block_c8bG7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bG7: // global
           if (R1 & 7 == 1) goto u8bGD; else goto u8bGE;
       u8bGD: // global
           Sp = Sp + 8;
           call _c8bGy() args: 0, res: 0, upd: 0;
       u8bGE: // global
           Sp = Sp + 8;
           call _c8bGu() args: 0, res: 0, upd: 0;
     }
 },
 _c8bGm() //  [R1]
         { info_tbl: [(c8bGm,
                       label: block_c8bGm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bGm: // global
           if (R1 & 7 == 1) goto u8bGB; else goto u8bGC;
       u8bGB: // global
           Sp = Sp + 8;
           call _c8bGu() args: 0, res: 0, upd: 0;
       u8bGC: // global
           Sp = Sp + 8;
           call _c8bGy() args: 0, res: 0, upd: 0;
     }
 },
 _c8bGu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bGu: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bGy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bGy: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.044523512 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_closure" {
     GHC.IO.Handle.Types.$fEqNewline_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqNewline_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqNewline_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.045493271 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8bGX,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bGX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bGY; else goto c8bGZ;
       c8bGY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bGZ: // global
           I64[Sp - 16] = block_c8bGQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bHr; else goto c8bGR;
       u8bHr: // global
           call _c8bGQ(R1) args: 0, res: 0, upd: 0;
       c8bGR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bGQ() //  [R1]
         { info_tbl: [(c8bGQ,
                       label: block_c8bGQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bGQ: // global
           _s8a9u::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bGU; else goto c8bGV;
       c8bGU: // global
           I64[Sp + 8] = block_c8bH2_info;
           R1 = _s8a9u::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bHp; else goto c8bH4;
       u8bHp: // global
           call _c8bH2(R1) args: 0, res: 0, upd: 0;
       c8bH4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bGV: // global
           I64[Sp + 8] = block_c8bHh_info;
           R1 = _s8a9u::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bHq; else goto c8bHj;
       u8bHq: // global
           call _c8bHh() args: 0, res: 0, upd: 0;
       c8bHj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bH2() //  [R1]
         { info_tbl: [(c8bH2,
                       label: block_c8bH2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bH2: // global
           if (R1 & 7 == 1) goto c8bHa; else goto c8bHe;
       c8bHa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8bHe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bHh() //  []
         { info_tbl: [(c8bHh,
                       label: block_c8bHh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bHh: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.047216586 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8bHD,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bHD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bHE; else goto c8bHF;
       c8bHE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bHF: // global
           I64[Sp - 16] = block_c8bHw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bHT; else goto c8bHx;
       u8bHT: // global
           call _c8bHw(R1) args: 0, res: 0, upd: 0;
       c8bHx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bHw() //  [R1]
         { info_tbl: [(c8bHw,
                       label: block_c8bHw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bHw: // global
           _s8a9z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bHA; else goto c8bHB;
       c8bHA: // global
           R1 = _s8a9z::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8bHB: // global
           I64[Sp + 8] = block_c8bHL_info;
           R1 = _s8a9z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bHS; else goto c8bHN;
       u8bHS: // global
           call _c8bHL() args: 0, res: 0, upd: 0;
       c8bHN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bHL() //  []
         { info_tbl: [(c8bHL,
                       label: block_c8bHL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bHL: // global
           R1 = GHC.IO.Handle.Types.CRLF_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.048888279 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8bI5,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bI5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bI6; else goto c8bI7;
       c8bI6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bI7: // global
           I64[Sp - 16] = block_c8bHY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bIz; else goto c8bHZ;
       u8bIz: // global
           call _c8bHY(R1) args: 0, res: 0, upd: 0;
       c8bHZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bHY() //  [R1]
         { info_tbl: [(c8bHY,
                       label: block_c8bHY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bHY: // global
           _s8a9E::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bI2; else goto c8bI3;
       c8bI2: // global
           I64[Sp + 8] = block_c8bIa_info;
           R1 = _s8a9E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bIx; else goto c8bIc;
       u8bIx: // global
           call _c8bIa(R1) args: 0, res: 0, upd: 0;
       c8bIc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bI3: // global
           I64[Sp + 8] = block_c8bIp_info;
           R1 = _s8a9E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bIy; else goto c8bIr;
       u8bIy: // global
           call _c8bIp() args: 0, res: 0, upd: 0;
       c8bIr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bIa() //  [R1]
         { info_tbl: [(c8bIa,
                       label: block_c8bIa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bIa: // global
           if (R1 & 7 == 1) goto c8bIi; else goto c8bIm;
       c8bIi: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8bIm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bIp() //  []
         { info_tbl: [(c8bIp,
                       label: block_c8bIp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bIp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.052466294 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8bIE,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bIE: // global
           _s8a9J::P64 = R3;
           R3 = R2;
           R2 = _s8a9J::P64;
           call GHC.IO.Handle.Types.$fOrdNewline_$c<_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.053574126 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8bIS,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bIS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bIT; else goto c8bIU;
       c8bIT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bIU: // global
           I64[Sp - 16] = block_c8bIL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bJ8; else goto c8bIM;
       u8bJ8: // global
           call _c8bIL(R1) args: 0, res: 0, upd: 0;
       c8bIM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bIL() //  [R1]
         { info_tbl: [(c8bIL,
                       label: block_c8bIL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bIL: // global
           _s8a9K::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bIP; else goto c8bIQ;
       c8bIP: // global
           I64[Sp + 8] = block_c8bIX_info;
           R1 = _s8a9K::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8bJ7; else goto c8bIZ;
       u8bJ7: // global
           call _c8bIX() args: 0, res: 0, upd: 0;
       c8bIZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bIQ: // global
           R1 = _s8a9K::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bIX() //  []
         { info_tbl: [(c8bIX,
                       label: block_c8bIX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bIX: // global
           R1 = GHC.IO.Handle.Types.LF_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.054835951 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqNewline_closure+1;
         const GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.056003019 UTC

[section ""data" . GHC.IO.Handle.Types.$w$ccompare_closure" {
     GHC.IO.Handle.Types.$w$ccompare_closure:
         const GHC.IO.Handle.Types.$w$ccompare_info;
 },
 GHC.IO.Handle.Types.$w$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8bJk,
                       label: GHC.IO.Handle.Types.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bJk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8bJl; else goto c8bJm;
       c8bJl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$ccompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bJm: // global
           I64[Sp - 32] = block_c8bJd_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8bJX; else goto c8bJe;
       u8bJX: // global
           call _c8bJd(R1) args: 0, res: 0, upd: 0;
       c8bJe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bJd() //  [R1]
         { info_tbl: [(c8bJd,
                       label: block_c8bJd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bJd: // global
           _s8a9Q::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8bJh; else goto c8bJi;
       c8bJh: // global
           I64[Sp] = block_c8bJp_info;
           R1 = _s8a9Q::P64;
           if (R1 & 7 != 0) goto u8bJV; else goto c8bJr;
       u8bJV: // global
           call _c8bJp(R1) args: 0, res: 0, upd: 0;
       c8bJr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bJi: // global
           I64[Sp] = block_c8bJE_info;
           R1 = _s8a9Q::P64;
           if (R1 & 7 != 0) goto u8bJW; else goto c8bJG;
       u8bJW: // global
           call _c8bJE(R1) args: 0, res: 0, upd: 0;
       c8bJG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bJp() //  [R1]
         { info_tbl: [(c8bJp,
                       label: block_c8bJp_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bJp: // global
           if (R1 & 7 == 1) goto u8bJU; else goto c8bJB;
       u8bJU: // global
           Sp = Sp + 8;
           call _c8bJQ() args: 0, res: 0, upd: 0;
       c8bJB: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bJE() //  [R1]
         { info_tbl: [(c8bJE,
                       label: block_c8bJE_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bJE: // global
           if (R1 & 7 == 1) goto c8bJM; else goto u8bJT;
       c8bJM: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8bJT: // global
           Sp = Sp + 8;
           call _c8bJQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8bJQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bJQ: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fOrdNewline_$ccompare_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.057978979 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8bK7,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bK7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8bKb; else goto c8bKc;
       c8bKb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bKc: // global
           I64[Sp - 16] = block_c8bK4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bKk; else goto c8bK5;
       u8bKk: // global
           call _c8bK4(R1) args: 0, res: 0, upd: 0;
       c8bK5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bK4() //  [R1]
         { info_tbl: [(c8bK4,
                       label: block_c8bK4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bK4: // global
           I64[Sp - 8] = block_c8bKa_info;
           _s8a9Y::P64 = P64[R1 + 7];
           _s8a9Z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8a9Z::P64;
           P64[Sp + 8] = _s8a9Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bKj; else goto c8bKe;
       u8bKj: // global
           call _c8bKa(R1) args: 0, res: 0, upd: 0;
       c8bKe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bKa() //  [R1]
         { info_tbl: [(c8bKa,
                       label: block_c8bKa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bKa: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$ccompare_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.059761454 UTC

[section ""data" . GHC.IO.Handle.Types.$w$c<_closure" {
     GHC.IO.Handle.Types.$w$c<_closure:
         const GHC.IO.Handle.Types.$w$c<_info;
 },
 GHC.IO.Handle.Types.$w$c<_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8bKw,
                       label: GHC.IO.Handle.Types.$w$c<_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bKw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8bKx; else goto c8bKy;
       c8bKx: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$c<_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bKy: // global
           I64[Sp - 32] = block_c8bKp_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8bL9; else goto c8bKq;
       u8bL9: // global
           call _c8bKp(R1) args: 0, res: 0, upd: 0;
       c8bKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bKp() //  [R1]
         { info_tbl: [(c8bKp,
                       label: block_c8bKp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bKp: // global
           _s8aa5::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8bKt; else goto c8bKu;
       c8bKt: // global
           I64[Sp] = block_c8bKB_info;
           R1 = _s8aa5::P64;
           if (R1 & 7 != 0) goto u8bL7; else goto c8bKD;
       u8bL7: // global
           call _c8bKB(R1) args: 0, res: 0, upd: 0;
       c8bKD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bKu: // global
           I64[Sp] = block_c8bKQ_info;
           R1 = _s8aa5::P64;
           if (R1 & 7 != 0) goto u8bL8; else goto c8bKS;
       u8bL8: // global
           call _c8bKQ(R1) args: 0, res: 0, upd: 0;
       c8bKS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bKB() //  [R1]
         { info_tbl: [(c8bKB,
                       label: block_c8bKB_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bKB: // global
           if (R1 & 7 == 1) goto u8bL6; else goto c8bKN;
       u8bL6: // global
           Sp = Sp + 8;
           call _c8bL2() args: 0, res: 0, upd: 0;
       c8bKN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bKQ() //  [R1]
         { info_tbl: [(c8bKQ,
                       label: block_c8bKQ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bKQ: // global
           if (R1 & 7 == 1) goto c8bKY; else goto u8bL5;
       c8bKY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8bL5: // global
           Sp = Sp + 8;
           call _c8bL2() args: 0, res: 0, upd: 0;
     }
 },
 _c8bL2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bL2: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fOrdNewline_$c<_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.06170533 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8bLj,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bLj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8bLn; else goto c8bLo;
       c8bLn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bLo: // global
           I64[Sp - 16] = block_c8bLg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bLw; else goto c8bLh;
       u8bLw: // global
           call _c8bLg(R1) args: 0, res: 0, upd: 0;
       c8bLh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bLg() //  [R1]
         { info_tbl: [(c8bLg,
                       label: block_c8bLg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bLg: // global
           I64[Sp - 8] = block_c8bLm_info;
           _s8aad::P64 = P64[R1 + 7];
           _s8aae::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aae::P64;
           P64[Sp + 8] = _s8aad::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bLv; else goto c8bLq;
       u8bLv: // global
           call _c8bLm(R1) args: 0, res: 0, upd: 0;
       c8bLq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bLm() //  [R1]
         { info_tbl: [(c8bLm,
                       label: block_c8bLm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bLm: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$c<_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.063497977 UTC

[section ""data" . GHC.IO.Handle.Types.$w$c==_closure" {
     GHC.IO.Handle.Types.$w$c==_closure:
         const GHC.IO.Handle.Types.$w$c==_info;
 },
 GHC.IO.Handle.Types.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8bLI,
                       label: GHC.IO.Handle.Types.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bLI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8bLJ; else goto c8bLK;
       c8bLJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bLK: // global
           I64[Sp - 32] = block_c8bLB_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8bMn; else goto c8bLC;
       u8bMn: // global
           call _c8bLB(R1) args: 0, res: 0, upd: 0;
       c8bLC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bLB() //  [R1]
         { info_tbl: [(c8bLB,
                       label: block_c8bLB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bLB: // global
           _s8aak::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8bLF; else goto c8bLG;
       c8bLF: // global
           I64[Sp] = block_c8bLN_info;
           R1 = _s8aak::P64;
           if (R1 & 7 != 0) goto u8bMl; else goto c8bLP;
       u8bMl: // global
           call _c8bLN(R1) args: 0, res: 0, upd: 0;
       c8bLP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bLG: // global
           I64[Sp] = block_c8bM2_info;
           R1 = _s8aak::P64;
           if (R1 & 7 != 0) goto u8bMm; else goto c8bM4;
       u8bMm: // global
           call _c8bM2(R1) args: 0, res: 0, upd: 0;
       c8bM4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bLN() //  [R1]
         { info_tbl: [(c8bLN,
                       label: block_c8bLN_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bLN: // global
           if (R1 & 7 == 1) goto u8bMj; else goto u8bMk;
       u8bMj: // global
           Sp = Sp + 8;
           call _c8bMe() args: 0, res: 0, upd: 0;
       u8bMk: // global
           Sp = Sp + 32;
           call _c8bMa() args: 0, res: 0, upd: 0;
     }
 },
 _c8bM2() //  [R1]
         { info_tbl: [(c8bM2,
                       label: block_c8bM2_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bM2: // global
           if (R1 & 7 == 1) goto u8bMh; else goto u8bMi;
       u8bMh: // global
           Sp = Sp + 32;
           call _c8bMa() args: 0, res: 0, upd: 0;
       u8bMi: // global
           Sp = Sp + 8;
           call _c8bMe() args: 0, res: 0, upd: 0;
     }
 },
 _c8bMa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bMa: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bMe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bMe: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fEqNewline_$c==_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.06570759 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure:
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqNewlineMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8bMz,
                       label: GHC.IO.Handle.Types.$fEqNewlineMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bMz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8bMD; else goto c8bME;
       c8bMD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bME: // global
           I64[Sp - 16] = block_c8bMw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bMM; else goto c8bMx;
       u8bMM: // global
           call _c8bMw(R1) args: 0, res: 0, upd: 0;
       c8bMx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bMw() //  [R1]
         { info_tbl: [(c8bMw,
                       label: block_c8bMw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bMw: // global
           I64[Sp - 8] = block_c8bMC_info;
           _s8aas::P64 = P64[R1 + 7];
           _s8aat::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aat::P64;
           P64[Sp + 8] = _s8aas::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bML; else goto c8bMG;
       u8bML: // global
           call _c8bMC(R1) args: 0, res: 0, upd: 0;
       c8bMG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bMC() //  [R1]
         { info_tbl: [(c8bMC,
                       label: block_c8bMC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bMC: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$c==_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.068161425 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8bMU,
                       label: GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bMU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8bMY; else goto c8bMZ;
       c8bMY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bMZ: // global
           I64[Sp - 16] = block_c8bMR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bPa; else goto c8bMS;
       u8bPa: // global
           call _c8bMR(R1) args: 0, res: 0, upd: 0;
       c8bMS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bMR() //  [R1]
         { info_tbl: [(c8bMR,
                       label: block_c8bMR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bMR: // global
           I64[Sp - 8] = block_c8bMX_info;
           _s8aaA::P64 = P64[R1 + 7];
           _s8aaB::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aaB::P64;
           P64[Sp + 8] = _s8aaA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bP9; else goto c8bN1;
       u8bP9: // global
           call _c8bMX(R1) args: 0, res: 0, upd: 0;
       c8bN1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bMX() //  [R1]
         { info_tbl: [(c8bMX,
                       label: block_c8bMX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bMX: // global
           I64[Sp - 8] = block_c8bN5_info;
           _s8aaD::P64 = P64[R1 + 7];
           _s8aaE::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8aaE::P64;
           P64[Sp + 16] = _s8aaD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bPb; else goto c8bN7;
       u8bPb: // global
           call _c8bN5(R1) args: 0, res: 0, upd: 0;
       c8bN7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bN5() //  [R1]
         { info_tbl: [(c8bN5,
                       label: block_c8bN5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bN5: // global
           _s8aaD::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8bNe; else goto c8bO4;
       c8bNe: // global
           I64[Sp] = block_c8bNb_info;
           R1 = _s8aaD::P64;
           if (R1 & 7 != 0) goto u8bPc; else goto c8bNf;
       u8bPc: // global
           call _c8bNb(R1) args: 0, res: 0, upd: 0;
       c8bNf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bO4: // global
           I64[Sp] = block_c8bO2_info;
           R1 = _s8aaD::P64;
           if (R1 & 7 != 0) goto u8bPd; else goto c8bO5;
       u8bPd: // global
           call _c8bO2(R1) args: 0, res: 0, upd: 0;
       c8bO5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bNb() //  [R1]
         { info_tbl: [(c8bNb,
                       label: block_c8bNb_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bNb: // global
           if (R1 & 7 == 1) goto c8bNm; else goto u8bP4;
       c8bNm: // global
           I64[Sp] = block_c8bNj_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8bPe; else goto c8bNn;
       u8bPe: // global
           call _c8bNj(R1) args: 0, res: 0, upd: 0;
       c8bNn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8bP4: // global
           Sp = Sp + 32;
           call _c8bOL() args: 0, res: 0, upd: 0;
     }
 },
 _c8bNj() //  [R1]
         { info_tbl: [(c8bNj,
                       label: block_c8bNj_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bNj: // global
           _s8aaE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bNu; else goto c8bNK;
       c8bNu: // global
           I64[Sp + 24] = block_c8bNr_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bPg; else goto c8bNv;
       u8bPg: // global
           call _c8bNr(R1) args: 0, res: 0, upd: 0;
       c8bNv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bNK: // global
           I64[Sp + 24] = block_c8bNI_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bPh; else goto c8bNL;
       u8bPh: // global
           call _c8bNI(R1) args: 0, res: 0, upd: 0;
       c8bNL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bNr() //  [R1]
         { info_tbl: [(c8bNr,
                       label: block_c8bNr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bNr: // global
           if (R1 & 7 == 1) goto u8bP7; else goto u8bP8;
       u8bP7: // global
           Sp = Sp + 8;
           call _c8bOP() args: 0, res: 0, upd: 0;
       u8bP8: // global
           Sp = Sp + 8;
           call _c8bOL() args: 0, res: 0, upd: 0;
     }
 },
 _c8bNI() //  [R1]
         { info_tbl: [(c8bNI,
                       label: block_c8bNI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bNI: // global
           if (R1 & 7 == 1) goto u8bP5; else goto u8bP6;
       u8bP5: // global
           Sp = Sp + 8;
           call _c8bOL() args: 0, res: 0, upd: 0;
       u8bP6: // global
           Sp = Sp + 8;
           call _c8bOP() args: 0, res: 0, upd: 0;
     }
 },
 _c8bO2() //  [R1]
         { info_tbl: [(c8bO2,
                       label: block_c8bO2_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bO2: // global
           if (R1 & 7 == 1) goto u8bOZ; else goto c8bOg;
       u8bOZ: // global
           Sp = Sp + 32;
           call _c8bOL() args: 0, res: 0, upd: 0;
       c8bOg: // global
           I64[Sp] = block_c8bOe_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8bPm; else goto c8bOh;
       u8bPm: // global
           call _c8bOe(R1) args: 0, res: 0, upd: 0;
       c8bOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bOe() //  [R1]
         { info_tbl: [(c8bOe,
                       label: block_c8bOe_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bOe: // global
           _s8aaE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bOo; else goto c8bOE;
       c8bOo: // global
           I64[Sp + 24] = block_c8bOl_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bPo; else goto c8bOp;
       u8bPo: // global
           call _c8bOl(R1) args: 0, res: 0, upd: 0;
       c8bOp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bOE: // global
           I64[Sp + 24] = block_c8bOC_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bPp; else goto c8bOF;
       u8bPp: // global
           call _c8bOC(R1) args: 0, res: 0, upd: 0;
       c8bOF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bOl() //  [R1]
         { info_tbl: [(c8bOl,
                       label: block_c8bOl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bOl: // global
           if (R1 & 7 == 1) goto u8bP2; else goto u8bP3;
       u8bP2: // global
           Sp = Sp + 8;
           call _c8bOP() args: 0, res: 0, upd: 0;
       u8bP3: // global
           Sp = Sp + 8;
           call _c8bOL() args: 0, res: 0, upd: 0;
     }
 },
 _c8bOC() //  [R1]
         { info_tbl: [(c8bOC,
                       label: block_c8bOC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bOC: // global
           if (R1 & 7 == 1) goto u8bP0; else goto u8bP1;
       u8bP0: // global
           Sp = Sp + 8;
           call _c8bOL() args: 0, res: 0, upd: 0;
       u8bP1: // global
           Sp = Sp + 8;
           call _c8bOP() args: 0, res: 0, upd: 0;
     }
 },
 _c8bOL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bOL: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bOP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bOP: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.071518514 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.073347362 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8bPB,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bPB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8bPF; else goto c8bPG;
       c8bPF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bPG: // global
           I64[Sp - 16] = block_c8bPy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bRz; else goto c8bPz;
       u8bRz: // global
           call _c8bPy(R1) args: 0, res: 0, upd: 0;
       c8bPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bPy() //  [R1]
         { info_tbl: [(c8bPy,
                       label: block_c8bPy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bPy: // global
           I64[Sp - 8] = block_c8bPE_info;
           _s8aaR::P64 = P64[R1 + 7];
           _s8aaS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aaS::P64;
           P64[Sp + 8] = _s8aaR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bRy; else goto c8bPI;
       u8bRy: // global
           call _c8bPE(R1) args: 0, res: 0, upd: 0;
       c8bPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bPE() //  [R1]
         { info_tbl: [(c8bPE,
                       label: block_c8bPE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bPE: // global
           I64[Sp - 8] = block_c8bPM_info;
           _s8aaU::P64 = P64[R1 + 7];
           _s8aaV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8aaV::P64;
           P64[Sp + 16] = _s8aaU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bRA; else goto c8bPO;
       u8bRA: // global
           call _c8bPM(R1) args: 0, res: 0, upd: 0;
       c8bPO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bPM() //  [R1]
         { info_tbl: [(c8bPM,
                       label: block_c8bPM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bPM: // global
           _s8aaU::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8bPV; else goto c8bQF;
       c8bPV: // global
           I64[Sp] = block_c8bPS_info;
           R1 = _s8aaU::P64;
           if (R1 & 7 != 0) goto u8bRB; else goto c8bPW;
       u8bRB: // global
           call _c8bPS(R1) args: 0, res: 0, upd: 0;
       c8bPW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bQF: // global
           I64[Sp] = block_c8bQD_info;
           R1 = _s8aaU::P64;
           if (R1 & 7 != 0) goto u8bRC; else goto c8bQG;
       u8bRC: // global
           call _c8bQD(R1) args: 0, res: 0, upd: 0;
       c8bQG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bPS() //  [R1]
         { info_tbl: [(c8bPS,
                       label: block_c8bPS_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bPS: // global
           if (R1 & 7 == 1) goto c8bQ3; else goto u8bRv;
       c8bQ3: // global
           I64[Sp] = block_c8bQ0_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8bRD; else goto c8bQ4;
       u8bRD: // global
           call _c8bQ0(R1) args: 0, res: 0, upd: 0;
       c8bQ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8bRv: // global
           Sp = Sp + 32;
           call _c8bRa() args: 0, res: 0, upd: 0;
     }
 },
 _c8bQ0() //  [R1]
         { info_tbl: [(c8bQ0,
                       label: block_c8bQ0_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bQ0: // global
           _s8aaV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bQb; else goto c8bQr;
       c8bQb: // global
           I64[Sp + 24] = block_c8bQ8_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bRF; else goto c8bQc;
       u8bRF: // global
           call _c8bQ8(R1) args: 0, res: 0, upd: 0;
       c8bQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bQr: // global
           I64[Sp + 24] = block_c8bQp_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bRG; else goto c8bQs;
       u8bRG: // global
           call _c8bQp() args: 0, res: 0, upd: 0;
       c8bQs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bQ8() //  [R1]
         { info_tbl: [(c8bQ8,
                       label: block_c8bQ8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bQ8: // global
           if (R1 & 7 == 1) goto u8bRw; else goto u8bRx;
       u8bRw: // global
           Sp = Sp + 8;
           call _c8bR6() args: 0, res: 0, upd: 0;
       u8bRx: // global
           Sp = Sp + 8;
           call _c8bRa() args: 0, res: 0, upd: 0;
     }
 },
 _c8bQp() //  []
         { info_tbl: [(c8bQp,
                       label: block_c8bQp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bQp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bQD() //  [R1]
         { info_tbl: [(c8bQD,
                       label: block_c8bQD_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bQD: // global
           if (R1 & 7 == 1) goto u8bRs; else goto c8bQR;
       u8bRs: // global
           Sp = Sp + 32;
           call _c8bR6() args: 0, res: 0, upd: 0;
       c8bQR: // global
           I64[Sp] = block_c8bQP_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8bRJ; else goto c8bQS;
       u8bRJ: // global
           call _c8bQP(R1) args: 0, res: 0, upd: 0;
       c8bQS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bQP() //  [R1]
         { info_tbl: [(c8bQP,
                       label: block_c8bQP_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bQP: // global
           _s8aaV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bQZ; else goto c8bRf;
       c8bQZ: // global
           I64[Sp + 24] = block_c8bQW_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bRL; else goto c8bR0;
       u8bRL: // global
           call _c8bQW(R1) args: 0, res: 0, upd: 0;
       c8bR0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bRf: // global
           I64[Sp + 24] = block_c8bRd_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bRM; else goto c8bRg;
       u8bRM: // global
           call _c8bRd() args: 0, res: 0, upd: 0;
       c8bRg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bQW() //  [R1]
         { info_tbl: [(c8bQW,
                       label: block_c8bQW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bQW: // global
           if (R1 & 7 == 1) goto u8bRt; else goto u8bRu;
       u8bRt: // global
           Sp = Sp + 8;
           call _c8bR6() args: 0, res: 0, upd: 0;
       u8bRu: // global
           Sp = Sp + 8;
           call _c8bRa() args: 0, res: 0, upd: 0;
     }
 },
 _c8bR6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bR6: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bRa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bRa: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bRd() //  []
         { info_tbl: [(c8bRd,
                       label: block_c8bRd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bRd: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.077976345 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8bRW,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bRW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8bS0; else goto c8bS1;
       c8bS0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bS1: // global
           I64[Sp - 16] = block_c8bRT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bTU; else goto c8bRU;
       u8bTU: // global
           call _c8bRT(R1) args: 0, res: 0, upd: 0;
       c8bRU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bRT() //  [R1]
         { info_tbl: [(c8bRT,
                       label: block_c8bRT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bRT: // global
           I64[Sp - 16] = block_c8bRZ_info;
           _s8ab7::P64 = R1;
           _s8ab8::P64 = P64[R1 + 7];
           _s8ab9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s8ab9::P64;
           P64[Sp] = _s8ab8::P64;
           P64[Sp + 8] = _s8ab7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bTT; else goto c8bS3;
       u8bTT: // global
           call _c8bRZ(R1) args: 0, res: 0, upd: 0;
       c8bS3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bRZ() //  [R1]
         { info_tbl: [(c8bRZ,
                       label: block_c8bRZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bRZ: // global
           I64[Sp - 16] = block_c8bS7_info;
           _s8aba::P64 = R1;
           _s8abb::P64 = P64[R1 + 7];
           _s8abc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8abc::P64;
           P64[Sp] = _s8abb::P64;
           P64[Sp + 16] = _s8aba::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bTV; else goto c8bS9;
       u8bTV: // global
           call _c8bS7(R1) args: 0, res: 0, upd: 0;
       c8bS9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bS7() //  [R1]
         { info_tbl: [(c8bS7,
                       label: block_c8bS7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bS7: // global
           _s8abb::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8bSg; else goto c8bT0;
       c8bSg: // global
           I64[Sp] = block_c8bSd_info;
           R1 = _s8abb::P64;
           if (R1 & 7 != 0) goto u8bTW; else goto c8bSh;
       u8bTW: // global
           call _c8bSd(R1) args: 0, res: 0, upd: 0;
       c8bSh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bT0: // global
           I64[Sp] = block_c8bSY_info;
           R1 = _s8abb::P64;
           if (R1 & 7 != 0) goto u8bTX; else goto c8bT1;
       u8bTX: // global
           call _c8bSY(R1) args: 0, res: 0, upd: 0;
       c8bT1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bSd() //  [R1]
         { info_tbl: [(c8bSd,
                       label: block_c8bSd_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bSd: // global
           if (R1 & 7 == 1) goto c8bSo; else goto u8bTQ;
       c8bSo: // global
           I64[Sp] = block_c8bSl_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8bTY; else goto c8bSp;
       u8bTY: // global
           call _c8bSl(R1) args: 0, res: 0, upd: 0;
       c8bSp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8bTQ: // global
           Sp = Sp + 32;
           call _c8bTv() args: 0, res: 0, upd: 0;
     }
 },
 _c8bSl() //  [R1]
         { info_tbl: [(c8bSl,
                       label: block_c8bSl_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bSl: // global
           _s8abc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bSw; else goto c8bSM;
       c8bSw: // global
           I64[Sp + 24] = block_c8bSt_info;
           R1 = _s8abc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bU0; else goto c8bSx;
       u8bU0: // global
           call _c8bSt(R1) args: 0, res: 0, upd: 0;
       c8bSx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bSM: // global
           I64[Sp + 32] = block_c8bSK_info;
           R1 = _s8abc::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8bU1; else goto c8bSN;
       u8bU1: // global
           call _c8bSK() args: 0, res: 0, upd: 0;
       c8bSN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bSt() //  [R1]
         { info_tbl: [(c8bSt,
                       label: block_c8bSt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bSt: // global
           if (R1 & 7 == 1) goto u8bTR; else goto u8bTS;
       u8bTR: // global
           Sp = Sp + 16;
           call _c8bTr() args: 0, res: 0, upd: 0;
       u8bTS: // global
           Sp = Sp + 8;
           call _c8bTv() args: 0, res: 0, upd: 0;
     }
 },
 _c8bSK() //  []
         { info_tbl: [(c8bSK,
                       label: block_c8bSK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bSK: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bSY() //  [R1]
         { info_tbl: [(c8bSY,
                       label: block_c8bSY_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bSY: // global
           if (R1 & 7 == 1) goto u8bTN; else goto c8bTc;
       u8bTN: // global
           Sp = Sp + 40;
           call _c8bTr() args: 0, res: 0, upd: 0;
       c8bTc: // global
           I64[Sp] = block_c8bTa_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8bU4; else goto c8bTd;
       u8bU4: // global
           call _c8bTa(R1) args: 0, res: 0, upd: 0;
       c8bTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bTa() //  [R1]
         { info_tbl: [(c8bTa,
                       label: block_c8bTa_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bTa: // global
           _s8abc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bTk; else goto c8bTA;
       c8bTk: // global
           I64[Sp + 24] = block_c8bTh_info;
           R1 = _s8abc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bU6; else goto c8bTl;
       u8bU6: // global
           call _c8bTh(R1) args: 0, res: 0, upd: 0;
       c8bTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bTA: // global
           I64[Sp + 32] = block_c8bTy_info;
           R1 = _s8abc::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8bU7; else goto c8bTB;
       u8bU7: // global
           call _c8bTy() args: 0, res: 0, upd: 0;
       c8bTB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bTh() //  [R1]
         { info_tbl: [(c8bTh,
                       label: block_c8bTh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bTh: // global
           if (R1 & 7 == 1) goto u8bTO; else goto u8bTP;
       u8bTO: // global
           Sp = Sp + 16;
           call _c8bTr() args: 0, res: 0, upd: 0;
       u8bTP: // global
           Sp = Sp + 8;
           call _c8bTv() args: 0, res: 0, upd: 0;
     }
 },
 _c8bTr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bTr: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bTv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bTv: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bTy() //  []
         { info_tbl: [(c8bTy,
                       label: block_c8bTy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bTy: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.082501662 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8bUh,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bUh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8bUl; else goto c8bUm;
       c8bUl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bUm: // global
           I64[Sp - 16] = block_c8bUe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bWf; else goto c8bUf;
       u8bWf: // global
           call _c8bUe(R1) args: 0, res: 0, upd: 0;
       c8bUf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bUe() //  [R1]
         { info_tbl: [(c8bUe,
                       label: block_c8bUe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bUe: // global
           I64[Sp - 8] = block_c8bUk_info;
           _s8abp::P64 = P64[R1 + 7];
           _s8abq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8abq::P64;
           P64[Sp + 8] = _s8abp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bWe; else goto c8bUo;
       u8bWe: // global
           call _c8bUk(R1) args: 0, res: 0, upd: 0;
       c8bUo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bUk() //  [R1]
         { info_tbl: [(c8bUk,
                       label: block_c8bUk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bUk: // global
           I64[Sp - 8] = block_c8bUs_info;
           _s8abs::P64 = P64[R1 + 7];
           _s8abt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8abt::P64;
           P64[Sp + 16] = _s8abs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8bWg; else goto c8bUu;
       u8bWg: // global
           call _c8bUs(R1) args: 0, res: 0, upd: 0;
       c8bUu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bUs() //  [R1]
         { info_tbl: [(c8bUs,
                       label: block_c8bUs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bUs: // global
           _s8abs::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8bUB; else goto c8bVl;
       c8bUB: // global
           I64[Sp] = block_c8bUy_info;
           R1 = _s8abs::P64;
           if (R1 & 7 != 0) goto u8bWh; else goto c8bUC;
       u8bWh: // global
           call _c8bUy(R1) args: 0, res: 0, upd: 0;
       c8bUC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bVl: // global
           I64[Sp] = block_c8bVj_info;
           R1 = _s8abs::P64;
           if (R1 & 7 != 0) goto u8bWi; else goto c8bVm;
       u8bWi: // global
           call _c8bVj(R1) args: 0, res: 0, upd: 0;
       c8bVm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bUy() //  [R1]
         { info_tbl: [(c8bUy,
                       label: block_c8bUy_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bUy: // global
           if (R1 & 7 == 1) goto c8bUJ; else goto u8bWb;
       c8bUJ: // global
           I64[Sp] = block_c8bUG_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8bWj; else goto c8bUK;
       u8bWj: // global
           call _c8bUG(R1) args: 0, res: 0, upd: 0;
       c8bUK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8bWb: // global
           Sp = Sp + 32;
           call _c8bVQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8bUG() //  [R1]
         { info_tbl: [(c8bUG,
                       label: block_c8bUG_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bUG: // global
           _s8abt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bUR; else goto c8bV7;
       c8bUR: // global
           I64[Sp + 24] = block_c8bUO_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bWl; else goto c8bUS;
       u8bWl: // global
           call _c8bUO(R1) args: 0, res: 0, upd: 0;
       c8bUS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bV7: // global
           I64[Sp + 24] = block_c8bV5_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bWm; else goto c8bV8;
       u8bWm: // global
           call _c8bV5() args: 0, res: 0, upd: 0;
       c8bV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bUO() //  [R1]
         { info_tbl: [(c8bUO,
                       label: block_c8bUO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bUO: // global
           if (R1 & 7 == 1) goto u8bWc; else goto u8bWd;
       u8bWc: // global
           Sp = Sp + 8;
           call _c8bVM() args: 0, res: 0, upd: 0;
       u8bWd: // global
           Sp = Sp + 8;
           call _c8bVQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8bV5() //  []
         { info_tbl: [(c8bV5,
                       label: block_c8bV5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bV5: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bVj() //  [R1]
         { info_tbl: [(c8bVj,
                       label: block_c8bVj_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bVj: // global
           if (R1 & 7 == 1) goto u8bW8; else goto c8bVx;
       u8bW8: // global
           Sp = Sp + 32;
           call _c8bVM() args: 0, res: 0, upd: 0;
       c8bVx: // global
           I64[Sp] = block_c8bVv_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8bWp; else goto c8bVy;
       u8bWp: // global
           call _c8bVv(R1) args: 0, res: 0, upd: 0;
       c8bVy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bVv() //  [R1]
         { info_tbl: [(c8bVv,
                       label: block_c8bVv_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bVv: // global
           _s8abt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bVF; else goto c8bVV;
       c8bVF: // global
           I64[Sp + 24] = block_c8bVC_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bWr; else goto c8bVG;
       u8bWr: // global
           call _c8bVC(R1) args: 0, res: 0, upd: 0;
       c8bVG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bVV: // global
           I64[Sp + 24] = block_c8bVT_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bWs; else goto c8bVW;
       u8bWs: // global
           call _c8bVT() args: 0, res: 0, upd: 0;
       c8bVW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bVC() //  [R1]
         { info_tbl: [(c8bVC,
                       label: block_c8bVC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bVC: // global
           if (R1 & 7 == 1) goto u8bW9; else goto u8bWa;
       u8bW9: // global
           Sp = Sp + 8;
           call _c8bVM() args: 0, res: 0, upd: 0;
       u8bWa: // global
           Sp = Sp + 8;
           call _c8bVQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8bVM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bVM: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bVQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bVQ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bVT() //  []
         { info_tbl: [(c8bVT,
                       label: block_c8bVT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bVT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.085858212 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8bWz,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bWz: // global
           _s8abE::P64 = R3;
           R3 = R2;
           R2 = _s8abE::P64;
           call GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.08778673 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8bWJ,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bWJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8bWN; else goto c8bWO;
       c8bWN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8bWO: // global
           I64[Sp - 16] = block_c8bWG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bYH; else goto c8bWH;
       u8bYH: // global
           call _c8bWG(R1) args: 0, res: 0, upd: 0;
       c8bWH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bWG() //  [R1]
         { info_tbl: [(c8bWG,
                       label: block_c8bWG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bWG: // global
           I64[Sp - 16] = block_c8bWM_info;
           _s8abH::P64 = R1;
           _s8abI::P64 = P64[R1 + 7];
           _s8abJ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s8abJ::P64;
           P64[Sp] = _s8abI::P64;
           P64[Sp + 8] = _s8abH::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bYG; else goto c8bWQ;
       u8bYG: // global
           call _c8bWM(R1) args: 0, res: 0, upd: 0;
       c8bWQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bWM() //  [R1]
         { info_tbl: [(c8bWM,
                       label: block_c8bWM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bWM: // global
           I64[Sp - 16] = block_c8bWU_info;
           _s8abK::P64 = R1;
           _s8abL::P64 = P64[R1 + 7];
           _s8abM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8abM::P64;
           P64[Sp] = _s8abL::P64;
           P64[Sp + 16] = _s8abK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8bYI; else goto c8bWW;
       u8bYI: // global
           call _c8bWU(R1) args: 0, res: 0, upd: 0;
       c8bWW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bWU() //  [R1]
         { info_tbl: [(c8bWU,
                       label: block_c8bWU_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bWU: // global
           _s8abL::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8bX3; else goto c8bXN;
       c8bX3: // global
           I64[Sp] = block_c8bX0_info;
           R1 = _s8abL::P64;
           if (R1 & 7 != 0) goto u8bYJ; else goto c8bX4;
       u8bYJ: // global
           call _c8bX0(R1) args: 0, res: 0, upd: 0;
       c8bX4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bXN: // global
           I64[Sp] = block_c8bXL_info;
           R1 = _s8abL::P64;
           if (R1 & 7 != 0) goto u8bYK; else goto c8bXO;
       u8bYK: // global
           call _c8bXL(R1) args: 0, res: 0, upd: 0;
       c8bXO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bX0() //  [R1]
         { info_tbl: [(c8bX0,
                       label: block_c8bX0_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bX0: // global
           if (R1 & 7 == 1) goto c8bXb; else goto u8bYD;
       c8bXb: // global
           I64[Sp] = block_c8bX8_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8bYL; else goto c8bXc;
       u8bYL: // global
           call _c8bX8(R1) args: 0, res: 0, upd: 0;
       c8bXc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8bYD: // global
           Sp = Sp + 40;
           call _c8bYi() args: 0, res: 0, upd: 0;
     }
 },
 _c8bX8() //  [R1]
         { info_tbl: [(c8bX8,
                       label: block_c8bX8_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bX8: // global
           _s8abM::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bXj; else goto c8bXz;
       c8bXj: // global
           I64[Sp + 24] = block_c8bXg_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bYN; else goto c8bXk;
       u8bYN: // global
           call _c8bXg(R1) args: 0, res: 0, upd: 0;
       c8bXk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bXz: // global
           I64[Sp + 24] = block_c8bXx_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bYO; else goto c8bXA;
       u8bYO: // global
           call _c8bXx() args: 0, res: 0, upd: 0;
       c8bXA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bXg() //  [R1]
         { info_tbl: [(c8bXg,
                       label: block_c8bXg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bXg: // global
           if (R1 & 7 == 1) goto u8bYE; else goto u8bYF;
       u8bYE: // global
           Sp = Sp + 8;
           call _c8bYe() args: 0, res: 0, upd: 0;
       u8bYF: // global
           Sp = Sp + 16;
           call _c8bYi() args: 0, res: 0, upd: 0;
     }
 },
 _c8bXx() //  []
         { info_tbl: [(c8bXx,
                       label: block_c8bXx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bXx: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bXL() //  [R1]
         { info_tbl: [(c8bXL,
                       label: block_c8bXL_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bXL: // global
           if (R1 & 7 == 1) goto u8bYA; else goto c8bXZ;
       u8bYA: // global
           Sp = Sp + 32;
           call _c8bYe() args: 0, res: 0, upd: 0;
       c8bXZ: // global
           I64[Sp] = block_c8bXX_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8bYR; else goto c8bY0;
       u8bYR: // global
           call _c8bXX(R1) args: 0, res: 0, upd: 0;
       c8bY0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bXX() //  [R1]
         { info_tbl: [(c8bXX,
                       label: block_c8bXX_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bXX: // global
           _s8abM::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8bY7; else goto c8bYn;
       c8bY7: // global
           I64[Sp + 24] = block_c8bY4_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bYT; else goto c8bY8;
       u8bYT: // global
           call _c8bY4(R1) args: 0, res: 0, upd: 0;
       c8bY8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8bYn: // global
           I64[Sp + 24] = block_c8bYl_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8bYU; else goto c8bYo;
       u8bYU: // global
           call _c8bYl() args: 0, res: 0, upd: 0;
       c8bYo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bY4() //  [R1]
         { info_tbl: [(c8bY4,
                       label: block_c8bY4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bY4: // global
           if (R1 & 7 == 1) goto u8bYB; else goto u8bYC;
       u8bYB: // global
           Sp = Sp + 8;
           call _c8bYe() args: 0, res: 0, upd: 0;
       u8bYC: // global
           Sp = Sp + 16;
           call _c8bYi() args: 0, res: 0, upd: 0;
     }
 },
 _c8bYe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bYe: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bYi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bYi: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8bYl() //  []
         { info_tbl: [(c8bYl,
                       label: block_c8bYl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bYl: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.09139948 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqNewlineMode_closure+1;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.092005368 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode13_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode13_bytes:
         I8[] [78,111,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.092748731 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode12_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode12_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode12_entry() //  [R1]
         { info_tbl: [(c8bZ3,
                       label: GHC.IO.Handle.Types.$fReadBufferMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bZ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bZ4; else goto c8bZ5;
       c8bZ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bZ5: // global
           (_c8bZ0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bZ0::I64 == 0) goto c8bZ2; else goto c8bZ1;
       c8bZ2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bZ1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bZ0::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.093770921 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode6_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode6_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode6_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode6_entry() //  [R2]
         { info_tbl: [(c8bZa,
                       label: GHC.IO.Handle.Types.$fShowBufferMode6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bZa: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode12_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.094528728 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode9_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode9_bytes:
         I8[] [76,105,110,101,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.095247052 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode8_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode8_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode8_entry() //  [R1]
         { info_tbl: [(c8bZj,
                       label: GHC.IO.Handle.Types.$fReadBufferMode8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bZk; else goto c8bZl;
       c8bZk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bZl: // global
           (_c8bZg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bZg::I64 == 0) goto c8bZi; else goto c8bZh;
       c8bZi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bZh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bZg::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.096227057 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode5_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode5_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode5_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode5_entry() //  [R2]
         { info_tbl: [(c8bZq,
                       label: GHC.IO.Handle.Types.$fShowBufferMode5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bZq: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode8_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.096991003 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowBufferMode4_bytes" {
     GHC.IO.Handle.Types.$fShowBufferMode4_bytes:
         I8[] [66,108,111,99,107,66,117,102,102,101,114,105,110,103,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.097749859 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode3_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode3_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode3_entry() //  [R1]
         { info_tbl: [(c8bZz,
                       label: GHC.IO.Handle.Types.$fShowBufferMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bZz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bZA; else goto c8bZB;
       c8bZA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bZB: // global
           (_c8bZw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8bZw::I64 == 0) goto c8bZy; else goto c8bZx;
       c8bZy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8bZx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8bZw::I64;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.100132135 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_info;
         const 0;
 },
 g_s8ac2_entry() //  [R1]
         { info_tbl: [(c8bZW,
                       label: g_s8ac2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bZW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8bZX; else goto c8bZY;
       c8bZX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8bZY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 16];
           R3 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R2 = GHC.Show.$fShowInt_closure;
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ac5_entry() //  [R1]
         { info_tbl: [(c8c0b,
                       label: sat_s8ac5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c0b: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ac6_entry() //  [R1, R2]
         { info_tbl: [(c8c0e,
                       label: sat_s8ac6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c0e: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8c0i; else goto c8c0h;
       c8c0i: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8c0h: // global
           _s8ac2::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s8ac5_info;
           P64[Hp - 8] = _s8ac2::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ac9_entry() //  [R1]
         { info_tbl: [(c8c0y,
                       label: sat_s8ac9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c0y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8c0C; else goto c8c0B;
       c8c0C: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c0B: // global
           _s8ac2::P64 = P64[R1 + 16];
           _s8ac7::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s8ac7::P64;
           R2 = Hp - 14;
           R1 = _s8ac2::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8aca_entry() //  [R1]
         { info_tbl: [(c8c0D,
                       label: sat_s8aca_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c0D: // global
           _s8aca::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8c0E; else goto c8c0F;
       c8c0F: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8c0H; else goto c8c0G;
       c8c0H: // global
           HpAlloc = 32;
           goto c8c0E;
       c8c0E: // global
           R1 = _s8aca::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c0G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8aca::P64;
           _s8ac2::P64 = P64[_s8aca::P64 + 16];
           _s8ac7::P64 = P64[_s8aca::P64 + 24];
           I64[Hp - 24] = sat_s8ac9_info;
           P64[Hp - 8] = _s8ac2::P64;
           P64[Hp] = _s8ac7::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8acb_entry() //  [R1, R2]
         { info_tbl: [(c8c0J,
                       label: sat_s8acb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c0J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8c0N; else goto c8c0M;
       c8c0N: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8c0M: // global
           _s8ac2::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s8aca_info;
           P64[Hp - 32] = _s8ac2::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8c0T,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c0T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8c0U; else goto c8c0V;
       c8c0U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8c0V: // global
           I64[Sp - 16] = block_c8bZG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8c19; else goto c8bZH;
       u8c19: // global
           call _c8bZG(R1) args: 0, res: 0, upd: 0;
       c8bZH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bZG() //  [R1]
         { info_tbl: [(c8bZG,
                       label: block_c8bZG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bZG: // global
           _c8c0S::P64 = R1 & 7;
           if (_c8c0S::P64 < 3) goto u8c17; else goto c8c0R;
       u8c17: // global
           if (_c8c0S::P64 < 2) goto c8c0P; else goto c8c0Q;
       c8c0P: // global
           R1 = GHC.IO.Handle.Types.$fShowBufferMode6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8c0Q: // global
           R1 = GHC.IO.Handle.Types.$fShowBufferMode5_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8c0R: // global
           I64[Sp] = block_c8bZN_info;
           _s8abZ::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8abZ::P64;
           if (R1 & 7 != 0) goto u8c18; else goto c8bZO;
       u8c18: // global
           call _c8bZN(R1) args: 0, res: 0, upd: 0;
       c8bZO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8bZN() //  [R1]
         { info_tbl: [(c8bZN,
                       label: block_c8bZN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8bZN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8c13; else goto c8c12;
       c8c13: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8c12: // global
           _s8ac1::I64 = I64[R1 + 7];
           I64[Hp - 32] = g_s8ac2_info;
           P64[Hp - 16] = P64[Sp + 8];
           _c8bZS::P64 = Hp - 32;
           if (%MO_S_Lt_W64(_s8ac1::I64, 11)) goto c8c15; else goto c8c16;
       c8c15: // global
           I64[Hp - 8] = sat_s8ac6_info;
           P64[Hp] = _c8bZS::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8c16: // global
           I64[Hp - 8] = sat_s8acb_info;
           P64[Hp] = _c8bZS::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.103875776 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode7_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode7_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.105734713 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_info;
         const 0;
 },
 sat_s8acm_entry() //  [R1]
         { info_tbl: [(c8c1G,
                       label: sat_s8acm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c1G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8c1M; else goto c8c1N;
       c8c1M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c1N: // global
           I64[Sp - 8] = block_c8c1D_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8c1S; else goto c8c1E;
       u8c1S: // global
           call _c8c1D(R1) args: 0, res: 0, upd: 0;
       c8c1E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c1D() //  [R1]
         { info_tbl: [(c8c1D,
                       label: block_c8c1D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c1D: // global
           I64[Sp] = block_c8c1J_info;
           R4 = GHC.IO.Handle.Types.$fShowBufferMode7_closure+2;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8c1J() //  [R1, R2]
         { info_tbl: [(c8c1J,
                       label: block_c8c1J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c1J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8c1R; else goto c8c1Q;
       c8c1R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8c1Q: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8acn_entry() //  [R1]
         { info_tbl: [(c8c1T,
                       label: sat_s8acn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c1T: // global
           _s8acn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8c1U; else goto c8c1V;
       c8c1V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8c1X; else goto c8c1W;
       c8c1X: // global
           HpAlloc = 24;
           goto c8c1U;
       c8c1U: // global
           R1 = _s8acn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c1W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8acn::P64;
           _s8acg::P64 = P64[_s8acn::P64 + 16];
           I64[Hp - 16] = sat_s8acm_info;
           P64[Hp] = _s8acg::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8aco_entry() //  [R1]
         { info_tbl: [(c8c22,
                       label: sat_s8aco_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c22: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8c23; else goto c8c24;
       c8c23: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c24: // global
           I64[Sp - 8] = block_c8c1p_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8c2b; else goto c8c1q;
       u8c2b: // global
           call _c8c1p(R1) args: 0, res: 0, upd: 0;
       c8c1q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c1p() //  [R1]
         { info_tbl: [(c8c1p,
                       label: block_c8c1p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c1p: // global
           if (R1 & 7 == 1) goto c8c1Z; else goto c8c20;
       c8c1Z: // global
           R1 = GHC.Show.$fShowMaybe4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8c20: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8c2a; else goto c8c29;
       c8c2a: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8c29: // global
           _s8acg::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_s8acn_info;
           P64[Hp - 24] = _s8acg::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8c2h,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c2h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8c2i; else goto c8c2j;
       c8c2i: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8c2j: // global
           I64[Sp - 8] = block_c8c1e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8c2s; else goto c8c1f;
       u8c2s: // global
           call _c8c1e(R1) args: 0, res: 0, upd: 0;
       c8c1f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c1e() //  [R1]
         { info_tbl: [(c8c1e,
                       label: block_c8c1e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c1e: // global
           _c8c2g::P64 = R1 & 7;
           if (_c8c2g::P64 < 3) goto u8c2r; else goto c8c2f;
       u8c2r: // global
           if (_c8c2g::P64 < 2) goto c8c2d; else goto c8c2e;
       c8c2d: // global
           R1 = GHC.IO.Handle.Types.$fReadBufferMode12_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8c2e: // global
           R1 = GHC.IO.Handle.Types.$fReadBufferMode8_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8c2f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8c2q; else goto c8c2p;
       c8c2q: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8c2p: // global
           _s8ace::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_s8aco_info;
           P64[Hp] = _s8ace::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.108950874 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode1_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode1_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode1_entry() //  [R2]
         { info_tbl: [(c8c2x,
                       label: GHC.IO.Handle.Types.$fShowBufferMode1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c2x: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode2_closure+1;
           call GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.110053229 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8c2E,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c2E: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.110871641 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure+2;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.111639405 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode11_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode11_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode11_info;
 },
 GHC.IO.Handle.Types.$fReadBufferMode11_entry() //  [R3]
         { info_tbl: [(c8c2L,
                       label: GHC.IO.Handle.Types.$fReadBufferMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c2L: // global
           R2 = GHC.IO.Handle.Types.NoBuffering_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.11245031 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode10_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode10_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode12_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.113211731 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode7_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode7_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode7_info;
 },
 GHC.IO.Handle.Types.$fReadBufferMode7_entry() //  [R3]
         { info_tbl: [(c8c2S,
                       label: GHC.IO.Handle.Types.$fReadBufferMode7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c2S: // global
           R2 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.114049088 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode6_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode6_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode8_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.114680425 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode5_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode5_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.115322649 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_sps_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_sps_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode10_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.115947767 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode4_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode4_bytes:
         I8[] [66,108,111,99,107,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.11672286 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode3_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode3_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode3_entry() //  [R1]
         { info_tbl: [(c8c31,
                       label: GHC.IO.Handle.Types.$fReadBufferMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c31: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8c32; else goto c8c33;
       c8c32: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c33: // global
           (_c8c2Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8c2Y::I64 == 0) goto c8c30; else goto c8c2Z;
       c8c30: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8c2Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8c2Y::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.117781765 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.119822425 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode2_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode2_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode2_info;
         const 0;
 },
 ds2_s8acw_entry() //  [R1]
         { info_tbl: [(c8c3c,
                       label: ds2_s8acw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c3c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8c3d; else goto c8c3e;
       c8c3d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c3e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadBufferMode_sps_closure+2;
           Sp = Sp - 16;
           call GHC.Read.choose2_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8acF_entry() //  [R1, R2]
         { info_tbl: [(c8c3I,
                       label: sat_s8acF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c3I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8c3M; else goto c8c3L;
       c8c3M: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8c3L: // global
           _s8acx::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.IO.Handle.Types.BlockBuffering_con_info;
           P64[Hp] = R2;
           R2 = Hp - 5;
           R1 = _s8acx::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8acG_entry() //  [R1, R2]
         { info_tbl: [(c8c3N,
                       label: sat_s8acG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c3N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8c3R; else goto c8c3Q;
       c8c3R: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8c3Q: // global
           _s8acx::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8acF_info;
           P64[Hp] = _s8acx::P64;
           R4 = Hp - 7;
           R3 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R2 = GHC.Read.$fReadInt_closure;
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8acJ_entry() //  [R1]
         { info_tbl: [(c8c3S,
                       label: sat_s8acJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c3S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8c3T; else goto c8c3U;
       c8c3T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c3U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8c3o_info;
           _s8acx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8acx::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8c47; else goto c8c3p;
       u8c47: // global
           call _c8c3o(R1) args: 0, res: 0, upd: 0;
       c8c3p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8c3o() //  [R1]
         { info_tbl: [(c8c3o,
                       label: block_c8c3o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c3o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8c3X; else goto c8c3W;
       c8c3X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8c3W: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto c8c3Z; else goto c8c43;
       c8c3Z: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8c43: // global
           I64[Hp - 8] = sat_s8acG_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8c40_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8c40() //  [R1]
         { info_tbl: [(c8c40,
                       label: block_c8c40_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c40: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8c46; else goto c8c45;
       c8c46: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8c45: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8acK_entry() //  [R1, R2]
         { info_tbl: [(c8c4a,
                       label: sat_s8acK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c4a: // global
           _s8acx::P64 = R2;
           _s8acK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8c4b; else goto c8c4c;
       c8c4c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8c4e; else goto c8c4d;
       c8c4e: // global
           HpAlloc = 32;
           goto c8c4b;
       c8c4b: // global
           R2 = _s8acx::P64;
           R1 = _s8acK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8c4d: // global
           _s8acv::P64 = P64[_s8acK::P64 + 7];
           _s8acw::P64 = P64[_s8acK::P64 + 15];
           I64[Hp - 24] = sat_s8acJ_info;
           P64[Hp - 8] = _s8acv::P64;
           P64[Hp] = _s8acx::P64;
           I64[Sp - 16] = block_c8c48_info;
           R2 = _s8acx::P64;
           R1 = _s8acw::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c48() //  [R1]
         { info_tbl: [(c8c48,
                       label: block_c8c48_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c48: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u8c4n_srtd" {
     u8c4n_srtd:
         const S8alj_srt+216;
         const 33;
         const 8522825729;
 },
 GHC.IO.Handle.Types.$fReadBufferMode2_entry() //  [R2]
         { info_tbl: [(c8c4i,
                       label: GHC.IO.Handle.Types.$fReadBufferMode2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c4i: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8c4m; else goto c8c4l;
       c8c4m: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8c4l: // global
           I64[Hp - 40] = ds2_s8acw_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8acK_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.123686074 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode1_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode1_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode1_info;
         const 0;
 },
 section ""relreadonly" . u8c4v_srtd" {
     u8c4v_srtd:
         const S8alj_srt+160;
         const 40;
         const 549755813889;
 },
 GHC.IO.Handle.Types.$fReadBufferMode1_entry() //  [R2, R3]
         { info_tbl: [(c8c4s,
                       label: GHC.IO.Handle.Types.$fReadBufferMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c4s: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.127097932 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_info;
         const 0;
 },
 section ""relreadonly" . u8c4M_srtd" {
     u8c4M_srtd:
         const S8alj_srt+160;
         const 40;
         const 549755813889;
 },
 sat_s8acM_entry() //  [R1]
         { info_tbl: [(c8c4E,
                       label: sat_s8acM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c4E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8c4F; else goto c8c4G;
       c8c4F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c4G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadBufferMode2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u8c4N_srtd" {
     u8c4N_srtd:
         const S8alj_srt+160;
         const 41;
         const 1649267441665;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8c4H,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c4H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8c4L; else goto c8c4K;
       c8c4L: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8c4K: // global
           I64[Hp - 16] = sat_s8acM_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.128408048 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8c4U,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c4U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8c4V; else goto c8c4W;
       c8c4V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c4W: // global
           (_c8c4R::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8c4R::I64 == 0) goto c8c4T; else goto c8c4S;
       c8c4T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8c4S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8c4R::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.12947118 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode14_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode14_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode14_entry() //  [R1]
         { info_tbl: [(c8c53,
                       label: GHC.IO.Handle.Types.$fReadBufferMode14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c53: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8c54; else goto c8c55;
       c8c54: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8c55: // global
           (_c8c50::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8c50::I64 == 0) goto c8c52; else goto c8c51;
       c8c52: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8c51: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8c50::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.130474174 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadList_entry() //  [R2]
         { info_tbl: [(c8c5a,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c5a: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode14_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.131195302 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode1_closure+2;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.132801897 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8c5p,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c5p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8c5q; else goto c8c5r;
       c8c5q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8c5r: // global
           I64[Sp - 16] = block_c8c5h_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8c73; else goto c8c5i;
       u8c73: // global
           call _c8c5h(R1) args: 0, res: 0, upd: 0;
       c8c5i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c5h() //  [R1]
         { info_tbl: [(c8c5h,
                       label: block_c8c5h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c5h: // global
           _s8acO::P64 = P64[Sp + 8];
           _c8c5o::P64 = R1 & 7;
           if (_c8c5o::P64 < 3) goto u8c6R; else goto c8c5n;
       u8c6R: // global
           if (_c8c5o::P64 < 2) goto c8c5l; else goto c8c5m;
       c8c5l: // global
           I64[Sp + 8] = block_c8c5u_info;
           R1 = _s8acO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8c70; else goto c8c5w;
       u8c70: // global
           call _c8c5u(R1) args: 0, res: 0, upd: 0;
       c8c5w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8c5m: // global
           I64[Sp + 8] = block_c8c5J_info;
           R1 = _s8acO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8c71; else goto c8c5L;
       u8c71: // global
           call _c8c5J(R1) args: 0, res: 0, upd: 0;
       c8c5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8c5n: // global
           I64[Sp] = block_c8c5Y_info;
           _s8acT::P64 = P64[R1 + 5];
           R1 = _s8acO::P64;
           P64[Sp + 8] = _s8acT::P64;
           if (R1 & 7 != 0) goto u8c72; else goto c8c60;
       u8c72: // global
           call _c8c5Y(R1) args: 0, res: 0, upd: 0;
       c8c60: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c5u() //  [R1]
         { info_tbl: [(c8c5u,
                       label: block_c8c5u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c5u: // global
           if (R1 & 7 == 1) goto u8c6S; else goto u8c6T;
       u8c6S: // global
           Sp = Sp + 8;
           call _c8c6G() args: 0, res: 0, upd: 0;
       u8c6T: // global
           Sp = Sp + 8;
           call _c8c6u() args: 0, res: 0, upd: 0;
     }
 },
 _c8c5J() //  [R1]
         { info_tbl: [(c8c5J,
                       label: block_c8c5J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c5J: // global
           if (R1 & 7 == 3) goto u8c6U; else goto u8c6V;
       u8c6U: // global
           Sp = Sp + 8;
           call _c8c6u() args: 0, res: 0, upd: 0;
       u8c6V: // global
           Sp = Sp + 8;
           call _c8c6G() args: 0, res: 0, upd: 0;
     }
 },
 _c8c5Y() //  [R1]
         { info_tbl: [(c8c5Y,
                       label: block_c8c5Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c5Y: // global
           if (R1 & 7 == 3) goto c8c6b; else goto u8c6W;
       c8c6b: // global
           I64[Sp] = block_c8c69_info;
           _s8acV::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8acV::P64;
           if (R1 & 7 != 0) goto u8c78; else goto c8c6c;
       u8c78: // global
           call _c8c69(R1) args: 0, res: 0, upd: 0;
       c8c6c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8c6W: // global
           Sp = Sp + 16;
           call _c8c6G() args: 0, res: 0, upd: 0;
     }
 },
 _c8c69() //  [R1]
         { info_tbl: [(c8c69,
                       label: block_c8c69_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c69: // global
           _s8acV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8c6j; else goto c8c6z;
       c8c6j: // global
           I64[Sp + 8] = block_c8c6g_info;
           R1 = _s8acV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8c7a; else goto c8c6k;
       u8c7a: // global
           call _c8c6g(R1) args: 0, res: 0, upd: 0;
       c8c6k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8c6z: // global
           I64[Sp] = block_c8c6x_info;
           _s8acZ::P64 = P64[R1 + 6];
           R1 = _s8acV::P64;
           P64[Sp + 8] = _s8acZ::P64;
           if (R1 & 7 != 0) goto u8c7b; else goto c8c6A;
       u8c7b: // global
           call _c8c6x(R1) args: 0, res: 0, upd: 0;
       c8c6A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c6g() //  [R1]
         { info_tbl: [(c8c6g,
                       label: block_c8c6g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c6g: // global
           if (R1 & 7 == 1) goto u8c6Y; else goto u8c6Z;
       u8c6Y: // global
           Sp = Sp + 8;
           call _c8c6G() args: 0, res: 0, upd: 0;
       u8c6Z: // global
           Sp = Sp + 8;
           call _c8c6u() args: 0, res: 0, upd: 0;
     }
 },
 _c8c6u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c6u: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8c6x() //  [R1]
         { info_tbl: [(c8c6x,
                       label: block_c8c6x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c6x: // global
           if (R1 & 7 == 1) goto u8c6X; else goto c8c6K;
       u8c6X: // global
           Sp = Sp + 16;
           call _c8c6G() args: 0, res: 0, upd: 0;
       c8c6K: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.ltInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8c6G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c6G: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.136795013 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8c7r,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c7r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8c7s; else goto c8c7t;
       c8c7s: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8c7t: // global
           I64[Sp - 16] = block_c8c7j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8c9b; else goto c8c7k;
       u8c9b: // global
           call _c8c7j(R1) args: 0, res: 0, upd: 0;
       c8c7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c7j() //  [R1]
         { info_tbl: [(c8c7j,
                       label: block_c8c7j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c7j: // global
           _s8ad3::P64 = P64[Sp + 8];
           _c8c7q::P64 = R1 & 7;
           if (_c8c7q::P64 < 3) goto u8c8X; else goto c8c7p;
       u8c8X: // global
           if (_c8c7q::P64 < 2) goto c8c7n; else goto c8c7o;
       c8c7n: // global
           I64[Sp + 8] = block_c8c7w_info;
           R1 = _s8ad3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8c98; else goto c8c7y;
       u8c98: // global
           call _c8c7w(R1) args: 0, res: 0, upd: 0;
       c8c7y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8c7o: // global
           I64[Sp + 8] = block_c8c7L_info;
           R1 = _s8ad3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8c99; else goto c8c7N;
       u8c99: // global
           call _c8c7L(R1) args: 0, res: 0, upd: 0;
       c8c7N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8c7p: // global
           I64[Sp] = block_c8c84_info;
           _s8ad8::P64 = P64[R1 + 5];
           R1 = _s8ad3::P64;
           P64[Sp + 8] = _s8ad8::P64;
           if (R1 & 7 != 0) goto u8c9a; else goto c8c86;
       u8c9a: // global
           call _c8c84(R1) args: 0, res: 0, upd: 0;
       c8c86: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c7w() //  [R1]
         { info_tbl: [(c8c7w,
                       label: block_c8c7w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c7w: // global
           if (R1 & 7 == 1) goto u8c8Z; else goto u8c90;
       u8c8Z: // global
           Sp = Sp + 8;
           call _c8c8w() args: 0, res: 0, upd: 0;
       u8c90: // global
           Sp = Sp + 8;
           call _c8c8A() args: 0, res: 0, upd: 0;
     }
 },
 _c8c7L() //  [R1]
         { info_tbl: [(c8c7L,
                       label: block_c8c7L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c7L: // global
           _c8c8V::P64 = R1 & 7;
           if (_c8c8V::P64 < 3) goto u8c8Y; else goto u8c91;
       u8c8Y: // global
           if (_c8c8V::P64 < 2) goto u8c93; else goto u8c92;
       u8c93: // global
           Sp = Sp + 8;
           call _c8c8M() args: 0, res: 0, upd: 0;
       u8c92: // global
           Sp = Sp + 8;
           call _c8c8w() args: 0, res: 0, upd: 0;
       u8c91: // global
           Sp = Sp + 8;
           call _c8c8A() args: 0, res: 0, upd: 0;
     }
 },
 _c8c84() //  [R1]
         { info_tbl: [(c8c84,
                       label: block_c8c84_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c84: // global
           if (R1 & 7 == 3) goto c8c8h; else goto u8c94;
       c8c8h: // global
           I64[Sp] = block_c8c8f_info;
           _s8ada::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ada::P64;
           if (R1 & 7 != 0) goto u8c9h; else goto c8c8i;
       u8c9h: // global
           call _c8c8f(R1) args: 0, res: 0, upd: 0;
       c8c8i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8c94: // global
           Sp = Sp + 16;
           call _c8c8M() args: 0, res: 0, upd: 0;
     }
 },
 _c8c8f() //  [R1]
         { info_tbl: [(c8c8f,
                       label: block_c8c8f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c8f: // global
           _s8ada::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8c8p; else goto c8c8F;
       c8c8p: // global
           I64[Sp + 8] = block_c8c8m_info;
           R1 = _s8ada::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8c9j; else goto c8c8q;
       u8c9j: // global
           call _c8c8m(R1) args: 0, res: 0, upd: 0;
       c8c8q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8c8F: // global
           I64[Sp] = block_c8c8D_info;
           _s8ade::P64 = P64[R1 + 6];
           R1 = _s8ada::P64;
           P64[Sp + 8] = _s8ade::P64;
           if (R1 & 7 != 0) goto u8c9k; else goto c8c8G;
       u8c9k: // global
           call _c8c8D(R1) args: 0, res: 0, upd: 0;
       c8c8G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c8m() //  [R1]
         { info_tbl: [(c8c8m,
                       label: block_c8c8m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c8m: // global
           if (R1 & 7 == 1) goto u8c96; else goto u8c97;
       u8c96: // global
           Sp = Sp + 8;
           call _c8c8w() args: 0, res: 0, upd: 0;
       u8c97: // global
           Sp = Sp + 8;
           call _c8c8A() args: 0, res: 0, upd: 0;
     }
 },
 _c8c8w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c8w: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8c8A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c8A: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8c8D() //  [R1]
         { info_tbl: [(c8c8D,
                       label: block_c8c8D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c8D: // global
           if (R1 & 7 == 1) goto u8c95; else goto c8c8Q;
       u8c95: // global
           Sp = Sp + 16;
           call _c8c8M() args: 0, res: 0, upd: 0;
       c8c8Q: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.compareInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8c8M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c8M: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.14054909 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure:
         const GHC.IO.Handle.Types.$fEqBufferMode_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqBufferMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8c9A,
                       label: GHC.IO.Handle.Types.$fEqBufferMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c9A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8c9B; else goto c8c9C;
       c8c9B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8c9C: // global
           I64[Sp - 16] = block_c8c9s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cbe; else goto c8c9t;
       u8cbe: // global
           call _c8c9s(R1) args: 0, res: 0, upd: 0;
       c8c9t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c9s() //  [R1]
         { info_tbl: [(c8c9s,
                       label: block_c8c9s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c9s: // global
           _s8adi::P64 = P64[Sp + 8];
           _c8c9z::P64 = R1 & 7;
           if (_c8c9z::P64 < 3) goto u8cb2; else goto c8c9y;
       u8cb2: // global
           if (_c8c9z::P64 < 2) goto c8c9w; else goto c8c9x;
       c8c9w: // global
           I64[Sp + 8] = block_c8c9F_info;
           R1 = _s8adi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cbb; else goto c8c9H;
       u8cbb: // global
           call _c8c9F(R1) args: 0, res: 0, upd: 0;
       c8c9H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8c9x: // global
           I64[Sp + 8] = block_c8c9U_info;
           R1 = _s8adi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cbc; else goto c8c9W;
       u8cbc: // global
           call _c8c9U(R1) args: 0, res: 0, upd: 0;
       c8c9W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8c9y: // global
           I64[Sp] = block_c8ca9_info;
           _s8adm::P64 = P64[R1 + 5];
           R1 = _s8adi::P64;
           P64[Sp + 8] = _s8adm::P64;
           if (R1 & 7 != 0) goto u8cbd; else goto c8cab;
       u8cbd: // global
           call _c8ca9(R1) args: 0, res: 0, upd: 0;
       c8cab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8c9F() //  [R1]
         { info_tbl: [(c8c9F,
                       label: block_c8c9F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c9F: // global
           if (R1 & 7 == 1) goto u8cb3; else goto u8cb4;
       u8cb3: // global
           Sp = Sp + 8;
           call _c8caB() args: 0, res: 0, upd: 0;
       u8cb4: // global
           Sp = Sp + 8;
           call _c8caR() args: 0, res: 0, upd: 0;
     }
 },
 _c8c9U() //  [R1]
         { info_tbl: [(c8c9U,
                       label: block_c8c9U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8c9U: // global
           if (R1 & 7 == 2) goto u8cb5; else goto u8cb6;
       u8cb5: // global
           Sp = Sp + 8;
           call _c8caB() args: 0, res: 0, upd: 0;
       u8cb6: // global
           Sp = Sp + 8;
           call _c8caR() args: 0, res: 0, upd: 0;
     }
 },
 _c8ca9() //  [R1]
         { info_tbl: [(c8ca9,
                       label: block_c8ca9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ca9: // global
           if (R1 & 7 == 3) goto c8cam; else goto u8cb7;
       c8cam: // global
           I64[Sp] = block_c8cak_info;
           _s8ado::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ado::P64;
           if (R1 & 7 != 0) goto u8cbj; else goto c8can;
       u8cbj: // global
           call _c8cak(R1) args: 0, res: 0, upd: 0;
       c8can: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8cb7: // global
           Sp = Sp + 16;
           call _c8caR() args: 0, res: 0, upd: 0;
     }
 },
 _c8cak() //  [R1]
         { info_tbl: [(c8cak,
                       label: block_c8cak_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cak: // global
           _s8ado::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cau; else goto c8caK;
       c8cau: // global
           I64[Sp + 8] = block_c8car_info;
           R1 = _s8ado::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cbl; else goto c8cav;
       u8cbl: // global
           call _c8car(R1) args: 0, res: 0, upd: 0;
       c8cav: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8caK: // global
           I64[Sp] = block_c8caI_info;
           _s8ads::P64 = P64[R1 + 6];
           R1 = _s8ado::P64;
           P64[Sp + 8] = _s8ads::P64;
           if (R1 & 7 != 0) goto u8cbm; else goto c8caL;
       u8cbm: // global
           call _c8caI(R1) args: 0, res: 0, upd: 0;
       c8caL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8car() //  [R1]
         { info_tbl: [(c8car,
                       label: block_c8car_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8car: // global
           if (R1 & 7 == 1) goto u8cb9; else goto u8cba;
       u8cb9: // global
           Sp = Sp + 8;
           call _c8caB() args: 0, res: 0, upd: 0;
       u8cba: // global
           Sp = Sp + 8;
           call _c8caR() args: 0, res: 0, upd: 0;
     }
 },
 _c8caB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8caB: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8caI() //  [R1]
         { info_tbl: [(c8caI,
                       label: block_c8caI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8caI: // global
           if (R1 & 7 == 1) goto u8cb8; else goto c8caV;
       u8cb8: // global
           Sp = Sp + 16;
           call _c8caR() args: 0, res: 0, upd: 0;
       c8caV: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.eqInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8caR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8caR: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.144382836 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqBufferMode_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqBufferMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8cbC,
                       label: GHC.IO.Handle.Types.$fEqBufferMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cbC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cbD; else goto c8cbE;
       c8cbD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cbE: // global
           I64[Sp - 16] = block_c8cbu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cdz; else goto c8cbv;
       u8cdz: // global
           call _c8cbu(R1) args: 0, res: 0, upd: 0;
       c8cbv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cbu() //  [R1]
         { info_tbl: [(c8cbu,
                       label: block_c8cbu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cbu: // global
           _s8adw::P64 = P64[Sp + 8];
           _c8cbB::P64 = R1 & 7;
           if (_c8cbB::P64 < 3) goto u8cdl; else goto c8cbA;
       u8cdl: // global
           if (_c8cbB::P64 < 2) goto c8cby; else goto c8cbz;
       c8cby: // global
           I64[Sp + 8] = block_c8cbH_info;
           R1 = _s8adw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cdw; else goto c8cbJ;
       u8cdw: // global
           call _c8cbH(R1) args: 0, res: 0, upd: 0;
       c8cbJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cbz: // global
           I64[Sp + 8] = block_c8cbW_info;
           R1 = _s8adw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cdx; else goto c8cbY;
       u8cdx: // global
           call _c8cbW(R1) args: 0, res: 0, upd: 0;
       c8cbY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cbA: // global
           I64[Sp] = block_c8ccb_info;
           _s8adA::P64 = P64[R1 + 5];
           R1 = _s8adw::P64;
           P64[Sp + 8] = _s8adA::P64;
           if (R1 & 7 != 0) goto u8cdy; else goto c8ccd;
       u8cdy: // global
           call _c8ccb(R1) args: 0, res: 0, upd: 0;
       c8ccd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cbH() //  [R1]
         { info_tbl: [(c8cbH,
                       label: block_c8cbH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cbH: // global
           if (R1 & 7 == 1) goto u8cdm; else goto u8cdn;
       u8cdm: // global
           Sp = Sp + 8;
           call _c8cde() args: 0, res: 0, upd: 0;
       u8cdn: // global
           Sp = Sp + 8;
           call _c8cdd() args: 0, res: 0, upd: 0;
     }
 },
 _c8cbW() //  [R1]
         { info_tbl: [(c8cbW,
                       label: block_c8cbW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cbW: // global
           if (R1 & 7 == 2) goto u8cdo; else goto u8cdp;
       u8cdo: // global
           Sp = Sp + 8;
           call _c8cde() args: 0, res: 0, upd: 0;
       u8cdp: // global
           Sp = Sp + 8;
           call _c8cdd() args: 0, res: 0, upd: 0;
     }
 },
 _c8ccb() //  [R1]
         { info_tbl: [(c8ccb,
                       label: block_c8ccb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ccb: // global
           if (R1 & 7 == 3) goto c8cco; else goto u8cdq;
       c8cco: // global
           I64[Sp] = block_c8ccm_info;
           _s8adC::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8adC::P64;
           if (R1 & 7 != 0) goto u8cdE; else goto c8ccp;
       u8cdE: // global
           call _c8ccm(R1) args: 0, res: 0, upd: 0;
       c8ccp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8cdq: // global
           Sp = Sp + 16;
           call _c8cdd() args: 0, res: 0, upd: 0;
     }
 },
 _c8ccm() //  [R1]
         { info_tbl: [(c8ccm,
                       label: block_c8ccm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ccm: // global
           _s8adC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ccw; else goto c8ccM;
       c8ccw: // global
           I64[Sp + 8] = block_c8cct_info;
           R1 = _s8adC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cdG; else goto c8ccx;
       u8cdG: // global
           call _c8cct(R1) args: 0, res: 0, upd: 0;
       c8ccx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ccM: // global
           I64[Sp] = block_c8ccK_info;
           _s8adG::P64 = P64[R1 + 6];
           R1 = _s8adC::P64;
           P64[Sp + 8] = _s8adG::P64;
           if (R1 & 7 != 0) goto u8cdH; else goto c8ccN;
       u8cdH: // global
           call _c8ccK(R1) args: 0, res: 0, upd: 0;
       c8ccN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cct() //  [R1]
         { info_tbl: [(c8cct,
                       label: block_c8cct_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cct: // global
           if (R1 & 7 == 1) goto u8cdu; else goto u8cdv;
       u8cdu: // global
           Sp = Sp + 8;
           call _c8cde() args: 0, res: 0, upd: 0;
       u8cdv: // global
           Sp = Sp + 8;
           call _c8cdd() args: 0, res: 0, upd: 0;
     }
 },
 _c8ccK() //  [R1]
         { info_tbl: [(c8ccK,
                       label: block_c8ccK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ccK: // global
           if (R1 & 7 == 1) goto u8cdr; else goto c8cd3;
       u8cdr: // global
           Sp = Sp + 16;
           call _c8cdd() args: 0, res: 0, upd: 0;
       c8cd3: // global
           I64[Sp] = block_c8ccW_info;
           _s8adI::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8adI::P64;
           if (R1 & 7 != 0) goto u8cdK; else goto c8ccX;
       u8cdK: // global
           call _c8ccW(R1) args: 0, res: 0, upd: 0;
       c8ccX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ccW() //  [R1]
         { info_tbl: [(c8ccW,
                       label: block_c8ccW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ccW: // global
           I64[Sp] = block_c8cd1_info;
           _s8adK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8adK::I64;
           if (R1 & 7 != 0) goto u8cdM; else goto c8cd5;
       u8cdM: // global
           call _c8cd1(R1) args: 0, res: 0, upd: 0;
       c8cd5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cd1() //  [R1]
         { info_tbl: [(c8cd1,
                       label: block_c8cd1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cd1: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u8cds; else goto u8cdt;
       u8cds: // global
           Sp = Sp + 16;
           call _c8cde() args: 0, res: 0, upd: 0;
       u8cdt: // global
           Sp = Sp + 16;
           call _c8cdd() args: 0, res: 0, upd: 0;
     }
 },
 _c8cde() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cde: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cdd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cdd: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.147412729 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.149162493 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8ce1,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ce1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ce2; else goto c8ce3;
       c8ce2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ce3: // global
           I64[Sp - 16] = block_c8cdT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cfY; else goto c8cdU;
       u8cfY: // global
           call _c8cdT(R1) args: 0, res: 0, upd: 0;
       c8cdU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cdT() //  [R1]
         { info_tbl: [(c8cdT,
                       label: block_c8cdT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cdT: // global
           _s8adO::P64 = P64[Sp + 8];
           _c8ce0::P64 = R1 & 7;
           if (_c8ce0::P64 < 3) goto u8cfK; else goto c8cdZ;
       u8cfK: // global
           if (_c8ce0::P64 < 2) goto c8cdX; else goto c8cdY;
       c8cdX: // global
           I64[Sp + 8] = block_c8ce6_info;
           R1 = _s8adO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cfV; else goto c8ce8;
       u8cfV: // global
           call _c8ce6(R1) args: 0, res: 0, upd: 0;
       c8ce8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cdY: // global
           I64[Sp + 8] = block_c8cel_info;
           R1 = _s8adO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cfW; else goto c8cen;
       u8cfW: // global
           call _c8cel(R1) args: 0, res: 0, upd: 0;
       c8cen: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cdZ: // global
           I64[Sp] = block_c8ceA_info;
           _s8adU::P64 = P64[R1 + 5];
           R1 = _s8adO::P64;
           P64[Sp + 8] = _s8adU::P64;
           if (R1 & 7 != 0) goto u8cfX; else goto c8ceC;
       u8cfX: // global
           call _c8ceA(R1) args: 0, res: 0, upd: 0;
       c8ceC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ce6() //  [R1]
         { info_tbl: [(c8ce6,
                       label: block_c8ce6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ce6: // global
           if (R1 & 7 == 1) goto u8cfL; else goto u8cfM;
       u8cfL: // global
           Sp = Sp + 8;
           call _c8cfC() args: 0, res: 0, upd: 0;
       u8cfM: // global
           Sp = Sp + 8;
           call _c8cfD() args: 0, res: 0, upd: 0;
     }
 },
 _c8cel() //  [R1]
         { info_tbl: [(c8cel,
                       label: block_c8cel_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cel: // global
           if (R1 & 7 == 3) goto u8cfN; else goto u8cfO;
       u8cfN: // global
           Sp = Sp + 8;
           call _c8cfD() args: 0, res: 0, upd: 0;
       u8cfO: // global
           Sp = Sp + 8;
           call _c8cfC() args: 0, res: 0, upd: 0;
     }
 },
 _c8ceA() //  [R1]
         { info_tbl: [(c8ceA,
                       label: block_c8ceA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ceA: // global
           if (R1 & 7 == 3) goto c8ceN; else goto u8cfP;
       c8ceN: // global
           I64[Sp] = block_c8ceL_info;
           _s8adW::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8adW::P64;
           if (R1 & 7 != 0) goto u8cg3; else goto c8ceO;
       u8cg3: // global
           call _c8ceL(R1) args: 0, res: 0, upd: 0;
       c8ceO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8cfP: // global
           Sp = Sp + 16;
           call _c8cfC() args: 0, res: 0, upd: 0;
     }
 },
 _c8ceL() //  [R1]
         { info_tbl: [(c8ceL,
                       label: block_c8ceL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ceL: // global
           _s8adW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ceV; else goto c8cfb;
       c8ceV: // global
           I64[Sp + 8] = block_c8ceS_info;
           R1 = _s8adW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cg5; else goto c8ceW;
       u8cg5: // global
           call _c8ceS(R1) args: 0, res: 0, upd: 0;
       c8ceW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cfb: // global
           I64[Sp] = block_c8cf9_info;
           _s8ae0::P64 = P64[R1 + 6];
           R1 = _s8adW::P64;
           P64[Sp + 8] = _s8ae0::P64;
           if (R1 & 7 != 0) goto u8cg6; else goto c8cfc;
       u8cg6: // global
           call _c8cf9(R1) args: 0, res: 0, upd: 0;
       c8cfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ceS() //  [R1]
         { info_tbl: [(c8ceS,
                       label: block_c8ceS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ceS: // global
           if (R1 & 7 == 1) goto u8cfT; else goto u8cfU;
       u8cfT: // global
           Sp = Sp + 8;
           call _c8cfC() args: 0, res: 0, upd: 0;
       u8cfU: // global
           Sp = Sp + 8;
           call _c8cfD() args: 0, res: 0, upd: 0;
     }
 },
 _c8cf9() //  [R1]
         { info_tbl: [(c8cf9,
                       label: block_c8cf9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cf9: // global
           if (R1 & 7 == 1) goto u8cfQ; else goto c8cfs;
       u8cfQ: // global
           Sp = Sp + 16;
           call _c8cfC() args: 0, res: 0, upd: 0;
       c8cfs: // global
           I64[Sp] = block_c8cfl_info;
           _s8ae2::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ae2::P64;
           if (R1 & 7 != 0) goto u8cg9; else goto c8cfm;
       u8cg9: // global
           call _c8cfl(R1) args: 0, res: 0, upd: 0;
       c8cfm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cfl() //  [R1]
         { info_tbl: [(c8cfl,
                       label: block_c8cfl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cfl: // global
           I64[Sp] = block_c8cfq_info;
           _s8ae4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ae4::I64;
           if (R1 & 7 != 0) goto u8cgb; else goto c8cfu;
       u8cgb: // global
           call _c8cfq(R1) args: 0, res: 0, upd: 0;
       c8cfu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cfq() //  [R1]
         { info_tbl: [(c8cfq,
                       label: block_c8cfq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cfq: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8cfS; else goto u8cfR;
       u8cfS: // global
           Sp = Sp + 16;
           call _c8cfC() args: 0, res: 0, upd: 0;
       u8cfR: // global
           Sp = Sp + 16;
           call _c8cfD() args: 0, res: 0, upd: 0;
     }
 },
 _c8cfD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cfD: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cfC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cfC: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.153429712 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8cgq,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cgq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8cgr; else goto c8cgs;
       c8cgr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cgs: // global
           I64[Sp - 16] = block_c8cgi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ci5; else goto c8cgj;
       u8ci5: // global
           call _c8cgi(R1) args: 0, res: 0, upd: 0;
       c8cgj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cgi() //  [R1]
         { info_tbl: [(c8cgi,
                       label: block_c8cgi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cgi: // global
           _s8ae8::P64 = P64[Sp + 8];
           _c8cgp::P64 = R1 & 7;
           if (_c8cgp::P64 < 3) goto u8chW; else goto c8cgo;
       u8chW: // global
           if (_c8cgp::P64 < 2) goto c8cgm; else goto c8cgn;
       c8cgm: // global
           R1 = _s8ae8::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8cgn: // global
           I64[Sp + 8] = block_c8cgy_info;
           R1 = _s8ae8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ci3; else goto c8cgA;
       u8ci3: // global
           call _c8cgy(R1) args: 0, res: 0, upd: 0;
       c8cgA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cgo: // global
           I64[Sp - 8] = block_c8cgN_info;
           _s8aea::P64 = R1;
           _s8aed::P64 = P64[R1 + 5];
           R1 = _s8ae8::P64;
           P64[Sp] = _s8aed::P64;
           P64[Sp + 8] = _s8aea::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ci4; else goto c8cgP;
       u8ci4: // global
           call _c8cgN(R1) args: 0, res: 0, upd: 0;
       c8cgP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cgy() //  [R1]
         { info_tbl: [(c8cgy,
                       label: block_c8cgy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cgy: // global
           if (R1 & 7 == 3) goto c8cgK; else goto c8cgG;
       c8cgK: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8cgG: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cgN() //  [R1]
         { info_tbl: [(c8cgN,
                       label: block_c8cgN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cgN: // global
           if (R1 & 7 == 3) goto c8ch0; else goto u8chX;
       c8ch0: // global
           I64[Sp - 8] = block_c8cgY_info;
           _s8aee::P64 = R1;
           _s8aef::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aef::P64;
           P64[Sp + 8] = _s8aee::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ci6; else goto c8ch1;
       u8ci6: // global
           call _c8cgY(R1) args: 0, res: 0, upd: 0;
       c8ch1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8chX: // global
           Sp = Sp + 16;
           call _c8chP() args: 0, res: 0, upd: 0;
     }
 },
 _c8cgY() //  [R1]
         { info_tbl: [(c8cgY,
                       label: block_c8cgY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cgY: // global
           _s8aef::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ch8; else goto c8cho;
       c8ch8: // global
           I64[Sp + 8] = block_c8ch5_info;
           R1 = _s8aef::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ci8; else goto c8ch9;
       u8ci8: // global
           call _c8ch5(R1) args: 0, res: 0, upd: 0;
       c8ch9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cho: // global
           I64[Sp] = block_c8chm_info;
           _s8aej::P64 = P64[R1 + 6];
           R1 = _s8aef::P64;
           P64[Sp + 8] = _s8aej::P64;
           if (R1 & 7 != 0) goto u8ci9; else goto c8chp;
       u8ci9: // global
           call _c8chm(R1) args: 0, res: 0, upd: 0;
       c8chp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ch5() //  [R1]
         { info_tbl: [(c8ch5,
                       label: block_c8ch5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ch5: // global
           if (R1 & 7 == 1) goto u8ci1; else goto u8ci2;
       u8ci1: // global
           Sp = Sp + 16;
           call _c8chP() args: 0, res: 0, upd: 0;
       u8ci2: // global
           Sp = Sp + 8;
           call _c8chQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8chm() //  [R1]
         { info_tbl: [(c8chm,
                       label: block_c8chm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8chm: // global
           if (R1 & 7 == 1) goto u8chY; else goto c8chF;
       u8chY: // global
           Sp = Sp + 24;
           call _c8chP() args: 0, res: 0, upd: 0;
       c8chF: // global
           I64[Sp] = block_c8chy_info;
           _s8ael::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ael::P64;
           if (R1 & 7 != 0) goto u8cic; else goto c8chz;
       u8cic: // global
           call _c8chy(R1) args: 0, res: 0, upd: 0;
       c8chz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8chy() //  [R1]
         { info_tbl: [(c8chy,
                       label: block_c8chy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8chy: // global
           I64[Sp] = block_c8chD_info;
           _s8aen::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8aen::I64;
           if (R1 & 7 != 0) goto u8cie; else goto c8chH;
       u8cie: // global
           call _c8chD(R1) args: 0, res: 0, upd: 0;
       c8chH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8chD() //  [R1]
         { info_tbl: [(c8chD,
                       label: block_c8chD_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8chD: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8ci0; else goto u8chZ;
       u8ci0: // global
           Sp = Sp + 24;
           call _c8chP() args: 0, res: 0, upd: 0;
       u8chZ: // global
           Sp = Sp + 16;
           call _c8chQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8chQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8chQ: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8chP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8chP: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.157609926 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8cit,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cit: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ciu; else goto c8civ;
       c8ciu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8civ: // global
           I64[Sp - 16] = block_c8cil_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ckq; else goto c8cim;
       u8ckq: // global
           call _c8cil(R1) args: 0, res: 0, upd: 0;
       c8cim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cil() //  [R1]
         { info_tbl: [(c8cil,
                       label: block_c8cil_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cil: // global
           _s8aes::P64 = P64[Sp + 8];
           _c8cis::P64 = R1 & 7;
           if (_c8cis::P64 < 3) goto u8ckc; else goto c8cir;
       u8ckc: // global
           if (_c8cis::P64 < 2) goto c8cip; else goto c8ciq;
       c8cip: // global
           I64[Sp + 8] = block_c8ciy_info;
           R1 = _s8aes::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ckn; else goto c8ciA;
       u8ckn: // global
           call _c8ciy(R1) args: 0, res: 0, upd: 0;
       c8ciA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ciq: // global
           I64[Sp + 8] = block_c8ciN_info;
           R1 = _s8aes::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cko; else goto c8ciP;
       u8cko: // global
           call _c8ciN(R1) args: 0, res: 0, upd: 0;
       c8ciP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cir: // global
           I64[Sp] = block_c8cj2_info;
           _s8aex::P64 = P64[R1 + 5];
           R1 = _s8aes::P64;
           P64[Sp + 8] = _s8aex::P64;
           if (R1 & 7 != 0) goto u8ckp; else goto c8cj4;
       u8ckp: // global
           call _c8cj2(R1) args: 0, res: 0, upd: 0;
       c8cj4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ciy() //  [R1]
         { info_tbl: [(c8ciy,
                       label: block_c8ciy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ciy: // global
           if (R1 & 7 == 1) goto u8ckd; else goto u8cke;
       u8ckd: // global
           Sp = Sp + 8;
           call _c8ck4() args: 0, res: 0, upd: 0;
       u8cke: // global
           Sp = Sp + 8;
           call _c8ck5() args: 0, res: 0, upd: 0;
     }
 },
 _c8ciN() //  [R1]
         { info_tbl: [(c8ciN,
                       label: block_c8ciN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ciN: // global
           if (R1 & 7 == 3) goto u8ckf; else goto u8ckg;
       u8ckf: // global
           Sp = Sp + 8;
           call _c8ck5() args: 0, res: 0, upd: 0;
       u8ckg: // global
           Sp = Sp + 8;
           call _c8ck4() args: 0, res: 0, upd: 0;
     }
 },
 _c8cj2() //  [R1]
         { info_tbl: [(c8cj2,
                       label: block_c8cj2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cj2: // global
           if (R1 & 7 == 3) goto c8cjf; else goto u8ckh;
       c8cjf: // global
           I64[Sp] = block_c8cjd_info;
           _s8aez::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8aez::P64;
           if (R1 & 7 != 0) goto u8ckv; else goto c8cjg;
       u8ckv: // global
           call _c8cjd(R1) args: 0, res: 0, upd: 0;
       c8cjg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8ckh: // global
           Sp = Sp + 16;
           call _c8ck4() args: 0, res: 0, upd: 0;
     }
 },
 _c8cjd() //  [R1]
         { info_tbl: [(c8cjd,
                       label: block_c8cjd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cjd: // global
           _s8aez::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cjn; else goto c8cjD;
       c8cjn: // global
           I64[Sp + 8] = block_c8cjk_info;
           R1 = _s8aez::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ckx; else goto c8cjo;
       u8ckx: // global
           call _c8cjk(R1) args: 0, res: 0, upd: 0;
       c8cjo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cjD: // global
           I64[Sp] = block_c8cjB_info;
           _s8aeD::P64 = P64[R1 + 6];
           R1 = _s8aez::P64;
           P64[Sp + 8] = _s8aeD::P64;
           if (R1 & 7 != 0) goto u8cky; else goto c8cjE;
       u8cky: // global
           call _c8cjB(R1) args: 0, res: 0, upd: 0;
       c8cjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cjk() //  [R1]
         { info_tbl: [(c8cjk,
                       label: block_c8cjk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cjk: // global
           if (R1 & 7 == 1) goto u8ckl; else goto u8ckm;
       u8ckl: // global
           Sp = Sp + 8;
           call _c8ck4() args: 0, res: 0, upd: 0;
       u8ckm: // global
           Sp = Sp + 8;
           call _c8ck5() args: 0, res: 0, upd: 0;
     }
 },
 _c8cjB() //  [R1]
         { info_tbl: [(c8cjB,
                       label: block_c8cjB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cjB: // global
           if (R1 & 7 == 1) goto u8cki; else goto c8cjU;
       u8cki: // global
           Sp = Sp + 16;
           call _c8ck4() args: 0, res: 0, upd: 0;
       c8cjU: // global
           I64[Sp] = block_c8cjN_info;
           _s8aeF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8aeF::P64;
           if (R1 & 7 != 0) goto u8ckB; else goto c8cjO;
       u8ckB: // global
           call _c8cjN(R1) args: 0, res: 0, upd: 0;
       c8cjO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cjN() //  [R1]
         { info_tbl: [(c8cjN,
                       label: block_c8cjN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cjN: // global
           I64[Sp] = block_c8cjS_info;
           _s8aeH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8aeH::I64;
           if (R1 & 7 != 0) goto u8ckD; else goto c8cjW;
       u8ckD: // global
           call _c8cjS(R1) args: 0, res: 0, upd: 0;
       c8cjW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cjS() //  [R1]
         { info_tbl: [(c8cjS,
                       label: block_c8cjS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cjS: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8ckk; else goto u8ckj;
       u8ckk: // global
           Sp = Sp + 16;
           call _c8ck4() args: 0, res: 0, upd: 0;
       u8ckj: // global
           Sp = Sp + 16;
           call _c8ck5() args: 0, res: 0, upd: 0;
     }
 },
 _c8ck5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ck5: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ck4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ck4: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.160754134 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8ckK,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ckK: // global
           _s8aeM::P64 = R3;
           R3 = R2;
           R2 = _s8aeM::P64;
           call GHC.IO.Handle.Types.$fOrdBufferMode_$c<_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.162773578 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8ckZ,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ckZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8cl0; else goto c8cl1;
       c8cl0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cl1: // global
           I64[Sp - 16] = block_c8ckR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cmL; else goto c8ckS;
       u8cmL: // global
           call _c8ckR(R1) args: 0, res: 0, upd: 0;
       c8ckS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ckR() //  [R1]
         { info_tbl: [(c8ckR,
                       label: block_c8ckR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ckR: // global
           _s8aeN::P64 = P64[Sp + 8];
           _c8ckY::P64 = R1 & 7;
           if (_c8ckY::P64 < 3) goto u8cmB; else goto c8ckX;
       u8cmB: // global
           if (_c8ckY::P64 < 2) goto c8ckV; else goto c8ckW;
       c8ckV: // global
           I64[Sp + 8] = block_c8cl4_info;
           R1 = _s8aeN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cmI; else goto c8cl6;
       u8cmI: // global
           call _c8cl4() args: 0, res: 0, upd: 0;
       c8cl6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ckW: // global
           I64[Sp + 8] = block_c8cld_info;
           R1 = _s8aeN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cmJ; else goto c8clf;
       u8cmJ: // global
           call _c8cld(R1) args: 0, res: 0, upd: 0;
       c8clf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ckX: // global
           I64[Sp - 8] = block_c8cls_info;
           _s8aeP::P64 = R1;
           _s8aeT::P64 = P64[R1 + 5];
           R1 = _s8aeN::P64;
           P64[Sp] = _s8aeT::P64;
           P64[Sp + 8] = _s8aeP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cmK; else goto c8clu;
       u8cmK: // global
           call _c8cls(R1) args: 0, res: 0, upd: 0;
       c8clu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cl4() //  []
         { info_tbl: [(c8cl4,
                       label: block_c8cl4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cl4: // global
           R1 = GHC.IO.Handle.Types.NoBuffering_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cld() //  [R1]
         { info_tbl: [(c8cld,
                       label: block_c8cld_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cld: // global
           if (R1 & 7 == 3) goto c8clp; else goto c8cll;
       c8clp: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8cll: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cls() //  [R1]
         { info_tbl: [(c8cls,
                       label: block_c8cls_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cls: // global
           if (R1 & 7 == 3) goto c8clF; else goto u8cmC;
       c8clF: // global
           I64[Sp - 8] = block_c8clD_info;
           _s8aeU::P64 = R1;
           _s8aeV::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aeV::P64;
           P64[Sp + 8] = _s8aeU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cmM; else goto c8clG;
       u8cmM: // global
           call _c8clD(R1) args: 0, res: 0, upd: 0;
       c8clG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8cmC: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8cmu() args: 0, res: 0, upd: 0;
     }
 },
 _c8clD() //  [R1]
         { info_tbl: [(c8clD,
                       label: block_c8clD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8clD: // global
           _s8aeV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8clN; else goto c8cm3;
       c8clN: // global
           I64[Sp + 8] = block_c8clK_info;
           R1 = _s8aeV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cmO; else goto c8clO;
       u8cmO: // global
           call _c8clK(R1) args: 0, res: 0, upd: 0;
       c8clO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cm3: // global
           I64[Sp] = block_c8cm1_info;
           _s8aeZ::P64 = P64[R1 + 6];
           R1 = _s8aeV::P64;
           P64[Sp + 8] = _s8aeZ::P64;
           if (R1 & 7 != 0) goto u8cmP; else goto c8cm4;
       u8cmP: // global
           call _c8cm1(R1) args: 0, res: 0, upd: 0;
       c8cm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8clK() //  [R1]
         { info_tbl: [(c8clK,
                       label: block_c8clK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8clK: // global
           if (R1 & 7 == 1) goto u8cmG; else goto u8cmH;
       u8cmG: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8cmu() args: 0, res: 0, upd: 0;
       u8cmH: // global
           Sp = Sp + 16;
           call _c8cmv() args: 0, res: 0, upd: 0;
     }
 },
 _c8cm1() //  [R1]
         { info_tbl: [(c8cm1,
                       label: block_c8cm1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cm1: // global
           if (R1 & 7 == 1) goto u8cmD; else goto c8cmk;
       u8cmD: // global
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp + 24;
           call _c8cmu() args: 0, res: 0, upd: 0;
       c8cmk: // global
           I64[Sp] = block_c8cmd_info;
           _s8af1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8af1::P64;
           if (R1 & 7 != 0) goto u8cmS; else goto c8cme;
       u8cmS: // global
           call _c8cmd(R1) args: 0, res: 0, upd: 0;
       c8cme: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cmd() //  [R1]
         { info_tbl: [(c8cmd,
                       label: block_c8cmd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cmd: // global
           I64[Sp] = block_c8cmi_info;
           _s8af3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8af3::I64;
           if (R1 & 7 != 0) goto u8cmU; else goto c8cmm;
       u8cmU: // global
           call _c8cmi(R1) args: 0, res: 0, upd: 0;
       c8cmm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cmi() //  [R1]
         { info_tbl: [(c8cmi,
                       label: block_c8cmi_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cmi: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8cmF; else goto u8cmE;
       u8cmF: // global
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp + 24;
           call _c8cmu() args: 0, res: 0, upd: 0;
       u8cmE: // global
           Sp = Sp + 24;
           call _c8cmv() args: 0, res: 0, upd: 0;
     }
 },
 _c8cmv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cmv: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cmu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cmu: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.166014455 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqBufferMode_closure+1;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.166874269 UTC

[section ""data" . GHC.IO.Handle.Types.haOtherSide_closure" {
     GHC.IO.Handle.Types.haOtherSide_closure:
         const GHC.IO.Handle.Types.haOtherSide_info;
 },
 GHC.IO.Handle.Types.haOtherSide_entry() //  [R2]
         { info_tbl: [(c8cn4,
                       label: GHC.IO.Handle.Types.haOtherSide_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cn4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cn5; else goto c8cn6;
       c8cn5: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haOtherSide_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cn6: // global
           I64[Sp - 8] = block_c8cn1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cna; else goto c8cn2;
       u8cna: // global
           call _c8cn1(R1) args: 0, res: 0, upd: 0;
       c8cn2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cn1() //  [R1]
         { info_tbl: [(c8cn1,
                       label: block_c8cn1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cn1: // global
           R1 = P64[R1 + 127] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.168023468 UTC

[section ""data" . GHC.IO.Handle.Types.haOutputNL_closure" {
     GHC.IO.Handle.Types.haOutputNL_closure:
         const GHC.IO.Handle.Types.haOutputNL_info;
 },
 GHC.IO.Handle.Types.haOutputNL_entry() //  [R2]
         { info_tbl: [(c8cni,
                       label: GHC.IO.Handle.Types.haOutputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cni: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cnj; else goto c8cnk;
       c8cnj: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haOutputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cnk: // global
           I64[Sp - 8] = block_c8cnf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cno; else goto c8cng;
       u8cno: // global
           call _c8cnf(R1) args: 0, res: 0, upd: 0;
       c8cng: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cnf() //  [R1]
         { info_tbl: [(c8cnf,
                       label: block_c8cnf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cnf: // global
           R1 = P64[R1 + 119] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.169182085 UTC

[section ""data" . GHC.IO.Handle.Types.haInputNL_closure" {
     GHC.IO.Handle.Types.haInputNL_closure:
         const GHC.IO.Handle.Types.haInputNL_info;
 },
 GHC.IO.Handle.Types.haInputNL_entry() //  [R2]
         { info_tbl: [(c8cnw,
                       label: GHC.IO.Handle.Types.haInputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cnw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cnx; else goto c8cny;
       c8cnx: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haInputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cny: // global
           I64[Sp - 8] = block_c8cnt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cnC; else goto c8cnu;
       u8cnC: // global
           call _c8cnt(R1) args: 0, res: 0, upd: 0;
       c8cnu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cnt() //  [R1]
         { info_tbl: [(c8cnt,
                       label: block_c8cnt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cnt: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.17037914 UTC

[section ""data" . GHC.IO.Handle.Types.haCodec_closure" {
     GHC.IO.Handle.Types.haCodec_closure:
         const GHC.IO.Handle.Types.haCodec_info;
 },
 GHC.IO.Handle.Types.haCodec_entry() //  [R2]
         { info_tbl: [(c8cnK,
                       label: GHC.IO.Handle.Types.haCodec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cnK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cnL; else goto c8cnM;
       c8cnL: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haCodec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cnM: // global
           I64[Sp - 8] = block_c8cnH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cnQ; else goto c8cnI;
       u8cnQ: // global
           call _c8cnH(R1) args: 0, res: 0, upd: 0;
       c8cnI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cnH() //  [R1]
         { info_tbl: [(c8cnH,
                       label: block_c8cnH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cnH: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.171354332 UTC

[section ""data" . GHC.IO.Handle.Types.haDecoder_closure" {
     GHC.IO.Handle.Types.haDecoder_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.171901758 UTC

[section ""data" . GHC.IO.Handle.Types.haEncoder_closure" {
     GHC.IO.Handle.Types.haEncoder_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.172757267 UTC

[section ""data" . GHC.IO.Handle.Types.haBuffers_closure" {
     GHC.IO.Handle.Types.haBuffers_closure:
         const GHC.IO.Handle.Types.haBuffers_info;
 },
 GHC.IO.Handle.Types.haBuffers_entry() //  [R2]
         { info_tbl: [(c8cnY,
                       label: GHC.IO.Handle.Types.haBuffers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cnY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8co2; else goto c8co3;
       c8co2: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haBuffers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8co3: // global
           I64[Sp - 8] = block_c8cnV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8co7; else goto c8cnW;
       u8co7: // global
           call _c8cnV(R1) args: 0, res: 0, upd: 0;
       c8cnW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cnV() //  [R1]
         { info_tbl: [(c8cnV,
                       label: block_c8cnV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cnV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8co6; else goto c8co5;
       c8co6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8co5: // global
           _s8ags::P64 = P64[R1 + 79];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8ags::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.174174835 UTC

[section ""data" . GHC.IO.Handle.Types.haCharBuffer_closure" {
     GHC.IO.Handle.Types.haCharBuffer_closure:
         const GHC.IO.Handle.Types.haCharBuffer_info;
 },
 GHC.IO.Handle.Types.haCharBuffer_entry() //  [R2]
         { info_tbl: [(c8cof,
                       label: GHC.IO.Handle.Types.haCharBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cof: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8coj; else goto c8cok;
       c8coj: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haCharBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cok: // global
           I64[Sp - 8] = block_c8coc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8coo; else goto c8cod;
       u8coo: // global
           call _c8coc(R1) args: 0, res: 0, upd: 0;
       c8cod: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8coc() //  [R1]
         { info_tbl: [(c8coc,
                       label: block_c8coc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8coc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8con; else goto c8com;
       c8con: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8com: // global
           _s8agJ::P64 = P64[R1 + 71];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8agJ::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.17526749 UTC

[section ""data" . GHC.IO.Handle.Types.haLastDecode_closure" {
     GHC.IO.Handle.Types.haLastDecode_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.176040849 UTC

[section ""data" . GHC.IO.Handle.Types.haBufferMode_closure" {
     GHC.IO.Handle.Types.haBufferMode_closure:
         const GHC.IO.Handle.Types.haBufferMode_info;
 },
 GHC.IO.Handle.Types.haBufferMode_entry() //  [R2]
         { info_tbl: [(c8cow,
                       label: GHC.IO.Handle.Types.haBufferMode_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cow: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cox; else goto c8coy;
       c8cox: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haBufferMode_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8coy: // global
           I64[Sp - 8] = block_c8cot_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8coC; else goto c8cou;
       u8coC: // global
           call _c8cot(R1) args: 0, res: 0, upd: 0;
       c8cou: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cot() //  [R1]
         { info_tbl: [(c8cot,
                       label: block_c8cot_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cot: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.17742383 UTC

[section ""data" . GHC.IO.Handle.Types.haByteBuffer_closure" {
     GHC.IO.Handle.Types.haByteBuffer_closure:
         const GHC.IO.Handle.Types.haByteBuffer_info;
 },
 GHC.IO.Handle.Types.haByteBuffer_entry() //  [R2]
         { info_tbl: [(c8coK,
                       label: GHC.IO.Handle.Types.haByteBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8coK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8coO; else goto c8coP;
       c8coO: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haByteBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8coP: // global
           I64[Sp - 8] = block_c8coH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8coT; else goto c8coI;
       u8coT: // global
           call _c8coH(R1) args: 0, res: 0, upd: 0;
       c8coI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8coH() //  [R1]
         { info_tbl: [(c8coH,
                       label: block_c8coH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8coH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8coS; else goto c8coR;
       c8coS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8coR: // global
           _s8ahg::P64 = P64[R1 + 47];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8ahg::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.178695426 UTC

[section ""data" . GHC.IO.Handle.Types.haType_closure" {
     GHC.IO.Handle.Types.haType_closure:
         const GHC.IO.Handle.Types.haType_info;
 },
 GHC.IO.Handle.Types.haType_entry() //  [R2]
         { info_tbl: [(c8cp1,
                       label: GHC.IO.Handle.Types.haType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cp1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cp2; else goto c8cp3;
       c8cp2: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cp3: // global
           I64[Sp - 8] = block_c8coY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cp7; else goto c8coZ;
       u8cp7: // global
           call _c8coY(R1) args: 0, res: 0, upd: 0;
       c8coZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8coY() //  [R1]
         { info_tbl: [(c8coY,
                       label: block_c8coY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8coY: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.179689258 UTC

[section ""data" . GHC.IO.Handle.Types.haDevice_closure" {
     GHC.IO.Handle.Types.haDevice_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.180458563 UTC

[section ""data" . GHC.IO.Handle.Types.outputNL_closure" {
     GHC.IO.Handle.Types.outputNL_closure:
         const GHC.IO.Handle.Types.outputNL_info;
 },
 GHC.IO.Handle.Types.outputNL_entry() //  [R2]
         { info_tbl: [(c8cpf,
                       label: GHC.IO.Handle.Types.outputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cpf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cpg; else goto c8cph;
       c8cpg: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.outputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cph: // global
           I64[Sp - 8] = block_c8cpc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cpl; else goto c8cpd;
       u8cpl: // global
           call _c8cpc(R1) args: 0, res: 0, upd: 0;
       c8cpd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cpc() //  [R1]
         { info_tbl: [(c8cpc,
                       label: block_c8cpc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cpc: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.181677558 UTC

[section ""data" . GHC.IO.Handle.Types.inputNL_closure" {
     GHC.IO.Handle.Types.inputNL_closure:
         const GHC.IO.Handle.Types.inputNL_info;
 },
 GHC.IO.Handle.Types.inputNL_entry() //  [R2]
         { info_tbl: [(c8cpt,
                       label: GHC.IO.Handle.Types.inputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cpt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cpu; else goto c8cpv;
       c8cpu: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.inputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cpv: // global
           I64[Sp - 8] = block_c8cpq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cpz; else goto c8cpr;
       u8cpz: // global
           call _c8cpq(R1) args: 0, res: 0, upd: 0;
       c8cpr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cpq() //  [R1]
         { info_tbl: [(c8cpq,
                       label: block_c8cpq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cpq: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.182999995 UTC

[section ""data" . GHC.IO.Handle.Types.isReadableHandleType_closure" {
     GHC.IO.Handle.Types.isReadableHandleType_closure:
         const GHC.IO.Handle.Types.isReadableHandleType_info;
 },
 GHC.IO.Handle.Types.isReadableHandleType_entry() //  [R2]
         { info_tbl: [(c8cpM,
                       label: GHC.IO.Handle.Types.isReadableHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cpM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cpN; else goto c8cpO;
       c8cpN: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isReadableHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cpO: // global
           I64[Sp - 8] = block_c8cpE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cpZ; else goto c8cpF;
       u8cpZ: // global
           call _c8cpE(R1) args: 0, res: 0, upd: 0;
       c8cpF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cpE() //  [R1]
         { info_tbl: [(c8cpE,
                       label: block_c8cpE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cpE: // global
           _c8cpL::P64 = R1 & 7;
           if (_c8cpL::P64 == 3) goto c8cpK; else goto u8cpY;
       u8cpY: // global
           if (_c8cpL::P64 == 6) goto c8cpK; else goto c8cpI;
       c8cpK: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8cpI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.184391577 UTC

[section ""data" . GHC.IO.Handle.Types.isWritableHandleType_closure" {
     GHC.IO.Handle.Types.isWritableHandleType_closure:
         const GHC.IO.Handle.Types.isWritableHandleType_info;
 },
 GHC.IO.Handle.Types.isWritableHandleType_entry() //  [R2]
         { info_tbl: [(c8cqd,
                       label: GHC.IO.Handle.Types.isWritableHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cqd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cqe; else goto c8cqf;
       c8cqe: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isWritableHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cqf: // global
           I64[Sp - 8] = block_c8cq4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cqt; else goto c8cq5;
       u8cqt: // global
           call _c8cq4(R1) args: 0, res: 0, upd: 0;
       c8cq5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cq4() //  [R1]
         { info_tbl: [(c8cq4,
                       label: block_c8cq4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cq4: // global
           _c8cqc::P64 = R1 & 7;
           if (_c8cqc::P64 < 4) goto c8cq8; else goto u8cqs;
       c8cq8: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8cqs: // global
           if (_c8cqc::P64 != 5) goto c8cqb; else goto c8cqb;
       c8cqb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.185746805 UTC

[section ""data" . GHC.IO.Handle.Types.isReadWriteHandleType_closure" {
     GHC.IO.Handle.Types.isReadWriteHandleType_closure:
         const GHC.IO.Handle.Types.isReadWriteHandleType_info;
 },
 GHC.IO.Handle.Types.isReadWriteHandleType_entry() //  [R2]
         { info_tbl: [(c8cqF,
                       label: GHC.IO.Handle.Types.isReadWriteHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cqF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cqG; else goto c8cqH;
       c8cqG: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isReadWriteHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cqH: // global
           I64[Sp - 8] = block_c8cqy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cqO; else goto c8cqz;
       u8cqO: // global
           call _c8cqy(R1) args: 0, res: 0, upd: 0;
       c8cqz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cqy() //  [R1]
         { info_tbl: [(c8cqy,
                       label: block_c8cqy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cqy: // global
           if (R1 & 7 == 6) goto c8cqD; else goto c8cqC;
       c8cqD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8cqC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.186780633 UTC

[section ""data" . GHC.IO.Handle.Types.nativeNewline_closure" {
     GHC.IO.Handle.Types.nativeNewline_closure:
         const GHC.IO.Handle.Types.LF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.187381761 UTC

[section ""data" . GHC.IO.Handle.Types.universalNewlineMode_closure" {
     GHC.IO.Handle.Types.universalNewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_con_info;
         const GHC.IO.Handle.Types.CRLF_closure+2;
         const GHC.IO.Handle.Types.LF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.187958992 UTC

[section ""data" . GHC.IO.Handle.Types.nativeNewlineMode_closure" {
     GHC.IO.Handle.Types.nativeNewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_con_info;
         const GHC.IO.Handle.Types.LF_closure+1;
         const GHC.IO.Handle.Types.LF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.188527657 UTC

[section ""data" . GHC.IO.Handle.Types.noNewlineTranslation_closure" {
     GHC.IO.Handle.Types.noNewlineTranslation_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Handle.Types.nativeNewlineMode_closure+1;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.189132107 UTC

[section ""cstring" . GHC.IO.Handle.Types.showHandle1_bytes" {
     GHC.IO.Handle.Types.showHandle1_bytes:
         I8[] [123,104,97,110,100,108,101,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.190191913 UTC

[section ""data" . GHC.IO.Handle.Types.showHandle_closure" {
     GHC.IO.Handle.Types.showHandle_closure:
         const GHC.IO.Handle.Types.showHandle_info;
 },
 sat_s8ahZ_entry() //  [R1]
         { info_tbl: [(c8cr1,
                       label: sat_s8ahZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cr1: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ai0_entry() //  [R1]
         { info_tbl: [(c8cr4,
                       label: sat_s8ai0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cr4: // global
           _s8ai0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8cr5; else goto c8cr6;
       c8cr6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8cr8; else goto c8cr7;
       c8cr8: // global
           HpAlloc = 24;
           goto c8cr5;
       c8cr5: // global
           R1 = _s8ai0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cr7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8ai0::P64;
           _s8ahX::P64 = P64[_s8ai0::P64 + 16];
           _s8ahY::P64 = P64[_s8ai0::P64 + 24];
           I64[Hp - 16] = sat_s8ahZ_info;
           P64[Hp] = _s8ahY::P64;
           R3 = Hp - 16;
           R2 = _s8ahX::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.showHandle_entry() //  [R2, R3]
         { info_tbl: [(c8cr9,
                       label: GHC.IO.Handle.Types.showHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cr9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8crd; else goto c8crc;
       c8crd: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.showHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8crc: // global
           I64[Hp - 24] = sat_s8ai0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.191988626 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_info;
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c8crp,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8crp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8crq; else goto c8crr;
       c8crq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8crr: // global
           I64[Sp - 16] = block_c8cri_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cry; else goto c8crj;
       u8cry: // global
           call _c8cri(R1) args: 0, res: 0, upd: 0;
       c8crj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cri() //  [R1]
         { info_tbl: [(c8cri,
                       label: block_c8cri_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cri: // global
           _s8ai3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8crm; else goto c8crn;
       c8crm: // global
           R3 = _s8ai3::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c8crn: // global
           R3 = _s8ai3::P64;
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.193838111 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_info;
         const 0;
 },
 sat_s8aie_entry() //  [R1]
         { info_tbl: [(c8crM,
                       label: sat_s8aie_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8crM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8crN; else goto c8crO;
       c8crN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8crO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8aii_entry() //  [R1]
         { info_tbl: [(c8crV,
                       label: sat_s8aii_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8crV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8crW; else goto c8crX;
       c8crW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8crX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshow_entry() //  [R2]
         { info_tbl: [(c8cs2,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cs2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cs3; else goto c8cs4;
       c8cs3: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cs4: // global
           I64[Sp - 8] = block_c8crD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8csb; else goto c8crE;
       u8csb: // global
           call _c8crD(R1) args: 0, res: 0, upd: 0;
       c8crE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8crD() //  [R1]
         { info_tbl: [(c8crD,
                       label: block_c8crD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8crD: // global
           if (R1 & 7 == 1) goto c8crZ; else goto c8cs0;
       c8crZ: // global
           Hp = Hp + 24;
           _s8aib::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8csa; else goto c8cs6;
       c8cs6: // global
           _s8aic::P64 = P64[_s8aib::P64 + 7];
           I64[Hp - 16] = sat_s8aie_info;
           P64[Hp] = _s8aic::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8cs0: // global
           Hp = Hp + 24;
           _s8aib::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8csa; else goto c8cs9;
       c8csa: // global
           HpAlloc = 24;
           R1 = _s8aib::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8cs9: // global
           _s8aif::P64 = P64[_s8aib::P64 + 6];
           I64[Hp - 16] = sat_s8aii_info;
           P64[Hp] = _s8aif::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.198612493 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle1_closure" {
     GHC.IO.Handle.Types.$fShowHandle1_closure:
         const GHC.IO.Handle.Types.$fShowHandle1_info;
 },
 GHC.IO.Handle.Types.$fShowHandle1_entry() //  [R2, R3]
         { info_tbl: [(c8csn,
                       label: GHC.IO.Handle.Types.$fShowHandle1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8csn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cso; else goto c8csp;
       c8cso: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8csp: // global
           I64[Sp - 16] = block_c8csg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8csw; else goto c8csh;
       u8csw: // global
           call _c8csg(R1) args: 0, res: 0, upd: 0;
       c8csh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8csg() //  [R1]
         { info_tbl: [(c8csg,
                       label: block_c8csg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8csg: // global
           _s8aik::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8csk; else goto c8csl;
       c8csk: // global
           R3 = _s8aik::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c8csl: // global
           R3 = _s8aik::P64;
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.19984614 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshowList_info;
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8csB,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8csB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowHandle1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.20051066 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_closure" {
     GHC.IO.Handle.Types.$fShowHandle_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.201096295 UTC

[section ""cstring" . GHC.IO.Handle.Types.$trModule4_bytes" {
     GHC.IO.Handle.Types.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.201668129 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule3_closure" {
     GHC.IO.Handle.Types.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.202263066 UTC

[section ""cstring" . GHC.IO.Handle.Types.$trModule2_bytes" {
     GHC.IO.Handle.Types.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.202767246 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule1_closure" {
     GHC.IO.Handle.Types.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.203316968 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule_closure" {
     GHC.IO.Handle.Types.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Types.$trModule3_closure+1;
         const GHC.IO.Handle.Types.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.203891319 UTC

[section ""data" . $krep_r8a59_closure" {
     $krep_r8a59_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.204492628 UTC

[section ""data" . $krep1_r8a5a_closure" {
     $krep1_r8a5a_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcTextEncoding_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.20505703 UTC

[section ""data" . $krep2_r8a5b_closure" {
     $krep2_r8a5b_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.206081259 UTC

[section ""data" . $krep3_r8a5c_closure" {
     $krep3_r8a5c_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.206691956 UTC

[section ""data" . $krep4_r8a5d_closure" {
     $krep4_r8a5d_closure:
         const :_con_info;
         const $krep_r8a59_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.207268235 UTC

[section ""data" . $krep5_r8a5e_closure" {
     $krep5_r8a5e_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep4_r8a5d_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.207856527 UTC

[section ""data" . $krep6_r8a5f_closure" {
     $krep6_r8a5f_closure:
         const :_con_info;
         const $krep1_r8a5a_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.208457376 UTC

[section ""data" . $krep7_r8a5g_closure" {
     $krep7_r8a5g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r8a5f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.209017952 UTC

[section ""data" . $krep8_r8a5h_closure" {
     $krep8_r8a5h_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.209627225 UTC

[section ""data" . $krep9_r8a5i_closure" {
     $krep9_r8a5i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.21017829 UTC

[section ""data" . $krep10_r8a5j_closure" {
     $krep10_r8a5j_closure:
         const :_con_info;
         const $krep9_r8a5i_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.210735225 UTC

[section ""data" . $krep11_r8a5k_closure" {
     $krep11_r8a5k_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep10_r8a5j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.211285201 UTC

[section ""data" . $krep12_r8a5l_closure" {
     $krep12_r8a5l_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.211848504 UTC

[section ""data" . $krep13_r8a5m_closure" {
     $krep13_r8a5m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure;
         const $krep12_r8a5l_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.212441574 UTC

[section ""data" . $krep14_r8a5n_closure" {
     $krep14_r8a5n_closure:
         const :_con_info;
         const $krep13_r8a5m_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.21304157 UTC

[section ""data" . $krep15_r8a5o_closure" {
     $krep15_r8a5o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep14_r8a5n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.213662175 UTC

[section ""data" . $krep16_r8a5p_closure" {
     $krep16_r8a5p_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.214232452 UTC

[section ""data" . $krep17_r8a5q_closure" {
     $krep17_r8a5q_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.214802444 UTC

[section ""data" . $krep18_r8a5r_closure" {
     $krep18_r8a5r_closure:
         const :_con_info;
         const $krep17_r8a5q_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.215378874 UTC

[section ""data" . $krep19_r8a5s_closure" {
     $krep19_r8a5s_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const $krep18_r8a5r_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.215913432 UTC

[section ""data" . $krep20_r8a5t_closure" {
     $krep20_r8a5t_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const $krep19_r8a5s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.216451806 UTC

[section ""data" . $krep21_r8a5u_closure" {
     $krep21_r8a5u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcBufferCodec_closure;
         const $krep20_r8a5t_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.217049687 UTC

[section ""data" . $krep22_r8a5v_closure" {
     $krep22_r8a5v_closure:
         const :_con_info;
         const $krep21_r8a5u_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.217645144 UTC

[section ""data" . $krep23_r8a5w_closure" {
     $krep23_r8a5w_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep22_r8a5v_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.218193559 UTC

[section ""data" . $krep24_r8a5x_closure" {
     $krep24_r8a5x_closure:
         const :_con_info;
         const $krep17_r8a5q_closure+2;
         const $krep14_r8a5n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.218768364 UTC

[section ""data" . $krep25_r8a5y_closure" {
     $krep25_r8a5y_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep24_r8a5x_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.219354736 UTC

[section ""data" . $krep26_r8a5z_closure" {
     $krep26_r8a5z_closure:
         const :_con_info;
         const $krep25_r8a5y_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.219923039 UTC

[section ""data" . $krep27_r8a5A_closure" {
     $krep27_r8a5A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep26_r8a5z_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.220531965 UTC

[section ""data" . $krep28_r8a5B_closure" {
     $krep28_r8a5B_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.221083974 UTC

[section ""data" . $krep29_r8a5C_closure" {
     $krep29_r8a5C_closure:
         const :_con_info;
         const $krep28_r8a5B_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.22165469 UTC

[section ""data" . $krep30_r8a5D_closure" {
     $krep30_r8a5D_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const $krep29_r8a5C_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.222200414 UTC

[section ""data" . $krep31_r8a5E_closure" {
     $krep31_r8a5E_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const $krep30_r8a5D_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.222751329 UTC

[section ""data" . $krep32_r8a5F_closure" {
     $krep32_r8a5F_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcBufferCodec_closure;
         const $krep31_r8a5E_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.223318257 UTC

[section ""data" . $krep33_r8a5G_closure" {
     $krep33_r8a5G_closure:
         const :_con_info;
         const $krep32_r8a5F_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.225141069 UTC

[section ""data" . $krep34_r8a5H_closure" {
     $krep34_r8a5H_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep33_r8a5G_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.225933349 UTC

[section ""data" . $krep35_r8a5I_closure" {
     $krep35_r8a5I_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.226535695 UTC

[section ""data" . $krep36_r8a5J_closure" {
     $krep36_r8a5J_closure:
         const :_con_info;
         const $krep35_r8a5I_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.227096036 UTC

[section ""data" . $krep37_r8a5K_closure" {
     $krep37_r8a5K_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.22767518 UTC

[section ""data" . $krep38_r8a5L_closure" {
     $krep38_r8a5L_closure:
         const :_con_info;
         const GHC.Types.krep$*_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.228213202 UTC

[section ""data" . $krep39_r8a5M_closure" {
     $krep39_r8a5M_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Typeable.Internal.$tcTypeable_closure;
         const $krep38_r8a5L_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.228786794 UTC

[section ""data" . $krep40_r8a5N_closure" {
     $krep40_r8a5N_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Device.$tcIODevice_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.229408732 UTC

[section ""data" . $krep41_r8a5O_closure" {
     $krep41_r8a5O_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.BufferedIO.$tcBufferedIO_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.230006192 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcBufferList2_bytes" {
     GHC.IO.Handle.Types.$tcBufferList2_bytes:
         I8[] [66,117,102,102,101,114,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.230542258 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferList1_closure" {
     GHC.IO.Handle.Types.$tcBufferList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcBufferList2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.231117544 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferList_closure" {
     GHC.IO.Handle.Types.$tcBufferList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcBufferList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16602278556585116844;
         const 18164509953320487254;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.231742587 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil1_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferList_closure+1;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.232308053 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BufferListNil3_bytes" {
     GHC.IO.Handle.Types.$tc'BufferListNil3_bytes:
         I8[] [39,66,117,102,102,101,114,76,105,115,116,78,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.232870321 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil2_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListNil3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.234032045 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil2_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const 1776148480580179033;
         const 13181184993065174936;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.234616543 UTC

[section ""data" . $krep42_r8a5P_closure" {
     $krep42_r8a5P_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.235177242 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons1_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep37_r8a5K_closure+1;
         const $krep42_r8a5P_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.235737875 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BufferListCons3_bytes" {
     GHC.IO.Handle.Types.$tc'BufferListCons3_bytes:
         I8[] [39,66,117,102,102,101,114,76,105,115,116,67,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.236279416 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons2_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListCons3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.23682381 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListCons2_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListCons1_closure+4;
         const 17252346539814354939;
         const 274626690118510806;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.237476296 UTC

[section ""data" . $krep43_r8a5Q_closure" {
     $krep43_r8a5Q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferList_closure+1;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.238038349 UTC

[section ""data" . $krep44_r8a5R_closure" {
     $krep44_r8a5R_closure:
         const :_con_info;
         const $krep43_r8a5Q_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.238609141 UTC

[section ""data" . $krep45_r8a5S_closure" {
     $krep45_r8a5S_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep44_r8a5R_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.239166498 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandleType2_bytes" {
     GHC.IO.Handle.Types.$tcHandleType2_bytes:
         I8[] [72,97,110,100,108,101,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.239709824 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandleType1_closure" {
     GHC.IO.Handle.Types.$tcHandleType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandleType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.240219977 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandleType_closure" {
     GHC.IO.Handle.Types.$tcHandleType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandleType1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12652050740177317592;
         const 15012172050125063359;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.240795119 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle1_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandleType_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.241384554 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes:
         I8[] [39,67,108,111,115,101,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.241922411 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ClosedHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ClosedHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.242481711 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ClosedHandle_closure" {
     GHC.IO.Handle.Types.$tc'ClosedHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ClosedHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 3827246897052092772;
         const 908733983357893198;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.243073657 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes:
         I8[] [39,83,101,109,105,67,108,111,115,101,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.243615236 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.244154621 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'SemiClosedHandle_closure" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 9212351547956271402;
         const 6570718180183054490;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.244786825 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ReadHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ReadHandle2_bytes:
         I8[] [39,82,101,97,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.245328914 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ReadHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ReadHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.245903331 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadHandle_closure" {
     GHC.IO.Handle.Types.$tc'ReadHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ReadHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 269968663592081974;
         const 17473723309710900549;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.246451733 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'WriteHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'WriteHandle2_bytes:
         I8[] [39,87,114,105,116,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.247007833 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'WriteHandle1_closure" {
     GHC.IO.Handle.Types.$tc'WriteHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'WriteHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.247548142 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'WriteHandle_closure" {
     GHC.IO.Handle.Types.$tc'WriteHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'WriteHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 18024523813608199082;
         const 4783872735135983851;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.248133353 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'AppendHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'AppendHandle3_bytes:
         I8[] [39,65,112,112,101,110,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.248679943 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle2_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'AppendHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.249278559 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 18423480119042393547;
         const 8911069045719960050;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.249882276 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes:
         I8[] [39,82,101,97,100,87,114,105,116,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.251060877 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.251660507 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadWriteHandle_closure" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 6962298179673541916;
         const 7858738479804269456;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.252295338 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcBufferMode2_bytes" {
     GHC.IO.Handle.Types.$tcBufferMode2_bytes:
         I8[] [66,117,102,102,101,114,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.252833434 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferMode1_closure" {
     GHC.IO.Handle.Types.$tcBufferMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcBufferMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.253419411 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferMode_closure" {
     GHC.IO.Handle.Types.$tcBufferMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcBufferMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2181253694666364469;
         const 18094997560331273583;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.25403837 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.254632218 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'NoBuffering2_bytes" {
     GHC.IO.Handle.Types.$tc'NoBuffering2_bytes:
         I8[] [39,78,111,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.255182735 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NoBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'NoBuffering1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'NoBuffering2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.255742633 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NoBuffering_closure" {
     GHC.IO.Handle.Types.$tc'NoBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'NoBuffering1_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 1829914617507863771;
         const 11519122601481432262;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.25632738 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'LineBuffering3_bytes" {
     GHC.IO.Handle.Types.$tc'LineBuffering3_bytes:
         I8[] [39,76,105,110,101,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.256862974 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering2_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'LineBuffering3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.257428519 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering2_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 6417231512954421547;
         const 14761155862500981941;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.258020766 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r8a5e_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.258603123 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes" {
     GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes:
         I8[] [39,66,108,111,99,107,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.259173637 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering2_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.259737471 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BlockBuffering2_closure+1;
         const GHC.IO.Handle.Types.$tc'BlockBuffering1_closure+4;
         const 704611490471072872;
         const 15656058643765081689;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.260338139 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcNewline2_bytes" {
     GHC.IO.Handle.Types.$tcNewline2_bytes:
         I8[] [78,101,119,108,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.260878511 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewline1_closure" {
     GHC.IO.Handle.Types.$tcNewline1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcNewline2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.26146431 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewline_closure" {
     GHC.IO.Handle.Types.$tcNewline_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcNewline1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4144517894815066994;
         const 10872055347860317487;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.262068119 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF1_closure" {
     GHC.IO.Handle.Types.$tc'CRLF1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcNewline_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.262677394 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'LF2_bytes" {
     GHC.IO.Handle.Types.$tc'LF2_bytes:
         I8[] [39,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.263230808 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LF1_closure" {
     GHC.IO.Handle.Types.$tc'LF1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'LF2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.263824786 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LF_closure" {
     GHC.IO.Handle.Types.$tc'LF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'LF1_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const 8352565500432618804;
         const 14951155965269318914;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.264441117 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'CRLF3_bytes" {
     GHC.IO.Handle.Types.$tc'CRLF3_bytes:
         I8[] [39,67,82,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.265001381 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF2_closure" {
     GHC.IO.Handle.Types.$tc'CRLF2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.265641584 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF_closure" {
     GHC.IO.Handle.Types.$tc'CRLF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF2_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const 12041259567283068515;
         const 3210182148185771829;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.266237381 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandle__2_bytes" {
     GHC.IO.Handle.Types.$tcHandle__2_bytes:
         I8[] [72,97,110,100,108,101,95,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.266768594 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle__1_closure" {
     GHC.IO.Handle.Types.$tcHandle__1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandle__2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.26736643 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle___closure" {
     GHC.IO.Handle.Types.$tcHandle___closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandle__1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10675922960094776064;
         const 10563785792974977547;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.267994903 UTC

[section ""data" . $krep46_r8a5T_closure" {
     $krep46_r8a5T_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle___closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.268609187 UTC

[section ""data" . $krep47_r8a5U_closure" {
     $krep47_r8a5U_closure:
         const :_con_info;
         const $krep46_r8a5T_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.269192709 UTC

[section ""data" . $krep48_r8a5V_closure" {
     $krep48_r8a5V_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep47_r8a5U_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.269821443 UTC

[section ""data" . $krep49_r8a5W_closure" {
     $krep49_r8a5W_closure:
         const :_con_info;
         const $krep48_r8a5V_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.270448954 UTC

[section ""data" . $krep50_r8a5X_closure" {
     $krep50_r8a5X_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep49_r8a5W_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.271039729 UTC

[section ""data" . $krep51_r8a5Y_closure" {
     $krep51_r8a5Y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep50_r8a5X_closure+1;
         const $krep46_r8a5T_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.271637908 UTC

[section ""data" . $krep52_r8a5Z_closure" {
     $krep52_r8a5Z_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep51_r8a5Y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.272200931 UTC

[section ""data" . $krep53_r8a60_closure" {
     $krep53_r8a60_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep52_r8a5Z_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.272764355 UTC

[section ""data" . $krep54_r8a61_closure" {
     $krep54_r8a61_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r8a5g_closure+1;
         const $krep53_r8a60_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.2733341 UTC

[section ""data" . $krep55_r8a62_closure" {
     $krep55_r8a62_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep23_r8a5w_closure+1;
         const $krep54_r8a61_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.273910753 UTC

[section ""data" . $krep56_r8a63_closure" {
     $krep56_r8a63_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep34_r8a5H_closure+1;
         const $krep55_r8a62_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.274489103 UTC

[section ""data" . $krep57_r8a64_closure" {
     $krep57_r8a64_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep45_r8a5S_closure+1;
         const $krep56_r8a63_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.275078712 UTC

[section ""data" . $krep58_r8a65_closure" {
     $krep58_r8a65_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r8a5k_closure+1;
         const $krep57_r8a64_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.275661491 UTC

[section ""data" . $krep59_r8a66_closure" {
     $krep59_r8a66_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep27_r8a5A_closure+1;
         const $krep58_r8a65_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.27690666 UTC

[section ""data" . $krep60_r8a67_closure" {
     $krep60_r8a67_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const $krep59_r8a66_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.27753212 UTC

[section ""data" . $krep61_r8a68_closure" {
     $krep61_r8a68_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep15_r8a5o_closure+1;
         const $krep60_r8a67_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.278130306 UTC

[section ""data" . $krep62_r8a69_closure" {
     $krep62_r8a69_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const $krep61_r8a68_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.278728705 UTC

[section ""data" . $krep63_r8a6a_closure" {
     $krep63_r8a6a_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep35_r8a5I_closure+2;
         const $krep62_r8a69_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.279283523 UTC

[section ""data" . $krep64_r8a6b_closure" {
     $krep64_r8a6b_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep39_r8a5M_closure+1;
         const $krep63_r8a6a_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.279907177 UTC

[section ""data" . $krep65_r8a6c_closure" {
     $krep65_r8a6c_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep41_r8a5O_closure+1;
         const $krep64_r8a6b_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.280482317 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle__1_closure" {
     GHC.IO.Handle.Types.$tc'Handle__1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep40_r8a5N_closure+1;
         const $krep65_r8a6c_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.281034494 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'Handle__3_bytes" {
     GHC.IO.Handle.Types.$tc'Handle__3_bytes:
         I8[] [39,72,97,110,100,108,101,95,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.282486427 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle__2_closure" {
     GHC.IO.Handle.Types.$tc'Handle__2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'Handle__3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.283130614 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle___closure" {
     GHC.IO.Handle.Types.$tc'Handle___closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'Handle__2_closure+1;
         const GHC.IO.Handle.Types.$tc'Handle__1_closure+4;
         const 15400920814375205416;
         const 14458810719499819570;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.283789184 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandle2_bytes" {
     GHC.IO.Handle.Types.$tcHandle2_bytes:
         I8[] [72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.284385118 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle1_closure" {
     GHC.IO.Handle.Types.$tcHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.285052686 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle_closure" {
     GHC.IO.Handle.Types.$tcHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandle1_closure+1;
         const GHC.Types.krep$*_closure;
         const 6808292778723485333;
         const 9239299165073943659;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.285752214 UTC

[section ""data" . $krep66_r8a6d_closure" {
     $krep66_r8a6d_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.286424543 UTC

[section ""data" . $krep67_r8a6e_closure" {
     $krep67_r8a6e_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep48_r8a5V_closure+1;
         const $krep66_r8a6d_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.287121976 UTC

[section ""data" . $krep68_r8a6f_closure" {
     $krep68_r8a6f_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep48_r8a5V_closure+1;
         const $krep67_r8a6e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.287744006 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle1_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r8a5p_closure+1;
         const $krep68_r8a6f_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.288351924 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes:
         I8[] [39,68,117,112,108,101,120,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.288929473 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle2_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.290175135 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'DuplexHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'DuplexHandle1_closure+4;
         const 477065760828861081;
         const 4557316572761143129;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.29080802 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle1_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r8a5p_closure+1;
         const $krep67_r8a6e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.29145843 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'FileHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'FileHandle3_bytes:
         I8[] [39,70,105,108,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.292068538 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle2_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'FileHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.29276274 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'FileHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'FileHandle1_closure+4;
         const 5544613225695748436;
         const 8829945929965735507;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.293496849 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewlineMode1_closure" {
     GHC.IO.Handle.Types.$tcNewlineMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode17_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.294177094 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewlineMode_closure" {
     GHC.IO.Handle.Types.$tcNewlineMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcNewlineMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 17953040817059389032;
         const 12498949339099960838;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.294890759 UTC

[section ""data" . $krep69_r8a6g_closure" {
     $krep69_r8a6g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcNewlineMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.295610128 UTC

[section ""data" . $krep70_r8a6h_closure" {
     $krep70_r8a6h_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep69_r8a6g_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.296326853 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode1_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep70_r8a6h_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.297004244 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'NewlineMode3_bytes" {
     GHC.IO.Handle.Types.$tc'NewlineMode3_bytes:
         I8[] [39,78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.297677956 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode2_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'NewlineMode3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.298376212 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'NewlineMode2_closure+1;
         const GHC.IO.Handle.Types.$tc'NewlineMode1_closure+4;
         const 4266278501114659446;
         const 17947462423734457010;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.299188624 UTC

[section ""data" . GHC.IO.Handle.Types.checkHandleInvariants1_closure" {
     GHC.IO.Handle.Types.checkHandleInvariants1_closure:
         const GHC.IO.Handle.Types.checkHandleInvariants1_info;
 },
 GHC.IO.Handle.Types.checkHandleInvariants1_entry() //  []
         { info_tbl: [(c8csI,
                       label: GHC.IO.Handle.Types.checkHandleInvariants1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8csI: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.300179934 UTC

[section ""data" . GHC.IO.Handle.Types.checkHandleInvariants_closure" {
     GHC.IO.Handle.Types.checkHandleInvariants_closure:
         const GHC.IO.Handle.Types.checkHandleInvariants_info;
 },
 GHC.IO.Handle.Types.checkHandleInvariants_entry() //  [R2]
         { info_tbl: [(c8csP,
                       label: GHC.IO.Handle.Types.checkHandleInvariants_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8csP: // global
           R2 = R2;
           call GHC.IO.Handle.Types.checkHandleInvariants1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.301211999 UTC

[section ""data" . GHC.IO.Handle.Types.NewlineMode_closure" {
     GHC.IO.Handle.Types.NewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_info;
 },
 GHC.IO.Handle.Types.NewlineMode_entry() //  [R2, R3]
         { info_tbl: [(c8csX,
                       label: GHC.IO.Handle.Types.NewlineMode_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8csX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ct1; else goto c8ct0;
       c8ct1: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.NewlineMode_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ct0: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.302255586 UTC

[section ""data" . GHC.IO.Handle.Types.LF_closure" {
     GHC.IO.Handle.Types.LF_closure:
         const GHC.IO.Handle.Types.LF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.302880314 UTC

[section ""data" . GHC.IO.Handle.Types.CRLF_closure" {
     GHC.IO.Handle.Types.CRLF_closure:
         const GHC.IO.Handle.Types.CRLF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.303514839 UTC

[section ""data" . GHC.IO.Handle.Types.NoBuffering_closure" {
     GHC.IO.Handle.Types.NoBuffering_closure:
         const GHC.IO.Handle.Types.NoBuffering_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.30416671 UTC

[section ""data" . GHC.IO.Handle.Types.LineBuffering_closure" {
     GHC.IO.Handle.Types.LineBuffering_closure:
         const GHC.IO.Handle.Types.LineBuffering_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.304887359 UTC

[section ""data" . GHC.IO.Handle.Types.BlockBuffering_closure" {
     GHC.IO.Handle.Types.BlockBuffering_closure:
         const GHC.IO.Handle.Types.BlockBuffering_info;
 },
 GHC.IO.Handle.Types.BlockBuffering_entry() //  [R2]
         { info_tbl: [(c8ct7,
                       label: GHC.IO.Handle.Types.BlockBuffering_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ct7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ctb; else goto c8cta;
       c8ctb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.BlockBuffering_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cta: // global
           I64[Hp - 8] = GHC.IO.Handle.Types.BlockBuffering_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.305843307 UTC

[section ""data" . GHC.IO.Handle.Types.ClosedHandle_closure" {
     GHC.IO.Handle.Types.ClosedHandle_closure:
         const GHC.IO.Handle.Types.ClosedHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.306463758 UTC

[section ""data" . GHC.IO.Handle.Types.SemiClosedHandle_closure" {
     GHC.IO.Handle.Types.SemiClosedHandle_closure:
         const GHC.IO.Handle.Types.SemiClosedHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.307726234 UTC

[section ""data" . GHC.IO.Handle.Types.ReadHandle_closure" {
     GHC.IO.Handle.Types.ReadHandle_closure:
         const GHC.IO.Handle.Types.ReadHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.308335343 UTC

[section ""data" . GHC.IO.Handle.Types.WriteHandle_closure" {
     GHC.IO.Handle.Types.WriteHandle_closure:
         const GHC.IO.Handle.Types.WriteHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.308960064 UTC

[section ""data" . GHC.IO.Handle.Types.AppendHandle_closure" {
     GHC.IO.Handle.Types.AppendHandle_closure:
         const GHC.IO.Handle.Types.AppendHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.30949503 UTC

[section ""data" . GHC.IO.Handle.Types.ReadWriteHandle_closure" {
     GHC.IO.Handle.Types.ReadWriteHandle_closure:
         const GHC.IO.Handle.Types.ReadWriteHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.310120902 UTC

[section ""data" . GHC.IO.Handle.Types.BufferListNil_closure" {
     GHC.IO.Handle.Types.BufferListNil_closure:
         const GHC.IO.Handle.Types.BufferListNil_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.310952954 UTC

[section ""data" . GHC.IO.Handle.Types.BufferListCons_closure" {
     GHC.IO.Handle.Types.BufferListCons_closure:
         const GHC.IO.Handle.Types.BufferListCons_info;
 },
 GHC.IO.Handle.Types.BufferListCons_entry() //  [R2, R3]
         { info_tbl: [(c8cth,
                       label: GHC.IO.Handle.Types.BufferListCons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cth: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ctl; else goto c8ctk;
       c8ctl: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.BufferListCons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ctk: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.3124231 UTC

[section ""data" . GHC.IO.Handle.Types.Handle___closure" {
     GHC.IO.Handle.Types.Handle___closure:
         const GHC.IO.Handle.Types.Handle___info;
 },
 GHC.IO.Handle.Types.Handle___slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ctn: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Types.Handle___entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 96, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.Handle___entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8cts,
                       label: GHC.IO.Handle.Types.Handle___info
                       rep:HeapRep static {
                             Fun {arity: 16
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cts: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8ctw; else goto c8ctv;
       c8ctw: // global
           HpAlloc = 136;
           R1 = GHC.IO.Handle.Types.Handle___closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 136, res: 0, upd: 8;
       c8ctv: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           P64[Hp - 88] = R6;
           P64[Hp - 80] = P64[Sp];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 56];
           P64[Hp - 16] = P64[Sp + 64];
           P64[Hp - 8] = P64[Sp + 72];
           P64[Hp] = P64[Sp + 80];
           R1 = Hp - 127;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.313976036 UTC

[section ""data" . GHC.IO.Handle.Types.FileHandle_closure" {
     GHC.IO.Handle.Types.FileHandle_closure:
         const GHC.IO.Handle.Types.FileHandle_info;
 },
 GHC.IO.Handle.Types.FileHandle_entry() //  [R2, R3]
         { info_tbl: [(c8ctC,
                       label: GHC.IO.Handle.Types.FileHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ctC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ctG; else goto c8ctF;
       c8ctG: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.FileHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ctF: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.31499767 UTC

[section ""data" . GHC.IO.Handle.Types.DuplexHandle_closure" {
     GHC.IO.Handle.Types.DuplexHandle_closure:
         const GHC.IO.Handle.Types.DuplexHandle_info;
 },
 GHC.IO.Handle.Types.DuplexHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(c8ctM,
                       label: GHC.IO.Handle.Types.DuplexHandle_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ctM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8ctQ; else goto c8ctP;
       c8ctQ: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.DuplexHandle_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ctP: // global
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 22;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.315909887 UTC

[GHC.IO.Handle.Types.NewlineMode_con_entry() //  [R1]
         { info_tbl: [(c8ctR,
                       label: GHC.IO.Handle.Types.NewlineMode_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,78,101,119,108,105,110,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ctR: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.316624449 UTC

[section ""relreadonly" . GHC.IO.Handle.Types.Newline_closure_tbl" {
     GHC.IO.Handle.Types.Newline_closure_tbl:
         const GHC.IO.Handle.Types.LF_closure+1;
         const GHC.IO.Handle.Types.CRLF_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.317292574 UTC

[GHC.IO.Handle.Types.LF_con_entry() //  [R1]
         { info_tbl: [(c8ctT,
                       label: GHC.IO.Handle.Types.LF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,76,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ctT: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.318028446 UTC

[GHC.IO.Handle.Types.CRLF_con_entry() //  [R1]
         { info_tbl: [(c8ctV,
                       label: GHC.IO.Handle.Types.CRLF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,67,82,76,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ctV: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.318747098 UTC

[GHC.IO.Handle.Types.NoBuffering_con_entry() //  [R1]
         { info_tbl: [(c8ctX,
                       label: GHC.IO.Handle.Types.NoBuffering_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,78,111,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ctX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.319462471 UTC

[GHC.IO.Handle.Types.LineBuffering_con_entry() //  [R1]
         { info_tbl: [(c8ctZ,
                       label: GHC.IO.Handle.Types.LineBuffering_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,76,105,110,101,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ctZ: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.320196205 UTC

[GHC.IO.Handle.Types.BlockBuffering_con_entry() //  [R1]
         { info_tbl: [(c8cu1,
                       label: GHC.IO.Handle.Types.BlockBuffering_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,108,111,99,107,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cu1: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.320831809 UTC

[section ""relreadonly" . GHC.IO.Handle.Types.HandleType_closure_tbl" {
     GHC.IO.Handle.Types.HandleType_closure_tbl:
         const GHC.IO.Handle.Types.ClosedHandle_closure+1;
         const GHC.IO.Handle.Types.SemiClosedHandle_closure+2;
         const GHC.IO.Handle.Types.ReadHandle_closure+3;
         const GHC.IO.Handle.Types.WriteHandle_closure+4;
         const GHC.IO.Handle.Types.AppendHandle_closure+5;
         const GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.321501829 UTC

[GHC.IO.Handle.Types.ClosedHandle_con_entry() //  [R1]
         { info_tbl: [(c8cu3,
                       label: GHC.IO.Handle.Types.ClosedHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,67,108,111,115,101,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cu3: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.322195177 UTC

[GHC.IO.Handle.Types.SemiClosedHandle_con_entry() //  [R1]
         { info_tbl: [(c8cu5,
                       label: GHC.IO.Handle.Types.SemiClosedHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,83,101,109,105,67,108,111,115,101,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cu5: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.322894962 UTC

[GHC.IO.Handle.Types.ReadHandle_con_entry() //  [R1]
         { info_tbl: [(c8cu7,
                       label: GHC.IO.Handle.Types.ReadHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,82,101,97,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cu7: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.323582318 UTC

[GHC.IO.Handle.Types.WriteHandle_con_entry() //  [R1]
         { info_tbl: [(c8cu9,
                       label: GHC.IO.Handle.Types.WriteHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,87,114,105,116,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cu9: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.32427605 UTC

[GHC.IO.Handle.Types.AppendHandle_con_entry() //  [R1]
         { info_tbl: [(c8cub,
                       label: GHC.IO.Handle.Types.AppendHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,65,112,112,101,110,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cub: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.32499806 UTC

[GHC.IO.Handle.Types.ReadWriteHandle_con_entry() //  [R1]
         { info_tbl: [(c8cud,
                       label: GHC.IO.Handle.Types.ReadWriteHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,82,101,97,100,87,114,105,116,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cud: // global
           R1 = R1 + 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.325972095 UTC

[GHC.IO.Handle.Types.BufferListNil_con_entry() //  [R1]
         { info_tbl: [(c8cuf,
                       label: GHC.IO.Handle.Types.BufferListNil_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,117,102,102,101,114,76,105,115,116,78,105,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuf: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.326687063 UTC

[GHC.IO.Handle.Types.BufferListCons_con_entry() //  [R1]
         { info_tbl: [(c8cuh,
                       label: GHC.IO.Handle.Types.BufferListCons_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,117,102,102,101,114,76,105,115,116,67,111,110,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuh: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.327401254 UTC

[GHC.IO.Handle.Types.Handle___con_entry() //  [R1]
         { info_tbl: [(c8cuj,
                       label: GHC.IO.Handle.Types.Handle___con_info
                       rep:HeapRep 16 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,72,97,110,100,108,101,95,95]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.328126536 UTC

[GHC.IO.Handle.Types.FileHandle_con_entry() //  [R1]
         { info_tbl: [(c8cul,
                       label: GHC.IO.Handle.Types.FileHandle_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,70,105,108,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cul: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.328836542 UTC

[GHC.IO.Handle.Types.DuplexHandle_con_entry() //  [R1]
         { info_tbl: [(c8cun,
                       label: GHC.IO.Handle.Types.DuplexHandle_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,68,117,112,108,101,120,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cun: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.329542265 UTC

[section ""relreadonly" . S8alj_srt" {
     S8alj_srt:
         const GHC.IO.Handle.Types.$w$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowHandleType1_closure;
         const GHC.IO.Handle.Types.$fShowHandleType3_closure;
         const GHC.IO.Handle.Types.$fShowHandleType5_closure;
         const GHC.IO.Handle.Types.$fShowHandleType7_closure;
         const GHC.IO.Handle.Types.$fShowHandleType9_closure;
         const GHC.IO.Handle.Types.$fShowHandleType11_closure;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure;
         const GHC.IO.Handle.Types.$fReadNewline6_closure;
         const GHC.IO.Handle.Types.$fReadNewline10_closure;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowNewline1_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.IO.Handle.Types.$w$cshowsPrec1_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode1_closure;
         const GHC.Read.choose2_closure;
         const GHC.IO.Handle.Types.$fReadNewline_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.Handle.Types.$fReadNewline2_closure;
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Handle.Types.$fReadNewline1_closure;
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewline12_closure;
         const Text.Read.Lex.$wexpect_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode3_closure;
         const GHC.Read.readField_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode6_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode11_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode8_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode12_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure;
         const GHC.IO.Handle.Types.$w$creadPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode2_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode1_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode18_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode12_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode8_closure;
         const GHC.Show.$fShowMaybe_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode3_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode5_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode6_closure;
         const GHC.Show.$fShowMaybe1_closure;
         const GHC.Show.$fShowMaybe4_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode1_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_sps_closure;
         const GHC.Read.choose2_closure;
         const GHC.Read.$fReadInt_closure;
         const GHC.Read.$fReadMaybe1_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode2_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode1_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode14_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.330763642 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:17.332809239 UTC

[section ""data" . GHC.IO.Handle.Types.$WHandle___closure" {
     GHC.IO.Handle.Types.$WHandle___closure:
         const GHC.IO.Handle.Types.$WHandle___info;
 },
 GHC.IO.Handle.Types.$WHandle___slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuq: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Types.$WHandle___entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 96, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$WHandle___entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8cuz,
                       label: GHC.IO.Handle.Types.$WHandle___info
                       rep:HeapRep static {
                             Fun {arity: 16
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8cuS; else goto c8cuT;
       c8cuS: // global
           R1 = GHC.IO.Handle.Types.$WHandle___closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 136, res: 0, upd: 8;
       c8cuT: // global
           I64[Sp - 40] = block_c8cuu_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cuu() //  [R1]
         { info_tbl: [(c8cuu,
                       label: block_c8cuu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuu: // global
           I64[Sp] = block_c8cuw_info;
           _s8a6z::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s8a6z::P64;
           if (R1 & 7 != 0) goto u8cv1; else goto c8cux;
       u8cv1: // global
           call _c8cuw(R1) args: 0, res: 0, upd: 0;
       c8cux: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cuw() //  [R1]
         { info_tbl: [(c8cuw,
                       label: block_c8cuw_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuw: // global
           I64[Sp] = block_c8cuC_info;
           _s8a6B::P64 = P64[R1 + 7];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _s8a6B::P64;
           if (R1 & 7 != 0) goto u8cv2; else goto c8cuD;
       u8cv2: // global
           call _c8cuC(R1) args: 0, res: 0, upd: 0;
       c8cuD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cuC() //  [R1]
         { info_tbl: [(c8cuC,
                       label: block_c8cuC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuC: // global
           I64[Sp] = block_c8cuH_info;
           _s8a6D::P64 = P64[R1 + 7];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s8a6D::P64;
           if (R1 & 7 != 0) goto u8cv3; else goto c8cuI;
       u8cv3: // global
           call _c8cuH(R1) args: 0, res: 0, upd: 0;
       c8cuI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cuH() //  [R1]
         { info_tbl: [(c8cuH,
                       label: block_c8cuH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuH: // global
           I64[Sp] = block_c8cuM_info;
           _s8a6F::P64 = P64[R1 + 7];
           R1 = P64[Sp + 72];
           P64[Sp + 72] = _s8a6F::P64;
           if (R1 & 7 != 0) goto u8cv4; else goto c8cuN;
       u8cv4: // global
           call _c8cuM(R1) args: 0, res: 0, upd: 0;
       c8cuN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cuM() //  [R1]
         { info_tbl: [(c8cuM,
                       label: block_c8cuM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cuM: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8cv0; else goto c8cuZ;
       c8cv0: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8cuZ: // global
           _s8a6H::P64 = P64[R1 + 7];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 64];
           P64[Hp - 56] = P64[Sp + 72];
           P64[Hp - 48] = _s8a6H::P64;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = P64[Sp + 104];
           P64[Hp - 8] = P64[Sp + 112];
           P64[Hp] = P64[Sp + 120];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.352407691 UTC

[section ""data" . GHC.IO.Handle.Types.$WFileHandle_closure" {
     GHC.IO.Handle.Types.$WFileHandle_closure:
         const GHC.IO.Handle.Types.$WFileHandle_info;
 },
 GHC.IO.Handle.Types.$WFileHandle_entry() //  [R2, R3]
         { info_tbl: [(c8cvS,
                       label: GHC.IO.Handle.Types.$WFileHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cvS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cvW; else goto c8cvX;
       c8cvW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$WFileHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cvX: // global
           I64[Sp - 16] = block_c8cvP_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cw1; else goto c8cvQ;
       u8cw1: // global
           call _c8cvP(R1) args: 0, res: 0, upd: 0;
       c8cvQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cvP() //  [R1]
         { info_tbl: [(c8cvP,
                       label: block_c8cvP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cvP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8cw0; else goto c8cvZ;
       c8cw0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8cvZ: // global
           _s8a6L::P64 = P64[R1 + 7];
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s8a6L::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.358447489 UTC

[section ""data" . GHC.IO.Handle.Types.$WDuplexHandle_closure" {
     GHC.IO.Handle.Types.$WDuplexHandle_closure:
         const GHC.IO.Handle.Types.$WDuplexHandle_info;
 },
 GHC.IO.Handle.Types.$WDuplexHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(c8cwk,
                       label: GHC.IO.Handle.Types.$WDuplexHandle_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cwk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8cwt; else goto c8cwu;
       c8cwt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$WDuplexHandle_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cwu: // global
           I64[Sp - 24] = block_c8cwh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8cwA; else goto c8cwi;
       u8cwA: // global
           call _c8cwh(R1) args: 0, res: 0, upd: 0;
       c8cwi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cwh() //  [R1]
         { info_tbl: [(c8cwh,
                       label: block_c8cwh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cwh: // global
           I64[Sp] = block_c8cwn_info;
           _s8a6Q::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8a6Q::P64;
           if (R1 & 7 != 0) goto u8cwz; else goto c8cwo;
       u8cwz: // global
           call _c8cwn(R1) args: 0, res: 0, upd: 0;
       c8cwo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cwn() //  [R1]
         { info_tbl: [(c8cwn,
                       label: block_c8cwn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cwn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8cwy; else goto c8cwx;
       c8cwy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8cwx: // global
           _s8a6S::P64 = P64[R1 + 7];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s8a6S::P64;
           R1 = Hp - 22;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.365879395 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType12_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType12_bytes:
         I8[] [99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.367793196 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType11_closure" {
     GHC.IO.Handle.Types.$fShowHandleType11_closure:
         const GHC.IO.Handle.Types.$fShowHandleType11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType11_entry() //  [R1]
         { info_tbl: [(c8cwY,
                       label: GHC.IO.Handle.Types.$fShowHandleType11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cwY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cwZ; else goto c8cx0;
       c8cwZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cx0: // global
           (_c8cwV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cwV::I64 == 0) goto c8cwX; else goto c8cwW;
       c8cwX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cwW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cwV::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.371682565 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType10_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType10_bytes:
         I8[] [115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.373521206 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType9_closure" {
     GHC.IO.Handle.Types.$fShowHandleType9_closure:
         const GHC.IO.Handle.Types.$fShowHandleType9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType9_entry() //  [R1]
         { info_tbl: [(c8cxf,
                       label: GHC.IO.Handle.Types.$fShowHandleType9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cxf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cxg; else goto c8cxh;
       c8cxg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cxh: // global
           (_c8cxc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cxc::I64 == 0) goto c8cxe; else goto c8cxd;
       c8cxe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cxd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cxc::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.377419277 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType8_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType8_bytes:
         I8[] [114,101,97,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.379303444 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType7_closure" {
     GHC.IO.Handle.Types.$fShowHandleType7_closure:
         const GHC.IO.Handle.Types.$fShowHandleType7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType7_entry() //  [R1]
         { info_tbl: [(c8cxw,
                       label: GHC.IO.Handle.Types.$fShowHandleType7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cxw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cxx; else goto c8cxy;
       c8cxx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cxy: // global
           (_c8cxt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cxt::I64 == 0) goto c8cxv; else goto c8cxu;
       c8cxv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cxu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cxt::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.384263915 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType6_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType6_bytes:
         I8[] [119,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.386167045 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType5_closure" {
     GHC.IO.Handle.Types.$fShowHandleType5_closure:
         const GHC.IO.Handle.Types.$fShowHandleType5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType5_entry() //  [R1]
         { info_tbl: [(c8cxN,
                       label: GHC.IO.Handle.Types.$fShowHandleType5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cxN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cxO; else goto c8cxP;
       c8cxO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cxP: // global
           (_c8cxK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cxK::I64 == 0) goto c8cxM; else goto c8cxL;
       c8cxM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cxL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cxK::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.390010879 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType4_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType4_bytes:
         I8[] [119,114,105,116,97,98,108,101,32,40,97,112,112,101,110,100,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.391909388 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType3_closure" {
     GHC.IO.Handle.Types.$fShowHandleType3_closure:
         const GHC.IO.Handle.Types.$fShowHandleType3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType3_entry() //  [R1]
         { info_tbl: [(c8cy4,
                       label: GHC.IO.Handle.Types.$fShowHandleType3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cy4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cy5; else goto c8cy6;
       c8cy5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cy6: // global
           (_c8cy1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cy1::I64 == 0) goto c8cy3; else goto c8cy2;
       c8cy3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cy2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cy1::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.395707135 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType2_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType2_bytes:
         I8[] [114,101,97,100,45,119,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.398088104 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType1_closure" {
     GHC.IO.Handle.Types.$fShowHandleType1_closure:
         const GHC.IO.Handle.Types.$fShowHandleType1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType1_entry() //  [R1]
         { info_tbl: [(c8cyl,
                       label: GHC.IO.Handle.Types.$fShowHandleType1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cyl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cym; else goto c8cyn;
       c8cym: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cyn: // global
           (_c8cyi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cyi::I64 == 0) goto c8cyk; else goto c8cyj;
       c8cyk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cyj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cyi::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.402307419 UTC

[section ""data" . GHC.IO.Handle.Types.$w$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$w$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8cyK,
                       label: GHC.IO.Handle.Types.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cyK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cyL; else goto c8cyM;
       c8cyL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cyM: // global
           I64[Sp - 16] = block_c8cyz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cz5; else goto c8cyA;
       u8cz5: // global
           call _c8cyz(R1) args: 0, res: 0, upd: 0;
       c8cyA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cyz() //  [R1]
         { info_tbl: [(c8cyz,
                       label: block_c8cyz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cyz: // global
           _s8a6U::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c8cyD;
               case 2 : goto c8cyE;
               case 3 : goto c8cyF;
               case 4 : goto c8cyG;
               case 5 : goto c8cyH;
               case 6 : goto c8cyI;
           }
       c8cyI: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8cyH: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8cyG: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8cyF: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8cyE: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8cyD: // global
           R3 = _s8a6U::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.40869477 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_entry() //  [R3,
                                                               R4]
         { info_tbl: [(c8czm,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8czm: // global
           _s8a6X::P64 = R3;
           R3 = R4;
           R2 = _s8a6X::P64;
           call GHC.IO.Handle.Types.$w$cshowsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.41273617 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshow_entry() //  [R2]
         { info_tbl: [(c8czI,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8czI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8czJ; else goto c8czK;
       c8czJ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8czK: // global
           I64[Sp - 8] = block_c8czx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cA3; else goto c8czy;
       u8cA3: // global
           call _c8czx(R1) args: 0, res: 0, upd: 0;
       c8czy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8czx() //  [R1]
         { info_tbl: [(c8czx,
                       label: block_c8czx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8czx: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c8czB;
               case 2 : goto c8czC;
               case 3 : goto c8czD;
               case 4 : goto c8czE;
               case 5 : goto c8czF;
               case 6 : goto c8czG;
           }
       c8czG: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8czF: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8czE: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8czD: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8czC: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8czB: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.419574389 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshowList_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8cAq,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cAq: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.423228504 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.425686497 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_$c==_closure" {
     GHC.IO.Handle.Types.$fEqHandle_$c==_closure:
         const GHC.IO.Handle.Types.$fEqHandle_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqHandle_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8cAJ,
                       label: GHC.IO.Handle.Types.$fEqHandle_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cAJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cAK; else goto c8cAL;
       c8cAK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqHandle_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cAL: // global
           I64[Sp - 16] = block_c8cAC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cBo; else goto c8cAD;
       u8cBo: // global
           call _c8cAC(R1) args: 0, res: 0, upd: 0;
       c8cAD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cAC() //  [R1]
         { info_tbl: [(c8cAC,
                       label: block_c8cAC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cAC: // global
           _s8a74::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cAG; else goto c8cAH;
       c8cAG: // global
           I64[Sp] = block_c8cAO_info;
           _s8a77::P64 = P64[R1 + 15];
           R1 = _s8a74::P64;
           P64[Sp + 8] = _s8a77::P64;
           if (R1 & 7 != 0) goto u8cBm; else goto c8cAQ;
       u8cBm: // global
           call _c8cAO(R1) args: 0, res: 0, upd: 0;
       c8cAQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cAH: // global
           I64[Sp] = block_c8cB3_info;
           _s8a7g::P64 = P64[R1 + 14];
           R1 = _s8a74::P64;
           P64[Sp + 8] = _s8a7g::P64;
           if (R1 & 7 != 0) goto u8cBn; else goto c8cB5;
       u8cBn: // global
           call _c8cB3(R1) args: 0, res: 0, upd: 0;
       c8cB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cAO() //  [R1]
         { info_tbl: [(c8cAO,
                       label: block_c8cAO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cAO: // global
           if (R1 & 7 == 1) goto c8cAW; else goto u8cBl;
       c8cAW: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8cBl: // global
           Sp = Sp + 16;
           call _c8cBb() args: 0, res: 0, upd: 0;
     }
 },
 _c8cB3() //  [R1]
         { info_tbl: [(c8cB3,
                       label: block_c8cB3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cB3: // global
           if (R1 & 7 == 1) goto u8cBk; else goto c8cBf;
       u8cBk: // global
           Sp = Sp + 16;
           call _c8cBb() args: 0, res: 0, upd: 0;
       c8cBf: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 14]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cBb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cBb: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.436717957 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqHandle_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqHandle_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqHandle_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8cCa,
                       label: GHC.IO.Handle.Types.$fEqHandle_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cCa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cCb; else goto c8cCc;
       c8cCb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqHandle_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cCc: // global
           I64[Sp - 16] = block_c8cC3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cDl; else goto c8cC4;
       u8cDl: // global
           call _c8cC3(R1) args: 0, res: 0, upd: 0;
       c8cC4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cC3() //  [R1]
         { info_tbl: [(c8cC3,
                       label: block_c8cC3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cC3: // global
           _s8a7q::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cC7; else goto c8cC8;
       c8cC7: // global
           I64[Sp] = block_c8cCf_info;
           _s8a7t::P64 = P64[R1 + 15];
           R1 = _s8a7q::P64;
           P64[Sp + 8] = _s8a7t::P64;
           if (R1 & 7 != 0) goto u8cDj; else goto c8cCh;
       u8cDj: // global
           call _c8cCf(R1) args: 0, res: 0, upd: 0;
       c8cCh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cC8: // global
           I64[Sp] = block_c8cCJ_info;
           _s8a7C::P64 = P64[R1 + 14];
           R1 = _s8a7q::P64;
           P64[Sp + 8] = _s8a7C::P64;
           if (R1 & 7 != 0) goto u8cDk; else goto c8cCL;
       u8cDk: // global
           call _c8cCJ(R1) args: 0, res: 0, upd: 0;
       c8cCL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cCf() //  [R1]
         { info_tbl: [(c8cCf,
                       label: block_c8cCf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cCf: // global
           if (R1 & 7 == 1) goto c8cCC; else goto u8cDg;
       c8cCC: // global
           if (P64[Sp + 8] == P64[R1 + 15]) goto u8cDh; else goto u8cDi;
       u8cDh: // global
           Sp = Sp + 16;
           call _c8cD6() args: 0, res: 0, upd: 0;
       u8cDi: // global
           Sp = Sp + 16;
           goto u8cDo;
       u8cDg: // global
           Sp = Sp + 16;
           goto u8cDo;
       u8cDo: // global
           call _c8cD0() args: 0, res: 0, upd: 0;
     }
 },
 _c8cCJ() //  [R1]
         { info_tbl: [(c8cCJ,
                       label: block_c8cCJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cCJ: // global
           if (R1 & 7 == 1) goto u8cDd; else goto c8cDa;
       u8cDd: // global
           Sp = Sp + 16;
           goto u8cDr;
       c8cDa: // global
           if (P64[Sp + 8] == P64[R1 + 14]) goto u8cDe; else goto u8cDf;
       u8cDe: // global
           Sp = Sp + 16;
           call _c8cD6() args: 0, res: 0, upd: 0;
       u8cDf: // global
           Sp = Sp + 16;
           goto u8cDr;
       u8cDr: // global
           call _c8cD0() args: 0, res: 0, upd: 0;
     }
 },
 _c8cD6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cD6: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cD0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cD0: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.447981404 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_closure" {
     GHC.IO.Handle.Types.$fEqHandle_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqHandle_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqHandle_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.449789592 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewline11_bytes" {
     GHC.IO.Handle.Types.$fReadNewline11_bytes:
         I8[] [76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.451791811 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline10_closure" {
     GHC.IO.Handle.Types.$fReadNewline10_closure:
         const GHC.IO.Handle.Types.$fReadNewline10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline10_entry() //  [R1]
         { info_tbl: [(c8cE5,
                       label: GHC.IO.Handle.Types.$fReadNewline10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cE5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cE6; else goto c8cE7;
       c8cE6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cE7: // global
           (_c8cE2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cE2::I64 == 0) goto c8cE4; else goto c8cE3;
       c8cE4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cE3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cE2::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.456384694 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewline7_bytes" {
     GHC.IO.Handle.Types.$fReadNewline7_bytes:
         I8[] [67,82,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.458143349 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline6_closure" {
     GHC.IO.Handle.Types.$fReadNewline6_closure:
         const GHC.IO.Handle.Types.$fReadNewline6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline6_entry() //  [R1]
         { info_tbl: [(c8cEm,
                       label: GHC.IO.Handle.Types.$fReadNewline6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cEm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cEn; else goto c8cEo;
       c8cEn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cEo: // global
           (_c8cEj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cEj::I64 == 0) goto c8cEl; else goto c8cEk;
       c8cEl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cEk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cEj::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.462293109 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c8cEH,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cEH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cEI; else goto c8cEJ;
       c8cEI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cEJ: // global
           I64[Sp - 16] = block_c8cEA_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cEQ; else goto c8cEB;
       u8cEQ: // global
           call _c8cEA(R1) args: 0, res: 0, upd: 0;
       c8cEB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cEA() //  [R1]
         { info_tbl: [(c8cEA,
                       label: block_c8cEA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cEA: // global
           _s8a7N::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cEE; else goto c8cEF;
       c8cEE: // global
           R3 = _s8a7N::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8cEF: // global
           R3 = _s8a7N::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.468144041 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshow_entry() //  [R2]
         { info_tbl: [(c8cFd,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cFd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cFe; else goto c8cFf;
       c8cFe: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cFf: // global
           I64[Sp - 8] = block_c8cF6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cFm; else goto c8cF7;
       u8cFm: // global
           call _c8cF6(R1) args: 0, res: 0, upd: 0;
       c8cF7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cF6() //  [R1]
         { info_tbl: [(c8cF6,
                       label: block_c8cF6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cF6: // global
           if (R1 & 7 == 1) goto c8cFa; else goto c8cFb;
       c8cFa: // global
           R1 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8cFb: // global
           R1 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.474503295 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline1_closure" {
     GHC.IO.Handle.Types.$fShowNewline1_closure:
         const GHC.IO.Handle.Types.$fShowNewline1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline1_entry() //  [R2, R3]
         { info_tbl: [(c8cFL,
                       label: GHC.IO.Handle.Types.$fShowNewline1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cFL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cFM; else goto c8cFN;
       c8cFM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cFN: // global
           I64[Sp - 16] = block_c8cFE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cFU; else goto c8cFF;
       u8cFU: // global
           call _c8cFE(R1) args: 0, res: 0, upd: 0;
       c8cFF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cFE() //  [R1]
         { info_tbl: [(c8cFE,
                       label: block_c8cFE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cFE: // global
           _s8a7S::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cFI; else goto c8cFJ;
       c8cFI: // global
           R3 = _s8a7S::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8cFJ: // global
           R3 = _s8a7S::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.480216942 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8cGa,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cGa: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowNewline1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.483535523 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_closure" {
     GHC.IO.Handle.Types.$fShowNewline_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.485916151 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode4_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode4_bytes:
         I8[] [78,101,119,108,105,110,101,77,111,100,101,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.488138943 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode3_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode3_bytes:
         I8[] [105,110,112,117,116,78,76,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.489815969 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode2_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode2_bytes:
         I8[] [111,117,116,112,117,116,78,76,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.491442142 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode5_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.495240624 UTC

[section ""data" . GHC.IO.Handle.Types.$w$cshowsPrec1_closure" {
     GHC.IO.Handle.Types.$w$cshowsPrec1_closure:
         const GHC.IO.Handle.Types.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$w$cshowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cGn: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a84_entry() //  [R1]
         { info_tbl: [(c8cGZ,
                       label: sat_s8a84_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cGZ: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a85_entry() //  [R1]
         { info_tbl: [(c8cH8,
                       label: sat_s8a85_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cH8: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a86_entry() //  [R1]
         { info_tbl: [(c8cHf,
                       label: sat_s8a86_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cHf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8cHg; else goto c8cHh;
       c8cHg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cHh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8cGQ_info;
           _s8a81::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8a81::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8cHo; else goto c8cGR;
       u8cHo: // global
           call _c8cGQ(R1) args: 0, res: 0, upd: 0;
       c8cGR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8cGQ() //  [R1]
         { info_tbl: [(c8cGQ,
                       label: block_c8cGQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cGQ: // global
           _s8a81::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cHc; else goto c8cHd;
       c8cHc: // global
           Hp = Hp + 24;
           _s8a83::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8cHn; else goto c8cHj;
       c8cHj: // global
           I64[Hp - 16] = sat_s8a84_info;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c8cHd: // global
           Hp = Hp + 24;
           _s8a83::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8cHn; else goto c8cHm;
       c8cHn: // global
           HpAlloc = 24;
           R1 = _s8a83::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8cHm: // global
           I64[Hp - 16] = sat_s8a85_info;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8a87_entry() //  [R1]
         { info_tbl: [(c8cHp,
                       label: sat_s8a87_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cHp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8cHt; else goto c8cHs;
       c8cHt: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cHs: // global
           _s8a7Y::P64 = P64[R1 + 16];
           _s8a81::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8a86_info;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 karg_s8a82_entry() //  [R1]
         { info_tbl: [(c8cHu,
                       label: karg_s8a82_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cHu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8cHy; else goto c8cHx;
       c8cHy: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cHx: // global
           _s8a7Y::P64 = P64[R1 + 16];
           _s8a81::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8a87_info;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a89_entry() //  [R1]
         { info_tbl: [(c8cHG,
                       label: sat_s8a89_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cHG: // global
           _s8a89::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8cHH; else goto c8cHI;
       c8cHI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8cHK; else goto c8cHJ;
       c8cHK: // global
           HpAlloc = 32;
           goto c8cHH;
       c8cHH: // global
           R1 = _s8a89::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cHJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8a89::P64;
           _s8a7X::P64 = P64[_s8a89::P64 + 16];
           _s8a7Y::P64 = P64[_s8a89::P64 + 24];
           _s8a81::P64 = P64[_s8a89::P64 + 32];
           I64[Hp - 24] = karg_s8a82_info;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           I64[Sp - 32] = block_c8cHz_info;
           R1 = _s8a7X::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8cHR; else goto c8cHA;
       u8cHR: // global
           call _c8cHz(R1) args: 0, res: 0, upd: 0;
       c8cHA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8cHz() //  [R1]
         { info_tbl: [(c8cHz,
                       label: block_c8cHz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cHz: // global
           _c8cGE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cHD; else goto c8cHE;
       c8cHD: // global
           R3 = _c8cGE::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c8cHE: // global
           R3 = _c8cGE::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8a8a_entry() //  [R1]
         { info_tbl: [(c8cHS,
                       label: sat_s8a8a_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cHS: // global
           _s8a8a::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8cHT; else goto c8cHU;
       c8cHU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8cHW; else goto c8cHV;
       c8cHW: // global
           HpAlloc = 40;
           goto c8cHT;
       c8cHT: // global
           R1 = _s8a8a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cHV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8a8a::P64;
           _s8a7X::P64 = P64[_s8a8a::P64 + 16];
           _s8a7Y::P64 = P64[_s8a8a::P64 + 24];
           _s8a81::P64 = P64[_s8a8a::P64 + 32];
           I64[Hp - 32] = sat_s8a89_info;
           P64[Hp - 16] = _s8a7X::P64;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = _s8a81::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_s8a80_entry() //  [R1, R2]
         { info_tbl: [(c8cHX,
                       label: p_s8a80_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cHX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8cI1; else goto c8cI0;
       c8cI1: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cI0: // global
           _s8a7X::P64 = P64[R1 + 7];
           _s8a7Y::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s8a8a_info;
           P64[Hp - 16] = _s8a7X::P64;
           P64[Hp - 8] = _s8a7Y::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8d_entry() //  [R1]
         { info_tbl: [(c8cIb,
                       label: sat_s8a8d_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cIb: // global
           _s8a8d::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8cIc; else goto c8cId;
       c8cId: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8cIf; else goto c8cIe;
       c8cIf: // global
           HpAlloc = 24;
           goto c8cIc;
       c8cIc: // global
           R1 = _s8a8d::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cIe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8a8d::P64;
           _s8a7Z::P64 = P64[_s8a8d::P64 + 16];
           _s8a80::P64 = P64[_s8a8d::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s8a7Z::P64;
           R2 = Hp - 14;
           R1 = _s8a80::P64;
           Sp = Sp - 16;
           call p_s8a80_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$w$cshowsPrec1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8cIj,
                       label: GHC.IO.Handle.Types.$w$cshowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cIj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8cIn; else goto c8cIm;
       c8cIn: // global
           HpAlloc = 80;
           R1 = GHC.IO.Handle.Types.$w$cshowsPrec1_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c8cIm: // global
           I64[Hp - 72] = p_s8a80_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           _c8cGr::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto c8cIh; else goto c8cIi;
       c8cIh: // global
           Hp = Hp - 56;
           R2 = R5;
           R1 = _c8cGr::P64;
           call p_s8a80_entry(R2, R1) args: 8, res: 0, upd: 8;
       c8cIi: // global
           I64[Hp - 48] = sat_s8a8d_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _c8cGr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.523104916 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c8cJm,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cJm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8cJq; else goto c8cJr;
       c8cJq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cJr: // global
           I64[Sp - 24] = block_c8cJj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8cJz; else goto c8cJk;
       u8cJz: // global
           call _c8cJj(R1) args: 0, res: 0, upd: 0;
       c8cJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cJj() //  [R1]
         { info_tbl: [(c8cJj,
                       label: block_c8cJj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cJj: // global
           I64[Sp] = block_c8cJp_info;
           _s8a8i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8a8i::I64;
           if (R1 & 7 != 0) goto u8cJy; else goto c8cJt;
       u8cJy: // global
           call _c8cJp(R1) args: 0, res: 0, upd: 0;
       c8cJt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cJp() //  [R1]
         { info_tbl: [(c8cJp,
                       label: block_c8cJp_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cJp: // global
           R5 = P64[Sp + 16];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.531571759 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode2_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.534192636 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8cJV,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cJV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8cJW; else goto c8cJX;
       c8cJW: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cJX: // global
           I64[Sp - 8] = block_c8cJS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8cK1; else goto c8cJT;
       u8cK1: // global
           call _c8cJS(R1) args: 0, res: 0, upd: 0;
       c8cJT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cJS() //  [R1]
         { info_tbl: [(c8cJS,
                       label: block_c8cJS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cJS: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.539763456 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode1_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode1_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(c8cKi,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cKi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cKj; else goto c8cKk;
       c8cKj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cKk: // global
           I64[Sp - 16] = block_c8cKf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cKo; else goto c8cKg;
       u8cKo: // global
           call _c8cKf(R1) args: 0, res: 0, upd: 0;
       c8cKg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cKf() //  [R1]
         { info_tbl: [(c8cKf,
                       label: block_c8cKf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cKf: // global
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.545624176 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8cKC,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cKC: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.548992311 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.551052202 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline9_closure" {
     GHC.IO.Handle.Types.$fReadNewline9_closure:
         const GHC.IO.Handle.Types.$fReadNewline9_info;
 },
 GHC.IO.Handle.Types.$fReadNewline9_entry() //  [R3]
         { info_tbl: [(c8cKO,
                       label: GHC.IO.Handle.Types.$fReadNewline9_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cKO: // global
           R2 = GHC.IO.Handle.Types.LF_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.554383231 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline8_closure" {
     GHC.IO.Handle.Types.$fReadNewline8_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadNewline10_closure;
         const GHC.IO.Handle.Types.$fReadNewline9_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.556242397 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline5_closure" {
     GHC.IO.Handle.Types.$fReadNewline5_closure:
         const GHC.IO.Handle.Types.$fReadNewline5_info;
 },
 GHC.IO.Handle.Types.$fReadNewline5_entry() //  [R3]
         { info_tbl: [(c8cL0,
                       label: GHC.IO.Handle.Types.$fReadNewline5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cL0: // global
           R2 = GHC.IO.Handle.Types.CRLF_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.560324345 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline4_closure" {
     GHC.IO.Handle.Types.$fReadNewline4_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadNewline6_closure;
         const GHC.IO.Handle.Types.$fReadNewline5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.562144983 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline3_closure" {
     GHC.IO.Handle.Types.$fReadNewline3_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadNewline4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.563913009 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_sps_closure" {
     GHC.IO.Handle.Types.$fReadNewline_sps_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadNewline8_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.566111431 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline2_closure" {
     GHC.IO.Handle.Types.$fReadNewline2_closure:
         const GHC.IO.Handle.Types.$fReadNewline2_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline2_entry() //  [R2]
         { info_tbl: [(c8cLe,
                       label: GHC.IO.Handle.Types.$fReadNewline2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cLe: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.569744169 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline1_closure" {
     GHC.IO.Handle.Types.$fReadNewline1_closure:
         const GHC.IO.Handle.Types.$fReadNewline1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline1_entry() //  [R2, R3]
         { info_tbl: [(c8cLp,
                       label: GHC.IO.Handle.Types.$fReadNewline1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cLp: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.573490783 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_info;
         const 0;
 },
 sat_s8a8D_entry() //  [R1]
         { info_tbl: [(c8cLE,
                       label: sat_s8a8D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cLE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cLF; else goto c8cLG;
       c8cLF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cLG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8cLH,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cLH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8cLL; else goto c8cLK;
       c8cLL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cLK: // global
           I64[Hp - 16] = sat_s8a8D_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.579634103 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8cM0,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cM0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cM1; else goto c8cM2;
       c8cM1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cM2: // global
           (_c8cLX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cLX::I64 == 0) goto c8cLZ; else goto c8cLY;
       c8cLZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cLY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cLX::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.583838717 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline12_closure" {
     GHC.IO.Handle.Types.$fReadNewline12_closure:
         const GHC.IO.Handle.Types.$fReadNewline12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline12_entry() //  [R1]
         { info_tbl: [(c8cMg,
                       label: GHC.IO.Handle.Types.$fReadNewline12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cMg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cMh; else goto c8cMi;
       c8cMh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cMi: // global
           (_c8cMd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cMd::I64 == 0) goto c8cMf; else goto c8cMe;
       c8cMf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cMe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cMd::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.58794193 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadList_entry() //  [R2]
         { info_tbl: [(c8cMu,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cMu: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.59293214 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_closure" {
     GHC.IO.Handle.Types.$fReadNewline_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline1_closure+2;
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.595304494 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode17_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode17_bytes:
         I8[] [78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.597276361 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode16_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode16_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode16_entry() //  [R1]
         { info_tbl: [(c8cMJ,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cMJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cMK; else goto c8cML;
       c8cMK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cML: // global
           (_c8cMG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cMG::I64 == 0) goto c8cMI; else goto c8cMH;
       c8cMI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cMH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cMG::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.60120445 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode16_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.602968277 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode15_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode15_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.604912917 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode14_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode14_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode14_entry() //  [R1]
         { info_tbl: [(c8cN1,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cN1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cN2; else goto c8cN3;
       c8cN2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cN3: // global
           (_c8cMY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cMY::I64 == 0) goto c8cN0; else goto c8cMZ;
       c8cN0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cMZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cMY::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.60909866 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.610913361 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode13_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode13_bytes:
         I8[] [105,110,112,117,116,78,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.612804411 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode12_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode12_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode12_entry() //  [R1]
         { info_tbl: [(c8cNj,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cNj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cNk; else goto c8cNl;
       c8cNk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cNl: // global
           (_c8cNg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cNg::I64 == 0) goto c8cNi; else goto c8cNh;
       c8cNi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cNh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cNg::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.617157902 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode11_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode11_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode11_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode11_entry() //  [R3]
         { info_tbl: [(c8cNx,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cNx: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.620703493 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_n_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_n_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.622588312 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode10_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode10_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.62464412 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode9_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode9_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode9_entry() //  [R1]
         { info_tbl: [(c8cNM,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cNM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cNN; else goto c8cNO;
       c8cNN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cNO: // global
           (_c8cNJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cNJ::I64 == 0) goto c8cNL; else goto c8cNK;
       c8cNL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cNK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cNJ::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.629887702 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode8_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode8_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode9_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.631644958 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode7_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode7_bytes:
         I8[] [111,117,116,112,117,116,78,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.633593533 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode6_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode6_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode6_entry() //  [R1]
         { info_tbl: [(c8cO4,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cO4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cO5; else goto c8cO6;
       c8cO5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cO6: // global
           (_c8cO1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cO1::I64 == 0) goto c8cO3; else goto c8cO2;
       c8cO3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cO2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cO1::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.638124065 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode4_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode4_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode4_entry() //  [R1]
         { info_tbl: [(c8cOk,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cOk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cOl; else goto c8cOm;
       c8cOl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cOm: // global
           (_c8cOh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cOh::I64 == 0) goto c8cOj; else goto c8cOi;
       c8cOj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cOi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cOh::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.642068924 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode3_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode3_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.645844382 UTC

[section ""data" . GHC.IO.Handle.Types.$w$creadPrec_closure" {
     GHC.IO.Handle.Types.$w$creadPrec_closure:
         const GHC.IO.Handle.Types.$w$creadPrec_info;
         const 0;
 },
 sat_s8a8Q_entry() //  [R1, R2]
         { info_tbl: [(c8cP8,
                       label: sat_s8a8Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cP8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8cPc; else goto c8cPb;
       c8cPc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cPb: // global
           _s8a8H::P64 = P64[R1 + 7];
           _s8a8L::P64 = P64[R1 + 15];
           _s8a8N::P64 = P64[R1 + 23];
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = _s8a8L::P64;
           P64[Hp] = _s8a8N::P64;
           R2 = Hp - 15;
           R1 = _s8a8H::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8T_entry() //  [R1, R2]
         { info_tbl: [(c8cPg,
                       label: sat_s8a8T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cPg: // global
           _s8a8N::P64 = R2;
           _s8a8T::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8cPh; else goto c8cPi;
       c8cPi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8cPk; else goto c8cPj;
       c8cPk: // global
           HpAlloc = 32;
           goto c8cPh;
       c8cPh: // global
           R2 = _s8a8N::P64;
           R1 = _s8a8T::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cPj: // global
           _s8a8H::P64 = P64[_s8a8T::P64 + 7];
           _s8a8L::P64 = P64[_s8a8T::P64 + 15];
           I64[Hp - 24] = sat_s8a8Q_info;
           P64[Hp - 16] = _s8a8H::P64;
           P64[Hp - 8] = _s8a8L::P64;
           P64[Hp] = _s8a8N::P64;
           I64[Sp - 8] = block_c8cPd_info;
           R3 = Hp - 23;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8cPd() //  [R1]
         { info_tbl: [(c8cPd,
                       label: block_c8cPd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cPd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8cPn; else goto c8cPm;
       c8cPn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8cPm: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8U_entry() //  [R1, R2]
         { info_tbl: [(c8cPo,
                       label: sat_s8a8U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cPo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8cPs; else goto c8cPr;
       c8cPs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cPr: // global
           _s8a8H::P64 = P64[R1 + 7];
           _s8a8L::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8a8T_info;
           P64[Hp - 8] = _s8a8H::P64;
           P64[Hp] = _s8a8L::P64;
           R5 = Hp - 15;
           R4 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode11_closure+2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8X_entry() //  [R1, R2]
         { info_tbl: [(c8cPw,
                       label: sat_s8a8X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cPw: // global
           _s8a8L::P64 = R2;
           _s8a8X::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8cPx; else goto c8cPy;
       c8cPy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8cPA; else goto c8cPz;
       c8cPA: // global
           HpAlloc = 24;
           goto c8cPx;
       c8cPx: // global
           R2 = _s8a8L::P64;
           R1 = _s8a8X::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cPz: // global
           _s8a8H::P64 = P64[_s8a8X::P64 + 7];
           I64[Hp - 16] = sat_s8a8U_info;
           P64[Hp - 8] = _s8a8H::P64;
           P64[Hp] = _s8a8L::P64;
           I64[Sp - 8] = block_c8cPt_info;
           R3 = Hp - 15;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode8_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8cPt() //  [R1]
         { info_tbl: [(c8cPt,
                       label: block_c8cPt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cPt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8cPD; else goto c8cPC;
       c8cPD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8cPC: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a8Y_entry() //  [R1, R2]
         { info_tbl: [(c8cPE,
                       label: sat_s8a8Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cPE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8cPI; else goto c8cPH;
       c8cPI: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cPH: // global
           _s8a8H::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8a8X_info;
           P64[Hp] = _s8a8H::P64;
           R5 = Hp - 7;
           R4 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode11_closure+2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode12_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8a91_entry() //  [R1, R2]
         { info_tbl: [(c8cPM,
                       label: sat_s8a91_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cPM: // global
           _s8a8J::P64 = R2;
           _s8a91::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8cPN; else goto c8cPO;
       c8cPO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8cPQ; else goto c8cPP;
       c8cPQ: // global
           HpAlloc = 16;
           goto c8cPN;
       c8cPN: // global
           R2 = _s8a8J::P64;
           R1 = _s8a91::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cPP: // global
           _s8a8H::P64 = P64[_s8a91::P64 + 7];
           I64[Hp - 8] = sat_s8a8Y_info;
           P64[Hp] = _s8a8H::P64;
           I64[Sp - 8] = block_c8cPJ_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8cPJ() //  [R1]
         { info_tbl: [(c8cPJ,
                       label: block_c8cPJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cPJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8cPT; else goto c8cPS;
       c8cPT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8cPS: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(c8cPX,
                       label: GHC.IO.Handle.Types.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cPX: // global
           _s8a8H::P64 = R3;
           _s8a8G::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c8cPY; else goto c8cPZ;
       c8cPZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8cQ1; else goto c8cQ0;
       c8cQ1: // global
           HpAlloc = 16;
           goto c8cPY;
       c8cPY: // global
           R3 = _s8a8H::P64;
           R2 = _s8a8G::I64;
           R1 = GHC.IO.Handle.Types.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cQ0: // global
           if (%MO_S_Gt_W64(_s8a8G::I64, 11)) goto c8cPV; else goto c8cPW;
       c8cPV: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8cPW: // global
           I64[Hp - 8] = sat_s8a91_info;
           P64[Hp] = _s8a8H::P64;
           I64[Sp - 8] = block_c8cQ2_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8cQ2() //  [R1]
         { info_tbl: [(c8cQ2,
                       label: block_c8cQ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cQ2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8cQ7; else goto c8cQ6;
       c8cQ7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8cQ6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.671183761 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode2_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode2_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode2_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode2_entry() //  [R2, R3]
         { info_tbl: [(c8cQW,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cQW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cQX; else goto c8cQY;
       c8cQX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cQY: // global
           I64[Sp - 16] = block_c8cQT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cR2; else goto c8cQU;
       u8cR2: // global
           call _c8cQT(R1) args: 0, res: 0, upd: 0;
       c8cQU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cQT() //  [R1]
         { info_tbl: [(c8cQT,
                       label: block_c8cQT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cQT: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.$w$creadPrec_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.676755847 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode1_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode1_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(c8cRg,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cRg: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.680420876 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_info;
         const 0;
 },
 sat_s8a99_entry() //  [R1]
         { info_tbl: [(c8cRv,
                       label: sat_s8a99_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cRv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cRw; else goto c8cRx;
       c8cRw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cRx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8cRy,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cRy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8cRC; else goto c8cRB;
       c8cRC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8cRB: // global
           I64[Hp - 16] = sat_s8a99_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.686495382 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8cRR,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cRR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cRS; else goto c8cRT;
       c8cRS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cRT: // global
           (_c8cRO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cRO::I64 == 0) goto c8cRQ; else goto c8cRP;
       c8cRQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cRP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cRO::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.690597275 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode18_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode18_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode18_entry() //  [R1]
         { info_tbl: [(c8cS7,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cS7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cS8; else goto c8cS9;
       c8cS8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8cS9: // global
           (_c8cS4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8cS4::I64 == 0) goto c8cS6; else goto c8cS5;
       c8cS6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8cS5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8cS4::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.695233459 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_entry() //  [R2]
         { info_tbl: [(c8cSl,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cSl: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode18_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.698658193 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadNewlineMode1_closure+2;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.701731519 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8cSE,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cSE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cSF; else goto c8cSG;
       c8cSF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cSG: // global
           I64[Sp - 16] = block_c8cSx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cT8; else goto c8cSy;
       u8cT8: // global
           call _c8cSx(R1) args: 0, res: 0, upd: 0;
       c8cSy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cSx() //  [R1]
         { info_tbl: [(c8cSx,
                       label: block_c8cSx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cSx: // global
           _s8a9b::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cSB; else goto c8cSC;
       c8cSB: // global
           I64[Sp + 8] = block_c8cSJ_info;
           R1 = _s8a9b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cT6; else goto c8cSL;
       u8cT6: // global
           call _c8cSJ(R1) args: 0, res: 0, upd: 0;
       c8cSL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cSC: // global
           I64[Sp + 8] = block_c8cSY_info;
           R1 = _s8a9b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cT7; else goto c8cT0;
       u8cT7: // global
           call _c8cSY() args: 0, res: 0, upd: 0;
       c8cT0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cSJ() //  [R1]
         { info_tbl: [(c8cSJ,
                       label: block_c8cSJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cSJ: // global
           if (R1 & 7 == 1) goto c8cSR; else goto c8cSV;
       c8cSR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8cSV: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cSY() //  []
         { info_tbl: [(c8cSY,
                       label: block_c8cSY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cSY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.711349879 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8cTI,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cTI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cTJ; else goto c8cTK;
       c8cTJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cTK: // global
           I64[Sp - 16] = block_c8cTB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cUl; else goto c8cTC;
       u8cUl: // global
           call _c8cTB(R1) args: 0, res: 0, upd: 0;
       c8cTC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cTB() //  [R1]
         { info_tbl: [(c8cTB,
                       label: block_c8cTB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cTB: // global
           _s8a9g::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cTF; else goto c8cTG;
       c8cTF: // global
           I64[Sp + 8] = block_c8cTN_info;
           R1 = _s8a9g::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cUj; else goto c8cTP;
       u8cUj: // global
           call _c8cTN(R1) args: 0, res: 0, upd: 0;
       c8cTP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cTG: // global
           I64[Sp + 8] = block_c8cU2_info;
           R1 = _s8a9g::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cUk; else goto c8cU4;
       u8cUk: // global
           call _c8cU2(R1) args: 0, res: 0, upd: 0;
       c8cU4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cTN() //  [R1]
         { info_tbl: [(c8cTN,
                       label: block_c8cTN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cTN: // global
           if (R1 & 7 == 1) goto u8cUi; else goto c8cTZ;
       u8cUi: // global
           Sp = Sp + 8;
           call _c8cUe() args: 0, res: 0, upd: 0;
       c8cTZ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cU2() //  [R1]
         { info_tbl: [(c8cU2,
                       label: block_c8cU2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cU2: // global
           if (R1 & 7 == 1) goto c8cUa; else goto u8cUh;
       c8cUa: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8cUh: // global
           Sp = Sp + 8;
           call _c8cUe() args: 0, res: 0, upd: 0;
     }
 },
 _c8cUe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cUe: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.7219656 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_$c==_closure" {
     GHC.IO.Handle.Types.$fEqNewline_$c==_closure:
         const GHC.IO.Handle.Types.$fEqNewline_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqNewline_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8cV1,
                       label: GHC.IO.Handle.Types.$fEqNewline_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cV1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cV2; else goto c8cV3;
       c8cV2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewline_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cV3: // global
           I64[Sp - 16] = block_c8cUU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cVG; else goto c8cUV;
       u8cVG: // global
           call _c8cUU(R1) args: 0, res: 0, upd: 0;
       c8cUV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cUU() //  [R1]
         { info_tbl: [(c8cUU,
                       label: block_c8cUU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cUU: // global
           _s8a9l::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cUY; else goto c8cUZ;
       c8cUY: // global
           I64[Sp + 8] = block_c8cV6_info;
           R1 = _s8a9l::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cVE; else goto c8cV8;
       u8cVE: // global
           call _c8cV6(R1) args: 0, res: 0, upd: 0;
       c8cV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cUZ: // global
           I64[Sp + 8] = block_c8cVl_info;
           R1 = _s8a9l::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cVF; else goto c8cVn;
       u8cVF: // global
           call _c8cVl(R1) args: 0, res: 0, upd: 0;
       c8cVn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cV6() //  [R1]
         { info_tbl: [(c8cV6,
                       label: block_c8cV6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cV6: // global
           if (R1 & 7 == 1) goto u8cVC; else goto u8cVD;
       u8cVC: // global
           Sp = Sp + 8;
           call _c8cVx() args: 0, res: 0, upd: 0;
       u8cVD: // global
           Sp = Sp + 8;
           call _c8cVt() args: 0, res: 0, upd: 0;
     }
 },
 _c8cVl() //  [R1]
         { info_tbl: [(c8cVl,
                       label: block_c8cVl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cVl: // global
           if (R1 & 7 == 1) goto u8cVA; else goto u8cVB;
       u8cVA: // global
           Sp = Sp + 8;
           call _c8cVt() args: 0, res: 0, upd: 0;
       u8cVB: // global
           Sp = Sp + 8;
           call _c8cVx() args: 0, res: 0, upd: 0;
     }
 },
 _c8cVt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cVt: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cVx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cVx: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.733653605 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqNewline_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqNewline_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqNewline_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8cWp,
                       label: GHC.IO.Handle.Types.$fEqNewline_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cWp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cWq; else goto c8cWr;
       c8cWq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewline_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cWr: // global
           I64[Sp - 16] = block_c8cWi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cX4; else goto c8cWj;
       u8cX4: // global
           call _c8cWi(R1) args: 0, res: 0, upd: 0;
       c8cWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cWi() //  [R1]
         { info_tbl: [(c8cWi,
                       label: block_c8cWi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cWi: // global
           _s8a9q::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cWm; else goto c8cWn;
       c8cWm: // global
           I64[Sp + 8] = block_c8cWu_info;
           R1 = _s8a9q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cX2; else goto c8cWw;
       u8cX2: // global
           call _c8cWu(R1) args: 0, res: 0, upd: 0;
       c8cWw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cWn: // global
           I64[Sp + 8] = block_c8cWJ_info;
           R1 = _s8a9q::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cX3; else goto c8cWL;
       u8cX3: // global
           call _c8cWJ(R1) args: 0, res: 0, upd: 0;
       c8cWL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cWu() //  [R1]
         { info_tbl: [(c8cWu,
                       label: block_c8cWu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cWu: // global
           if (R1 & 7 == 1) goto u8cX0; else goto u8cX1;
       u8cX0: // global
           Sp = Sp + 8;
           call _c8cWV() args: 0, res: 0, upd: 0;
       u8cX1: // global
           Sp = Sp + 8;
           call _c8cWR() args: 0, res: 0, upd: 0;
     }
 },
 _c8cWJ() //  [R1]
         { info_tbl: [(c8cWJ,
                       label: block_c8cWJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cWJ: // global
           if (R1 & 7 == 1) goto u8cWY; else goto u8cWZ;
       u8cWY: // global
           Sp = Sp + 8;
           call _c8cWR() args: 0, res: 0, upd: 0;
       u8cWZ: // global
           Sp = Sp + 8;
           call _c8cWV() args: 0, res: 0, upd: 0;
     }
 },
 _c8cWR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cWR: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cWV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cWV: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.74539296 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_closure" {
     GHC.IO.Handle.Types.$fEqNewline_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqNewline_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqNewline_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.747662315 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8cXO,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cXO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cXP; else goto c8cXQ;
       c8cXP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cXQ: // global
           I64[Sp - 16] = block_c8cXH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cYi; else goto c8cXI;
       u8cYi: // global
           call _c8cXH(R1) args: 0, res: 0, upd: 0;
       c8cXI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cXH() //  [R1]
         { info_tbl: [(c8cXH,
                       label: block_c8cXH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cXH: // global
           _s8a9u::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cXL; else goto c8cXM;
       c8cXL: // global
           I64[Sp + 8] = block_c8cXT_info;
           R1 = _s8a9u::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cYg; else goto c8cXV;
       u8cYg: // global
           call _c8cXT(R1) args: 0, res: 0, upd: 0;
       c8cXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cXM: // global
           I64[Sp + 8] = block_c8cY8_info;
           R1 = _s8a9u::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cYh; else goto c8cYa;
       u8cYh: // global
           call _c8cY8() args: 0, res: 0, upd: 0;
       c8cYa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cXT() //  [R1]
         { info_tbl: [(c8cXT,
                       label: block_c8cXT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cXT: // global
           if (R1 & 7 == 1) goto c8cY1; else goto c8cY5;
       c8cY1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8cY5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cY8() //  []
         { info_tbl: [(c8cY8,
                       label: block_c8cY8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cY8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.757378262 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8cYS,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cYS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cYT; else goto c8cYU;
       c8cYT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cYU: // global
           I64[Sp - 16] = block_c8cYL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8cZ8; else goto c8cYM;
       u8cZ8: // global
           call _c8cYL(R1) args: 0, res: 0, upd: 0;
       c8cYM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cYL() //  [R1]
         { info_tbl: [(c8cYL,
                       label: block_c8cYL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cYL: // global
           _s8a9z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cYP; else goto c8cYQ;
       c8cYP: // global
           R1 = _s8a9z::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8cYQ: // global
           I64[Sp + 8] = block_c8cZ0_info;
           R1 = _s8a9z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8cZ7; else goto c8cZ2;
       u8cZ7: // global
           call _c8cZ0() args: 0, res: 0, upd: 0;
       c8cZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cZ0() //  []
         { info_tbl: [(c8cZ0,
                       label: block_c8cZ0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cZ0: // global
           R1 = GHC.IO.Handle.Types.CRLF_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.764871255 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8cZC,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cZC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8cZD; else goto c8cZE;
       c8cZD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8cZE: // global
           I64[Sp - 16] = block_c8cZv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8d06; else goto c8cZw;
       u8d06: // global
           call _c8cZv(R1) args: 0, res: 0, upd: 0;
       c8cZw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cZv() //  [R1]
         { info_tbl: [(c8cZv,
                       label: block_c8cZv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cZv: // global
           _s8a9E::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8cZz; else goto c8cZA;
       c8cZz: // global
           I64[Sp + 8] = block_c8cZH_info;
           R1 = _s8a9E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8d04; else goto c8cZJ;
       u8d04: // global
           call _c8cZH(R1) args: 0, res: 0, upd: 0;
       c8cZJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8cZA: // global
           I64[Sp + 8] = block_c8cZW_info;
           R1 = _s8a9E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8d05; else goto c8cZY;
       u8d05: // global
           call _c8cZW() args: 0, res: 0, upd: 0;
       c8cZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8cZH() //  [R1]
         { info_tbl: [(c8cZH,
                       label: block_c8cZH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cZH: // global
           if (R1 & 7 == 1) goto c8cZP; else goto c8cZT;
       c8cZP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8cZT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8cZW() //  []
         { info_tbl: [(c8cZW,
                       label: block_c8cZW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8cZW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.774346821 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8d0z,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d0z: // global
           _s8a9J::P64 = R3;
           R3 = R2;
           R2 = _s8a9J::P64;
           call GHC.IO.Handle.Types.$fOrdNewline_$c<_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.778820867 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8d0R,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d0R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8d0S; else goto c8d0T;
       c8d0S: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8d0T: // global
           I64[Sp - 16] = block_c8d0K_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8d17; else goto c8d0L;
       u8d17: // global
           call _c8d0K(R1) args: 0, res: 0, upd: 0;
       c8d0L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d0K() //  [R1]
         { info_tbl: [(c8d0K,
                       label: block_c8d0K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d0K: // global
           _s8a9K::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8d0O; else goto c8d0P;
       c8d0O: // global
           I64[Sp + 8] = block_c8d0W_info;
           R1 = _s8a9K::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8d16; else goto c8d0Y;
       u8d16: // global
           call _c8d0W() args: 0, res: 0, upd: 0;
       c8d0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8d0P: // global
           R1 = _s8a9K::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8d0W() //  []
         { info_tbl: [(c8d0W,
                       label: block_c8d0W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d0W: // global
           R1 = GHC.IO.Handle.Types.LF_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.785968062 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqNewline_closure+1;
         const GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.78852517 UTC

[section ""data" . GHC.IO.Handle.Types.$w$ccompare_closure" {
     GHC.IO.Handle.Types.$w$ccompare_closure:
         const GHC.IO.Handle.Types.$w$ccompare_info;
 },
 GHC.IO.Handle.Types.$w$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8d1C,
                       label: GHC.IO.Handle.Types.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d1C: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8d1D; else goto c8d1E;
       c8d1D: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$ccompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8d1E: // global
           I64[Sp - 32] = block_c8d1v_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8d2f; else goto c8d1w;
       u8d2f: // global
           call _c8d1v(R1) args: 0, res: 0, upd: 0;
       c8d1w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d1v() //  [R1]
         { info_tbl: [(c8d1v,
                       label: block_c8d1v_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d1v: // global
           _s8a9Q::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8d1z; else goto c8d1A;
       c8d1z: // global
           I64[Sp] = block_c8d1H_info;
           R1 = _s8a9Q::P64;
           if (R1 & 7 != 0) goto u8d2d; else goto c8d1J;
       u8d2d: // global
           call _c8d1H(R1) args: 0, res: 0, upd: 0;
       c8d1J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8d1A: // global
           I64[Sp] = block_c8d1W_info;
           R1 = _s8a9Q::P64;
           if (R1 & 7 != 0) goto u8d2e; else goto c8d1Y;
       u8d2e: // global
           call _c8d1W(R1) args: 0, res: 0, upd: 0;
       c8d1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d1H() //  [R1]
         { info_tbl: [(c8d1H,
                       label: block_c8d1H_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d1H: // global
           if (R1 & 7 == 1) goto u8d2c; else goto c8d1T;
       u8d2c: // global
           Sp = Sp + 8;
           call _c8d28() args: 0, res: 0, upd: 0;
       c8d1T: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8d1W() //  [R1]
         { info_tbl: [(c8d1W,
                       label: block_c8d1W_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d1W: // global
           if (R1 & 7 == 1) goto c8d24; else goto u8d2b;
       c8d24: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8d2b: // global
           Sp = Sp + 8;
           call _c8d28() args: 0, res: 0, upd: 0;
     }
 },
 _c8d28() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d28: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fOrdNewline_$ccompare_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.799363336 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8d2Q,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d2Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8d2U; else goto c8d2V;
       c8d2U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8d2V: // global
           I64[Sp - 16] = block_c8d2N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8d33; else goto c8d2O;
       u8d33: // global
           call _c8d2N(R1) args: 0, res: 0, upd: 0;
       c8d2O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d2N() //  [R1]
         { info_tbl: [(c8d2N,
                       label: block_c8d2N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d2N: // global
           I64[Sp - 8] = block_c8d2T_info;
           _s8a9Y::P64 = P64[R1 + 7];
           _s8a9Z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8a9Z::P64;
           P64[Sp + 8] = _s8a9Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8d32; else goto c8d2X;
       u8d32: // global
           call _c8d2T(R1) args: 0, res: 0, upd: 0;
       c8d2X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d2T() //  [R1]
         { info_tbl: [(c8d2T,
                       label: block_c8d2T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d2T: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$ccompare_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.807486985 UTC

[section ""data" . GHC.IO.Handle.Types.$w$c<_closure" {
     GHC.IO.Handle.Types.$w$c<_closure:
         const GHC.IO.Handle.Types.$w$c<_info;
 },
 GHC.IO.Handle.Types.$w$c<_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8d3s,
                       label: GHC.IO.Handle.Types.$w$c<_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d3s: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8d3t; else goto c8d3u;
       c8d3t: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$c<_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8d3u: // global
           I64[Sp - 32] = block_c8d3l_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8d45; else goto c8d3m;
       u8d45: // global
           call _c8d3l(R1) args: 0, res: 0, upd: 0;
       c8d3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d3l() //  [R1]
         { info_tbl: [(c8d3l,
                       label: block_c8d3l_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d3l: // global
           _s8aa5::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8d3p; else goto c8d3q;
       c8d3p: // global
           I64[Sp] = block_c8d3x_info;
           R1 = _s8aa5::P64;
           if (R1 & 7 != 0) goto u8d43; else goto c8d3z;
       u8d43: // global
           call _c8d3x(R1) args: 0, res: 0, upd: 0;
       c8d3z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8d3q: // global
           I64[Sp] = block_c8d3M_info;
           R1 = _s8aa5::P64;
           if (R1 & 7 != 0) goto u8d44; else goto c8d3O;
       u8d44: // global
           call _c8d3M(R1) args: 0, res: 0, upd: 0;
       c8d3O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d3x() //  [R1]
         { info_tbl: [(c8d3x,
                       label: block_c8d3x_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d3x: // global
           if (R1 & 7 == 1) goto u8d42; else goto c8d3J;
       u8d42: // global
           Sp = Sp + 8;
           call _c8d3Y() args: 0, res: 0, upd: 0;
       c8d3J: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8d3M() //  [R1]
         { info_tbl: [(c8d3M,
                       label: block_c8d3M_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d3M: // global
           if (R1 & 7 == 1) goto c8d3U; else goto u8d41;
       c8d3U: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8d41: // global
           Sp = Sp + 8;
           call _c8d3Y() args: 0, res: 0, upd: 0;
     }
 },
 _c8d3Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d3Y: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fOrdNewline_$c<_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.818920939 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8d4G,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d4G: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8d4K; else goto c8d4L;
       c8d4K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8d4L: // global
           I64[Sp - 16] = block_c8d4D_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8d4T; else goto c8d4E;
       u8d4T: // global
           call _c8d4D(R1) args: 0, res: 0, upd: 0;
       c8d4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d4D() //  [R1]
         { info_tbl: [(c8d4D,
                       label: block_c8d4D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d4D: // global
           I64[Sp - 8] = block_c8d4J_info;
           _s8aad::P64 = P64[R1 + 7];
           _s8aae::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aae::P64;
           P64[Sp + 8] = _s8aad::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8d4S; else goto c8d4N;
       u8d4S: // global
           call _c8d4J(R1) args: 0, res: 0, upd: 0;
       c8d4N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d4J() //  [R1]
         { info_tbl: [(c8d4J,
                       label: block_c8d4J_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d4J: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$c<_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.827189538 UTC

[section ""data" . GHC.IO.Handle.Types.$w$c==_closure" {
     GHC.IO.Handle.Types.$w$c==_closure:
         const GHC.IO.Handle.Types.$w$c==_info;
 },
 GHC.IO.Handle.Types.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8d5i,
                       label: GHC.IO.Handle.Types.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d5i: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8d5j; else goto c8d5k;
       c8d5j: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8d5k: // global
           I64[Sp - 32] = block_c8d5b_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8d5X; else goto c8d5c;
       u8d5X: // global
           call _c8d5b(R1) args: 0, res: 0, upd: 0;
       c8d5c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d5b() //  [R1]
         { info_tbl: [(c8d5b,
                       label: block_c8d5b_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d5b: // global
           _s8aak::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8d5f; else goto c8d5g;
       c8d5f: // global
           I64[Sp] = block_c8d5n_info;
           R1 = _s8aak::P64;
           if (R1 & 7 != 0) goto u8d5V; else goto c8d5p;
       u8d5V: // global
           call _c8d5n(R1) args: 0, res: 0, upd: 0;
       c8d5p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8d5g: // global
           I64[Sp] = block_c8d5C_info;
           R1 = _s8aak::P64;
           if (R1 & 7 != 0) goto u8d5W; else goto c8d5E;
       u8d5W: // global
           call _c8d5C(R1) args: 0, res: 0, upd: 0;
       c8d5E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d5n() //  [R1]
         { info_tbl: [(c8d5n,
                       label: block_c8d5n_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d5n: // global
           if (R1 & 7 == 1) goto u8d5T; else goto u8d5U;
       u8d5T: // global
           Sp = Sp + 8;
           call _c8d5O() args: 0, res: 0, upd: 0;
       u8d5U: // global
           Sp = Sp + 32;
           call _c8d5K() args: 0, res: 0, upd: 0;
     }
 },
 _c8d5C() //  [R1]
         { info_tbl: [(c8d5C,
                       label: block_c8d5C_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d5C: // global
           if (R1 & 7 == 1) goto u8d5R; else goto u8d5S;
       u8d5R: // global
           Sp = Sp + 32;
           call _c8d5K() args: 0, res: 0, upd: 0;
       u8d5S: // global
           Sp = Sp + 8;
           call _c8d5O() args: 0, res: 0, upd: 0;
     }
 },
 _c8d5K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d5K: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8d5O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d5O: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fEqNewline_$c==_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.838485549 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure:
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqNewlineMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8d6B,
                       label: GHC.IO.Handle.Types.$fEqNewlineMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d6B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8d6F; else goto c8d6G;
       c8d6F: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8d6G: // global
           I64[Sp - 16] = block_c8d6y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8d6O; else goto c8d6z;
       u8d6O: // global
           call _c8d6y(R1) args: 0, res: 0, upd: 0;
       c8d6z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d6y() //  [R1]
         { info_tbl: [(c8d6y,
                       label: block_c8d6y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d6y: // global
           I64[Sp - 8] = block_c8d6E_info;
           _s8aas::P64 = P64[R1 + 7];
           _s8aat::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aat::P64;
           P64[Sp + 8] = _s8aas::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8d6N; else goto c8d6I;
       u8d6N: // global
           call _c8d6E(R1) args: 0, res: 0, upd: 0;
       c8d6I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d6E() //  [R1]
         { info_tbl: [(c8d6E,
                       label: block_c8d6E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d6E: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$c==_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.847229845 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8d79,
                       label: GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d79: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8d7d; else goto c8d7e;
       c8d7d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8d7e: // global
           I64[Sp - 16] = block_c8d76_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8d9p; else goto c8d77;
       u8d9p: // global
           call _c8d76(R1) args: 0, res: 0, upd: 0;
       c8d77: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d76() //  [R1]
         { info_tbl: [(c8d76,
                       label: block_c8d76_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d76: // global
           I64[Sp - 8] = block_c8d7c_info;
           _s8aaA::P64 = P64[R1 + 7];
           _s8aaB::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aaB::P64;
           P64[Sp + 8] = _s8aaA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8d9o; else goto c8d7g;
       u8d9o: // global
           call _c8d7c(R1) args: 0, res: 0, upd: 0;
       c8d7g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d7c() //  [R1]
         { info_tbl: [(c8d7c,
                       label: block_c8d7c_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d7c: // global
           I64[Sp - 8] = block_c8d7k_info;
           _s8aaD::P64 = P64[R1 + 7];
           _s8aaE::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8aaE::P64;
           P64[Sp + 16] = _s8aaD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8d9q; else goto c8d7m;
       u8d9q: // global
           call _c8d7k(R1) args: 0, res: 0, upd: 0;
       c8d7m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d7k() //  [R1]
         { info_tbl: [(c8d7k,
                       label: block_c8d7k_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d7k: // global
           _s8aaD::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8d7t; else goto c8d8j;
       c8d7t: // global
           I64[Sp] = block_c8d7q_info;
           R1 = _s8aaD::P64;
           if (R1 & 7 != 0) goto u8d9r; else goto c8d7u;
       u8d9r: // global
           call _c8d7q(R1) args: 0, res: 0, upd: 0;
       c8d7u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8d8j: // global
           I64[Sp] = block_c8d8h_info;
           R1 = _s8aaD::P64;
           if (R1 & 7 != 0) goto u8d9s; else goto c8d8k;
       u8d9s: // global
           call _c8d8h(R1) args: 0, res: 0, upd: 0;
       c8d8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d7q() //  [R1]
         { info_tbl: [(c8d7q,
                       label: block_c8d7q_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d7q: // global
           if (R1 & 7 == 1) goto c8d7B; else goto u8d9j;
       c8d7B: // global
           I64[Sp] = block_c8d7y_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8d9t; else goto c8d7C;
       u8d9t: // global
           call _c8d7y(R1) args: 0, res: 0, upd: 0;
       c8d7C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8d9j: // global
           Sp = Sp + 32;
           call _c8d90() args: 0, res: 0, upd: 0;
     }
 },
 _c8d7y() //  [R1]
         { info_tbl: [(c8d7y,
                       label: block_c8d7y_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d7y: // global
           _s8aaE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8d7J; else goto c8d7Z;
       c8d7J: // global
           I64[Sp + 24] = block_c8d7G_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8d9v; else goto c8d7K;
       u8d9v: // global
           call _c8d7G(R1) args: 0, res: 0, upd: 0;
       c8d7K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8d7Z: // global
           I64[Sp + 24] = block_c8d7X_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8d9w; else goto c8d80;
       u8d9w: // global
           call _c8d7X(R1) args: 0, res: 0, upd: 0;
       c8d80: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d7G() //  [R1]
         { info_tbl: [(c8d7G,
                       label: block_c8d7G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d7G: // global
           if (R1 & 7 == 1) goto u8d9m; else goto u8d9n;
       u8d9m: // global
           Sp = Sp + 8;
           call _c8d94() args: 0, res: 0, upd: 0;
       u8d9n: // global
           Sp = Sp + 8;
           call _c8d90() args: 0, res: 0, upd: 0;
     }
 },
 _c8d7X() //  [R1]
         { info_tbl: [(c8d7X,
                       label: block_c8d7X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d7X: // global
           if (R1 & 7 == 1) goto u8d9k; else goto u8d9l;
       u8d9k: // global
           Sp = Sp + 8;
           call _c8d90() args: 0, res: 0, upd: 0;
       u8d9l: // global
           Sp = Sp + 8;
           call _c8d94() args: 0, res: 0, upd: 0;
     }
 },
 _c8d8h() //  [R1]
         { info_tbl: [(c8d8h,
                       label: block_c8d8h_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d8h: // global
           if (R1 & 7 == 1) goto u8d9e; else goto c8d8v;
       u8d9e: // global
           Sp = Sp + 32;
           call _c8d90() args: 0, res: 0, upd: 0;
       c8d8v: // global
           I64[Sp] = block_c8d8t_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8d9B; else goto c8d8w;
       u8d9B: // global
           call _c8d8t(R1) args: 0, res: 0, upd: 0;
       c8d8w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d8t() //  [R1]
         { info_tbl: [(c8d8t,
                       label: block_c8d8t_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d8t: // global
           _s8aaE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8d8D; else goto c8d8T;
       c8d8D: // global
           I64[Sp + 24] = block_c8d8A_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8d9D; else goto c8d8E;
       u8d9D: // global
           call _c8d8A(R1) args: 0, res: 0, upd: 0;
       c8d8E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8d8T: // global
           I64[Sp + 24] = block_c8d8R_info;
           R1 = _s8aaE::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8d9E; else goto c8d8U;
       u8d9E: // global
           call _c8d8R(R1) args: 0, res: 0, upd: 0;
       c8d8U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8d8A() //  [R1]
         { info_tbl: [(c8d8A,
                       label: block_c8d8A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d8A: // global
           if (R1 & 7 == 1) goto u8d9h; else goto u8d9i;
       u8d9h: // global
           Sp = Sp + 8;
           call _c8d94() args: 0, res: 0, upd: 0;
       u8d9i: // global
           Sp = Sp + 8;
           call _c8d90() args: 0, res: 0, upd: 0;
     }
 },
 _c8d8R() //  [R1]
         { info_tbl: [(c8d8R,
                       label: block_c8d8R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d8R: // global
           if (R1 & 7 == 1) goto u8d9f; else goto u8d9g;
       u8d9f: // global
           Sp = Sp + 8;
           call _c8d90() args: 0, res: 0, upd: 0;
       u8d9g: // global
           Sp = Sp + 8;
           call _c8d94() args: 0, res: 0, upd: 0;
     }
 },
 _c8d90() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d90: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8d94() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8d94: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.873632468 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.876742703 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8db2,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8db2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8db6; else goto c8db7;
       c8db6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8db7: // global
           I64[Sp - 16] = block_c8daZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dd0; else goto c8db0;
       u8dd0: // global
           call _c8daZ(R1) args: 0, res: 0, upd: 0;
       c8db0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8daZ() //  [R1]
         { info_tbl: [(c8daZ,
                       label: block_c8daZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8daZ: // global
           I64[Sp - 8] = block_c8db5_info;
           _s8aaR::P64 = P64[R1 + 7];
           _s8aaS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aaS::P64;
           P64[Sp + 8] = _s8aaR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dcZ; else goto c8db9;
       u8dcZ: // global
           call _c8db5(R1) args: 0, res: 0, upd: 0;
       c8db9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8db5() //  [R1]
         { info_tbl: [(c8db5,
                       label: block_c8db5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8db5: // global
           I64[Sp - 8] = block_c8dbd_info;
           _s8aaU::P64 = P64[R1 + 7];
           _s8aaV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8aaV::P64;
           P64[Sp + 16] = _s8aaU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dd1; else goto c8dbf;
       u8dd1: // global
           call _c8dbd(R1) args: 0, res: 0, upd: 0;
       c8dbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dbd() //  [R1]
         { info_tbl: [(c8dbd,
                       label: block_c8dbd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dbd: // global
           _s8aaU::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8dbm; else goto c8dc6;
       c8dbm: // global
           I64[Sp] = block_c8dbj_info;
           R1 = _s8aaU::P64;
           if (R1 & 7 != 0) goto u8dd2; else goto c8dbn;
       u8dd2: // global
           call _c8dbj(R1) args: 0, res: 0, upd: 0;
       c8dbn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dc6: // global
           I64[Sp] = block_c8dc4_info;
           R1 = _s8aaU::P64;
           if (R1 & 7 != 0) goto u8dd3; else goto c8dc7;
       u8dd3: // global
           call _c8dc4(R1) args: 0, res: 0, upd: 0;
       c8dc7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dbj() //  [R1]
         { info_tbl: [(c8dbj,
                       label: block_c8dbj_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dbj: // global
           if (R1 & 7 == 1) goto c8dbu; else goto u8dcW;
       c8dbu: // global
           I64[Sp] = block_c8dbr_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8dd4; else goto c8dbv;
       u8dd4: // global
           call _c8dbr(R1) args: 0, res: 0, upd: 0;
       c8dbv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dcW: // global
           Sp = Sp + 32;
           call _c8dcB() args: 0, res: 0, upd: 0;
     }
 },
 _c8dbr() //  [R1]
         { info_tbl: [(c8dbr,
                       label: block_c8dbr_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dbr: // global
           _s8aaV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dbC; else goto c8dbS;
       c8dbC: // global
           I64[Sp + 24] = block_c8dbz_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dd6; else goto c8dbD;
       u8dd6: // global
           call _c8dbz(R1) args: 0, res: 0, upd: 0;
       c8dbD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dbS: // global
           I64[Sp + 24] = block_c8dbQ_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dd7; else goto c8dbT;
       u8dd7: // global
           call _c8dbQ() args: 0, res: 0, upd: 0;
       c8dbT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dbz() //  [R1]
         { info_tbl: [(c8dbz,
                       label: block_c8dbz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dbz: // global
           if (R1 & 7 == 1) goto u8dcX; else goto u8dcY;
       u8dcX: // global
           Sp = Sp + 8;
           call _c8dcx() args: 0, res: 0, upd: 0;
       u8dcY: // global
           Sp = Sp + 8;
           call _c8dcB() args: 0, res: 0, upd: 0;
     }
 },
 _c8dbQ() //  []
         { info_tbl: [(c8dbQ,
                       label: block_c8dbQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dbQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dc4() //  [R1]
         { info_tbl: [(c8dc4,
                       label: block_c8dc4_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dc4: // global
           if (R1 & 7 == 1) goto u8dcT; else goto c8dci;
       u8dcT: // global
           Sp = Sp + 32;
           call _c8dcx() args: 0, res: 0, upd: 0;
       c8dci: // global
           I64[Sp] = block_c8dcg_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8dda; else goto c8dcj;
       u8dda: // global
           call _c8dcg(R1) args: 0, res: 0, upd: 0;
       c8dcj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dcg() //  [R1]
         { info_tbl: [(c8dcg,
                       label: block_c8dcg_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dcg: // global
           _s8aaV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dcq; else goto c8dcG;
       c8dcq: // global
           I64[Sp + 24] = block_c8dcn_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8ddc; else goto c8dcr;
       u8ddc: // global
           call _c8dcn(R1) args: 0, res: 0, upd: 0;
       c8dcr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dcG: // global
           I64[Sp + 24] = block_c8dcE_info;
           R1 = _s8aaV::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8ddd; else goto c8dcH;
       u8ddd: // global
           call _c8dcE() args: 0, res: 0, upd: 0;
       c8dcH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dcn() //  [R1]
         { info_tbl: [(c8dcn,
                       label: block_c8dcn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dcn: // global
           if (R1 & 7 == 1) goto u8dcU; else goto u8dcV;
       u8dcU: // global
           Sp = Sp + 8;
           call _c8dcx() args: 0, res: 0, upd: 0;
       u8dcV: // global
           Sp = Sp + 8;
           call _c8dcB() args: 0, res: 0, upd: 0;
     }
 },
 _c8dcx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dcx: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dcB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dcB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dcE() //  []
         { info_tbl: [(c8dcE,
                       label: block_c8dcE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dcE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.903947572 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8dew,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dew: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8deA; else goto c8deB;
       c8deA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8deB: // global
           I64[Sp - 16] = block_c8det_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dgu; else goto c8deu;
       u8dgu: // global
           call _c8det(R1) args: 0, res: 0, upd: 0;
       c8deu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8det() //  [R1]
         { info_tbl: [(c8det,
                       label: block_c8det_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8det: // global
           I64[Sp - 16] = block_c8dez_info;
           _s8ab7::P64 = R1;
           _s8ab8::P64 = P64[R1 + 7];
           _s8ab9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s8ab9::P64;
           P64[Sp] = _s8ab8::P64;
           P64[Sp + 8] = _s8ab7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dgt; else goto c8deD;
       u8dgt: // global
           call _c8dez(R1) args: 0, res: 0, upd: 0;
       c8deD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dez() //  [R1]
         { info_tbl: [(c8dez,
                       label: block_c8dez_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dez: // global
           I64[Sp - 16] = block_c8deH_info;
           _s8aba::P64 = R1;
           _s8abb::P64 = P64[R1 + 7];
           _s8abc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8abc::P64;
           P64[Sp] = _s8abb::P64;
           P64[Sp + 16] = _s8aba::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dgv; else goto c8deJ;
       u8dgv: // global
           call _c8deH(R1) args: 0, res: 0, upd: 0;
       c8deJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8deH() //  [R1]
         { info_tbl: [(c8deH,
                       label: block_c8deH_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8deH: // global
           _s8abb::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8deQ; else goto c8dfA;
       c8deQ: // global
           I64[Sp] = block_c8deN_info;
           R1 = _s8abb::P64;
           if (R1 & 7 != 0) goto u8dgw; else goto c8deR;
       u8dgw: // global
           call _c8deN(R1) args: 0, res: 0, upd: 0;
       c8deR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dfA: // global
           I64[Sp] = block_c8dfy_info;
           R1 = _s8abb::P64;
           if (R1 & 7 != 0) goto u8dgx; else goto c8dfB;
       u8dgx: // global
           call _c8dfy(R1) args: 0, res: 0, upd: 0;
       c8dfB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8deN() //  [R1]
         { info_tbl: [(c8deN,
                       label: block_c8deN_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8deN: // global
           if (R1 & 7 == 1) goto c8deY; else goto u8dgq;
       c8deY: // global
           I64[Sp] = block_c8deV_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8dgy; else goto c8deZ;
       u8dgy: // global
           call _c8deV(R1) args: 0, res: 0, upd: 0;
       c8deZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dgq: // global
           Sp = Sp + 32;
           call _c8dg5() args: 0, res: 0, upd: 0;
     }
 },
 _c8deV() //  [R1]
         { info_tbl: [(c8deV,
                       label: block_c8deV_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8deV: // global
           _s8abc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8df6; else goto c8dfm;
       c8df6: // global
           I64[Sp + 24] = block_c8df3_info;
           R1 = _s8abc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dgA; else goto c8df7;
       u8dgA: // global
           call _c8df3(R1) args: 0, res: 0, upd: 0;
       c8df7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dfm: // global
           I64[Sp + 32] = block_c8dfk_info;
           R1 = _s8abc::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8dgB; else goto c8dfn;
       u8dgB: // global
           call _c8dfk() args: 0, res: 0, upd: 0;
       c8dfn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8df3() //  [R1]
         { info_tbl: [(c8df3,
                       label: block_c8df3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8df3: // global
           if (R1 & 7 == 1) goto u8dgr; else goto u8dgs;
       u8dgr: // global
           Sp = Sp + 16;
           call _c8dg1() args: 0, res: 0, upd: 0;
       u8dgs: // global
           Sp = Sp + 8;
           call _c8dg5() args: 0, res: 0, upd: 0;
     }
 },
 _c8dfk() //  []
         { info_tbl: [(c8dfk,
                       label: block_c8dfk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dfk: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dfy() //  [R1]
         { info_tbl: [(c8dfy,
                       label: block_c8dfy_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dfy: // global
           if (R1 & 7 == 1) goto u8dgn; else goto c8dfM;
       u8dgn: // global
           Sp = Sp + 40;
           call _c8dg1() args: 0, res: 0, upd: 0;
       c8dfM: // global
           I64[Sp] = block_c8dfK_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8dgE; else goto c8dfN;
       u8dgE: // global
           call _c8dfK(R1) args: 0, res: 0, upd: 0;
       c8dfN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dfK() //  [R1]
         { info_tbl: [(c8dfK,
                       label: block_c8dfK_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dfK: // global
           _s8abc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dfU; else goto c8dga;
       c8dfU: // global
           I64[Sp + 24] = block_c8dfR_info;
           R1 = _s8abc::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dgG; else goto c8dfV;
       u8dgG: // global
           call _c8dfR(R1) args: 0, res: 0, upd: 0;
       c8dfV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dga: // global
           I64[Sp + 32] = block_c8dg8_info;
           R1 = _s8abc::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8dgH; else goto c8dgb;
       u8dgH: // global
           call _c8dg8() args: 0, res: 0, upd: 0;
       c8dgb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dfR() //  [R1]
         { info_tbl: [(c8dfR,
                       label: block_c8dfR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dfR: // global
           if (R1 & 7 == 1) goto u8dgo; else goto u8dgp;
       u8dgo: // global
           Sp = Sp + 16;
           call _c8dg1() args: 0, res: 0, upd: 0;
       u8dgp: // global
           Sp = Sp + 8;
           call _c8dg5() args: 0, res: 0, upd: 0;
     }
 },
 _c8dg1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dg1: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dg5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dg5: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dg8() //  []
         { info_tbl: [(c8dg8,
                       label: block_c8dg8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dg8: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.931566143 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8di4,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8di4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8di8; else goto c8di9;
       c8di8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8di9: // global
           I64[Sp - 16] = block_c8di1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dk2; else goto c8di2;
       u8dk2: // global
           call _c8di1(R1) args: 0, res: 0, upd: 0;
       c8di2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8di1() //  [R1]
         { info_tbl: [(c8di1,
                       label: block_c8di1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8di1: // global
           I64[Sp - 8] = block_c8di7_info;
           _s8abp::P64 = P64[R1 + 7];
           _s8abq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8abq::P64;
           P64[Sp + 8] = _s8abp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dk1; else goto c8dib;
       u8dk1: // global
           call _c8di7(R1) args: 0, res: 0, upd: 0;
       c8dib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8di7() //  [R1]
         { info_tbl: [(c8di7,
                       label: block_c8di7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8di7: // global
           I64[Sp - 8] = block_c8dif_info;
           _s8abs::P64 = P64[R1 + 7];
           _s8abt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8abt::P64;
           P64[Sp + 16] = _s8abs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dk3; else goto c8dih;
       u8dk3: // global
           call _c8dif(R1) args: 0, res: 0, upd: 0;
       c8dih: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dif() //  [R1]
         { info_tbl: [(c8dif,
                       label: block_c8dif_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dif: // global
           _s8abs::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8dio; else goto c8dj8;
       c8dio: // global
           I64[Sp] = block_c8dil_info;
           R1 = _s8abs::P64;
           if (R1 & 7 != 0) goto u8dk4; else goto c8dip;
       u8dk4: // global
           call _c8dil(R1) args: 0, res: 0, upd: 0;
       c8dip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dj8: // global
           I64[Sp] = block_c8dj6_info;
           R1 = _s8abs::P64;
           if (R1 & 7 != 0) goto u8dk5; else goto c8dj9;
       u8dk5: // global
           call _c8dj6(R1) args: 0, res: 0, upd: 0;
       c8dj9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dil() //  [R1]
         { info_tbl: [(c8dil,
                       label: block_c8dil_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dil: // global
           if (R1 & 7 == 1) goto c8diw; else goto u8djY;
       c8diw: // global
           I64[Sp] = block_c8dit_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8dk6; else goto c8dix;
       u8dk6: // global
           call _c8dit(R1) args: 0, res: 0, upd: 0;
       c8dix: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8djY: // global
           Sp = Sp + 32;
           call _c8djD() args: 0, res: 0, upd: 0;
     }
 },
 _c8dit() //  [R1]
         { info_tbl: [(c8dit,
                       label: block_c8dit_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dit: // global
           _s8abt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8diE; else goto c8diU;
       c8diE: // global
           I64[Sp + 24] = block_c8diB_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dk8; else goto c8diF;
       u8dk8: // global
           call _c8diB(R1) args: 0, res: 0, upd: 0;
       c8diF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8diU: // global
           I64[Sp + 24] = block_c8diS_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dk9; else goto c8diV;
       u8dk9: // global
           call _c8diS() args: 0, res: 0, upd: 0;
       c8diV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8diB() //  [R1]
         { info_tbl: [(c8diB,
                       label: block_c8diB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8diB: // global
           if (R1 & 7 == 1) goto u8djZ; else goto u8dk0;
       u8djZ: // global
           Sp = Sp + 8;
           call _c8djz() args: 0, res: 0, upd: 0;
       u8dk0: // global
           Sp = Sp + 8;
           call _c8djD() args: 0, res: 0, upd: 0;
     }
 },
 _c8diS() //  []
         { info_tbl: [(c8diS,
                       label: block_c8diS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8diS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dj6() //  [R1]
         { info_tbl: [(c8dj6,
                       label: block_c8dj6_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dj6: // global
           if (R1 & 7 == 1) goto u8djV; else goto c8djk;
       u8djV: // global
           Sp = Sp + 32;
           call _c8djz() args: 0, res: 0, upd: 0;
       c8djk: // global
           I64[Sp] = block_c8dji_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8dkc; else goto c8djl;
       u8dkc: // global
           call _c8dji(R1) args: 0, res: 0, upd: 0;
       c8djl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dji() //  [R1]
         { info_tbl: [(c8dji,
                       label: block_c8dji_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dji: // global
           _s8abt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8djs; else goto c8djI;
       c8djs: // global
           I64[Sp + 24] = block_c8djp_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dke; else goto c8djt;
       u8dke: // global
           call _c8djp(R1) args: 0, res: 0, upd: 0;
       c8djt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8djI: // global
           I64[Sp + 24] = block_c8djG_info;
           R1 = _s8abt::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dkf; else goto c8djJ;
       u8dkf: // global
           call _c8djG() args: 0, res: 0, upd: 0;
       c8djJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8djp() //  [R1]
         { info_tbl: [(c8djp,
                       label: block_c8djp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8djp: // global
           if (R1 & 7 == 1) goto u8djW; else goto u8djX;
       u8djW: // global
           Sp = Sp + 8;
           call _c8djz() args: 0, res: 0, upd: 0;
       u8djX: // global
           Sp = Sp + 8;
           call _c8djD() args: 0, res: 0, upd: 0;
     }
 },
 _c8djz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8djz: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8djD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8djD: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8djG() //  []
         { info_tbl: [(c8djG,
                       label: block_c8djG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8djG: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.957890067 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8dlv,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dlv: // global
           _s8abE::P64 = R3;
           R3 = R2;
           R2 = _s8abE::P64;
           call GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.963111748 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8dlJ,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dlJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8dlN; else goto c8dlO;
       c8dlN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dlO: // global
           I64[Sp - 16] = block_c8dlG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dnH; else goto c8dlH;
       u8dnH: // global
           call _c8dlG(R1) args: 0, res: 0, upd: 0;
       c8dlH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dlG() //  [R1]
         { info_tbl: [(c8dlG,
                       label: block_c8dlG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dlG: // global
           I64[Sp - 16] = block_c8dlM_info;
           _s8abH::P64 = R1;
           _s8abI::P64 = P64[R1 + 7];
           _s8abJ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s8abJ::P64;
           P64[Sp] = _s8abI::P64;
           P64[Sp + 8] = _s8abH::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dnG; else goto c8dlQ;
       u8dnG: // global
           call _c8dlM(R1) args: 0, res: 0, upd: 0;
       c8dlQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dlM() //  [R1]
         { info_tbl: [(c8dlM,
                       label: block_c8dlM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dlM: // global
           I64[Sp - 16] = block_c8dlU_info;
           _s8abK::P64 = R1;
           _s8abL::P64 = P64[R1 + 7];
           _s8abM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8abM::P64;
           P64[Sp] = _s8abL::P64;
           P64[Sp + 16] = _s8abK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dnI; else goto c8dlW;
       u8dnI: // global
           call _c8dlU(R1) args: 0, res: 0, upd: 0;
       c8dlW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dlU() //  [R1]
         { info_tbl: [(c8dlU,
                       label: block_c8dlU_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dlU: // global
           _s8abL::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8dm3; else goto c8dmN;
       c8dm3: // global
           I64[Sp] = block_c8dm0_info;
           R1 = _s8abL::P64;
           if (R1 & 7 != 0) goto u8dnJ; else goto c8dm4;
       u8dnJ: // global
           call _c8dm0(R1) args: 0, res: 0, upd: 0;
       c8dm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dmN: // global
           I64[Sp] = block_c8dmL_info;
           R1 = _s8abL::P64;
           if (R1 & 7 != 0) goto u8dnK; else goto c8dmO;
       u8dnK: // global
           call _c8dmL(R1) args: 0, res: 0, upd: 0;
       c8dmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dm0() //  [R1]
         { info_tbl: [(c8dm0,
                       label: block_c8dm0_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dm0: // global
           if (R1 & 7 == 1) goto c8dmb; else goto u8dnD;
       c8dmb: // global
           I64[Sp] = block_c8dm8_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8dnL; else goto c8dmc;
       u8dnL: // global
           call _c8dm8(R1) args: 0, res: 0, upd: 0;
       c8dmc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dnD: // global
           Sp = Sp + 40;
           call _c8dni() args: 0, res: 0, upd: 0;
     }
 },
 _c8dm8() //  [R1]
         { info_tbl: [(c8dm8,
                       label: block_c8dm8_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dm8: // global
           _s8abM::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dmj; else goto c8dmz;
       c8dmj: // global
           I64[Sp + 24] = block_c8dmg_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dnN; else goto c8dmk;
       u8dnN: // global
           call _c8dmg(R1) args: 0, res: 0, upd: 0;
       c8dmk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dmz: // global
           I64[Sp + 24] = block_c8dmx_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dnO; else goto c8dmA;
       u8dnO: // global
           call _c8dmx() args: 0, res: 0, upd: 0;
       c8dmA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dmg() //  [R1]
         { info_tbl: [(c8dmg,
                       label: block_c8dmg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dmg: // global
           if (R1 & 7 == 1) goto u8dnE; else goto u8dnF;
       u8dnE: // global
           Sp = Sp + 8;
           call _c8dne() args: 0, res: 0, upd: 0;
       u8dnF: // global
           Sp = Sp + 16;
           call _c8dni() args: 0, res: 0, upd: 0;
     }
 },
 _c8dmx() //  []
         { info_tbl: [(c8dmx,
                       label: block_c8dmx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dmx: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dmL() //  [R1]
         { info_tbl: [(c8dmL,
                       label: block_c8dmL_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dmL: // global
           if (R1 & 7 == 1) goto u8dnA; else goto c8dmZ;
       u8dnA: // global
           Sp = Sp + 32;
           call _c8dne() args: 0, res: 0, upd: 0;
       c8dmZ: // global
           I64[Sp] = block_c8dmX_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8dnR; else goto c8dn0;
       u8dnR: // global
           call _c8dmX(R1) args: 0, res: 0, upd: 0;
       c8dn0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dmX() //  [R1]
         { info_tbl: [(c8dmX,
                       label: block_c8dmX_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dmX: // global
           _s8abM::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dn7; else goto c8dnn;
       c8dn7: // global
           I64[Sp + 24] = block_c8dn4_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dnT; else goto c8dn8;
       u8dnT: // global
           call _c8dn4(R1) args: 0, res: 0, upd: 0;
       c8dn8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dnn: // global
           I64[Sp + 24] = block_c8dnl_info;
           R1 = _s8abM::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8dnU; else goto c8dno;
       u8dnU: // global
           call _c8dnl() args: 0, res: 0, upd: 0;
       c8dno: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dn4() //  [R1]
         { info_tbl: [(c8dn4,
                       label: block_c8dn4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dn4: // global
           if (R1 & 7 == 1) goto u8dnB; else goto u8dnC;
       u8dnB: // global
           Sp = Sp + 8;
           call _c8dne() args: 0, res: 0, upd: 0;
       u8dnC: // global
           Sp = Sp + 16;
           call _c8dni() args: 0, res: 0, upd: 0;
     }
 },
 _c8dne() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dne: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dni() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dni: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dnl() //  []
         { info_tbl: [(c8dnl,
                       label: block_c8dnl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dnl: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.988705652 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqNewlineMode_closure+1;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.990596737 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode13_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode13_bytes:
         I8[] [78,111,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.992455603 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode12_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode12_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode12_entry() //  [R1]
         { info_tbl: [(c8dpi,
                       label: GHC.IO.Handle.Types.$fReadBufferMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dpi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dpj; else goto c8dpk;
       c8dpj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dpk: // global
           (_c8dpf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8dpf::I64 == 0) goto c8dph; else goto c8dpg;
       c8dph: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8dpg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8dpf::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.996649011 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode6_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode6_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode6_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode6_entry() //  [R2]
         { info_tbl: [(c8dpw,
                       label: GHC.IO.Handle.Types.$fShowBufferMode6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dpw: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode12_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:17.999836443 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode9_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode9_bytes:
         I8[] [76,105,110,101,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.001554658 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode8_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode8_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode8_entry() //  [R1]
         { info_tbl: [(c8dpK,
                       label: GHC.IO.Handle.Types.$fReadBufferMode8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dpK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dpL; else goto c8dpM;
       c8dpL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dpM: // global
           (_c8dpH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8dpH::I64 == 0) goto c8dpJ; else goto c8dpI;
       c8dpJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8dpI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8dpH::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.006127678 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode5_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode5_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode5_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode5_entry() //  [R2]
         { info_tbl: [(c8dpY,
                       label: GHC.IO.Handle.Types.$fShowBufferMode5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dpY: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode8_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.009456218 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowBufferMode4_bytes" {
     GHC.IO.Handle.Types.$fShowBufferMode4_bytes:
         I8[] [66,108,111,99,107,66,117,102,102,101,114,105,110,103,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.011351375 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode3_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode3_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode3_entry() //  [R1]
         { info_tbl: [(c8dqc,
                       label: GHC.IO.Handle.Types.$fShowBufferMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dqc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dqd; else goto c8dqe;
       c8dqd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dqe: // global
           (_c8dq9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8dq9::I64 == 0) goto c8dqb; else goto c8dqa;
       c8dqb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8dqa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8dq9::I64;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.01674621 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_info;
         const 0;
 },
 g_s8ac2_entry() //  [R1]
         { info_tbl: [(c8dqG,
                       label: g_s8ac2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dqG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dqH; else goto c8dqI;
       c8dqH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dqI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 16];
           R3 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R2 = GHC.Show.$fShowInt_closure;
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ac5_entry() //  [R1]
         { info_tbl: [(c8dqV,
                       label: sat_s8ac5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dqV: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ac6_entry() //  [R1, R2]
         { info_tbl: [(c8dqY,
                       label: sat_s8ac6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dqY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8dr2; else goto c8dr1;
       c8dr2: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dr1: // global
           _s8ac2::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s8ac5_info;
           P64[Hp - 8] = _s8ac2::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ac9_entry() //  [R1]
         { info_tbl: [(c8dri,
                       label: sat_s8ac9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dri: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8drm; else goto c8drl;
       c8drm: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8drl: // global
           _s8ac2::P64 = P64[R1 + 16];
           _s8ac7::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s8ac7::P64;
           R2 = Hp - 14;
           R1 = _s8ac2::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8aca_entry() //  [R1]
         { info_tbl: [(c8drn,
                       label: sat_s8aca_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8drn: // global
           _s8aca::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8dro; else goto c8drp;
       c8drp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8drr; else goto c8drq;
       c8drr: // global
           HpAlloc = 32;
           goto c8dro;
       c8dro: // global
           R1 = _s8aca::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8drq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8aca::P64;
           _s8ac2::P64 = P64[_s8aca::P64 + 16];
           _s8ac7::P64 = P64[_s8aca::P64 + 24];
           I64[Hp - 24] = sat_s8ac9_info;
           P64[Hp - 8] = _s8ac2::P64;
           P64[Hp] = _s8ac7::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8acb_entry() //  [R1, R2]
         { info_tbl: [(c8drt,
                       label: sat_s8acb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8drt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8drx; else goto c8drw;
       c8drx: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8drw: // global
           _s8ac2::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s8aca_info;
           P64[Hp - 32] = _s8ac2::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8drD,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8drD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8drE; else goto c8drF;
       c8drE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8drF: // global
           I64[Sp - 16] = block_c8dqq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8drT; else goto c8dqr;
       u8drT: // global
           call _c8dqq(R1) args: 0, res: 0, upd: 0;
       c8dqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dqq() //  [R1]
         { info_tbl: [(c8dqq,
                       label: block_c8dqq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dqq: // global
           _c8drC::P64 = R1 & 7;
           if (_c8drC::P64 < 3) goto u8drR; else goto c8drB;
       u8drR: // global
           if (_c8drC::P64 < 2) goto c8drz; else goto c8drA;
       c8drz: // global
           R1 = GHC.IO.Handle.Types.$fShowBufferMode6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8drA: // global
           R1 = GHC.IO.Handle.Types.$fShowBufferMode5_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8drB: // global
           I64[Sp] = block_c8dqx_info;
           _s8abZ::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8abZ::P64;
           if (R1 & 7 != 0) goto u8drS; else goto c8dqy;
       u8drS: // global
           call _c8dqx(R1) args: 0, res: 0, upd: 0;
       c8dqy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dqx() //  [R1]
         { info_tbl: [(c8dqx,
                       label: block_c8dqx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dqx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8drN; else goto c8drM;
       c8drN: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8drM: // global
           _s8ac1::I64 = I64[R1 + 7];
           I64[Hp - 32] = g_s8ac2_info;
           P64[Hp - 16] = P64[Sp + 8];
           _c8dqC::P64 = Hp - 32;
           if (%MO_S_Lt_W64(_s8ac1::I64, 11)) goto c8drP; else goto c8drQ;
       c8drP: // global
           I64[Hp - 8] = sat_s8ac6_info;
           P64[Hp] = _c8dqC::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8drQ: // global
           I64[Hp - 8] = sat_s8acb_info;
           P64[Hp] = _c8dqC::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.035959002 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode7_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode7_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.039262789 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_info;
         const 0;
 },
 sat_s8acm_entry() //  [R1]
         { info_tbl: [(c8dt6,
                       label: sat_s8acm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dt6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dtc; else goto c8dtd;
       c8dtc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dtd: // global
           I64[Sp - 8] = block_c8dt3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dti; else goto c8dt4;
       u8dti: // global
           call _c8dt3(R1) args: 0, res: 0, upd: 0;
       c8dt4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dt3() //  [R1]
         { info_tbl: [(c8dt3,
                       label: block_c8dt3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dt3: // global
           I64[Sp] = block_c8dt9_info;
           R4 = GHC.IO.Handle.Types.$fShowBufferMode7_closure+2;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8dt9() //  [R1, R2]
         { info_tbl: [(c8dt9,
                       label: block_c8dt9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dt9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8dth; else goto c8dtg;
       c8dth: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8dtg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8acn_entry() //  [R1]
         { info_tbl: [(c8dtj,
                       label: sat_s8acn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dtj: // global
           _s8acn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8dtk; else goto c8dtl;
       c8dtl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8dtn; else goto c8dtm;
       c8dtn: // global
           HpAlloc = 24;
           goto c8dtk;
       c8dtk: // global
           R1 = _s8acn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dtm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8acn::P64;
           _s8acg::P64 = P64[_s8acn::P64 + 16];
           I64[Hp - 16] = sat_s8acm_info;
           P64[Hp] = _s8acg::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8aco_entry() //  [R1]
         { info_tbl: [(c8dts,
                       label: sat_s8aco_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dts: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dtt; else goto c8dtu;
       c8dtt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dtu: // global
           I64[Sp - 8] = block_c8dsP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dtB; else goto c8dsQ;
       u8dtB: // global
           call _c8dsP(R1) args: 0, res: 0, upd: 0;
       c8dsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dsP() //  [R1]
         { info_tbl: [(c8dsP,
                       label: block_c8dsP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dsP: // global
           if (R1 & 7 == 1) goto c8dtp; else goto c8dtq;
       c8dtp: // global
           R1 = GHC.Show.$fShowMaybe4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8dtq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8dtA; else goto c8dtz;
       c8dtA: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8dtz: // global
           _s8acg::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_s8acn_info;
           P64[Hp - 24] = _s8acg::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8dtH,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dtH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dtI; else goto c8dtJ;
       c8dtI: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dtJ: // global
           I64[Sp - 8] = block_c8dsE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dtS; else goto c8dsF;
       u8dtS: // global
           call _c8dsE(R1) args: 0, res: 0, upd: 0;
       c8dsF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dsE() //  [R1]
         { info_tbl: [(c8dsE,
                       label: block_c8dsE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dsE: // global
           _c8dtG::P64 = R1 & 7;
           if (_c8dtG::P64 < 3) goto u8dtR; else goto c8dtF;
       u8dtR: // global
           if (_c8dtG::P64 < 2) goto c8dtD; else goto c8dtE;
       c8dtD: // global
           R1 = GHC.IO.Handle.Types.$fReadBufferMode12_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8dtE: // global
           R1 = GHC.IO.Handle.Types.$fReadBufferMode8_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8dtF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8dtQ; else goto c8dtP;
       c8dtQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8dtP: // global
           _s8ace::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_s8aco_info;
           P64[Hp] = _s8ace::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.057600594 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode1_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode1_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode1_entry() //  [R2]
         { info_tbl: [(c8duC,
                       label: GHC.IO.Handle.Types.$fShowBufferMode1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8duC: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode2_closure+1;
           call GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.061073379 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8duN,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8duN: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.064320032 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure+2;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.066271607 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode11_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode11_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode11_info;
 },
 GHC.IO.Handle.Types.$fReadBufferMode11_entry() //  [R3]
         { info_tbl: [(c8duZ,
                       label: GHC.IO.Handle.Types.$fReadBufferMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8duZ: // global
           R2 = GHC.IO.Handle.Types.NoBuffering_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.069635328 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode10_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode10_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode12_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.07149396 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode7_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode7_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode7_info;
 },
 GHC.IO.Handle.Types.$fReadBufferMode7_entry() //  [R3]
         { info_tbl: [(c8dvb,
                       label: GHC.IO.Handle.Types.$fReadBufferMode7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dvb: // global
           R2 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.074902122 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode6_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode6_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode8_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.07672007 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode5_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode5_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.080542544 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_sps_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_sps_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode10_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.082320916 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode4_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode4_bytes:
         I8[] [66,108,111,99,107,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.084241312 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode3_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode3_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode3_entry() //  [R1]
         { info_tbl: [(c8dvs,
                       label: GHC.IO.Handle.Types.$fReadBufferMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dvs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dvt; else goto c8dvu;
       c8dvt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dvu: // global
           (_c8dvp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8dvp::I64 == 0) goto c8dvr; else goto c8dvq;
       c8dvr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8dvq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8dvp::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.088269743 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.091498787 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode2_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode2_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode2_info;
         const 0;
 },
 ds2_s8acw_entry() //  [R1]
         { info_tbl: [(c8dvL,
                       label: ds2_s8acw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dvL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dvM; else goto c8dvN;
       c8dvM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dvN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadBufferMode_sps_closure+2;
           Sp = Sp - 16;
           call GHC.Read.choose2_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8acF_entry() //  [R1, R2]
         { info_tbl: [(c8dwh,
                       label: sat_s8acF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dwh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8dwl; else goto c8dwk;
       c8dwl: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dwk: // global
           _s8acx::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.IO.Handle.Types.BlockBuffering_con_info;
           P64[Hp] = R2;
           R2 = Hp - 5;
           R1 = _s8acx::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8acG_entry() //  [R1, R2]
         { info_tbl: [(c8dwm,
                       label: sat_s8acG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dwm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8dwq; else goto c8dwp;
       c8dwq: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dwp: // global
           _s8acx::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8acF_info;
           P64[Hp] = _s8acx::P64;
           R4 = Hp - 7;
           R3 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R2 = GHC.Read.$fReadInt_closure;
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8acJ_entry() //  [R1]
         { info_tbl: [(c8dwr,
                       label: sat_s8acJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dwr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8dws; else goto c8dwt;
       c8dws: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dwt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8dvX_info;
           _s8acx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8acx::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8dwG; else goto c8dvY;
       u8dwG: // global
           call _c8dvX(R1) args: 0, res: 0, upd: 0;
       c8dvY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8dvX() //  [R1]
         { info_tbl: [(c8dvX,
                       label: block_c8dvX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dvX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8dww; else goto c8dwv;
       c8dww: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8dwv: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto c8dwy; else goto c8dwC;
       c8dwy: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8dwC: // global
           I64[Hp - 8] = sat_s8acG_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8dwz_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8dwz() //  [R1]
         { info_tbl: [(c8dwz,
                       label: block_c8dwz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dwz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8dwF; else goto c8dwE;
       c8dwF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8dwE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8acK_entry() //  [R1, R2]
         { info_tbl: [(c8dwJ,
                       label: sat_s8acK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dwJ: // global
           _s8acx::P64 = R2;
           _s8acK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8dwK; else goto c8dwL;
       c8dwL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8dwN; else goto c8dwM;
       c8dwN: // global
           HpAlloc = 32;
           goto c8dwK;
       c8dwK: // global
           R2 = _s8acx::P64;
           R1 = _s8acK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dwM: // global
           _s8acv::P64 = P64[_s8acK::P64 + 7];
           _s8acw::P64 = P64[_s8acK::P64 + 15];
           I64[Hp - 24] = sat_s8acJ_info;
           P64[Hp - 8] = _s8acv::P64;
           P64[Hp] = _s8acx::P64;
           I64[Sp - 16] = block_c8dwH_info;
           R2 = _s8acx::P64;
           R1 = _s8acw::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dwH() //  [R1]
         { info_tbl: [(c8dwH,
                       label: block_c8dwH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dwH: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u8dwW_srtd" {
     u8dwW_srtd:
         const S8alj_srt+216;
         const 33;
         const 8522825729;
 },
 GHC.IO.Handle.Types.$fReadBufferMode2_entry() //  [R2]
         { info_tbl: [(c8dwR,
                       label: GHC.IO.Handle.Types.$fReadBufferMode2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dwR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8dwV; else goto c8dwU;
       c8dwV: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dwU: // global
           I64[Hp - 40] = ds2_s8acw_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8acK_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.113381453 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode1_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode1_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode1_info;
         const 0;
 },
 section ""relreadonly" . u8dxH_srtd" {
     u8dxH_srtd:
         const S8alj_srt+160;
         const 40;
         const 549755813889;
 },
 GHC.IO.Handle.Types.$fReadBufferMode1_entry() //  [R2, R3]
         { info_tbl: [(c8dxE,
                       label: GHC.IO.Handle.Types.$fReadBufferMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dxE: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.118599219 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_info;
         const 0;
 },
 section ""relreadonly" . u8dy3_srtd" {
     u8dy3_srtd:
         const S8alj_srt+160;
         const 40;
         const 549755813889;
 },
 sat_s8acM_entry() //  [R1]
         { info_tbl: [(c8dxV,
                       label: sat_s8acM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dxV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dxW; else goto c8dxX;
       c8dxW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dxX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadBufferMode2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u8dy4_srtd" {
     u8dy4_srtd:
         const S8alj_srt+160;
         const 41;
         const 1649267441665;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8dxY,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dxY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8dy2; else goto c8dy1;
       c8dy2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dy1: // global
           I64[Hp - 16] = sat_s8acM_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.12573621 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8dyl,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dyl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dym; else goto c8dyn;
       c8dym: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dyn: // global
           (_c8dyi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8dyi::I64 == 0) goto c8dyk; else goto c8dyj;
       c8dyk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8dyj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8dyi::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.129970383 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode14_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode14_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode14_entry() //  [R1]
         { info_tbl: [(c8dyB,
                       label: GHC.IO.Handle.Types.$fReadBufferMode14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dyB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dyC; else goto c8dyD;
       c8dyC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8dyD: // global
           (_c8dyy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8dyy::I64 == 0) goto c8dyA; else goto c8dyz;
       c8dyA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8dyz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8dyy::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.134109453 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadList_entry() //  [R2]
         { info_tbl: [(c8dyP,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dyP: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode14_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.137984043 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode1_closure+2;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.140940942 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8dz9,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dz9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dza; else goto c8dzb;
       c8dza: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dzb: // global
           I64[Sp - 16] = block_c8dz1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dAN; else goto c8dz2;
       u8dAN: // global
           call _c8dz1(R1) args: 0, res: 0, upd: 0;
       c8dz2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dz1() //  [R1]
         { info_tbl: [(c8dz1,
                       label: block_c8dz1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dz1: // global
           _s8acO::P64 = P64[Sp + 8];
           _c8dz8::P64 = R1 & 7;
           if (_c8dz8::P64 < 3) goto u8dAB; else goto c8dz7;
       u8dAB: // global
           if (_c8dz8::P64 < 2) goto c8dz5; else goto c8dz6;
       c8dz5: // global
           I64[Sp + 8] = block_c8dze_info;
           R1 = _s8acO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dAK; else goto c8dzg;
       u8dAK: // global
           call _c8dze(R1) args: 0, res: 0, upd: 0;
       c8dzg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dz6: // global
           I64[Sp + 8] = block_c8dzt_info;
           R1 = _s8acO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dAL; else goto c8dzv;
       u8dAL: // global
           call _c8dzt(R1) args: 0, res: 0, upd: 0;
       c8dzv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dz7: // global
           I64[Sp] = block_c8dzI_info;
           _s8acT::P64 = P64[R1 + 5];
           R1 = _s8acO::P64;
           P64[Sp + 8] = _s8acT::P64;
           if (R1 & 7 != 0) goto u8dAM; else goto c8dzK;
       u8dAM: // global
           call _c8dzI(R1) args: 0, res: 0, upd: 0;
       c8dzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dze() //  [R1]
         { info_tbl: [(c8dze,
                       label: block_c8dze_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dze: // global
           if (R1 & 7 == 1) goto u8dAC; else goto u8dAD;
       u8dAC: // global
           Sp = Sp + 8;
           call _c8dAq() args: 0, res: 0, upd: 0;
       u8dAD: // global
           Sp = Sp + 8;
           call _c8dAe() args: 0, res: 0, upd: 0;
     }
 },
 _c8dzt() //  [R1]
         { info_tbl: [(c8dzt,
                       label: block_c8dzt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dzt: // global
           if (R1 & 7 == 3) goto u8dAE; else goto u8dAF;
       u8dAE: // global
           Sp = Sp + 8;
           call _c8dAe() args: 0, res: 0, upd: 0;
       u8dAF: // global
           Sp = Sp + 8;
           call _c8dAq() args: 0, res: 0, upd: 0;
     }
 },
 _c8dzI() //  [R1]
         { info_tbl: [(c8dzI,
                       label: block_c8dzI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dzI: // global
           if (R1 & 7 == 3) goto c8dzV; else goto u8dAG;
       c8dzV: // global
           I64[Sp] = block_c8dzT_info;
           _s8acV::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8acV::P64;
           if (R1 & 7 != 0) goto u8dAS; else goto c8dzW;
       u8dAS: // global
           call _c8dzT(R1) args: 0, res: 0, upd: 0;
       c8dzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dAG: // global
           Sp = Sp + 16;
           call _c8dAq() args: 0, res: 0, upd: 0;
     }
 },
 _c8dzT() //  [R1]
         { info_tbl: [(c8dzT,
                       label: block_c8dzT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dzT: // global
           _s8acV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dA3; else goto c8dAj;
       c8dA3: // global
           I64[Sp + 8] = block_c8dA0_info;
           R1 = _s8acV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dAU; else goto c8dA4;
       u8dAU: // global
           call _c8dA0(R1) args: 0, res: 0, upd: 0;
       c8dA4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dAj: // global
           I64[Sp] = block_c8dAh_info;
           _s8acZ::P64 = P64[R1 + 6];
           R1 = _s8acV::P64;
           P64[Sp + 8] = _s8acZ::P64;
           if (R1 & 7 != 0) goto u8dAV; else goto c8dAk;
       u8dAV: // global
           call _c8dAh(R1) args: 0, res: 0, upd: 0;
       c8dAk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dA0() //  [R1]
         { info_tbl: [(c8dA0,
                       label: block_c8dA0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dA0: // global
           if (R1 & 7 == 1) goto u8dAI; else goto u8dAJ;
       u8dAI: // global
           Sp = Sp + 8;
           call _c8dAq() args: 0, res: 0, upd: 0;
       u8dAJ: // global
           Sp = Sp + 8;
           call _c8dAe() args: 0, res: 0, upd: 0;
     }
 },
 _c8dAe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dAe: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dAh() //  [R1]
         { info_tbl: [(c8dAh,
                       label: block_c8dAh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dAh: // global
           if (R1 & 7 == 1) goto u8dAH; else goto c8dAu;
       u8dAH: // global
           Sp = Sp + 16;
           call _c8dAq() args: 0, res: 0, upd: 0;
       c8dAu: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.ltInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8dAq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dAq: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.161823177 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8dC1,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dC1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dC2; else goto c8dC3;
       c8dC2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dC3: // global
           I64[Sp - 16] = block_c8dBT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dDL; else goto c8dBU;
       u8dDL: // global
           call _c8dBT(R1) args: 0, res: 0, upd: 0;
       c8dBU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dBT() //  [R1]
         { info_tbl: [(c8dBT,
                       label: block_c8dBT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dBT: // global
           _s8ad3::P64 = P64[Sp + 8];
           _c8dC0::P64 = R1 & 7;
           if (_c8dC0::P64 < 3) goto u8dDx; else goto c8dBZ;
       u8dDx: // global
           if (_c8dC0::P64 < 2) goto c8dBX; else goto c8dBY;
       c8dBX: // global
           I64[Sp + 8] = block_c8dC6_info;
           R1 = _s8ad3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dDI; else goto c8dC8;
       u8dDI: // global
           call _c8dC6(R1) args: 0, res: 0, upd: 0;
       c8dC8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dBY: // global
           I64[Sp + 8] = block_c8dCl_info;
           R1 = _s8ad3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dDJ; else goto c8dCn;
       u8dDJ: // global
           call _c8dCl(R1) args: 0, res: 0, upd: 0;
       c8dCn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dBZ: // global
           I64[Sp] = block_c8dCE_info;
           _s8ad8::P64 = P64[R1 + 5];
           R1 = _s8ad3::P64;
           P64[Sp + 8] = _s8ad8::P64;
           if (R1 & 7 != 0) goto u8dDK; else goto c8dCG;
       u8dDK: // global
           call _c8dCE(R1) args: 0, res: 0, upd: 0;
       c8dCG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dC6() //  [R1]
         { info_tbl: [(c8dC6,
                       label: block_c8dC6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dC6: // global
           if (R1 & 7 == 1) goto u8dDz; else goto u8dDA;
       u8dDz: // global
           Sp = Sp + 8;
           call _c8dD6() args: 0, res: 0, upd: 0;
       u8dDA: // global
           Sp = Sp + 8;
           call _c8dDa() args: 0, res: 0, upd: 0;
     }
 },
 _c8dCl() //  [R1]
         { info_tbl: [(c8dCl,
                       label: block_c8dCl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dCl: // global
           _c8dDv::P64 = R1 & 7;
           if (_c8dDv::P64 < 3) goto u8dDy; else goto u8dDB;
       u8dDy: // global
           if (_c8dDv::P64 < 2) goto u8dDD; else goto u8dDC;
       u8dDD: // global
           Sp = Sp + 8;
           call _c8dDm() args: 0, res: 0, upd: 0;
       u8dDC: // global
           Sp = Sp + 8;
           call _c8dD6() args: 0, res: 0, upd: 0;
       u8dDB: // global
           Sp = Sp + 8;
           call _c8dDa() args: 0, res: 0, upd: 0;
     }
 },
 _c8dCE() //  [R1]
         { info_tbl: [(c8dCE,
                       label: block_c8dCE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dCE: // global
           if (R1 & 7 == 3) goto c8dCR; else goto u8dDE;
       c8dCR: // global
           I64[Sp] = block_c8dCP_info;
           _s8ada::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ada::P64;
           if (R1 & 7 != 0) goto u8dDR; else goto c8dCS;
       u8dDR: // global
           call _c8dCP(R1) args: 0, res: 0, upd: 0;
       c8dCS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dDE: // global
           Sp = Sp + 16;
           call _c8dDm() args: 0, res: 0, upd: 0;
     }
 },
 _c8dCP() //  [R1]
         { info_tbl: [(c8dCP,
                       label: block_c8dCP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dCP: // global
           _s8ada::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dCZ; else goto c8dDf;
       c8dCZ: // global
           I64[Sp + 8] = block_c8dCW_info;
           R1 = _s8ada::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dDT; else goto c8dD0;
       u8dDT: // global
           call _c8dCW(R1) args: 0, res: 0, upd: 0;
       c8dD0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dDf: // global
           I64[Sp] = block_c8dDd_info;
           _s8ade::P64 = P64[R1 + 6];
           R1 = _s8ada::P64;
           P64[Sp + 8] = _s8ade::P64;
           if (R1 & 7 != 0) goto u8dDU; else goto c8dDg;
       u8dDU: // global
           call _c8dDd(R1) args: 0, res: 0, upd: 0;
       c8dDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dCW() //  [R1]
         { info_tbl: [(c8dCW,
                       label: block_c8dCW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dCW: // global
           if (R1 & 7 == 1) goto u8dDG; else goto u8dDH;
       u8dDG: // global
           Sp = Sp + 8;
           call _c8dD6() args: 0, res: 0, upd: 0;
       u8dDH: // global
           Sp = Sp + 8;
           call _c8dDa() args: 0, res: 0, upd: 0;
     }
 },
 _c8dD6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dD6: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dDa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dDa: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dDd() //  [R1]
         { info_tbl: [(c8dDd,
                       label: block_c8dDd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dDd: // global
           if (R1 & 7 == 1) goto u8dDF; else goto c8dDq;
       u8dDF: // global
           Sp = Sp + 16;
           call _c8dDm() args: 0, res: 0, upd: 0;
       c8dDq: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.compareInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8dDm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dDm: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.182938405 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure:
         const GHC.IO.Handle.Types.$fEqBufferMode_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqBufferMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8dF2,
                       label: GHC.IO.Handle.Types.$fEqBufferMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dF2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dF3; else goto c8dF4;
       c8dF3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dF4: // global
           I64[Sp - 16] = block_c8dEU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dGG; else goto c8dEV;
       u8dGG: // global
           call _c8dEU(R1) args: 0, res: 0, upd: 0;
       c8dEV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dEU() //  [R1]
         { info_tbl: [(c8dEU,
                       label: block_c8dEU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dEU: // global
           _s8adi::P64 = P64[Sp + 8];
           _c8dF1::P64 = R1 & 7;
           if (_c8dF1::P64 < 3) goto u8dGu; else goto c8dF0;
       u8dGu: // global
           if (_c8dF1::P64 < 2) goto c8dEY; else goto c8dEZ;
       c8dEY: // global
           I64[Sp + 8] = block_c8dF7_info;
           R1 = _s8adi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dGD; else goto c8dF9;
       u8dGD: // global
           call _c8dF7(R1) args: 0, res: 0, upd: 0;
       c8dF9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dEZ: // global
           I64[Sp + 8] = block_c8dFm_info;
           R1 = _s8adi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dGE; else goto c8dFo;
       u8dGE: // global
           call _c8dFm(R1) args: 0, res: 0, upd: 0;
       c8dFo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dF0: // global
           I64[Sp] = block_c8dFB_info;
           _s8adm::P64 = P64[R1 + 5];
           R1 = _s8adi::P64;
           P64[Sp + 8] = _s8adm::P64;
           if (R1 & 7 != 0) goto u8dGF; else goto c8dFD;
       u8dGF: // global
           call _c8dFB(R1) args: 0, res: 0, upd: 0;
       c8dFD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dF7() //  [R1]
         { info_tbl: [(c8dF7,
                       label: block_c8dF7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dF7: // global
           if (R1 & 7 == 1) goto u8dGv; else goto u8dGw;
       u8dGv: // global
           Sp = Sp + 8;
           call _c8dG3() args: 0, res: 0, upd: 0;
       u8dGw: // global
           Sp = Sp + 8;
           call _c8dGj() args: 0, res: 0, upd: 0;
     }
 },
 _c8dFm() //  [R1]
         { info_tbl: [(c8dFm,
                       label: block_c8dFm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dFm: // global
           if (R1 & 7 == 2) goto u8dGx; else goto u8dGy;
       u8dGx: // global
           Sp = Sp + 8;
           call _c8dG3() args: 0, res: 0, upd: 0;
       u8dGy: // global
           Sp = Sp + 8;
           call _c8dGj() args: 0, res: 0, upd: 0;
     }
 },
 _c8dFB() //  [R1]
         { info_tbl: [(c8dFB,
                       label: block_c8dFB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dFB: // global
           if (R1 & 7 == 3) goto c8dFO; else goto u8dGz;
       c8dFO: // global
           I64[Sp] = block_c8dFM_info;
           _s8ado::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ado::P64;
           if (R1 & 7 != 0) goto u8dGL; else goto c8dFP;
       u8dGL: // global
           call _c8dFM(R1) args: 0, res: 0, upd: 0;
       c8dFP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dGz: // global
           Sp = Sp + 16;
           call _c8dGj() args: 0, res: 0, upd: 0;
     }
 },
 _c8dFM() //  [R1]
         { info_tbl: [(c8dFM,
                       label: block_c8dFM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dFM: // global
           _s8ado::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dFW; else goto c8dGc;
       c8dFW: // global
           I64[Sp + 8] = block_c8dFT_info;
           R1 = _s8ado::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dGN; else goto c8dFX;
       u8dGN: // global
           call _c8dFT(R1) args: 0, res: 0, upd: 0;
       c8dFX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dGc: // global
           I64[Sp] = block_c8dGa_info;
           _s8ads::P64 = P64[R1 + 6];
           R1 = _s8ado::P64;
           P64[Sp + 8] = _s8ads::P64;
           if (R1 & 7 != 0) goto u8dGO; else goto c8dGd;
       u8dGO: // global
           call _c8dGa(R1) args: 0, res: 0, upd: 0;
       c8dGd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dFT() //  [R1]
         { info_tbl: [(c8dFT,
                       label: block_c8dFT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dFT: // global
           if (R1 & 7 == 1) goto u8dGB; else goto u8dGC;
       u8dGB: // global
           Sp = Sp + 8;
           call _c8dG3() args: 0, res: 0, upd: 0;
       u8dGC: // global
           Sp = Sp + 8;
           call _c8dGj() args: 0, res: 0, upd: 0;
     }
 },
 _c8dG3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dG3: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dGa() //  [R1]
         { info_tbl: [(c8dGa,
                       label: block_c8dGa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dGa: // global
           if (R1 & 7 == 1) goto u8dGA; else goto c8dGn;
       u8dGA: // global
           Sp = Sp + 16;
           call _c8dGj() args: 0, res: 0, upd: 0;
       c8dGn: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.eqInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8dGj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dGj: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.20370426 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqBufferMode_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqBufferMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8dHU,
                       label: GHC.IO.Handle.Types.$fEqBufferMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dHU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dHV; else goto c8dHW;
       c8dHV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dHW: // global
           I64[Sp - 16] = block_c8dHM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dJR; else goto c8dHN;
       u8dJR: // global
           call _c8dHM(R1) args: 0, res: 0, upd: 0;
       c8dHN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dHM() //  [R1]
         { info_tbl: [(c8dHM,
                       label: block_c8dHM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dHM: // global
           _s8adw::P64 = P64[Sp + 8];
           _c8dHT::P64 = R1 & 7;
           if (_c8dHT::P64 < 3) goto u8dJD; else goto c8dHS;
       u8dJD: // global
           if (_c8dHT::P64 < 2) goto c8dHQ; else goto c8dHR;
       c8dHQ: // global
           I64[Sp + 8] = block_c8dHZ_info;
           R1 = _s8adw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dJO; else goto c8dI1;
       u8dJO: // global
           call _c8dHZ(R1) args: 0, res: 0, upd: 0;
       c8dI1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dHR: // global
           I64[Sp + 8] = block_c8dIe_info;
           R1 = _s8adw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dJP; else goto c8dIg;
       u8dJP: // global
           call _c8dIe(R1) args: 0, res: 0, upd: 0;
       c8dIg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dHS: // global
           I64[Sp] = block_c8dIt_info;
           _s8adA::P64 = P64[R1 + 5];
           R1 = _s8adw::P64;
           P64[Sp + 8] = _s8adA::P64;
           if (R1 & 7 != 0) goto u8dJQ; else goto c8dIv;
       u8dJQ: // global
           call _c8dIt(R1) args: 0, res: 0, upd: 0;
       c8dIv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dHZ() //  [R1]
         { info_tbl: [(c8dHZ,
                       label: block_c8dHZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dHZ: // global
           if (R1 & 7 == 1) goto u8dJE; else goto u8dJF;
       u8dJE: // global
           Sp = Sp + 8;
           call _c8dJw() args: 0, res: 0, upd: 0;
       u8dJF: // global
           Sp = Sp + 8;
           call _c8dJv() args: 0, res: 0, upd: 0;
     }
 },
 _c8dIe() //  [R1]
         { info_tbl: [(c8dIe,
                       label: block_c8dIe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dIe: // global
           if (R1 & 7 == 2) goto u8dJG; else goto u8dJH;
       u8dJG: // global
           Sp = Sp + 8;
           call _c8dJw() args: 0, res: 0, upd: 0;
       u8dJH: // global
           Sp = Sp + 8;
           call _c8dJv() args: 0, res: 0, upd: 0;
     }
 },
 _c8dIt() //  [R1]
         { info_tbl: [(c8dIt,
                       label: block_c8dIt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dIt: // global
           if (R1 & 7 == 3) goto c8dIG; else goto u8dJI;
       c8dIG: // global
           I64[Sp] = block_c8dIE_info;
           _s8adC::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8adC::P64;
           if (R1 & 7 != 0) goto u8dJW; else goto c8dIH;
       u8dJW: // global
           call _c8dIE(R1) args: 0, res: 0, upd: 0;
       c8dIH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dJI: // global
           Sp = Sp + 16;
           call _c8dJv() args: 0, res: 0, upd: 0;
     }
 },
 _c8dIE() //  [R1]
         { info_tbl: [(c8dIE,
                       label: block_c8dIE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dIE: // global
           _s8adC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dIO; else goto c8dJ4;
       c8dIO: // global
           I64[Sp + 8] = block_c8dIL_info;
           R1 = _s8adC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dJY; else goto c8dIP;
       u8dJY: // global
           call _c8dIL(R1) args: 0, res: 0, upd: 0;
       c8dIP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dJ4: // global
           I64[Sp] = block_c8dJ2_info;
           _s8adG::P64 = P64[R1 + 6];
           R1 = _s8adC::P64;
           P64[Sp + 8] = _s8adG::P64;
           if (R1 & 7 != 0) goto u8dJZ; else goto c8dJ5;
       u8dJZ: // global
           call _c8dJ2(R1) args: 0, res: 0, upd: 0;
       c8dJ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dIL() //  [R1]
         { info_tbl: [(c8dIL,
                       label: block_c8dIL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dIL: // global
           if (R1 & 7 == 1) goto u8dJM; else goto u8dJN;
       u8dJM: // global
           Sp = Sp + 8;
           call _c8dJw() args: 0, res: 0, upd: 0;
       u8dJN: // global
           Sp = Sp + 8;
           call _c8dJv() args: 0, res: 0, upd: 0;
     }
 },
 _c8dJ2() //  [R1]
         { info_tbl: [(c8dJ2,
                       label: block_c8dJ2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dJ2: // global
           if (R1 & 7 == 1) goto u8dJJ; else goto c8dJl;
       u8dJJ: // global
           Sp = Sp + 16;
           call _c8dJv() args: 0, res: 0, upd: 0;
       c8dJl: // global
           I64[Sp] = block_c8dJe_info;
           _s8adI::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8adI::P64;
           if (R1 & 7 != 0) goto u8dK2; else goto c8dJf;
       u8dK2: // global
           call _c8dJe(R1) args: 0, res: 0, upd: 0;
       c8dJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dJe() //  [R1]
         { info_tbl: [(c8dJe,
                       label: block_c8dJe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dJe: // global
           I64[Sp] = block_c8dJj_info;
           _s8adK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8adK::I64;
           if (R1 & 7 != 0) goto u8dK4; else goto c8dJn;
       u8dK4: // global
           call _c8dJj(R1) args: 0, res: 0, upd: 0;
       c8dJn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dJj() //  [R1]
         { info_tbl: [(c8dJj,
                       label: block_c8dJj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dJj: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u8dJK; else goto u8dJL;
       u8dJK: // global
           Sp = Sp + 16;
           call _c8dJw() args: 0, res: 0, upd: 0;
       u8dJL: // global
           Sp = Sp + 16;
           call _c8dJv() args: 0, res: 0, upd: 0;
     }
 },
 _c8dJw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dJw: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dJv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dJv: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.226119118 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.229512996 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8dLj,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dLj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dLk; else goto c8dLl;
       c8dLk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dLl: // global
           I64[Sp - 16] = block_c8dLb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dNg; else goto c8dLc;
       u8dNg: // global
           call _c8dLb(R1) args: 0, res: 0, upd: 0;
       c8dLc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dLb() //  [R1]
         { info_tbl: [(c8dLb,
                       label: block_c8dLb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dLb: // global
           _s8adO::P64 = P64[Sp + 8];
           _c8dLi::P64 = R1 & 7;
           if (_c8dLi::P64 < 3) goto u8dN2; else goto c8dLh;
       u8dN2: // global
           if (_c8dLi::P64 < 2) goto c8dLf; else goto c8dLg;
       c8dLf: // global
           I64[Sp + 8] = block_c8dLo_info;
           R1 = _s8adO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dNd; else goto c8dLq;
       u8dNd: // global
           call _c8dLo(R1) args: 0, res: 0, upd: 0;
       c8dLq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dLg: // global
           I64[Sp + 8] = block_c8dLD_info;
           R1 = _s8adO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dNe; else goto c8dLF;
       u8dNe: // global
           call _c8dLD(R1) args: 0, res: 0, upd: 0;
       c8dLF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dLh: // global
           I64[Sp] = block_c8dLS_info;
           _s8adU::P64 = P64[R1 + 5];
           R1 = _s8adO::P64;
           P64[Sp + 8] = _s8adU::P64;
           if (R1 & 7 != 0) goto u8dNf; else goto c8dLU;
       u8dNf: // global
           call _c8dLS(R1) args: 0, res: 0, upd: 0;
       c8dLU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dLo() //  [R1]
         { info_tbl: [(c8dLo,
                       label: block_c8dLo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dLo: // global
           if (R1 & 7 == 1) goto u8dN3; else goto u8dN4;
       u8dN3: // global
           Sp = Sp + 8;
           call _c8dMU() args: 0, res: 0, upd: 0;
       u8dN4: // global
           Sp = Sp + 8;
           call _c8dMV() args: 0, res: 0, upd: 0;
     }
 },
 _c8dLD() //  [R1]
         { info_tbl: [(c8dLD,
                       label: block_c8dLD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dLD: // global
           if (R1 & 7 == 3) goto u8dN5; else goto u8dN6;
       u8dN5: // global
           Sp = Sp + 8;
           call _c8dMV() args: 0, res: 0, upd: 0;
       u8dN6: // global
           Sp = Sp + 8;
           call _c8dMU() args: 0, res: 0, upd: 0;
     }
 },
 _c8dLS() //  [R1]
         { info_tbl: [(c8dLS,
                       label: block_c8dLS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dLS: // global
           if (R1 & 7 == 3) goto c8dM5; else goto u8dN7;
       c8dM5: // global
           I64[Sp] = block_c8dM3_info;
           _s8adW::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8adW::P64;
           if (R1 & 7 != 0) goto u8dNl; else goto c8dM6;
       u8dNl: // global
           call _c8dM3(R1) args: 0, res: 0, upd: 0;
       c8dM6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dN7: // global
           Sp = Sp + 16;
           call _c8dMU() args: 0, res: 0, upd: 0;
     }
 },
 _c8dM3() //  [R1]
         { info_tbl: [(c8dM3,
                       label: block_c8dM3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dM3: // global
           _s8adW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dMd; else goto c8dMt;
       c8dMd: // global
           I64[Sp + 8] = block_c8dMa_info;
           R1 = _s8adW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dNn; else goto c8dMe;
       u8dNn: // global
           call _c8dMa(R1) args: 0, res: 0, upd: 0;
       c8dMe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dMt: // global
           I64[Sp] = block_c8dMr_info;
           _s8ae0::P64 = P64[R1 + 6];
           R1 = _s8adW::P64;
           P64[Sp + 8] = _s8ae0::P64;
           if (R1 & 7 != 0) goto u8dNo; else goto c8dMu;
       u8dNo: // global
           call _c8dMr(R1) args: 0, res: 0, upd: 0;
       c8dMu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dMa() //  [R1]
         { info_tbl: [(c8dMa,
                       label: block_c8dMa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dMa: // global
           if (R1 & 7 == 1) goto u8dNb; else goto u8dNc;
       u8dNb: // global
           Sp = Sp + 8;
           call _c8dMU() args: 0, res: 0, upd: 0;
       u8dNc: // global
           Sp = Sp + 8;
           call _c8dMV() args: 0, res: 0, upd: 0;
     }
 },
 _c8dMr() //  [R1]
         { info_tbl: [(c8dMr,
                       label: block_c8dMr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dMr: // global
           if (R1 & 7 == 1) goto u8dN8; else goto c8dMK;
       u8dN8: // global
           Sp = Sp + 16;
           call _c8dMU() args: 0, res: 0, upd: 0;
       c8dMK: // global
           I64[Sp] = block_c8dMD_info;
           _s8ae2::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ae2::P64;
           if (R1 & 7 != 0) goto u8dNr; else goto c8dME;
       u8dNr: // global
           call _c8dMD(R1) args: 0, res: 0, upd: 0;
       c8dME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dMD() //  [R1]
         { info_tbl: [(c8dMD,
                       label: block_c8dMD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dMD: // global
           I64[Sp] = block_c8dMI_info;
           _s8ae4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ae4::I64;
           if (R1 & 7 != 0) goto u8dNt; else goto c8dMM;
       u8dNt: // global
           call _c8dMI(R1) args: 0, res: 0, upd: 0;
       c8dMM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dMI() //  [R1]
         { info_tbl: [(c8dMI,
                       label: block_c8dMI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dMI: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8dNa; else goto u8dN9;
       u8dNa: // global
           Sp = Sp + 16;
           call _c8dMU() args: 0, res: 0, upd: 0;
       u8dN9: // global
           Sp = Sp + 16;
           call _c8dMV() args: 0, res: 0, upd: 0;
     }
 },
 _c8dMV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dMV: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dMU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dMU: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.253830324 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8dOH,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dOH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8dOI; else goto c8dOJ;
       c8dOI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dOJ: // global
           I64[Sp - 16] = block_c8dOz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dQm; else goto c8dOA;
       u8dQm: // global
           call _c8dOz(R1) args: 0, res: 0, upd: 0;
       c8dOA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dOz() //  [R1]
         { info_tbl: [(c8dOz,
                       label: block_c8dOz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dOz: // global
           _s8ae8::P64 = P64[Sp + 8];
           _c8dOG::P64 = R1 & 7;
           if (_c8dOG::P64 < 3) goto u8dQd; else goto c8dOF;
       u8dQd: // global
           if (_c8dOG::P64 < 2) goto c8dOD; else goto c8dOE;
       c8dOD: // global
           R1 = _s8ae8::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8dOE: // global
           I64[Sp + 8] = block_c8dOP_info;
           R1 = _s8ae8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dQk; else goto c8dOR;
       u8dQk: // global
           call _c8dOP(R1) args: 0, res: 0, upd: 0;
       c8dOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dOF: // global
           I64[Sp - 8] = block_c8dP4_info;
           _s8aea::P64 = R1;
           _s8aed::P64 = P64[R1 + 5];
           R1 = _s8ae8::P64;
           P64[Sp] = _s8aed::P64;
           P64[Sp + 8] = _s8aea::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dQl; else goto c8dP6;
       u8dQl: // global
           call _c8dP4(R1) args: 0, res: 0, upd: 0;
       c8dP6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dOP() //  [R1]
         { info_tbl: [(c8dOP,
                       label: block_c8dOP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dOP: // global
           if (R1 & 7 == 3) goto c8dP1; else goto c8dOX;
       c8dP1: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8dOX: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dP4() //  [R1]
         { info_tbl: [(c8dP4,
                       label: block_c8dP4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dP4: // global
           if (R1 & 7 == 3) goto c8dPh; else goto u8dQe;
       c8dPh: // global
           I64[Sp - 8] = block_c8dPf_info;
           _s8aee::P64 = R1;
           _s8aef::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aef::P64;
           P64[Sp + 8] = _s8aee::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dQn; else goto c8dPi;
       u8dQn: // global
           call _c8dPf(R1) args: 0, res: 0, upd: 0;
       c8dPi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dQe: // global
           Sp = Sp + 16;
           call _c8dQ6() args: 0, res: 0, upd: 0;
     }
 },
 _c8dPf() //  [R1]
         { info_tbl: [(c8dPf,
                       label: block_c8dPf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dPf: // global
           _s8aef::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dPp; else goto c8dPF;
       c8dPp: // global
           I64[Sp + 8] = block_c8dPm_info;
           R1 = _s8aef::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dQp; else goto c8dPq;
       u8dQp: // global
           call _c8dPm(R1) args: 0, res: 0, upd: 0;
       c8dPq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dPF: // global
           I64[Sp] = block_c8dPD_info;
           _s8aej::P64 = P64[R1 + 6];
           R1 = _s8aef::P64;
           P64[Sp + 8] = _s8aej::P64;
           if (R1 & 7 != 0) goto u8dQq; else goto c8dPG;
       u8dQq: // global
           call _c8dPD(R1) args: 0, res: 0, upd: 0;
       c8dPG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dPm() //  [R1]
         { info_tbl: [(c8dPm,
                       label: block_c8dPm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dPm: // global
           if (R1 & 7 == 1) goto u8dQi; else goto u8dQj;
       u8dQi: // global
           Sp = Sp + 16;
           call _c8dQ6() args: 0, res: 0, upd: 0;
       u8dQj: // global
           Sp = Sp + 8;
           call _c8dQ7() args: 0, res: 0, upd: 0;
     }
 },
 _c8dPD() //  [R1]
         { info_tbl: [(c8dPD,
                       label: block_c8dPD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dPD: // global
           if (R1 & 7 == 1) goto u8dQf; else goto c8dPW;
       u8dQf: // global
           Sp = Sp + 24;
           call _c8dQ6() args: 0, res: 0, upd: 0;
       c8dPW: // global
           I64[Sp] = block_c8dPP_info;
           _s8ael::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ael::P64;
           if (R1 & 7 != 0) goto u8dQt; else goto c8dPQ;
       u8dQt: // global
           call _c8dPP(R1) args: 0, res: 0, upd: 0;
       c8dPQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dPP() //  [R1]
         { info_tbl: [(c8dPP,
                       label: block_c8dPP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dPP: // global
           I64[Sp] = block_c8dPU_info;
           _s8aen::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8aen::I64;
           if (R1 & 7 != 0) goto u8dQv; else goto c8dPY;
       u8dQv: // global
           call _c8dPU(R1) args: 0, res: 0, upd: 0;
       c8dPY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dPU() //  [R1]
         { info_tbl: [(c8dPU,
                       label: block_c8dPU_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dPU: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8dQh; else goto u8dQg;
       u8dQh: // global
           Sp = Sp + 24;
           call _c8dQ6() args: 0, res: 0, upd: 0;
       u8dQg: // global
           Sp = Sp + 16;
           call _c8dQ7() args: 0, res: 0, upd: 0;
     }
 },
 _c8dQ7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dQ7: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dQ6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dQ6: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.275763958 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8dRK,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dRK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8dRL; else goto c8dRM;
       c8dRL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dRM: // global
           I64[Sp - 16] = block_c8dRC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dTH; else goto c8dRD;
       u8dTH: // global
           call _c8dRC(R1) args: 0, res: 0, upd: 0;
       c8dRD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dRC() //  [R1]
         { info_tbl: [(c8dRC,
                       label: block_c8dRC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dRC: // global
           _s8aes::P64 = P64[Sp + 8];
           _c8dRJ::P64 = R1 & 7;
           if (_c8dRJ::P64 < 3) goto u8dTt; else goto c8dRI;
       u8dTt: // global
           if (_c8dRJ::P64 < 2) goto c8dRG; else goto c8dRH;
       c8dRG: // global
           I64[Sp + 8] = block_c8dRP_info;
           R1 = _s8aes::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dTE; else goto c8dRR;
       u8dTE: // global
           call _c8dRP(R1) args: 0, res: 0, upd: 0;
       c8dRR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dRH: // global
           I64[Sp + 8] = block_c8dS4_info;
           R1 = _s8aes::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dTF; else goto c8dS6;
       u8dTF: // global
           call _c8dS4(R1) args: 0, res: 0, upd: 0;
       c8dS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dRI: // global
           I64[Sp] = block_c8dSj_info;
           _s8aex::P64 = P64[R1 + 5];
           R1 = _s8aes::P64;
           P64[Sp + 8] = _s8aex::P64;
           if (R1 & 7 != 0) goto u8dTG; else goto c8dSl;
       u8dTG: // global
           call _c8dSj(R1) args: 0, res: 0, upd: 0;
       c8dSl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dRP() //  [R1]
         { info_tbl: [(c8dRP,
                       label: block_c8dRP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dRP: // global
           if (R1 & 7 == 1) goto u8dTu; else goto u8dTv;
       u8dTu: // global
           Sp = Sp + 8;
           call _c8dTl() args: 0, res: 0, upd: 0;
       u8dTv: // global
           Sp = Sp + 8;
           call _c8dTm() args: 0, res: 0, upd: 0;
     }
 },
 _c8dS4() //  [R1]
         { info_tbl: [(c8dS4,
                       label: block_c8dS4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dS4: // global
           if (R1 & 7 == 3) goto u8dTw; else goto u8dTx;
       u8dTw: // global
           Sp = Sp + 8;
           call _c8dTm() args: 0, res: 0, upd: 0;
       u8dTx: // global
           Sp = Sp + 8;
           call _c8dTl() args: 0, res: 0, upd: 0;
     }
 },
 _c8dSj() //  [R1]
         { info_tbl: [(c8dSj,
                       label: block_c8dSj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dSj: // global
           if (R1 & 7 == 3) goto c8dSw; else goto u8dTy;
       c8dSw: // global
           I64[Sp] = block_c8dSu_info;
           _s8aez::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8aez::P64;
           if (R1 & 7 != 0) goto u8dTM; else goto c8dSx;
       u8dTM: // global
           call _c8dSu(R1) args: 0, res: 0, upd: 0;
       c8dSx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dTy: // global
           Sp = Sp + 16;
           call _c8dTl() args: 0, res: 0, upd: 0;
     }
 },
 _c8dSu() //  [R1]
         { info_tbl: [(c8dSu,
                       label: block_c8dSu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dSu: // global
           _s8aez::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dSE; else goto c8dSU;
       c8dSE: // global
           I64[Sp + 8] = block_c8dSB_info;
           R1 = _s8aez::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dTO; else goto c8dSF;
       u8dTO: // global
           call _c8dSB(R1) args: 0, res: 0, upd: 0;
       c8dSF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dSU: // global
           I64[Sp] = block_c8dSS_info;
           _s8aeD::P64 = P64[R1 + 6];
           R1 = _s8aez::P64;
           P64[Sp + 8] = _s8aeD::P64;
           if (R1 & 7 != 0) goto u8dTP; else goto c8dSV;
       u8dTP: // global
           call _c8dSS(R1) args: 0, res: 0, upd: 0;
       c8dSV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dSB() //  [R1]
         { info_tbl: [(c8dSB,
                       label: block_c8dSB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dSB: // global
           if (R1 & 7 == 1) goto u8dTC; else goto u8dTD;
       u8dTC: // global
           Sp = Sp + 8;
           call _c8dTl() args: 0, res: 0, upd: 0;
       u8dTD: // global
           Sp = Sp + 8;
           call _c8dTm() args: 0, res: 0, upd: 0;
     }
 },
 _c8dSS() //  [R1]
         { info_tbl: [(c8dSS,
                       label: block_c8dSS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dSS: // global
           if (R1 & 7 == 1) goto u8dTz; else goto c8dTb;
       u8dTz: // global
           Sp = Sp + 16;
           call _c8dTl() args: 0, res: 0, upd: 0;
       c8dTb: // global
           I64[Sp] = block_c8dT4_info;
           _s8aeF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8aeF::P64;
           if (R1 & 7 != 0) goto u8dTS; else goto c8dT5;
       u8dTS: // global
           call _c8dT4(R1) args: 0, res: 0, upd: 0;
       c8dT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dT4() //  [R1]
         { info_tbl: [(c8dT4,
                       label: block_c8dT4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dT4: // global
           I64[Sp] = block_c8dT9_info;
           _s8aeH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8aeH::I64;
           if (R1 & 7 != 0) goto u8dTU; else goto c8dTd;
       u8dTU: // global
           call _c8dT9(R1) args: 0, res: 0, upd: 0;
       c8dTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dT9() //  [R1]
         { info_tbl: [(c8dT9,
                       label: block_c8dT9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dT9: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8dTB; else goto u8dTA;
       u8dTB: // global
           Sp = Sp + 16;
           call _c8dTl() args: 0, res: 0, upd: 0;
       u8dTA: // global
           Sp = Sp + 16;
           call _c8dTm() args: 0, res: 0, upd: 0;
     }
 },
 _c8dTm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dTm: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dTl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dTl: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.29881306 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8dV0,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dV0: // global
           _s8aeM::P64 = R3;
           R3 = R2;
           R2 = _s8aeM::P64;
           call GHC.IO.Handle.Types.$fOrdBufferMode_$c<_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.303789152 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8dVj,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dVj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8dVk; else goto c8dVl;
       c8dVk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8dVl: // global
           I64[Sp - 16] = block_c8dVb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8dX5; else goto c8dVc;
       u8dX5: // global
           call _c8dVb(R1) args: 0, res: 0, upd: 0;
       c8dVc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dVb() //  [R1]
         { info_tbl: [(c8dVb,
                       label: block_c8dVb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dVb: // global
           _s8aeN::P64 = P64[Sp + 8];
           _c8dVi::P64 = R1 & 7;
           if (_c8dVi::P64 < 3) goto u8dWV; else goto c8dVh;
       u8dWV: // global
           if (_c8dVi::P64 < 2) goto c8dVf; else goto c8dVg;
       c8dVf: // global
           I64[Sp + 8] = block_c8dVo_info;
           R1 = _s8aeN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dX2; else goto c8dVq;
       u8dX2: // global
           call _c8dVo() args: 0, res: 0, upd: 0;
       c8dVq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dVg: // global
           I64[Sp + 8] = block_c8dVx_info;
           R1 = _s8aeN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dX3; else goto c8dVz;
       u8dX3: // global
           call _c8dVx(R1) args: 0, res: 0, upd: 0;
       c8dVz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dVh: // global
           I64[Sp - 8] = block_c8dVM_info;
           _s8aeP::P64 = R1;
           _s8aeT::P64 = P64[R1 + 5];
           R1 = _s8aeN::P64;
           P64[Sp] = _s8aeT::P64;
           P64[Sp + 8] = _s8aeP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dX4; else goto c8dVO;
       u8dX4: // global
           call _c8dVM(R1) args: 0, res: 0, upd: 0;
       c8dVO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dVo() //  []
         { info_tbl: [(c8dVo,
                       label: block_c8dVo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dVo: // global
           R1 = GHC.IO.Handle.Types.NoBuffering_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dVx() //  [R1]
         { info_tbl: [(c8dVx,
                       label: block_c8dVx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dVx: // global
           if (R1 & 7 == 3) goto c8dVJ; else goto c8dVF;
       c8dVJ: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8dVF: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dVM() //  [R1]
         { info_tbl: [(c8dVM,
                       label: block_c8dVM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dVM: // global
           if (R1 & 7 == 3) goto c8dVZ; else goto u8dWW;
       c8dVZ: // global
           I64[Sp - 8] = block_c8dVX_info;
           _s8aeU::P64 = R1;
           _s8aeV::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8aeV::P64;
           P64[Sp + 8] = _s8aeU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dX6; else goto c8dW0;
       u8dX6: // global
           call _c8dVX(R1) args: 0, res: 0, upd: 0;
       c8dW0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8dWW: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8dWO() args: 0, res: 0, upd: 0;
     }
 },
 _c8dVX() //  [R1]
         { info_tbl: [(c8dVX,
                       label: block_c8dVX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dVX: // global
           _s8aeV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8dW7; else goto c8dWn;
       c8dW7: // global
           I64[Sp + 8] = block_c8dW4_info;
           R1 = _s8aeV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8dX8; else goto c8dW8;
       u8dX8: // global
           call _c8dW4(R1) args: 0, res: 0, upd: 0;
       c8dW8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8dWn: // global
           I64[Sp] = block_c8dWl_info;
           _s8aeZ::P64 = P64[R1 + 6];
           R1 = _s8aeV::P64;
           P64[Sp + 8] = _s8aeZ::P64;
           if (R1 & 7 != 0) goto u8dX9; else goto c8dWo;
       u8dX9: // global
           call _c8dWl(R1) args: 0, res: 0, upd: 0;
       c8dWo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dW4() //  [R1]
         { info_tbl: [(c8dW4,
                       label: block_c8dW4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dW4: // global
           if (R1 & 7 == 1) goto u8dX0; else goto u8dX1;
       u8dX0: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8dWO() args: 0, res: 0, upd: 0;
       u8dX1: // global
           Sp = Sp + 16;
           call _c8dWP() args: 0, res: 0, upd: 0;
     }
 },
 _c8dWl() //  [R1]
         { info_tbl: [(c8dWl,
                       label: block_c8dWl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dWl: // global
           if (R1 & 7 == 1) goto u8dWX; else goto c8dWE;
       u8dWX: // global
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp + 24;
           call _c8dWO() args: 0, res: 0, upd: 0;
       c8dWE: // global
           I64[Sp] = block_c8dWx_info;
           _s8af1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8af1::P64;
           if (R1 & 7 != 0) goto u8dXc; else goto c8dWy;
       u8dXc: // global
           call _c8dWx(R1) args: 0, res: 0, upd: 0;
       c8dWy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dWx() //  [R1]
         { info_tbl: [(c8dWx,
                       label: block_c8dWx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dWx: // global
           I64[Sp] = block_c8dWC_info;
           _s8af3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8af3::I64;
           if (R1 & 7 != 0) goto u8dXe; else goto c8dWG;
       u8dXe: // global
           call _c8dWC(R1) args: 0, res: 0, upd: 0;
       c8dWG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dWC() //  [R1]
         { info_tbl: [(c8dWC,
                       label: block_c8dWC_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dWC: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8dWZ; else goto u8dWY;
       u8dWZ: // global
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp + 24;
           call _c8dWO() args: 0, res: 0, upd: 0;
       u8dWY: // global
           Sp = Sp + 24;
           call _c8dWP() args: 0, res: 0, upd: 0;
     }
 },
 _c8dWP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dWP: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8dWO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dWO: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.327048027 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqBufferMode_closure+1;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.330264939 UTC

[section ""data" . GHC.IO.Handle.Types.haOtherSide_closure" {
     GHC.IO.Handle.Types.haOtherSide_closure:
         const GHC.IO.Handle.Types.haOtherSide_info;
 },
 GHC.IO.Handle.Types.haOtherSide_entry() //  [R2]
         { info_tbl: [(c8dYv,
                       label: GHC.IO.Handle.Types.haOtherSide_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dYv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dYw; else goto c8dYx;
       c8dYw: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haOtherSide_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dYx: // global
           I64[Sp - 8] = block_c8dYs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dYB; else goto c8dYt;
       u8dYB: // global
           call _c8dYs(R1) args: 0, res: 0, upd: 0;
       c8dYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dYs() //  [R1]
         { info_tbl: [(c8dYs,
                       label: block_c8dYs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dYs: // global
           R1 = P64[R1 + 127] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.335606807 UTC

[section ""data" . GHC.IO.Handle.Types.haOutputNL_closure" {
     GHC.IO.Handle.Types.haOutputNL_closure:
         const GHC.IO.Handle.Types.haOutputNL_info;
 },
 GHC.IO.Handle.Types.haOutputNL_entry() //  [R2]
         { info_tbl: [(c8dYU,
                       label: GHC.IO.Handle.Types.haOutputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dYU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dYV; else goto c8dYW;
       c8dYV: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haOutputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dYW: // global
           I64[Sp - 8] = block_c8dYR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dZ0; else goto c8dYS;
       u8dZ0: // global
           call _c8dYR(R1) args: 0, res: 0, upd: 0;
       c8dYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dYR() //  [R1]
         { info_tbl: [(c8dYR,
                       label: block_c8dYR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dYR: // global
           R1 = P64[R1 + 119] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.341291319 UTC

[section ""data" . GHC.IO.Handle.Types.haInputNL_closure" {
     GHC.IO.Handle.Types.haInputNL_closure:
         const GHC.IO.Handle.Types.haInputNL_info;
 },
 GHC.IO.Handle.Types.haInputNL_entry() //  [R2]
         { info_tbl: [(c8dZj,
                       label: GHC.IO.Handle.Types.haInputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dZj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dZk; else goto c8dZl;
       c8dZk: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haInputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dZl: // global
           I64[Sp - 8] = block_c8dZg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dZp; else goto c8dZh;
       u8dZp: // global
           call _c8dZg(R1) args: 0, res: 0, upd: 0;
       c8dZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dZg() //  [R1]
         { info_tbl: [(c8dZg,
                       label: block_c8dZg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dZg: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.346669415 UTC

[section ""data" . GHC.IO.Handle.Types.haCodec_closure" {
     GHC.IO.Handle.Types.haCodec_closure:
         const GHC.IO.Handle.Types.haCodec_info;
 },
 GHC.IO.Handle.Types.haCodec_entry() //  [R2]
         { info_tbl: [(c8dZI,
                       label: GHC.IO.Handle.Types.haCodec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dZI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8dZJ; else goto c8dZK;
       c8dZJ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haCodec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8dZK: // global
           I64[Sp - 8] = block_c8dZF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8dZO; else goto c8dZG;
       u8dZO: // global
           call _c8dZF(R1) args: 0, res: 0, upd: 0;
       c8dZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8dZF() //  [R1]
         { info_tbl: [(c8dZF,
                       label: block_c8dZF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8dZF: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.351864333 UTC

[section ""data" . GHC.IO.Handle.Types.haDecoder_closure" {
     GHC.IO.Handle.Types.haDecoder_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.354141023 UTC

[section ""data" . GHC.IO.Handle.Types.haEncoder_closure" {
     GHC.IO.Handle.Types.haEncoder_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.356142872 UTC

[section ""data" . GHC.IO.Handle.Types.haBuffers_closure" {
     GHC.IO.Handle.Types.haBuffers_closure:
         const GHC.IO.Handle.Types.haBuffers_info;
 },
 GHC.IO.Handle.Types.haBuffers_entry() //  [R2]
         { info_tbl: [(c8e09,
                       label: GHC.IO.Handle.Types.haBuffers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e09: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e0d; else goto c8e0e;
       c8e0d: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haBuffers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e0e: // global
           I64[Sp - 8] = block_c8e06_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e0i; else goto c8e07;
       u8e0i: // global
           call _c8e06(R1) args: 0, res: 0, upd: 0;
       c8e07: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e06() //  [R1]
         { info_tbl: [(c8e06,
                       label: block_c8e06_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e06: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8e0h; else goto c8e0g;
       c8e0h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8e0g: // global
           _s8ags::P64 = P64[R1 + 79];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8ags::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.362548031 UTC

[section ""data" . GHC.IO.Handle.Types.haCharBuffer_closure" {
     GHC.IO.Handle.Types.haCharBuffer_closure:
         const GHC.IO.Handle.Types.haCharBuffer_info;
 },
 GHC.IO.Handle.Types.haCharBuffer_entry() //  [R2]
         { info_tbl: [(c8e0A,
                       label: GHC.IO.Handle.Types.haCharBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e0A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e0E; else goto c8e0F;
       c8e0E: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haCharBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e0F: // global
           I64[Sp - 8] = block_c8e0x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e0J; else goto c8e0y;
       u8e0J: // global
           call _c8e0x(R1) args: 0, res: 0, upd: 0;
       c8e0y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e0x() //  [R1]
         { info_tbl: [(c8e0x,
                       label: block_c8e0x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e0x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8e0I; else goto c8e0H;
       c8e0I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8e0H: // global
           _s8agJ::P64 = P64[R1 + 71];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8agJ::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.368063733 UTC

[section ""data" . GHC.IO.Handle.Types.haLastDecode_closure" {
     GHC.IO.Handle.Types.haLastDecode_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.370098947 UTC

[section ""data" . GHC.IO.Handle.Types.haBufferMode_closure" {
     GHC.IO.Handle.Types.haBufferMode_closure:
         const GHC.IO.Handle.Types.haBufferMode_info;
 },
 GHC.IO.Handle.Types.haBufferMode_entry() //  [R2]
         { info_tbl: [(c8e12,
                       label: GHC.IO.Handle.Types.haBufferMode_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e12: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e13; else goto c8e14;
       c8e13: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haBufferMode_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e14: // global
           I64[Sp - 8] = block_c8e0Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e18; else goto c8e10;
       u8e18: // global
           call _c8e0Z(R1) args: 0, res: 0, upd: 0;
       c8e10: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e0Z() //  [R1]
         { info_tbl: [(c8e0Z,
                       label: block_c8e0Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e0Z: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.376247687 UTC

[section ""data" . GHC.IO.Handle.Types.haByteBuffer_closure" {
     GHC.IO.Handle.Types.haByteBuffer_closure:
         const GHC.IO.Handle.Types.haByteBuffer_info;
 },
 GHC.IO.Handle.Types.haByteBuffer_entry() //  [R2]
         { info_tbl: [(c8e1r,
                       label: GHC.IO.Handle.Types.haByteBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e1r: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e1v; else goto c8e1w;
       c8e1v: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haByteBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e1w: // global
           I64[Sp - 8] = block_c8e1o_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e1A; else goto c8e1p;
       u8e1A: // global
           call _c8e1o(R1) args: 0, res: 0, upd: 0;
       c8e1p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e1o() //  [R1]
         { info_tbl: [(c8e1o,
                       label: block_c8e1o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e1o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8e1z; else goto c8e1y;
       c8e1z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8e1y: // global
           _s8ahg::P64 = P64[R1 + 47];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8ahg::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.382246841 UTC

[section ""data" . GHC.IO.Handle.Types.haType_closure" {
     GHC.IO.Handle.Types.haType_closure:
         const GHC.IO.Handle.Types.haType_info;
 },
 GHC.IO.Handle.Types.haType_entry() //  [R2]
         { info_tbl: [(c8e1S,
                       label: GHC.IO.Handle.Types.haType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e1S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e1T; else goto c8e1U;
       c8e1T: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e1U: // global
           I64[Sp - 8] = block_c8e1P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e1Y; else goto c8e1Q;
       u8e1Y: // global
           call _c8e1P(R1) args: 0, res: 0, upd: 0;
       c8e1Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e1P() //  [R1]
         { info_tbl: [(c8e1P,
                       label: block_c8e1P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e1P: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.388306935 UTC

[section ""data" . GHC.IO.Handle.Types.haDevice_closure" {
     GHC.IO.Handle.Types.haDevice_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.390508476 UTC

[section ""data" . GHC.IO.Handle.Types.outputNL_closure" {
     GHC.IO.Handle.Types.outputNL_closure:
         const GHC.IO.Handle.Types.outputNL_info;
 },
 GHC.IO.Handle.Types.outputNL_entry() //  [R2]
         { info_tbl: [(c8e2i,
                       label: GHC.IO.Handle.Types.outputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e2i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e2j; else goto c8e2k;
       c8e2j: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.outputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e2k: // global
           I64[Sp - 8] = block_c8e2f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e2o; else goto c8e2g;
       u8e2o: // global
           call _c8e2f(R1) args: 0, res: 0, upd: 0;
       c8e2g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e2f() //  [R1]
         { info_tbl: [(c8e2f,
                       label: block_c8e2f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e2f: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.395964142 UTC

[section ""data" . GHC.IO.Handle.Types.inputNL_closure" {
     GHC.IO.Handle.Types.inputNL_closure:
         const GHC.IO.Handle.Types.inputNL_info;
 },
 GHC.IO.Handle.Types.inputNL_entry() //  [R2]
         { info_tbl: [(c8e2H,
                       label: GHC.IO.Handle.Types.inputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e2H: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e2I; else goto c8e2J;
       c8e2I: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.inputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e2J: // global
           I64[Sp - 8] = block_c8e2E_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e2N; else goto c8e2F;
       u8e2N: // global
           call _c8e2E(R1) args: 0, res: 0, upd: 0;
       c8e2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e2E() //  [R1]
         { info_tbl: [(c8e2E,
                       label: block_c8e2E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e2E: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.401526034 UTC

[section ""data" . GHC.IO.Handle.Types.isReadableHandleType_closure" {
     GHC.IO.Handle.Types.isReadableHandleType_closure:
         const GHC.IO.Handle.Types.isReadableHandleType_info;
 },
 GHC.IO.Handle.Types.isReadableHandleType_entry() //  [R2]
         { info_tbl: [(c8e3b,
                       label: GHC.IO.Handle.Types.isReadableHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e3b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e3c; else goto c8e3d;
       c8e3c: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isReadableHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e3d: // global
           I64[Sp - 8] = block_c8e33_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e3o; else goto c8e34;
       u8e3o: // global
           call _c8e33(R1) args: 0, res: 0, upd: 0;
       c8e34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e33() //  [R1]
         { info_tbl: [(c8e33,
                       label: block_c8e33_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e33: // global
           _c8e3a::P64 = R1 & 7;
           if (_c8e3a::P64 == 3) goto c8e39; else goto u8e3n;
       u8e3n: // global
           if (_c8e3a::P64 == 6) goto c8e39; else goto c8e37;
       c8e39: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8e37: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.407568674 UTC

[section ""data" . GHC.IO.Handle.Types.isWritableHandleType_closure" {
     GHC.IO.Handle.Types.isWritableHandleType_closure:
         const GHC.IO.Handle.Types.isWritableHandleType_info;
 },
 GHC.IO.Handle.Types.isWritableHandleType_entry() //  [R2]
         { info_tbl: [(c8e3O,
                       label: GHC.IO.Handle.Types.isWritableHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e3O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e3P; else goto c8e3Q;
       c8e3P: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isWritableHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e3Q: // global
           I64[Sp - 8] = block_c8e3F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e44; else goto c8e3G;
       u8e44: // global
           call _c8e3F(R1) args: 0, res: 0, upd: 0;
       c8e3G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e3F() //  [R1]
         { info_tbl: [(c8e3F,
                       label: block_c8e3F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e3F: // global
           _c8e3N::P64 = R1 & 7;
           if (_c8e3N::P64 < 4) goto c8e3J; else goto u8e43;
       c8e3J: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8e43: // global
           if (_c8e3N::P64 != 5) goto c8e3M; else goto c8e3M;
       c8e3M: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.413452678 UTC

[section ""data" . GHC.IO.Handle.Types.isReadWriteHandleType_closure" {
     GHC.IO.Handle.Types.isReadWriteHandleType_closure:
         const GHC.IO.Handle.Types.isReadWriteHandleType_info;
 },
 GHC.IO.Handle.Types.isReadWriteHandleType_entry() //  [R2]
         { info_tbl: [(c8e4s,
                       label: GHC.IO.Handle.Types.isReadWriteHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e4s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e4t; else goto c8e4u;
       c8e4t: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isReadWriteHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e4u: // global
           I64[Sp - 8] = block_c8e4l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e4B; else goto c8e4m;
       u8e4B: // global
           call _c8e4l(R1) args: 0, res: 0, upd: 0;
       c8e4m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e4l() //  [R1]
         { info_tbl: [(c8e4l,
                       label: block_c8e4l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e4l: // global
           if (R1 & 7 == 6) goto c8e4q; else goto c8e4p;
       c8e4q: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8e4p: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.418974055 UTC

[section ""data" . GHC.IO.Handle.Types.nativeNewline_closure" {
     GHC.IO.Handle.Types.nativeNewline_closure:
         const GHC.IO.Handle.Types.LF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.420730411 UTC

[section ""data" . GHC.IO.Handle.Types.universalNewlineMode_closure" {
     GHC.IO.Handle.Types.universalNewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_con_info;
         const GHC.IO.Handle.Types.CRLF_closure+2;
         const GHC.IO.Handle.Types.LF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.423174312 UTC

[section ""data" . GHC.IO.Handle.Types.nativeNewlineMode_closure" {
     GHC.IO.Handle.Types.nativeNewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_con_info;
         const GHC.IO.Handle.Types.LF_closure+1;
         const GHC.IO.Handle.Types.LF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.424868805 UTC

[section ""data" . GHC.IO.Handle.Types.noNewlineTranslation_closure" {
     GHC.IO.Handle.Types.noNewlineTranslation_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Handle.Types.nativeNewlineMode_closure+1;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.426632077 UTC

[section ""cstring" . GHC.IO.Handle.Types.showHandle1_bytes" {
     GHC.IO.Handle.Types.showHandle1_bytes:
         I8[] [123,104,97,110,100,108,101,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.428851062 UTC

[section ""data" . GHC.IO.Handle.Types.showHandle_closure" {
     GHC.IO.Handle.Types.showHandle_closure:
         const GHC.IO.Handle.Types.showHandle_info;
 },
 sat_s8ahZ_entry() //  [R1]
         { info_tbl: [(c8e56,
                       label: sat_s8ahZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e56: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ai0_entry() //  [R1]
         { info_tbl: [(c8e59,
                       label: sat_s8ai0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e59: // global
           _s8ai0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8e5a; else goto c8e5b;
       c8e5b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8e5d; else goto c8e5c;
       c8e5d: // global
           HpAlloc = 24;
           goto c8e5a;
       c8e5a: // global
           R1 = _s8ai0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8e5c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8ai0::P64;
           _s8ahX::P64 = P64[_s8ai0::P64 + 16];
           _s8ahY::P64 = P64[_s8ai0::P64 + 24];
           I64[Hp - 16] = sat_s8ahZ_info;
           P64[Hp] = _s8ahY::P64;
           R3 = Hp - 16;
           R2 = _s8ahX::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.showHandle_entry() //  [R2, R3]
         { info_tbl: [(c8e5e,
                       label: GHC.IO.Handle.Types.showHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e5e: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8e5i; else goto c8e5h;
       c8e5i: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.showHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8e5h: // global
           I64[Hp - 24] = sat_s8ai0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.436598246 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_info;
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c8e5F,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e5F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8e5G; else goto c8e5H;
       c8e5G: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8e5H: // global
           I64[Sp - 16] = block_c8e5y_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8e5O; else goto c8e5z;
       u8e5O: // global
           call _c8e5y(R1) args: 0, res: 0, upd: 0;
       c8e5z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e5y() //  [R1]
         { info_tbl: [(c8e5y,
                       label: block_c8e5y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e5y: // global
           _s8ai3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8e5C; else goto c8e5D;
       c8e5C: // global
           R3 = _s8ai3::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c8e5D: // global
           R3 = _s8ai3::P64;
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.44302697 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_info;
         const 0;
 },
 sat_s8aie_entry() //  [R1]
         { info_tbl: [(c8e6d,
                       label: sat_s8aie_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e6d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8e6e; else goto c8e6f;
       c8e6e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8e6f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8aii_entry() //  [R1]
         { info_tbl: [(c8e6m,
                       label: sat_s8aii_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e6m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8e6n; else goto c8e6o;
       c8e6n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8e6o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshow_entry() //  [R2]
         { info_tbl: [(c8e6t,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e6t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8e6u; else goto c8e6v;
       c8e6u: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8e6v: // global
           I64[Sp - 8] = block_c8e64_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8e6C; else goto c8e65;
       u8e6C: // global
           call _c8e64(R1) args: 0, res: 0, upd: 0;
       c8e65: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e64() //  [R1]
         { info_tbl: [(c8e64,
                       label: block_c8e64_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e64: // global
           if (R1 & 7 == 1) goto c8e6q; else goto c8e6r;
       c8e6q: // global
           Hp = Hp + 24;
           _s8aib::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8e6B; else goto c8e6x;
       c8e6x: // global
           _s8aic::P64 = P64[_s8aib::P64 + 7];
           I64[Hp - 16] = sat_s8aie_info;
           P64[Hp] = _s8aic::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8e6r: // global
           Hp = Hp + 24;
           _s8aib::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8e6B; else goto c8e6A;
       c8e6B: // global
           HpAlloc = 24;
           R1 = _s8aib::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8e6A: // global
           _s8aif::P64 = P64[_s8aib::P64 + 6];
           I64[Hp - 16] = sat_s8aii_info;
           P64[Hp] = _s8aif::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.453110518 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle1_closure" {
     GHC.IO.Handle.Types.$fShowHandle1_closure:
         const GHC.IO.Handle.Types.$fShowHandle1_info;
 },
 GHC.IO.Handle.Types.$fShowHandle1_entry() //  [R2, R3]
         { info_tbl: [(c8e77,
                       label: GHC.IO.Handle.Types.$fShowHandle1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8e78; else goto c8e79;
       c8e78: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8e79: // global
           I64[Sp - 16] = block_c8e70_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8e7g; else goto c8e71;
       u8e7g: // global
           call _c8e70(R1) args: 0, res: 0, upd: 0;
       c8e71: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8e70() //  [R1]
         { info_tbl: [(c8e70,
                       label: block_c8e70_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e70: // global
           _s8aik::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8e74; else goto c8e75;
       c8e74: // global
           R3 = _s8aik::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c8e75: // global
           R3 = _s8aik::P64;
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.45956308 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshowList_info;
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8e7w,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8e7w: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowHandle1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.463503622 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_closure" {
     GHC.IO.Handle.Types.$fShowHandle_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.465183316 UTC

[section ""cstring" . GHC.IO.Handle.Types.$trModule4_bytes" {
     GHC.IO.Handle.Types.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.466848583 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule3_closure" {
     GHC.IO.Handle.Types.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.468519371 UTC

[section ""cstring" . GHC.IO.Handle.Types.$trModule2_bytes" {
     GHC.IO.Handle.Types.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.470404087 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule1_closure" {
     GHC.IO.Handle.Types.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.472146903 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule_closure" {
     GHC.IO.Handle.Types.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Types.$trModule3_closure+1;
         const GHC.IO.Handle.Types.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.473885389 UTC

[section ""data" . $krep_r8a59_closure" {
     $krep_r8a59_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.47559625 UTC

[section ""data" . $krep1_r8a5a_closure" {
     $krep1_r8a5a_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcTextEncoding_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.477289872 UTC

[section ""data" . $krep2_r8a5b_closure" {
     $krep2_r8a5b_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.47898881 UTC

[section ""data" . $krep3_r8a5c_closure" {
     $krep3_r8a5c_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.48067548 UTC

[section ""data" . $krep4_r8a5d_closure" {
     $krep4_r8a5d_closure:
         const :_con_info;
         const $krep_r8a59_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.482395099 UTC

[section ""data" . $krep5_r8a5e_closure" {
     $krep5_r8a5e_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep4_r8a5d_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.484614969 UTC

[section ""data" . $krep6_r8a5f_closure" {
     $krep6_r8a5f_closure:
         const :_con_info;
         const $krep1_r8a5a_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.487650462 UTC

[section ""data" . $krep7_r8a5g_closure" {
     $krep7_r8a5g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r8a5f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.489399611 UTC

[section ""data" . $krep8_r8a5h_closure" {
     $krep8_r8a5h_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.491068159 UTC

[section ""data" . $krep9_r8a5i_closure" {
     $krep9_r8a5i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.492846477 UTC

[section ""data" . $krep10_r8a5j_closure" {
     $krep10_r8a5j_closure:
         const :_con_info;
         const $krep9_r8a5i_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.495161216 UTC

[section ""data" . $krep11_r8a5k_closure" {
     $krep11_r8a5k_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep10_r8a5j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.496750018 UTC

[section ""data" . $krep12_r8a5l_closure" {
     $krep12_r8a5l_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.49848914 UTC

[section ""data" . $krep13_r8a5m_closure" {
     $krep13_r8a5m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure;
         const $krep12_r8a5l_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.500098777 UTC

[section ""data" . $krep14_r8a5n_closure" {
     $krep14_r8a5n_closure:
         const :_con_info;
         const $krep13_r8a5m_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.501823055 UTC

[section ""data" . $krep15_r8a5o_closure" {
     $krep15_r8a5o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep14_r8a5n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.503526916 UTC

[section ""data" . $krep16_r8a5p_closure" {
     $krep16_r8a5p_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.50517585 UTC

[section ""data" . $krep17_r8a5q_closure" {
     $krep17_r8a5q_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.507339159 UTC

[section ""data" . $krep18_r8a5r_closure" {
     $krep18_r8a5r_closure:
         const :_con_info;
         const $krep17_r8a5q_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.509014217 UTC

[section ""data" . $krep19_r8a5s_closure" {
     $krep19_r8a5s_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const $krep18_r8a5r_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.510790329 UTC

[section ""data" . $krep20_r8a5t_closure" {
     $krep20_r8a5t_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const $krep19_r8a5s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.513080016 UTC

[section ""data" . $krep21_r8a5u_closure" {
     $krep21_r8a5u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcBufferCodec_closure;
         const $krep20_r8a5t_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.515093163 UTC

[section ""data" . $krep22_r8a5v_closure" {
     $krep22_r8a5v_closure:
         const :_con_info;
         const $krep21_r8a5u_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.516816312 UTC

[section ""data" . $krep23_r8a5w_closure" {
     $krep23_r8a5w_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep22_r8a5v_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.519885247 UTC

[section ""data" . $krep24_r8a5x_closure" {
     $krep24_r8a5x_closure:
         const :_con_info;
         const $krep17_r8a5q_closure+2;
         const $krep14_r8a5n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.521721319 UTC

[section ""data" . $krep25_r8a5y_closure" {
     $krep25_r8a5y_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep24_r8a5x_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.523435865 UTC

[section ""data" . $krep26_r8a5z_closure" {
     $krep26_r8a5z_closure:
         const :_con_info;
         const $krep25_r8a5y_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.525102973 UTC

[section ""data" . $krep27_r8a5A_closure" {
     $krep27_r8a5A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep26_r8a5z_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.527287559 UTC

[section ""data" . $krep28_r8a5B_closure" {
     $krep28_r8a5B_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.528990298 UTC

[section ""data" . $krep29_r8a5C_closure" {
     $krep29_r8a5C_closure:
         const :_con_info;
         const $krep28_r8a5B_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.530680663 UTC

[section ""data" . $krep30_r8a5D_closure" {
     $krep30_r8a5D_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const $krep29_r8a5C_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.532502724 UTC

[section ""data" . $krep31_r8a5E_closure" {
     $krep31_r8a5E_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const $krep30_r8a5D_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.534330066 UTC

[section ""data" . $krep32_r8a5F_closure" {
     $krep32_r8a5F_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcBufferCodec_closure;
         const $krep31_r8a5E_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.536124101 UTC

[section ""data" . $krep33_r8a5G_closure" {
     $krep33_r8a5G_closure:
         const :_con_info;
         const $krep32_r8a5F_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.538175807 UTC

[section ""data" . $krep34_r8a5H_closure" {
     $krep34_r8a5H_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep33_r8a5G_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.540823052 UTC

[section ""data" . $krep35_r8a5I_closure" {
     $krep35_r8a5I_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.542524261 UTC

[section ""data" . $krep36_r8a5J_closure" {
     $krep36_r8a5J_closure:
         const :_con_info;
         const $krep35_r8a5I_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.544374122 UTC

[section ""data" . $krep37_r8a5K_closure" {
     $krep37_r8a5K_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.546106405 UTC

[section ""data" . $krep38_r8a5L_closure" {
     $krep38_r8a5L_closure:
         const :_con_info;
         const GHC.Types.krep$*_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.547894112 UTC

[section ""data" . $krep39_r8a5M_closure" {
     $krep39_r8a5M_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Typeable.Internal.$tcTypeable_closure;
         const $krep38_r8a5L_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.549704896 UTC

[section ""data" . $krep40_r8a5N_closure" {
     $krep40_r8a5N_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Device.$tcIODevice_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.55140295 UTC

[section ""data" . $krep41_r8a5O_closure" {
     $krep41_r8a5O_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.BufferedIO.$tcBufferedIO_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.553090275 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcBufferList2_bytes" {
     GHC.IO.Handle.Types.$tcBufferList2_bytes:
         I8[] [66,117,102,102,101,114,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.554872125 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferList1_closure" {
     GHC.IO.Handle.Types.$tcBufferList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcBufferList2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.556576927 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferList_closure" {
     GHC.IO.Handle.Types.$tcBufferList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcBufferList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16602278556585116844;
         const 18164509953320487254;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.559024452 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil1_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferList_closure+1;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.560817127 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BufferListNil3_bytes" {
     GHC.IO.Handle.Types.$tc'BufferListNil3_bytes:
         I8[] [39,66,117,102,102,101,114,76,105,115,116,78,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.562582465 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil2_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListNil3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.564321551 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil2_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const 1776148480580179033;
         const 13181184993065174936;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.566814227 UTC

[section ""data" . $krep42_r8a5P_closure" {
     $krep42_r8a5P_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.568580119 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons1_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep37_r8a5K_closure+1;
         const $krep42_r8a5P_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.570565493 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BufferListCons3_bytes" {
     GHC.IO.Handle.Types.$tc'BufferListCons3_bytes:
         I8[] [39,66,117,102,102,101,114,76,105,115,116,67,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.572215514 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons2_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListCons3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.573999241 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListCons2_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListCons1_closure+4;
         const 17252346539814354939;
         const 274626690118510806;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.575892023 UTC

[section ""data" . $krep43_r8a5Q_closure" {
     $krep43_r8a5Q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferList_closure+1;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.577655416 UTC

[section ""data" . $krep44_r8a5R_closure" {
     $krep44_r8a5R_closure:
         const :_con_info;
         const $krep43_r8a5Q_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.579413329 UTC

[section ""data" . $krep45_r8a5S_closure" {
     $krep45_r8a5S_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep44_r8a5R_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.581150183 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandleType2_bytes" {
     GHC.IO.Handle.Types.$tcHandleType2_bytes:
         I8[] [72,97,110,100,108,101,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.583681722 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandleType1_closure" {
     GHC.IO.Handle.Types.$tcHandleType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandleType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.585473257 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandleType_closure" {
     GHC.IO.Handle.Types.$tcHandleType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandleType1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12652050740177317592;
         const 15012172050125063359;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.587416294 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle1_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandleType_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.589230425 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes:
         I8[] [39,67,108,111,115,101,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.591022794 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ClosedHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ClosedHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.593215382 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ClosedHandle_closure" {
     GHC.IO.Handle.Types.$tc'ClosedHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ClosedHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 3827246897052092772;
         const 908733983357893198;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.595564835 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes:
         I8[] [39,83,101,109,105,67,108,111,115,101,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.597222065 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.598931409 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'SemiClosedHandle_closure" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 9212351547956271402;
         const 6570718180183054490;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.60081553 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ReadHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ReadHandle2_bytes:
         I8[] [39,82,101,97,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.602802608 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ReadHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ReadHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.604598942 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadHandle_closure" {
     GHC.IO.Handle.Types.$tc'ReadHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ReadHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 269968663592081974;
         const 17473723309710900549;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.606497001 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'WriteHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'WriteHandle2_bytes:
         I8[] [39,87,114,105,116,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.60821846 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'WriteHandle1_closure" {
     GHC.IO.Handle.Types.$tc'WriteHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'WriteHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.610002943 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'WriteHandle_closure" {
     GHC.IO.Handle.Types.$tc'WriteHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'WriteHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 18024523813608199082;
         const 4783872735135983851;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.611903278 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'AppendHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'AppendHandle3_bytes:
         I8[] [39,65,112,112,101,110,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.614035413 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle2_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'AppendHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.615769152 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 18423480119042393547;
         const 8911069045719960050;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.617606621 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes:
         I8[] [39,82,101,97,100,87,114,105,116,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.619882722 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.621805331 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadWriteHandle_closure" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 6962298179673541916;
         const 7858738479804269456;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.623657927 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcBufferMode2_bytes" {
     GHC.IO.Handle.Types.$tcBufferMode2_bytes:
         I8[] [66,117,102,102,101,114,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.62578967 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferMode1_closure" {
     GHC.IO.Handle.Types.$tcBufferMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcBufferMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.627459754 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferMode_closure" {
     GHC.IO.Handle.Types.$tcBufferMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcBufferMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2181253694666364469;
         const 18094997560331273583;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.629320475 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.631086426 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'NoBuffering2_bytes" {
     GHC.IO.Handle.Types.$tc'NoBuffering2_bytes:
         I8[] [39,78,111,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.632810609 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NoBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'NoBuffering1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'NoBuffering2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.634568387 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NoBuffering_closure" {
     GHC.IO.Handle.Types.$tc'NoBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'NoBuffering1_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 1829914617507863771;
         const 11519122601481432262;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.636485504 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'LineBuffering3_bytes" {
     GHC.IO.Handle.Types.$tc'LineBuffering3_bytes:
         I8[] [39,76,105,110,101,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.638528751 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering2_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'LineBuffering3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.640321588 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering2_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 6417231512954421547;
         const 14761155862500981941;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.642257855 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r8a5e_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.644036416 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes" {
     GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes:
         I8[] [39,66,108,111,99,107,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.645769138 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering2_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.648193949 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BlockBuffering2_closure+1;
         const GHC.IO.Handle.Types.$tc'BlockBuffering1_closure+4;
         const 704611490471072872;
         const 15656058643765081689;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.650563298 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcNewline2_bytes" {
     GHC.IO.Handle.Types.$tcNewline2_bytes:
         I8[] [78,101,119,108,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.652242763 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewline1_closure" {
     GHC.IO.Handle.Types.$tcNewline1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcNewline2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.654036208 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewline_closure" {
     GHC.IO.Handle.Types.$tcNewline_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcNewline1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4144517894815066994;
         const 10872055347860317487;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.655933664 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF1_closure" {
     GHC.IO.Handle.Types.$tc'CRLF1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcNewline_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.657664386 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'LF2_bytes" {
     GHC.IO.Handle.Types.$tc'LF2_bytes:
         I8[] [39,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.659476535 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LF1_closure" {
     GHC.IO.Handle.Types.$tc'LF1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'LF2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.661200655 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LF_closure" {
     GHC.IO.Handle.Types.$tc'LF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'LF1_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const 8352565500432618804;
         const 14951155965269318914;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.663348023 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'CRLF3_bytes" {
     GHC.IO.Handle.Types.$tc'CRLF3_bytes:
         I8[] [39,67,82,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.665024444 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF2_closure" {
     GHC.IO.Handle.Types.$tc'CRLF2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.666688606 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF_closure" {
     GHC.IO.Handle.Types.$tc'CRLF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF2_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const 12041259567283068515;
         const 3210182148185771829;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.668435771 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandle__2_bytes" {
     GHC.IO.Handle.Types.$tcHandle__2_bytes:
         I8[] [72,97,110,100,108,101,95,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.6701054 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle__1_closure" {
     GHC.IO.Handle.Types.$tcHandle__1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandle__2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.671746657 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle___closure" {
     GHC.IO.Handle.Types.$tcHandle___closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandle__1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10675922960094776064;
         const 10563785792974977547;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.674182188 UTC

[section ""data" . $krep46_r8a5T_closure" {
     $krep46_r8a5T_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle___closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.675939851 UTC

[section ""data" . $krep47_r8a5U_closure" {
     $krep47_r8a5U_closure:
         const :_con_info;
         const $krep46_r8a5T_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.678181383 UTC

[section ""data" . $krep48_r8a5V_closure" {
     $krep48_r8a5V_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep47_r8a5U_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.679886571 UTC

[section ""data" . $krep49_r8a5W_closure" {
     $krep49_r8a5W_closure:
         const :_con_info;
         const $krep48_r8a5V_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.681628757 UTC

[section ""data" . $krep50_r8a5X_closure" {
     $krep50_r8a5X_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep49_r8a5W_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.683285991 UTC

[section ""data" . $krep51_r8a5Y_closure" {
     $krep51_r8a5Y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep50_r8a5X_closure+1;
         const $krep46_r8a5T_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.685007443 UTC

[section ""data" . $krep52_r8a5Z_closure" {
     $krep52_r8a5Z_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep51_r8a5Y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.687181696 UTC

[section ""data" . $krep53_r8a60_closure" {
     $krep53_r8a60_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep52_r8a5Z_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.688843075 UTC

[section ""data" . $krep54_r8a61_closure" {
     $krep54_r8a61_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r8a5g_closure+1;
         const $krep53_r8a60_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.690513779 UTC

[section ""data" . $krep55_r8a62_closure" {
     $krep55_r8a62_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep23_r8a5w_closure+1;
         const $krep54_r8a61_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.692276549 UTC

[section ""data" . $krep56_r8a63_closure" {
     $krep56_r8a63_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep34_r8a5H_closure+1;
         const $krep55_r8a62_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.69401967 UTC

[section ""data" . $krep57_r8a64_closure" {
     $krep57_r8a64_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep45_r8a5S_closure+1;
         const $krep56_r8a63_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.695768559 UTC

[section ""data" . $krep58_r8a65_closure" {
     $krep58_r8a65_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r8a5k_closure+1;
         const $krep57_r8a64_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.697564034 UTC

[section ""data" . $krep59_r8a66_closure" {
     $krep59_r8a66_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep27_r8a5A_closure+1;
         const $krep58_r8a65_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.699942698 UTC

[section ""data" . $krep60_r8a67_closure" {
     $krep60_r8a67_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const $krep59_r8a66_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.702186693 UTC

[section ""data" . $krep61_r8a68_closure" {
     $krep61_r8a68_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep15_r8a5o_closure+1;
         const $krep60_r8a67_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.703911489 UTC

[section ""data" . $krep62_r8a69_closure" {
     $krep62_r8a69_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const $krep61_r8a68_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.705653897 UTC

[section ""data" . $krep63_r8a6a_closure" {
     $krep63_r8a6a_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep35_r8a5I_closure+2;
         const $krep62_r8a69_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.707431723 UTC

[section ""data" . $krep64_r8a6b_closure" {
     $krep64_r8a6b_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep39_r8a5M_closure+1;
         const $krep63_r8a6a_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.709302265 UTC

[section ""data" . $krep65_r8a6c_closure" {
     $krep65_r8a6c_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep41_r8a5O_closure+1;
         const $krep64_r8a6b_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.711012182 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle__1_closure" {
     GHC.IO.Handle.Types.$tc'Handle__1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep40_r8a5N_closure+1;
         const $krep65_r8a6c_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.712802683 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'Handle__3_bytes" {
     GHC.IO.Handle.Types.$tc'Handle__3_bytes:
         I8[] [39,72,97,110,100,108,101,95,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.714483859 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle__2_closure" {
     GHC.IO.Handle.Types.$tc'Handle__2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'Handle__3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.71617991 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle___closure" {
     GHC.IO.Handle.Types.$tc'Handle___closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'Handle__2_closure+1;
         const GHC.IO.Handle.Types.$tc'Handle__1_closure+4;
         const 15400920814375205416;
         const 14458810719499819570;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.718607137 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandle2_bytes" {
     GHC.IO.Handle.Types.$tcHandle2_bytes:
         I8[] [72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.720439564 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle1_closure" {
     GHC.IO.Handle.Types.$tcHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.722312054 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle_closure" {
     GHC.IO.Handle.Types.$tcHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandle1_closure+1;
         const GHC.Types.krep$*_closure;
         const 6808292778723485333;
         const 9239299165073943659;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.724196664 UTC

[section ""data" . $krep66_r8a6d_closure" {
     $krep66_r8a6d_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.726488983 UTC

[section ""data" . $krep67_r8a6e_closure" {
     $krep67_r8a6e_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep48_r8a5V_closure+1;
         const $krep66_r8a6d_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.728395037 UTC

[section ""data" . $krep68_r8a6f_closure" {
     $krep68_r8a6f_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep48_r8a5V_closure+1;
         const $krep67_r8a6e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.730637472 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle1_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r8a5p_closure+1;
         const $krep68_r8a6f_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.732463509 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes:
         I8[] [39,68,117,112,108,101,120,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.734194004 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle2_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.735932534 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'DuplexHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'DuplexHandle1_closure+4;
         const 477065760828861081;
         const 4557316572761143129;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.737856186 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle1_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r8a5p_closure+1;
         const $krep67_r8a6e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.739616091 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'FileHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'FileHandle3_bytes:
         I8[] [39,70,105,108,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.741332426 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle2_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'FileHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.743022657 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'FileHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'FileHandle1_closure+4;
         const 5544613225695748436;
         const 8829945929965735507;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.74480955 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewlineMode1_closure" {
     GHC.IO.Handle.Types.$tcNewlineMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode17_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.746910213 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewlineMode_closure" {
     GHC.IO.Handle.Types.$tcNewlineMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcNewlineMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 17953040817059389032;
         const 12498949339099960838;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.748729625 UTC

[section ""data" . $krep69_r8a6g_closure" {
     $krep69_r8a6g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcNewlineMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.750404863 UTC

[section ""data" . $krep70_r8a6h_closure" {
     $krep70_r8a6h_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep69_r8a6g_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.752160331 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode1_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep70_r8a6h_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.754525903 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'NewlineMode3_bytes" {
     GHC.IO.Handle.Types.$tc'NewlineMode3_bytes:
         I8[] [39,78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.756196147 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode2_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'NewlineMode3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.757924109 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'NewlineMode2_closure+1;
         const GHC.IO.Handle.Types.$tc'NewlineMode1_closure+4;
         const 4266278501114659446;
         const 17947462423734457010;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.76000009 UTC

[section ""data" . GHC.IO.Handle.Types.checkHandleInvariants1_closure" {
     GHC.IO.Handle.Types.checkHandleInvariants1_closure:
         const GHC.IO.Handle.Types.checkHandleInvariants1_info;
 },
 GHC.IO.Handle.Types.checkHandleInvariants1_entry() //  []
         { info_tbl: [(c8eaf,
                       label: GHC.IO.Handle.Types.checkHandleInvariants1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eaf: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.763495216 UTC

[section ""data" . GHC.IO.Handle.Types.checkHandleInvariants_closure" {
     GHC.IO.Handle.Types.checkHandleInvariants_closure:
         const GHC.IO.Handle.Types.checkHandleInvariants_info;
 },
 GHC.IO.Handle.Types.checkHandleInvariants_entry() //  [R2]
         { info_tbl: [(c8ear,
                       label: GHC.IO.Handle.Types.checkHandleInvariants_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ear: // global
           R2 = R2;
           call GHC.IO.Handle.Types.checkHandleInvariants1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.767376096 UTC

[section ""data" . GHC.IO.Handle.Types.NewlineMode_closure" {
     GHC.IO.Handle.Types.NewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_info;
 },
 GHC.IO.Handle.Types.NewlineMode_entry() //  [R2, R3]
         { info_tbl: [(c8eaD,
                       label: GHC.IO.Handle.Types.NewlineMode_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eaD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8eaH; else goto c8eaG;
       c8eaH: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.NewlineMode_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eaG: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.771020484 UTC

[section ""data" . GHC.IO.Handle.Types.LF_closure" {
     GHC.IO.Handle.Types.LF_closure:
         const GHC.IO.Handle.Types.LF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.772783163 UTC

[section ""data" . GHC.IO.Handle.Types.CRLF_closure" {
     GHC.IO.Handle.Types.CRLF_closure:
         const GHC.IO.Handle.Types.CRLF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.774516051 UTC

[section ""data" . GHC.IO.Handle.Types.NoBuffering_closure" {
     GHC.IO.Handle.Types.NoBuffering_closure:
         const GHC.IO.Handle.Types.NoBuffering_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.77618526 UTC

[section ""data" . GHC.IO.Handle.Types.LineBuffering_closure" {
     GHC.IO.Handle.Types.LineBuffering_closure:
         const GHC.IO.Handle.Types.LineBuffering_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.77813171 UTC

[section ""data" . GHC.IO.Handle.Types.BlockBuffering_closure" {
     GHC.IO.Handle.Types.BlockBuffering_closure:
         const GHC.IO.Handle.Types.BlockBuffering_info;
 },
 GHC.IO.Handle.Types.BlockBuffering_entry() //  [R2]
         { info_tbl: [(c8eaW,
                       label: GHC.IO.Handle.Types.BlockBuffering_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eaW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8eb0; else goto c8eaZ;
       c8eb0: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.BlockBuffering_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eaZ: // global
           I64[Hp - 8] = GHC.IO.Handle.Types.BlockBuffering_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.783159105 UTC

[section ""data" . GHC.IO.Handle.Types.ClosedHandle_closure" {
     GHC.IO.Handle.Types.ClosedHandle_closure:
         const GHC.IO.Handle.Types.ClosedHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.784970092 UTC

[section ""data" . GHC.IO.Handle.Types.SemiClosedHandle_closure" {
     GHC.IO.Handle.Types.SemiClosedHandle_closure:
         const GHC.IO.Handle.Types.SemiClosedHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.786701076 UTC

[section ""data" . GHC.IO.Handle.Types.ReadHandle_closure" {
     GHC.IO.Handle.Types.ReadHandle_closure:
         const GHC.IO.Handle.Types.ReadHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.788354041 UTC

[section ""data" . GHC.IO.Handle.Types.WriteHandle_closure" {
     GHC.IO.Handle.Types.WriteHandle_closure:
         const GHC.IO.Handle.Types.WriteHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.790082141 UTC

[section ""data" . GHC.IO.Handle.Types.AppendHandle_closure" {
     GHC.IO.Handle.Types.AppendHandle_closure:
         const GHC.IO.Handle.Types.AppendHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.791785806 UTC

[section ""data" . GHC.IO.Handle.Types.ReadWriteHandle_closure" {
     GHC.IO.Handle.Types.ReadWriteHandle_closure:
         const GHC.IO.Handle.Types.ReadWriteHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.794017468 UTC

[section ""data" . GHC.IO.Handle.Types.BufferListNil_closure" {
     GHC.IO.Handle.Types.BufferListNil_closure:
         const GHC.IO.Handle.Types.BufferListNil_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.796021424 UTC

[section ""data" . GHC.IO.Handle.Types.BufferListCons_closure" {
     GHC.IO.Handle.Types.BufferListCons_closure:
         const GHC.IO.Handle.Types.BufferListCons_info;
 },
 GHC.IO.Handle.Types.BufferListCons_entry() //  [R2, R3]
         { info_tbl: [(c8ebi,
                       label: GHC.IO.Handle.Types.BufferListCons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ebi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ebm; else goto c8ebl;
       c8ebm: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.BufferListCons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ebl: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.800241367 UTC

[section ""data" . GHC.IO.Handle.Types.Handle___closure" {
     GHC.IO.Handle.Types.Handle___closure:
         const GHC.IO.Handle.Types.Handle___info;
 },
 GHC.IO.Handle.Types.Handle___slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ebt: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Types.Handle___entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 96, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.Handle___entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8eby,
                       label: GHC.IO.Handle.Types.Handle___info
                       rep:HeapRep static {
                             Fun {arity: 16
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eby: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8ebC; else goto c8ebB;
       c8ebC: // global
           HpAlloc = 136;
           R1 = GHC.IO.Handle.Types.Handle___closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 136, res: 0, upd: 8;
       c8ebB: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           P64[Hp - 88] = R6;
           P64[Hp - 80] = P64[Sp];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 56];
           P64[Hp - 16] = P64[Sp + 64];
           P64[Hp - 8] = P64[Sp + 72];
           P64[Hp] = P64[Sp + 80];
           R1 = Hp - 127;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.806440878 UTC

[section ""data" . GHC.IO.Handle.Types.FileHandle_closure" {
     GHC.IO.Handle.Types.FileHandle_closure:
         const GHC.IO.Handle.Types.FileHandle_info;
 },
 GHC.IO.Handle.Types.FileHandle_entry() //  [R2, R3]
         { info_tbl: [(c8ec0,
                       label: GHC.IO.Handle.Types.FileHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ec0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ec4; else goto c8ec3;
       c8ec4: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.FileHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ec3: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.810220159 UTC

[section ""data" . GHC.IO.Handle.Types.DuplexHandle_closure" {
     GHC.IO.Handle.Types.DuplexHandle_closure:
         const GHC.IO.Handle.Types.DuplexHandle_info;
 },
 GHC.IO.Handle.Types.DuplexHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(c8ecf,
                       label: GHC.IO.Handle.Types.DuplexHandle_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ecf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8ecj; else goto c8eci;
       c8ecj: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.DuplexHandle_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eci: // global
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 22;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.814607427 UTC

[GHC.IO.Handle.Types.NewlineMode_con_entry() //  [R1]
         { info_tbl: [(c8ecp,
                       label: GHC.IO.Handle.Types.NewlineMode_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,78,101,119,108,105,110,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ecp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.818230121 UTC

[section ""relreadonly" . GHC.IO.Handle.Types.Newline_closure_tbl" {
     GHC.IO.Handle.Types.Newline_closure_tbl:
         const GHC.IO.Handle.Types.LF_closure+1;
         const GHC.IO.Handle.Types.CRLF_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.820011056 UTC

[GHC.IO.Handle.Types.LF_con_entry() //  [R1]
         { info_tbl: [(c8ecw,
                       label: GHC.IO.Handle.Types.LF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,76,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ecw: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.82330789 UTC

[GHC.IO.Handle.Types.CRLF_con_entry() //  [R1]
         { info_tbl: [(c8ecC,
                       label: GHC.IO.Handle.Types.CRLF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,67,82,76,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ecC: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.826705654 UTC

[GHC.IO.Handle.Types.NoBuffering_con_entry() //  [R1]
         { info_tbl: [(c8ecI,
                       label: GHC.IO.Handle.Types.NoBuffering_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,78,111,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ecI: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.829927699 UTC

[GHC.IO.Handle.Types.LineBuffering_con_entry() //  [R1]
         { info_tbl: [(c8ecO,
                       label: GHC.IO.Handle.Types.LineBuffering_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,76,105,110,101,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ecO: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.833223628 UTC

[GHC.IO.Handle.Types.BlockBuffering_con_entry() //  [R1]
         { info_tbl: [(c8ecU,
                       label: GHC.IO.Handle.Types.BlockBuffering_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,108,111,99,107,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ecU: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.83642807 UTC

[section ""relreadonly" . GHC.IO.Handle.Types.HandleType_closure_tbl" {
     GHC.IO.Handle.Types.HandleType_closure_tbl:
         const GHC.IO.Handle.Types.ClosedHandle_closure+1;
         const GHC.IO.Handle.Types.SemiClosedHandle_closure+2;
         const GHC.IO.Handle.Types.ReadHandle_closure+3;
         const GHC.IO.Handle.Types.WriteHandle_closure+4;
         const GHC.IO.Handle.Types.AppendHandle_closure+5;
         const GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.838316664 UTC

[GHC.IO.Handle.Types.ClosedHandle_con_entry() //  [R1]
         { info_tbl: [(c8ed1,
                       label: GHC.IO.Handle.Types.ClosedHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,67,108,111,115,101,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ed1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.841491725 UTC

[GHC.IO.Handle.Types.SemiClosedHandle_con_entry() //  [R1]
         { info_tbl: [(c8ed7,
                       label: GHC.IO.Handle.Types.SemiClosedHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,83,101,109,105,67,108,111,115,101,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ed7: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.845762824 UTC

[GHC.IO.Handle.Types.ReadHandle_con_entry() //  [R1]
         { info_tbl: [(c8edd,
                       label: GHC.IO.Handle.Types.ReadHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,82,101,97,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8edd: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.848799818 UTC

[GHC.IO.Handle.Types.WriteHandle_con_entry() //  [R1]
         { info_tbl: [(c8edj,
                       label: GHC.IO.Handle.Types.WriteHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,87,114,105,116,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8edj: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.851980814 UTC

[GHC.IO.Handle.Types.AppendHandle_con_entry() //  [R1]
         { info_tbl: [(c8edp,
                       label: GHC.IO.Handle.Types.AppendHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,65,112,112,101,110,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8edp: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.855125041 UTC

[GHC.IO.Handle.Types.ReadWriteHandle_con_entry() //  [R1]
         { info_tbl: [(c8edv,
                       label: GHC.IO.Handle.Types.ReadWriteHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,82,101,97,100,87,114,105,116,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8edv: // global
           R1 = R1 + 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.858201273 UTC

[GHC.IO.Handle.Types.BufferListNil_con_entry() //  [R1]
         { info_tbl: [(c8edB,
                       label: GHC.IO.Handle.Types.BufferListNil_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,117,102,102,101,114,76,105,115,116,78,105,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8edB: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.86140727 UTC

[GHC.IO.Handle.Types.BufferListCons_con_entry() //  [R1]
         { info_tbl: [(c8edH,
                       label: GHC.IO.Handle.Types.BufferListCons_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,117,102,102,101,114,76,105,115,116,67,111,110,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8edH: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.864555408 UTC

[GHC.IO.Handle.Types.Handle___con_entry() //  [R1]
         { info_tbl: [(c8edN,
                       label: GHC.IO.Handle.Types.Handle___con_info
                       rep:HeapRep 16 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,72,97,110,100,108,101,95,95]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8edN: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.868353508 UTC

[GHC.IO.Handle.Types.FileHandle_con_entry() //  [R1]
         { info_tbl: [(c8edT,
                       label: GHC.IO.Handle.Types.FileHandle_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,70,105,108,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8edT: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.872119006 UTC

[GHC.IO.Handle.Types.DuplexHandle_con_entry() //  [R1]
         { info_tbl: [(c8edZ,
                       label: GHC.IO.Handle.Types.DuplexHandle_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,68,117,112,108,101,120,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8edZ: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:18.875356489 UTC

[section ""relreadonly" . S8alj_srt" {
     S8alj_srt:
         const GHC.IO.Handle.Types.$w$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowHandleType1_closure;
         const GHC.IO.Handle.Types.$fShowHandleType3_closure;
         const GHC.IO.Handle.Types.$fShowHandleType5_closure;
         const GHC.IO.Handle.Types.$fShowHandleType7_closure;
         const GHC.IO.Handle.Types.$fShowHandleType9_closure;
         const GHC.IO.Handle.Types.$fShowHandleType11_closure;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure;
         const GHC.IO.Handle.Types.$fReadNewline6_closure;
         const GHC.IO.Handle.Types.$fReadNewline10_closure;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowNewline1_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.IO.Handle.Types.$w$cshowsPrec1_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode1_closure;
         const GHC.Read.choose2_closure;
         const GHC.IO.Handle.Types.$fReadNewline_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.Handle.Types.$fReadNewline2_closure;
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Handle.Types.$fReadNewline1_closure;
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewline12_closure;
         const Text.Read.Lex.$wexpect_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode3_closure;
         const GHC.Read.readField_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode6_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode11_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode8_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode12_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure;
         const GHC.IO.Handle.Types.$w$creadPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode2_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode1_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode18_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode12_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode8_closure;
         const GHC.Show.$fShowMaybe_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode3_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode5_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode6_closure;
         const GHC.Show.$fShowMaybe1_closure;
         const GHC.Show.$fShowMaybe4_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode1_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_sps_closure;
         const GHC.Read.choose2_closure;
         const GHC.Read.$fReadInt_closure;
         const GHC.Read.$fReadMaybe1_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode2_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode1_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode14_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:21.966272767 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:21.971313881 UTC

[section ""data" . GHC.IO.Handle.Types.$WHandle___closure" {
     GHC.IO.Handle.Types.$WHandle___closure:
         const GHC.IO.Handle.Types.$WHandle___info;
 },
 GHC.IO.Handle.Types.$WHandle___slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eqj: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Types.$WHandle___entry(R6,
                                                     R5,
                                                     R4,
                                                     R3,
                                                     R2,
                                                     R1) args: 96, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$WHandle___entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8eqs,
                       label: GHC.IO.Handle.Types.$WHandle___info
                       rep:HeapRep static {
                             Fun {arity: 16
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eqs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8eqL; else goto c8eqM;
       c8eqL: // global
           R1 = GHC.IO.Handle.Types.$WHandle___closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 136, res: 0, upd: 8;
       c8eqM: // global
           I64[Sp - 40] = block_c8eqn_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eqn() //  [R1]
         { info_tbl: [(c8eqn,
                       label: block_c8eqn_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eqn: // global
           I64[Sp] = block_c8eqp_info;
           _s8eem::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s8eem::P64;
           if (R1 & 7 != 0) goto u8eqU; else goto c8eqq;
       u8eqU: // global
           call _c8eqp(R1) args: 0, res: 0, upd: 0;
       c8eqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eqp() //  [R1]
         { info_tbl: [(c8eqp,
                       label: block_c8eqp_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eqp: // global
           I64[Sp] = block_c8eqv_info;
           _s8eeo::P64 = P64[R1 + 7];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _s8eeo::P64;
           if (R1 & 7 != 0) goto u8eqV; else goto c8eqw;
       u8eqV: // global
           call _c8eqv(R1) args: 0, res: 0, upd: 0;
       c8eqw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eqv() //  [R1]
         { info_tbl: [(c8eqv,
                       label: block_c8eqv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eqv: // global
           I64[Sp] = block_c8eqA_info;
           _s8eeq::P64 = P64[R1 + 7];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s8eeq::P64;
           if (R1 & 7 != 0) goto u8eqW; else goto c8eqB;
       u8eqW: // global
           call _c8eqA(R1) args: 0, res: 0, upd: 0;
       c8eqB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eqA() //  [R1]
         { info_tbl: [(c8eqA,
                       label: block_c8eqA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eqA: // global
           I64[Sp] = block_c8eqF_info;
           _s8ees::P64 = P64[R1 + 7];
           R1 = P64[Sp + 72];
           P64[Sp + 72] = _s8ees::P64;
           if (R1 & 7 != 0) goto u8eqX; else goto c8eqG;
       u8eqX: // global
           call _c8eqF(R1) args: 0, res: 0, upd: 0;
       c8eqG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eqF() //  [R1]
         { info_tbl: [(c8eqF,
                       label: block_c8eqF_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eqF: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8eqT; else goto c8eqS;
       c8eqT: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8eqS: // global
           _s8eeu::P64 = P64[R1 + 7];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = P64[Sp + 16];
           P64[Hp - 104] = P64[Sp + 24];
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 64];
           P64[Hp - 56] = P64[Sp + 72];
           P64[Hp - 48] = _s8eeu::P64;
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = P64[Sp + 104];
           P64[Hp - 8] = P64[Sp + 112];
           P64[Hp] = P64[Sp + 120];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:21.987902517 UTC

[section ""data" . GHC.IO.Handle.Types.$WFileHandle_closure" {
     GHC.IO.Handle.Types.$WFileHandle_closure:
         const GHC.IO.Handle.Types.$WFileHandle_info;
 },
 GHC.IO.Handle.Types.$WFileHandle_entry() //  [R2, R3]
         { info_tbl: [(c8erR,
                       label: GHC.IO.Handle.Types.$WFileHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8erR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8erV; else goto c8erW;
       c8erV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$WFileHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8erW: // global
           I64[Sp - 16] = block_c8erO_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8es0; else goto c8erP;
       u8es0: // global
           call _c8erO(R1) args: 0, res: 0, upd: 0;
       c8erP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8erO() //  [R1]
         { info_tbl: [(c8erO,
                       label: block_c8erO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8erO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8erZ; else goto c8erY;
       c8erZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8erY: // global
           _s8eey::P64 = P64[R1 + 7];
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s8eey::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:21.99457352 UTC

[section ""data" . GHC.IO.Handle.Types.$WDuplexHandle_closure" {
     GHC.IO.Handle.Types.$WDuplexHandle_closure:
         const GHC.IO.Handle.Types.$WDuplexHandle_info;
 },
 GHC.IO.Handle.Types.$WDuplexHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(c8esl,
                       label: GHC.IO.Handle.Types.$WDuplexHandle_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8esl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8esu; else goto c8esv;
       c8esu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$WDuplexHandle_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8esv: // global
           I64[Sp - 24] = block_c8esi_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8esB; else goto c8esj;
       u8esB: // global
           call _c8esi(R1) args: 0, res: 0, upd: 0;
       c8esj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8esi() //  [R1]
         { info_tbl: [(c8esi,
                       label: block_c8esi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8esi: // global
           I64[Sp] = block_c8eso_info;
           _s8eeD::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8eeD::P64;
           if (R1 & 7 != 0) goto u8esA; else goto c8esp;
       u8esA: // global
           call _c8eso(R1) args: 0, res: 0, upd: 0;
       c8esp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eso() //  [R1]
         { info_tbl: [(c8eso,
                       label: block_c8eso_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eso: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8esz; else goto c8esy;
       c8esz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8esy: // global
           _s8eeF::P64 = P64[R1 + 7];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s8eeF::P64;
           R1 = Hp - 22;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.003093529 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType12_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType12_bytes:
         I8[] [99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.005189395 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType11_closure" {
     GHC.IO.Handle.Types.$fShowHandleType11_closure:
         const GHC.IO.Handle.Types.$fShowHandleType11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType11_entry() //  [R1]
         { info_tbl: [(c8et2,
                       label: GHC.IO.Handle.Types.$fShowHandleType11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8et2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8et3; else goto c8et4;
       c8et3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8et4: // global
           (_c8esZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8esZ::I64 == 0) goto c8et1; else goto c8et0;
       c8et1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8et0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8esZ::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.009741106 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType10_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType10_bytes:
         I8[] [115,101,109,105,45,99,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.011841922 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType9_closure" {
     GHC.IO.Handle.Types.$fShowHandleType9_closure:
         const GHC.IO.Handle.Types.$fShowHandleType9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType9_entry() //  [R1]
         { info_tbl: [(c8etk,
                       label: GHC.IO.Handle.Types.$fShowHandleType9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8etk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8etl; else goto c8etm;
       c8etl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8etm: // global
           (_c8eth::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eth::I64 == 0) goto c8etj; else goto c8eti;
       c8etj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eti: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eth::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.016496929 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType8_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType8_bytes:
         I8[] [114,101,97,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.01864924 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType7_closure" {
     GHC.IO.Handle.Types.$fShowHandleType7_closure:
         const GHC.IO.Handle.Types.$fShowHandleType7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType7_entry() //  [R1]
         { info_tbl: [(c8etC,
                       label: GHC.IO.Handle.Types.$fShowHandleType7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8etC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8etD; else goto c8etE;
       c8etD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8etE: // global
           (_c8etz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8etz::I64 == 0) goto c8etB; else goto c8etA;
       c8etB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8etA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8etz::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.023409916 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType6_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType6_bytes:
         I8[] [119,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.025537963 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType5_closure" {
     GHC.IO.Handle.Types.$fShowHandleType5_closure:
         const GHC.IO.Handle.Types.$fShowHandleType5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType5_entry() //  [R1]
         { info_tbl: [(c8etU,
                       label: GHC.IO.Handle.Types.$fShowHandleType5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8etU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8etV; else goto c8etW;
       c8etV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8etW: // global
           (_c8etR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8etR::I64 == 0) goto c8etT; else goto c8etS;
       c8etT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8etS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8etR::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.029898327 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType4_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType4_bytes:
         I8[] [119,114,105,116,97,98,108,101,32,40,97,112,112,101,110,100,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.032340126 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType3_closure" {
     GHC.IO.Handle.Types.$fShowHandleType3_closure:
         const GHC.IO.Handle.Types.$fShowHandleType3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType3_entry() //  [R1]
         { info_tbl: [(c8euc,
                       label: GHC.IO.Handle.Types.$fShowHandleType3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8euc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eud; else goto c8eue;
       c8eud: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eue: // global
           (_c8eu9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eu9::I64 == 0) goto c8eub; else goto c8eua;
       c8eub: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eua: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eu9::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.036494869 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowHandleType2_bytes" {
     GHC.IO.Handle.Types.$fShowHandleType2_bytes:
         I8[] [114,101,97,100,45,119,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.038622023 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType1_closure" {
     GHC.IO.Handle.Types.$fShowHandleType1_closure:
         const GHC.IO.Handle.Types.$fShowHandleType1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType1_entry() //  [R1]
         { info_tbl: [(c8euu,
                       label: GHC.IO.Handle.Types.$fShowHandleType1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8euu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8euv; else goto c8euw;
       c8euv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8euw: // global
           (_c8eur::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eur::I64 == 0) goto c8eut; else goto c8eus;
       c8eut: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eus: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eur::I64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.043610889 UTC

[section ""data" . GHC.IO.Handle.Types.$w$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$w$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c8euU,
                       label: GHC.IO.Handle.Types.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8euU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8euV; else goto c8euW;
       c8euV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8euW: // global
           I64[Sp - 16] = block_c8euJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8evf; else goto c8euK;
       u8evf: // global
           call _c8euJ(R1) args: 0, res: 0, upd: 0;
       c8euK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8euJ() //  [R1]
         { info_tbl: [(c8euJ,
                       label: block_c8euJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8euJ: // global
           _s8eeH::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c8euN;
               case 2 : goto c8euO;
               case 3 : goto c8euP;
               case 4 : goto c8euQ;
               case 5 : goto c8euR;
               case 6 : goto c8euS;
           }
       c8euS: // global
           R3 = _s8eeH::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8euR: // global
           R3 = _s8eeH::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8euQ: // global
           R3 = _s8eeH::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8euP: // global
           R3 = _s8eeH::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8euO: // global
           R3 = _s8eeH::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8euN: // global
           R3 = _s8eeH::P64;
           R2 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.051189384 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_entry() //  [R3,
                                                               R4]
         { info_tbl: [(c8evA,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8evA: // global
           _s8eeK::P64 = R3;
           R3 = R4;
           R2 = _s8eeK::P64;
           call GHC.IO.Handle.Types.$w$cshowsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.055324389 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshow_entry() //  [R2]
         { info_tbl: [(c8evW,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8evW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8evX; else goto c8evY;
       c8evX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8evY: // global
           I64[Sp - 8] = block_c8evL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ewh; else goto c8evM;
       u8ewh: // global
           call _c8evL(R1) args: 0, res: 0, upd: 0;
       c8evM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8evL() //  [R1]
         { info_tbl: [(c8evL,
                       label: block_c8evL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8evL: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c8evP;
               case 2 : goto c8evQ;
               case 3 : goto c8evR;
               case 4 : goto c8evS;
               case 5 : goto c8evT;
               case 6 : goto c8evU;
           }
       c8evU: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8evT: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8evS: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8evR: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8evQ: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8evP: // global
           R1 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.063127753 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowHandleType_$cshowList_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8ewH,
                       label: GHC.IO.Handle.Types.$fShowHandleType_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ewH: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.06721784 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandleType_closure" {
     GHC.IO.Handle.Types.$fShowHandleType_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.071629906 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_$c==_closure" {
     GHC.IO.Handle.Types.$fEqHandle_$c==_closure:
         const GHC.IO.Handle.Types.$fEqHandle_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqHandle_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8ex0,
                       label: GHC.IO.Handle.Types.$fEqHandle_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ex0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ex1; else goto c8ex2;
       c8ex1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqHandle_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ex2: // global
           I64[Sp - 16] = block_c8ewT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8exF; else goto c8ewU;
       u8exF: // global
           call _c8ewT(R1) args: 0, res: 0, upd: 0;
       c8ewU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ewT() //  [R1]
         { info_tbl: [(c8ewT,
                       label: block_c8ewT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ewT: // global
           _s8eeR::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ewX; else goto c8ewY;
       c8ewX: // global
           I64[Sp] = block_c8ex5_info;
           _s8eeU::P64 = P64[R1 + 15];
           R1 = _s8eeR::P64;
           P64[Sp + 8] = _s8eeU::P64;
           if (R1 & 7 != 0) goto u8exD; else goto c8ex7;
       u8exD: // global
           call _c8ex5(R1) args: 0, res: 0, upd: 0;
       c8ex7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ewY: // global
           I64[Sp] = block_c8exk_info;
           _s8ef3::P64 = P64[R1 + 14];
           R1 = _s8eeR::P64;
           P64[Sp + 8] = _s8ef3::P64;
           if (R1 & 7 != 0) goto u8exE; else goto c8exm;
       u8exE: // global
           call _c8exk(R1) args: 0, res: 0, upd: 0;
       c8exm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ex5() //  [R1]
         { info_tbl: [(c8ex5,
                       label: block_c8ex5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ex5: // global
           if (R1 & 7 == 1) goto c8exd; else goto u8exC;
       c8exd: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8exC: // global
           Sp = Sp + 16;
           call _c8exs() args: 0, res: 0, upd: 0;
     }
 },
 _c8exk() //  [R1]
         { info_tbl: [(c8exk,
                       label: block_c8exk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8exk: // global
           if (R1 & 7 == 1) goto u8exB; else goto c8exw;
       u8exB: // global
           Sp = Sp + 16;
           call _c8exs() args: 0, res: 0, upd: 0;
       c8exw: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 14]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8exs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8exs: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.08601895 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqHandle_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqHandle_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqHandle_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8eyx,
                       label: GHC.IO.Handle.Types.$fEqHandle_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eyx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eyy; else goto c8eyz;
       c8eyy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqHandle_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eyz: // global
           I64[Sp - 16] = block_c8eyq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ezI; else goto c8eyr;
       u8ezI: // global
           call _c8eyq(R1) args: 0, res: 0, upd: 0;
       c8eyr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eyq() //  [R1]
         { info_tbl: [(c8eyq,
                       label: block_c8eyq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eyq: // global
           _s8efd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eyu; else goto c8eyv;
       c8eyu: // global
           I64[Sp] = block_c8eyC_info;
           _s8efg::P64 = P64[R1 + 15];
           R1 = _s8efd::P64;
           P64[Sp + 8] = _s8efg::P64;
           if (R1 & 7 != 0) goto u8ezG; else goto c8eyE;
       u8ezG: // global
           call _c8eyC(R1) args: 0, res: 0, upd: 0;
       c8eyE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8eyv: // global
           I64[Sp] = block_c8ez6_info;
           _s8efp::P64 = P64[R1 + 14];
           R1 = _s8efd::P64;
           P64[Sp + 8] = _s8efp::P64;
           if (R1 & 7 != 0) goto u8ezH; else goto c8ez8;
       u8ezH: // global
           call _c8ez6(R1) args: 0, res: 0, upd: 0;
       c8ez8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eyC() //  [R1]
         { info_tbl: [(c8eyC,
                       label: block_c8eyC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eyC: // global
           if (R1 & 7 == 1) goto c8eyZ; else goto u8ezD;
       c8eyZ: // global
           if (P64[Sp + 8] == P64[R1 + 15]) goto u8ezE; else goto u8ezF;
       u8ezE: // global
           Sp = Sp + 16;
           call _c8ezt() args: 0, res: 0, upd: 0;
       u8ezF: // global
           Sp = Sp + 16;
           goto u8ezL;
       u8ezD: // global
           Sp = Sp + 16;
           goto u8ezL;
       u8ezL: // global
           call _c8ezn() args: 0, res: 0, upd: 0;
     }
 },
 _c8ez6() //  [R1]
         { info_tbl: [(c8ez6,
                       label: block_c8ez6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ez6: // global
           if (R1 & 7 == 1) goto u8ezA; else goto c8ezx;
       u8ezA: // global
           Sp = Sp + 16;
           goto u8ezO;
       c8ezx: // global
           if (P64[Sp + 8] == P64[R1 + 14]) goto u8ezB; else goto u8ezC;
       u8ezB: // global
           Sp = Sp + 16;
           call _c8ezt() args: 0, res: 0, upd: 0;
       u8ezC: // global
           Sp = Sp + 16;
           goto u8ezO;
       u8ezO: // global
           call _c8ezn() args: 0, res: 0, upd: 0;
     }
 },
 _c8ezt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ezt: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ezn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ezn: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.098786357 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqHandle_closure" {
     GHC.IO.Handle.Types.$fEqHandle_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqHandle_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqHandle_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.10050471 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewline11_bytes" {
     GHC.IO.Handle.Types.$fReadNewline11_bytes:
         I8[] [76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.102639609 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline10_closure" {
     GHC.IO.Handle.Types.$fReadNewline10_closure:
         const GHC.IO.Handle.Types.$fReadNewline10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline10_entry() //  [R1]
         { info_tbl: [(c8eAx,
                       label: GHC.IO.Handle.Types.$fReadNewline10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eAx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eAy; else goto c8eAz;
       c8eAy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eAz: // global
           (_c8eAu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eAu::I64 == 0) goto c8eAw; else goto c8eAv;
       c8eAw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eAv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eAu::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.107265335 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewline7_bytes" {
     GHC.IO.Handle.Types.$fReadNewline7_bytes:
         I8[] [67,82,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.109606591 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline6_closure" {
     GHC.IO.Handle.Types.$fReadNewline6_closure:
         const GHC.IO.Handle.Types.$fReadNewline6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline6_entry() //  [R1]
         { info_tbl: [(c8eAP,
                       label: GHC.IO.Handle.Types.$fReadNewline6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eAP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eAQ; else goto c8eAR;
       c8eAQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eAR: // global
           (_c8eAM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eAM::I64 == 0) goto c8eAO; else goto c8eAN;
       c8eAO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eAN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eAM::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.11469404 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c8eBb,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eBb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eBc; else goto c8eBd;
       c8eBc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eBd: // global
           I64[Sp - 16] = block_c8eB4_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eBk; else goto c8eB5;
       u8eBk: // global
           call _c8eB4(R1) args: 0, res: 0, upd: 0;
       c8eB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eB4() //  [R1]
         { info_tbl: [(c8eB4,
                       label: block_c8eB4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eB4: // global
           _s8efA::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eB8; else goto c8eB9;
       c8eB8: // global
           R3 = _s8efA::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8eB9: // global
           R3 = _s8efA::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.121084666 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshow_entry() //  [R2]
         { info_tbl: [(c8eBI,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eBI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8eBJ; else goto c8eBK;
       c8eBJ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eBK: // global
           I64[Sp - 8] = block_c8eBB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8eBR; else goto c8eBC;
       u8eBR: // global
           call _c8eBB(R1) args: 0, res: 0, upd: 0;
       c8eBC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eBB() //  [R1]
         { info_tbl: [(c8eBB,
                       label: block_c8eBB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eBB: // global
           if (R1 & 7 == 1) goto c8eBF; else goto c8eBG;
       c8eBF: // global
           R1 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8eBG: // global
           R1 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.12803939 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline1_closure" {
     GHC.IO.Handle.Types.$fShowNewline1_closure:
         const GHC.IO.Handle.Types.$fShowNewline1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline1_entry() //  [R2, R3]
         { info_tbl: [(c8eCh,
                       label: GHC.IO.Handle.Types.$fShowNewline1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eCh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eCi; else goto c8eCj;
       c8eCi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewline1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eCj: // global
           I64[Sp - 16] = block_c8eCa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eCq; else goto c8eCb;
       u8eCq: // global
           call _c8eCa(R1) args: 0, res: 0, upd: 0;
       c8eCb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eCa() //  [R1]
         { info_tbl: [(c8eCa,
                       label: block_c8eCa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eCa: // global
           _s8efF::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eCe; else goto c8eCf;
       c8eCe: // global
           R3 = _s8efF::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c8eCf: // global
           R3 = _s8efF::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.134693647 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowNewline_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewline_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8eCH,
                       label: GHC.IO.Handle.Types.$fShowNewline_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eCH: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowNewline1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.138334014 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewline_closure" {
     GHC.IO.Handle.Types.$fShowNewline_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.140239907 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode4_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode4_bytes:
         I8[] [78,101,119,108,105,110,101,77,111,100,101,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.142313811 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode3_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode3_bytes:
         I8[] [105,110,112,117,116,78,76,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.144032052 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowNewlineMode2_bytes" {
     GHC.IO.Handle.Types.$fShowNewlineMode2_bytes:
         I8[] [111,117,116,112,117,116,78,76,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.14585697 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode5_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.150612696 UTC

[section ""data" . GHC.IO.Handle.Types.$w$cshowsPrec1_closure" {
     GHC.IO.Handle.Types.$w$cshowsPrec1_closure:
         const GHC.IO.Handle.Types.$w$cshowsPrec1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$w$cshowsPrec1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eCU: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8efR_entry() //  [R1]
         { info_tbl: [(c8eDw,
                       label: sat_s8efR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eDw: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8efS_entry() //  [R1]
         { info_tbl: [(c8eDF,
                       label: sat_s8efS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eDF: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8efT_entry() //  [R1]
         { info_tbl: [(c8eDM,
                       label: sat_s8efT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eDM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8eDN; else goto c8eDO;
       c8eDN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eDO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8eDn_info;
           _s8efO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8efO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8eDV; else goto c8eDo;
       u8eDV: // global
           call _c8eDn(R1) args: 0, res: 0, upd: 0;
       c8eDo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8eDn() //  [R1]
         { info_tbl: [(c8eDn,
                       label: block_c8eDn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eDn: // global
           _s8efO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eDJ; else goto c8eDK;
       c8eDJ: // global
           Hp = Hp + 24;
           _s8efQ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8eDU; else goto c8eDQ;
       c8eDQ: // global
           I64[Hp - 16] = sat_s8efR_info;
           P64[Hp] = _s8efO::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c8eDK: // global
           Hp = Hp + 24;
           _s8efQ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8eDU; else goto c8eDT;
       c8eDU: // global
           HpAlloc = 24;
           R1 = _s8efQ::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8eDT: // global
           I64[Hp - 16] = sat_s8efS_info;
           P64[Hp] = _s8efO::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8efU_entry() //  [R1]
         { info_tbl: [(c8eDW,
                       label: sat_s8efU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eDW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8eE0; else goto c8eDZ;
       c8eE0: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eDZ: // global
           _s8efL::P64 = P64[R1 + 16];
           _s8efO::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8efT_info;
           P64[Hp - 8] = _s8efL::P64;
           P64[Hp] = _s8efO::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 karg_s8efP_entry() //  [R1]
         { info_tbl: [(c8eE1,
                       label: karg_s8efP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eE1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8eE5; else goto c8eE4;
       c8eE5: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eE4: // global
           _s8efL::P64 = P64[R1 + 16];
           _s8efO::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s8efU_info;
           P64[Hp - 8] = _s8efL::P64;
           P64[Hp] = _s8efO::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8efW_entry() //  [R1]
         { info_tbl: [(c8eEd,
                       label: sat_s8efW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eEd: // global
           _s8efW::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c8eEe; else goto c8eEf;
       c8eEf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8eEh; else goto c8eEg;
       c8eEh: // global
           HpAlloc = 32;
           goto c8eEe;
       c8eEe: // global
           R1 = _s8efW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eEg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8efW::P64;
           _s8efK::P64 = P64[_s8efW::P64 + 16];
           _s8efL::P64 = P64[_s8efW::P64 + 24];
           _s8efO::P64 = P64[_s8efW::P64 + 32];
           I64[Hp - 24] = karg_s8efP_info;
           P64[Hp - 8] = _s8efL::P64;
           P64[Hp] = _s8efO::P64;
           I64[Sp - 32] = block_c8eE6_info;
           R1 = _s8efK::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8eEo; else goto c8eE7;
       u8eEo: // global
           call _c8eE6(R1) args: 0, res: 0, upd: 0;
       c8eE7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8eE6() //  [R1]
         { info_tbl: [(c8eE6,
                       label: block_c8eE6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eE6: // global
           _c8eDb::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eEa; else goto c8eEb;
       c8eEa: // global
           R3 = _c8eDb::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c8eEb: // global
           R3 = _c8eDb::P64;
           R2 = GHC.IO.Handle.Types.$fReadNewline6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8efX_entry() //  [R1]
         { info_tbl: [(c8eEp,
                       label: sat_s8efX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eEp: // global
           _s8efX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8eEq; else goto c8eEr;
       c8eEr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8eEt; else goto c8eEs;
       c8eEt: // global
           HpAlloc = 40;
           goto c8eEq;
       c8eEq: // global
           R1 = _s8efX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eEs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8efX::P64;
           _s8efK::P64 = P64[_s8efX::P64 + 16];
           _s8efL::P64 = P64[_s8efX::P64 + 24];
           _s8efO::P64 = P64[_s8efX::P64 + 32];
           I64[Hp - 32] = sat_s8efW_info;
           P64[Hp - 16] = _s8efK::P64;
           P64[Hp - 8] = _s8efL::P64;
           P64[Hp] = _s8efO::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_s8efN_entry() //  [R1, R2]
         { info_tbl: [(c8eEu,
                       label: p_s8efN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eEu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8eEy; else goto c8eEx;
       c8eEy: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eEx: // global
           _s8efK::P64 = P64[R1 + 7];
           _s8efL::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s8efX_info;
           P64[Hp - 16] = _s8efK::P64;
           P64[Hp - 8] = _s8efL::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8eg0_entry() //  [R1]
         { info_tbl: [(c8eEI,
                       label: sat_s8eg0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eEI: // global
           _s8eg0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8eEJ; else goto c8eEK;
       c8eEK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8eEM; else goto c8eEL;
       c8eEM: // global
           HpAlloc = 24;
           goto c8eEJ;
       c8eEJ: // global
           R1 = _s8eg0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eEL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8eg0::P64;
           _s8efM::P64 = P64[_s8eg0::P64 + 16];
           _s8efN::P64 = P64[_s8eg0::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s8efM::P64;
           R2 = Hp - 14;
           R1 = _s8efN::P64;
           Sp = Sp - 16;
           call p_s8efN_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$w$cshowsPrec1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8eEQ,
                       label: GHC.IO.Handle.Types.$w$cshowsPrec1_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eEQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8eEU; else goto c8eET;
       c8eEU: // global
           HpAlloc = 80;
           R1 = GHC.IO.Handle.Types.$w$cshowsPrec1_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c8eET: // global
           I64[Hp - 72] = p_s8efN_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           _c8eCY::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto c8eEO; else goto c8eEP;
       c8eEO: // global
           Hp = Hp - 56;
           R2 = R5;
           R1 = _c8eCY::P64;
           call p_s8efN_entry(R2, R1) args: 8, res: 0, upd: 8;
       c8eEP: // global
           I64[Hp - 48] = sat_s8eg0_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _c8eCY::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.182177211 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c8eGc,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eGc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8eGg; else goto c8eGh;
       c8eGg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eGh: // global
           I64[Sp - 24] = block_c8eG9_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8eGp; else goto c8eGa;
       u8eGp: // global
           call _c8eG9(R1) args: 0, res: 0, upd: 0;
       c8eGa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eG9() //  [R1]
         { info_tbl: [(c8eG9,
                       label: block_c8eG9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eG9: // global
           I64[Sp] = block_c8eGf_info;
           _s8eg5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8eg5::I64;
           if (R1 & 7 != 0) goto u8eGo; else goto c8eGj;
       u8eGo: // global
           call _c8eGf(R1) args: 0, res: 0, upd: 0;
       c8eGj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eGf() //  [R1]
         { info_tbl: [(c8eGf,
                       label: block_c8eGf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eGf: // global
           R5 = P64[Sp + 16];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.190847054 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode2_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.193079656 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8eGN,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eGN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8eGO; else goto c8eGP;
       c8eGO: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eGP: // global
           I64[Sp - 8] = block_c8eGK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8eGT; else goto c8eGL;
       u8eGT: // global
           call _c8eGK(R1) args: 0, res: 0, upd: 0;
       c8eGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eGK() //  [R1]
         { info_tbl: [(c8eGK,
                       label: block_c8eGK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eGK: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.199631704 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode1_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode1_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(c8eHc,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eHc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eHd; else goto c8eHe;
       c8eHd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowNewlineMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eHe: // global
           I64[Sp - 16] = block_c8eH9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eHi; else goto c8eHa;
       u8eHi: // global
           call _c8eH9(R1) args: 0, res: 0, upd: 0;
       c8eHa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eH9() //  [R1]
         { info_tbl: [(c8eH9,
                       label: block_c8eH9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eH9: // global
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.$w$cshowsPrec1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.206305517 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8eHx,
                       label: GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eHx: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowNewlineMode1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.209966991 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowNewlineMode_closure" {
     GHC.IO.Handle.Types.$fShowNewlineMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.212440076 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline9_closure" {
     GHC.IO.Handle.Types.$fReadNewline9_closure:
         const GHC.IO.Handle.Types.$fReadNewline9_info;
 },
 GHC.IO.Handle.Types.$fReadNewline9_entry() //  [R3]
         { info_tbl: [(c8eHJ,
                       label: GHC.IO.Handle.Types.$fReadNewline9_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eHJ: // global
           R2 = GHC.IO.Handle.Types.LF_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.215813736 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline8_closure" {
     GHC.IO.Handle.Types.$fReadNewline8_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadNewline10_closure;
         const GHC.IO.Handle.Types.$fReadNewline9_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.21827458 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline5_closure" {
     GHC.IO.Handle.Types.$fReadNewline5_closure:
         const GHC.IO.Handle.Types.$fReadNewline5_info;
 },
 GHC.IO.Handle.Types.$fReadNewline5_entry() //  [R3]
         { info_tbl: [(c8eHV,
                       label: GHC.IO.Handle.Types.$fReadNewline5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eHV: // global
           R2 = GHC.IO.Handle.Types.CRLF_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.22204283 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline4_closure" {
     GHC.IO.Handle.Types.$fReadNewline4_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadNewline6_closure;
         const GHC.IO.Handle.Types.$fReadNewline5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.223800808 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline3_closure" {
     GHC.IO.Handle.Types.$fReadNewline3_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadNewline4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.225740142 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_sps_closure" {
     GHC.IO.Handle.Types.$fReadNewline_sps_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadNewline8_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.228174124 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline2_closure" {
     GHC.IO.Handle.Types.$fReadNewline2_closure:
         const GHC.IO.Handle.Types.$fReadNewline2_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline2_entry() //  [R2]
         { info_tbl: [(c8eI9,
                       label: GHC.IO.Handle.Types.$fReadNewline2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eI9: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.232204251 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline1_closure" {
     GHC.IO.Handle.Types.$fReadNewline1_closure:
         const GHC.IO.Handle.Types.$fReadNewline1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline1_entry() //  [R2, R3]
         { info_tbl: [(c8eIk,
                       label: GHC.IO.Handle.Types.$fReadNewline1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eIk: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.236164552 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_info;
         const 0;
 },
 sat_s8egq_entry() //  [R1]
         { info_tbl: [(c8eIz,
                       label: sat_s8egq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eIz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eIA; else goto c8eIB;
       c8eIA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eIB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8eIC,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eIC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8eIG; else goto c8eIF;
       c8eIG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eIF: // global
           I64[Hp - 16] = sat_s8egq_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.242699863 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8eIZ,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eIZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eJ0; else goto c8eJ1;
       c8eJ0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eJ1: // global
           (_c8eIW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eIW::I64 == 0) goto c8eIY; else goto c8eIX;
       c8eIY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eIX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eIW::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewline1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.247486199 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline12_closure" {
     GHC.IO.Handle.Types.$fReadNewline12_closure:
         const GHC.IO.Handle.Types.$fReadNewline12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline12_entry() //  [R1]
         { info_tbl: [(c8eJg,
                       label: GHC.IO.Handle.Types.$fReadNewline12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eJg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eJh; else goto c8eJi;
       c8eJh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eJi: // global
           (_c8eJd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eJd::I64 == 0) goto c8eJf; else goto c8eJe;
       c8eJf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eJe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eJd::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.252247193 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadNewline_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadNewline_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewline_$creadList_entry() //  [R2]
         { info_tbl: [(c8eJw,
                       label: GHC.IO.Handle.Types.$fReadNewline_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eJw: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewline12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.256234821 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewline_closure" {
     GHC.IO.Handle.Types.$fReadNewline_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadNewline1_closure+2;
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.25813615 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode17_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode17_bytes:
         I8[] [78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.260265907 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode16_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode16_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode16_entry() //  [R1]
         { info_tbl: [(c8eJL,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eJL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eJM; else goto c8eJN;
       c8eJM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eJN: // global
           (_c8eJI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eJI::I64 == 0) goto c8eJK; else goto c8eJJ;
       c8eJK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eJJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eJI::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.265517061 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode16_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.267374541 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode15_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode15_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.26950005 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode14_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode14_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode14_entry() //  [R1]
         { info_tbl: [(c8eK4,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eK4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eK5; else goto c8eK6;
       c8eK5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eK6: // global
           (_c8eK1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eK1::I64 == 0) goto c8eK3; else goto c8eK2;
       c8eK3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eK2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eK1::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.274033167 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.275930217 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode13_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode13_bytes:
         I8[] [105,110,112,117,116,78,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.278126076 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode12_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode12_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode12_entry() //  [R1]
         { info_tbl: [(c8eKn,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eKo; else goto c8eKp;
       c8eKo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eKp: // global
           (_c8eKk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eKk::I64 == 0) goto c8eKm; else goto c8eKl;
       c8eKm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eKl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eKk::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.283054889 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode11_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode11_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode11_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode11_entry() //  [R3]
         { info_tbl: [(c8eKC,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eKC: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.IO.Handle.Types.$fReadNewline2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.286598936 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_n_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_n_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.288720975 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode10_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode10_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.290751877 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode9_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode9_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode9_entry() //  [R1]
         { info_tbl: [(c8eKR,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eKR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eKS; else goto c8eKT;
       c8eKS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eKT: // global
           (_c8eKO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eKO::I64 == 0) goto c8eKQ; else goto c8eKP;
       c8eKQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eKP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eKO::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.295088058 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode8_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode8_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode9_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.297372034 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadNewlineMode7_bytes" {
     GHC.IO.Handle.Types.$fReadNewlineMode7_bytes:
         I8[] [111,117,116,112,117,116,78,76]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.299403509 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode6_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode6_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode6_entry() //  [R1]
         { info_tbl: [(c8eLa,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eLa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eLb; else goto c8eLc;
       c8eLb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eLc: // global
           (_c8eL7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eL7::I64 == 0) goto c8eL9; else goto c8eL8;
       c8eL9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eL8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eL7::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.303585751 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode4_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode4_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode4_entry() //  [R1]
         { info_tbl: [(c8eLr,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eLr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eLs; else goto c8eLt;
       c8eLs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eLt: // global
           (_c8eLo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8eLo::I64 == 0) goto c8eLq; else goto c8eLp;
       c8eLq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8eLp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8eLo::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.307776719 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode3_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode3_closure:
         const Text.Read.Lex.Punc_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.311342892 UTC

[section ""data" . GHC.IO.Handle.Types.$w$creadPrec_closure" {
     GHC.IO.Handle.Types.$w$creadPrec_closure:
         const GHC.IO.Handle.Types.$w$creadPrec_info;
         const 0;
 },
 sat_s8egD_entry() //  [R1, R2]
         { info_tbl: [(c8eMg,
                       label: sat_s8egD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eMg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8eMk; else goto c8eMj;
       c8eMk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eMj: // global
           _s8egu::P64 = P64[R1 + 7];
           _s8egy::P64 = P64[R1 + 15];
           _s8egA::P64 = P64[R1 + 23];
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = _s8egy::P64;
           P64[Hp] = _s8egA::P64;
           R2 = Hp - 15;
           R1 = _s8egu::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8egG_entry() //  [R1, R2]
         { info_tbl: [(c8eMo,
                       label: sat_s8egG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eMo: // global
           _s8egA::P64 = R2;
           _s8egG::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8eMp; else goto c8eMq;
       c8eMq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8eMs; else goto c8eMr;
       c8eMs: // global
           HpAlloc = 32;
           goto c8eMp;
       c8eMp: // global
           R2 = _s8egA::P64;
           R1 = _s8egG::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eMr: // global
           _s8egu::P64 = P64[_s8egG::P64 + 7];
           _s8egy::P64 = P64[_s8egG::P64 + 15];
           I64[Hp - 24] = sat_s8egD_info;
           P64[Hp - 16] = _s8egu::P64;
           P64[Hp - 8] = _s8egy::P64;
           P64[Hp] = _s8egA::P64;
           I64[Sp - 8] = block_c8eMl_info;
           R3 = Hp - 23;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8eMl() //  [R1]
         { info_tbl: [(c8eMl,
                       label: block_c8eMl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eMl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8eMv; else goto c8eMu;
       c8eMv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8eMu: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8egH_entry() //  [R1, R2]
         { info_tbl: [(c8eMw,
                       label: sat_s8egH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eMw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8eMA; else goto c8eMz;
       c8eMA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eMz: // global
           _s8egu::P64 = P64[R1 + 7];
           _s8egy::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8egG_info;
           P64[Hp - 8] = _s8egu::P64;
           P64[Hp] = _s8egy::P64;
           R5 = Hp - 15;
           R4 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode11_closure+2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8egK_entry() //  [R1, R2]
         { info_tbl: [(c8eME,
                       label: sat_s8egK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eME: // global
           _s8egy::P64 = R2;
           _s8egK::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8eMF; else goto c8eMG;
       c8eMG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8eMI; else goto c8eMH;
       c8eMI: // global
           HpAlloc = 24;
           goto c8eMF;
       c8eMF: // global
           R2 = _s8egy::P64;
           R1 = _s8egK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eMH: // global
           _s8egu::P64 = P64[_s8egK::P64 + 7];
           I64[Hp - 16] = sat_s8egH_info;
           P64[Hp - 8] = _s8egu::P64;
           P64[Hp] = _s8egy::P64;
           I64[Sp - 8] = block_c8eMB_info;
           R3 = Hp - 15;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode8_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8eMB() //  [R1]
         { info_tbl: [(c8eMB,
                       label: block_c8eMB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eMB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8eML; else goto c8eMK;
       c8eML: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8eMK: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8egL_entry() //  [R1, R2]
         { info_tbl: [(c8eMM,
                       label: sat_s8egL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eMM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8eMQ; else goto c8eMP;
       c8eMQ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eMP: // global
           _s8egu::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8egK_info;
           P64[Hp] = _s8egu::P64;
           R5 = Hp - 7;
           R4 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode11_closure+2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode12_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8egO_entry() //  [R1, R2]
         { info_tbl: [(c8eMU,
                       label: sat_s8egO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eMU: // global
           _s8egw::P64 = R2;
           _s8egO::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c8eMV; else goto c8eMW;
       c8eMW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8eMY; else goto c8eMX;
       c8eMY: // global
           HpAlloc = 16;
           goto c8eMV;
       c8eMV: // global
           R2 = _s8egw::P64;
           R1 = _s8egO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eMX: // global
           _s8egu::P64 = P64[_s8egO::P64 + 7];
           I64[Hp - 8] = sat_s8egL_info;
           P64[Hp] = _s8egu::P64;
           I64[Sp - 8] = block_c8eMR_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8eMR() //  [R1]
         { info_tbl: [(c8eMR,
                       label: block_c8eMR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eMR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8eN1; else goto c8eN0;
       c8eN1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8eN0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(c8eN5,
                       label: GHC.IO.Handle.Types.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eN5: // global
           _s8egu::P64 = R3;
           _s8egt::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c8eN6; else goto c8eN7;
       c8eN7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8eN9; else goto c8eN8;
       c8eN9: // global
           HpAlloc = 16;
           goto c8eN6;
       c8eN6: // global
           R3 = _s8egu::P64;
           R2 = _s8egt::I64;
           R1 = GHC.IO.Handle.Types.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eN8: // global
           if (%MO_S_Gt_W64(_s8egt::I64, 11)) goto c8eN3; else goto c8eN4;
       c8eN3: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8eN4: // global
           I64[Hp - 8] = sat_s8egO_info;
           P64[Hp] = _s8egu::P64;
           I64[Sp - 8] = block_c8eNa_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8eNa() //  [R1]
         { info_tbl: [(c8eNa,
                       label: block_c8eNa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eNa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8eNf; else goto c8eNe;
       c8eNf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8eNe: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.338887723 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode2_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode2_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode2_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode2_entry() //  [R2, R3]
         { info_tbl: [(c8eOk,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eOk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eOl; else goto c8eOm;
       c8eOl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eOm: // global
           I64[Sp - 16] = block_c8eOh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eOq; else goto c8eOi;
       u8eOq: // global
           call _c8eOh(R1) args: 0, res: 0, upd: 0;
       c8eOi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eOh() //  [R1]
         { info_tbl: [(c8eOh,
                       label: block_c8eOh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eOh: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.$w$creadPrec_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.345183927 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode1_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode1_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(c8eOF,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eOF: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.34959126 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_info;
         const 0;
 },
 sat_s8egW_entry() //  [R1]
         { info_tbl: [(c8eOU,
                       label: sat_s8egW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eOU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eOV; else goto c8eOW;
       c8eOV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8eOW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8eOX,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eOX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8eP1; else goto c8eP0;
       c8eP1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8eP0: // global
           I64[Hp - 16] = sat_s8egW_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.356159987 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8ePk,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ePk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ePl; else goto c8ePm;
       c8ePl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ePm: // global
           (_c8ePh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ePh::I64 == 0) goto c8ePj; else goto c8ePi;
       c8ePj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ePi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ePh::I64;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.360937661 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode18_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode18_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode18_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode18_entry() //  [R1]
         { info_tbl: [(c8ePB,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ePB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ePC; else goto c8ePD;
       c8ePC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ePD: // global
           (_c8ePy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ePy::I64 == 0) goto c8ePA; else goto c8ePz;
       c8ePA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ePz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ePy::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.36741275 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_entry() //  [R2]
         { info_tbl: [(c8ePR,
                       label: GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ePR: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode18_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.371341033 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadNewlineMode_closure" {
     GHC.IO.Handle.Types.$fReadNewlineMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadNewlineMode1_closure+2;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.373825881 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8eQa,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eQa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eQb; else goto c8eQc;
       c8eQb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eQc: // global
           I64[Sp - 16] = block_c8eQ3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eQE; else goto c8eQ4;
       u8eQE: // global
           call _c8eQ3(R1) args: 0, res: 0, upd: 0;
       c8eQ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eQ3() //  [R1]
         { info_tbl: [(c8eQ3,
                       label: block_c8eQ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eQ3: // global
           _s8egY::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eQ7; else goto c8eQ8;
       c8eQ7: // global
           I64[Sp + 8] = block_c8eQf_info;
           R1 = _s8egY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eQC; else goto c8eQh;
       u8eQC: // global
           call _c8eQf(R1) args: 0, res: 0, upd: 0;
       c8eQh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8eQ8: // global
           I64[Sp + 8] = block_c8eQu_info;
           R1 = _s8egY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eQD; else goto c8eQw;
       u8eQD: // global
           call _c8eQu() args: 0, res: 0, upd: 0;
       c8eQw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eQf() //  [R1]
         { info_tbl: [(c8eQf,
                       label: block_c8eQf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eQf: // global
           if (R1 & 7 == 1) goto c8eQn; else goto c8eQr;
       c8eQn: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8eQr: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8eQu() //  []
         { info_tbl: [(c8eQu,
                       label: block_c8eQu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eQu: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.385218972 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8eRk,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eRk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eRl; else goto c8eRm;
       c8eRl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eRm: // global
           I64[Sp - 16] = block_c8eRd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eRX; else goto c8eRe;
       u8eRX: // global
           call _c8eRd(R1) args: 0, res: 0, upd: 0;
       c8eRe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eRd() //  [R1]
         { info_tbl: [(c8eRd,
                       label: block_c8eRd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eRd: // global
           _s8eh3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eRh; else goto c8eRi;
       c8eRh: // global
           I64[Sp + 8] = block_c8eRp_info;
           R1 = _s8eh3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eRV; else goto c8eRr;
       u8eRV: // global
           call _c8eRp(R1) args: 0, res: 0, upd: 0;
       c8eRr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8eRi: // global
           I64[Sp + 8] = block_c8eRE_info;
           R1 = _s8eh3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eRW; else goto c8eRG;
       u8eRW: // global
           call _c8eRE(R1) args: 0, res: 0, upd: 0;
       c8eRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eRp() //  [R1]
         { info_tbl: [(c8eRp,
                       label: block_c8eRp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eRp: // global
           if (R1 & 7 == 1) goto u8eRU; else goto c8eRB;
       u8eRU: // global
           Sp = Sp + 8;
           call _c8eRQ() args: 0, res: 0, upd: 0;
       c8eRB: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8eRE() //  [R1]
         { info_tbl: [(c8eRE,
                       label: block_c8eRE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eRE: // global
           if (R1 & 7 == 1) goto c8eRM; else goto u8eRT;
       c8eRM: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8eRT: // global
           Sp = Sp + 8;
           call _c8eRQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8eRQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eRQ: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.397029832 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_$c==_closure" {
     GHC.IO.Handle.Types.$fEqNewline_$c==_closure:
         const GHC.IO.Handle.Types.$fEqNewline_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqNewline_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8eSJ,
                       label: GHC.IO.Handle.Types.$fEqNewline_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eSJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eSK; else goto c8eSL;
       c8eSK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewline_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eSL: // global
           I64[Sp - 16] = block_c8eSC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eTo; else goto c8eSD;
       u8eTo: // global
           call _c8eSC(R1) args: 0, res: 0, upd: 0;
       c8eSD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eSC() //  [R1]
         { info_tbl: [(c8eSC,
                       label: block_c8eSC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eSC: // global
           _s8eh8::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eSG; else goto c8eSH;
       c8eSG: // global
           I64[Sp + 8] = block_c8eSO_info;
           R1 = _s8eh8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eTm; else goto c8eSQ;
       u8eTm: // global
           call _c8eSO(R1) args: 0, res: 0, upd: 0;
       c8eSQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8eSH: // global
           I64[Sp + 8] = block_c8eT3_info;
           R1 = _s8eh8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eTn; else goto c8eT5;
       u8eTn: // global
           call _c8eT3(R1) args: 0, res: 0, upd: 0;
       c8eT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eSO() //  [R1]
         { info_tbl: [(c8eSO,
                       label: block_c8eSO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eSO: // global
           if (R1 & 7 == 1) goto u8eTk; else goto u8eTl;
       u8eTk: // global
           Sp = Sp + 8;
           call _c8eTf() args: 0, res: 0, upd: 0;
       u8eTl: // global
           Sp = Sp + 8;
           call _c8eTb() args: 0, res: 0, upd: 0;
     }
 },
 _c8eT3() //  [R1]
         { info_tbl: [(c8eT3,
                       label: block_c8eT3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eT3: // global
           if (R1 & 7 == 1) goto u8eTi; else goto u8eTj;
       u8eTi: // global
           Sp = Sp + 8;
           call _c8eTb() args: 0, res: 0, upd: 0;
       u8eTj: // global
           Sp = Sp + 8;
           call _c8eTf() args: 0, res: 0, upd: 0;
     }
 },
 _c8eTb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eTb: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8eTf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eTf: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.409935827 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqNewline_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqNewline_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqNewline_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8eUc,
                       label: GHC.IO.Handle.Types.$fEqNewline_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eUc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eUd; else goto c8eUe;
       c8eUd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewline_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eUe: // global
           I64[Sp - 16] = block_c8eU5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eUR; else goto c8eU6;
       u8eUR: // global
           call _c8eU5(R1) args: 0, res: 0, upd: 0;
       c8eU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eU5() //  [R1]
         { info_tbl: [(c8eU5,
                       label: block_c8eU5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eU5: // global
           _s8ehd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eU9; else goto c8eUa;
       c8eU9: // global
           I64[Sp + 8] = block_c8eUh_info;
           R1 = _s8ehd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eUP; else goto c8eUj;
       u8eUP: // global
           call _c8eUh(R1) args: 0, res: 0, upd: 0;
       c8eUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8eUa: // global
           I64[Sp + 8] = block_c8eUw_info;
           R1 = _s8ehd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eUQ; else goto c8eUy;
       u8eUQ: // global
           call _c8eUw(R1) args: 0, res: 0, upd: 0;
       c8eUy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eUh() //  [R1]
         { info_tbl: [(c8eUh,
                       label: block_c8eUh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eUh: // global
           if (R1 & 7 == 1) goto u8eUN; else goto u8eUO;
       u8eUN: // global
           Sp = Sp + 8;
           call _c8eUI() args: 0, res: 0, upd: 0;
       u8eUO: // global
           Sp = Sp + 8;
           call _c8eUE() args: 0, res: 0, upd: 0;
     }
 },
 _c8eUw() //  [R1]
         { info_tbl: [(c8eUw,
                       label: block_c8eUw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eUw: // global
           if (R1 & 7 == 1) goto u8eUL; else goto u8eUM;
       u8eUL: // global
           Sp = Sp + 8;
           call _c8eUE() args: 0, res: 0, upd: 0;
       u8eUM: // global
           Sp = Sp + 8;
           call _c8eUI() args: 0, res: 0, upd: 0;
     }
 },
 _c8eUE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eUE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8eUI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eUI: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.422326697 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewline_closure" {
     GHC.IO.Handle.Types.$fEqNewline_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqNewline_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqNewline_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.424695658 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8eVG,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eVG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eVH; else goto c8eVI;
       c8eVH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eVI: // global
           I64[Sp - 16] = block_c8eVz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eWa; else goto c8eVA;
       u8eWa: // global
           call _c8eVz(R1) args: 0, res: 0, upd: 0;
       c8eVA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eVz() //  [R1]
         { info_tbl: [(c8eVz,
                       label: block_c8eVz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eVz: // global
           _s8ehh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eVD; else goto c8eVE;
       c8eVD: // global
           I64[Sp + 8] = block_c8eVL_info;
           R1 = _s8ehh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eW8; else goto c8eVN;
       u8eW8: // global
           call _c8eVL(R1) args: 0, res: 0, upd: 0;
       c8eVN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8eVE: // global
           I64[Sp + 8] = block_c8eW0_info;
           R1 = _s8ehh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eW9; else goto c8eW2;
       u8eW9: // global
           call _c8eW0() args: 0, res: 0, upd: 0;
       c8eW2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eVL() //  [R1]
         { info_tbl: [(c8eVL,
                       label: block_c8eVL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eVL: // global
           if (R1 & 7 == 1) goto c8eVT; else goto c8eVX;
       c8eVT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8eVX: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8eW0() //  []
         { info_tbl: [(c8eW0,
                       label: block_c8eW0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eW0: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.434397591 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8eWQ,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eWQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eWR; else goto c8eWS;
       c8eWR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eWS: // global
           I64[Sp - 16] = block_c8eWJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eX6; else goto c8eWK;
       u8eX6: // global
           call _c8eWJ(R1) args: 0, res: 0, upd: 0;
       c8eWK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eWJ() //  [R1]
         { info_tbl: [(c8eWJ,
                       label: block_c8eWJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eWJ: // global
           _s8ehm::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eWN; else goto c8eWO;
       c8eWN: // global
           R1 = _s8ehm::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8eWO: // global
           I64[Sp + 8] = block_c8eWY_info;
           R1 = _s8ehm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eX5; else goto c8eX0;
       u8eX5: // global
           call _c8eWY() args: 0, res: 0, upd: 0;
       c8eX0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eWY() //  []
         { info_tbl: [(c8eWY,
                       label: block_c8eWY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eWY: // global
           R1 = GHC.IO.Handle.Types.CRLF_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.442207498 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8eXC,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eXC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eXD; else goto c8eXE;
       c8eXD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eXE: // global
           I64[Sp - 16] = block_c8eXv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eY6; else goto c8eXw;
       u8eY6: // global
           call _c8eXv(R1) args: 0, res: 0, upd: 0;
       c8eXw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eXv() //  [R1]
         { info_tbl: [(c8eXv,
                       label: block_c8eXv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eXv: // global
           _s8ehr::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eXz; else goto c8eXA;
       c8eXz: // global
           I64[Sp + 8] = block_c8eXH_info;
           R1 = _s8ehr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eY4; else goto c8eXJ;
       u8eY4: // global
           call _c8eXH(R1) args: 0, res: 0, upd: 0;
       c8eXJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8eXA: // global
           I64[Sp + 8] = block_c8eXW_info;
           R1 = _s8ehr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eY5; else goto c8eXY;
       u8eY5: // global
           call _c8eXW() args: 0, res: 0, upd: 0;
       c8eXY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eXH() //  [R1]
         { info_tbl: [(c8eXH,
                       label: block_c8eXH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eXH: // global
           if (R1 & 7 == 1) goto c8eXP; else goto c8eXT;
       c8eXP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8eXT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8eXW() //  []
         { info_tbl: [(c8eXW,
                       label: block_c8eXW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eXW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.451446608 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8eYF,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eYF: // global
           _s8ehw::P64 = R3;
           R3 = R2;
           R2 = _s8ehw::P64;
           call GHC.IO.Handle.Types.$fOrdNewline_$c<_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.455154105 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdNewline_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdNewline_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8eYX,
                       label: GHC.IO.Handle.Types.$fOrdNewline_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eYX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8eYY; else goto c8eYZ;
       c8eYY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eYZ: // global
           I64[Sp - 16] = block_c8eYQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8eZd; else goto c8eYR;
       u8eZd: // global
           call _c8eYQ(R1) args: 0, res: 0, upd: 0;
       c8eYR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eYQ() //  [R1]
         { info_tbl: [(c8eYQ,
                       label: block_c8eYQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eYQ: // global
           _s8ehx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8eYU; else goto c8eYV;
       c8eYU: // global
           I64[Sp + 8] = block_c8eZ2_info;
           R1 = _s8ehx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8eZc; else goto c8eZ4;
       u8eZc: // global
           call _c8eZ2() args: 0, res: 0, upd: 0;
       c8eZ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8eYV: // global
           R1 = _s8ehx::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8eZ2() //  []
         { info_tbl: [(c8eZ2,
                       label: block_c8eZ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eZ2: // global
           R1 = GHC.IO.Handle.Types.LF_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.462254545 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewline_closure" {
     GHC.IO.Handle.Types.$fOrdNewline_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqNewline_closure+1;
         const GHC.IO.Handle.Types.$fOrdNewline_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewline_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.464634507 UTC

[section ""data" . GHC.IO.Handle.Types.$w$ccompare_closure" {
     GHC.IO.Handle.Types.$w$ccompare_closure:
         const GHC.IO.Handle.Types.$w$ccompare_info;
 },
 GHC.IO.Handle.Types.$w$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8eZK,
                       label: GHC.IO.Handle.Types.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eZK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8eZL; else goto c8eZM;
       c8eZL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$ccompare_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8eZM: // global
           I64[Sp - 32] = block_c8eZD_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8f0n; else goto c8eZE;
       u8f0n: // global
           call _c8eZD(R1) args: 0, res: 0, upd: 0;
       c8eZE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eZD() //  [R1]
         { info_tbl: [(c8eZD,
                       label: block_c8eZD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eZD: // global
           _s8ehD::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8eZH; else goto c8eZI;
       c8eZH: // global
           I64[Sp] = block_c8eZP_info;
           R1 = _s8ehD::P64;
           if (R1 & 7 != 0) goto u8f0l; else goto c8eZR;
       u8f0l: // global
           call _c8eZP(R1) args: 0, res: 0, upd: 0;
       c8eZR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8eZI: // global
           I64[Sp] = block_c8f04_info;
           R1 = _s8ehD::P64;
           if (R1 & 7 != 0) goto u8f0m; else goto c8f06;
       u8f0m: // global
           call _c8f04(R1) args: 0, res: 0, upd: 0;
       c8f06: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8eZP() //  [R1]
         { info_tbl: [(c8eZP,
                       label: block_c8eZP_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8eZP: // global
           if (R1 & 7 == 1) goto u8f0k; else goto c8f01;
       u8f0k: // global
           Sp = Sp + 8;
           call _c8f0g() args: 0, res: 0, upd: 0;
       c8f01: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8f04() //  [R1]
         { info_tbl: [(c8f04,
                       label: block_c8f04_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f04: // global
           if (R1 & 7 == 1) goto c8f0c; else goto u8f0j;
       c8f0c: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8f0j: // global
           Sp = Sp + 8;
           call _c8f0g() args: 0, res: 0, upd: 0;
     }
 },
 _c8f0g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f0g: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fOrdNewline_$ccompare_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.475255167 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8f13,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f13: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8f17; else goto c8f18;
       c8f17: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8f18: // global
           I64[Sp - 16] = block_c8f10_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8f1g; else goto c8f11;
       u8f1g: // global
           call _c8f10(R1) args: 0, res: 0, upd: 0;
       c8f11: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f10() //  [R1]
         { info_tbl: [(c8f10,
                       label: block_c8f10_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f10: // global
           I64[Sp - 8] = block_c8f16_info;
           _s8ehL::P64 = P64[R1 + 7];
           _s8ehM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8ehM::P64;
           P64[Sp + 8] = _s8ehL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8f1f; else goto c8f1a;
       u8f1f: // global
           call _c8f16(R1) args: 0, res: 0, upd: 0;
       c8f1a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f16() //  [R1]
         { info_tbl: [(c8f16,
                       label: block_c8f16_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f16: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$ccompare_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.482968162 UTC

[section ""data" . GHC.IO.Handle.Types.$w$c<_closure" {
     GHC.IO.Handle.Types.$w$c<_closure:
         const GHC.IO.Handle.Types.$w$c<_info;
 },
 GHC.IO.Handle.Types.$w$c<_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8f1H,
                       label: GHC.IO.Handle.Types.$w$c<_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f1H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8f1I; else goto c8f1J;
       c8f1I: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$c<_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8f1J: // global
           I64[Sp - 32] = block_c8f1A_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8f2k; else goto c8f1B;
       u8f2k: // global
           call _c8f1A(R1) args: 0, res: 0, upd: 0;
       c8f1B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f1A() //  [R1]
         { info_tbl: [(c8f1A,
                       label: block_c8f1A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f1A: // global
           _s8ehS::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8f1E; else goto c8f1F;
       c8f1E: // global
           I64[Sp] = block_c8f1M_info;
           R1 = _s8ehS::P64;
           if (R1 & 7 != 0) goto u8f2i; else goto c8f1O;
       u8f2i: // global
           call _c8f1M(R1) args: 0, res: 0, upd: 0;
       c8f1O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8f1F: // global
           I64[Sp] = block_c8f21_info;
           R1 = _s8ehS::P64;
           if (R1 & 7 != 0) goto u8f2j; else goto c8f23;
       u8f2j: // global
           call _c8f21(R1) args: 0, res: 0, upd: 0;
       c8f23: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f1M() //  [R1]
         { info_tbl: [(c8f1M,
                       label: block_c8f1M_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f1M: // global
           if (R1 & 7 == 1) goto u8f2h; else goto c8f1Y;
       u8f2h: // global
           Sp = Sp + 8;
           call _c8f2d() args: 0, res: 0, upd: 0;
       c8f1Y: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8f21() //  [R1]
         { info_tbl: [(c8f21,
                       label: block_c8f21_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f21: // global
           if (R1 & 7 == 1) goto c8f29; else goto u8f2g;
       c8f29: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8f2g: // global
           Sp = Sp + 8;
           call _c8f2d() args: 0, res: 0, upd: 0;
     }
 },
 _c8f2d() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f2d: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fOrdNewline_$c<_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.493415144 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8f30,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f30: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8f34; else goto c8f35;
       c8f34: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8f35: // global
           I64[Sp - 16] = block_c8f2X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8f3d; else goto c8f2Y;
       u8f3d: // global
           call _c8f2X(R1) args: 0, res: 0, upd: 0;
       c8f2Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f2X() //  [R1]
         { info_tbl: [(c8f2X,
                       label: block_c8f2X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f2X: // global
           I64[Sp - 8] = block_c8f33_info;
           _s8ei0::P64 = P64[R1 + 7];
           _s8ei1::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8ei1::P64;
           P64[Sp + 8] = _s8ei0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8f3c; else goto c8f37;
       u8f3c: // global
           call _c8f33(R1) args: 0, res: 0, upd: 0;
       c8f37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f33() //  [R1]
         { info_tbl: [(c8f33,
                       label: block_c8f33_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f33: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$c<_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.500745307 UTC

[section ""data" . GHC.IO.Handle.Types.$w$c==_closure" {
     GHC.IO.Handle.Types.$w$c==_closure:
         const GHC.IO.Handle.Types.$w$c==_info;
 },
 GHC.IO.Handle.Types.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8f3E,
                       label: GHC.IO.Handle.Types.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f3E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8f3F; else goto c8f3G;
       c8f3F: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8f3G: // global
           I64[Sp - 32] = block_c8f3x_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8f4j; else goto c8f3y;
       u8f4j: // global
           call _c8f3x(R1) args: 0, res: 0, upd: 0;
       c8f3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f3x() //  [R1]
         { info_tbl: [(c8f3x,
                       label: block_c8f3x_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f3x: // global
           _s8ei7::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8f3B; else goto c8f3C;
       c8f3B: // global
           I64[Sp] = block_c8f3J_info;
           R1 = _s8ei7::P64;
           if (R1 & 7 != 0) goto u8f4h; else goto c8f3L;
       u8f4h: // global
           call _c8f3J(R1) args: 0, res: 0, upd: 0;
       c8f3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8f3C: // global
           I64[Sp] = block_c8f3Y_info;
           R1 = _s8ei7::P64;
           if (R1 & 7 != 0) goto u8f4i; else goto c8f40;
       u8f4i: // global
           call _c8f3Y(R1) args: 0, res: 0, upd: 0;
       c8f40: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f3J() //  [R1]
         { info_tbl: [(c8f3J,
                       label: block_c8f3J_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f3J: // global
           if (R1 & 7 == 1) goto u8f4f; else goto u8f4g;
       u8f4f: // global
           Sp = Sp + 8;
           call _c8f4a() args: 0, res: 0, upd: 0;
       u8f4g: // global
           Sp = Sp + 32;
           call _c8f46() args: 0, res: 0, upd: 0;
     }
 },
 _c8f3Y() //  [R1]
         { info_tbl: [(c8f3Y,
                       label: block_c8f3Y_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f3Y: // global
           if (R1 & 7 == 1) goto u8f4d; else goto u8f4e;
       u8f4d: // global
           Sp = Sp + 32;
           call _c8f46() args: 0, res: 0, upd: 0;
       u8f4e: // global
           Sp = Sp + 8;
           call _c8f4a() args: 0, res: 0, upd: 0;
     }
 },
 _c8f46() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f46: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8f4a() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f4a: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fEqNewline_$c==_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.511906015 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure:
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqNewlineMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8f51,
                       label: GHC.IO.Handle.Types.$fEqNewlineMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f51: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8f55; else goto c8f56;
       c8f55: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8f56: // global
           I64[Sp - 16] = block_c8f4Y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8f5e; else goto c8f4Z;
       u8f5e: // global
           call _c8f4Y(R1) args: 0, res: 0, upd: 0;
       c8f4Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f4Y() //  [R1]
         { info_tbl: [(c8f4Y,
                       label: block_c8f4Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f4Y: // global
           I64[Sp - 8] = block_c8f54_info;
           _s8eif::P64 = P64[R1 + 7];
           _s8eig::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8eig::P64;
           P64[Sp + 8] = _s8eif::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8f5d; else goto c8f58;
       u8f5d: // global
           call _c8f54(R1) args: 0, res: 0, upd: 0;
       c8f58: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f54() //  [R1]
         { info_tbl: [(c8f54,
                       label: block_c8f54_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f54: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$w$c==_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.520535732 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8f5B,
                       label: GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f5B: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8f5F; else goto c8f5G;
       c8f5F: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8f5G: // global
           I64[Sp - 16] = block_c8f5y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8f7R; else goto c8f5z;
       u8f7R: // global
           call _c8f5y(R1) args: 0, res: 0, upd: 0;
       c8f5z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f5y() //  [R1]
         { info_tbl: [(c8f5y,
                       label: block_c8f5y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f5y: // global
           I64[Sp - 8] = block_c8f5E_info;
           _s8ein::P64 = P64[R1 + 7];
           _s8eio::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8eio::P64;
           P64[Sp + 8] = _s8ein::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8f7Q; else goto c8f5I;
       u8f7Q: // global
           call _c8f5E(R1) args: 0, res: 0, upd: 0;
       c8f5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f5E() //  [R1]
         { info_tbl: [(c8f5E,
                       label: block_c8f5E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f5E: // global
           I64[Sp - 8] = block_c8f5M_info;
           _s8eiq::P64 = P64[R1 + 7];
           _s8eir::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8eir::P64;
           P64[Sp + 16] = _s8eiq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8f7S; else goto c8f5O;
       u8f7S: // global
           call _c8f5M(R1) args: 0, res: 0, upd: 0;
       c8f5O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f5M() //  [R1]
         { info_tbl: [(c8f5M,
                       label: block_c8f5M_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f5M: // global
           _s8eiq::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8f5V; else goto c8f6L;
       c8f5V: // global
           I64[Sp] = block_c8f5S_info;
           R1 = _s8eiq::P64;
           if (R1 & 7 != 0) goto u8f7T; else goto c8f5W;
       u8f7T: // global
           call _c8f5S(R1) args: 0, res: 0, upd: 0;
       c8f5W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8f6L: // global
           I64[Sp] = block_c8f6J_info;
           R1 = _s8eiq::P64;
           if (R1 & 7 != 0) goto u8f7U; else goto c8f6M;
       u8f7U: // global
           call _c8f6J(R1) args: 0, res: 0, upd: 0;
       c8f6M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f5S() //  [R1]
         { info_tbl: [(c8f5S,
                       label: block_c8f5S_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f5S: // global
           if (R1 & 7 == 1) goto c8f63; else goto u8f7L;
       c8f63: // global
           I64[Sp] = block_c8f60_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8f7V; else goto c8f64;
       u8f7V: // global
           call _c8f60(R1) args: 0, res: 0, upd: 0;
       c8f64: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8f7L: // global
           Sp = Sp + 32;
           call _c8f7s() args: 0, res: 0, upd: 0;
     }
 },
 _c8f60() //  [R1]
         { info_tbl: [(c8f60,
                       label: block_c8f60_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f60: // global
           _s8eir::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8f6b; else goto c8f6r;
       c8f6b: // global
           I64[Sp + 24] = block_c8f68_info;
           R1 = _s8eir::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8f7X; else goto c8f6c;
       u8f7X: // global
           call _c8f68(R1) args: 0, res: 0, upd: 0;
       c8f6c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8f6r: // global
           I64[Sp + 24] = block_c8f6p_info;
           R1 = _s8eir::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8f7Y; else goto c8f6s;
       u8f7Y: // global
           call _c8f6p(R1) args: 0, res: 0, upd: 0;
       c8f6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f68() //  [R1]
         { info_tbl: [(c8f68,
                       label: block_c8f68_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f68: // global
           if (R1 & 7 == 1) goto u8f7O; else goto u8f7P;
       u8f7O: // global
           Sp = Sp + 8;
           call _c8f7w() args: 0, res: 0, upd: 0;
       u8f7P: // global
           Sp = Sp + 8;
           call _c8f7s() args: 0, res: 0, upd: 0;
     }
 },
 _c8f6p() //  [R1]
         { info_tbl: [(c8f6p,
                       label: block_c8f6p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f6p: // global
           if (R1 & 7 == 1) goto u8f7M; else goto u8f7N;
       u8f7M: // global
           Sp = Sp + 8;
           call _c8f7s() args: 0, res: 0, upd: 0;
       u8f7N: // global
           Sp = Sp + 8;
           call _c8f7w() args: 0, res: 0, upd: 0;
     }
 },
 _c8f6J() //  [R1]
         { info_tbl: [(c8f6J,
                       label: block_c8f6J_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f6J: // global
           if (R1 & 7 == 1) goto u8f7G; else goto c8f6X;
       u8f7G: // global
           Sp = Sp + 32;
           call _c8f7s() args: 0, res: 0, upd: 0;
       c8f6X: // global
           I64[Sp] = block_c8f6V_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8f83; else goto c8f6Y;
       u8f83: // global
           call _c8f6V(R1) args: 0, res: 0, upd: 0;
       c8f6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f6V() //  [R1]
         { info_tbl: [(c8f6V,
                       label: block_c8f6V_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f6V: // global
           _s8eir::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8f75; else goto c8f7l;
       c8f75: // global
           I64[Sp + 24] = block_c8f72_info;
           R1 = _s8eir::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8f85; else goto c8f76;
       u8f85: // global
           call _c8f72(R1) args: 0, res: 0, upd: 0;
       c8f76: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8f7l: // global
           I64[Sp + 24] = block_c8f7j_info;
           R1 = _s8eir::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8f86; else goto c8f7m;
       u8f86: // global
           call _c8f7j(R1) args: 0, res: 0, upd: 0;
       c8f7m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f72() //  [R1]
         { info_tbl: [(c8f72,
                       label: block_c8f72_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f72: // global
           if (R1 & 7 == 1) goto u8f7J; else goto u8f7K;
       u8f7J: // global
           Sp = Sp + 8;
           call _c8f7w() args: 0, res: 0, upd: 0;
       u8f7K: // global
           Sp = Sp + 8;
           call _c8f7s() args: 0, res: 0, upd: 0;
     }
 },
 _c8f7j() //  [R1]
         { info_tbl: [(c8f7j,
                       label: block_c8f7j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f7j: // global
           if (R1 & 7 == 1) goto u8f7H; else goto u8f7I;
       u8f7H: // global
           Sp = Sp + 8;
           call _c8f7s() args: 0, res: 0, upd: 0;
       u8f7I: // global
           Sp = Sp + 8;
           call _c8f7w() args: 0, res: 0, upd: 0;
     }
 },
 _c8f7s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f7s: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8f7w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f7w: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.546293796 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqNewlineMode_closure" {
     GHC.IO.Handle.Types.$fEqNewlineMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqNewlineMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.549434885 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8f9H,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f9H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8f9L; else goto c8f9M;
       c8f9L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8f9M: // global
           I64[Sp - 16] = block_c8f9E_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fbF; else goto c8f9F;
       u8fbF: // global
           call _c8f9E(R1) args: 0, res: 0, upd: 0;
       c8f9F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f9E() //  [R1]
         { info_tbl: [(c8f9E,
                       label: block_c8f9E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f9E: // global
           I64[Sp - 8] = block_c8f9K_info;
           _s8eiE::P64 = P64[R1 + 7];
           _s8eiF::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8eiF::P64;
           P64[Sp + 8] = _s8eiE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8fbE; else goto c8f9O;
       u8fbE: // global
           call _c8f9K(R1) args: 0, res: 0, upd: 0;
       c8f9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f9K() //  [R1]
         { info_tbl: [(c8f9K,
                       label: block_c8f9K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f9K: // global
           I64[Sp - 8] = block_c8f9S_info;
           _s8eiH::P64 = P64[R1 + 7];
           _s8eiI::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8eiI::P64;
           P64[Sp + 16] = _s8eiH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8fbG; else goto c8f9U;
       u8fbG: // global
           call _c8f9S(R1) args: 0, res: 0, upd: 0;
       c8f9U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f9S() //  [R1]
         { info_tbl: [(c8f9S,
                       label: block_c8f9S_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f9S: // global
           _s8eiH::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8fa1; else goto c8faL;
       c8fa1: // global
           I64[Sp] = block_c8f9Y_info;
           R1 = _s8eiH::P64;
           if (R1 & 7 != 0) goto u8fbH; else goto c8fa2;
       u8fbH: // global
           call _c8f9Y(R1) args: 0, res: 0, upd: 0;
       c8fa2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8faL: // global
           I64[Sp] = block_c8faJ_info;
           R1 = _s8eiH::P64;
           if (R1 & 7 != 0) goto u8fbI; else goto c8faM;
       u8fbI: // global
           call _c8faJ(R1) args: 0, res: 0, upd: 0;
       c8faM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8f9Y() //  [R1]
         { info_tbl: [(c8f9Y,
                       label: block_c8f9Y_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8f9Y: // global
           if (R1 & 7 == 1) goto c8fa9; else goto u8fbB;
       c8fa9: // global
           I64[Sp] = block_c8fa6_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8fbJ; else goto c8faa;
       u8fbJ: // global
           call _c8fa6(R1) args: 0, res: 0, upd: 0;
       c8faa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fbB: // global
           Sp = Sp + 32;
           call _c8fbg() args: 0, res: 0, upd: 0;
     }
 },
 _c8fa6() //  [R1]
         { info_tbl: [(c8fa6,
                       label: block_c8fa6_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fa6: // global
           _s8eiI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fah; else goto c8fax;
       c8fah: // global
           I64[Sp + 24] = block_c8fae_info;
           R1 = _s8eiI::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fbL; else goto c8fai;
       u8fbL: // global
           call _c8fae(R1) args: 0, res: 0, upd: 0;
       c8fai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fax: // global
           I64[Sp + 24] = block_c8fav_info;
           R1 = _s8eiI::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fbM; else goto c8fay;
       u8fbM: // global
           call _c8fav() args: 0, res: 0, upd: 0;
       c8fay: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fae() //  [R1]
         { info_tbl: [(c8fae,
                       label: block_c8fae_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fae: // global
           if (R1 & 7 == 1) goto u8fbC; else goto u8fbD;
       u8fbC: // global
           Sp = Sp + 8;
           call _c8fbc() args: 0, res: 0, upd: 0;
       u8fbD: // global
           Sp = Sp + 8;
           call _c8fbg() args: 0, res: 0, upd: 0;
     }
 },
 _c8fav() //  []
         { info_tbl: [(c8fav,
                       label: block_c8fav_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fav: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8faJ() //  [R1]
         { info_tbl: [(c8faJ,
                       label: block_c8faJ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8faJ: // global
           if (R1 & 7 == 1) goto u8fby; else goto c8faX;
       u8fby: // global
           Sp = Sp + 32;
           call _c8fbc() args: 0, res: 0, upd: 0;
       c8faX: // global
           I64[Sp] = block_c8faV_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8fbP; else goto c8faY;
       u8fbP: // global
           call _c8faV(R1) args: 0, res: 0, upd: 0;
       c8faY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8faV() //  [R1]
         { info_tbl: [(c8faV,
                       label: block_c8faV_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8faV: // global
           _s8eiI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fb5; else goto c8fbl;
       c8fb5: // global
           I64[Sp + 24] = block_c8fb2_info;
           R1 = _s8eiI::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fbR; else goto c8fb6;
       u8fbR: // global
           call _c8fb2(R1) args: 0, res: 0, upd: 0;
       c8fb6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fbl: // global
           I64[Sp + 24] = block_c8fbj_info;
           R1 = _s8eiI::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fbS; else goto c8fbm;
       u8fbS: // global
           call _c8fbj() args: 0, res: 0, upd: 0;
       c8fbm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fb2() //  [R1]
         { info_tbl: [(c8fb2,
                       label: block_c8fb2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fb2: // global
           if (R1 & 7 == 1) goto u8fbz; else goto u8fbA;
       u8fbz: // global
           Sp = Sp + 8;
           call _c8fbc() args: 0, res: 0, upd: 0;
       u8fbA: // global
           Sp = Sp + 8;
           call _c8fbg() args: 0, res: 0, upd: 0;
     }
 },
 _c8fbc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fbc: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fbg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fbg: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fbj() //  []
         { info_tbl: [(c8fbj,
                       label: block_c8fbj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fbj: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.576316472 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8fdq,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fdq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8fdu; else goto c8fdv;
       c8fdu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fdv: // global
           I64[Sp - 16] = block_c8fdn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ffo; else goto c8fdo;
       u8ffo: // global
           call _c8fdn(R1) args: 0, res: 0, upd: 0;
       c8fdo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fdn() //  [R1]
         { info_tbl: [(c8fdn,
                       label: block_c8fdn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fdn: // global
           I64[Sp - 16] = block_c8fdt_info;
           _s8eiU::P64 = R1;
           _s8eiV::P64 = P64[R1 + 7];
           _s8eiW::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s8eiW::P64;
           P64[Sp] = _s8eiV::P64;
           P64[Sp + 8] = _s8eiU::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ffn; else goto c8fdx;
       u8ffn: // global
           call _c8fdt(R1) args: 0, res: 0, upd: 0;
       c8fdx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fdt() //  [R1]
         { info_tbl: [(c8fdt,
                       label: block_c8fdt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fdt: // global
           I64[Sp - 16] = block_c8fdB_info;
           _s8eiX::P64 = R1;
           _s8eiY::P64 = P64[R1 + 7];
           _s8eiZ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8eiZ::P64;
           P64[Sp] = _s8eiY::P64;
           P64[Sp + 16] = _s8eiX::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ffp; else goto c8fdD;
       u8ffp: // global
           call _c8fdB(R1) args: 0, res: 0, upd: 0;
       c8fdD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fdB() //  [R1]
         { info_tbl: [(c8fdB,
                       label: block_c8fdB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fdB: // global
           _s8eiY::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8fdK; else goto c8feu;
       c8fdK: // global
           I64[Sp] = block_c8fdH_info;
           R1 = _s8eiY::P64;
           if (R1 & 7 != 0) goto u8ffq; else goto c8fdL;
       u8ffq: // global
           call _c8fdH(R1) args: 0, res: 0, upd: 0;
       c8fdL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8feu: // global
           I64[Sp] = block_c8fes_info;
           R1 = _s8eiY::P64;
           if (R1 & 7 != 0) goto u8ffr; else goto c8fev;
       u8ffr: // global
           call _c8fes(R1) args: 0, res: 0, upd: 0;
       c8fev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fdH() //  [R1]
         { info_tbl: [(c8fdH,
                       label: block_c8fdH_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fdH: // global
           if (R1 & 7 == 1) goto c8fdS; else goto u8ffk;
       c8fdS: // global
           I64[Sp] = block_c8fdP_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8ffs; else goto c8fdT;
       u8ffs: // global
           call _c8fdP(R1) args: 0, res: 0, upd: 0;
       c8fdT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8ffk: // global
           Sp = Sp + 32;
           call _c8feZ() args: 0, res: 0, upd: 0;
     }
 },
 _c8fdP() //  [R1]
         { info_tbl: [(c8fdP,
                       label: block_c8fdP_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fdP: // global
           _s8eiZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fe0; else goto c8feg;
       c8fe0: // global
           I64[Sp + 24] = block_c8fdX_info;
           R1 = _s8eiZ::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8ffu; else goto c8fe1;
       u8ffu: // global
           call _c8fdX(R1) args: 0, res: 0, upd: 0;
       c8fe1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8feg: // global
           I64[Sp + 32] = block_c8fee_info;
           R1 = _s8eiZ::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8ffv; else goto c8feh;
       u8ffv: // global
           call _c8fee() args: 0, res: 0, upd: 0;
       c8feh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fdX() //  [R1]
         { info_tbl: [(c8fdX,
                       label: block_c8fdX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fdX: // global
           if (R1 & 7 == 1) goto u8ffl; else goto u8ffm;
       u8ffl: // global
           Sp = Sp + 16;
           call _c8feV() args: 0, res: 0, upd: 0;
       u8ffm: // global
           Sp = Sp + 8;
           call _c8feZ() args: 0, res: 0, upd: 0;
     }
 },
 _c8fee() //  []
         { info_tbl: [(c8fee,
                       label: block_c8fee_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fee: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fes() //  [R1]
         { info_tbl: [(c8fes,
                       label: block_c8fes_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fes: // global
           if (R1 & 7 == 1) goto u8ffh; else goto c8feG;
       u8ffh: // global
           Sp = Sp + 40;
           call _c8feV() args: 0, res: 0, upd: 0;
       c8feG: // global
           I64[Sp] = block_c8feE_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8ffy; else goto c8feH;
       u8ffy: // global
           call _c8feE(R1) args: 0, res: 0, upd: 0;
       c8feH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8feE() //  [R1]
         { info_tbl: [(c8feE,
                       label: block_c8feE_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8feE: // global
           _s8eiZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8feO; else goto c8ff4;
       c8feO: // global
           I64[Sp + 24] = block_c8feL_info;
           R1 = _s8eiZ::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8ffA; else goto c8feP;
       u8ffA: // global
           call _c8feL(R1) args: 0, res: 0, upd: 0;
       c8feP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ff4: // global
           I64[Sp + 32] = block_c8ff2_info;
           R1 = _s8eiZ::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8ffB; else goto c8ff5;
       u8ffB: // global
           call _c8ff2() args: 0, res: 0, upd: 0;
       c8ff5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8feL() //  [R1]
         { info_tbl: [(c8feL,
                       label: block_c8feL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8feL: // global
           if (R1 & 7 == 1) goto u8ffi; else goto u8ffj;
       u8ffi: // global
           Sp = Sp + 16;
           call _c8feV() args: 0, res: 0, upd: 0;
       u8ffj: // global
           Sp = Sp + 8;
           call _c8feZ() args: 0, res: 0, upd: 0;
     }
 },
 _c8feV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8feV: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8feZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8feZ: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ff2() //  []
         { info_tbl: [(c8ff2,
                       label: block_c8ff2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ff2: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.602752699 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8fh9,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fh9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8fhd; else goto c8fhe;
       c8fhd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fhe: // global
           I64[Sp - 16] = block_c8fh6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fj7; else goto c8fh7;
       u8fj7: // global
           call _c8fh6(R1) args: 0, res: 0, upd: 0;
       c8fh7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fh6() //  [R1]
         { info_tbl: [(c8fh6,
                       label: block_c8fh6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fh6: // global
           I64[Sp - 8] = block_c8fhc_info;
           _s8ejc::P64 = P64[R1 + 7];
           _s8ejd::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8ejd::P64;
           P64[Sp + 8] = _s8ejc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8fj6; else goto c8fhg;
       u8fj6: // global
           call _c8fhc(R1) args: 0, res: 0, upd: 0;
       c8fhg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fhc() //  [R1]
         { info_tbl: [(c8fhc,
                       label: block_c8fhc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fhc: // global
           I64[Sp - 8] = block_c8fhk_info;
           _s8ejf::P64 = P64[R1 + 7];
           _s8ejg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8ejg::P64;
           P64[Sp + 16] = _s8ejf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8fj8; else goto c8fhm;
       u8fj8: // global
           call _c8fhk(R1) args: 0, res: 0, upd: 0;
       c8fhm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fhk() //  [R1]
         { info_tbl: [(c8fhk,
                       label: block_c8fhk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fhk: // global
           _s8ejf::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8fht; else goto c8fid;
       c8fht: // global
           I64[Sp] = block_c8fhq_info;
           R1 = _s8ejf::P64;
           if (R1 & 7 != 0) goto u8fj9; else goto c8fhu;
       u8fj9: // global
           call _c8fhq(R1) args: 0, res: 0, upd: 0;
       c8fhu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fid: // global
           I64[Sp] = block_c8fib_info;
           R1 = _s8ejf::P64;
           if (R1 & 7 != 0) goto u8fja; else goto c8fie;
       u8fja: // global
           call _c8fib(R1) args: 0, res: 0, upd: 0;
       c8fie: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fhq() //  [R1]
         { info_tbl: [(c8fhq,
                       label: block_c8fhq_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fhq: // global
           if (R1 & 7 == 1) goto c8fhB; else goto u8fj3;
       c8fhB: // global
           I64[Sp] = block_c8fhy_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8fjb; else goto c8fhC;
       u8fjb: // global
           call _c8fhy(R1) args: 0, res: 0, upd: 0;
       c8fhC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fj3: // global
           Sp = Sp + 32;
           call _c8fiI() args: 0, res: 0, upd: 0;
     }
 },
 _c8fhy() //  [R1]
         { info_tbl: [(c8fhy,
                       label: block_c8fhy_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fhy: // global
           _s8ejg::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fhJ; else goto c8fhZ;
       c8fhJ: // global
           I64[Sp + 24] = block_c8fhG_info;
           R1 = _s8ejg::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fjd; else goto c8fhK;
       u8fjd: // global
           call _c8fhG(R1) args: 0, res: 0, upd: 0;
       c8fhK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fhZ: // global
           I64[Sp + 24] = block_c8fhX_info;
           R1 = _s8ejg::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fje; else goto c8fi0;
       u8fje: // global
           call _c8fhX() args: 0, res: 0, upd: 0;
       c8fi0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fhG() //  [R1]
         { info_tbl: [(c8fhG,
                       label: block_c8fhG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fhG: // global
           if (R1 & 7 == 1) goto u8fj4; else goto u8fj5;
       u8fj4: // global
           Sp = Sp + 8;
           call _c8fiE() args: 0, res: 0, upd: 0;
       u8fj5: // global
           Sp = Sp + 8;
           call _c8fiI() args: 0, res: 0, upd: 0;
     }
 },
 _c8fhX() //  []
         { info_tbl: [(c8fhX,
                       label: block_c8fhX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fhX: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fib() //  [R1]
         { info_tbl: [(c8fib,
                       label: block_c8fib_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fib: // global
           if (R1 & 7 == 1) goto u8fj0; else goto c8fip;
       u8fj0: // global
           Sp = Sp + 32;
           call _c8fiE() args: 0, res: 0, upd: 0;
       c8fip: // global
           I64[Sp] = block_c8fin_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8fjh; else goto c8fiq;
       u8fjh: // global
           call _c8fin(R1) args: 0, res: 0, upd: 0;
       c8fiq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fin() //  [R1]
         { info_tbl: [(c8fin,
                       label: block_c8fin_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fin: // global
           _s8ejg::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fix; else goto c8fiN;
       c8fix: // global
           I64[Sp + 24] = block_c8fiu_info;
           R1 = _s8ejg::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fjj; else goto c8fiy;
       u8fjj: // global
           call _c8fiu(R1) args: 0, res: 0, upd: 0;
       c8fiy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fiN: // global
           I64[Sp + 24] = block_c8fiL_info;
           R1 = _s8ejg::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fjk; else goto c8fiO;
       u8fjk: // global
           call _c8fiL() args: 0, res: 0, upd: 0;
       c8fiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fiu() //  [R1]
         { info_tbl: [(c8fiu,
                       label: block_c8fiu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fiu: // global
           if (R1 & 7 == 1) goto u8fj1; else goto u8fj2;
       u8fj1: // global
           Sp = Sp + 8;
           call _c8fiE() args: 0, res: 0, upd: 0;
       u8fj2: // global
           Sp = Sp + 8;
           call _c8fiI() args: 0, res: 0, upd: 0;
     }
 },
 _c8fiE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fiE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fiI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fiI: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fiL() //  []
         { info_tbl: [(c8fiL,
                       label: block_c8fiL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fiL: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.628181939 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8fkP,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fkP: // global
           _s8ejr::P64 = R3;
           R3 = R2;
           R2 = _s8ejr::P64;
           call GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.632866759 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8fl3,
                       label: GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fl3: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8fl7; else goto c8fl8;
       c8fl7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fl8: // global
           I64[Sp - 16] = block_c8fl0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fn1; else goto c8fl1;
       u8fn1: // global
           call _c8fl0(R1) args: 0, res: 0, upd: 0;
       c8fl1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fl0() //  [R1]
         { info_tbl: [(c8fl0,
                       label: block_c8fl0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fl0: // global
           I64[Sp - 16] = block_c8fl6_info;
           _s8eju::P64 = R1;
           _s8ejv::P64 = P64[R1 + 7];
           _s8ejw::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _s8ejw::P64;
           P64[Sp] = _s8ejv::P64;
           P64[Sp + 8] = _s8eju::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fn0; else goto c8fla;
       u8fn0: // global
           call _c8fl6(R1) args: 0, res: 0, upd: 0;
       c8fla: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fl6() //  [R1]
         { info_tbl: [(c8fl6,
                       label: block_c8fl6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fl6: // global
           I64[Sp - 16] = block_c8fle_info;
           _s8ejx::P64 = R1;
           _s8ejy::P64 = P64[R1 + 7];
           _s8ejz::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8ejz::P64;
           P64[Sp] = _s8ejy::P64;
           P64[Sp + 16] = _s8ejx::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fn2; else goto c8flg;
       u8fn2: // global
           call _c8fle(R1) args: 0, res: 0, upd: 0;
       c8flg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fle() //  [R1]
         { info_tbl: [(c8fle,
                       label: block_c8fle_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fle: // global
           _s8ejy::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8fln; else goto c8fm7;
       c8fln: // global
           I64[Sp] = block_c8flk_info;
           R1 = _s8ejy::P64;
           if (R1 & 7 != 0) goto u8fn3; else goto c8flo;
       u8fn3: // global
           call _c8flk(R1) args: 0, res: 0, upd: 0;
       c8flo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fm7: // global
           I64[Sp] = block_c8fm5_info;
           R1 = _s8ejy::P64;
           if (R1 & 7 != 0) goto u8fn4; else goto c8fm8;
       u8fn4: // global
           call _c8fm5(R1) args: 0, res: 0, upd: 0;
       c8fm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8flk() //  [R1]
         { info_tbl: [(c8flk,
                       label: block_c8flk_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8flk: // global
           if (R1 & 7 == 1) goto c8flv; else goto u8fmX;
       c8flv: // global
           I64[Sp] = block_c8fls_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8fn5; else goto c8flw;
       u8fn5: // global
           call _c8fls(R1) args: 0, res: 0, upd: 0;
       c8flw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fmX: // global
           Sp = Sp + 40;
           call _c8fmC() args: 0, res: 0, upd: 0;
     }
 },
 _c8fls() //  [R1]
         { info_tbl: [(c8fls,
                       label: block_c8fls_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fls: // global
           _s8ejz::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8flD; else goto c8flT;
       c8flD: // global
           I64[Sp + 24] = block_c8flA_info;
           R1 = _s8ejz::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fn7; else goto c8flE;
       u8fn7: // global
           call _c8flA(R1) args: 0, res: 0, upd: 0;
       c8flE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8flT: // global
           I64[Sp + 24] = block_c8flR_info;
           R1 = _s8ejz::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fn8; else goto c8flU;
       u8fn8: // global
           call _c8flR() args: 0, res: 0, upd: 0;
       c8flU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8flA() //  [R1]
         { info_tbl: [(c8flA,
                       label: block_c8flA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8flA: // global
           if (R1 & 7 == 1) goto u8fmY; else goto u8fmZ;
       u8fmY: // global
           Sp = Sp + 8;
           call _c8fmy() args: 0, res: 0, upd: 0;
       u8fmZ: // global
           Sp = Sp + 16;
           call _c8fmC() args: 0, res: 0, upd: 0;
     }
 },
 _c8flR() //  []
         { info_tbl: [(c8flR,
                       label: block_c8flR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8flR: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fm5() //  [R1]
         { info_tbl: [(c8fm5,
                       label: block_c8fm5_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fm5: // global
           if (R1 & 7 == 1) goto u8fmU; else goto c8fmj;
       u8fmU: // global
           Sp = Sp + 32;
           call _c8fmy() args: 0, res: 0, upd: 0;
       c8fmj: // global
           I64[Sp] = block_c8fmh_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto u8fnb; else goto c8fmk;
       u8fnb: // global
           call _c8fmh(R1) args: 0, res: 0, upd: 0;
       c8fmk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fmh() //  [R1]
         { info_tbl: [(c8fmh,
                       label: block_c8fmh_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fmh: // global
           _s8ejz::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fmr; else goto c8fmH;
       c8fmr: // global
           I64[Sp + 24] = block_c8fmo_info;
           R1 = _s8ejz::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fnd; else goto c8fms;
       u8fnd: // global
           call _c8fmo(R1) args: 0, res: 0, upd: 0;
       c8fms: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fmH: // global
           I64[Sp + 24] = block_c8fmF_info;
           R1 = _s8ejz::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto u8fne; else goto c8fmI;
       u8fne: // global
           call _c8fmF() args: 0, res: 0, upd: 0;
       c8fmI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fmo() //  [R1]
         { info_tbl: [(c8fmo,
                       label: block_c8fmo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fmo: // global
           if (R1 & 7 == 1) goto u8fmV; else goto u8fmW;
       u8fmV: // global
           Sp = Sp + 8;
           call _c8fmy() args: 0, res: 0, upd: 0;
       u8fmW: // global
           Sp = Sp + 16;
           call _c8fmC() args: 0, res: 0, upd: 0;
     }
 },
 _c8fmy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fmy: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fmC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fmC: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fmF() //  []
         { info_tbl: [(c8fmF,
                       label: block_c8fmF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fmF: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.658612384 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdNewlineMode_closure" {
     GHC.IO.Handle.Types.$fOrdNewlineMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqNewlineMode_closure+1;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdNewlineMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.660420756 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode13_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode13_bytes:
         I8[] [78,111,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.662595341 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode12_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode12_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode12_entry() //  [R1]
         { info_tbl: [(c8foN,
                       label: GHC.IO.Handle.Types.$fReadBufferMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8foN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8foO; else goto c8foP;
       c8foO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8foP: // global
           (_c8foK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8foK::I64 == 0) goto c8foM; else goto c8foL;
       c8foM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8foL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8foK::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.666666971 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode6_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode6_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode6_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode6_entry() //  [R2]
         { info_tbl: [(c8fp2,
                       label: GHC.IO.Handle.Types.$fShowBufferMode6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fp2: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode12_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.669844565 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode9_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode9_bytes:
         I8[] [76,105,110,101,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.671817948 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode8_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode8_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode8_entry() //  [R1]
         { info_tbl: [(c8fpg,
                       label: GHC.IO.Handle.Types.$fReadBufferMode8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fpg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fph; else goto c8fpi;
       c8fph: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fpi: // global
           (_c8fpd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8fpd::I64 == 0) goto c8fpf; else goto c8fpe;
       c8fpf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8fpe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8fpd::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.675673626 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode5_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode5_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode5_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode5_entry() //  [R2]
         { info_tbl: [(c8fpv,
                       label: GHC.IO.Handle.Types.$fShowBufferMode5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fpv: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode8_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.680515404 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fShowBufferMode4_bytes" {
     GHC.IO.Handle.Types.$fShowBufferMode4_bytes:
         I8[] [66,108,111,99,107,66,117,102,102,101,114,105,110,103,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.682373117 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode3_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode3_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode3_entry() //  [R1]
         { info_tbl: [(c8fpJ,
                       label: GHC.IO.Handle.Types.$fShowBufferMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fpJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fpK; else goto c8fpL;
       c8fpK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fpL: // global
           (_c8fpG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8fpG::I64 == 0) goto c8fpI; else goto c8fpH;
       c8fpI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8fpH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8fpG::I64;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.687739726 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_info;
         const 0;
 },
 g_s8ejP_entry() //  [R1]
         { info_tbl: [(c8fqe,
                       label: g_s8ejP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fqe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fqf; else goto c8fqg;
       c8fqf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fqg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 16];
           R3 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R2 = GHC.Show.$fShowInt_closure;
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ejS_entry() //  [R1]
         { info_tbl: [(c8fqt,
                       label: sat_s8ejS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fqt: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ejT_entry() //  [R1, R2]
         { info_tbl: [(c8fqw,
                       label: sat_s8ejT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fqw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8fqA; else goto c8fqz;
       c8fqA: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8fqz: // global
           _s8ejP::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s8ejS_info;
           P64[Hp - 8] = _s8ejP::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ejW_entry() //  [R1]
         { info_tbl: [(c8fqQ,
                       label: sat_s8ejW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fqQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8fqU; else goto c8fqT;
       c8fqU: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fqT: // global
           _s8ejP::P64 = P64[R1 + 16];
           _s8ejU::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s8ejU::P64;
           R2 = Hp - 14;
           R1 = _s8ejP::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ejX_entry() //  [R1]
         { info_tbl: [(c8fqV,
                       label: sat_s8ejX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fqV: // global
           _s8ejX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8fqW; else goto c8fqX;
       c8fqX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8fqZ; else goto c8fqY;
       c8fqZ: // global
           HpAlloc = 32;
           goto c8fqW;
       c8fqW: // global
           R1 = _s8ejX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fqY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8ejX::P64;
           _s8ejP::P64 = P64[_s8ejX::P64 + 16];
           _s8ejU::P64 = P64[_s8ejX::P64 + 24];
           I64[Hp - 24] = sat_s8ejW_info;
           P64[Hp - 8] = _s8ejP::P64;
           P64[Hp] = _s8ejU::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ejY_entry() //  [R1, R2]
         { info_tbl: [(c8fr1,
                       label: sat_s8ejY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fr1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8fr5; else goto c8fr4;
       c8fr5: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8fr4: // global
           _s8ejP::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s8ejX_info;
           P64[Hp - 32] = _s8ejP::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c8frb,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8frb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8frc; else goto c8frd;
       c8frc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8frd: // global
           I64[Sp - 16] = block_c8fpY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8frr; else goto c8fpZ;
       u8frr: // global
           call _c8fpY(R1) args: 0, res: 0, upd: 0;
       c8fpZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fpY() //  [R1]
         { info_tbl: [(c8fpY,
                       label: block_c8fpY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fpY: // global
           _c8fra::P64 = R1 & 7;
           if (_c8fra::P64 < 3) goto u8frp; else goto c8fr9;
       u8frp: // global
           if (_c8fra::P64 < 2) goto c8fr7; else goto c8fr8;
       c8fr7: // global
           R1 = GHC.IO.Handle.Types.$fShowBufferMode6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8fr8: // global
           R1 = GHC.IO.Handle.Types.$fShowBufferMode5_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8fr9: // global
           I64[Sp] = block_c8fq5_info;
           _s8ejM::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ejM::P64;
           if (R1 & 7 != 0) goto u8frq; else goto c8fq6;
       u8frq: // global
           call _c8fq5(R1) args: 0, res: 0, upd: 0;
       c8fq6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fq5() //  [R1]
         { info_tbl: [(c8fq5,
                       label: block_c8fq5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fq5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8frl; else goto c8frk;
       c8frl: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8frk: // global
           _s8ejO::I64 = I64[R1 + 7];
           I64[Hp - 32] = g_s8ejP_info;
           P64[Hp - 16] = P64[Sp + 8];
           _c8fqa::P64 = Hp - 32;
           if (%MO_S_Lt_W64(_s8ejO::I64, 11)) goto c8frn; else goto c8fro;
       c8frn: // global
           I64[Hp - 8] = sat_s8ejT_info;
           P64[Hp] = _c8fqa::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8fro: // global
           I64[Hp - 8] = sat_s8ejY_info;
           P64[Hp] = _c8fqa::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.708008763 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode7_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode7_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.711216809 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_info;
         const 0;
 },
 sat_s8ek9_entry() //  [R1]
         { info_tbl: [(c8fsS,
                       label: sat_s8ek9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fsS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8fsY; else goto c8fsZ;
       c8fsY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fsZ: // global
           I64[Sp - 8] = block_c8fsP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ft4; else goto c8fsQ;
       u8ft4: // global
           call _c8fsP(R1) args: 0, res: 0, upd: 0;
       c8fsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fsP() //  [R1]
         { info_tbl: [(c8fsP,
                       label: block_c8fsP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fsP: // global
           I64[Sp] = block_c8fsV_info;
           R4 = GHC.IO.Handle.Types.$fShowBufferMode7_closure+2;
           R3 = I64[R1 + 7];
           R2 = 11;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8fsV() //  [R1, R2]
         { info_tbl: [(c8fsV,
                       label: block_c8fsV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fsV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ft3; else goto c8ft2;
       c8ft3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c8ft2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8eka_entry() //  [R1]
         { info_tbl: [(c8ft5,
                       label: sat_s8eka_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ft5: // global
           _s8eka::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ft6; else goto c8ft7;
       c8ft7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ft9; else goto c8ft8;
       c8ft9: // global
           HpAlloc = 24;
           goto c8ft6;
       c8ft6: // global
           R1 = _s8eka::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ft8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8eka::P64;
           _s8ek3::P64 = P64[_s8eka::P64 + 16];
           I64[Hp - 16] = sat_s8ek9_info;
           P64[Hp] = _s8ek3::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ekb_entry() //  [R1]
         { info_tbl: [(c8fte,
                       label: sat_s8ekb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fte: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ftf; else goto c8ftg;
       c8ftf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ftg: // global
           I64[Sp - 8] = block_c8fsB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ftn; else goto c8fsC;
       u8ftn: // global
           call _c8fsB(R1) args: 0, res: 0, upd: 0;
       c8fsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fsB() //  [R1]
         { info_tbl: [(c8fsB,
                       label: block_c8fsB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fsB: // global
           if (R1 & 7 == 1) goto c8ftb; else goto c8ftc;
       c8ftb: // global
           R1 = GHC.Show.$fShowMaybe4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8ftc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8ftm; else goto c8ftl;
       c8ftm: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ftl: // global
           _s8ek3::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_s8eka_info;
           P64[Hp - 24] = _s8ek3::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshow_entry() //  [R2]
         { info_tbl: [(c8ftt,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ftt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ftu; else goto c8ftv;
       c8ftu: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ftv: // global
           I64[Sp - 8] = block_c8fsq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ftE; else goto c8fsr;
       u8ftE: // global
           call _c8fsq(R1) args: 0, res: 0, upd: 0;
       c8fsr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fsq() //  [R1]
         { info_tbl: [(c8fsq,
                       label: block_c8fsq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fsq: // global
           _c8fts::P64 = R1 & 7;
           if (_c8fts::P64 < 3) goto u8ftD; else goto c8ftr;
       u8ftD: // global
           if (_c8fts::P64 < 2) goto c8ftp; else goto c8ftq;
       c8ftp: // global
           R1 = GHC.IO.Handle.Types.$fReadBufferMode12_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8ftq: // global
           R1 = GHC.IO.Handle.Types.$fReadBufferMode8_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8ftr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ftC; else goto c8ftB;
       c8ftC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ftB: // global
           _s8ek1::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_s8ekb_info;
           P64[Hp] = _s8ek1::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode3_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.729102479 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode1_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode1_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode1_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode1_entry() //  [R2]
         { info_tbl: [(c8fuz,
                       label: GHC.IO.Handle.Types.$fShowBufferMode1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fuz: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode2_closure+1;
           call GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.73274398 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c8fuK,
                       label: GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fuK: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowBufferMode1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.735978693 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowBufferMode_closure" {
     GHC.IO.Handle.Types.$fShowBufferMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure+2;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.737870348 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode11_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode11_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode11_info;
 },
 GHC.IO.Handle.Types.$fReadBufferMode11_entry() //  [R3]
         { info_tbl: [(c8fuW,
                       label: GHC.IO.Handle.Types.$fReadBufferMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fuW: // global
           R2 = GHC.IO.Handle.Types.NoBuffering_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.741481373 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode10_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode10_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode12_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.743327051 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode7_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode7_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode7_info;
 },
 GHC.IO.Handle.Types.$fReadBufferMode7_entry() //  [R3]
         { info_tbl: [(c8fv8,
                       label: GHC.IO.Handle.Types.$fReadBufferMode7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fv8: // global
           R2 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.746762673 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode6_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode6_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode8_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.748402423 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode5_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode5_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.750087757 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_sps_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_sps_closure:
         const :_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode10_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.751740965 UTC

[section ""cstring" . GHC.IO.Handle.Types.$fReadBufferMode4_bytes" {
     GHC.IO.Handle.Types.$fReadBufferMode4_bytes:
         I8[] [66,108,111,99,107,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.754469478 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode3_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode3_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode3_entry() //  [R1]
         { info_tbl: [(c8fvp,
                       label: GHC.IO.Handle.Types.$fReadBufferMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fvp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fvq; else goto c8fvr;
       c8fvq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fvr: // global
           (_c8fvm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8fvm::I64 == 0) goto c8fvo; else goto c8fvn;
       c8fvo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8fvn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8fvm::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.758307078 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.761734406 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode2_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode2_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode2_info;
         const 0;
 },
 ds2_s8ekj_entry() //  [R1]
         { info_tbl: [(c8fvJ,
                       label: ds2_s8ekj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fvJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fvK; else goto c8fvL;
       c8fvK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fvL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadBufferMode_sps_closure+2;
           Sp = Sp - 16;
           call GHC.Read.choose2_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eks_entry() //  [R1, R2]
         { info_tbl: [(c8fwf,
                       label: sat_s8eks_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fwf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8fwj; else goto c8fwi;
       c8fwj: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8fwi: // global
           _s8ekk::P64 = P64[R1 + 7];
           I64[Hp - 8] = GHC.IO.Handle.Types.BlockBuffering_con_info;
           P64[Hp] = R2;
           R2 = Hp - 5;
           R1 = _s8ekk::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ekt_entry() //  [R1, R2]
         { info_tbl: [(c8fwk,
                       label: sat_s8ekt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fwk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8fwo; else goto c8fwn;
       c8fwo: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8fwn: // global
           _s8ekk::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8eks_info;
           P64[Hp] = _s8ekk::P64;
           R4 = Hp - 7;
           R3 = GHC.IO.Handle.Types.$fReadBufferMode_n_closure+1;
           R2 = GHC.Read.$fReadInt_closure;
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ekw_entry() //  [R1]
         { info_tbl: [(c8fwp,
                       label: sat_s8ekw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fwp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8fwq; else goto c8fwr;
       c8fwq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fwr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8fvV_info;
           _s8ekk::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s8ekk::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8fwE; else goto c8fvW;
       u8fwE: // global
           call _c8fvV(R1) args: 0, res: 0, upd: 0;
       c8fvW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8fvV() //  [R1]
         { info_tbl: [(c8fvV,
                       label: block_c8fvV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fvV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8fwu; else goto c8fwt;
       c8fwu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8fwt: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 10)) goto c8fww; else goto c8fwA;
       c8fww: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8fwA: // global
           I64[Hp - 8] = sat_s8ekt_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8fwx_info;
           R3 = Hp - 7;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure+4;
           Sp = Sp + 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8fwx() //  [R1]
         { info_tbl: [(c8fwx,
                       label: block_c8fwx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fwx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8fwD; else goto c8fwC;
       c8fwD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8fwC: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ekx_entry() //  [R1, R2]
         { info_tbl: [(c8fwH,
                       label: sat_s8ekx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fwH: // global
           _s8ekk::P64 = R2;
           _s8ekx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8fwI; else goto c8fwJ;
       c8fwJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8fwL; else goto c8fwK;
       c8fwL: // global
           HpAlloc = 32;
           goto c8fwI;
       c8fwI: // global
           R2 = _s8ekk::P64;
           R1 = _s8ekx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8fwK: // global
           _s8eki::P64 = P64[_s8ekx::P64 + 7];
           _s8ekj::P64 = P64[_s8ekx::P64 + 15];
           I64[Hp - 24] = sat_s8ekw_info;
           P64[Hp - 8] = _s8eki::P64;
           P64[Hp] = _s8ekk::P64;
           I64[Sp - 16] = block_c8fwF_info;
           R2 = _s8ekk::P64;
           R1 = _s8ekj::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fwF() //  [R1]
         { info_tbl: [(c8fwF,
                       label: block_c8fwF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fwF: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u8fwU_srtd" {
     u8fwU_srtd:
         const S8evg_srt+216;
         const 33;
         const 8522825729;
 },
 GHC.IO.Handle.Types.$fReadBufferMode2_entry() //  [R2]
         { info_tbl: [(c8fwP,
                       label: GHC.IO.Handle.Types.$fReadBufferMode2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fwP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8fwT; else goto c8fwS;
       c8fwT: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8fwS: // global
           I64[Hp - 40] = ds2_s8ekj_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8ekx_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.782537781 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode1_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode1_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode1_info;
         const 0;
 },
 section ""relreadonly" . u8fxS_srtd" {
     u8fxS_srtd:
         const S8evg_srt+160;
         const 40;
         const 549755813889;
 },
 GHC.IO.Handle.Types.$fReadBufferMode1_entry() //  [R2, R3]
         { info_tbl: [(c8fxP,
                       label: GHC.IO.Handle.Types.$fReadBufferMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fxP: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.787226751 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_info;
         const 0;
 },
 section ""relreadonly" . u8fye_srtd" {
     u8fye_srtd:
         const S8evg_srt+160;
         const 40;
         const 549755813889;
 },
 sat_s8ekz_entry() //  [R1]
         { info_tbl: [(c8fy6,
                       label: sat_s8ekz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fy6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fy7; else goto c8fy8;
       c8fy7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fy8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadBufferMode2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u8fyf_srtd" {
     u8fyf_srtd:
         const S8evg_srt+160;
         const 41;
         const 1649267441665;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c8fy9,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fy9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8fyd; else goto c8fyc;
       c8fyd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8fyc: // global
           I64[Hp - 16] = sat_s8ekz_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.79503928 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c8fyA,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fyA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fyB; else goto c8fyC;
       c8fyB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fyC: // global
           (_c8fyx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8fyx::I64 == 0) goto c8fyz; else goto c8fyy;
       c8fyz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8fyy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8fyx::I64;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.799518964 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode14_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode14_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode14_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode14_entry() //  [R1]
         { info_tbl: [(c8fyR,
                       label: GHC.IO.Handle.Types.$fReadBufferMode14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fyR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fyS; else goto c8fyT;
       c8fyS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8fyT: // global
           (_c8fyO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8fyO::I64 == 0) goto c8fyQ; else goto c8fyP;
       c8fyQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8fyP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8fyO::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.803594619 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure:
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadList_info;
         const 0;
 },
 GHC.IO.Handle.Types.$fReadBufferMode_$creadList_entry() //  [R2]
         { info_tbl: [(c8fz7,
                       label: GHC.IO.Handle.Types.$fReadBufferMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fz7: // global
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fReadBufferMode14_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.807268012 UTC

[section ""data" . GHC.IO.Handle.Types.$fReadBufferMode_closure" {
     GHC.IO.Handle.Types.$fReadBufferMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadList_closure+1;
         const GHC.IO.Handle.Types.$fReadBufferMode1_closure+2;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.810616156 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c8fzr,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fzr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fzs; else goto c8fzt;
       c8fzs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fzt: // global
           I64[Sp - 16] = block_c8fzj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fB5; else goto c8fzk;
       u8fB5: // global
           call _c8fzj(R1) args: 0, res: 0, upd: 0;
       c8fzk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fzj() //  [R1]
         { info_tbl: [(c8fzj,
                       label: block_c8fzj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fzj: // global
           _s8ekB::P64 = P64[Sp + 8];
           _c8fzq::P64 = R1 & 7;
           if (_c8fzq::P64 < 3) goto u8fAT; else goto c8fzp;
       u8fAT: // global
           if (_c8fzq::P64 < 2) goto c8fzn; else goto c8fzo;
       c8fzn: // global
           I64[Sp + 8] = block_c8fzw_info;
           R1 = _s8ekB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fB2; else goto c8fzy;
       u8fB2: // global
           call _c8fzw(R1) args: 0, res: 0, upd: 0;
       c8fzy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fzo: // global
           I64[Sp + 8] = block_c8fzL_info;
           R1 = _s8ekB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fB3; else goto c8fzN;
       u8fB3: // global
           call _c8fzL(R1) args: 0, res: 0, upd: 0;
       c8fzN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fzp: // global
           I64[Sp] = block_c8fA0_info;
           _s8ekG::P64 = P64[R1 + 5];
           R1 = _s8ekB::P64;
           P64[Sp + 8] = _s8ekG::P64;
           if (R1 & 7 != 0) goto u8fB4; else goto c8fA2;
       u8fB4: // global
           call _c8fA0(R1) args: 0, res: 0, upd: 0;
       c8fA2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fzw() //  [R1]
         { info_tbl: [(c8fzw,
                       label: block_c8fzw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fzw: // global
           if (R1 & 7 == 1) goto u8fAU; else goto u8fAV;
       u8fAU: // global
           Sp = Sp + 8;
           call _c8fAI() args: 0, res: 0, upd: 0;
       u8fAV: // global
           Sp = Sp + 8;
           call _c8fAw() args: 0, res: 0, upd: 0;
     }
 },
 _c8fzL() //  [R1]
         { info_tbl: [(c8fzL,
                       label: block_c8fzL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fzL: // global
           if (R1 & 7 == 3) goto u8fAW; else goto u8fAX;
       u8fAW: // global
           Sp = Sp + 8;
           call _c8fAw() args: 0, res: 0, upd: 0;
       u8fAX: // global
           Sp = Sp + 8;
           call _c8fAI() args: 0, res: 0, upd: 0;
     }
 },
 _c8fA0() //  [R1]
         { info_tbl: [(c8fA0,
                       label: block_c8fA0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fA0: // global
           if (R1 & 7 == 3) goto c8fAd; else goto u8fAY;
       c8fAd: // global
           I64[Sp] = block_c8fAb_info;
           _s8ekI::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ekI::P64;
           if (R1 & 7 != 0) goto u8fBa; else goto c8fAe;
       u8fBa: // global
           call _c8fAb(R1) args: 0, res: 0, upd: 0;
       c8fAe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fAY: // global
           Sp = Sp + 16;
           call _c8fAI() args: 0, res: 0, upd: 0;
     }
 },
 _c8fAb() //  [R1]
         { info_tbl: [(c8fAb,
                       label: block_c8fAb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fAb: // global
           _s8ekI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fAl; else goto c8fAB;
       c8fAl: // global
           I64[Sp + 8] = block_c8fAi_info;
           R1 = _s8ekI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fBc; else goto c8fAm;
       u8fBc: // global
           call _c8fAi(R1) args: 0, res: 0, upd: 0;
       c8fAm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fAB: // global
           I64[Sp] = block_c8fAz_info;
           _s8ekM::P64 = P64[R1 + 6];
           R1 = _s8ekI::P64;
           P64[Sp + 8] = _s8ekM::P64;
           if (R1 & 7 != 0) goto u8fBd; else goto c8fAC;
       u8fBd: // global
           call _c8fAz(R1) args: 0, res: 0, upd: 0;
       c8fAC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fAi() //  [R1]
         { info_tbl: [(c8fAi,
                       label: block_c8fAi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fAi: // global
           if (R1 & 7 == 1) goto u8fB0; else goto u8fB1;
       u8fB0: // global
           Sp = Sp + 8;
           call _c8fAI() args: 0, res: 0, upd: 0;
       u8fB1: // global
           Sp = Sp + 8;
           call _c8fAw() args: 0, res: 0, upd: 0;
     }
 },
 _c8fAw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fAw: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fAz() //  [R1]
         { info_tbl: [(c8fAz,
                       label: block_c8fAz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fAz: // global
           if (R1 & 7 == 1) goto u8fAZ; else goto c8fAM;
       u8fAZ: // global
           Sp = Sp + 16;
           call _c8fAI() args: 0, res: 0, upd: 0;
       c8fAM: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.ltInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8fAI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fAI: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.831449882 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c8fCs,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fCs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fCt; else goto c8fCu;
       c8fCt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fCu: // global
           I64[Sp - 16] = block_c8fCk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fEc; else goto c8fCl;
       u8fEc: // global
           call _c8fCk(R1) args: 0, res: 0, upd: 0;
       c8fCl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fCk() //  [R1]
         { info_tbl: [(c8fCk,
                       label: block_c8fCk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fCk: // global
           _s8ekQ::P64 = P64[Sp + 8];
           _c8fCr::P64 = R1 & 7;
           if (_c8fCr::P64 < 3) goto u8fDY; else goto c8fCq;
       u8fDY: // global
           if (_c8fCr::P64 < 2) goto c8fCo; else goto c8fCp;
       c8fCo: // global
           I64[Sp + 8] = block_c8fCx_info;
           R1 = _s8ekQ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fE9; else goto c8fCz;
       u8fE9: // global
           call _c8fCx(R1) args: 0, res: 0, upd: 0;
       c8fCz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fCp: // global
           I64[Sp + 8] = block_c8fCM_info;
           R1 = _s8ekQ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fEa; else goto c8fCO;
       u8fEa: // global
           call _c8fCM(R1) args: 0, res: 0, upd: 0;
       c8fCO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fCq: // global
           I64[Sp] = block_c8fD5_info;
           _s8ekV::P64 = P64[R1 + 5];
           R1 = _s8ekQ::P64;
           P64[Sp + 8] = _s8ekV::P64;
           if (R1 & 7 != 0) goto u8fEb; else goto c8fD7;
       u8fEb: // global
           call _c8fD5(R1) args: 0, res: 0, upd: 0;
       c8fD7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fCx() //  [R1]
         { info_tbl: [(c8fCx,
                       label: block_c8fCx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fCx: // global
           if (R1 & 7 == 1) goto u8fE0; else goto u8fE1;
       u8fE0: // global
           Sp = Sp + 8;
           call _c8fDx() args: 0, res: 0, upd: 0;
       u8fE1: // global
           Sp = Sp + 8;
           call _c8fDB() args: 0, res: 0, upd: 0;
     }
 },
 _c8fCM() //  [R1]
         { info_tbl: [(c8fCM,
                       label: block_c8fCM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fCM: // global
           _c8fDW::P64 = R1 & 7;
           if (_c8fDW::P64 < 3) goto u8fDZ; else goto u8fE2;
       u8fDZ: // global
           if (_c8fDW::P64 < 2) goto u8fE4; else goto u8fE3;
       u8fE4: // global
           Sp = Sp + 8;
           call _c8fDN() args: 0, res: 0, upd: 0;
       u8fE3: // global
           Sp = Sp + 8;
           call _c8fDx() args: 0, res: 0, upd: 0;
       u8fE2: // global
           Sp = Sp + 8;
           call _c8fDB() args: 0, res: 0, upd: 0;
     }
 },
 _c8fD5() //  [R1]
         { info_tbl: [(c8fD5,
                       label: block_c8fD5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fD5: // global
           if (R1 & 7 == 3) goto c8fDi; else goto u8fE5;
       c8fDi: // global
           I64[Sp] = block_c8fDg_info;
           _s8ekX::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ekX::P64;
           if (R1 & 7 != 0) goto u8fEi; else goto c8fDj;
       u8fEi: // global
           call _c8fDg(R1) args: 0, res: 0, upd: 0;
       c8fDj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fE5: // global
           Sp = Sp + 16;
           call _c8fDN() args: 0, res: 0, upd: 0;
     }
 },
 _c8fDg() //  [R1]
         { info_tbl: [(c8fDg,
                       label: block_c8fDg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fDg: // global
           _s8ekX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fDq; else goto c8fDG;
       c8fDq: // global
           I64[Sp + 8] = block_c8fDn_info;
           R1 = _s8ekX::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fEk; else goto c8fDr;
       u8fEk: // global
           call _c8fDn(R1) args: 0, res: 0, upd: 0;
       c8fDr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fDG: // global
           I64[Sp] = block_c8fDE_info;
           _s8el1::P64 = P64[R1 + 6];
           R1 = _s8ekX::P64;
           P64[Sp + 8] = _s8el1::P64;
           if (R1 & 7 != 0) goto u8fEl; else goto c8fDH;
       u8fEl: // global
           call _c8fDE(R1) args: 0, res: 0, upd: 0;
       c8fDH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fDn() //  [R1]
         { info_tbl: [(c8fDn,
                       label: block_c8fDn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fDn: // global
           if (R1 & 7 == 1) goto u8fE7; else goto u8fE8;
       u8fE7: // global
           Sp = Sp + 8;
           call _c8fDx() args: 0, res: 0, upd: 0;
       u8fE8: // global
           Sp = Sp + 8;
           call _c8fDB() args: 0, res: 0, upd: 0;
     }
 },
 _c8fDx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fDx: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fDB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fDB: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fDE() //  [R1]
         { info_tbl: [(c8fDE,
                       label: block_c8fDE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fDE: // global
           if (R1 & 7 == 1) goto u8fE6; else goto c8fDR;
       u8fE6: // global
           Sp = Sp + 16;
           call _c8fDN() args: 0, res: 0, upd: 0;
       c8fDR: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.compareInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8fDN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fDN: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.852951041 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure:
         const GHC.IO.Handle.Types.$fEqBufferMode_$c==_info;
 },
 GHC.IO.Handle.Types.$fEqBufferMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c8fFD,
                       label: GHC.IO.Handle.Types.$fEqBufferMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fFD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fFE; else goto c8fFF;
       c8fFE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fFF: // global
           I64[Sp - 16] = block_c8fFv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fHh; else goto c8fFw;
       u8fHh: // global
           call _c8fFv(R1) args: 0, res: 0, upd: 0;
       c8fFw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fFv() //  [R1]
         { info_tbl: [(c8fFv,
                       label: block_c8fFv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fFv: // global
           _s8el5::P64 = P64[Sp + 8];
           _c8fFC::P64 = R1 & 7;
           if (_c8fFC::P64 < 3) goto u8fH5; else goto c8fFB;
       u8fH5: // global
           if (_c8fFC::P64 < 2) goto c8fFz; else goto c8fFA;
       c8fFz: // global
           I64[Sp + 8] = block_c8fFI_info;
           R1 = _s8el5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fHe; else goto c8fFK;
       u8fHe: // global
           call _c8fFI(R1) args: 0, res: 0, upd: 0;
       c8fFK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fFA: // global
           I64[Sp + 8] = block_c8fFX_info;
           R1 = _s8el5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fHf; else goto c8fFZ;
       u8fHf: // global
           call _c8fFX(R1) args: 0, res: 0, upd: 0;
       c8fFZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fFB: // global
           I64[Sp] = block_c8fGc_info;
           _s8el9::P64 = P64[R1 + 5];
           R1 = _s8el5::P64;
           P64[Sp + 8] = _s8el9::P64;
           if (R1 & 7 != 0) goto u8fHg; else goto c8fGe;
       u8fHg: // global
           call _c8fGc(R1) args: 0, res: 0, upd: 0;
       c8fGe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fFI() //  [R1]
         { info_tbl: [(c8fFI,
                       label: block_c8fFI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fFI: // global
           if (R1 & 7 == 1) goto u8fH6; else goto u8fH7;
       u8fH6: // global
           Sp = Sp + 8;
           call _c8fGE() args: 0, res: 0, upd: 0;
       u8fH7: // global
           Sp = Sp + 8;
           call _c8fGU() args: 0, res: 0, upd: 0;
     }
 },
 _c8fFX() //  [R1]
         { info_tbl: [(c8fFX,
                       label: block_c8fFX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fFX: // global
           if (R1 & 7 == 2) goto u8fH8; else goto u8fH9;
       u8fH8: // global
           Sp = Sp + 8;
           call _c8fGE() args: 0, res: 0, upd: 0;
       u8fH9: // global
           Sp = Sp + 8;
           call _c8fGU() args: 0, res: 0, upd: 0;
     }
 },
 _c8fGc() //  [R1]
         { info_tbl: [(c8fGc,
                       label: block_c8fGc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fGc: // global
           if (R1 & 7 == 3) goto c8fGp; else goto u8fHa;
       c8fGp: // global
           I64[Sp] = block_c8fGn_info;
           _s8elb::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8elb::P64;
           if (R1 & 7 != 0) goto u8fHm; else goto c8fGq;
       u8fHm: // global
           call _c8fGn(R1) args: 0, res: 0, upd: 0;
       c8fGq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fHa: // global
           Sp = Sp + 16;
           call _c8fGU() args: 0, res: 0, upd: 0;
     }
 },
 _c8fGn() //  [R1]
         { info_tbl: [(c8fGn,
                       label: block_c8fGn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fGn: // global
           _s8elb::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fGx; else goto c8fGN;
       c8fGx: // global
           I64[Sp + 8] = block_c8fGu_info;
           R1 = _s8elb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fHo; else goto c8fGy;
       u8fHo: // global
           call _c8fGu(R1) args: 0, res: 0, upd: 0;
       c8fGy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fGN: // global
           I64[Sp] = block_c8fGL_info;
           _s8elf::P64 = P64[R1 + 6];
           R1 = _s8elb::P64;
           P64[Sp + 8] = _s8elf::P64;
           if (R1 & 7 != 0) goto u8fHp; else goto c8fGO;
       u8fHp: // global
           call _c8fGL(R1) args: 0, res: 0, upd: 0;
       c8fGO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fGu() //  [R1]
         { info_tbl: [(c8fGu,
                       label: block_c8fGu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fGu: // global
           if (R1 & 7 == 1) goto u8fHc; else goto u8fHd;
       u8fHc: // global
           Sp = Sp + 8;
           call _c8fGE() args: 0, res: 0, upd: 0;
       u8fHd: // global
           Sp = Sp + 8;
           call _c8fGU() args: 0, res: 0, upd: 0;
     }
 },
 _c8fGE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fGE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fGL() //  [R1]
         { info_tbl: [(c8fGL,
                       label: block_c8fGL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fGL: // global
           if (R1 & 7 == 1) goto u8fHb; else goto c8fGY;
       u8fHb: // global
           Sp = Sp + 16;
           call _c8fGU() args: 0, res: 0, upd: 0;
       c8fGY: // global
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.eqInt_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c8fGU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fGU: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.872310427 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure:
         const GHC.IO.Handle.Types.$fEqBufferMode_$c/=_info;
 },
 GHC.IO.Handle.Types.$fEqBufferMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c8fIE,
                       label: GHC.IO.Handle.Types.$fEqBufferMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fIE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fIF; else goto c8fIG;
       c8fIF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fIG: // global
           I64[Sp - 16] = block_c8fIw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fKB; else goto c8fIx;
       u8fKB: // global
           call _c8fIw(R1) args: 0, res: 0, upd: 0;
       c8fIx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fIw() //  [R1]
         { info_tbl: [(c8fIw,
                       label: block_c8fIw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fIw: // global
           _s8elj::P64 = P64[Sp + 8];
           _c8fID::P64 = R1 & 7;
           if (_c8fID::P64 < 3) goto u8fKn; else goto c8fIC;
       u8fKn: // global
           if (_c8fID::P64 < 2) goto c8fIA; else goto c8fIB;
       c8fIA: // global
           I64[Sp + 8] = block_c8fIJ_info;
           R1 = _s8elj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fKy; else goto c8fIL;
       u8fKy: // global
           call _c8fIJ(R1) args: 0, res: 0, upd: 0;
       c8fIL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fIB: // global
           I64[Sp + 8] = block_c8fIY_info;
           R1 = _s8elj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fKz; else goto c8fJ0;
       u8fKz: // global
           call _c8fIY(R1) args: 0, res: 0, upd: 0;
       c8fJ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fIC: // global
           I64[Sp] = block_c8fJd_info;
           _s8eln::P64 = P64[R1 + 5];
           R1 = _s8elj::P64;
           P64[Sp + 8] = _s8eln::P64;
           if (R1 & 7 != 0) goto u8fKA; else goto c8fJf;
       u8fKA: // global
           call _c8fJd(R1) args: 0, res: 0, upd: 0;
       c8fJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fIJ() //  [R1]
         { info_tbl: [(c8fIJ,
                       label: block_c8fIJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fIJ: // global
           if (R1 & 7 == 1) goto u8fKo; else goto u8fKp;
       u8fKo: // global
           Sp = Sp + 8;
           call _c8fKg() args: 0, res: 0, upd: 0;
       u8fKp: // global
           Sp = Sp + 8;
           call _c8fKf() args: 0, res: 0, upd: 0;
     }
 },
 _c8fIY() //  [R1]
         { info_tbl: [(c8fIY,
                       label: block_c8fIY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fIY: // global
           if (R1 & 7 == 2) goto u8fKq; else goto u8fKr;
       u8fKq: // global
           Sp = Sp + 8;
           call _c8fKg() args: 0, res: 0, upd: 0;
       u8fKr: // global
           Sp = Sp + 8;
           call _c8fKf() args: 0, res: 0, upd: 0;
     }
 },
 _c8fJd() //  [R1]
         { info_tbl: [(c8fJd,
                       label: block_c8fJd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fJd: // global
           if (R1 & 7 == 3) goto c8fJq; else goto u8fKs;
       c8fJq: // global
           I64[Sp] = block_c8fJo_info;
           _s8elp::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8elp::P64;
           if (R1 & 7 != 0) goto u8fKG; else goto c8fJr;
       u8fKG: // global
           call _c8fJo(R1) args: 0, res: 0, upd: 0;
       c8fJr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fKs: // global
           Sp = Sp + 16;
           call _c8fKf() args: 0, res: 0, upd: 0;
     }
 },
 _c8fJo() //  [R1]
         { info_tbl: [(c8fJo,
                       label: block_c8fJo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fJo: // global
           _s8elp::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fJy; else goto c8fJO;
       c8fJy: // global
           I64[Sp + 8] = block_c8fJv_info;
           R1 = _s8elp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fKI; else goto c8fJz;
       u8fKI: // global
           call _c8fJv(R1) args: 0, res: 0, upd: 0;
       c8fJz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fJO: // global
           I64[Sp] = block_c8fJM_info;
           _s8elt::P64 = P64[R1 + 6];
           R1 = _s8elp::P64;
           P64[Sp + 8] = _s8elt::P64;
           if (R1 & 7 != 0) goto u8fKJ; else goto c8fJP;
       u8fKJ: // global
           call _c8fJM(R1) args: 0, res: 0, upd: 0;
       c8fJP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fJv() //  [R1]
         { info_tbl: [(c8fJv,
                       label: block_c8fJv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fJv: // global
           if (R1 & 7 == 1) goto u8fKw; else goto u8fKx;
       u8fKw: // global
           Sp = Sp + 8;
           call _c8fKg() args: 0, res: 0, upd: 0;
       u8fKx: // global
           Sp = Sp + 8;
           call _c8fKf() args: 0, res: 0, upd: 0;
     }
 },
 _c8fJM() //  [R1]
         { info_tbl: [(c8fJM,
                       label: block_c8fJM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fJM: // global
           if (R1 & 7 == 1) goto u8fKt; else goto c8fK5;
       u8fKt: // global
           Sp = Sp + 16;
           call _c8fKf() args: 0, res: 0, upd: 0;
       c8fK5: // global
           I64[Sp] = block_c8fJY_info;
           _s8elv::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8elv::P64;
           if (R1 & 7 != 0) goto u8fKM; else goto c8fJZ;
       u8fKM: // global
           call _c8fJY(R1) args: 0, res: 0, upd: 0;
       c8fJZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fJY() //  [R1]
         { info_tbl: [(c8fJY,
                       label: block_c8fJY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fJY: // global
           I64[Sp] = block_c8fK3_info;
           _s8elx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8elx::I64;
           if (R1 & 7 != 0) goto u8fKO; else goto c8fK7;
       u8fKO: // global
           call _c8fK3(R1) args: 0, res: 0, upd: 0;
       c8fK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fK3() //  [R1]
         { info_tbl: [(c8fK3,
                       label: block_c8fK3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fK3: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u8fKu; else goto u8fKv;
       u8fKu: // global
           Sp = Sp + 16;
           call _c8fKg() args: 0, res: 0, upd: 0;
       u8fKv: // global
           Sp = Sp + 16;
           call _c8fKf() args: 0, res: 0, upd: 0;
     }
 },
 _c8fKg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fKg: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fKf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fKf: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.895110031 UTC

[section ""data" . GHC.IO.Handle.Types.$fEqBufferMode_closure" {
     GHC.IO.Handle.Types.$fEqBufferMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.Types.$fEqBufferMode_$c==_closure+2;
         const GHC.IO.Handle.Types.$fEqBufferMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.89845872 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c8fMe,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fMe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fMf; else goto c8fMg;
       c8fMf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fMg: // global
           I64[Sp - 16] = block_c8fM6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fOb; else goto c8fM7;
       u8fOb: // global
           call _c8fM6(R1) args: 0, res: 0, upd: 0;
       c8fM7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fM6() //  [R1]
         { info_tbl: [(c8fM6,
                       label: block_c8fM6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fM6: // global
           _s8elB::P64 = P64[Sp + 8];
           _c8fMd::P64 = R1 & 7;
           if (_c8fMd::P64 < 3) goto u8fNX; else goto c8fMc;
       u8fNX: // global
           if (_c8fMd::P64 < 2) goto c8fMa; else goto c8fMb;
       c8fMa: // global
           I64[Sp + 8] = block_c8fMj_info;
           R1 = _s8elB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fO8; else goto c8fMl;
       u8fO8: // global
           call _c8fMj(R1) args: 0, res: 0, upd: 0;
       c8fMl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fMb: // global
           I64[Sp + 8] = block_c8fMy_info;
           R1 = _s8elB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fO9; else goto c8fMA;
       u8fO9: // global
           call _c8fMy(R1) args: 0, res: 0, upd: 0;
       c8fMA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fMc: // global
           I64[Sp] = block_c8fMN_info;
           _s8elH::P64 = P64[R1 + 5];
           R1 = _s8elB::P64;
           P64[Sp + 8] = _s8elH::P64;
           if (R1 & 7 != 0) goto u8fOa; else goto c8fMP;
       u8fOa: // global
           call _c8fMN(R1) args: 0, res: 0, upd: 0;
       c8fMP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fMj() //  [R1]
         { info_tbl: [(c8fMj,
                       label: block_c8fMj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fMj: // global
           if (R1 & 7 == 1) goto u8fNY; else goto u8fNZ;
       u8fNY: // global
           Sp = Sp + 8;
           call _c8fNP() args: 0, res: 0, upd: 0;
       u8fNZ: // global
           Sp = Sp + 8;
           call _c8fNQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8fMy() //  [R1]
         { info_tbl: [(c8fMy,
                       label: block_c8fMy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fMy: // global
           if (R1 & 7 == 3) goto u8fO0; else goto u8fO1;
       u8fO0: // global
           Sp = Sp + 8;
           call _c8fNQ() args: 0, res: 0, upd: 0;
       u8fO1: // global
           Sp = Sp + 8;
           call _c8fNP() args: 0, res: 0, upd: 0;
     }
 },
 _c8fMN() //  [R1]
         { info_tbl: [(c8fMN,
                       label: block_c8fMN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fMN: // global
           if (R1 & 7 == 3) goto c8fN0; else goto u8fO2;
       c8fN0: // global
           I64[Sp] = block_c8fMY_info;
           _s8elJ::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8elJ::P64;
           if (R1 & 7 != 0) goto u8fOg; else goto c8fN1;
       u8fOg: // global
           call _c8fMY(R1) args: 0, res: 0, upd: 0;
       c8fN1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fO2: // global
           Sp = Sp + 16;
           call _c8fNP() args: 0, res: 0, upd: 0;
     }
 },
 _c8fMY() //  [R1]
         { info_tbl: [(c8fMY,
                       label: block_c8fMY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fMY: // global
           _s8elJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fN8; else goto c8fNo;
       c8fN8: // global
           I64[Sp + 8] = block_c8fN5_info;
           R1 = _s8elJ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fOi; else goto c8fN9;
       u8fOi: // global
           call _c8fN5(R1) args: 0, res: 0, upd: 0;
       c8fN9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fNo: // global
           I64[Sp] = block_c8fNm_info;
           _s8elN::P64 = P64[R1 + 6];
           R1 = _s8elJ::P64;
           P64[Sp + 8] = _s8elN::P64;
           if (R1 & 7 != 0) goto u8fOj; else goto c8fNp;
       u8fOj: // global
           call _c8fNm(R1) args: 0, res: 0, upd: 0;
       c8fNp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fN5() //  [R1]
         { info_tbl: [(c8fN5,
                       label: block_c8fN5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fN5: // global
           if (R1 & 7 == 1) goto u8fO6; else goto u8fO7;
       u8fO6: // global
           Sp = Sp + 8;
           call _c8fNP() args: 0, res: 0, upd: 0;
       u8fO7: // global
           Sp = Sp + 8;
           call _c8fNQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8fNm() //  [R1]
         { info_tbl: [(c8fNm,
                       label: block_c8fNm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fNm: // global
           if (R1 & 7 == 1) goto u8fO3; else goto c8fNF;
       u8fO3: // global
           Sp = Sp + 16;
           call _c8fNP() args: 0, res: 0, upd: 0;
       c8fNF: // global
           I64[Sp] = block_c8fNy_info;
           _s8elP::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8elP::P64;
           if (R1 & 7 != 0) goto u8fOm; else goto c8fNz;
       u8fOm: // global
           call _c8fNy(R1) args: 0, res: 0, upd: 0;
       c8fNz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fNy() //  [R1]
         { info_tbl: [(c8fNy,
                       label: block_c8fNy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fNy: // global
           I64[Sp] = block_c8fND_info;
           _s8elR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8elR::I64;
           if (R1 & 7 != 0) goto u8fOo; else goto c8fNH;
       u8fOo: // global
           call _c8fND(R1) args: 0, res: 0, upd: 0;
       c8fNH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fND() //  [R1]
         { info_tbl: [(c8fND,
                       label: block_c8fND_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fND: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8fO5; else goto u8fO4;
       u8fO5: // global
           Sp = Sp + 16;
           call _c8fNP() args: 0, res: 0, upd: 0;
       u8fO4: // global
           Sp = Sp + 16;
           call _c8fNQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8fNQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fNQ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fNP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fNP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.922026001 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c8fPN,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fPN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8fPO; else goto c8fPP;
       c8fPO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fPP: // global
           I64[Sp - 16] = block_c8fPF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fRs; else goto c8fPG;
       u8fRs: // global
           call _c8fPF(R1) args: 0, res: 0, upd: 0;
       c8fPG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fPF() //  [R1]
         { info_tbl: [(c8fPF,
                       label: block_c8fPF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fPF: // global
           _s8elV::P64 = P64[Sp + 8];
           _c8fPM::P64 = R1 & 7;
           if (_c8fPM::P64 < 3) goto u8fRj; else goto c8fPL;
       u8fRj: // global
           if (_c8fPM::P64 < 2) goto c8fPJ; else goto c8fPK;
       c8fPJ: // global
           R1 = _s8elV::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8fPK: // global
           I64[Sp + 8] = block_c8fPV_info;
           R1 = _s8elV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fRq; else goto c8fPX;
       u8fRq: // global
           call _c8fPV(R1) args: 0, res: 0, upd: 0;
       c8fPX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fPL: // global
           I64[Sp - 8] = block_c8fQa_info;
           _s8elX::P64 = R1;
           _s8em0::P64 = P64[R1 + 5];
           R1 = _s8elV::P64;
           P64[Sp] = _s8em0::P64;
           P64[Sp + 8] = _s8elX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8fRr; else goto c8fQc;
       u8fRr: // global
           call _c8fQa(R1) args: 0, res: 0, upd: 0;
       c8fQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fPV() //  [R1]
         { info_tbl: [(c8fPV,
                       label: block_c8fPV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fPV: // global
           if (R1 & 7 == 3) goto c8fQ7; else goto c8fQ3;
       c8fQ7: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c8fQ3: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fQa() //  [R1]
         { info_tbl: [(c8fQa,
                       label: block_c8fQa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fQa: // global
           if (R1 & 7 == 3) goto c8fQn; else goto u8fRk;
       c8fQn: // global
           I64[Sp - 8] = block_c8fQl_info;
           _s8em1::P64 = R1;
           _s8em2::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8em2::P64;
           P64[Sp + 8] = _s8em1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8fRt; else goto c8fQo;
       u8fRt: // global
           call _c8fQl(R1) args: 0, res: 0, upd: 0;
       c8fQo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fRk: // global
           Sp = Sp + 16;
           call _c8fRc() args: 0, res: 0, upd: 0;
     }
 },
 _c8fQl() //  [R1]
         { info_tbl: [(c8fQl,
                       label: block_c8fQl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fQl: // global
           _s8em2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fQv; else goto c8fQL;
       c8fQv: // global
           I64[Sp + 8] = block_c8fQs_info;
           R1 = _s8em2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fRv; else goto c8fQw;
       u8fRv: // global
           call _c8fQs(R1) args: 0, res: 0, upd: 0;
       c8fQw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fQL: // global
           I64[Sp] = block_c8fQJ_info;
           _s8em6::P64 = P64[R1 + 6];
           R1 = _s8em2::P64;
           P64[Sp + 8] = _s8em6::P64;
           if (R1 & 7 != 0) goto u8fRw; else goto c8fQM;
       u8fRw: // global
           call _c8fQJ(R1) args: 0, res: 0, upd: 0;
       c8fQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fQs() //  [R1]
         { info_tbl: [(c8fQs,
                       label: block_c8fQs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fQs: // global
           if (R1 & 7 == 1) goto u8fRo; else goto u8fRp;
       u8fRo: // global
           Sp = Sp + 16;
           call _c8fRc() args: 0, res: 0, upd: 0;
       u8fRp: // global
           Sp = Sp + 8;
           call _c8fRd() args: 0, res: 0, upd: 0;
     }
 },
 _c8fQJ() //  [R1]
         { info_tbl: [(c8fQJ,
                       label: block_c8fQJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fQJ: // global
           if (R1 & 7 == 1) goto u8fRl; else goto c8fR2;
       u8fRl: // global
           Sp = Sp + 24;
           call _c8fRc() args: 0, res: 0, upd: 0;
       c8fR2: // global
           I64[Sp] = block_c8fQV_info;
           _s8em8::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8em8::P64;
           if (R1 & 7 != 0) goto u8fRz; else goto c8fQW;
       u8fRz: // global
           call _c8fQV(R1) args: 0, res: 0, upd: 0;
       c8fQW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fQV() //  [R1]
         { info_tbl: [(c8fQV,
                       label: block_c8fQV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fQV: // global
           I64[Sp] = block_c8fR0_info;
           _s8ema::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8ema::I64;
           if (R1 & 7 != 0) goto u8fRB; else goto c8fR4;
       u8fRB: // global
           call _c8fR0(R1) args: 0, res: 0, upd: 0;
       c8fR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fR0() //  [R1]
         { info_tbl: [(c8fR0,
                       label: block_c8fR0_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fR0: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8fRn; else goto u8fRm;
       u8fRn: // global
           Sp = Sp + 24;
           call _c8fRc() args: 0, res: 0, upd: 0;
       u8fRm: // global
           Sp = Sp + 16;
           call _c8fRd() args: 0, res: 0, upd: 0;
     }
 },
 _c8fRd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fRd: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fRc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fRc: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.94514169 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c8fSY,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fSY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8fSZ; else goto c8fT0;
       c8fSZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fT0: // global
           I64[Sp - 16] = block_c8fSQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fUV; else goto c8fSR;
       u8fUV: // global
           call _c8fSQ(R1) args: 0, res: 0, upd: 0;
       c8fSR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fSQ() //  [R1]
         { info_tbl: [(c8fSQ,
                       label: block_c8fSQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fSQ: // global
           _s8emf::P64 = P64[Sp + 8];
           _c8fSX::P64 = R1 & 7;
           if (_c8fSX::P64 < 3) goto u8fUH; else goto c8fSW;
       u8fUH: // global
           if (_c8fSX::P64 < 2) goto c8fSU; else goto c8fSV;
       c8fSU: // global
           I64[Sp + 8] = block_c8fT3_info;
           R1 = _s8emf::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fUS; else goto c8fT5;
       u8fUS: // global
           call _c8fT3(R1) args: 0, res: 0, upd: 0;
       c8fT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fSV: // global
           I64[Sp + 8] = block_c8fTi_info;
           R1 = _s8emf::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fUT; else goto c8fTk;
       u8fUT: // global
           call _c8fTi(R1) args: 0, res: 0, upd: 0;
       c8fTk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fSW: // global
           I64[Sp] = block_c8fTx_info;
           _s8emk::P64 = P64[R1 + 5];
           R1 = _s8emf::P64;
           P64[Sp + 8] = _s8emk::P64;
           if (R1 & 7 != 0) goto u8fUU; else goto c8fTz;
       u8fUU: // global
           call _c8fTx(R1) args: 0, res: 0, upd: 0;
       c8fTz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fT3() //  [R1]
         { info_tbl: [(c8fT3,
                       label: block_c8fT3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fT3: // global
           if (R1 & 7 == 1) goto u8fUI; else goto u8fUJ;
       u8fUI: // global
           Sp = Sp + 8;
           call _c8fUz() args: 0, res: 0, upd: 0;
       u8fUJ: // global
           Sp = Sp + 8;
           call _c8fUA() args: 0, res: 0, upd: 0;
     }
 },
 _c8fTi() //  [R1]
         { info_tbl: [(c8fTi,
                       label: block_c8fTi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fTi: // global
           if (R1 & 7 == 3) goto u8fUK; else goto u8fUL;
       u8fUK: // global
           Sp = Sp + 8;
           call _c8fUA() args: 0, res: 0, upd: 0;
       u8fUL: // global
           Sp = Sp + 8;
           call _c8fUz() args: 0, res: 0, upd: 0;
     }
 },
 _c8fTx() //  [R1]
         { info_tbl: [(c8fTx,
                       label: block_c8fTx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fTx: // global
           if (R1 & 7 == 3) goto c8fTK; else goto u8fUM;
       c8fTK: // global
           I64[Sp] = block_c8fTI_info;
           _s8emm::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8emm::P64;
           if (R1 & 7 != 0) goto u8fV0; else goto c8fTL;
       u8fV0: // global
           call _c8fTI(R1) args: 0, res: 0, upd: 0;
       c8fTL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fUM: // global
           Sp = Sp + 16;
           call _c8fUz() args: 0, res: 0, upd: 0;
     }
 },
 _c8fTI() //  [R1]
         { info_tbl: [(c8fTI,
                       label: block_c8fTI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fTI: // global
           _s8emm::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fTS; else goto c8fU8;
       c8fTS: // global
           I64[Sp + 8] = block_c8fTP_info;
           R1 = _s8emm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fV2; else goto c8fTT;
       u8fV2: // global
           call _c8fTP(R1) args: 0, res: 0, upd: 0;
       c8fTT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fU8: // global
           I64[Sp] = block_c8fU6_info;
           _s8emq::P64 = P64[R1 + 6];
           R1 = _s8emm::P64;
           P64[Sp + 8] = _s8emq::P64;
           if (R1 & 7 != 0) goto u8fV3; else goto c8fU9;
       u8fV3: // global
           call _c8fU6(R1) args: 0, res: 0, upd: 0;
       c8fU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fTP() //  [R1]
         { info_tbl: [(c8fTP,
                       label: block_c8fTP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fTP: // global
           if (R1 & 7 == 1) goto u8fUQ; else goto u8fUR;
       u8fUQ: // global
           Sp = Sp + 8;
           call _c8fUz() args: 0, res: 0, upd: 0;
       u8fUR: // global
           Sp = Sp + 8;
           call _c8fUA() args: 0, res: 0, upd: 0;
     }
 },
 _c8fU6() //  [R1]
         { info_tbl: [(c8fU6,
                       label: block_c8fU6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fU6: // global
           if (R1 & 7 == 1) goto u8fUN; else goto c8fUp;
       u8fUN: // global
           Sp = Sp + 16;
           call _c8fUz() args: 0, res: 0, upd: 0;
       c8fUp: // global
           I64[Sp] = block_c8fUi_info;
           _s8ems::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ems::P64;
           if (R1 & 7 != 0) goto u8fV6; else goto c8fUj;
       u8fV6: // global
           call _c8fUi(R1) args: 0, res: 0, upd: 0;
       c8fUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fUi() //  [R1]
         { info_tbl: [(c8fUi,
                       label: block_c8fUi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fUi: // global
           I64[Sp] = block_c8fUn_info;
           _s8emu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8emu::I64;
           if (R1 & 7 != 0) goto u8fV8; else goto c8fUr;
       u8fV8: // global
           call _c8fUn(R1) args: 0, res: 0, upd: 0;
       c8fUr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fUn() //  [R1]
         { info_tbl: [(c8fUn,
                       label: block_c8fUn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fUn: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8fUP; else goto u8fUO;
       u8fUP: // global
           Sp = Sp + 16;
           call _c8fUz() args: 0, res: 0, upd: 0;
       u8fUO: // global
           Sp = Sp + 16;
           call _c8fUA() args: 0, res: 0, upd: 0;
     }
 },
 _c8fUA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fUA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fUz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fUz: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.968099666 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c8fWp,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fWp: // global
           _s8emz::P64 = R3;
           R3 = R2;
           R2 = _s8emz::P64;
           call GHC.IO.Handle.Types.$fOrdBufferMode_$c<_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.973062571 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure:
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_info;
 },
 GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c8fWI,
                       label: GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fWI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8fWJ; else goto c8fWK;
       c8fWJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8fWK: // global
           I64[Sp - 16] = block_c8fWA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8fYu; else goto c8fWB;
       u8fYu: // global
           call _c8fWA(R1) args: 0, res: 0, upd: 0;
       c8fWB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fWA() //  [R1]
         { info_tbl: [(c8fWA,
                       label: block_c8fWA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fWA: // global
           _s8emA::P64 = P64[Sp + 8];
           _c8fWH::P64 = R1 & 7;
           if (_c8fWH::P64 < 3) goto u8fYk; else goto c8fWG;
       u8fYk: // global
           if (_c8fWH::P64 < 2) goto c8fWE; else goto c8fWF;
       c8fWE: // global
           I64[Sp + 8] = block_c8fWN_info;
           R1 = _s8emA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fYr; else goto c8fWP;
       u8fYr: // global
           call _c8fWN() args: 0, res: 0, upd: 0;
       c8fWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fWF: // global
           I64[Sp + 8] = block_c8fWW_info;
           R1 = _s8emA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fYs; else goto c8fWY;
       u8fYs: // global
           call _c8fWW(R1) args: 0, res: 0, upd: 0;
       c8fWY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fWG: // global
           I64[Sp - 8] = block_c8fXb_info;
           _s8emC::P64 = R1;
           _s8emG::P64 = P64[R1 + 5];
           R1 = _s8emA::P64;
           P64[Sp] = _s8emG::P64;
           P64[Sp + 8] = _s8emC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8fYt; else goto c8fXd;
       u8fYt: // global
           call _c8fXb(R1) args: 0, res: 0, upd: 0;
       c8fXd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fWN() //  []
         { info_tbl: [(c8fWN,
                       label: block_c8fWN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fWN: // global
           R1 = GHC.IO.Handle.Types.NoBuffering_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fWW() //  [R1]
         { info_tbl: [(c8fWW,
                       label: block_c8fWW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fWW: // global
           if (R1 & 7 == 3) goto c8fX8; else goto c8fX4;
       c8fX8: // global
           R1 = GHC.IO.Handle.Types.LineBuffering_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8fX4: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fXb() //  [R1]
         { info_tbl: [(c8fXb,
                       label: block_c8fXb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fXb: // global
           if (R1 & 7 == 3) goto c8fXo; else goto u8fYl;
       c8fXo: // global
           I64[Sp - 8] = block_c8fXm_info;
           _s8emH::P64 = R1;
           _s8emI::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s8emI::P64;
           P64[Sp + 8] = _s8emH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8fYv; else goto c8fXp;
       u8fYv: // global
           call _c8fXm(R1) args: 0, res: 0, upd: 0;
       c8fXp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8fYl: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c8fYd() args: 0, res: 0, upd: 0;
     }
 },
 _c8fXm() //  [R1]
         { info_tbl: [(c8fXm,
                       label: block_c8fXm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fXm: // global
           _s8emI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8fXw; else goto c8fXM;
       c8fXw: // global
           I64[Sp + 8] = block_c8fXt_info;
           R1 = _s8emI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8fYx; else goto c8fXx;
       u8fYx: // global
           call _c8fXt(R1) args: 0, res: 0, upd: 0;
       c8fXx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8fXM: // global
           I64[Sp] = block_c8fXK_info;
           _s8emM::P64 = P64[R1 + 6];
           R1 = _s8emI::P64;
           P64[Sp + 8] = _s8emM::P64;
           if (R1 & 7 != 0) goto u8fYy; else goto c8fXN;
       u8fYy: // global
           call _c8fXK(R1) args: 0, res: 0, upd: 0;
       c8fXN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fXt() //  [R1]
         { info_tbl: [(c8fXt,
                       label: block_c8fXt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fXt: // global
           if (R1 & 7 == 1) goto u8fYp; else goto u8fYq;
       u8fYp: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8fYd() args: 0, res: 0, upd: 0;
       u8fYq: // global
           Sp = Sp + 16;
           call _c8fYe() args: 0, res: 0, upd: 0;
     }
 },
 _c8fXK() //  [R1]
         { info_tbl: [(c8fXK,
                       label: block_c8fXK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fXK: // global
           if (R1 & 7 == 1) goto u8fYm; else goto c8fY3;
       u8fYm: // global
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp + 24;
           call _c8fYd() args: 0, res: 0, upd: 0;
       c8fY3: // global
           I64[Sp] = block_c8fXW_info;
           _s8emO::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8emO::P64;
           if (R1 & 7 != 0) goto u8fYB; else goto c8fXX;
       u8fYB: // global
           call _c8fXW(R1) args: 0, res: 0, upd: 0;
       c8fXX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fXW() //  [R1]
         { info_tbl: [(c8fXW,
                       label: block_c8fXW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fXW: // global
           I64[Sp] = block_c8fY1_info;
           _s8emQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8emQ::I64;
           if (R1 & 7 != 0) goto u8fYD; else goto c8fY5;
       u8fYD: // global
           call _c8fY1(R1) args: 0, res: 0, upd: 0;
       c8fY5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8fY1() //  [R1]
         { info_tbl: [(c8fY1,
                       label: block_c8fY1_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fY1: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u8fYo; else goto u8fYn;
       u8fYo: // global
           P64[Sp + 24] = P64[Sp + 16];
           Sp = Sp + 24;
           call _c8fYd() args: 0, res: 0, upd: 0;
       u8fYn: // global
           Sp = Sp + 24;
           call _c8fYe() args: 0, res: 0, upd: 0;
     }
 },
 _c8fYe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fYe: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8fYd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8fYd: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.996390022 UTC

[section ""data" . GHC.IO.Handle.Types.$fOrdBufferMode_closure" {
     GHC.IO.Handle.Types.$fOrdBufferMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.Handle.Types.$fEqBufferMode_closure+1;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$ccompare_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c<=_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$c>=_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmax_closure+2;
         const GHC.IO.Handle.Types.$fOrdBufferMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:22.998578346 UTC

[section ""data" . GHC.IO.Handle.Types.haOtherSide_closure" {
     GHC.IO.Handle.Types.haOtherSide_closure:
         const GHC.IO.Handle.Types.haOtherSide_info;
 },
 GHC.IO.Handle.Types.haOtherSide_entry() //  [R2]
         { info_tbl: [(c8g03,
                       label: GHC.IO.Handle.Types.haOtherSide_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g03: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g04; else goto c8g05;
       c8g04: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haOtherSide_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g05: // global
           I64[Sp - 8] = block_c8g00_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g09; else goto c8g01;
       u8g09: // global
           call _c8g00(R1) args: 0, res: 0, upd: 0;
       c8g01: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g00() //  [R1]
         { info_tbl: [(c8g00,
                       label: block_c8g00_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g00: // global
           R1 = P64[R1 + 127] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.004377848 UTC

[section ""data" . GHC.IO.Handle.Types.haOutputNL_closure" {
     GHC.IO.Handle.Types.haOutputNL_closure:
         const GHC.IO.Handle.Types.haOutputNL_info;
 },
 GHC.IO.Handle.Types.haOutputNL_entry() //  [R2]
         { info_tbl: [(c8g0t,
                       label: GHC.IO.Handle.Types.haOutputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g0t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g0u; else goto c8g0v;
       c8g0u: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haOutputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g0v: // global
           I64[Sp - 8] = block_c8g0q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g0z; else goto c8g0r;
       u8g0z: // global
           call _c8g0q(R1) args: 0, res: 0, upd: 0;
       c8g0r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g0q() //  [R1]
         { info_tbl: [(c8g0q,
                       label: block_c8g0q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g0q: // global
           R1 = P64[R1 + 119] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.009570493 UTC

[section ""data" . GHC.IO.Handle.Types.haInputNL_closure" {
     GHC.IO.Handle.Types.haInputNL_closure:
         const GHC.IO.Handle.Types.haInputNL_info;
 },
 GHC.IO.Handle.Types.haInputNL_entry() //  [R2]
         { info_tbl: [(c8g0T,
                       label: GHC.IO.Handle.Types.haInputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g0T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g0U; else goto c8g0V;
       c8g0U: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haInputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g0V: // global
           I64[Sp - 8] = block_c8g0Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g0Z; else goto c8g0R;
       u8g0Z: // global
           call _c8g0Q(R1) args: 0, res: 0, upd: 0;
       c8g0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g0Q() //  [R1]
         { info_tbl: [(c8g0Q,
                       label: block_c8g0Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g0Q: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.015118198 UTC

[section ""data" . GHC.IO.Handle.Types.haCodec_closure" {
     GHC.IO.Handle.Types.haCodec_closure:
         const GHC.IO.Handle.Types.haCodec_info;
 },
 GHC.IO.Handle.Types.haCodec_entry() //  [R2]
         { info_tbl: [(c8g1j,
                       label: GHC.IO.Handle.Types.haCodec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g1j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g1k; else goto c8g1l;
       c8g1k: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haCodec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g1l: // global
           I64[Sp - 8] = block_c8g1g_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g1p; else goto c8g1h;
       u8g1p: // global
           call _c8g1g(R1) args: 0, res: 0, upd: 0;
       c8g1h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g1g() //  [R1]
         { info_tbl: [(c8g1g,
                       label: block_c8g1g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g1g: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.020147381 UTC

[section ""data" . GHC.IO.Handle.Types.haDecoder_closure" {
     GHC.IO.Handle.Types.haDecoder_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.023766515 UTC

[section ""data" . GHC.IO.Handle.Types.haEncoder_closure" {
     GHC.IO.Handle.Types.haEncoder_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.025741945 UTC

[section ""data" . GHC.IO.Handle.Types.haBuffers_closure" {
     GHC.IO.Handle.Types.haBuffers_closure:
         const GHC.IO.Handle.Types.haBuffers_info;
 },
 GHC.IO.Handle.Types.haBuffers_entry() //  [R2]
         { info_tbl: [(c8g1L,
                       label: GHC.IO.Handle.Types.haBuffers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g1L: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g1P; else goto c8g1Q;
       c8g1P: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haBuffers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g1Q: // global
           I64[Sp - 8] = block_c8g1I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g1U; else goto c8g1J;
       u8g1U: // global
           call _c8g1I(R1) args: 0, res: 0, upd: 0;
       c8g1J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g1I() //  [R1]
         { info_tbl: [(c8g1I,
                       label: block_c8g1I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g1I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8g1T; else goto c8g1S;
       c8g1T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8g1S: // global
           _s8eof::P64 = P64[R1 + 79];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8eof::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.031785158 UTC

[section ""data" . GHC.IO.Handle.Types.haCharBuffer_closure" {
     GHC.IO.Handle.Types.haCharBuffer_closure:
         const GHC.IO.Handle.Types.haCharBuffer_info;
 },
 GHC.IO.Handle.Types.haCharBuffer_entry() //  [R2]
         { info_tbl: [(c8g2e,
                       label: GHC.IO.Handle.Types.haCharBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g2e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g2i; else goto c8g2j;
       c8g2i: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haCharBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g2j: // global
           I64[Sp - 8] = block_c8g2b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g2n; else goto c8g2c;
       u8g2n: // global
           call _c8g2b(R1) args: 0, res: 0, upd: 0;
       c8g2c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g2b() //  [R1]
         { info_tbl: [(c8g2b,
                       label: block_c8g2b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g2b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8g2m; else goto c8g2l;
       c8g2m: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8g2l: // global
           _s8eow::P64 = P64[R1 + 71];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8eow::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.03719349 UTC

[section ""data" . GHC.IO.Handle.Types.haLastDecode_closure" {
     GHC.IO.Handle.Types.haLastDecode_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.038978949 UTC

[section ""data" . GHC.IO.Handle.Types.haBufferMode_closure" {
     GHC.IO.Handle.Types.haBufferMode_closure:
         const GHC.IO.Handle.Types.haBufferMode_info;
 },
 GHC.IO.Handle.Types.haBufferMode_entry() //  [R2]
         { info_tbl: [(c8g2I,
                       label: GHC.IO.Handle.Types.haBufferMode_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g2I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g2J; else goto c8g2K;
       c8g2J: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haBufferMode_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g2K: // global
           I64[Sp - 8] = block_c8g2F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g2O; else goto c8g2G;
       u8g2O: // global
           call _c8g2F(R1) args: 0, res: 0, upd: 0;
       c8g2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g2F() //  [R1]
         { info_tbl: [(c8g2F,
                       label: block_c8g2F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g2F: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.044672011 UTC

[section ""data" . GHC.IO.Handle.Types.haByteBuffer_closure" {
     GHC.IO.Handle.Types.haByteBuffer_closure:
         const GHC.IO.Handle.Types.haByteBuffer_info;
 },
 GHC.IO.Handle.Types.haByteBuffer_entry() //  [R2]
         { info_tbl: [(c8g38,
                       label: GHC.IO.Handle.Types.haByteBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g38: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g3c; else goto c8g3d;
       c8g3c: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haByteBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g3d: // global
           I64[Sp - 8] = block_c8g35_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g3h; else goto c8g36;
       u8g3h: // global
           call _c8g35(R1) args: 0, res: 0, upd: 0;
       c8g36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g35() //  [R1]
         { info_tbl: [(c8g35,
                       label: block_c8g35_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g35: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8g3g; else goto c8g3f;
       c8g3g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8g3f: // global
           _s8ep3::P64 = P64[R1 + 47];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s8ep3::P64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.050455786 UTC

[section ""data" . GHC.IO.Handle.Types.haType_closure" {
     GHC.IO.Handle.Types.haType_closure:
         const GHC.IO.Handle.Types.haType_info;
 },
 GHC.IO.Handle.Types.haType_entry() //  [R2]
         { info_tbl: [(c8g3B,
                       label: GHC.IO.Handle.Types.haType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g3B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g3C; else goto c8g3D;
       c8g3C: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.haType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g3D: // global
           I64[Sp - 8] = block_c8g3y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g3H; else goto c8g3z;
       u8g3H: // global
           call _c8g3y(R1) args: 0, res: 0, upd: 0;
       c8g3z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g3y() //  [R1]
         { info_tbl: [(c8g3y,
                       label: block_c8g3y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g3y: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.056064746 UTC

[section ""data" . GHC.IO.Handle.Types.haDevice_closure" {
     GHC.IO.Handle.Types.haDevice_closure:
         const ()_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.057936377 UTC

[section ""data" . GHC.IO.Handle.Types.outputNL_closure" {
     GHC.IO.Handle.Types.outputNL_closure:
         const GHC.IO.Handle.Types.outputNL_info;
 },
 GHC.IO.Handle.Types.outputNL_entry() //  [R2]
         { info_tbl: [(c8g42,
                       label: GHC.IO.Handle.Types.outputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g42: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g43; else goto c8g44;
       c8g43: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.outputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g44: // global
           I64[Sp - 8] = block_c8g3Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g48; else goto c8g40;
       u8g48: // global
           call _c8g3Z(R1) args: 0, res: 0, upd: 0;
       c8g40: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g3Z() //  [R1]
         { info_tbl: [(c8g3Z,
                       label: block_c8g3Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g3Z: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.06336509 UTC

[section ""data" . GHC.IO.Handle.Types.inputNL_closure" {
     GHC.IO.Handle.Types.inputNL_closure:
         const GHC.IO.Handle.Types.inputNL_info;
 },
 GHC.IO.Handle.Types.inputNL_entry() //  [R2]
         { info_tbl: [(c8g4s,
                       label: GHC.IO.Handle.Types.inputNL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g4s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g4t; else goto c8g4u;
       c8g4t: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.inputNL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g4u: // global
           I64[Sp - 8] = block_c8g4p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g4y; else goto c8g4q;
       u8g4y: // global
           call _c8g4p(R1) args: 0, res: 0, upd: 0;
       c8g4q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g4p() //  [R1]
         { info_tbl: [(c8g4p,
                       label: block_c8g4p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g4p: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.068917748 UTC

[section ""data" . GHC.IO.Handle.Types.isReadableHandleType_closure" {
     GHC.IO.Handle.Types.isReadableHandleType_closure:
         const GHC.IO.Handle.Types.isReadableHandleType_info;
 },
 GHC.IO.Handle.Types.isReadableHandleType_entry() //  [R2]
         { info_tbl: [(c8g4X,
                       label: GHC.IO.Handle.Types.isReadableHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g4X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g4Y; else goto c8g4Z;
       c8g4Y: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isReadableHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g4Z: // global
           I64[Sp - 8] = block_c8g4P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g5a; else goto c8g4Q;
       u8g5a: // global
           call _c8g4P(R1) args: 0, res: 0, upd: 0;
       c8g4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g4P() //  [R1]
         { info_tbl: [(c8g4P,
                       label: block_c8g4P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g4P: // global
           _c8g4W::P64 = R1 & 7;
           if (_c8g4W::P64 == 3) goto c8g4V; else goto u8g59;
       u8g59: // global
           if (_c8g4W::P64 == 6) goto c8g4V; else goto c8g4T;
       c8g4V: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8g4T: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.074693208 UTC

[section ""data" . GHC.IO.Handle.Types.isWritableHandleType_closure" {
     GHC.IO.Handle.Types.isWritableHandleType_closure:
         const GHC.IO.Handle.Types.isWritableHandleType_info;
 },
 GHC.IO.Handle.Types.isWritableHandleType_entry() //  [R2]
         { info_tbl: [(c8g5D,
                       label: GHC.IO.Handle.Types.isWritableHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g5D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g5E; else goto c8g5F;
       c8g5E: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isWritableHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g5F: // global
           I64[Sp - 8] = block_c8g5u_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g5T; else goto c8g5v;
       u8g5T: // global
           call _c8g5u(R1) args: 0, res: 0, upd: 0;
       c8g5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g5u() //  [R1]
         { info_tbl: [(c8g5u,
                       label: block_c8g5u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g5u: // global
           _c8g5C::P64 = R1 & 7;
           if (_c8g5C::P64 < 4) goto c8g5y; else goto u8g5S;
       c8g5y: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8g5S: // global
           if (_c8g5C::P64 != 5) goto c8g5B; else goto c8g5B;
       c8g5B: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.080258268 UTC

[section ""data" . GHC.IO.Handle.Types.isReadWriteHandleType_closure" {
     GHC.IO.Handle.Types.isReadWriteHandleType_closure:
         const GHC.IO.Handle.Types.isReadWriteHandleType_info;
 },
 GHC.IO.Handle.Types.isReadWriteHandleType_entry() //  [R2]
         { info_tbl: [(c8g6k,
                       label: GHC.IO.Handle.Types.isReadWriteHandleType_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g6k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g6l; else goto c8g6m;
       c8g6l: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.isReadWriteHandleType_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g6m: // global
           I64[Sp - 8] = block_c8g6d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g6t; else goto c8g6e;
       u8g6t: // global
           call _c8g6d(R1) args: 0, res: 0, upd: 0;
       c8g6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g6d() //  [R1]
         { info_tbl: [(c8g6d,
                       label: block_c8g6d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g6d: // global
           if (R1 & 7 == 6) goto c8g6i; else goto c8g6h;
       c8g6i: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8g6h: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.085457408 UTC

[section ""data" . GHC.IO.Handle.Types.nativeNewline_closure" {
     GHC.IO.Handle.Types.nativeNewline_closure:
         const GHC.IO.Handle.Types.LF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.087022956 UTC

[section ""data" . GHC.IO.Handle.Types.universalNewlineMode_closure" {
     GHC.IO.Handle.Types.universalNewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_con_info;
         const GHC.IO.Handle.Types.CRLF_closure+2;
         const GHC.IO.Handle.Types.LF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.088678771 UTC

[section ""data" . GHC.IO.Handle.Types.nativeNewlineMode_closure" {
     GHC.IO.Handle.Types.nativeNewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_con_info;
         const GHC.IO.Handle.Types.LF_closure+1;
         const GHC.IO.Handle.Types.LF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.090353371 UTC

[section ""data" . GHC.IO.Handle.Types.noNewlineTranslation_closure" {
     GHC.IO.Handle.Types.noNewlineTranslation_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Handle.Types.nativeNewlineMode_closure+1;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.092178168 UTC

[section ""cstring" . GHC.IO.Handle.Types.showHandle1_bytes" {
     GHC.IO.Handle.Types.showHandle1_bytes:
         I8[] [123,104,97,110,100,108,101,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.094266903 UTC

[section ""data" . GHC.IO.Handle.Types.showHandle_closure" {
     GHC.IO.Handle.Types.showHandle_closure:
         const GHC.IO.Handle.Types.showHandle_info;
 },
 sat_s8epM_entry() //  [R1]
         { info_tbl: [(c8g71,
                       label: sat_s8epM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g71: // global
           R3 = P64[R1 + 16];
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8epN_entry() //  [R1]
         { info_tbl: [(c8g74,
                       label: sat_s8epN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g74: // global
           _s8epN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8g75; else goto c8g76;
       c8g76: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8g78; else goto c8g77;
       c8g78: // global
           HpAlloc = 24;
           goto c8g75;
       c8g75: // global
           R1 = _s8epN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8g77: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8epN::P64;
           _s8epK::P64 = P64[_s8epN::P64 + 16];
           _s8epL::P64 = P64[_s8epN::P64 + 24];
           I64[Hp - 16] = sat_s8epM_info;
           P64[Hp] = _s8epL::P64;
           R3 = Hp - 16;
           R2 = _s8epK::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.showHandle_entry() //  [R2, R3]
         { info_tbl: [(c8g79,
                       label: GHC.IO.Handle.Types.showHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g79: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8g7d; else goto c8g7c;
       c8g7d: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.showHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8g7c: // global
           I64[Hp - 24] = sat_s8epN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.101683866 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_info;
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c8g7D,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8g7E; else goto c8g7F;
       c8g7E: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8g7F: // global
           I64[Sp - 16] = block_c8g7w_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8g7M; else goto c8g7x;
       u8g7M: // global
           call _c8g7w(R1) args: 0, res: 0, upd: 0;
       c8g7x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g7w() //  [R1]
         { info_tbl: [(c8g7w,
                       label: block_c8g7w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g7w: // global
           _s8epQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8g7A; else goto c8g7B;
       c8g7A: // global
           R3 = _s8epQ::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c8g7B: // global
           R3 = _s8epQ::P64;
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.107829155 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshow_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshow_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_info;
         const 0;
 },
 sat_s8eq1_entry() //  [R1]
         { info_tbl: [(c8g8c,
                       label: sat_s8eq1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g8c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8g8d; else goto c8g8e;
       c8g8d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8g8e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eq5_entry() //  [R1]
         { info_tbl: [(c8g8l,
                       label: sat_s8eq5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g8l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8g8m; else goto c8g8n;
       c8g8m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8g8n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshow_entry() //  [R2]
         { info_tbl: [(c8g8s,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g8s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8g8t; else goto c8g8u;
       c8g8t: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8g8u: // global
           I64[Sp - 8] = block_c8g83_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8g8B; else goto c8g84;
       u8g8B: // global
           call _c8g83(R1) args: 0, res: 0, upd: 0;
       c8g84: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g83() //  [R1]
         { info_tbl: [(c8g83,
                       label: block_c8g83_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g83: // global
           if (R1 & 7 == 1) goto c8g8p; else goto c8g8q;
       c8g8p: // global
           Hp = Hp + 24;
           _s8epY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8g8A; else goto c8g8w;
       c8g8w: // global
           _s8epZ::P64 = P64[_s8epY::P64 + 7];
           I64[Hp - 16] = sat_s8eq1_info;
           P64[Hp] = _s8epZ::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       c8g8q: // global
           Hp = Hp + 24;
           _s8epY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8g8A; else goto c8g8z;
       c8g8A: // global
           HpAlloc = 24;
           R1 = _s8epY::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8g8z: // global
           _s8eq2::P64 = P64[_s8epY::P64 + 6];
           I64[Hp - 16] = sat_s8eq5_info;
           P64[Hp] = _s8eq2::P64;
           R3 = Hp - 16;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.117594643 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle1_closure" {
     GHC.IO.Handle.Types.$fShowHandle1_closure:
         const GHC.IO.Handle.Types.$fShowHandle1_info;
 },
 GHC.IO.Handle.Types.$fShowHandle1_entry() //  [R2, R3]
         { info_tbl: [(c8g9b,
                       label: GHC.IO.Handle.Types.$fShowHandle1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g9b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8g9c; else goto c8g9d;
       c8g9c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.$fShowHandle1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8g9d: // global
           I64[Sp - 16] = block_c8g94_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8g9k; else goto c8g95;
       u8g9k: // global
           call _c8g94(R1) args: 0, res: 0, upd: 0;
       c8g95: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8g94() //  [R1]
         { info_tbl: [(c8g94,
                       label: block_c8g94_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g94: // global
           _s8eq7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8g98; else goto c8g99;
       c8g98: // global
           R3 = _s8eq7::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c8g99: // global
           R3 = _s8eq7::P64;
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.IO.Handle.Types.showHandle_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.123500738 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure" {
     GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure:
         const GHC.IO.Handle.Types.$fShowHandle_$cshowList_info;
 },
 GHC.IO.Handle.Types.$fShowHandle_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c8g9B,
                       label: GHC.IO.Handle.Types.$fShowHandle_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8g9B: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Types.$fShowHandle1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.126763948 UTC

[section ""data" . GHC.IO.Handle.Types.$fShowHandle_closure" {
     GHC.IO.Handle.Types.$fShowHandle_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Types.$fShowHandle_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_closure+1;
         const GHC.IO.Handle.Types.$fShowHandle_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.12873094 UTC

[section ""cstring" . GHC.IO.Handle.Types.$trModule4_bytes" {
     GHC.IO.Handle.Types.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.13036752 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule3_closure" {
     GHC.IO.Handle.Types.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.132075398 UTC

[section ""cstring" . GHC.IO.Handle.Types.$trModule2_bytes" {
     GHC.IO.Handle.Types.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.133886066 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule1_closure" {
     GHC.IO.Handle.Types.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.135585842 UTC

[section ""data" . GHC.IO.Handle.Types.$trModule_closure" {
     GHC.IO.Handle.Types.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Types.$trModule3_closure+1;
         const GHC.IO.Handle.Types.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.137229244 UTC

[section ""data" . $krep_r8a59_closure" {
     $krep_r8a59_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.138956179 UTC

[section ""data" . $krep1_r8a5a_closure" {
     $krep1_r8a5a_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcTextEncoding_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.140829538 UTC

[section ""data" . $krep2_r8a5b_closure" {
     $krep2_r8a5b_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.142518314 UTC

[section ""data" . $krep3_r8a5c_closure" {
     $krep3_r8a5c_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.144121309 UTC

[section ""data" . $krep4_r8a5d_closure" {
     $krep4_r8a5d_closure:
         const :_con_info;
         const $krep_r8a59_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.145835448 UTC

[section ""data" . $krep5_r8a5e_closure" {
     $krep5_r8a5e_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep4_r8a5d_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.147729974 UTC

[section ""data" . $krep6_r8a5f_closure" {
     $krep6_r8a5f_closure:
         const :_con_info;
         const $krep1_r8a5a_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.149365574 UTC

[section ""data" . $krep7_r8a5g_closure" {
     $krep7_r8a5g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep6_r8a5f_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.151011227 UTC

[section ""data" . $krep8_r8a5h_closure" {
     $krep8_r8a5h_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.152891772 UTC

[section ""data" . $krep9_r8a5i_closure" {
     $krep9_r8a5i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.154519637 UTC

[section ""data" . $krep10_r8a5j_closure" {
     $krep10_r8a5j_closure:
         const :_con_info;
         const $krep9_r8a5i_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.156148878 UTC

[section ""data" . $krep11_r8a5k_closure" {
     $krep11_r8a5k_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep10_r8a5j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.157788188 UTC

[section ""data" . $krep12_r8a5l_closure" {
     $krep12_r8a5l_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.159611433 UTC

[section ""data" . $krep13_r8a5m_closure" {
     $krep13_r8a5m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure;
         const $krep12_r8a5l_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.161220412 UTC

[section ""data" . $krep14_r8a5n_closure" {
     $krep14_r8a5n_closure:
         const :_con_info;
         const $krep13_r8a5m_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.162814577 UTC

[section ""data" . $krep15_r8a5o_closure" {
     $krep15_r8a5o_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep14_r8a5n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.164494423 UTC

[section ""data" . $krep16_r8a5p_closure" {
     $krep16_r8a5p_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.16634031 UTC

[section ""data" . $krep17_r8a5q_closure" {
     $krep17_r8a5q_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.167878313 UTC

[section ""data" . $krep18_r8a5r_closure" {
     $krep18_r8a5r_closure:
         const :_con_info;
         const $krep17_r8a5q_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.169543004 UTC

[section ""data" . $krep19_r8a5s_closure" {
     $krep19_r8a5s_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const $krep18_r8a5r_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.171191663 UTC

[section ""data" . $krep20_r8a5t_closure" {
     $krep20_r8a5t_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const $krep19_r8a5s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.173112627 UTC

[section ""data" . $krep21_r8a5u_closure" {
     $krep21_r8a5u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcBufferCodec_closure;
         const $krep20_r8a5t_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.175334269 UTC

[section ""data" . $krep22_r8a5v_closure" {
     $krep22_r8a5v_closure:
         const :_con_info;
         const $krep21_r8a5u_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.17718923 UTC

[section ""data" . $krep23_r8a5w_closure" {
     $krep23_r8a5w_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep22_r8a5v_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.179413345 UTC

[section ""data" . $krep24_r8a5x_closure" {
     $krep24_r8a5x_closure:
         const :_con_info;
         const $krep17_r8a5q_closure+2;
         const $krep14_r8a5n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.181259892 UTC

[section ""data" . $krep25_r8a5y_closure" {
     $krep25_r8a5y_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep24_r8a5x_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.183073421 UTC

[section ""data" . $krep26_r8a5z_closure" {
     $krep26_r8a5z_closure:
         const :_con_info;
         const $krep25_r8a5y_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.184992992 UTC

[section ""data" . $krep27_r8a5A_closure" {
     $krep27_r8a5A_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep26_r8a5z_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.190238808 UTC

[section ""data" . $krep28_r8a5B_closure" {
     $krep28_r8a5B_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.192049134 UTC

[section ""data" . $krep29_r8a5C_closure" {
     $krep29_r8a5C_closure:
         const :_con_info;
         const $krep28_r8a5B_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.19398444 UTC

[section ""data" . $krep30_r8a5D_closure" {
     $krep30_r8a5D_closure:
         const :_con_info;
         const $krep2_r8a5b_closure+1;
         const $krep29_r8a5C_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.195839426 UTC

[section ""data" . $krep31_r8a5E_closure" {
     $krep31_r8a5E_closure:
         const :_con_info;
         const $krep3_r8a5c_closure+1;
         const $krep30_r8a5D_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.198118556 UTC

[section ""data" . $krep32_r8a5F_closure" {
     $krep32_r8a5F_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Encoding.Types.$tcBufferCodec_closure;
         const $krep31_r8a5E_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.199943249 UTC

[section ""data" . $krep33_r8a5G_closure" {
     $krep33_r8a5G_closure:
         const :_con_info;
         const $krep32_r8a5F_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.20234396 UTC

[section ""data" . $krep34_r8a5H_closure" {
     $krep34_r8a5H_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep33_r8a5G_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.20459347 UTC

[section ""data" . $krep35_r8a5I_closure" {
     $krep35_r8a5I_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.206507887 UTC

[section ""data" . $krep36_r8a5J_closure" {
     $krep36_r8a5J_closure:
         const :_con_info;
         const $krep35_r8a5I_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.208375493 UTC

[section ""data" . $krep37_r8a5K_closure" {
     $krep37_r8a5K_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.210273147 UTC

[section ""data" . $krep38_r8a5L_closure" {
     $krep38_r8a5L_closure:
         const :_con_info;
         const GHC.Types.krep$*_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.212322253 UTC

[section ""data" . $krep39_r8a5M_closure" {
     $krep39_r8a5M_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Typeable.Internal.$tcTypeable_closure;
         const $krep38_r8a5L_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.214070963 UTC

[section ""data" . $krep40_r8a5N_closure" {
     $krep40_r8a5N_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Device.$tcIODevice_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.215742074 UTC

[section ""data" . $krep41_r8a5O_closure" {
     $krep41_r8a5O_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.BufferedIO.$tcBufferedIO_closure;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.217904127 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcBufferList2_bytes" {
     GHC.IO.Handle.Types.$tcBufferList2_bytes:
         I8[] [66,117,102,102,101,114,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.219734405 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferList1_closure" {
     GHC.IO.Handle.Types.$tcBufferList1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcBufferList2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.221294815 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferList_closure" {
     GHC.IO.Handle.Types.$tcBufferList_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcBufferList1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16602278556585116844;
         const 18164509953320487254;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.22308277 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil1_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferList_closure+1;
         const $krep36_r8a5J_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.224962357 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BufferListNil3_bytes" {
     GHC.IO.Handle.Types.$tc'BufferListNil3_bytes:
         I8[] [39,66,117,102,102,101,114,76,105,115,116,78,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.226603059 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil2_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListNil3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.228240856 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListNil_closure" {
     GHC.IO.Handle.Types.$tc'BufferListNil_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil2_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const 1776148480580179033;
         const 13181184993065174936;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.230507258 UTC

[section ""data" . $krep42_r8a5P_closure" {
     $krep42_r8a5P_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListNil1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.232393451 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons1_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep37_r8a5K_closure+1;
         const $krep42_r8a5P_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.234082633 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BufferListCons3_bytes" {
     GHC.IO.Handle.Types.$tc'BufferListCons3_bytes:
         I8[] [39,66,117,102,102,101,114,76,105,115,116,67,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.235627913 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons2_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BufferListCons3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.237322611 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BufferListCons_closure" {
     GHC.IO.Handle.Types.$tc'BufferListCons_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListCons2_closure+1;
         const GHC.IO.Handle.Types.$tc'BufferListCons1_closure+4;
         const 17252346539814354939;
         const 274626690118510806;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.239283924 UTC

[section ""data" . $krep43_r8a5Q_closure" {
     $krep43_r8a5Q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferList_closure+1;
         const $krep8_r8a5h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.240950885 UTC

[section ""data" . $krep44_r8a5R_closure" {
     $krep44_r8a5R_closure:
         const :_con_info;
         const $krep43_r8a5Q_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.242676703 UTC

[section ""data" . $krep45_r8a5S_closure" {
     $krep45_r8a5S_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep44_r8a5R_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.244510277 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandleType2_bytes" {
     GHC.IO.Handle.Types.$tcHandleType2_bytes:
         I8[] [72,97,110,100,108,101,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.24648695 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandleType1_closure" {
     GHC.IO.Handle.Types.$tcHandleType1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandleType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.248074107 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandleType_closure" {
     GHC.IO.Handle.Types.$tcHandleType_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandleType1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12652050740177317592;
         const 15012172050125063359;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.249869147 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle1_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandleType_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.251739548 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes:
         I8[] [39,67,108,111,115,101,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.25338013 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ClosedHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ClosedHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ClosedHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.255055302 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ClosedHandle_closure" {
     GHC.IO.Handle.Types.$tc'ClosedHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ClosedHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 3827246897052092772;
         const 908733983357893198;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.256842489 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes:
         I8[] [39,83,101,109,105,67,108,111,115,101,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.259155001 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'SemiClosedHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.260814957 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'SemiClosedHandle_closure" {
     GHC.IO.Handle.Types.$tc'SemiClosedHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'SemiClosedHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 9212351547956271402;
         const 6570718180183054490;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.262667243 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ReadHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ReadHandle2_bytes:
         I8[] [39,82,101,97,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.264538993 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ReadHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ReadHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.266185579 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadHandle_closure" {
     GHC.IO.Handle.Types.$tc'ReadHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ReadHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 269968663592081974;
         const 17473723309710900549;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.267855138 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'WriteHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'WriteHandle2_bytes:
         I8[] [39,87,114,105,116,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.269910888 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'WriteHandle1_closure" {
     GHC.IO.Handle.Types.$tc'WriteHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'WriteHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.271723282 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'WriteHandle_closure" {
     GHC.IO.Handle.Types.$tc'WriteHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'WriteHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 18024523813608199082;
         const 4783872735135983851;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.273583238 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'AppendHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'AppendHandle3_bytes:
         I8[] [39,65,112,112,101,110,100,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.275277695 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle2_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'AppendHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.27725986 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'AppendHandle_closure" {
     GHC.IO.Handle.Types.$tc'AppendHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 18423480119042393547;
         const 8911069045719960050;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.27917187 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes:
         I8[] [39,82,101,97,100,87,114,105,116,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.280920901 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'ReadWriteHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.282807445 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'ReadWriteHandle_closure" {
     GHC.IO.Handle.Types.$tc'ReadWriteHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'ReadWriteHandle1_closure+1;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const 6962298179673541916;
         const 7858738479804269456;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.284974813 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcBufferMode2_bytes" {
     GHC.IO.Handle.Types.$tcBufferMode2_bytes:
         I8[] [66,117,102,102,101,114,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.287049007 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferMode1_closure" {
     GHC.IO.Handle.Types.$tcBufferMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcBufferMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.288884766 UTC

[section ""data" . GHC.IO.Handle.Types.$tcBufferMode_closure" {
     GHC.IO.Handle.Types.$tcBufferMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcBufferMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2181253694666364469;
         const 18094997560331273583;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.291232956 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcBufferMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.293035217 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'NoBuffering2_bytes" {
     GHC.IO.Handle.Types.$tc'NoBuffering2_bytes:
         I8[] [39,78,111,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.294829338 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NoBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'NoBuffering1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'NoBuffering2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.296673782 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NoBuffering_closure" {
     GHC.IO.Handle.Types.$tc'NoBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'NoBuffering1_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 1829914617507863771;
         const 11519122601481432262;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.298901519 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'LineBuffering3_bytes" {
     GHC.IO.Handle.Types.$tc'LineBuffering3_bytes:
         I8[] [39,76,105,110,101,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.30058763 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering2_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'LineBuffering3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.302860944 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LineBuffering_closure" {
     GHC.IO.Handle.Types.$tc'LineBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering2_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 6417231512954421547;
         const 14761155862500981941;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.304814016 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering1_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r8a5e_closure+1;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.306890462 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes" {
     GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes:
         I8[] [39,66,108,111,99,107,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.308671172 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering2_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'BlockBuffering3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.310541808 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'BlockBuffering_closure" {
     GHC.IO.Handle.Types.$tc'BlockBuffering_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'BlockBuffering2_closure+1;
         const GHC.IO.Handle.Types.$tc'BlockBuffering1_closure+4;
         const 704611490471072872;
         const 15656058643765081689;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.312737839 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcNewline2_bytes" {
     GHC.IO.Handle.Types.$tcNewline2_bytes:
         I8[] [78,101,119,108,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.314506177 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewline1_closure" {
     GHC.IO.Handle.Types.$tcNewline1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcNewline2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.316239202 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewline_closure" {
     GHC.IO.Handle.Types.$tcNewline_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcNewline1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4144517894815066994;
         const 10872055347860317487;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.318136165 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF1_closure" {
     GHC.IO.Handle.Types.$tc'CRLF1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcNewline_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.320178172 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'LF2_bytes" {
     GHC.IO.Handle.Types.$tc'LF2_bytes:
         I8[] [39,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.321855758 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LF1_closure" {
     GHC.IO.Handle.Types.$tc'LF1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'LF2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.323604474 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'LF_closure" {
     GHC.IO.Handle.Types.$tc'LF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'LF1_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const 8352565500432618804;
         const 14951155965269318914;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.325776308 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'CRLF3_bytes" {
     GHC.IO.Handle.Types.$tc'CRLF3_bytes:
         I8[] [39,67,82,76,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.327473672 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF2_closure" {
     GHC.IO.Handle.Types.$tc'CRLF2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.32920118 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'CRLF_closure" {
     GHC.IO.Handle.Types.$tc'CRLF_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF2_closure+1;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const 12041259567283068515;
         const 3210182148185771829;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.331058892 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandle__2_bytes" {
     GHC.IO.Handle.Types.$tcHandle__2_bytes:
         I8[] [72,97,110,100,108,101,95,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.333046168 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle__1_closure" {
     GHC.IO.Handle.Types.$tcHandle__1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandle__2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.334749266 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle___closure" {
     GHC.IO.Handle.Types.$tcHandle___closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandle__1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10675922960094776064;
         const 10563785792974977547;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.33656143 UTC

[section ""data" . $krep46_r8a5T_closure" {
     $krep46_r8a5T_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle___closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.33834046 UTC

[section ""data" . $krep47_r8a5U_closure" {
     $krep47_r8a5U_closure:
         const :_con_info;
         const $krep46_r8a5T_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.340393334 UTC

[section ""data" . $krep48_r8a5V_closure" {
     $krep48_r8a5V_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.MVar.$tcMVar_closure;
         const $krep47_r8a5U_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.342110321 UTC

[section ""data" . $krep49_r8a5W_closure" {
     $krep49_r8a5W_closure:
         const :_con_info;
         const $krep48_r8a5V_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.343855507 UTC

[section ""data" . $krep50_r8a5X_closure" {
     $krep50_r8a5X_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep49_r8a5W_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.345673759 UTC

[section ""data" . $krep51_r8a5Y_closure" {
     $krep51_r8a5Y_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep50_r8a5X_closure+1;
         const $krep46_r8a5T_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.347753633 UTC

[section ""data" . $krep52_r8a5Z_closure" {
     $krep52_r8a5Z_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep51_r8a5Y_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.349527942 UTC

[section ""data" . $krep53_r8a60_closure" {
     $krep53_r8a60_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep52_r8a5Z_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.351386465 UTC

[section ""data" . $krep54_r8a61_closure" {
     $krep54_r8a61_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r8a5g_closure+1;
         const $krep53_r8a60_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.353116001 UTC

[section ""data" . $krep55_r8a62_closure" {
     $krep55_r8a62_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep23_r8a5w_closure+1;
         const $krep54_r8a61_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.355263089 UTC

[section ""data" . $krep56_r8a63_closure" {
     $krep56_r8a63_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep34_r8a5H_closure+1;
         const $krep55_r8a62_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.357074095 UTC

[section ""data" . $krep57_r8a64_closure" {
     $krep57_r8a64_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep45_r8a5S_closure+1;
         const $krep56_r8a63_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.359370615 UTC

[section ""data" . $krep58_r8a65_closure" {
     $krep58_r8a65_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r8a5k_closure+1;
         const $krep57_r8a64_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.36148402 UTC

[section ""data" . $krep59_r8a66_closure" {
     $krep59_r8a66_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep27_r8a5A_closure+1;
         const $krep58_r8a65_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.363220424 UTC

[section ""data" . $krep60_r8a67_closure" {
     $krep60_r8a67_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'LineBuffering1_closure+1;
         const $krep59_r8a66_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.365010548 UTC

[section ""data" . $krep61_r8a68_closure" {
     $krep61_r8a68_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep15_r8a5o_closure+1;
         const $krep60_r8a67_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.366878479 UTC

[section ""data" . $krep62_r8a69_closure" {
     $krep62_r8a69_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'AppendHandle1_closure+1;
         const $krep61_r8a68_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.368981113 UTC

[section ""data" . $krep63_r8a6a_closure" {
     $krep63_r8a6a_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep35_r8a5I_closure+2;
         const $krep62_r8a69_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.372593633 UTC

[section ""data" . $krep64_r8a6b_closure" {
     $krep64_r8a6b_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep39_r8a5M_closure+1;
         const $krep63_r8a6a_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.374549297 UTC

[section ""data" . $krep65_r8a6c_closure" {
     $krep65_r8a6c_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep41_r8a5O_closure+1;
         const $krep64_r8a6b_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.376701509 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle__1_closure" {
     GHC.IO.Handle.Types.$tc'Handle__1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep40_r8a5N_closure+1;
         const $krep65_r8a6c_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.378534172 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'Handle__3_bytes" {
     GHC.IO.Handle.Types.$tc'Handle__3_bytes:
         I8[] [39,72,97,110,100,108,101,95,95]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.380286983 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle__2_closure" {
     GHC.IO.Handle.Types.$tc'Handle__2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'Handle__3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.382165959 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'Handle___closure" {
     GHC.IO.Handle.Types.$tc'Handle___closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'Handle__2_closure+1;
         const GHC.IO.Handle.Types.$tc'Handle__1_closure+4;
         const 15400920814375205416;
         const 14458810719499819570;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.38447964 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tcHandle2_bytes" {
     GHC.IO.Handle.Types.$tcHandle2_bytes:
         I8[] [72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.386540035 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle1_closure" {
     GHC.IO.Handle.Types.$tcHandle1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tcHandle2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.38834942 UTC

[section ""data" . GHC.IO.Handle.Types.$tcHandle_closure" {
     GHC.IO.Handle.Types.$tcHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcHandle1_closure+1;
         const GHC.Types.krep$*_closure;
         const 6808292778723485333;
         const 9239299165073943659;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.390670615 UTC

[section ""data" . $krep66_r8a6d_closure" {
     $krep66_r8a6d_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.392469272 UTC

[section ""data" . $krep67_r8a6e_closure" {
     $krep67_r8a6e_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep48_r8a5V_closure+1;
         const $krep66_r8a6d_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.394270811 UTC

[section ""data" . $krep68_r8a6f_closure" {
     $krep68_r8a6f_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep48_r8a5V_closure+1;
         const $krep67_r8a6e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.396123361 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle1_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r8a5p_closure+1;
         const $krep68_r8a6f_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.398746286 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes:
         I8[] [39,68,117,112,108,101,120,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.400453645 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle2_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'DuplexHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.402219063 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'DuplexHandle_closure" {
     GHC.IO.Handle.Types.$tc'DuplexHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'DuplexHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'DuplexHandle1_closure+4;
         const 477065760828861081;
         const 4557316572761143129;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.404188122 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle1_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r8a5p_closure+1;
         const $krep67_r8a6e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.406327533 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'FileHandle3_bytes" {
     GHC.IO.Handle.Types.$tc'FileHandle3_bytes:
         I8[] [39,70,105,108,101,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.408095086 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle2_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'FileHandle3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.409939343 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'FileHandle_closure" {
     GHC.IO.Handle.Types.$tc'FileHandle_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'FileHandle2_closure+1;
         const GHC.IO.Handle.Types.$tc'FileHandle1_closure+4;
         const 5544613225695748436;
         const 8829945929965735507;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.412162717 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewlineMode1_closure" {
     GHC.IO.Handle.Types.$tcNewlineMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$fReadNewlineMode17_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.414240727 UTC

[section ""data" . GHC.IO.Handle.Types.$tcNewlineMode_closure" {
     GHC.IO.Handle.Types.$tcNewlineMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tcNewlineMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 17953040817059389032;
         const 12498949339099960838;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.416045366 UTC

[section ""data" . $krep69_r8a6g_closure" {
     $krep69_r8a6g_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcNewlineMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.417840181 UTC

[section ""data" . $krep70_r8a6h_closure" {
     $krep70_r8a6h_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep69_r8a6g_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.419877824 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode1_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Handle.Types.$tc'CRLF1_closure+1;
         const $krep70_r8a6h_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.421665173 UTC

[section ""cstring" . GHC.IO.Handle.Types.$tc'NewlineMode3_bytes" {
     GHC.IO.Handle.Types.$tc'NewlineMode3_bytes:
         I8[] [39,78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.423412455 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode2_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Types.$tc'NewlineMode3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.425680559 UTC

[section ""data" . GHC.IO.Handle.Types.$tc'NewlineMode_closure" {
     GHC.IO.Handle.Types.$tc'NewlineMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Types.$trModule_closure+1;
         const GHC.IO.Handle.Types.$tc'NewlineMode2_closure+1;
         const GHC.IO.Handle.Types.$tc'NewlineMode1_closure+4;
         const 4266278501114659446;
         const 17947462423734457010;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.427734055 UTC

[section ""data" . GHC.IO.Handle.Types.checkHandleInvariants1_closure" {
     GHC.IO.Handle.Types.checkHandleInvariants1_closure:
         const GHC.IO.Handle.Types.checkHandleInvariants1_info;
 },
 GHC.IO.Handle.Types.checkHandleInvariants1_entry() //  []
         { info_tbl: [(c8gck,
                       label: GHC.IO.Handle.Types.checkHandleInvariants1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gck: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.431401682 UTC

[section ""data" . GHC.IO.Handle.Types.checkHandleInvariants_closure" {
     GHC.IO.Handle.Types.checkHandleInvariants_closure:
         const GHC.IO.Handle.Types.checkHandleInvariants_info;
 },
 GHC.IO.Handle.Types.checkHandleInvariants_entry() //  [R2]
         { info_tbl: [(c8gcx,
                       label: GHC.IO.Handle.Types.checkHandleInvariants_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gcx: // global
           R2 = R2;
           call GHC.IO.Handle.Types.checkHandleInvariants1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.435225513 UTC

[section ""data" . GHC.IO.Handle.Types.NewlineMode_closure" {
     GHC.IO.Handle.Types.NewlineMode_closure:
         const GHC.IO.Handle.Types.NewlineMode_info;
 },
 GHC.IO.Handle.Types.NewlineMode_entry() //  [R2, R3]
         { info_tbl: [(c8gcJ,
                       label: GHC.IO.Handle.Types.NewlineMode_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gcJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8gcN; else goto c8gcM;
       c8gcN: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.NewlineMode_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8gcM: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.439635138 UTC

[section ""data" . GHC.IO.Handle.Types.LF_closure" {
     GHC.IO.Handle.Types.LF_closure:
         const GHC.IO.Handle.Types.LF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.441671898 UTC

[section ""data" . GHC.IO.Handle.Types.CRLF_closure" {
     GHC.IO.Handle.Types.CRLF_closure:
         const GHC.IO.Handle.Types.CRLF_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.443422709 UTC

[section ""data" . GHC.IO.Handle.Types.NoBuffering_closure" {
     GHC.IO.Handle.Types.NoBuffering_closure:
         const GHC.IO.Handle.Types.NoBuffering_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.44511646 UTC

[section ""data" . GHC.IO.Handle.Types.LineBuffering_closure" {
     GHC.IO.Handle.Types.LineBuffering_closure:
         const GHC.IO.Handle.Types.LineBuffering_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.447062012 UTC

[section ""data" . GHC.IO.Handle.Types.BlockBuffering_closure" {
     GHC.IO.Handle.Types.BlockBuffering_closure:
         const GHC.IO.Handle.Types.BlockBuffering_info;
 },
 GHC.IO.Handle.Types.BlockBuffering_entry() //  [R2]
         { info_tbl: [(c8gd3,
                       label: GHC.IO.Handle.Types.BlockBuffering_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gd3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8gd7; else goto c8gd6;
       c8gd7: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.BlockBuffering_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8gd6: // global
           I64[Hp - 8] = GHC.IO.Handle.Types.BlockBuffering_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.450918478 UTC

[section ""data" . GHC.IO.Handle.Types.ClosedHandle_closure" {
     GHC.IO.Handle.Types.ClosedHandle_closure:
         const GHC.IO.Handle.Types.ClosedHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.45264738 UTC

[section ""data" . GHC.IO.Handle.Types.SemiClosedHandle_closure" {
     GHC.IO.Handle.Types.SemiClosedHandle_closure:
         const GHC.IO.Handle.Types.SemiClosedHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.454715814 UTC

[section ""data" . GHC.IO.Handle.Types.ReadHandle_closure" {
     GHC.IO.Handle.Types.ReadHandle_closure:
         const GHC.IO.Handle.Types.ReadHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.456599108 UTC

[section ""data" . GHC.IO.Handle.Types.WriteHandle_closure" {
     GHC.IO.Handle.Types.WriteHandle_closure:
         const GHC.IO.Handle.Types.WriteHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.458341789 UTC

[section ""data" . GHC.IO.Handle.Types.AppendHandle_closure" {
     GHC.IO.Handle.Types.AppendHandle_closure:
         const GHC.IO.Handle.Types.AppendHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.459972565 UTC

[section ""data" . GHC.IO.Handle.Types.ReadWriteHandle_closure" {
     GHC.IO.Handle.Types.ReadWriteHandle_closure:
         const GHC.IO.Handle.Types.ReadWriteHandle_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.461902589 UTC

[section ""data" . GHC.IO.Handle.Types.BufferListNil_closure" {
     GHC.IO.Handle.Types.BufferListNil_closure:
         const GHC.IO.Handle.Types.BufferListNil_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.46389796 UTC

[section ""data" . GHC.IO.Handle.Types.BufferListCons_closure" {
     GHC.IO.Handle.Types.BufferListCons_closure:
         const GHC.IO.Handle.Types.BufferListCons_info;
 },
 GHC.IO.Handle.Types.BufferListCons_entry() //  [R2, R3]
         { info_tbl: [(c8gdq,
                       label: GHC.IO.Handle.Types.BufferListCons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gdq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8gdu; else goto c8gdt;
       c8gdu: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.BufferListCons_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8gdt: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.468780613 UTC

[section ""data" . GHC.IO.Handle.Types.Handle___closure" {
     GHC.IO.Handle.Types.Handle___closure:
         const GHC.IO.Handle.Types.Handle___info;
 },
 GHC.IO.Handle.Types.Handle___slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gdC: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Types.Handle___entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 96, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Types.Handle___entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8gdH,
                       label: GHC.IO.Handle.Types.Handle___info
                       rep:HeapRep static {
                             Fun {arity: 16
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gdH: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c8gdL; else goto c8gdK;
       c8gdL: // global
           HpAlloc = 136;
           R1 = GHC.IO.Handle.Types.Handle___closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 136, res: 0, upd: 8;
       c8gdK: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = R2;
           P64[Hp - 112] = R3;
           P64[Hp - 104] = R4;
           P64[Hp - 96] = R5;
           P64[Hp - 88] = R6;
           P64[Hp - 80] = P64[Sp];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 56];
           P64[Hp - 16] = P64[Sp + 64];
           P64[Hp - 8] = P64[Sp + 72];
           P64[Hp] = P64[Sp + 80];
           R1 = Hp - 127;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.474851433 UTC

[section ""data" . GHC.IO.Handle.Types.FileHandle_closure" {
     GHC.IO.Handle.Types.FileHandle_closure:
         const GHC.IO.Handle.Types.FileHandle_info;
 },
 GHC.IO.Handle.Types.FileHandle_entry() //  [R2, R3]
         { info_tbl: [(c8gea,
                       label: GHC.IO.Handle.Types.FileHandle_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gea: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8gee; else goto c8ged;
       c8gee: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.FileHandle_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ged: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.FileHandle_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.478919211 UTC

[section ""data" . GHC.IO.Handle.Types.DuplexHandle_closure" {
     GHC.IO.Handle.Types.DuplexHandle_closure:
         const GHC.IO.Handle.Types.DuplexHandle_info;
 },
 GHC.IO.Handle.Types.DuplexHandle_entry() //  [R2, R3, R4]
         { info_tbl: [(c8geq,
                       label: GHC.IO.Handle.Types.DuplexHandle_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8geq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8geu; else goto c8get;
       c8geu: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Types.DuplexHandle_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8get: // global
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 22;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.482612477 UTC

[GHC.IO.Handle.Types.NewlineMode_con_entry() //  [R1]
         { info_tbl: [(c8geB,
                       label: GHC.IO.Handle.Types.NewlineMode_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,78,101,119,108,105,110,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8geB: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.486092399 UTC

[section ""relreadonly" . GHC.IO.Handle.Types.Newline_closure_tbl" {
     GHC.IO.Handle.Types.Newline_closure_tbl:
         const GHC.IO.Handle.Types.LF_closure+1;
         const GHC.IO.Handle.Types.CRLF_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.487804222 UTC

[GHC.IO.Handle.Types.LF_con_entry() //  [R1]
         { info_tbl: [(c8geJ,
                       label: GHC.IO.Handle.Types.LF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,76,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8geJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.491627104 UTC

[GHC.IO.Handle.Types.CRLF_con_entry() //  [R1]
         { info_tbl: [(c8geQ,
                       label: GHC.IO.Handle.Types.CRLF_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,67,82,76,70]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8geQ: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.494695718 UTC

[GHC.IO.Handle.Types.NoBuffering_con_entry() //  [R1]
         { info_tbl: [(c8geX,
                       label: GHC.IO.Handle.Types.NoBuffering_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,78,111,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8geX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.498694631 UTC

[GHC.IO.Handle.Types.LineBuffering_con_entry() //  [R1]
         { info_tbl: [(c8gf4,
                       label: GHC.IO.Handle.Types.LineBuffering_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,76,105,110,101,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gf4: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.502178766 UTC

[GHC.IO.Handle.Types.BlockBuffering_con_entry() //  [R1]
         { info_tbl: [(c8gfb,
                       label: GHC.IO.Handle.Types.BlockBuffering_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,108,111,99,107,66,117,102,102,101,114,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gfb: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.505407592 UTC

[section ""relreadonly" . GHC.IO.Handle.Types.HandleType_closure_tbl" {
     GHC.IO.Handle.Types.HandleType_closure_tbl:
         const GHC.IO.Handle.Types.ClosedHandle_closure+1;
         const GHC.IO.Handle.Types.SemiClosedHandle_closure+2;
         const GHC.IO.Handle.Types.ReadHandle_closure+3;
         const GHC.IO.Handle.Types.WriteHandle_closure+4;
         const GHC.IO.Handle.Types.AppendHandle_closure+5;
         const GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.50759697 UTC

[GHC.IO.Handle.Types.ClosedHandle_con_entry() //  [R1]
         { info_tbl: [(c8gfj,
                       label: GHC.IO.Handle.Types.ClosedHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,67,108,111,115,101,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gfj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.511481083 UTC

[GHC.IO.Handle.Types.SemiClosedHandle_con_entry() //  [R1]
         { info_tbl: [(c8gfq,
                       label: GHC.IO.Handle.Types.SemiClosedHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,83,101,109,105,67,108,111,115,101,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gfq: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.515050297 UTC

[GHC.IO.Handle.Types.ReadHandle_con_entry() //  [R1]
         { info_tbl: [(c8gfx,
                       label: GHC.IO.Handle.Types.ReadHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,82,101,97,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gfx: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.51837901 UTC

[GHC.IO.Handle.Types.WriteHandle_con_entry() //  [R1]
         { info_tbl: [(c8gfE,
                       label: GHC.IO.Handle.Types.WriteHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,87,114,105,116,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gfE: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.522548926 UTC

[GHC.IO.Handle.Types.AppendHandle_con_entry() //  [R1]
         { info_tbl: [(c8gfL,
                       label: GHC.IO.Handle.Types.AppendHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,65,112,112,101,110,100,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gfL: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.525863041 UTC

[GHC.IO.Handle.Types.ReadWriteHandle_con_entry() //  [R1]
         { info_tbl: [(c8gfS,
                       label: GHC.IO.Handle.Types.ReadWriteHandle_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,82,101,97,100,87,114,105,116,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gfS: // global
           R1 = R1 + 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.529520879 UTC

[GHC.IO.Handle.Types.BufferListNil_con_entry() //  [R1]
         { info_tbl: [(c8gfZ,
                       label: GHC.IO.Handle.Types.BufferListNil_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,117,102,102,101,114,76,105,115,116,78,105,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gfZ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.532884934 UTC

[GHC.IO.Handle.Types.BufferListCons_con_entry() //  [R1]
         { info_tbl: [(c8gg6,
                       label: GHC.IO.Handle.Types.BufferListCons_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,66,117,102,102,101,114,76,105,115,116,67,111,110,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8gg6: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.537118327 UTC

[GHC.IO.Handle.Types.Handle___con_entry() //  [R1]
         { info_tbl: [(c8ggd,
                       label: GHC.IO.Handle.Types.Handle___con_info
                       rep:HeapRep 16 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,72,97,110,100,108,101,95,95]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ggd: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.54062721 UTC

[GHC.IO.Handle.Types.FileHandle_con_entry() //  [R1]
         { info_tbl: [(c8ggk,
                       label: GHC.IO.Handle.Types.FileHandle_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,70,105,108,101,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ggk: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.544572496 UTC

[GHC.IO.Handle.Types.DuplexHandle_con_entry() //  [R1]
         { info_tbl: [(c8ggr,
                       label: GHC.IO.Handle.Types.DuplexHandle_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,121,112,101,115,46,68,117,112,108,101,120,72,97,110,100,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ggr: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:23.548318121 UTC

[section ""relreadonly" . S8evg_srt" {
     S8evg_srt:
         const GHC.IO.Handle.Types.$w$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowHandleType1_closure;
         const GHC.IO.Handle.Types.$fShowHandleType3_closure;
         const GHC.IO.Handle.Types.$fShowHandleType5_closure;
         const GHC.IO.Handle.Types.$fShowHandleType7_closure;
         const GHC.IO.Handle.Types.$fShowHandleType9_closure;
         const GHC.IO.Handle.Types.$fShowHandleType11_closure;
         const GHC.IO.Handle.Types.$fShowHandleType_$cshow_closure;
         const GHC.IO.Handle.Types.$fReadNewline6_closure;
         const GHC.IO.Handle.Types.$fReadNewline10_closure;
         const GHC.IO.Handle.Types.$fShowNewline_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowNewline_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowNewline1_closure;
         const GHC.Show.showCommaSpace1_closure;
         const GHC.IO.Handle.Types.$w$cshowsPrec1_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowNewlineMode1_closure;
         const GHC.Read.choose2_closure;
         const GHC.IO.Handle.Types.$fReadNewline_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.Handle.Types.$fReadNewline2_closure;
         const GHC.IO.Handle.Types.$fReadNewline_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Handle.Types.$fReadNewline1_closure;
         const GHC.IO.Handle.Types.$fReadNewline_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewline12_closure;
         const Text.Read.Lex.$wexpect_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode3_closure;
         const GHC.Read.readField_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode6_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode11_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode8_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode12_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_lexeme_closure;
         const GHC.IO.Handle.Types.$w$creadPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_lexeme1_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode2_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadsPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode1_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode18_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode12_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode8_closure;
         const GHC.Show.$fShowMaybe_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode3_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshowsPrec_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode5_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode6_closure;
         const GHC.Show.$fShowMaybe1_closure;
         const GHC.Show.$fShowMaybe4_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode_$cshow_closure;
         const GHC.IO.Handle.Types.$fShowBufferMode1_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_sps_closure;
         const GHC.Read.choose2_closure;
         const GHC.Read.$fReadInt_closure;
         const GHC.Read.$fReadMaybe1_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_lexeme_closure;
         const Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode2_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadsPrec_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode1_closure;
         const GHC.Read.list_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode_$creadListPrec_closure;
         const GHC.IO.Handle.Types.$fReadBufferMode14_closure;
         const GHC.IO.Handle.Types.$fReadNewlineMode4_closure;
         const GHC.IO.Handle.Types.$fShowHandle_$cshow_closure;
 }]

