
==================== Raw Cmm ====================
2018-03-16 16:06:14.213152047 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:06:14.214381338 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes:
         I8[] [70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.218319015 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_entry() //  [R1]
         { []
         }
     {offset
       cbiG9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiGa; else goto cbiGb;
       cbiGa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiGb: // global
           (_cbiG6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiG6::I64 == 0) goto cbiG8; else goto cbiG7;
       cbiG8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiG7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiG6::I64;
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.222716082 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { []
         }
     {offset
       cbiGq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiGr; else goto cbiGs;
       cbiGr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiGs: // global
           I64[Sp - 16] = block_cbiGn_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubiGw; else goto cbiGo;
       ubiGw: // global
           call _cbiGn() args: 0, res: 0, upd: 0;
       cbiGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const Sbipx_srt;
 },
 _cbiGn() //  []
         { []
         }
     {offset
       cbiGn: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiGn_info" {
     block_cbiGn_info:
         const _cbiGn;
         const 1;
         const 4294967326;
         const Sbipx_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.22818567 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_entry() //  [R2]
         { []
         }
     {offset
       cbiGN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbiGO; else goto cbiGP;
       cbiGO: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiGP: // global
           I64[Sp - 8] = block_cbiGK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiGT; else goto cbiGL;
       ubiGT: // global
           call _cbiGK() args: 0, res: 0, upd: 0;
       cbiGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const Sbipx_srt;
 },
 _cbiGK() //  []
         { []
         }
     {offset
       cbiGK: // global
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiGK_info" {
     block_cbiGK_info:
         const _cbiGK;
         const 0;
         const 4294967326;
         const Sbipx_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.234137735 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_entry() //  [R2,
                                                                R3]
         { []
         }
     {offset
       cbiHb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiHc; else goto cbiHd;
       cbiHc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiHd: // global
           I64[Sp - 16] = block_cbiH8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubiHh; else goto cbiH9;
       ubiHh: // global
           call _cbiH8() args: 0, res: 0, upd: 0;
       cbiH9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const Sbipx_srt;
 },
 _cbiH8() //  []
         { []
         }
     {offset
       cbiH8: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiH8_info" {
     block_cbiH8_info:
         const _cbiH8;
         const 1;
         const 4294967326;
         const Sbipx_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.239259979 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_entry() //  [R2,
                                                                          R3]
         { []
         }
     {offset
       cbiHv: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const Sbipx_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.242867925 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.244620808 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule4_bytes" {
     GHC.IO.Handle.Lock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.246334174 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule3_closure" {
     GHC.IO.Handle.Lock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.248003591 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule2_bytes" {
     GHC.IO.Handle.Lock.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.250434132 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule1_closure" {
     GHC.IO.Handle.Lock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.252092682 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule_closure" {
     GHC.IO.Handle.Lock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Lock.$trModule3_closure+1;
         const GHC.IO.Handle.Lock.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.254182622 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.255943278 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
         const GHC.Types.krep$*_closure;
         const 2716065848555532007;
         const 12251424812302631774;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.257843996 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.259543111 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes:
         I8[] [39,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.261228361 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.263052923 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure+1;
         const 13975601321420314475;
         const 8398323512000399582;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.266919063 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_entry() //  [R1]
         { []
         }
     {offset
       cbiHZ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbiI0; else goto cbiI1;
       cbiI0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiI1: // global
           (_cbiHR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiHR::I64 == 0) goto cbiHT; else goto cbiHS;
       cbiHT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiHS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiHR::I64;
           I64[Sp - 24] = block_cbiHU_info;
           R6 = 0;
           R5 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
           R4 = GHC.IO.Handle.Lock.$trModule_closure+1;
           R3 = 12251424812302631774;
           R2 = 2716065848555532007;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_entry;
         const 0;
         const 4294967317;
         const Sbipx_srt+32;
 },
 _cbiHU() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       cbiHU: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbiHV() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cbiHU_info" {
     block_cbiHU_info:
         const _cbiHU;
         const 0;
         const 30;
 },
 _cbiHV() //  []
         { []
         }
     {offset
       cbiHV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbiI4; else goto cbiI3;
       cbiI4: // global
           HpAlloc = 48;
           I64[Sp] = block_cbiHV_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbiI3: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cbiHV_info" {
     block_cbiHV_info:
         const _cbiHV;
         const 1093;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.275340209 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_entry() //  [R2]
         { []
         }
     {offset
       cbiIx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiIB; else goto cbiIC;
       cbiIB: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiIC: // global
           I64[Sp - 8] = block_cbiIu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiIX; else goto cbiIv;
       ubiIX: // global
           call _cbiIu(R1) args: 0, res: 0, upd: 0;
       cbiIv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const Sbipx_srt+40;
 },
 _cbiIu() //  [R1]
         { []
         }
     {offset
       cbiIu: // global
           I64[Sp - 8] = block_cbiIA_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiIu_info" {
     block_cbiIu_info:
         const _cbiIu;
         const 0;
         const 21474836510;
         const Sbipx_srt+40;
 },
 _cbiIA() //  [R1]
         { []
         }
     {offset
       cbiIA: // global
           I64[Sp] = block_cbiIH_info;
           R3 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiIA_info" {
     block_cbiIA_info:
         const _cbiIA;
         const 1;
         const 21474836510;
         const Sbipx_srt+40;
 },
 _cbiIH() //  [R1]
         { []
         }
     {offset
       cbiIH: // global
           if (R1 & 7 == 1) goto cbiIO; else goto cbiIS;
       cbiIO: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiIS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbiIV; else goto cbiIU;
       cbiIV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbiIU: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiIH_info" {
     block_cbiIH_info:
         const _cbiIH;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.284986537 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_entry() //  [R2]
         { []
         }
     {offset
       cbiJo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbiJs; else goto cbiJr;
       cbiJs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiJr: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Sbipx_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.288843586 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tcLockMode2_bytes" {
     GHC.IO.Handle.Lock.$tcLockMode2_bytes:
         I8[] [76,111,99,107,77,111,100,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.290757246 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode1_closure" {
     GHC.IO.Handle.Lock.$tcLockMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.29256726 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode_closure" {
     GHC.IO.Handle.Lock.$tcLockMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tcLockMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18068849831825836849;
         const 1974453150269185476;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.294302491 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.29604991 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'SharedLock2_bytes" {
     GHC.IO.Handle.Lock.$tc'SharedLock2_bytes:
         I8[] [39,83,104,97,114,101,100,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.297670364 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock1_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'SharedLock2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.299447987 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'SharedLock1_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 9660990538910196995;
         const 16983901031857135990;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.301165739 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes:
         I8[] [39,69,120,99,108,117,115,105,118,101,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.303236539 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.305007589 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 8544818512469904331;
         const 16785548070058023905;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.306832021 UTC

[section ""cstring" . lvl_rbimF_bytes" {
     lvl_rbimF_bytes:
         I8[] [102,108,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.309740176 UTC

[section ""data" . lvl1_rbimG_closure" {
     lvl1_rbimG_closure:
         const lvl1_rbimG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbimG_entry() //  [R1]
         { []
         }
     {offset
       cbiJQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiJR; else goto cbiJS;
       cbiJR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiJS: // global
           (_cbiJN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiJN::I64 == 0) goto cbiJP; else goto cbiJO;
       cbiJP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiJO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiJN::I64;
           R2 = lvl_rbimF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_rbimG_info" {
     lvl1_rbimG_info:
         const lvl1_rbimG_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.314120631 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock2_closure" {
     GHC.IO.Handle.Lock.hUnlock2_closure:
         const GHC.IO.Handle.Lock.hUnlock2_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock2_entry() //  [R2]
         { []
         }
     {offset
       cbiK6: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_rbimG_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hUnlock2_info" {
     GHC.IO.Handle.Lock.hUnlock2_info:
         const GHC.IO.Handle.Lock.hUnlock2_entry;
         const 0;
         const 12884901902;
         const 8589934596;
         const Sbipx_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.319822499 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock1_closure" {
     GHC.IO.Handle.Lock.hUnlock1_closure:
         const GHC.IO.Handle.Lock.hUnlock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock1_entry() //  [R2]
         { []
         }
     {offset
       cbiKo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbiKp; else goto cbiKq;
       cbiKp: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hUnlock1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiKq: // global
           I64[Sp - 8] = block_cbiKh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiLt; else goto cbiKi;
       ubiLt: // global
           call _cbiKh(R1) args: 0, res: 0, upd: 0;
       cbiKi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hUnlock1_info" {
     GHC.IO.Handle.Lock.hUnlock1_info:
         const GHC.IO.Handle.Lock.hUnlock1_entry;
         const 0;
         const 17046725197838;
         const 8589934597;
         const Sbipx_srt+40;
 },
 _cbiKh() //  [R1]
         { []
         }
     {offset
       cbiKh: // global
           if (R1 & 7 == 1) goto cbiKl; else goto cbiKm;
       cbiKl: // global
           I64[Sp - 8] = block_cbiKt_info;
           _sbina::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbina::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbiKm: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiKh_info" {
     block_cbiKh_info:
         const _cbiKh;
         const 0;
         const 12648678686750;
         const Sbipx_srt+40;
 },
 _cbiKt() //  [R1]
         { []
         }
     {offset
       cbiKt: // global
           I64[Sp] = block_cbiKv_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubiLu; else goto cbiKw;
       ubiLu: // global
           call _cbiKv(R1) args: 0, res: 0, upd: 0;
       cbiKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiKt_info" {
     block_cbiKt_info:
         const _cbiKt;
         const 1;
         const 11549167058974;
         const Sbipx_srt+40;
 },
 _cbiKv() //  [R1]
         { []
         }
     {offset
       cbiKv: // global
           I64[Sp - 8] = block_cbiKA_info;
           _sbinj::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbinj::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiKv_info" {
     block_cbiKv_info:
         const _cbiKv;
         const 1;
         const 11549167058974;
         const Sbipx_srt+40;
 },
 _cbiKA() //  [R1]
         { []
         }
     {offset
       cbiKA: // global
           I64[Sp] = block_cbiKH_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiKA_info" {
     block_cbiKA_info:
         const _cbiKA;
         const 2;
         const 11549167058974;
         const Sbipx_srt+40;
 },
 _cbiKH() //  [R1]
         { []
         }
     {offset
       cbiKH: // global
           if (R1 & 7 == 1) goto cbiKO; else goto cbiKS;
       cbiKO: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbiKS: // global
           I64[Sp + 16] = block_cbiKW_info;
           _cbiKU::I64 = I64[Sp + 8];
           Sp = Sp + 16;
           _ubiLl::P64 = CurrentTSO;
           I64[I64[_ubiLl::P64 + 24] + 16] = Sp;
           _ubiLm::I64 = CurrentNursery;
           P64[_ubiLm::I64 + 8] = Hp + 8;
           I64[_ubiLl::P64 + 104] = I64[_ubiLl::P64 + 104] - ((Hp + 8) - I64[_ubiLm::I64]);
           (_ubiLj::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbinF::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_cbiKU::I64, 8);
           (_ubiLk::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubiLj::I64);
           BaseReg = _ubiLk::I64;
           _ubiLn::P64 = CurrentTSO;
           _ubiLo::P64 = I64[_ubiLn::P64 + 24];
           Sp = I64[_ubiLo::P64 + 16];
           SpLim = _ubiLo::P64 + 192;
           HpAlloc = 0;
           _ubiLp::I64 = CurrentNursery;
           _ubiLq::I64 = I64[_ubiLp::I64 + 8];
           Hp = _ubiLq::I64 - 8;
           _ubiLr::I64 = I64[_ubiLp::I64];
           HpLim = _ubiLr::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubiLp::I64 + 48]) << 12) - 1);
           I64[_ubiLn::P64 + 104] = I64[_ubiLn::P64 + 104] + (_ubiLq::I64 - _ubiLr::I64);
           R1 = _sbinF::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiKH_info" {
     block_cbiKH_info:
         const _cbiKH;
         const 66;
         const 21474836510;
         const Sbipx_srt+112;
 },
 _cbiKW() //  [R1]
         { []
         }
     {offset
       cbiKW: // global
           if (%MO_SS_Conv_W64_W32(R1) == (-1) :: W32) goto cbiLa; else goto cbiL4;
       cbiLa: // global
           (_sbinK::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sbinK::I64;
           Sp = Sp + 8;
           call GHC.IO.Handle.Lock.hUnlock2_entry(R2) args: 8, res: 0, upd: 8;
       cbiL4: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiKW_info" {
     block_cbiKW_info:
         const _cbiKW;
         const 0;
         const 4294967326;
         const Sbipx_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.33370076 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock_closure" {
     GHC.IO.Handle.Lock.hUnlock_closure:
         const GHC.IO.Handle.Lock.hUnlock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock_entry() //  [R2]
         { []
         }
     {offset
       cbiMj: // global
           R2 = R2;
           call GHC.IO.Handle.Lock.hUnlock1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hUnlock_info" {
     GHC.IO.Handle.Lock.hUnlock_info:
         const GHC.IO.Handle.Lock.hUnlock_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const Sbipx_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.3384321 UTC

[section ""data" . GHC.IO.Handle.Lock.$wlvl_closure" {
     GHC.IO.Handle.Lock.$wlvl_closure:
         const GHC.IO.Handle.Lock.$wlvl_info;
         const 0;
 },
 sat_sbinV_entry() //  [R1]
         { []
         }
     {offset
       cbiMD: // global
           _sbinV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbiME; else goto cbiMF;
       cbiMF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbiMH; else goto cbiMG;
       cbiMH: // global
           HpAlloc = 16;
           goto cbiME;
       cbiME: // global
           R1 = _sbinV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiMG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbinV::P64;
           _sbinR::P64 = P64[_sbinV::P64 + 16];
           _sbinS::P64 = P64[_sbinV::P64 + 24];
           _sbinQ::I64 = I64[_sbinV::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbinS::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sbinQ::I64;
           R2 = _sbinR::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sbinV_info" {
     sat_sbinV_info:
         const sat_sbinV_entry;
         const 4294967298;
         const 4294967311;
         const Sbipx_srt+136;
 },
 sat_sbinW_entry() //  [R1]
         { []
         }
     {offset
       cbiMI: // global
           _sbinW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbiMJ; else goto cbiMK;
       cbiMK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbiMM; else goto cbiML;
       cbiMM: // global
           HpAlloc = 40;
           goto cbiMJ;
       cbiMJ: // global
           R1 = _sbinW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiML: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbinW::P64;
           _sbinR::P64 = P64[_sbinW::P64 + 16];
           _sbinS::P64 = P64[_sbinW::P64 + 24];
           _sbinQ::I64 = I64[_sbinW::P64 + 32];
           I64[Hp - 32] = sat_sbinV_info;
           P64[Hp - 16] = _sbinR::P64;
           P64[Hp - 8] = _sbinS::P64;
           I64[Hp] = _sbinQ::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sbinW_info" {
     sat_sbinW_info:
         const sat_sbinW_entry;
         const 4294967298;
         const 12884901903;
         const Sbipx_srt+136;
 },
 GHC.IO.Handle.Lock.$wlvl_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cbiMN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbiMR; else goto cbiMQ;
       cbiMR: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiMQ: // global
           I64[Hp - 32] = sat_sbinW_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$wlvl_info" {
     GHC.IO.Handle.Lock.$wlvl_info:
         const GHC.IO.Handle.Lock.$wlvl_entry;
         const 0;
         const 30064771086;
         const 17179869203;
         const Sbipx_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.351129631 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock4_closure" {
     GHC.IO.Handle.Lock.hLock4_closure:
         const GHC.IO.Handle.Lock.hLock4_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock4_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cbiNf: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbiNg; else goto cbiNh;
       cbiNg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiNh: // global
           I64[Sp - 32] = block_cbiN8_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubiQp; else goto cbiN9;
       ubiQp: // global
           call _cbiN8(R1) args: 0, res: 0, upd: 0;
       cbiN9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hLock4_info" {
     GHC.IO.Handle.Lock.hLock4_info:
         const GHC.IO.Handle.Lock.hLock4_entry;
         const 0;
         const 214958818197518;
         const 21474836504;
         const Sbipx_srt+40;
 },
 _cbiN8() //  [R1]
         { []
         }
     {offset
       cbiN8: // global
           if (R1 & 7 == 1) goto cbiNc; else goto cbiNd;
       cbiNc: // global
           I64[Sp - 8] = block_cbiNk_info;
           _sbio2::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbio2::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbiNd: // global
           R2 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiN8_info" {
     block_cbiN8_info:
         const _cbiN8;
         const 3;
         const 74221329842206;
         const Sbipx_srt+40;
 },
 _cbiNk() //  [R1]
         { []
         }
     {offset
       cbiNk: // global
           I64[Sp] = block_cbiNm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubiQq; else goto cbiNn;
       ubiQq: // global
           call _cbiNm(R1) args: 0, res: 0, upd: 0;
       cbiNn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiNk_info" {
     block_cbiNk_info:
         const _cbiNk;
         const 4;
         const 73121818214430;
         const Sbipx_srt+40;
 },
 _cbiNm() //  [R1]
         { []
         }
     {offset
       cbiNm: // global
           I64[Sp - 8] = block_cbiNr_info;
           _sbiob::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbiob::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiNm_info" {
     block_cbiNm_info:
         const _cbiNm;
         const 4;
         const 73121818214430;
         const Sbipx_srt+40;
 },
 _cbiNr() //  [R1]
         { []
         }
     {offset
       cbiNr: // global
           I64[Sp] = block_cbiNy_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiNr_info" {
     block_cbiNr_info:
         const _cbiNr;
         const 5;
         const 73121818214430;
         const Sbipx_srt+40;
 },
 _cbiNy() //  [R1]
         { []
         }
     {offset
       cbiNy: // global
           if (R1 & 7 == 1) goto cbiNF; else goto ubiQc;
       cbiNF: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       ubiQc: // global
           Sp = Sp + 8;
           call _cbiNY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cbiNy_info" {
     block_cbiNy_info:
         const _cbiNy;
         const 69;
         const 141733920798;
         const Sbipx_srt+112;
 },
 _cbiNY() //  []
         { []
         }
     {offset
       cbiNY: // global
           I64[Sp - 8] = block_cbiO2_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiQs; else goto cbiPQ;
       ubiQs: // global
           call _cbiO2(R1) args: 0, res: 0, upd: 0;
       cbiPQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiO2() //  [R1]
         { []
         }
     {offset
       cbiO2: // global
           _sbio0::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbiPW; else goto cbiQ0;
       cbiPW: // global
           _sbioD::I64 = 1;
           goto sbioC;
       cbiQ0: // global
           _sbioD::I64 = 2;
           goto sbioC;
       sbioC: // global
           I64[Sp - 8] = block_cbiO9_info;
           R1 = _sbio0::P64;
           I64[Sp] = _sbioD::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiQt; else goto cbiPF;
       ubiQt: // global
           call _cbiO9(R1) args: 0, res: 0, upd: 0;
       cbiPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiO2_info" {
     block_cbiO2_info:
         const _cbiO2;
         const 69;
         const 4294967326;
         const Sbipx_srt+152;
 },
 _cbiO9() //  [R1]
         { []
         }
     {offset
       cbiO9: // global
           _sbioq::I64 = I64[Sp + 16];
           _sbioD::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbiPL; else goto cbiPP;
       cbiPL: // global
           _sbioF::I64 = 4;
           goto sbioE;
       cbiPP: // global
           _sbioF::I64 = 0;
           goto sbioE;
       sbioE: // global
           I64[Sp + 8] = block_cbiOu_info;
           Sp = Sp + 8;
           _ubiQh::P64 = CurrentTSO;
           I64[I64[_ubiQh::P64 + 24] + 16] = Sp;
           _ubiQi::I64 = CurrentNursery;
           P64[_ubiQi::I64 + 8] = Hp + 8;
           I64[_ubiQh::P64 + 104] = I64[_ubiQh::P64 + 104] - ((Hp + 8) - I64[_ubiQi::I64]);
           (_ubiQf::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbioN::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_sbioq::I64, _sbioD::I64 | _sbioF::I64);
           (_ubiQg::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubiQf::I64);
           BaseReg = _ubiQg::I64;
           _ubiQj::P64 = CurrentTSO;
           _ubiQk::P64 = I64[_ubiQj::P64 + 24];
           Sp = I64[_ubiQk::P64 + 16];
           SpLim = _ubiQk::P64 + 192;
           HpAlloc = 0;
           _ubiQl::I64 = CurrentNursery;
           _ubiQm::I64 = I64[_ubiQl::I64 + 8];
           Hp = _ubiQm::I64 - 8;
           _ubiQn::I64 = I64[_ubiQl::I64];
           HpLim = _ubiQn::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubiQl::I64 + 48]) << 12) - 1);
           I64[_ubiQj::P64 + 104] = I64[_ubiQj::P64 + 104] + (_ubiQm::I64 - _ubiQn::I64);
           R1 = _sbioN::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiO9_info" {
     block_cbiO9_info:
         const _cbiO9;
         const 198;
         const 4294967326;
         const Sbipx_srt+152;
 },
 _cbiOu() //  [R1]
         { []
         }
     {offset
       cbiOu: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cbiPB; else goto cbiOG;
       cbiPB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiOG: // global
           _sbio0::P64 = P64[Sp + 40];
           (_sbioS::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_cbiOE_info;
           R1 = _sbio0::P64;
           I64[Sp] = _sbioS::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiQu; else goto cbiOI;
       ubiQu: // global
           call _cbiOE(R1) args: 0, res: 0, upd: 0;
       cbiOI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiOu_info" {
     block_cbiOu_info:
         const _cbiOu;
         const 69;
         const 4294967326;
         const Sbipx_srt+152;
 },
 _cbiOE() //  [R1]
         { []
         }
     {offset
       cbiOE: // global
           _sbinY::P64 = P64[Sp + 32];
           _sbio2::P64 = P64[Sp + 24];
           _sbioS::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbiPf; else goto cbiPy;
       cbiPf: // global
           _sbioU::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbioS::I64));
           if (%MO_S_Ge_W64(_sbioU::I64, 14)) goto cbiOS; else goto ubiQ9;
       ubiQ9: // global
           if (%MO_S_Lt_W64(_sbioU::I64, 11)) goto ubiQa; else goto ubiQb;
       ubiQa: // global
           if (_sbioU::I64 != 4) goto cbiOS; else goto ubiQe;
       ubiQe: // global
           Sp = Sp + 16;
           goto ubiQw;
       ubiQb: // global
           if (_sbioU::I64 == 12) goto cbiOS; else goto cbiPa;
       cbiOS: // global
           R4 = _sbio2::P64;
           R3 = _sbinY::P64;
           R2 = _sbioU::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       cbiPa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiPy: // global
           _sbioV::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbioS::I64));
           if (_sbioV::I64 != 4) goto cbiPo; else goto ubiQd;
       cbiPo: // global
           R4 = _sbio2::P64;
           R3 = _sbinY::P64;
           R2 = _sbioV::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       ubiQd: // global
           Sp = Sp + 16;
           goto ubiQw;
       ubiQw: // global
           call _cbiNY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cbiOE_info" {
     block_cbiOE_info:
         const _cbiOE;
         const 198;
         const 4294967326;
         const Sbipx_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.372335319 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hTryLock3_bytes" {
     GHC.IO.Handle.Lock.hTryLock3_bytes:
         I8[] [104,84,114,121,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.374903592 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock2_closure" {
     GHC.IO.Handle.Lock.hTryLock2_closure:
         const GHC.IO.Handle.Lock.hTryLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock2_entry() //  [R1]
         { []
         }
     {offset
       cbiRL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiRM; else goto cbiRN;
       cbiRM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiRN: // global
           (_cbiRI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiRI::I64 == 0) goto cbiRK; else goto cbiRJ;
       cbiRK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiRJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiRI::I64;
           R2 = GHC.IO.Handle.Lock.hTryLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hTryLock2_info" {
     GHC.IO.Handle.Lock.hTryLock2_info:
         const GHC.IO.Handle.Lock.hTryLock2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.378762437 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock1_closure" {
     GHC.IO.Handle.Lock.hTryLock1_closure:
         const GHC.IO.Handle.Lock.hTryLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock1_entry() //  [R2, R3]
         { []
         }
     {offset
       cbiRZ: // global
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hTryLock2_closure;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hTryLock1_info" {
     GHC.IO.Handle.Lock.hTryLock1_info:
         const GHC.IO.Handle.Lock.hTryLock1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const Sbipx_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.382354443 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock_closure" {
     GHC.IO.Handle.Lock.hTryLock_closure:
         const GHC.IO.Handle.Lock.hTryLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock_entry() //  [R2, R3]
         { []
         }
     {offset
       cbiSa: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hTryLock1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hTryLock_info" {
     GHC.IO.Handle.Lock.hTryLock_info:
         const GHC.IO.Handle.Lock.hTryLock_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Sbipx_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.385577599 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hLock3_bytes" {
     GHC.IO.Handle.Lock.hLock3_bytes:
         I8[] [104,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.38834246 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock2_closure" {
     GHC.IO.Handle.Lock.hLock2_closure:
         const GHC.IO.Handle.Lock.hLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock2_entry() //  [R1]
         { []
         }
     {offset
       cbiSo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiSp; else goto cbiSq;
       cbiSp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiSq: // global
           (_cbiSl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiSl::I64 == 0) goto cbiSn; else goto cbiSm;
       cbiSn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiSm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiSl::I64;
           R2 = GHC.IO.Handle.Lock.hLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hLock2_info" {
     GHC.IO.Handle.Lock.hLock2_info:
         const GHC.IO.Handle.Lock.hLock2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.392842778 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock1_closure" {
     GHC.IO.Handle.Lock.hLock1_closure:
         const GHC.IO.Handle.Lock.hLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock1_entry() //  [R2, R3]
         { []
         }
     {offset
       cbiSE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbiSF; else goto cbiSG;
       cbiSF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiSG: // global
           I64[Sp - 8] = block_cbiSC_info;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hLock2_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hLock1_info" {
     GHC.IO.Handle.Lock.hLock1_info:
         const GHC.IO.Handle.Lock.hLock1_entry;
         const 0;
         const 107374182414;
         const 12884901903;
         const Sbipx_srt+160;
 },
 _cbiSC() //  []
         { []
         }
     {offset
       cbiSC: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiSC_info" {
     block_cbiSC_info:
         const _cbiSC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.397847109 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock_closure" {
     GHC.IO.Handle.Lock.hLock_closure:
         const GHC.IO.Handle.Lock.hLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock_entry() //  [R2, R3]
         { []
         }
     {offset
       cbiSV: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hLock_info" {
     GHC.IO.Handle.Lock.hLock_info:
         const GHC.IO.Handle.Lock.hLock_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const Sbipx_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.400724225 UTC

[section ""data" . GHC.IO.Handle.Lock.SharedLock_closure" {
     GHC.IO.Handle.Lock.SharedLock_closure:
         const GHC.IO.Handle.Lock.SharedLock_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.4028789 UTC

[section ""data" . GHC.IO.Handle.Lock.ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.ExclusiveLock_closure:
         const GHC.IO.Handle.Lock.ExclusiveLock_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.404432806 UTC

[section ""data" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.406044046 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.LockMode_closure_tbl" {
     GHC.IO.Handle.Lock.LockMode_closure_tbl:
         const GHC.IO.Handle.Lock.SharedLock_closure+1;
         const GHC.IO.Handle.Lock.ExclusiveLock_closure+2;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.407919066 UTC

[section ""cstring" . ibiFX_str" {
     ibiFX_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,83,104,97,114,101,100,76,111,99,107]
 },
 GHC.IO.Handle.Lock.SharedLock_con_entry() //  [R1]
         { []
         }
     {offset
       cbiT6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.SharedLock_con_info" {
     GHC.IO.Handle.Lock.SharedLock_con_info:
         const GHC.IO.Handle.Lock.SharedLock_con_entry;
         const 4294967296;
         const 3;
         const ibiFX_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.411543501 UTC

[section ""cstring" . ibiFZ_str" {
     ibiFZ_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,69,120,99,108,117,115,105,118,101,76,111,99,107]
 },
 GHC.IO.Handle.Lock.ExclusiveLock_con_entry() //  [R1]
         { []
         }
     {offset
       cbiTc: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.ExclusiveLock_con_info" {
     GHC.IO.Handle.Lock.ExclusiveLock_con_info:
         const GHC.IO.Handle.Lock.ExclusiveLock_con_entry;
         const 4294967296;
         const 4294967299;
         const ibiFZ_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.414715356 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_closure+1;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.417079561 UTC

[section ""cstring" . ibiG1_str" {
     ibiG1_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 },
 GHC.IO.Handle.Lock.FileLockingNotSupported_con_entry() //  [R1]
         { []
         }
     {offset
       cbiTj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.FileLockingNotSupported_con_info" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_con_info:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_con_entry;
         const 4294967296;
         const 3;
         const ibiG1_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.42031234 UTC

[section ""relreadonly" . Sbipx_srt" {
     Sbipx_srt:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_rbimG_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const GHC.IO.Handle.Lock.hUnlock1_closure;
         const GHC.IO.Handle.Lock.hUnlock2_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Lock.$wlvl_closure;
         const GHC.IO.Handle.Lock.hLock4_closure;
         const GHC.IO.Handle.Lock.hTryLock2_closure;
         const GHC.IO.Handle.Lock.hTryLock1_closure;
         const GHC.IO.Handle.Lock.hLock1_closure;
         const GHC.IO.Handle.Lock.hLock2_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.764508639 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:06:14.768430784 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes:
         I8[] [70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.770755784 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_entry() //  [R1]
         { []
         }
     {offset
       cbiVZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiW0; else goto cbiW1;
       cbiW0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiW1: // global
           (_cbiVW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiVW::I64 == 0) goto cbiVY; else goto cbiVX;
       cbiVY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiVX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiVW::I64;
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.775132663 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_entry() //  [R2,
                                                                           R3, R4]
         { []
         }
     {offset
       cbiWh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiWi; else goto cbiWj;
       cbiWi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiWj: // global
           I64[Sp - 16] = block_cbiWe_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubiWn; else goto cbiWf;
       ubiWn: // global
           call _cbiWe() args: 0, res: 0, upd: 0;
       cbiWf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_info:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const SbiWo_srt;
 },
 _cbiWe() //  []
         { []
         }
     {offset
       cbiWe: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiWe_info" {
     block_cbiWe_info:
         const _cbiWe;
         const 1;
         const 4294967326;
         const SbiWo_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.780574223 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_entry() //  [R2]
         { []
         }
     {offset
       cbiWG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbiWH; else goto cbiWI;
       cbiWH: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiWI: // global
           I64[Sp - 8] = block_cbiWD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiWM; else goto cbiWE;
       ubiWM: // global
           call _cbiWD() args: 0, res: 0, upd: 0;
       cbiWE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const SbiWo_srt;
 },
 _cbiWD() //  []
         { []
         }
     {offset
       cbiWD: // global
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiWD_info" {
     block_cbiWD_info:
         const _cbiWD;
         const 0;
         const 4294967326;
         const SbiWo_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.786105976 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_entry() //  [R2,
                                                                R3]
         { []
         }
     {offset
       cbiX5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiX6; else goto cbiX7;
       cbiX6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbiX7: // global
           I64[Sp - 16] = block_cbiX2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubiXb; else goto cbiX3;
       ubiXb: // global
           call _cbiX2() args: 0, res: 0, upd: 0;
       cbiX3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_info:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const SbiWo_srt;
 },
 _cbiX2() //  []
         { []
         }
     {offset
       cbiX2: // global
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiX2_info" {
     block_cbiX2_info:
         const _cbiX2;
         const 1;
         const 4294967326;
         const SbiWo_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.791352285 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_entry() //  [R2,
                                                                          R3]
         { []
         }
     {offset
       cbiXq: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_info:
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const SbiWo_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.794976657 UTC

[section ""data" . GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure+3;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.796838955 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule4_bytes" {
     GHC.IO.Handle.Lock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.798602333 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule3_closure" {
     GHC.IO.Handle.Lock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.800866365 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$trModule2_bytes" {
     GHC.IO.Handle.Lock.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.802882195 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule1_closure" {
     GHC.IO.Handle.Lock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.804561314 UTC

[section ""data" . GHC.IO.Handle.Lock.$trModule_closure" {
     GHC.IO.Handle.Lock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Lock.$trModule3_closure+1;
         const GHC.IO.Handle.Lock.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.806303713 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.808065275 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
         const GHC.Types.krep$*_closure;
         const 2716065848555532007;
         const 12251424812302631774;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.809838423 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcFileLockingNotSupported_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.811507456 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes:
         I8[] [39,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.81317865 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.815021653 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$tc'FileLockingNotSupported_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported2_closure+1;
         const GHC.IO.Handle.Lock.$tc'FileLockingNotSupported1_closure+1;
         const 13975601321420314475;
         const 8398323512000399582;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.818693268 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_entry() //  [R1]
         { []
         }
     {offset
       cbiXU: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbiXV; else goto cbiXW;
       cbiXV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbiXW: // global
           (_cbiXM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiXM::I64 == 0) goto cbiXO; else goto cbiXN;
       cbiXO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiXN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiXM::I64;
           I64[Sp - 24] = block_cbiXP_info;
           R6 = 0;
           R5 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported4_closure+1;
           R4 = GHC.IO.Handle.Lock.$trModule_closure+1;
           R3 = 12251424812302631774;
           R2 = 2716065848555532007;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_entry;
         const 0;
         const 4294967317;
         const SbiWo_srt+32;
 },
 _cbiXP() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       cbiXP: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbiXQ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cbiXP_info" {
     block_cbiXP_info:
         const _cbiXP;
         const 0;
         const 30;
 },
 _cbiXQ() //  []
         { []
         }
     {offset
       cbiXQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbiXZ; else goto cbiXY;
       cbiXZ: // global
           HpAlloc = 48;
           I64[Sp] = block_cbiXQ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbiXY: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cbiXQ_info" {
     block_cbiXQ_info:
         const _cbiXQ;
         const 1093;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.827354096 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_entry() //  [R2]
         { []
         }
     {offset
       cbiYz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbiYD; else goto cbiYE;
       cbiYD: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiYE: // global
           I64[Sp - 8] = block_cbiYw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiYZ; else goto cbiYx;
       ubiYZ: // global
           call _cbiYw(R1) args: 0, res: 0, upd: 0;
       cbiYx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const SbiWo_srt+40;
 },
 _cbiYw() //  [R1]
         { []
         }
     {offset
       cbiYw: // global
           I64[Sp - 8] = block_cbiYC_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiYw_info" {
     block_cbiYw_info:
         const _cbiYw;
         const 0;
         const 21474836510;
         const SbiWo_srt+40;
 },
 _cbiYC() //  [R1]
         { []
         }
     {offset
       cbiYC: // global
           I64[Sp] = block_cbiYJ_info;
           R3 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiYC_info" {
     block_cbiYC_info:
         const _cbiYC;
         const 1;
         const 21474836510;
         const SbiWo_srt+40;
 },
 _cbiYJ() //  [R1]
         { []
         }
     {offset
       cbiYJ: // global
           if (R1 & 7 == 1) goto cbiYQ; else goto cbiYU;
       cbiYQ: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbiYU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbiYX; else goto cbiYW;
       cbiYX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbiYW: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbiYJ_info" {
     block_cbiYJ_info:
         const _cbiYJ;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.837544458 UTC

[section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure:
         const GHC.Exception.C:Exception_con_info;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure+1;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure+1;
         const 0;
 },
 section ""data" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info;
         const 0;
 },
 GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_entry() //  [R2]
         { []
         }
     {offset
       cbiZv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbiZz; else goto cbiZy;
       cbiZz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiZy: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info" {
     GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_info:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SbiWo_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.841531423 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tcLockMode2_bytes" {
     GHC.IO.Handle.Lock.$tcLockMode2_bytes:
         I8[] [76,111,99,107,77,111,100,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.843085799 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode1_closure" {
     GHC.IO.Handle.Lock.$tcLockMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.844834256 UTC

[section ""data" . GHC.IO.Handle.Lock.$tcLockMode_closure" {
     GHC.IO.Handle.Lock.$tcLockMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tcLockMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18068849831825836849;
         const 1974453150269185476;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.846601054 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Lock.$tcLockMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.848360615 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'SharedLock2_bytes" {
     GHC.IO.Handle.Lock.$tc'SharedLock2_bytes:
         I8[] [39,83,104,97,114,101,100,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.850328889 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock1_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'SharedLock2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.852068345 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'SharedLock_closure" {
     GHC.IO.Handle.Lock.$tc'SharedLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'SharedLock1_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 9660990538910196995;
         const 16983901031857135990;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.853869475 UTC

[section ""cstring" . GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes:
         I8[] [39,69,120,99,108,117,115,105,118,101,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.855588401 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.857406328 UTC

[section ""data" . GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.$tc'ExclusiveLock_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.Lock.$trModule_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock2_closure+1;
         const GHC.IO.Handle.Lock.$tc'ExclusiveLock1_closure+1;
         const 8544818512469904331;
         const 16785548070058023905;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.859199087 UTC

[section ""cstring" . lvl_rbimF_bytes" {
     lvl_rbimF_bytes:
         I8[] [102,108,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.862676051 UTC

[section ""data" . lvl1_rbimG_closure" {
     lvl1_rbimG_closure:
         const lvl1_rbimG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbimG_entry() //  [R1]
         { []
         }
     {offset
       cbiZZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbj00; else goto cbj01;
       cbj00: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj01: // global
           (_cbiZW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbiZW::I64 == 0) goto cbiZY; else goto cbiZX;
       cbiZY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbiZX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbiZW::I64;
           R2 = lvl_rbimF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_rbimG_info" {
     lvl1_rbimG_info:
         const lvl1_rbimG_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.866632255 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock2_closure" {
     GHC.IO.Handle.Lock.hUnlock2_closure:
         const GHC.IO.Handle.Lock.hUnlock2_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock2_entry() //  [R2]
         { []
         }
     {offset
       cbj0g: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl1_rbimG_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hUnlock2_info" {
     GHC.IO.Handle.Lock.hUnlock2_info:
         const GHC.IO.Handle.Lock.hUnlock2_entry;
         const 0;
         const 12884901902;
         const 8589934596;
         const SbiWo_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.872348933 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock1_closure" {
     GHC.IO.Handle.Lock.hUnlock1_closure:
         const GHC.IO.Handle.Lock.hUnlock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock1_entry() //  [R2]
         { []
         }
     {offset
       cbj0y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbj0z; else goto cbj0A;
       cbj0z: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hUnlock1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbj0A: // global
           I64[Sp - 8] = block_cbj0r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubj1D; else goto cbj0s;
       ubj1D: // global
           call _cbj0r(R1) args: 0, res: 0, upd: 0;
       cbj0s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hUnlock1_info" {
     GHC.IO.Handle.Lock.hUnlock1_info:
         const GHC.IO.Handle.Lock.hUnlock1_entry;
         const 0;
         const 17046725197838;
         const 8589934597;
         const SbiWo_srt+40;
 },
 _cbj0r() //  [R1]
         { []
         }
     {offset
       cbj0r: // global
           if (R1 & 7 == 1) goto cbj0v; else goto cbj0w;
       cbj0v: // global
           I64[Sp - 8] = block_cbj0D_info;
           _sbiTS::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbiTS::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbj0w: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj0r_info" {
     block_cbj0r_info:
         const _cbj0r;
         const 0;
         const 12648678686750;
         const SbiWo_srt+40;
 },
 _cbj0D() //  [R1]
         { []
         }
     {offset
       cbj0D: // global
           I64[Sp] = block_cbj0F_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubj1E; else goto cbj0G;
       ubj1E: // global
           call _cbj0F(R1) args: 0, res: 0, upd: 0;
       cbj0G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj0D_info" {
     block_cbj0D_info:
         const _cbj0D;
         const 1;
         const 11549167058974;
         const SbiWo_srt+40;
 },
 _cbj0F() //  [R1]
         { []
         }
     {offset
       cbj0F: // global
           I64[Sp - 8] = block_cbj0K_info;
           _sbiU1::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbiU1::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj0F_info" {
     block_cbj0F_info:
         const _cbj0F;
         const 1;
         const 11549167058974;
         const SbiWo_srt+40;
 },
 _cbj0K() //  [R1]
         { []
         }
     {offset
       cbj0K: // global
           I64[Sp] = block_cbj0R_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj0K_info" {
     block_cbj0K_info:
         const _cbj0K;
         const 2;
         const 11549167058974;
         const SbiWo_srt+40;
 },
 _cbj0R() //  [R1]
         { []
         }
     {offset
       cbj0R: // global
           if (R1 & 7 == 1) goto cbj0Y; else goto cbj12;
       cbj0Y: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       cbj12: // global
           I64[Sp + 16] = block_cbj16_info;
           _cbj14::I64 = I64[Sp + 8];
           Sp = Sp + 16;
           _ubj1v::P64 = CurrentTSO;
           I64[I64[_ubj1v::P64 + 24] + 16] = Sp;
           _ubj1w::I64 = CurrentNursery;
           P64[_ubj1w::I64 + 8] = Hp + 8;
           I64[_ubj1v::P64 + 104] = I64[_ubj1v::P64 + 104] - ((Hp + 8) - I64[_ubj1w::I64]);
           (_ubj1t::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbiUn::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_cbj14::I64, 8);
           (_ubj1u::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubj1t::I64);
           BaseReg = _ubj1u::I64;
           _ubj1x::P64 = CurrentTSO;
           _ubj1y::P64 = I64[_ubj1x::P64 + 24];
           Sp = I64[_ubj1y::P64 + 16];
           SpLim = _ubj1y::P64 + 192;
           HpAlloc = 0;
           _ubj1z::I64 = CurrentNursery;
           _ubj1A::I64 = I64[_ubj1z::I64 + 8];
           Hp = _ubj1A::I64 - 8;
           _ubj1B::I64 = I64[_ubj1z::I64];
           HpLim = _ubj1B::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubj1z::I64 + 48]) << 12) - 1);
           I64[_ubj1x::P64 + 104] = I64[_ubj1x::P64 + 104] + (_ubj1A::I64 - _ubj1B::I64);
           R1 = _sbiUn::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj0R_info" {
     block_cbj0R_info:
         const _cbj0R;
         const 66;
         const 21474836510;
         const SbiWo_srt+112;
 },
 _cbj16() //  [R1]
         { []
         }
     {offset
       cbj16: // global
           if (%MO_SS_Conv_W64_W32(R1) == (-1) :: W32) goto cbj1k; else goto cbj1e;
       cbj1k: // global
           (_sbiUs::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _sbiUs::I64;
           Sp = Sp + 8;
           call GHC.IO.Handle.Lock.hUnlock2_entry(R2) args: 8, res: 0, upd: 8;
       cbj1e: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj16_info" {
     block_cbj16_info:
         const _cbj16;
         const 0;
         const 4294967326;
         const SbiWo_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.886893231 UTC

[section ""data" . GHC.IO.Handle.Lock.hUnlock_closure" {
     GHC.IO.Handle.Lock.hUnlock_closure:
         const GHC.IO.Handle.Lock.hUnlock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hUnlock_entry() //  [R2]
         { []
         }
     {offset
       cbj2A: // global
           R2 = R2;
           call GHC.IO.Handle.Lock.hUnlock1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hUnlock_info" {
     GHC.IO.Handle.Lock.hUnlock_info:
         const GHC.IO.Handle.Lock.hUnlock_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SbiWo_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.891766771 UTC

[section ""data" . GHC.IO.Handle.Lock.$wlvl_closure" {
     GHC.IO.Handle.Lock.$wlvl_closure:
         const GHC.IO.Handle.Lock.$wlvl_info;
         const 0;
 },
 sat_sbiUD_entry() //  [R1]
         { []
         }
     {offset
       cbj2U: // global
           _sbiUD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbj2V; else goto cbj2W;
       cbj2W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbj2Y; else goto cbj2X;
       cbj2Y: // global
           HpAlloc = 16;
           goto cbj2V;
       cbj2V: // global
           R1 = _sbiUD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj2X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbiUD::P64;
           _sbiUz::P64 = P64[_sbiUD::P64 + 16];
           _sbiUA::P64 = P64[_sbiUD::P64 + 24];
           _sbiUy::I64 = I64[_sbiUD::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbiUA::P64;
           R5 = GHC.Base.Nothing_closure+1;
           R4 = Hp - 6;
           R3 = _sbiUy::I64;
           R2 = _sbiUz::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sbiUD_info" {
     sat_sbiUD_info:
         const sat_sbiUD_entry;
         const 4294967298;
         const 4294967311;
         const SbiWo_srt+136;
 },
 sat_sbiUE_entry() //  [R1]
         { []
         }
     {offset
       cbj2Z: // global
           _sbiUE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbj30; else goto cbj31;
       cbj31: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbj33; else goto cbj32;
       cbj33: // global
           HpAlloc = 40;
           goto cbj30;
       cbj30: // global
           R1 = _sbiUE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj32: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbiUE::P64;
           _sbiUz::P64 = P64[_sbiUE::P64 + 16];
           _sbiUA::P64 = P64[_sbiUE::P64 + 24];
           _sbiUy::I64 = I64[_sbiUE::P64 + 32];
           I64[Hp - 32] = sat_sbiUD_info;
           P64[Hp - 16] = _sbiUz::P64;
           P64[Hp - 8] = _sbiUA::P64;
           I64[Hp] = _sbiUy::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sbiUE_info" {
     sat_sbiUE_info:
         const sat_sbiUE_entry;
         const 4294967298;
         const 12884901903;
         const SbiWo_srt+136;
 },
 GHC.IO.Handle.Lock.$wlvl_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cbj34: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbj38; else goto cbj37;
       cbj38: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbj37: // global
           I64[Hp - 32] = sat_sbiUE_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.$wlvl_info" {
     GHC.IO.Handle.Lock.$wlvl_info:
         const GHC.IO.Handle.Lock.$wlvl_entry;
         const 0;
         const 30064771086;
         const 17179869203;
         const SbiWo_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.905145313 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock4_closure" {
     GHC.IO.Handle.Lock.hLock4_closure:
         const GHC.IO.Handle.Lock.hLock4_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock4_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cbj3C: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbj3D; else goto cbj3E;
       cbj3D: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbj3E: // global
           I64[Sp - 32] = block_cbj3v_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubj6M; else goto cbj3w;
       ubj6M: // global
           call _cbj3v(R1) args: 0, res: 0, upd: 0;
       cbj3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hLock4_info" {
     GHC.IO.Handle.Lock.hLock4_info:
         const GHC.IO.Handle.Lock.hLock4_entry;
         const 0;
         const 214958818197518;
         const 21474836504;
         const SbiWo_srt+40;
 },
 _cbj3v() //  [R1]
         { []
         }
     {offset
       cbj3v: // global
           if (R1 & 7 == 1) goto cbj3z; else goto cbj3A;
       cbj3z: // global
           I64[Sp - 8] = block_cbj3H_info;
           _sbiUK::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbiUK::P64;
           Sp = Sp - 8;
           call stg_readMVar#(R1) args: 8, res: 8, upd: 8;
       cbj3A: // global
           R2 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.FD.handleToFd2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj3v_info" {
     block_cbj3v_info:
         const _cbj3v;
         const 3;
         const 74221329842206;
         const SbiWo_srt+40;
 },
 _cbj3H() //  [R1]
         { []
         }
     {offset
       cbj3H: // global
           I64[Sp] = block_cbj3J_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubj6N; else goto cbj3K;
       ubj6N: // global
           call _cbj3J(R1) args: 0, res: 0, upd: 0;
       cbj3K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj3H_info" {
     block_cbj3H_info:
         const _cbj3H;
         const 4;
         const 73121818214430;
         const SbiWo_srt+40;
 },
 _cbj3J() //  [R1]
         { []
         }
     {offset
       cbj3J: // global
           I64[Sp - 8] = block_cbj3O_info;
           _sbiUT::P64 = P64[R1 + 23];
           R1 = P64[R1 + 31];
           P64[Sp] = _sbiUT::P64;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj3J_info" {
     block_cbj3J_info:
         const _cbj3J;
         const 4;
         const 73121818214430;
         const SbiWo_srt+40;
 },
 _cbj3O() //  [R1]
         { []
         }
     {offset
       cbj3O: // global
           I64[Sp] = block_cbj3V_info;
           R3 = GHC.IO.Handle.FD.fdToHandle12_closure;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 7];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj3O_info" {
     block_cbj3O_info:
         const _cbj3O;
         const 5;
         const 73121818214430;
         const SbiWo_srt+40;
 },
 _cbj3V() //  [R1]
         { []
         }
     {offset
       cbj3V: // global
           if (R1 & 7 == 1) goto cbj42; else goto ubj6z;
       cbj42: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 48;
           call GHC.IO.Handle.FD.handleToFd3_entry(R2) args: 8, res: 0, upd: 8;
       ubj6z: // global
           Sp = Sp + 8;
           call _cbj4l() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cbj3V_info" {
     block_cbj3V_info:
         const _cbj3V;
         const 69;
         const 141733920798;
         const SbiWo_srt+112;
 },
 _cbj4l() //  []
         { []
         }
     {offset
       cbj4l: // global
           I64[Sp - 8] = block_cbj4p_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubj6P; else goto cbj6d;
       ubj6P: // global
           call _cbj4p(R1) args: 0, res: 0, upd: 0;
       cbj6d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbj4p() //  [R1]
         { []
         }
     {offset
       cbj4p: // global
           _sbiUI::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbj6j; else goto cbj6n;
       cbj6j: // global
           _sbiVl::I64 = 1;
           goto sbiVk;
       cbj6n: // global
           _sbiVl::I64 = 2;
           goto sbiVk;
       sbiVk: // global
           I64[Sp - 8] = block_cbj4w_info;
           R1 = _sbiUI::P64;
           I64[Sp] = _sbiVl::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubj6Q; else goto cbj62;
       ubj6Q: // global
           call _cbj4w(R1) args: 0, res: 0, upd: 0;
       cbj62: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj4p_info" {
     block_cbj4p_info:
         const _cbj4p;
         const 69;
         const 4294967326;
         const SbiWo_srt+152;
 },
 _cbj4w() //  [R1]
         { []
         }
     {offset
       cbj4w: // global
           _sbiV8::I64 = I64[Sp + 16];
           _sbiVl::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbj68; else goto cbj6c;
       cbj68: // global
           _sbiVn::I64 = 4;
           goto sbiVm;
       cbj6c: // global
           _sbiVn::I64 = 0;
           goto sbiVm;
       sbiVm: // global
           I64[Sp + 8] = block_cbj4R_info;
           Sp = Sp + 8;
           _ubj6E::P64 = CurrentTSO;
           I64[I64[_ubj6E::P64 + 24] + 16] = Sp;
           _ubj6F::I64 = CurrentNursery;
           P64[_ubj6F::I64 + 8] = Hp + 8;
           I64[_ubj6E::P64 + 104] = I64[_ubj6E::P64 + 104] - ((Hp + 8) - I64[_ubj6F::I64]);
           (_ubj6C::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 1);
           (_sbiVv::I64) = call "ccall" arg hints:  [‘signed’,
                                                     ‘signed’]  result hints:  [‘signed’] flock(_sbiV8::I64, _sbiVl::I64 | _sbiVn::I64);
           (_ubj6D::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ubj6C::I64);
           BaseReg = _ubj6D::I64;
           _ubj6G::P64 = CurrentTSO;
           _ubj6H::P64 = I64[_ubj6G::P64 + 24];
           Sp = I64[_ubj6H::P64 + 16];
           SpLim = _ubj6H::P64 + 192;
           HpAlloc = 0;
           _ubj6I::I64 = CurrentNursery;
           _ubj6J::I64 = I64[_ubj6I::I64 + 8];
           Hp = _ubj6J::I64 - 8;
           _ubj6K::I64 = I64[_ubj6I::I64];
           HpLim = _ubj6K::I64 + ((%MO_SS_Conv_W32_W64(I32[_ubj6I::I64 + 48]) << 12) - 1);
           I64[_ubj6G::P64 + 104] = I64[_ubj6G::P64 + 104] + (_ubj6J::I64 - _ubj6K::I64);
           R1 = _sbiVv::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj4w_info" {
     block_cbj4w_info:
         const _cbj4w;
         const 198;
         const 4294967326;
         const SbiWo_srt+152;
 },
 _cbj4R() //  [R1]
         { []
         }
     {offset
       cbj4R: // global
           if (%MO_SS_Conv_W64_W32(R1) == 0 :: W32) goto cbj5Y; else goto cbj53;
       cbj5Y: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbj53: // global
           _sbiUI::P64 = P64[Sp + 40];
           (_sbiVA::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           I64[Sp - 8] = block_cbj51_info;
           R1 = _sbiUI::P64;
           I64[Sp] = _sbiVA::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubj6R; else goto cbj55;
       ubj6R: // global
           call _cbj51(R1) args: 0, res: 0, upd: 0;
       cbj55: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj4R_info" {
     block_cbj4R_info:
         const _cbj4R;
         const 69;
         const 4294967326;
         const SbiWo_srt+152;
 },
 _cbj51() //  [R1]
         { []
         }
     {offset
       cbj51: // global
           _sbiUG::P64 = P64[Sp + 32];
           _sbiUK::P64 = P64[Sp + 24];
           _sbiVA::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbj5C; else goto cbj5V;
       cbj5C: // global
           _sbiVC::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbiVA::I64));
           if (%MO_S_Ge_W64(_sbiVC::I64, 14)) goto cbj5f; else goto ubj6w;
       ubj6w: // global
           if (%MO_S_Lt_W64(_sbiVC::I64, 11)) goto ubj6x; else goto ubj6y;
       ubj6x: // global
           if (_sbiVC::I64 != 4) goto cbj5f; else goto ubj6B;
       ubj6B: // global
           Sp = Sp + 16;
           goto ubj6T;
       ubj6y: // global
           if (_sbiVC::I64 == 12) goto cbj5f; else goto cbj5x;
       cbj5f: // global
           R4 = _sbiUK::P64;
           R3 = _sbiUG::P64;
           R2 = _sbiVC::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       cbj5x: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbj5V: // global
           _sbiVD::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbiVA::I64));
           if (_sbiVD::I64 != 4) goto cbj5L; else goto ubj6A;
       cbj5L: // global
           R4 = _sbiUK::P64;
           R3 = _sbiUG::P64;
           R2 = _sbiVD::I64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Lock.$wlvl_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
       ubj6A: // global
           Sp = Sp + 16;
           goto ubj6T;
       ubj6T: // global
           call _cbj4l() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cbj51_info" {
     block_cbj51_info:
         const _cbj51;
         const 198;
         const 4294967326;
         const SbiWo_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.926496716 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hTryLock3_bytes" {
     GHC.IO.Handle.Lock.hTryLock3_bytes:
         I8[] [104,84,114,121,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.928972202 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock2_closure" {
     GHC.IO.Handle.Lock.hTryLock2_closure:
         const GHC.IO.Handle.Lock.hTryLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock2_entry() //  [R1]
         { []
         }
     {offset
       cbj8j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbj8k; else goto cbj8l;
       cbj8k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj8l: // global
           (_cbj8g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbj8g::I64 == 0) goto cbj8i; else goto cbj8h;
       cbj8i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbj8h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbj8g::I64;
           R2 = GHC.IO.Handle.Lock.hTryLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hTryLock2_info" {
     GHC.IO.Handle.Lock.hTryLock2_info:
         const GHC.IO.Handle.Lock.hTryLock2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.933963444 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock1_closure" {
     GHC.IO.Handle.Lock.hTryLock1_closure:
         const GHC.IO.Handle.Lock.hTryLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock1_entry() //  [R2, R3]
         { []
         }
     {offset
       cbj8y: // global
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hTryLock2_closure;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hTryLock1_info" {
     GHC.IO.Handle.Lock.hTryLock1_info:
         const GHC.IO.Handle.Lock.hTryLock1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const SbiWo_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.937419638 UTC

[section ""data" . GHC.IO.Handle.Lock.hTryLock_closure" {
     GHC.IO.Handle.Lock.hTryLock_closure:
         const GHC.IO.Handle.Lock.hTryLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hTryLock_entry() //  [R2, R3]
         { []
         }
     {offset
       cbj8K: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hTryLock1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hTryLock_info" {
     GHC.IO.Handle.Lock.hTryLock_info:
         const GHC.IO.Handle.Lock.hTryLock_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SbiWo_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.940254418 UTC

[section ""cstring" . GHC.IO.Handle.Lock.hLock3_bytes" {
     GHC.IO.Handle.Lock.hLock3_bytes:
         I8[] [104,76,111,99,107]
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.942866372 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock2_closure" {
     GHC.IO.Handle.Lock.hLock2_closure:
         const GHC.IO.Handle.Lock.hLock2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock2_entry() //  [R1]
         { []
         }
     {offset
       cbj8Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbj8Z; else goto cbj90;
       cbj8Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbj90: // global
           (_cbj8V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbj8V::I64 == 0) goto cbj8X; else goto cbj8W;
       cbj8X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbj8W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbj8V::I64;
           R2 = GHC.IO.Handle.Lock.hLock3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hLock2_info" {
     GHC.IO.Handle.Lock.hLock2_info:
         const GHC.IO.Handle.Lock.hLock2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.947044975 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock1_closure" {
     GHC.IO.Handle.Lock.hLock1_closure:
         const GHC.IO.Handle.Lock.hLock1_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock1_entry() //  [R2, R3]
         { []
         }
     {offset
       cbj9f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbj9g; else goto cbj9h;
       cbj9g: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Lock.hLock1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbj9h: // global
           I64[Sp - 8] = block_cbj9d_info;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = GHC.IO.Handle.Lock.hLock2_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.Lock.hLock4_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hLock1_info" {
     GHC.IO.Handle.Lock.hLock1_info:
         const GHC.IO.Handle.Lock.hLock1_entry;
         const 0;
         const 107374182414;
         const 12884901903;
         const SbiWo_srt+160;
 },
 _cbj9d() //  []
         { []
         }
     {offset
       cbj9d: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cbj9d_info" {
     block_cbj9d_info:
         const _cbj9d;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.952193208 UTC

[section ""data" . GHC.IO.Handle.Lock.hLock_closure" {
     GHC.IO.Handle.Lock.hLock_closure:
         const GHC.IO.Handle.Lock.hLock_info;
         const 0;
 },
 GHC.IO.Handle.Lock.hLock_entry() //  [R2, R3]
         { []
         }
     {offset
       cbj9z: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Lock.hLock1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.hLock_info" {
     GHC.IO.Handle.Lock.hLock_info:
         const GHC.IO.Handle.Lock.hLock_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SbiWo_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.955577794 UTC

[section ""data" . GHC.IO.Handle.Lock.SharedLock_closure" {
     GHC.IO.Handle.Lock.SharedLock_closure:
         const GHC.IO.Handle.Lock.SharedLock_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.957170301 UTC

[section ""data" . GHC.IO.Handle.Lock.ExclusiveLock_closure" {
     GHC.IO.Handle.Lock.ExclusiveLock_closure:
         const GHC.IO.Handle.Lock.ExclusiveLock_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.958806242 UTC

[section ""data" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.96054086 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.LockMode_closure_tbl" {
     GHC.IO.Handle.Lock.LockMode_closure_tbl:
         const GHC.IO.Handle.Lock.SharedLock_closure+1;
         const GHC.IO.Handle.Lock.ExclusiveLock_closure+2;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.96312158 UTC

[section ""cstring" . ibj9L_str" {
     ibj9L_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,83,104,97,114,101,100,76,111,99,107]
 },
 GHC.IO.Handle.Lock.SharedLock_con_entry() //  [R1]
         { []
         }
     {offset
       cbj9K: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.SharedLock_con_info" {
     GHC.IO.Handle.Lock.SharedLock_con_info:
         const GHC.IO.Handle.Lock.SharedLock_con_entry;
         const 4294967296;
         const 3;
         const ibj9L_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.966372709 UTC

[section ""cstring" . ibj9S_str" {
     ibj9S_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,69,120,99,108,117,115,105,118,101,76,111,99,107]
 },
 GHC.IO.Handle.Lock.ExclusiveLock_con_entry() //  [R1]
         { []
         }
     {offset
       cbj9R: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.ExclusiveLock_con_info" {
     GHC.IO.Handle.Lock.ExclusiveLock_con_info:
         const GHC.IO.Handle.Lock.ExclusiveLock_con_entry;
         const 4294967296;
         const 4294967299;
         const ibj9S_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.969285271 UTC

[section ""relreadonly" . GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_closure_tbl:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_closure+1;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.971067396 UTC

[section ""cstring" . ibja0_str" {
     ibja0_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,76,111,99,107,46,70,105,108,101,76,111,99,107,105,110,103,78,111,116,83,117,112,112,111,114,116,101,100]
 },
 GHC.IO.Handle.Lock.FileLockingNotSupported_con_entry() //  [R1]
         { []
         }
     {offset
       cbj9Z: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Handle.Lock.FileLockingNotSupported_con_info" {
     GHC.IO.Handle.Lock.FileLockingNotSupported_con_info:
         const GHC.IO.Handle.Lock.FileLockingNotSupported_con_entry;
         const 4294967296;
         const 3;
         const ibja0_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:06:14.974433699 UTC

[section ""relreadonly" . SbiWo_srt" {
     SbiWo_srt:
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported1_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported_$cshowsPrec_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cshow_closure;
         const GHC.IO.Handle.Lock.$fShowFileLockingNotSupported1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$cfromException_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported3_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_closure;
         const GHC.IO.Handle.Lock.$fExceptionFileLockingNotSupported_$ctoException_closure;
         const Foreign.C.Error.$wlvl_closure;
         const lvl1_rbimG_closure;
         const GHC.IO.Handle.FD.fdToHandle12_closure;
         const GHC.IO.Handle.FD.handleToFd2_closure;
         const GHC.IO.Handle.FD.handleToFd3_closure;
         const GHC.IO.Handle.Lock.hUnlock1_closure;
         const GHC.IO.Handle.Lock.hUnlock2_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Lock.$wlvl_closure;
         const GHC.IO.Handle.Lock.hLock4_closure;
         const GHC.IO.Handle.Lock.hTryLock2_closure;
         const GHC.IO.Handle.Lock.hTryLock1_closure;
         const GHC.IO.Handle.Lock.hLock1_closure;
         const GHC.IO.Handle.Lock.hLock2_closure;
 }]

