
==================== Output Cmm ====================
2018-03-16 16:06:02.742613826 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:02.743220633 UTC

[section ""cstring" . lvl_rb6WB_bytes" {
     lvl_rb6WB_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.744723846 UTC

[section ""data" . GHC.IO.Handle.Text.$willegalBufferSize_closure" {
     GHC.IO.Handle.Text.$willegalBufferSize_closure:
         const GHC.IO.Handle.Text.$willegalBufferSize_info;
         const 0;
 },
 sat_sb6Xn_entry() //  [R1]
         { info_tbl: [(cb7vt,
                       label: sat_sb6Xn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7vt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb7vu; else goto cb7vv;
       cb7vu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7vv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb7vq_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb7vq() //  [R1, R2]
         { info_tbl: [(cb7vq,
                       label: block_cb7vq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7vq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7vy; else goto cb7vx;
       cb7vy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cb7vx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb6Xo_entry() //  [R1]
         { info_tbl: [(cb7vz,
                       label: sat_sb6Xo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7vz: // global
           _sb6Xo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb7vA; else goto cb7vB;
       cb7vB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7vD; else goto cb7vC;
       cb7vD: // global
           HpAlloc = 24;
           goto cb7vA;
       cb7vA: // global
           R1 = _sb6Xo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7vC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb6Xo::P64;
           _sb6Xh::I64 = I64[_sb6Xo::P64 + 16];
           I64[Hp - 16] = sat_sb6Xn_info;
           I64[Hp] = _sb6Xh::I64;
           R3 = Hp - 16;
           R2 = lvl_rb6WB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb6Xq_entry() //  [R1]
         { info_tbl: [(cb7vG,
                       label: sat_sb6Xq_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7vG: // global
           _sb6Xq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb7vH; else goto cb7vI;
       cb7vI: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb7vK; else goto cb7vJ;
       cb7vK: // global
           HpAlloc = 96;
           goto cb7vH;
       cb7vH: // global
           R1 = _sb6Xq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7vJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb6Xq::P64;
           _sb6Xf::P64 = P64[_sb6Xq::P64 + 16];
           _sb6Xg::P64 = P64[_sb6Xq::P64 + 24];
           _sb6Xh::I64 = I64[_sb6Xq::P64 + 32];
           I64[Hp - 88] = sat_sb6Xo_info;
           I64[Hp - 72] = _sb6Xh::I64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sb6Xf::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = _sb6Xg::P64;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.$willegalBufferSize_entry() //  [R2, R3, R4]
         { info_tbl: [(cb7vL,
                       label: GHC.IO.Handle.Text.$willegalBufferSize_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7vL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb7vP; else goto cb7vO;
       cb7vP: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$willegalBufferSize_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb7vO: // global
           I64[Hp - 32] = sat_sb6Xq_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.746907341 UTC

[section ""cstring" . GHC.IO.Handle.Text.$trModule4_bytes" {
     GHC.IO.Handle.Text.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.747505488 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule3_closure" {
     GHC.IO.Handle.Text.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Text.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.748045379 UTC

[section ""cstring" . GHC.IO.Handle.Text.$trModule2_bytes" {
     GHC.IO.Handle.Text.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,101,120,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.748569325 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule1_closure" {
     GHC.IO.Handle.Text.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Text.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.749083645 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule_closure" {
     GHC.IO.Handle.Text.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Text.$trModule3_closure+1;
         const GHC.IO.Handle.Text.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.750128004 UTC

[section ""data" . memcpy1_rb6WC_closure" {
     memcpy1_rb6WC_closure:
         const memcpy1_rb6WC_info;
 },
 memcpy1_rb6WC_entry() //  [R2, R3, R4]
         { info_tbl: [(cb7vY,
                       label: memcpy1_rb6WC_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7vY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb7wg; else goto cb7wh;
       cb7wg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = memcpy1_rb6WC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb7wh: // global
           I64[Sp - 24] = block_cb7vV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub7wo; else goto cb7vW;
       ub7wo: // global
           call _cb7vV(R1) args: 0, res: 0, upd: 0;
       cb7vW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7vV() //  [R1]
         { info_tbl: [(cb7vV,
                       label: block_cb7vV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7vV: // global
           I64[Sp] = block_cb7w1_info;
           _sb6Xw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sb6Xw::I64;
           if (R1 & 7 != 0) goto ub7wn; else goto cb7w2;
       ub7wn: // global
           call _cb7w1(R1) args: 0, res: 0, upd: 0;
       cb7w2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7w1() //  [R1]
         { info_tbl: [(cb7w1,
                       label: block_cb7w1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7w1: // global
           I64[Sp] = block_cb7w6_info;
           _sb6Xy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb6Xy::I64;
           if (R1 & 7 != 0) goto ub7wp; else goto cb7w7;
       ub7wp: // global
           call _cb7w6(R1) args: 0, res: 0, upd: 0;
       cb7w7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7w6() //  [R1]
         { info_tbl: [(cb7w6,
                       label: block_cb7w6_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7w6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7wm; else goto cb7wl;
       cb7wm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7wl: // global
           (_sb6XE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sb6XE::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.751755298 UTC

[section ""data" . GHC.IO.Handle.Text.memcpy_closure" {
     GHC.IO.Handle.Text.memcpy_closure:
         const GHC.IO.Handle.Text.memcpy_info;
 },
 GHC.IO.Handle.Text.memcpy_entry() //  [R2, R3, R4]
         { info_tbl: [(cb7wu,
                       label: GHC.IO.Handle.Text.memcpy_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7wu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call memcpy1_rb6WC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.754877608 UTC

[section ""data" . GHC.IO.Handle.Text.$wcommitBuffer'_closure" {
     GHC.IO.Handle.Text.$wcommitBuffer'_closure:
         const GHC.IO.Handle.Text.$wcommitBuffer'_info;
 },
 GHC.IO.Handle.Text.$wcommitBuffer'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7wy: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wcommitBuffer'_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$wcommitBuffer'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb7wF,
                       label: GHC.IO.Handle.Text.$wcommitBuffer'_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [True, False, True, True, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7wF: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb7wG; else goto cb7wH;
       cb7wG: // global
           R1 = GHC.IO.Handle.Text.$wcommitBuffer'_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cb7wH: // global
           I64[Sp - 40] = block_cb7wC_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           I64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub7za; else goto cb7wD;
       ub7za: // global
           call _cb7wC(R1) args: 0, res: 0, upd: 0;
       cb7wD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7wC() //  [R1]
         { info_tbl: [(cb7wC,
                       label: block_cb7wC_info
                       rep:StackRep [False, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7wC: // global
           I64[Sp - 40] = block_cb7wK_info;
           R6 = I64[Sp + 16];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 48];
           R2 = R1;
           I64[Sp - 56] = 0;
           I64[Sp - 48] = I64[Sp + 24];
           P64[Sp - 32] = P64[R1 + 31];
           P64[Sp - 24] = P64[R1 + 47];
           P64[Sp - 16] = P64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 79];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 56;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb7wK() //  []
         { info_tbl: [(cb7wK,
                       label: block_cb7wK_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7wK: // global
           I64[Sp] = block_cb7wM_info;
           R1 = P64[Sp + 72];
           if (R1 & 7 != 0) goto ub7zb; else goto cb7wP;
       ub7zb: // global
           call _cb7wM(R1) args: 0, res: 0, upd: 0;
       cb7wP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7wM() //  [R1]
         { info_tbl: [(cb7wM,
                       label: block_cb7wM_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7wM: // global
           if (R1 & 7 == 1) goto cb7wW; else goto cb7xB;
       cb7wW: // global
           I64[Sp + 16] = block_cb7wT_info;
           R1 = P64[Sp + 80];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub7zc; else goto cb7wX;
       ub7zc: // global
           call _cb7wT(R1) args: 0, res: 0, upd: 0;
       cb7wX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb7xB: // global
           _sb6Yw::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cb7xz_info;
           R1 = _sb6Yw::P64;
           if (R1 & 7 != 0) goto ub7zd; else goto cb7xC;
       ub7zd: // global
           call _cb7xz(R1) args: 0, res: 0, upd: 0;
       cb7xC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7wT() //  [R1]
         { info_tbl: [(cb7wT,
                       label: block_cb7wT_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7wT: // global
           if (R1 & 7 == 1) goto cb7x3; else goto cb7xb;
       cb7x3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7x6; else goto cb7x5;
       cb7x6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7x5: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7xb: // global
           _sb6Yd::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cb7x9_info;
           R1 = _sb6Yd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub7ze; else goto cb7xc;
       ub7ze: // global
           call _cb7x9(R1) args: 0, res: 0, upd: 0;
       cb7xc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7x9() //  [R1]
         { info_tbl: [(cb7x9,
                       label: block_cb7x9_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7x9: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb7xi; else goto cb7xh;
       cb7xi: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7xh: // global
           _sb6XG::I64 = I64[Sp + 64];
           _sb6XH::P64 = P64[Sp + 24];
           _sb6XI::I64 = I64[Sp + 32];
           _sb6XJ::I64 = I64[Sp + 40];
           if (_sb6XI::I64 == I64[R1 + 31]) goto cb7xw; else goto cb7xo;
       cb7xw: // global
           _sb6XY::P64 = P64[Sp + 8];
           _sb6Yp::P64 = P64[_sb6XY::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           I64[Hp - 80] = _sb6XG::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sb6Yp::P64;
           call MO_WriteBarrier();
           P64[_sb6XY::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XY::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb6XH::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb6XG::I64;
           I64[Hp - 16] = _sb6XI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sb6XJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7xo: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sb6XG::I64;
           I64[Hp - 64] = _sb6XI::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sb6XJ::I64;
           _cb7xm::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cb7xm::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7xz() //  [R1]
         { info_tbl: [(cb7xz,
                       label: block_cb7xz_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7xz: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb7yv; else goto cb7xR;
       cb7yv: // global
           I64[Sp + 16] = block_cb7yu_info;
           R1 = P64[Sp + 80];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub7zf; else goto cb7yw;
       ub7zf: // global
           call _cb7yu(R1) args: 0, res: 0, upd: 0;
       cb7yw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb7xR: // global
           _sb6XS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb7xK_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sb6XS::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb7yu() //  [R1]
         { info_tbl: [(cb7yu,
                       label: block_cb7yu_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7yu: // global
           if (R1 & 7 == 1) goto cb7yC; else goto cb7yK;
       cb7yC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7yF; else goto cb7yE;
       cb7yF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7yE: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7yK: // global
           _sb6Z8::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cb7yI_info;
           R1 = _sb6Z8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub7zi; else goto cb7yL;
       ub7zi: // global
           call _cb7yI(R1) args: 0, res: 0, upd: 0;
       cb7yL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7yI() //  [R1]
         { info_tbl: [(cb7yI,
                       label: block_cb7yI_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7yI: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb7yR; else goto cb7yQ;
       cb7yR: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7yQ: // global
           _sb6XG::I64 = I64[Sp + 64];
           _sb6XH::P64 = P64[Sp + 24];
           _sb6XI::I64 = I64[Sp + 32];
           _sb6XJ::I64 = I64[Sp + 40];
           if (_sb6XI::I64 == I64[R1 + 31]) goto cb7z5; else goto cb7yX;
       cb7z5: // global
           _sb6XY::P64 = P64[Sp + 8];
           _sb6Zk::P64 = P64[_sb6XY::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           I64[Hp - 80] = _sb6XG::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sb6Zk::P64;
           call MO_WriteBarrier();
           P64[_sb6XY::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XY::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb6XH::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb6XG::I64;
           I64[Hp - 16] = _sb6XI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sb6XJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7yX: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sb6XG::I64;
           I64[Hp - 64] = _sb6XI::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sb6XJ::I64;
           _cb7yV::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cb7yV::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7xK() //  [R1]
         { info_tbl: [(cb7xK,
                       label: block_cb7xK_info
                       rep:StackRep [False, False, False, True, False, True, True, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7xK: // global
           _sb6XL::P64 = P64[Sp + 72];
           _sb6XU::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb6XU::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XU::P64);
           I64[Sp + 8] = block_cb7xP_info;
           R1 = _sb6XL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub7zg; else goto cb7xT;
       ub7zg: // global
           call _cb7xP(R1) args: 0, res: 0, upd: 0;
       cb7xT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7xP() //  [R1]
         { info_tbl: [(cb7xP,
                       label: block_cb7xP_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7xP: // global
           if (R1 & 7 == 1) goto cb7xZ; else goto cb7y7;
       cb7xZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7y2; else goto cb7y1;
       cb7y2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7y1: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7y7: // global
           _sb6YN::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cb7y5_info;
           R1 = _sb6YN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub7zh; else goto cb7y8;
       ub7zh: // global
           call _cb7y5(R1) args: 0, res: 0, upd: 0;
       cb7y8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7y5() //  [R1]
         { info_tbl: [(cb7y5,
                       label: block_cb7y5_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7y5: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb7ye; else goto cb7yd;
       cb7ye: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7yd: // global
           _sb6XG::I64 = I64[Sp + 64];
           _sb6XH::P64 = P64[Sp + 24];
           _sb6XI::I64 = I64[Sp + 32];
           _sb6XJ::I64 = I64[Sp + 40];
           if (_sb6XI::I64 == I64[R1 + 31]) goto cb7ys; else goto cb7yk;
       cb7ys: // global
           _sb6XY::P64 = P64[Sp + 8];
           _sb6YZ::P64 = P64[_sb6XY::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           I64[Hp - 80] = _sb6XG::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sb6YZ::P64;
           call MO_WriteBarrier();
           P64[_sb6XY::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XY::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb6XH::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb6XG::I64;
           I64[Hp - 16] = _sb6XI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sb6XJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7yk: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sb6XG::I64;
           I64[Hp - 64] = _sb6XI::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sb6XJ::I64;
           _cb7yi::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cb7yi::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.761166404 UTC

[section ""data" . GHC.IO.Handle.Text.commitBuffer'1_closure" {
     GHC.IO.Handle.Text.commitBuffer'1_closure:
         const GHC.IO.Handle.Text.commitBuffer'1_info;
 },
 GHC.IO.Handle.Text.commitBuffer'1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb7zq,
                       label: GHC.IO.Handle.Text.commitBuffer'1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7zq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb7zz; else goto cb7zA;
       cb7zz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.commitBuffer'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cb7zA: // global
           I64[Sp - 40] = block_cb7zn_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub7zJ; else goto cb7zo;
       ub7zJ: // global
           call _cb7zn(R1) args: 0, res: 0, upd: 0;
       cb7zo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7zn() //  [R1]
         { info_tbl: [(cb7zn,
                       label: block_cb7zn_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7zn: // global
           I64[Sp - 8] = block_cb7zt_info;
           _sb6Zy::P64 = P64[R1 + 7];
           _sb6Zx::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb6Zy::P64;
           I64[Sp + 8] = _sb6Zx::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub7zI; else goto cb7zu;
       ub7zI: // global
           call _cb7zt(R1) args: 0, res: 0, upd: 0;
       cb7zu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7zt() //  [R1]
         { info_tbl: [(cb7zt,
                       label: block_cb7zt_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7zt: // global
           I64[Sp] = block_cb7zy_info;
           _sb6ZA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb6ZA::I64;
           if (R1 & 7 != 0) goto ub7zK; else goto cb7zD;
       ub7zK: // global
           call _cb7zy(R1) args: 0, res: 0, upd: 0;
       cb7zD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7zy() //  [R1]
         { info_tbl: [(cb7zy,
                       label: block_cb7zy_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7zy: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wcommitBuffer'_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.762870195 UTC

[section ""data" . GHC.IO.Handle.Text.commitBuffer'_closure" {
     GHC.IO.Handle.Text.commitBuffer'_closure:
         const GHC.IO.Handle.Text.commitBuffer'_info;
 },
 GHC.IO.Handle.Text.commitBuffer'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb7zP,
                       label: GHC.IO.Handle.Text.commitBuffer'_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7zP: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.commitBuffer'1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.763628591 UTC

[section ""cstring" . lvl1_rb6WD_bytes" {
     lvl1_rb6WD_bytes:
         I8[] [99,111,109,109,105,116,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.76437374 UTC

[section ""data" . lvl2_rb6WE_closure" {
     lvl2_rb6WE_closure:
         const lvl2_rb6WE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rb6WE_entry() //  [R1]
         { info_tbl: [(cb7zY,
                       label: lvl2_rb6WE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7zY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7zZ; else goto cb7A0;
       cb7zZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7A0: // global
           (_cb7zV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb7zV::I64 == 0) goto cb7zX; else goto cb7zW;
       cb7zX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb7zW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb7zV::I64;
           R2 = lvl1_rb6WD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.765485965 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutChar3_bytes" {
     GHC.IO.Handle.Text.hPutChar3_bytes:
         I8[] [104,80,117,116,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.766192134 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar2_closure" {
     GHC.IO.Handle.Text.hPutChar2_closure:
         const GHC.IO.Handle.Text.hPutChar2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar2_entry() //  [R1]
         { info_tbl: [(cb7A7,
                       label: GHC.IO.Handle.Text.hPutChar2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7A7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7A8; else goto cb7A9;
       cb7A8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7A9: // global
           (_cb7A4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb7A4::I64 == 0) goto cb7A6; else goto cb7A5;
       cb7A6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb7A5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb7A4::I64;
           R2 = GHC.IO.Handle.Text.hPutChar3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.769053121 UTC

[section ""data" . GHC.IO.Handle.Text.$whPutChar_closure" {
     GHC.IO.Handle.Text.$whPutChar_closure:
         const GHC.IO.Handle.Text.$whPutChar_info;
         const 0;
 },
 act_sb6ZG_entry() //  [R1, R2]
         { info_tbl: [(cb7Am,
                       label: act_sb6ZG_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Am: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cb7An; else goto cb7Ao;
       cb7An: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7Ao: // global
           I64[Sp - 16] = block_cb7Aj_info;
           _sb6ZE::I64 = I64[R1 + 6];
           R1 = R2;
           I64[Sp - 8] = _sb6ZE::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub7C2; else goto cb7Ak;
       ub7C2: // global
           call _cb7Aj(R1) args: 0, res: 0, upd: 0;
       cb7Ak: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Aj() //  [R1]
         { info_tbl: [(cb7Aj,
                       label: block_cb7Aj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Aj: // global
           _sb702::P64 = P64[P64[R1 + 71] + 8];
           _sb703::I64 = I64[Sp + 8];
           if (_sb703::I64 == 10) goto cb7Bl; else goto cb7AF;
       cb7Bl: // global
           I64[Sp - 40] = block_cb7AM_info;
           _sb6ZJ::P64 = R1;
           _sb6ZL::P64 = P64[R1 + 15];
           _sb6ZN::P64 = P64[R1 + 31];
           _sb6ZP::P64 = P64[R1 + 47];
           _sb6ZQ::P64 = P64[R1 + 55];
           R1 = P64[R1 + 119];
           P64[Sp - 32] = _sb6ZN::P64;
           P64[Sp - 24] = _sb6ZP::P64;
           P64[Sp - 16] = _sb6ZQ::P64;
           P64[Sp - 8] = _sb702::P64;
           P64[Sp] = _sb6ZL::P64;
           P64[Sp + 8] = _sb6ZJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub7C1; else goto cb7Bm;
       ub7C1: // global
           call _cb7AM(R1) args: 0, res: 0, upd: 0;
       cb7Bm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb7AF: // global
           I64[Sp - 8] = block_cb7Au_info;
           _sb6ZJ::P64 = R1;
           R1 = _sb702::P64;
           I64[Sp] = _sb703::I64;
           P64[Sp + 8] = _sb6ZJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub7C0; else goto cb7Av;
       ub7C0: // global
           call _cb7Au(R1) args: 0, res: 0, upd: 0;
       cb7Av: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7AM() //  [R1]
         { info_tbl: [(cb7AM,
                       label: block_cb7AM_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7AM: // global
           _sb702::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cb7Bt; else goto cb7BD;
       cb7Bt: // global
           I64[Sp] = block_cb7Bq_info;
           R1 = _sb702::P64;
           if (R1 & 7 != 0) goto ub7C3; else goto cb7Bu;
       ub7C3: // global
           call _cb7Bq(R1) args: 0, res: 0, upd: 0;
       cb7Bu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb7BD: // global
           I64[Sp] = block_cb7BB_info;
           R1 = _sb702::P64;
           if (R1 & 7 != 0) goto ub7C4; else goto cb7BE;
       ub7C4: // global
           call _cb7BB(R1) args: 0, res: 0, upd: 0;
       cb7BE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Bq() //  [R1]
         { info_tbl: [(cb7Bq,
                       label: block_cb7Bq_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Bq: // global
           _sb70L::P64 = P64[R1 + 7];
           _sb70M::P64 = P64[R1 + 15];
           _sb70K::I64 = I64[R1 + 23];
           _sb70N::I64 = I64[R1 + 31];
           _sb70O::I64 = I64[R1 + 39];
           _sb70P::I64 = I64[R1 + 47];
           I32[_sb70K::I64 + (_sb70P::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb70L::P64);
           I64[Sp + 32] = _sb70K::I64;
           P64[Sp] = _sb70L::P64;
           P64[Sp - 32] = _sb70M::P64;
           I64[Sp - 24] = _sb70N::I64;
           I64[Sp - 16] = _sb70O::I64;
           I64[Sp - 8] = _sb70P::I64 + 1;
           Sp = Sp - 32;
           call _sb70h() args: 0, res: 0, upd: 0;
     }
 },
 _cb7BB() //  [R1]
         { info_tbl: [(cb7BB,
                       label: block_cb7BB_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7BB: // global
           _sb70V::P64 = P64[R1 + 7];
           _sb70W::P64 = P64[R1 + 15];
           _sb70U::I64 = I64[R1 + 23];
           _sb70X::I64 = I64[R1 + 31];
           _sb70Y::I64 = I64[R1 + 39];
           _sb70Z::I64 = I64[R1 + 47];
           I32[_sb70U::I64 + (_sb70Z::I64 << 2)] = 13 :: W32;
           call MO_Touch(_sb70V::P64);
           _sb712::I64 = _sb70Z::I64 + 1;
           I32[_sb70U::I64 + (_sb712::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb70V::P64);
           P64[Sp - 32] = _sb70W::P64;
           I64[Sp - 24] = _sb70X::I64;
           I64[Sp - 16] = _sb70Y::I64;
           I64[Sp - 8] = _sb712::I64 + 1;
           P64[Sp] = _sb70V::P64;
           I64[Sp + 32] = _sb70U::I64;
           Sp = Sp - 32;
           call _sb70h() args: 0, res: 0, upd: 0;
     }
 },
 _sb70h() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb70h: // global
           _sb70k::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cb7AQ_info;
           R6 = I64[Sp + 8];
           R5 = P64[Sp];
           R4 = _sb70k::P64;
           R3 = I64[Sp + 64];
           R2 = P64[Sp + 80];
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb7AQ() //  []
         { info_tbl: [(cb7AQ,
                       label: block_cb7AQ_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7AQ: // global
           I64[Sp] = block_cb7AS_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto ub7C5; else goto cb7AV;
       ub7C5: // global
           call _cb7AS(R1) args: 0, res: 0, upd: 0;
       cb7AV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7AS() //  [R1]
         { info_tbl: [(cb7AS,
                       label: block_cb7AS_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7AS: // global
           if (R1 & 7 == 2) goto cb7B6; else goto ub7BY;
       cb7B6: // global
           _sb70v::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cb7B4_info;
           R1 = _sb70v::P64;
           if (R1 & 7 != 0) goto ub7C6; else goto cb7B7;
       ub7C6: // global
           call _cb7B4(R1) args: 0, res: 0, upd: 0;
       cb7B7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub7BY: // global
           Sp = Sp + 56;
           call _cb7Bk() args: 0, res: 0, upd: 0;
     }
 },
 _cb7B4() //  [R1]
         { info_tbl: [(cb7B4,
                       label: block_cb7B4_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7B4: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ub7BZ; else goto cb7Bh;
       ub7BZ: // global
           Sp = Sp + 56;
           call _cb7Bk() args: 0, res: 0, upd: 0;
       cb7Bh: // global
           _sb6ZN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb7Bf_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sb6ZN::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb7Bf() //  [R1]
         { info_tbl: [(cb7Bf,
                       label: block_cb7Bf_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Bf: // global
           _sb6ZP::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb6ZP::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6ZP::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7Bk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Bk: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7Au() //  [R1]
         { info_tbl: [(cb7Au,
                       label: block_cb7Au_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Au: // global
           _sb6ZJ::P64 = P64[Sp + 16];
           _sb706::P64 = P64[R1 + 7];
           _sb707::P64 = P64[R1 + 15];
           _sb705::I64 = I64[R1 + 23];
           _sb708::I64 = I64[R1 + 31];
           _sb709::I64 = I64[R1 + 39];
           _sb70a::I64 = I64[R1 + 47];
           I32[_sb705::I64 + (_sb70a::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp + 8]);
           call MO_Touch(_sb706::P64);
           I64[Sp + 16] = block_cb7AD_info;
           R6 = _sb708::I64;
           R5 = _sb707::P64;
           R4 = _sb706::P64;
           R3 = _sb705::I64;
           R2 = _sb6ZJ::P64;
           I64[Sp] = _sb709::I64;
           I64[Sp + 8] = _sb70a::I64 + 1;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb7AD() //  []
         { info_tbl: [(cb7AD,
                       label: block_cb7AD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7AD: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$whPutChar_entry() //  [R2, R3]
         { info_tbl: [(cb7Ci,
                       label: GHC.IO.Handle.Text.$whPutChar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ci: // global
           _sb6ZE::I64 = R3;
           _sb6ZD::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cb7Cj; else goto cb7Ck;
       cb7Ck: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7Cm; else goto cb7Cl;
       cb7Cm: // global
           HpAlloc = 16;
           goto cb7Cj;
       cb7Cj: // global
           R3 = _sb6ZE::I64;
           R2 = _sb6ZD::P64;
           R1 = GHC.IO.Handle.Text.$whPutChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb7Cl: // global
           I64[Hp - 8] = act_sb6ZG_info;
           I64[Hp] = _sb6ZE::I64;
           I64[Sp - 16] = block_cb7Cb_info;
           R1 = _sb6ZD::P64;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub7Ct; else goto cb7Cc;
       ub7Ct: // global
           call _cb7Cb(R1) args: 0, res: 0, upd: 0;
       cb7Cc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Cb() //  [R1]
         { info_tbl: [(cb7Cb,
                       label: block_cb7Cb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Cb: // global
           _cb7Ae::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cb7Cf; else goto cb7Cg;
       cb7Cf: // global
           R5 = _cb7Ae::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutChar2_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cb7Cg: // global
           R5 = _cb7Ae::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutChar2_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.773731365 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar1_closure" {
     GHC.IO.Handle.Text.hPutChar1_closure:
         const GHC.IO.Handle.Text.hPutChar1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar1_entry() //  [R2, R3]
         { info_tbl: [(cb7CB,
                       label: GHC.IO.Handle.Text.hPutChar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7CB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7CC; else goto cb7CD;
       cb7CC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutChar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb7CD: // global
           I64[Sp - 16] = block_cb7Cy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub7CH; else goto cb7Cz;
       ub7CH: // global
           call _cb7Cy(R1) args: 0, res: 0, upd: 0;
       cb7Cz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Cy() //  [R1]
         { info_tbl: [(cb7Cy,
                       label: block_cb7Cy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Cy: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.774863813 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar_closure" {
     GHC.IO.Handle.Text.hPutChar_closure:
         const GHC.IO.Handle.Text.hPutChar_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar_entry() //  [R2, R3]
         { info_tbl: [(cb7CM,
                       label: GHC.IO.Handle.Text.hPutChar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7CM: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutChar1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.776068646 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr7_closure" {
     GHC.IO.Handle.Text.hPutStr7_closure:
         const GHC.IO.Handle.Text.hPutStr7_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr7_entry() //  [R2, R3]
         { info_tbl: [(cb7D0,
                       label: GHC.IO.Handle.Text.hPutStr7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7D0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb7D1; else goto ub7Di;
       cb7D1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ub7Di: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cb7CQ() args: 0, res: 0, upd: 0;
     }
 },
 _cb7CQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7CQ: // global
           I64[Sp - 8] = block_cb7CT_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub7Dk; else goto cb7CU;
       ub7Dk: // global
           call _cb7CT(R1) args: 0, res: 0, upd: 0;
       cb7CU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7CT() //  [R1]
         { info_tbl: [(cb7CT,
                       label: block_cb7CT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7CT: // global
           if (R1 & 7 == 1) goto cb7CX; else goto cb7CY;
       cb7CX: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7CY: // global
           I64[Sp] = block_cb7D8_info;
           _sb71m::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sb71m::P64;
           if (R1 & 7 != 0) goto ub7Dl; else goto cb7Da;
       ub7Dl: // global
           call _cb7D8(R1) args: 0, res: 0, upd: 0;
       cb7Da: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7D8() //  [R1]
         { info_tbl: [(cb7D8,
                       label: block_cb7D8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7D8: // global
           I64[Sp] = block_cb7De_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7De() //  []
         { info_tbl: [(cb7De,
                       label: block_cb7De_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7De: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cb7CQ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.7784296 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar3_closure" {
     GHC.IO.Handle.Text.hGetChar3_closure:
         const GHC.IO.Handle.Text.hGetChar3_info;
         const 0;
 },
 sat_sb71H_entry() //  [R1]
         { info_tbl: [(cb7DT,
                       label: sat_sb71H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7DT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7DU; else goto cb7DV;
       cb7DU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7DV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetChar3_entry() //  [R2]
         { info_tbl: [(cb7DW,
                       label: GHC.IO.Handle.Text.hGetChar3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7DW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb7DX; else goto cb7DY;
       cb7DX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetChar3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7DY: // global
           I64[Sp - 8] = block_cb7Ds_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub7Ek; else goto cb7Dt;
       ub7Ek: // global
           call _cb7Ds(R1) args: 0, res: 0, upd: 0;
       cb7Dt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Ds() //  [R1]
         { info_tbl: [(cb7Ds,
                       label: block_cb7Ds_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ds: // global
           I64[Sp - 16] = block_cb7Dx_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Dx() //  [R1]
         { info_tbl: [(cb7Dx,
                       label: block_cb7Dx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Dx: // global
           I64[Sp] = block_cb7DB_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7DB() //  [R1]
         { info_tbl: [(cb7DB,
                       label: block_cb7DB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7DB: // global
           if (R1 & 7 == 1) goto cb7E4; else goto cb7E6;
       cb7E4: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cb7E6: // global
           I64[Sp + 16] = block_cb7DG_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7DG() //  [R1]
         { info_tbl: [(cb7DG,
                       label: block_cb7DG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7DG: // global
           I64[Sp - 8] = block_cb7DK_info;
           _sb71z::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sb71z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub7Ej; else goto cb7DL;
       ub7Ej: // global
           call _cb7DK(R1) args: 0, res: 0, upd: 0;
       cb7DL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7DK() //  [R1]
         { info_tbl: [(cb7DK,
                       label: block_cb7DK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7DK: // global
           if (I32[I64[R1 - 1] + 20] == 4 :: W32) goto cb7Eg; else goto cb7E9;
       cb7Eg: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7E9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7Ec; else goto cb7Eb;
       cb7Ec: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7Eb: // global
           I64[Hp - 16] = sat_sb71H_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.780394166 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetChar7_bytes" {
     GHC.IO.Handle.Text.hGetChar7_bytes:
         I8[] [104,71,101,116,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.78115603 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar6_closure" {
     GHC.IO.Handle.Text.hGetChar6_closure:
         const GHC.IO.Handle.Text.hGetChar6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar6_entry() //  [R1]
         { info_tbl: [(cb7Er,
                       label: GHC.IO.Handle.Text.hGetChar6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Er: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7Es; else goto cb7Et;
       cb7Es: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Et: // global
           (_cb7Eo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb7Eo::I64 == 0) goto cb7Eq; else goto cb7Ep;
       cb7Eq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb7Ep: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb7Eo::I64;
           R2 = GHC.IO.Handle.Text.hGetChar7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.782021755 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar5_closure" {
     GHC.IO.Handle.Text.hGetChar5_closure:
         const GHC.Types.C#_con_info;
         const 13;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.782614682 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar4_closure" {
     GHC.IO.Handle.Text.hGetChar4_closure:
         const GHC.Types.C#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.787569843 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar2_closure" {
     GHC.IO.Handle.Text.hGetChar2_closure:
         const GHC.IO.Handle.Text.hGetChar2_info;
         const 0;
 },
 sat_sb72q_entry() //  [R1]
         { info_tbl: [(cb7Fi,
                       label: sat_sb72q_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Fi: // global
           _sb72q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb7Fj; else goto cb7Fk;
       cb7Fk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7Fm; else goto cb7Fl;
       cb7Fm: // global
           HpAlloc = 56;
           goto cb7Fj;
       cb7Fj: // global
           R1 = _sb72q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Fl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb72q::P64;
           _sb72e::P64 = P64[_sb72q::P64 + 16];
           _sb72f::P64 = P64[_sb72q::P64 + 24];
           _sb72d::I64 = I64[_sb72q::P64 + 32];
           _sb72g::I64 = I64[_sb72q::P64 + 40];
           _sb72i::I64 = I64[_sb72q::P64 + 48];
           _sb72n::I64 = I64[_sb72q::P64 + 56];
           if (_sb72n::I64 == _sb72i::I64) goto cb7Fh; else goto cb7Fg;
       cb7Fh: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7Fg: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = _sb72n::I64;
           I64[Hp] = _sb72i::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb72v_entry() //  [R1]
         { info_tbl: [(cb7FA,
                       label: sat_sb72v_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7FA: // global
           _sb72v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb7FB; else goto cb7FC;
       cb7FC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7FE; else goto cb7FD;
       cb7FE: // global
           HpAlloc = 56;
           goto cb7FB;
       cb7FB: // global
           R1 = _sb72v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7FD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb72v::P64;
           _sb72e::P64 = P64[_sb72v::P64 + 16];
           _sb72f::P64 = P64[_sb72v::P64 + 24];
           _sb72d::I64 = I64[_sb72v::P64 + 32];
           _sb72g::I64 = I64[_sb72v::P64 + 40];
           _sb72i::I64 = I64[_sb72v::P64 + 48];
           _sb72n::I64 = I64[_sb72v::P64 + 56];
           if (_sb72n::I64 == _sb72i::I64) goto cb7Fz; else goto cb7Fy;
       cb7Fz: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7Fy: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = _sb72n::I64;
           I64[Hp] = _sb72i::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb72P_entry() //  [R1]
         { info_tbl: [(cb7FZ,
                       label: sat_sb72P_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7FZ: // global
           _sb72P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb7G0; else goto cb7G1;
       cb7G1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7G3; else goto cb7G2;
       cb7G3: // global
           HpAlloc = 56;
           goto cb7G0;
       cb7G0: // global
           R1 = _sb72P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7G2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb72P::P64;
           _sb72A::P64 = P64[_sb72P::P64 + 16];
           _sb72B::P64 = P64[_sb72P::P64 + 24];
           _sb72z::I64 = I64[_sb72P::P64 + 32];
           _sb72C::I64 = I64[_sb72P::P64 + 40];
           _sb72E::I64 = I64[_sb72P::P64 + 56];
           _sb72N::I64 = I64[_sb72P::P64 + 48] + 1;
           if (_sb72N::I64 == _sb72E::I64) goto cb7Gd; else goto cb7Ga;
       cb7Gd: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72A::P64;
           P64[Hp - 32] = _sb72B::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7Ga: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72A::P64;
           P64[Hp - 32] = _sb72B::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = _sb72N::I64;
           I64[Hp] = _sb72E::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb73b_entry() //  [R1]
         { info_tbl: [(cb7Gq,
                       label: sat_sb73b_info
                       rep:HeapRep 4 ptrs 4 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Gq: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cb7Gr; else goto cb7Gs;
       cb7Gr: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb7Gs: // global
           _sb71K::P64 = P64[R1 + 7];
           _sb72F::P64 = P64[R1 + 31];
           _sb72D::I64 = I64[R1 + 55];
           _sb72S::I64 = I64[R1 + 63] - _sb72D::I64;
           if (_sb72S::I64 != 0) goto ub7H9; else goto cb7Go;
       ub7H9: // global
           if (_sb72S::I64 != 1) goto ub7Hb; else goto ub7Ha;
       ub7Hb: // global
           P64[Sp - 16] = _sb72F::P64;
           I64[Sp - 8] = _sb72S::I64;
           Sp = Sp - 16;
           call _cb7Gv() args: 0, res: 0, upd: 0;
       ub7Ha: // global
           P64[Sp - 64] = _sb71K::P64;
           I64[Sp - 56] = I64[R1 + 39];
           P64[Sp - 48] = P64[R1 + 15];
           P64[Sp - 40] = P64[R1 + 23];
           I64[Sp - 32] = I64[R1 + 47];
           I64[Sp - 24] = _sb72D::I64;
           P64[Sp - 16] = _sb72F::P64;
           I64[Sp - 8] = _sb72S::I64;
           Sp = Sp - 64;
           call _cb7GO() args: 0, res: 0, upd: 0;
       cb7Go: // global
           I64[Sp - 8] = block_cb7GF_info;
           R3 = _sb72F::P64;
           R2 = _sb71K::P64;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Gv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Gv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7GA; else goto cb7Gz;
       cb7GA: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb7Gu_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb7Gz: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7Gu() //  [R1]
         { info_tbl: [(cb7Gu,
                       label: block_cb7Gu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Gu: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb7Gv() args: 0, res: 0, upd: 0;
     }
 },
 _cb7GO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7GO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7GS; else goto cb7GR;
       cb7GS: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cb7GN_info;
           R1 = I64[Sp + 56];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb7GR: // global
           _sb71K::P64 = P64[Sp];
           _sb72z::I64 = I64[Sp + 8];
           _sb72A::P64 = P64[Sp + 16];
           _sb72B::P64 = P64[Sp + 24];
           _sb72C::I64 = I64[Sp + 32];
           _sb72F::P64 = P64[Sp + 48];
           _sb730::I64 = %MO_UU_Conv_W32_W64(I32[_sb72z::I64 + (I64[Sp + 40] << 2)]);
           call MO_Touch(_sb72A::P64);
           if (_sb730::I64 == 13) goto cb7H5; else goto cb7GY;
       cb7H5: // global
           I32[_sb72z::I64] = 13 :: W32;
           call MO_Touch(_sb72A::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72A::P64;
           P64[Hp - 32] = _sb72B::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 56] = block_cb7H2_info;
           R3 = Hp - 47;
           R2 = _sb71K::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb7GY: // global
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = _sb72F::P64;
           _cb7GW::P64 = Hp - 46;
           Hp = Hp - 40;
           R1 = _cb7GW::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7GN() //  [R1]
         { info_tbl: [(cb7GN,
                       label: block_cb7GN_info
                       rep:StackRep [False, True, False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7GN: // global
           I64[Sp + 64] = R1;
           Sp = Sp + 8;
           call _cb7GO() args: 0, res: 0, upd: 0;
     }
 },
 _cb7H2() //  [R1]
         { info_tbl: [(cb7H2,
                       label: block_cb7H2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7H2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7H8; else goto cb7H7;
       cb7H8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7H7: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7GF() //  [R1]
         { info_tbl: [(cb7GF,
                       label: block_cb7GF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7GF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7GL; else goto cb7GK;
       cb7GL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7GK: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb73x_entry() //  [R1]
         { info_tbl: [(cb7HB,
                       label: sat_sb73x_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7HB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb7HC; else goto cb7HD;
       cb7HC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7HD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb7Hy_info;
           _sb72D::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb72D::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub7HV; else goto cb7Hz;
       ub7HV: // global
           call _cb7Hy(R1) args: 0, res: 0, upd: 0;
       cb7Hz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb7Hy() //  [R1]
         { info_tbl: [(cb7Hy,
                       label: block_cb7Hy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Hy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7HI; else goto cb7HH;
       cb7HI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb7HH: // global
           _sb73q::P64 = P64[R1 + 7];
           _sb73r::P64 = P64[R1 + 15];
           _sb73p::I64 = I64[R1 + 23];
           _sb73s::I64 = I64[R1 + 31];
           _sb73u::I64 = I64[R1 + 47];
           _sb73v::I64 = I64[Sp + 8] + 1;
           if (_sb73v::I64 == _sb73u::I64) goto cb7HU; else goto cb7HR;
       cb7HU: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb73q::P64;
           P64[Hp - 32] = _sb73r::P64;
           I64[Hp - 24] = _sb73p::I64;
           I64[Hp - 16] = _sb73s::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7HR: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb73q::P64;
           P64[Hp - 32] = _sb73r::P64;
           I64[Hp - 24] = _sb73p::I64;
           I64[Hp - 16] = _sb73s::I64;
           I64[Hp - 8] = _sb73v::I64;
           I64[Hp] = _sb73u::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetChar2_entry() //  [R2]
         { info_tbl: [(cb7HW,
                       label: GHC.IO.Handle.Text.hGetChar2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7HW: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cb7HX; else goto cb7HY;
       cb7HX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetChar2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7HY: // global
           I64[Sp - 8] = block_cb7Ey_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub7Jq; else goto cb7Ez;
       ub7Jq: // global
           call _cb7Ey(R1) args: 0, res: 0, upd: 0;
       cb7Ez: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Ey() //  [R1]
         { info_tbl: [(cb7Ey,
                       label: block_cb7Ey_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ey: // global
           I64[Sp - 24] = block_cb7ED_info;
           _sb71K::P64 = R1;
           _sb71T::P64 = P64[R1 + 71];
           _sb71Y::P64 = P64[R1 + 111];
           R1 = P64[_sb71T::P64 + 8];
           P64[Sp - 16] = _sb71T::P64;
           P64[Sp - 8] = _sb71Y::P64;
           P64[Sp] = _sb71K::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub7Jl; else goto cb7EE;
       ub7Jl: // global
           call _cb7ED(R1) args: 0, res: 0, upd: 0;
       cb7EE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7ED() //  [R1]
         { info_tbl: [(cb7ED,
                       label: block_cb7ED_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7ED: // global
           _sb729::I64 = I64[R1 + 39];
           _sb72a::I64 = I64[R1 + 47];
           if (_sb729::I64 == _sb72a::I64) goto cb7IT; else goto cb7IN;
       cb7IT: // global
           I64[Sp] = block_cb7IQ_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb7IN: // global
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sb729::I64;
           I64[Sp - 8] = _sb72a::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 40;
           call _sb72b() args: 0, res: 0, upd: 0;
     }
 },
 _cb7IQ() //  [R1]
         { info_tbl: [(cb7IQ,
                       label: block_cb7IQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7IQ: // global
           I64[Sp] = block_cb7IS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub7Jr; else goto cb7IV;
       ub7Jr: // global
           call _cb7IS(R1) args: 0, res: 0, upd: 0;
       cb7IV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7IS() //  [R1]
         { info_tbl: [(cb7IS,
                       label: block_cb7IS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7IS: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sb72b() args: 0, res: 0, upd: 0;
     }
 },
 _sb72b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb72b: // global
           _sb71Y::P64 = P64[Sp + 56];
           _sb72h::I64 = I64[Sp + 24];
           _sb72l::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 40] + (_sb72h::I64 << 2)]);
           call MO_Touch(P64[Sp]);
           I64[Sp - 8] = block_cb7ER_info;
           R1 = _sb71Y::P64;
           I64[Sp + 24] = _sb72h::I64 + 1;
           I64[Sp + 56] = _sb72l::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub7Jt; else goto cb7ES;
       ub7Jt: // global
           call _cb7ER(R1) args: 0, res: 0, upd: 0;
       cb7ES: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7ER() //  [R1]
         { info_tbl: [(cb7ER,
                       label: block_cb7ER_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7ER: // global
           _sb71T::P64 = P64[Sp + 56];
           _sb72d::I64 = I64[Sp + 48];
           _sb72e::P64 = P64[Sp + 8];
           _sb72f::P64 = P64[Sp + 16];
           _sb72g::I64 = I64[Sp + 24];
           _sb72i::I64 = I64[Sp + 40];
           _sb72l::I64 = I64[Sp + 64];
           _sb72n::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cb7I7; else goto cb7Ib;
       cb7I7: // global
           Hp = Hp + 80;
           _sb72o::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb7Ie; else goto cb7I9;
       cb7I9: // global
           I64[Hp - 72] = sat_sb72q_info;
           P64[Hp - 56] = _sb72e::P64;
           P64[Hp - 48] = _sb72f::P64;
           I64[Hp - 40] = _sb72d::I64;
           I64[Hp - 32] = _sb72g::I64;
           I64[Hp - 24] = _sb72i::I64;
           I64[Hp - 16] = _sb72n::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 72;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sb72l::I64;
           R1 = Hp - 7;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7Ib: // global
           Hp = Hp + 80;
           _sb72o::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb7Ie; else goto cb7Id;
       cb7Ie: // global
           HpAlloc = 80;
           R1 = _sb72o::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7Id: // global
           if (_sb72l::I64 == 13) goto cb7IJ; else goto cb7Ik;
       cb7IJ: // global
           if (_sb72n::I64 == _sb72i::I64) goto cb7II; else goto cb7IH;
       cb7II: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb72e::P64;
           P64[Hp - 56] = _sb72f::P64;
           I64[Hp - 48] = _sb72d::I64;
           I64[Hp - 40] = _sb72g::I64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           _cb7F7::P64 = Hp - 71;
           Hp = Hp - 24;
           I64[Sp + 64] = _sb72d::I64;
           P64[Sp + 48] = _sb72e::P64;
           P64[Sp + 40] = _sb72f::P64;
           I64[Sp + 32] = _sb72g::I64;
           I64[Sp + 24] = 0;
           I64[Sp + 16] = 0;
           P64[Sp + 8] = _cb7F7::P64;
           goto ub7Jo;
       cb7IH: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb72e::P64;
           P64[Hp - 56] = _sb72f::P64;
           I64[Hp - 48] = _sb72d::I64;
           I64[Hp - 40] = _sb72g::I64;
           I64[Hp - 32] = _sb72n::I64;
           I64[Hp - 24] = _sb72i::I64;
           _cb7F5::P64 = Hp - 71;
           Hp = Hp - 24;
           P64[Sp + 8] = _cb7F5::P64;
           I64[Sp + 16] = _sb72i::I64;
           I64[Sp + 24] = _sb72n::I64;
           I64[Sp + 32] = _sb72g::I64;
           P64[Sp + 40] = _sb72f::P64;
           P64[Sp + 48] = _sb72e::P64;
           I64[Sp + 64] = _sb72d::I64;
           goto ub7Jo;
       ub7Jo: // global
           call _cb7FJ() args: 0, res: 0, upd: 0;
       cb7Ik: // global
           I64[Hp - 72] = sat_sb72v_info;
           P64[Hp - 56] = _sb72e::P64;
           P64[Hp - 48] = _sb72f::P64;
           I64[Hp - 40] = _sb72d::I64;
           I64[Hp - 32] = _sb72g::I64;
           I64[Hp - 24] = _sb72i::I64;
           I64[Hp - 16] = _sb72n::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 72;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sb72l::I64;
           R1 = Hp - 7;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7FJ() //  []
         { info_tbl: [(cb7FJ,
                       label: block_cb7FJ_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7FJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cb7In; else goto cb7Im;
       cb7In: // global
           HpAlloc = 72;
           I64[Sp] = block_cb7FJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb7Im: // global
           _sb72z::I64 = I64[Sp + 64];
           _sb72A::P64 = P64[Sp + 48];
           _sb72B::P64 = P64[Sp + 40];
           _sb72C::I64 = I64[Sp + 32];
           _sb72D::I64 = I64[Sp + 24];
           _sb72E::I64 = I64[Sp + 16];
           _sb72F::P64 = P64[Sp + 8];
           if (_sb72D::I64 == _sb72E::I64) goto cb7It; else goto cb7Is;
       cb7It: // global
           I64[Hp - 64] = sat_sb73b_info;
           P64[Hp - 56] = P64[Sp + 72];
           P64[Hp - 48] = _sb72A::P64;
           P64[Hp - 40] = _sb72B::P64;
           P64[Hp - 32] = _sb72F::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = _sb72D::I64;
           I64[Hp] = _sb72E::I64;
           I64[Sp] = block_cb7Hi_info;
           R2 = GHC.IO.Handle.Text.hGetChar3_closure+2;
           R1 = Hp - 63;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cb7Is: // global
           _sb71T::P64 = P64[Sp + 56];
           _sb72J::I64 = %MO_UU_Conv_W32_W64(I32[_sb72z::I64 + (_sb72D::I64 << 2)]);
           call MO_Touch(_sb72A::P64);
           if (_sb72J::I64 == 10) goto cb7Iq; else goto cb7Ip;
       cb7Iq: // global
           I64[Hp - 64] = sat_sb72P_info;
           P64[Hp - 48] = _sb72A::P64;
           P64[Hp - 40] = _sb72B::P64;
           I64[Hp - 32] = _sb72z::I64;
           I64[Hp - 24] = _sb72C::I64;
           I64[Hp - 16] = _sb72D::I64;
           I64[Hp - 8] = _sb72E::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           Hp = Hp - 8;
           R1 = GHC.IO.Handle.Text.hGetChar4_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7Ip: // global
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = _sb72F::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           Hp = Hp - 72;
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7Hi() //  [R1]
         { info_tbl: [(cb7Hi,
                       label: block_cb7Hi_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Hi: // global
           I64[Sp] = block_cb7Hk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub7Jp; else goto cb7Hl;
       ub7Jp: // global
           call _cb7Hk(R1) args: 0, res: 0, upd: 0;
       cb7Hl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Hk() //  [R1]
         { info_tbl: [(cb7Hk,
                       label: block_cb7Hk_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Hk: // global
           _sb71T::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cb7Iy; else goto cb7Iz;
       cb7Iy: // global
           _sb72F::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = _sb72F::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7Iz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb7IC; else goto cb7IB;
       cb7IC: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7IB: // global
           _sb72D::I64 = I64[Sp + 24];
           _sb73h::P64 = P64[R1 + 6];
           _sb73k::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 64] + (_sb72D::I64 << 2)]);
           call MO_Touch(P64[Sp + 48]);
           if (_sb73k::I64 == 10) goto cb7IF; else goto cb7IE;
       cb7IF: // global
           I64[Hp - 24] = sat_sb73x_info;
           P64[Hp - 8] = _sb73h::P64;
           I64[Hp] = _sb72D::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           R1 = GHC.IO.Handle.Text.hGetChar4_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7IE: // global
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = _sb73h::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           Hp = Hp - 32;
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.797221144 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar1_closure" {
     GHC.IO.Handle.Text.hGetChar1_closure:
         const GHC.IO.Handle.Text.hGetChar1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar1_entry() //  [R2]
         { info_tbl: [(cb7Jy,
                       label: GHC.IO.Handle.Text.hGetChar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Jy: // global
           R4 = GHC.IO.Handle.Text.hGetChar2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetChar6_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.79813228 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar_closure" {
     GHC.IO.Handle.Text.hGetChar_closure:
         const GHC.IO.Handle.Text.hGetChar_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar_entry() //  [R2]
         { info_tbl: [(cb7JF,
                       label: GHC.IO.Handle.Text.hGetChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7JF: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.798852988 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf3_closure" {
     GHC.IO.Handle.Text.hGetBuf3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.800789619 UTC

[section ""data" . $wunpack_nl_rb6WF_closure" {
     $wunpack_nl_rb6WF_closure:
         const $wunpack_nl_rb6WF_info;
 },
 $wunpack_nl_rb6WF_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7JJ: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2,
                                        R1) args: 8, res: 0, upd: 8;
     }
 },
 $wunpackRB_sb73Z_entry() //  [R1, R2, R3]
         { info_tbl: [(cb7Ky,
                       label: $wunpackRB_sb73Z_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ky: // global
           _sb741::I64 = R3;
           _sb740::P64 = R2;
           _sb73Z::P64 = R1;
           goto cb7JV;
       cb7JV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb7KC; else goto cb7KB;
       cb7KC: // global
           HpAlloc = 40;
           R3 = _sb741::I64;
           R2 = _sb740::P64;
           R1 = _sb73Z::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb7KB: // global
           _sb73Q::I64 = I64[_sb73Z::P64 + 13];
           if (%MO_S_Ge_W64(_sb741::I64,
                            _sb73Q::I64)) goto cb7Kw; else goto cb7Kx;
       cb7Kw: // global
           _sb73O::I64 = I64[_sb73Z::P64 + 5];
           _sb747::I64 = %MO_UU_Conv_W32_W64(I32[_sb73O::I64 + (_sb741::I64 << 2)]);
           if (_sb747::I64 != 10) goto cb7KE; else goto cb7KL;
       cb7KE: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sb747::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sb740::P64;
           _sb741::I64 = _sb741::I64 - 1;
           _sb740::P64 = Hp - 14;
           goto cb7JV;
       cb7KL: // global
           if (%MO_S_Le_W64(_sb741::I64,
                            _sb73Q::I64)) goto cb7KG; else goto cb7KK;
       cb7KG: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sb740::P64;
           _cb7Kf::P64 = Hp - 30;
           Hp = Hp - 16;
           _sb741::I64 = _sb741::I64 - 1;
           _sb740::P64 = _cb7Kf::P64;
           goto cb7JV;
       cb7KK: // global
           if (I32[_sb73O::I64 + ((_sb741::I64 + -1) << 2)] == 13 :: W32) goto cb7KJ; else goto cb7KI;
       cb7KJ: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sb740::P64;
           _cb7Ku::P64 = Hp - 30;
           Hp = Hp - 16;
           _sb741::I64 = _sb741::I64 - 2;
           _sb740::P64 = _cb7Ku::P64;
           goto cb7JV;
       cb7KI: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sb740::P64;
           _cb7Kp::P64 = Hp - 30;
           Hp = Hp - 16;
           _sb741::I64 = _sb741::I64 - 1;
           _sb740::P64 = _cb7Kp::P64;
           goto cb7JV;
       cb7Kx: // global
           Hp = Hp - 40;
           R1 = _sb740::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wunpack_nl_rb6WF_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb7KP,
                       label: $wunpack_nl_rb6WF_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [True, False, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7KP: // global
           _sb73S::P64 = R6;
           _sb73R::I64 = R5;
           _sb73Q::I64 = R4;
           _sb73P::P64 = R3;
           _sb73O::I64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cb7KQ; else goto cb7KR;
       cb7KR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7KT; else goto cb7KS;
       cb7KT: // global
           HpAlloc = 24;
           goto cb7KQ;
       cb7KQ: // global
           R1 = $wunpack_nl_rb6WF_closure;
           I64[Sp - 40] = _sb73O::I64;
           P64[Sp - 32] = _sb73P::P64;
           I64[Sp - 24] = _sb73Q::I64;
           I64[Sp - 16] = _sb73R::I64;
           P64[Sp - 8] = _sb73S::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cb7KS: // global
           if (_sb73Q::I64 == _sb73R::I64) goto cb7KO; else goto cb7KN;
       cb7KO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb73S::P64;
           P64[Hp] = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7KN: // global
           _sb73Y::I64 = %MO_UU_Conv_W32_W64(I32[_sb73O::I64 + ((_sb73R::I64 + -1) << 2)]);
           I64[Hp - 16] = $wunpackRB_sb73Z_info;
           I64[Hp - 8] = _sb73O::I64;
           I64[Hp] = _sb73Q::I64;
           _cb7JT::P64 = Hp - 13;
           if (_sb73Y::I64 == 13) goto cb7Ll; else goto cb7L5;
       cb7Ll: // global
           I64[Sp - 24] = block_cb7Ld_info;
           R3 = _sb73R::I64 - 2;
           R2 = _sb73S::P64;
           R1 = _cb7JT::P64;
           P64[Sp - 16] = _sb73P::P64;
           I64[Sp - 8] = _sb73R::I64;
           Sp = Sp - 24;
           call $wunpackRB_sb73Z_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       cb7L5: // global
           I64[Sp - 24] = block_cb7KZ_info;
           R3 = _sb73R::I64 - 1;
           R2 = _sb73S::P64;
           R1 = _cb7JT::P64;
           P64[Sp - 16] = _sb73P::P64;
           I64[Sp - 8] = _sb73R::I64;
           Sp = Sp - 24;
           call $wunpackRB_sb73Z_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Ld() //  [R1]
         { info_tbl: [(cb7Ld,
                       label: block_cb7Ld_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ld: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb7Lo; else goto cb7Ln;
       cb7Lo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7Ln: // global
           _sb73R::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sb73R::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7KZ() //  [R1]
         { info_tbl: [(cb7KZ,
                       label: block_cb7KZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7KZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb7L8; else goto cb7L7;
       cb7L8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7L7: // global
           _sb73R::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sb73R::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.8039218 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetContents4_bytes" {
     GHC.IO.Handle.Text.hGetContents4_bytes:
         I8[] [104,71,101,116,67,111,110,116,101,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.804619608 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents3_closure" {
     GHC.IO.Handle.Text.hGetContents3_closure:
         const GHC.IO.Handle.Text.hGetContents3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetContents3_entry() //  [R1]
         { info_tbl: [(cb7Lx,
                       label: GHC.IO.Handle.Text.hGetContents3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Lx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7Ly; else goto cb7Lz;
       cb7Ly: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Lz: // global
           (_cb7Lu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb7Lu::I64 == 0) goto cb7Lw; else goto cb7Lv;
       cb7Lw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb7Lv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb7Lu::I64;
           R2 = GHC.IO.Handle.Text.hGetContents4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.805550876 UTC

[section ""cstring" . lvl3_rb6WG_bytes" {
     lvl3_rb6WG_bytes:
         I8[] [13]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.806239896 UTC

[section ""data" . lvl4_rb6WH_closure" {
     lvl4_rb6WH_closure:
         const lvl4_rb6WH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rb6WH_entry() //  [R1]
         { info_tbl: [(cb7LG,
                       label: lvl4_rb6WH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7LG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7LH; else goto cb7LI;
       cb7LH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7LI: // global
           (_cb7LD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb7LD::I64 == 0) goto cb7LF; else goto cb7LE;
       cb7LF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb7LE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb7LD::I64;
           R2 = lvl3_rb6WG_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.80796302 UTC

[section ""data" . $wlvl_rb6WI_closure" {
     $wlvl_rb6WI_closure:
         const $wlvl_rb6WI_info;
         const 0;
 },
 sat_sb74S_entry() //  [R1]
         { info_tbl: [(cb7LY,
                       label: sat_sb74S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7LY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb7LZ; else goto cb7M0;
       cb7LZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7M0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb7LR_info;
           _sb74E::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sb74E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub7Mr; else goto cb7LS;
       ub7Mr: // global
           call _cb7LR(R1) args: 0, res: 0, upd: 0;
       cb7LS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb7LR() //  [R1]
         { info_tbl: [(cb7LR,
                       label: block_cb7LR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7LR: // global
           if (R1 & 7 == 1) goto cb7LV; else goto cb7LW;
       cb7LV: // global
           _sb74E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb7M3_info;
           R1 = _sb74E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub7Mq; else goto cb7M5;
       ub7Mq: // global
           call _cb7M3(R1) args: 0, res: 0, upd: 0;
       cb7M5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cb7LW: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cb7M3() //  [R1]
         { info_tbl: [(cb7M3,
                       label: block_cb7M3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7M3: // global
           if (R1 & 7 == 1) goto cb7Mb; else goto cb7Mi;
       cb7Mb: // global
           Hp = Hp + 16;
           _sb74L::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb7Ml; else goto cb7Md;
       cb7Md: // global
           _sb74M::P64 = P64[_sb74L::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sb74M::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7Mi: // global
           Hp = Hp + 16;
           _sb74L::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb7Ml; else goto cb7Mk;
       cb7Ml: // global
           HpAlloc = 16;
           R1 = _sb74L::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb7Mk: // global
           _sb74O::P64 = P64[_sb74L::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sb74O::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rb6WI_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb7Mu,
                       label: $wlvl_rb6WI_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Mu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb7My; else goto cb7Mx;
       cb7My: // global
           HpAlloc = 104;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_rb6WI_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb7Mx: // global
           I64[Hp - 96] = sat_sb74S_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = Hp - 96;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.810055052 UTC

[section ""cstring" . lvl5_rb6WJ_bytes" {
     lvl5_rb6WJ_bytes:
         I8[] [100,101,108,97,121,101,100,32,114,101,97,100,32,111,110,32,99,108,111,115,101,100,32,104,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.810832582 UTC

[section ""data" . lvl6_rb6WK_closure" {
     lvl6_rb6WK_closure:
         const lvl6_rb6WK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rb6WK_entry() //  [R1]
         { info_tbl: [(cb7MF,
                       label: lvl6_rb6WK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7MF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7MG; else goto cb7MH;
       cb7MG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7MH: // global
           (_cb7MC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb7MC::I64 == 0) goto cb7ME; else goto cb7MD;
       cb7ME: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb7MD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb7MC::I64;
           R2 = lvl5_rb6WJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.812072773 UTC

[section ""data" . lvl7_rb6WL_closure" {
     lvl7_rb6WL_closure:
         const lvl7_rb6WL_info;
         const 0;
 },
 sat_sb74Y_entry() //  [R1]
         { info_tbl: [(cb7MS,
                       label: sat_sb74Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7MS: // global
           _sb74Y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb7MT; else goto cb7MU;
       cb7MU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cb7MW; else goto cb7MV;
       cb7MW: // global
           HpAlloc = 72;
           goto cb7MT;
       cb7MT: // global
           R1 = _sb74Y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7MV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb74Y::P64;
           _sb74U::P64 = P64[_sb74Y::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sb74U::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = lvl6_rb6WK_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl7_rb6WL_entry() //  [R2]
         { info_tbl: [(cb7MX,
                       label: lvl7_rb6WL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7MX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7N1; else goto cb7N0;
       cb7N1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl7_rb6WL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7N0: // global
           I64[Hp - 16] = sat_sb74Y_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.81587314 UTC

[section ""cstring" . lvl8_rb6WM_bytes" {
     lvl8_rb6WM_bytes:
         I8[] [105,108,108,101,103,97,108,32,104,97,110,100,108,101,32,116,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.81652675 UTC

[section ""data" . lvl9_rb6WN_closure" {
     lvl9_rb6WN_closure:
         const lvl9_rb6WN_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rb6WN_entry() //  [R1]
         { info_tbl: [(cb7N8,
                       label: lvl9_rb6WN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7N8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7N9; else goto cb7Na;
       cb7N9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Na: // global
           (_cb7N5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb7N5::I64 == 0) goto cb7N7; else goto cb7N6;
       cb7N7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb7N6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb7N5::I64;
           R2 = lvl8_rb6WM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.817719561 UTC

[section ""data" . lvl10_rb6WO_closure" {
     lvl10_rb6WO_closure:
         const lvl10_rb6WO_info;
         const 0;
 },
 sat_sb753_entry() //  [R1]
         { info_tbl: [(cb7Nl,
                       label: sat_sb753_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Nl: // global
           _sb753::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb7Nm; else goto cb7Nn;
       cb7Nn: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cb7Np; else goto cb7No;
       cb7Np: // global
           HpAlloc = 72;
           goto cb7Nm;
       cb7Nm: // global
           R1 = _sb753::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7No: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb753::P64;
           _sb74Z::P64 = P64[_sb753::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sb74Z::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = lvl9_rb6WN_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl10_rb6WO_entry() //  [R2]
         { info_tbl: [(cb7Nq,
                       label: lvl10_rb6WO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Nq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7Nu; else goto cb7Nt;
       cb7Nu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl10_rb6WO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7Nt: // global
           I64[Hp - 16] = sat_sb753_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.824216362 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents2_closure" {
     GHC.IO.Handle.Text.hGetContents2_closure:
         const GHC.IO.Handle.Text.hGetContents2_info;
         const 0;
 },
 sat_sb77n_entry() //  [R1]
         { info_tbl: [(cb7Ot,
                       label: sat_sb77n_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ot: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb7Ou; else goto cb7Ov;
       cb7Ou: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Ov: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cb7Or_info;
           _sb754::P64 = P64[R1 + 16];
           _sb75v::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sb754::P64;
           P64[Sp - 24] = _sb75v::P64;
           Sp = Sp - 40;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb7Or() //  [R1]
         { info_tbl: [(cb7Or,
                       label: block_cb7Or_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Or: // global
           I64[Sp - 24] = block_cb7Oy_info;
           _sb77b::P64 = P64[R1 + 31];
           _sb77c::P64 = P64[R1 + 39];
           _sb77d::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _sb77c::P64;
           P64[Sp - 8] = _sb77d::P64;
           P64[Sp] = _sb77b::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub7OX; else goto cb7OA;
       ub7OX: // global
           call _cb7Oy(R1) args: 0, res: 0, upd: 0;
       cb7OA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb7Oy() //  [R1]
         { info_tbl: [(cb7Oy,
                       label: block_cb7Oy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Oy: // global
           if (I32[I64[R1 - 1] + 20] == 4 :: W32) goto cb7OL; else goto cb7OG;
       cb7OL: // global
           _sb75v::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cb7OJ_info;
           R1 = _sb75v::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ub7OY; else goto cb7OM;
       ub7OY: // global
           call _cb7OJ(R1) args: 0, res: 0, upd: 0;
       cb7OM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cb7OG: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 24];
           R3 = R1;
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call $wlvl_rb6WI_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 _cb7OJ() //  [R1]
         { info_tbl: [(cb7OJ,
                       label: block_cb7OJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7OJ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb7OV; else goto cb7OU;
       cb7OV: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7OU: // global
           R1 = lvl4_rb6WH_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb77p_entry() //  [R1, R2]
         { info_tbl: [(cb7OZ,
                       label: sat_sb77p_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7OZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb7P0; else goto cb7P1;
       cb7P0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7P1: // global
           I64[Sp - 32] = block_cb7O2_info;
           _sb754::P64 = P64[R1 + 6];
           _sb75b::P64 = P64[R1 + 14];
           _sb75v::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb754::P64;
           P64[Sp - 16] = _sb75b::P64;
           P64[Sp - 8] = _sb75v::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub7Ph; else goto cb7O3;
       ub7Ph: // global
           call _cb7O2(R1) args: 0, res: 0, upd: 0;
       cb7O3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7O2() //  [R1]
         { info_tbl: [(cb7O2,
                       label: block_cb7O2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7O2: // global
           I64[Sp - 16] = block_cb7O7_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7O7() //  [R1]
         { info_tbl: [(cb7O7,
                       label: block_cb7O7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7O7: // global
           I64[Sp] = block_cb7Ob_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Ob() //  [R1]
         { info_tbl: [(cb7Ob,
                       label: block_cb7Ob_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ob: // global
           if (R1 & 7 == 1) goto cb7P7; else goto cb7Pa;
       cb7P7: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cb7Pa: // global
           I64[Sp] = block_cb7Og_info;
           R2 = P64[Sp + 32];
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Og() //  [R1]
         { info_tbl: [(cb7Og,
                       label: block_cb7Og_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Og: // global
           I64[Sp] = block_cb7Oi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub7Pg; else goto cb7Oj;
       ub7Pg: // global
           call _cb7Oi(R1) args: 0, res: 0, upd: 0;
       cb7Oj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Oi() //  [R1]
         { info_tbl: [(cb7Oi,
                       label: block_cb7Oi_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Oi: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cb7Pe; else goto cb7Pd;
       cb7Pe: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7Pd: // global
           _sb775::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_sb77n_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb775::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb76m_entry() //  [R1]
         { info_tbl: [(cb7Qf,
                       label: sat_sb76m_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Qf: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb7Qg; else goto cb7Qh;
       cb7Qg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Qh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cb7Qc_info;
           _sb75H::P64 = P64[R1 + 16];
           _sb75I::P64 = P64[R1 + 24];
           _sb75G::I64 = I64[R1 + 40];
           _sb75J::I64 = I64[R1 + 48];
           _sb75L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _sb75G::I64;
           P64[Sp - 48] = _sb75H::P64;
           P64[Sp - 40] = _sb75I::P64;
           I64[Sp - 32] = _sb75J::I64;
           I64[Sp - 24] = _sb75L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ub7Qw; else goto cb7Qd;
       ub7Qw: // global
           call _cb7Qc(R1) args: 0, res: 0, upd: 0;
       cb7Qd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb7Qc() //  [R1]
         { info_tbl: [(cb7Qc,
                       label: block_cb7Qc_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Qc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7Qm; else goto cb7Ql;
       cb7Qm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb7Ql: // global
           _sb75G::I64 = I64[Sp + 8];
           _sb75H::P64 = P64[Sp + 16];
           _sb75I::P64 = P64[Sp + 24];
           _sb75J::I64 = I64[Sp + 32];
           _sb75L::I64 = I64[Sp + 40];
           _sb76k::I64 = I64[R1 + 7];
           if (_sb76k::I64 == _sb75L::I64) goto cb7Qv; else goto cb7Qs;
       cb7Qv: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb75H::P64;
           P64[Hp - 32] = _sb75I::P64;
           I64[Hp - 24] = _sb75G::I64;
           I64[Hp - 16] = _sb75J::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7Qs: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb75H::P64;
           P64[Hp - 32] = _sb75I::P64;
           I64[Hp - 24] = _sb75G::I64;
           I64[Hp - 16] = _sb75J::I64;
           I64[Hp - 8] = _sb76k::I64;
           I64[Hp] = _sb75L::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb76T_entry() //  [R1]
         { info_tbl: [(cb7Qx,
                       label: sat_sb76T_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Qx: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cb7Qy; else goto cb7Qz;
       cb7Qy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb7Qz: // global
           I64[Sp - 40] = block_cb7Pn_info;
           _sb754::P64 = P64[R1 + 7];
           _sb75b::P64 = P64[R1 + 15];
           _sb75k::P64 = P64[R1 + 23];
           _sb75p::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sb754::P64;
           P64[Sp - 24] = _sb75b::P64;
           P64[Sp - 16] = _sb75k::P64;
           P64[Sp - 8] = _sb75p::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub7SD; else goto cb7Po;
       ub7SD: // global
           call _cb7Pn(R1) args: 0, res: 0, upd: 0;
       cb7Po: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Pn() //  [R1]
         { info_tbl: [(cb7Pn,
                       label: block_cb7Pn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Pn: // global
           _sb75C::I64 = I64[R1 + 39];
           _sb75D::I64 = I64[R1 + 47];
           _sb76p::I64 = _sb75D::I64 - _sb75C::I64;
           if (_sb76p::I64 == 0) goto cb7Rz; else goto ub7Sl;
       cb7Rz: // global
           I64[Sp] = block_cb7Rw_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       ub7Sl: // global
           _sb75z::P64 = P64[R1 + 7];
           _sb75A::P64 = P64[R1 + 15];
           _sb75y::I64 = I64[R1 + 23];
           _sb75B::I64 = I64[R1 + 31];
           if (_sb76p::I64 != 1) goto ub7Sm; else goto cb7RM;
       ub7Sm: // global
           P64[Sp - 40] = _sb75z::P64;
           P64[Sp - 32] = _sb75A::P64;
           I64[Sp - 24] = _sb75B::I64;
           I64[Sp - 16] = _sb75C::I64;
           I64[Sp - 8] = _sb75D::I64;
           I64[Sp] = _sb75y::I64;
           Sp = Sp - 40;
           call _cb7RU() args: 0, res: 0, upd: 0;
       cb7RM: // global
           I64[Sp - 48] = block_cb7RL_info;
           R1 = P64[Sp + 32];
           P64[Sp - 40] = _sb75z::P64;
           P64[Sp - 32] = _sb75A::P64;
           I64[Sp - 24] = _sb75B::I64;
           I64[Sp - 16] = _sb75C::I64;
           I64[Sp - 8] = _sb75D::I64;
           I64[Sp] = _sb75y::I64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ub7Sw; else goto cb7RO;
       ub7Sw: // global
           call _cb7RL(R1) args: 0, res: 0, upd: 0;
       cb7RO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Rw() //  [R1]
         { info_tbl: [(cb7Rw,
                       label: block_cb7Rw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Rw: // global
           I64[Sp] = block_cb7Ry_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub7SF; else goto cb7RC;
       ub7SF: // global
           call _cb7Ry(R1) args: 0, res: 0, upd: 0;
       cb7RC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Ry() //  [R1]
         { info_tbl: [(cb7Ry,
                       label: block_cb7Ry_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ry: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 32] = I64[R1 + 39];
           I64[Sp - 40] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _cb7RL() //  [R1]
         { info_tbl: [(cb7RL,
                       label: block_cb7RL_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7RL: // global
           if (R1 & 7 == 1) goto ub7Sn; else goto cb7RV;
       ub7Sn: // global
           Sp = Sp + 8;
           call _cb7RU() args: 0, res: 0, upd: 0;
       cb7RV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7S0; else goto cb7RZ;
       cb7S0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7RZ: // global
           _sb75b::P64 = P64[Sp + 64];
           _sb75y::I64 = I64[Sp + 48];
           _sb75z::P64 = P64[Sp + 8];
           _sb75A::P64 = P64[Sp + 16];
           _sb75B::I64 = I64[Sp + 24];
           _sb75C::I64 = I64[Sp + 32];
           _sb75D::I64 = I64[Sp + 40];
           _sb76D::I64 = %MO_UU_Conv_W32_W64(I32[_sb75y::I64 + (_sb75C::I64 << 2)]);
           call MO_Touch(_sb75z::P64);
           if (_sb76D::I64 == 13) goto cb7Sc; else goto cb7S4;
       cb7Sc: // global
           I32[_sb75y::I64] = 13 :: W32;
           call MO_Touch(_sb75z::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb75z::P64;
           P64[Hp - 32] = _sb75A::P64;
           I64[Hp - 24] = _sb75y::I64;
           I64[Hp - 16] = _sb75B::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 48] = block_cb7S9_info;
           R3 = Hp - 47;
           R2 = _sb75b::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb7S4: // global
           Hp = Hp - 56;
           I64[Sp + 8] = _sb75D::I64;
           I64[Sp + 16] = _sb75C::I64;
           I64[Sp + 24] = _sb75B::I64;
           P64[Sp + 32] = _sb75A::P64;
           P64[Sp + 40] = _sb75z::P64;
           I64[Sp + 48] = _sb75y::I64;
           Sp = Sp + 8;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _cb7RU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7RU: // global
           I64[Sp + 40] = I64[Sp + 40];
           _sb75L::I64 = I64[Sp + 32];
           P64[Sp + 32] = P64[Sp];
           _sb75K::I64 = I64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 8] = _sb75K::I64;
           I64[Sp] = _sb75L::I64;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _cb7S9() //  [R1]
         { info_tbl: [(cb7S9,
                       label: block_cb7S9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7S9: // global
           I64[Sp] = block_cb7Sb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub7SK; else goto cb7Se;
       ub7SK: // global
           call _cb7Sb(R1) args: 0, res: 0, upd: 0;
       cb7Se: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Sb() //  [R1]
         { info_tbl: [(cb7Sb,
                       label: block_cb7Sb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Sb: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 32] = I64[R1 + 39];
           I64[Sp - 40] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _sb75E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb75E: // global
           I64[Sp - 8] = block_cb7Px_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.hGetContents2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Px() //  [R1]
         { info_tbl: [(cb7Px,
                       label: block_cb7Px_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Px: // global
           I64[Sp] = block_cb7Pz_info;
           _sb75O::P64 = R1;
           R1 = P64[Sp + 80];
           P64[Sp + 80] = _sb75O::P64;
           if (R1 & 7 != 0) goto ub7Sy; else goto cb7PA;
       ub7Sy: // global
           call _cb7Pz(R1) args: 0, res: 0, upd: 0;
       cb7PA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Pz() //  [R1]
         { info_tbl: [(cb7Pz,
                       label: block_cb7Pz_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Pz: // global
           _sb75G::I64 = I64[Sp + 48];
           _sb75H::P64 = P64[Sp + 40];
           _sb75K::I64 = I64[Sp + 16];
           _sb75L::I64 = I64[Sp + 8];
           _sb75O::P64 = P64[Sp + 80];
           if (R1 & 7 == 1) goto cb7QE; else goto cb7Re;
       cb7QE: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cb7QH; else goto cb7QG;
       cb7QH: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7QG: // global
           if (_sb75K::I64 == _sb75L::I64) goto cb7R8; else goto cb7R1;
       cb7R8: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb75H::P64;
           P64[Hp - 56] = P64[Sp + 32];
           I64[Hp - 48] = _sb75G::I64;
           I64[Hp - 40] = I64[Sp + 24];
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           _sb75b::P64 = P64[Sp + 64];
           _sb75k::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb75k::P64 + 8] = Hp - 71;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb75k::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb75b::P64;
           P64[Hp] = _sb75O::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7R1: // global
           Hp = Hp - 80;
           I64[Sp + 56] = _sb75L::I64 - 1;
           P64[Sp + 80] = _sb75O::P64;
           Sp = Sp + 8;
           call _cb7PO() args: 0, res: 0, upd: 0;
       cb7Re: // global
           I64[Sp] = block_cb7Q1_info;
           R6 = _sb75O::P64;
           R5 = _sb75L::I64;
           R4 = _sb75K::I64;
           R3 = _sb75H::P64;
           R2 = _sb75G::I64;
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7PO() //  []
         { info_tbl: [(cb7PO,
                       label: block_cb7PO_info
                       rep:StackRep [True, True, False, False, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7PO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb7QW; else goto cb7QV;
       cb7QW: // global
           HpAlloc = 40;
           I64[Sp] = block_cb7PO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb7QV: // global
           _sb75Z::P64 = P64[Sp + 72];
           _sb760::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_sb760::I64,
                            I64[Sp + 8])) goto cb7QY; else goto cb7QZ;
       cb7QY: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 40] + (_sb760::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sb75Z::P64;
           P64[Sp + 72] = Hp - 14;
           I64[Sp + 48] = _sb760::I64 - 1;
           call _cb7PO() args: 0, res: 0, upd: 0;
       cb7QZ: // global
           Hp = Hp - 40;
           P64[Sp + 72] = _sb75Z::P64;
           Sp = Sp + 16;
           call _cb7QJ() args: 0, res: 0, upd: 0;
     }
 },
 _cb7QJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7QJ: // global
           Hp = Hp + 80;
           _sb75T::P64 = P64[Sp + 56];
           if (Hp > HpLim) (likely: False) goto cb7QT; else goto cb7QS;
       cb7QT: // global
           HpAlloc = 80;
           I64[Sp - 8] = block_cb7QI_info;
           R1 = _sb75T::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7QS: // global
           _sb75b::P64 = P64[Sp + 40];
           _sb75k::P64 = P64[Sp + 48];
           _sb75G::I64 = I64[Sp + 24];
           _sb75H::P64 = P64[Sp + 16];
           _sb75I::P64 = P64[Sp + 8];
           _sb75J::I64 = I64[Sp];
           call MO_Touch(_sb75H::P64);
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb75H::P64;
           P64[Hp - 56] = _sb75I::P64;
           I64[Hp - 48] = _sb75G::I64;
           I64[Hp - 40] = _sb75J::I64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           call MO_WriteBarrier();
           P64[_sb75k::P64 + 8] = Hp - 71;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb75k::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb75b::P64;
           P64[Hp] = _sb75T::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7QI() //  [R1]
         { info_tbl: [(cb7QI,
                       label: block_cb7QI_info
                       rep:StackRep [True, False, False, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7QI: // global
           P64[Sp + 64] = R1;
           Sp = Sp + 8;
           call _cb7QJ() args: 0, res: 0, upd: 0;
     }
 },
 _cb7Q1() //  [R1]
         { info_tbl: [(cb7Q1,
                       label: block_cb7Q1_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Q1: // global
           I64[Sp] = block_cb7Q3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub7SC; else goto cb7Q4;
       ub7SC: // global
           call _cb7Q3(R1) args: 0, res: 0, upd: 0;
       cb7Q4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Q3() //  [R1]
         { info_tbl: [(cb7Q3,
                       label: block_cb7Q3_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Q3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cb7Ri; else goto cb7Rh;
       cb7Ri: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7Rh: // global
           _sb76h::P64 = P64[R1 + 7];
           _sb76i::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sb76m_info;
           P64[Hp - 64] = P64[Sp + 40];
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sb76i::P64;
           I64[Hp - 40] = I64[Sp + 48];
           I64[Hp - 32] = I64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           _sb75b::P64 = P64[Sp + 64];
           _sb75k::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb75k::P64 + 8] = Hp - 80;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb75k::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb75b::P64;
           P64[Hp] = _sb76h::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 act_sb758_entry() //  [R1, R2]
         { info_tbl: [(cb7SM,
                       label: act_sb758_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7SM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb7SN; else goto cb7SO;
       cb7SN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7SO: // global
           I64[Sp - 16] = block_cb7NL_info;
           _sb754::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sb754::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub7T4; else goto cb7NM;
       ub7T4: // global
           call _cb7NL(R1) args: 0, res: 0, upd: 0;
       cb7NM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7NL() //  [R1]
         { info_tbl: [(cb7NL,
                       label: block_cb7NL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7NL: // global
           I64[Sp - 24] = block_cb7NQ_info;
           _sb75b::P64 = R1;
           _sb75k::P64 = P64[R1 + 71];
           _sb75p::P64 = P64[R1 + 111];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sb75k::P64;
           P64[Sp - 8] = _sb75p::P64;
           P64[Sp] = _sb75b::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub7T3; else goto cb7NR;
       ub7T3: // global
           call _cb7NQ(R1) args: 0, res: 0, upd: 0;
       cb7NR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7NQ() //  [R1]
         { info_tbl: [(cb7NQ,
                       label: block_cb7NQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7NQ: // global
           _sb754::P64 = P64[Sp + 32];
           _cb7T1::P64 = R1 & 7;
           if (_cb7T1::P64 == 1) goto cb7SW; else goto ub7T2;
       cb7SW: // global
           R2 = _sb754::P64;
           Sp = Sp + 40;
           call lvl7_rb6WL_entry(R2) args: 8, res: 0, upd: 8;
       ub7T2: // global
           if (_cb7T1::P64 == 2) goto cb7SX; else goto cb7ST;
       cb7SX: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cb7T0; else goto cb7SZ;
       cb7T0: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7SZ: // global
           _sb75k::P64 = P64[Sp + 8];
           _sb75v::P64 = P64[_sb75k::P64 + 8];
           I64[Hp - 72] = sat_sb77p_info;
           P64[Hp - 64] = _sb754::P64;
           _sb75b::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sb75b::P64;
           P64[Hp - 48] = _sb75v::P64;
           I64[Hp - 40] = sat_sb76T_info;
           P64[Hp - 32] = _sb754::P64;
           P64[Hp - 24] = _sb75b::P64;
           P64[Hp - 16] = _sb75k::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sb75v::P64;
           R2 = Hp - 70;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       cb7ST: // global
           R2 = _sb754::P64;
           Sp = Sp + 40;
           call lvl10_rb6WO_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb77w_entry() //  [R1]
         { info_tbl: [(cb7Tc,
                       label: sat_sb77w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Tc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7Td; else goto cb7Te;
       cb7Td: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb7Te: // global
           I64[Sp - 16] = block_cb7NE_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cb7NE() //  []
         { info_tbl: [(cb7NE,
                       label: block_cb7NE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7NE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7Th; else goto cb7Tg;
       cb7Th: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb7Tg: // global
           I64[Hp - 8] = act_sb758_info;
           _sb754::P64 = P64[Sp + 8];
           P64[Hp] = _sb754::P64;
           I64[Sp] = block_cb7T5_info;
           R1 = _sb754::P64;
           P64[Sp + 8] = Hp - 6;
           if (R1 & 7 != 0) goto ub7To; else goto cb7T6;
       ub7To: // global
           call _cb7T5(R1) args: 0, res: 0, upd: 0;
       cb7T6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7T5() //  [R1]
         { info_tbl: [(cb7T5,
                       label: block_cb7T5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7T5: // global
           _cb7NG::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cb7T9; else goto cb7Ta;
       cb7T9: // global
           R5 = _cb7NG::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cb7Ta: // global
           R5 = _cb7NG::P64;
           R4 = P64[R1 + 14];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.hGetContents2_entry() //  [R2]
         { info_tbl: [(cb7Tp,
                       label: GHC.IO.Handle.Text.hGetContents2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Tp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7Tt; else goto cb7Ts;
       cb7Tt: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetContents2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7Ts: // global
           I64[Hp - 8] = sat_sb77w_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.835977938 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents1_closure" {
     GHC.IO.Handle.Text.hGetContents1_closure:
         const GHC.IO.Handle.Text.hGetContents1_info;
         const 0;
 },
 sat_sb77V_entry() //  [R1]
         { info_tbl: [(cb7TM,
                       label: sat_sb77V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7TM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb7TQ; else goto cb7TR;
       cb7TQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7TR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb7TJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub7TV; else goto cb7TK;
       ub7TV: // global
           call _cb7TJ(R1) args: 0, res: 0, upd: 0;
       cb7TK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb7TJ() //  [R1]
         { info_tbl: [(cb7TJ,
                       label: block_cb7TJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7TJ: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cb7TU; else goto cb7TT;
       cb7TU: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb7TT: // global
           _sb77F::P64 = P64[R1 + 7];
           _sb77G::P64 = P64[R1 + 15];
           _sb77H::P64 = P64[R1 + 23];
           _sb77I::P64 = P64[R1 + 31];
           _sb77K::P64 = P64[R1 + 47];
           _sb77L::P64 = P64[R1 + 55];
           _sb77M::P64 = P64[R1 + 63];
           _sb77N::P64 = P64[R1 + 71];
           _sb77O::P64 = P64[R1 + 79];
           _sb77P::P64 = P64[R1 + 87];
           _sb77Q::P64 = P64[R1 + 95];
           _sb77R::P64 = P64[R1 + 103];
           _sb77S::P64 = P64[R1 + 111];
           _sb77T::P64 = P64[R1 + 119];
           _sb77U::P64 = P64[R1 + 127];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sb77F::P64;
           P64[Hp - 112] = _sb77G::P64;
           P64[Hp - 104] = _sb77H::P64;
           P64[Hp - 96] = _sb77I::P64;
           P64[Hp - 88] = GHC.IO.Handle.Types.SemiClosedHandle_closure+2;
           P64[Hp - 80] = _sb77K::P64;
           P64[Hp - 72] = _sb77L::P64;
           P64[Hp - 64] = _sb77M::P64;
           P64[Hp - 56] = _sb77N::P64;
           P64[Hp - 48] = _sb77O::P64;
           P64[Hp - 40] = _sb77P::P64;
           P64[Hp - 32] = _sb77Q::P64;
           P64[Hp - 24] = _sb77R::P64;
           P64[Hp - 16] = _sb77S::P64;
           P64[Hp - 8] = _sb77T::P64;
           P64[Hp] = _sb77U::P64;
           R1 = Hp - 127;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb77X_entry() //  [R1, R2]
         { info_tbl: [(cb7TX,
                       label: sat_sb77X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7TX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7TY; else goto cb7TZ;
       cb7TY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7TZ: // global
           I64[Sp - 16] = block_cb7TD_info;
           _sb77z::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sb77z::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Text.hGetContents2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7TD() //  [R1]
         { info_tbl: [(cb7TD,
                       label: block_cb7TD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7TD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb7U2; else goto cb7U1;
       cb7U2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7U1: // global
           I64[Hp - 40] = sat_sb77V_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.hGetContents1_entry() //  [R2]
         { info_tbl: [(cb7U3,
                       label: GHC.IO.Handle.Text.hGetContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7U3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7U7; else goto cb7U6;
       cb7U7: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7U6: // global
           I64[Hp - 8] = sat_sb77X_info;
           P64[Hp] = R2;
           R4 = Hp - 6;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.838378945 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents_closure" {
     GHC.IO.Handle.Text.hGetContents_closure:
         const GHC.IO.Handle.Text.hGetContents_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetContents_entry() //  [R2]
         { info_tbl: [(cb7Uc,
                       label: GHC.IO.Handle.Text.hGetContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Uc: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.839469643 UTC

[section ""data" . go_rb6WP_closure" {
     go_rb6WP_closure:
         const go_rb6WP_info;
 },
 sat_sb782_entry() //  [R1]
         { info_tbl: [(cb7Ut,
                       label: sat_sb782_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ut: // global
           R2 = P64[R1 + 16];
           call go_rb6WP_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 go_rb6WP_entry() //  [R2]
         { info_tbl: [(cb7UA,
                       label: go_rb6WP_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7UA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb7UB; else goto cb7UC;
       cb7UB: // global
           R2 = R2;
           R1 = go_rb6WP_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7UC: // global
           I64[Sp - 8] = block_cb7Uj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub7UI; else goto cb7Uk;
       ub7UI: // global
           call _cb7Uj(R1) args: 0, res: 0, upd: 0;
       cb7Uk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Uj() //  [R1]
         { info_tbl: [(cb7Uj,
                       label: block_cb7Uj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Uj: // global
           if (R1 & 7 == 1) goto cb7Ux; else goto cb7Uy;
       cb7Ux: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7Uy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7UH; else goto cb7UG;
       cb7UH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7UG: // global
           _sb780::P64 = P64[R1 + 6];
           _sb781::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sb782_info;
           P64[Hp] = _sb781::P64;
           R3 = Hp - 16;
           R2 = _sb780::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.841137805 UTC

[section ""data" . go1_rb6WQ_closure" {
     go1_rb6WQ_closure:
         const go1_rb6WQ_info;
 },
 sat_sb787_entry() //  [R1]
         { info_tbl: [(cb7UX,
                       label: sat_sb787_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7UX: // global
           R2 = P64[R1 + 16];
           call go1_rb6WQ_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 go1_rb6WQ_entry() //  [R2]
         { info_tbl: [(cb7V4,
                       label: go1_rb6WQ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7V4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb7V5; else goto cb7V6;
       cb7V5: // global
           R2 = R2;
           R1 = go1_rb6WQ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb7V6: // global
           I64[Sp - 8] = block_cb7UN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub7Vc; else goto cb7UO;
       ub7Vc: // global
           call _cb7UN(R1) args: 0, res: 0, upd: 0;
       cb7UO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7UN() //  [R1]
         { info_tbl: [(cb7UN,
                       label: block_cb7UN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7UN: // global
           if (R1 & 7 == 1) goto cb7V1; else goto cb7V2;
       cb7V1: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7V2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7Vb; else goto cb7Va;
       cb7Vb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7Va: // global
           _sb785::P64 = P64[R1 + 6];
           _sb786::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sb787_info;
           P64[Hp] = _sb786::P64;
           R3 = Hp - 16;
           R2 = _sb785::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.848486207 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure" {
     GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure:
         const GHC.IO.Handle.Text.$whGetLineBufferedLoop_info;
         const 0;
 },
 GHC.IO.Handle.Text.$whGetLineBufferedLoop_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Ve: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 buf1_sb78H_entry() //  [R1]
         { info_tbl: [(cb7Wx,
                       label: buf1_sb78H_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Wx: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb7Wy; else goto cb7Wz;
       cb7Wy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Wz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cb7Wu_info;
           _sb78a::P64 = P64[R1 + 16];
           _sb78b::P64 = P64[R1 + 24];
           _sb789::I64 = I64[R1 + 40];
           _sb78c::I64 = I64[R1 + 48];
           _sb78e::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _sb789::I64;
           P64[Sp - 48] = _sb78a::P64;
           P64[Sp - 40] = _sb78b::P64;
           I64[Sp - 32] = _sb78c::I64;
           I64[Sp - 24] = _sb78e::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ub7WO; else goto cb7Wv;
       ub7WO: // global
           call _cb7Wu(R1) args: 0, res: 0, upd: 0;
       cb7Wv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb7Wu() //  [R1]
         { info_tbl: [(cb7Wu,
                       label: block_cb7Wu_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Wu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7WE; else goto cb7WD;
       cb7WE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb7WD: // global
           _sb789::I64 = I64[Sp + 8];
           _sb78a::P64 = P64[Sp + 16];
           _sb78b::P64 = P64[Sp + 24];
           _sb78c::I64 = I64[Sp + 32];
           _sb78e::I64 = I64[Sp + 40];
           _sb78J::I64 = I64[R1 + 7];
           if (_sb78J::I64 == _sb78e::I64) goto cb7WN; else goto cb7WK;
       cb7WN: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7WK: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = _sb78J::I64;
           I64[Hp] = _sb78e::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79e_entry() //  [R1]
         { info_tbl: [(cb7WV,
                       label: sat_sb79e_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7WV: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb7WW; else goto cb7WX;
       cb7WW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb7WX: // global
           I64[Sp - 24] = block_cb7WS_info;
           _sb78h::P64 = P64[R1 + 7];
           _sb78v::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _sb78h::P64;
           P64[Sp - 8] = _sb78v::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub7Y8; else goto cb7WT;
       ub7Y8: // global
           call _cb7WS(R1) args: 0, res: 0, upd: 0;
       cb7WT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7WS() //  [R1]
         { info_tbl: [(cb7WS,
                       label: block_cb7WS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7WS: // global
           _sb78R::I64 = I64[R1 + 39];
           _sb78T::I64 = I64[R1 + 47] - _sb78R::I64;
           if (_sb78T::I64 == 0) goto cb7Xk; else goto ub7Y3;
       cb7Xk: // global
           I64[Sp + 16] = block_cb7Xh_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       ub7Y3: // global
           if (_sb78T::I64 == 1) goto cb7Xu; else goto ub7Y4;
       cb7Xu: // global
           I64[Sp - 40] = block_cb7Xt_info;
           _sb78M::P64 = R1;
           _sb78O::P64 = P64[R1 + 7];
           _sb78P::P64 = P64[R1 + 15];
           _sb78N::I64 = I64[R1 + 23];
           _sb78Q::I64 = I64[R1 + 31];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _sb78O::P64;
           P64[Sp - 24] = _sb78P::P64;
           I64[Sp - 16] = _sb78Q::I64;
           I64[Sp - 8] = _sb78R::I64;
           I64[Sp] = _sb78N::I64;
           P64[Sp + 16] = _sb78M::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub7Y6; else goto cb7Xw;
       ub7Y6: // global
           call _cb7Xt(R1) args: 0, res: 0, upd: 0;
       cb7Xw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub7Y4: // global
           I64[Sp + 8] = _sb78T::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb7X5() args: 0, res: 0, upd: 0;
     }
 },
 _cb7Xh() //  [R1]
         { info_tbl: [(cb7Xh,
                       label: block_cb7Xh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Xh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7Xo; else goto cb7Xn;
       cb7Xo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7Xn: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7Xt() //  [R1]
         { info_tbl: [(cb7Xt,
                       label: block_cb7Xt_info
                       rep:StackRep [False, False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Xt: // global
           _sb78M::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cb7XC; else goto cb7XG;
       cb7XC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7XF; else goto cb7XE;
       cb7XF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7XE: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sb78M::P64;
           R1 = Hp - 6;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb7XG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7XL; else goto cb7XK;
       cb7XL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7XK: // global
           _sb78h::P64 = P64[Sp + 48];
           _sb78N::I64 = I64[Sp + 40];
           _sb78O::P64 = P64[Sp + 8];
           _sb78P::P64 = P64[Sp + 16];
           _sb78Q::I64 = I64[Sp + 24];
           _sb793::I64 = %MO_UU_Conv_W32_W64(I32[_sb78N::I64 + (I64[Sp + 32] << 2)]);
           call MO_Touch(_sb78O::P64);
           if (_sb793::I64 == 13) goto cb7XY; else goto cb7XR;
       cb7XY: // global
           I32[_sb78N::I64] = 13 :: W32;
           call MO_Touch(_sb78O::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78O::P64;
           P64[Hp - 32] = _sb78P::P64;
           I64[Hp - 24] = _sb78N::I64;
           I64[Hp - 16] = _sb78Q::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 56] = block_cb7XV_info;
           R3 = Hp - 47;
           R2 = _sb78h::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb7XR: // global
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = _sb78M::P64;
           _cb7XP::P64 = Hp - 46;
           Hp = Hp - 40;
           R1 = _cb7XP::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7XV() //  [R1]
         { info_tbl: [(cb7XV,
                       label: block_cb7XV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7XV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7Y1; else goto cb7Y0;
       cb7Y1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7Y0: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7X5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7X5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7Xc; else goto cb7Xb;
       cb7Xc: // global
           HpAlloc = 16;
           _sb78T::I64 = I64[Sp];
           I64[Sp] = block_cb7X4_info;
           R1 = _sb78T::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb7Xb: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7X4() //  [R1]
         { info_tbl: [(cb7X4,
                       label: block_cb7X4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7X4: // global
           I64[Sp] = R1;
           call _cb7X5() args: 0, res: 0, upd: 0;
     }
 },
 sat_sb79q_entry() //  [R1]
         { info_tbl: [(cb7Yi,
                       label: sat_sb79q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Yi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb7Ym; else goto cb7Yn;
       cb7Ym: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Yn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb7Yf_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub7Yr; else goto cb7Yg;
       ub7Yr: // global
           call _cb7Yf(R1) args: 0, res: 0, upd: 0;
       cb7Yg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb7Yf() //  [R1]
         { info_tbl: [(cb7Yf,
                       label: block_cb7Yf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Yf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7Yq; else goto cb7Yp;
       cb7Yq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb7Yp: // global
           _sb79l::P64 = P64[R1 + 7];
           _sb79m::P64 = P64[R1 + 15];
           _sb79k::I64 = I64[R1 + 23];
           _sb79n::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb79l::P64;
           P64[Hp - 32] = _sb79m::P64;
           I64[Hp - 24] = _sb79k::I64;
           I64[Hp - 16] = _sb79n::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79A_entry() //  [R1]
         { info_tbl: [(cb7YD,
                       label: sat_sb79A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7YD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb7YE; else goto cb7YF;
       cb7YE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7YF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb7YA_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub7YO; else goto cb7YB;
       ub7YO: // global
           call _cb7YA(R1) args: 0, res: 0, upd: 0;
       cb7YB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb7YA() //  [R1]
         { info_tbl: [(cb7YA,
                       label: block_cb7YA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7YA: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb7YN; else goto cb7YM;
       cb7YN: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7YM: // global
           R1 = lvl4_rb6WH_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79S_entry() //  [R1]
         { info_tbl: [(cb7YX,
                       label: sat_sb79S_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7YX: // global
           _sb79S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb7YY; else goto cb7YZ;
       cb7YZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb7Z1; else goto cb7Z0;
       cb7Z1: // global
           HpAlloc = 56;
           goto cb7YY;
       cb7YY: // global
           R1 = _sb79S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Z0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb79S::P64;
           _sb78a::P64 = P64[_sb79S::P64 + 16];
           _sb78b::P64 = P64[_sb79S::P64 + 24];
           _sb789::I64 = I64[_sb79S::P64 + 32];
           _sb78c::I64 = I64[_sb79S::P64 + 40];
           _sb78e::I64 = I64[_sb79S::P64 + 48];
           _sb79Q::I64 = I64[_sb79S::P64 + 56] + 1;
           if (_sb79Q::I64 == _sb78e::I64) goto cb7Zb; else goto cb7Z8;
       cb7Zb: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb7Z8: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = _sb79Q::I64;
           I64[Hp] = _sb78e::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79W_entry() //  [R1]
         { info_tbl: [(cb7Zm,
                       label: sat_sb79W_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Zm: // global
           _sb79W::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cb7Zn; else goto cb7Zo;
       cb7Zo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7Zq; else goto cb7Zp;
       cb7Zq: // global
           HpAlloc = 24;
           goto cb7Zn;
       cb7Zn: // global
           R1 = _sb79W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb7Zp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb79W::P64;
           _sb78f::P64 = P64[_sb79W::P64 + 16];
           _sb78E::P64 = P64[_sb79W::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sb78E::P64;
           P64[Hp] = _sb78f::P64;
           I64[Sp - 24] = block_cb7Zk_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb7Zk() //  [R1]
         { info_tbl: [(cb7Zk,
                       label: block_cb7Zk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Zk: // global
           R2 = R1;
           Sp = Sp + 8;
           call go_rb6WP_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cb7Zu,
                       label: GHC.IO.Handle.Text.$whGetLineBufferedLoop_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Zu: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb7Zv; else goto ub81m;
       cb7Zv: // global
           R1 = GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ub81m: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cb7Vf() args: 0, res: 0, upd: 0;
     }
 },
 _cb7Vf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Vf: // global
           _sb788::P64 = P64[Sp];
           I64[Sp] = block_cb7Vi_info;
           R1 = _sb788::P64;
           if (R1 & 7 != 0) goto ub81z; else goto cb7Vj;
       ub81z: // global
           call _cb7Vi(R1) args: 0, res: 0, upd: 0;
       cb7Vj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Vi() //  [R1]
         { info_tbl: [(cb7Vi,
                       label: block_cb7Vi_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Vi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb7Zz; else goto cb7Zy;
       cb7Zz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7Zy: // global
           _sb78q::P64 = P64[R1 + 71];
           _sb78v::P64 = P64[R1 + 111];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           P64[Sp - 32] = _sb78q::P64;
           P64[Sp - 24] = _sb78v::P64;
           P64[Sp - 16] = Hp - 15;
           I64[Sp - 8] = I64[Sp + 40];
           P64[Sp] = R1;
           Sp = Sp - 32;
           call _cb80V() args: 0, res: 0, upd: 0;
     }
 },
 _cb80V() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb80V: // global
           _sb78e::I64 = I64[Sp + 80];
           if (I64[Sp + 24] == _sb78e::I64) goto cb81f; else goto cb814;
       cb81f: // global
           P64[Sp + 24] = GHC.Types.False_closure+1;
           I64[Sp + 16] = _sb78e::I64;
           call _sb78y() args: 0, res: 0, upd: 0;
       cb814: // global
           I64[Sp - 8] = block_cb812_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub81N; else goto cb815;
       ub81N: // global
           call _cb812(R1) args: 0, res: 0, upd: 0;
       cb815: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb812() //  [R1]
         { info_tbl: [(cb812,
                       label: block_cb812_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb812: // global
           _sb7au::I64 = I64[Sp + 32];
           _sb7aC::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 15] + (_sb7au::I64 << 2)]);
           call MO_Touch(P64[R1 + 7]);
           if (_sb7aC::I64 == 10) goto cb81e; else goto cb81d;
       cb81e: // global
           I64[Sp + 24] = _sb7au::I64;
           P64[Sp + 32] = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call _sb78y() args: 0, res: 0, upd: 0;
       cb81d: // global
           P64[Sp + 24] = R1;
           I64[Sp + 32] = _sb7au::I64 + 1;
           Sp = Sp + 8;
           call _cb80V() args: 0, res: 0, upd: 0;
     }
 },
 _sb78y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb78y: // global
           I64[Sp - 8] = block_cb7Vv_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub81R; else goto cb7Vw;
       ub81R: // global
           call _cb7Vv(R1) args: 0, res: 0, upd: 0;
       cb7Vw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Vv() //  [R1]
         { info_tbl: [(cb7Vv,
                       label: block_cb7Vv_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Vv: // global
           _sb78d::I64 = I64[Sp + 80];
           _sb78B::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cb80e; else goto cb80A;
       cb80e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb80h; else goto cb80g;
       cb80h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb80g: // global
           if (_sb78d::I64 == _sb78B::I64) goto cb80t; else goto cb80s;
       cb80t: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb78B::I64;
           P64[Sp + 80] = GHC.Types.[]_closure+1;
           P64[Sp] = Hp - 7;
           call _sb78C() args: 0, res: 0, upd: 0;
       cb80s: // global
           Hp = Hp - 16;
           I64[Sp - 8] = _sb78B::I64 - 1;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call _cb7Wh() args: 0, res: 0, upd: 0;
       cb80A: // global
           I64[Sp] = block_cb80w_info;
           R6 = GHC.Types.[]_closure+1;
           R5 = _sb78B::I64;
           R4 = _sb78d::I64;
           R3 = P64[Sp + 56];
           R2 = I64[Sp + 48];
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7Wh() //  []
         { info_tbl: [(cb7Wh,
                       label: block_cb7Wh_info
                       rep:StackRep [True, False, False, False, True, False, False, True,
                                     False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Wh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb80n; else goto cb80m;
       cb80n: // global
           HpAlloc = 40;
           I64[Sp] = block_cb7Wh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb80m: // global
           _sb7a5::P64 = P64[Sp + 16];
           _sb7a6::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_sb7a6::I64,
                            I64[Sp + 96])) goto cb80p; else goto cb80q;
       cb80p: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 64] + (_sb7a6::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sb7a5::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 8] = _sb7a6::I64 - 1;
           call _cb7Wh() args: 0, res: 0, upd: 0;
       cb80q: // global
           Hp = Hp - 40;
           P64[Sp + 96] = _sb7a5::P64;
           Sp = Sp + 24;
           call _cb7Wb() args: 0, res: 0, upd: 0;
     }
 },
 _cb7Wb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Wb: // global
           Hp = Hp + 16;
           _sb7a1::P64 = P64[Sp + 72];
           if (Hp > HpLim) (likely: False) goto cb80k; else goto cb80j;
       cb80k: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb7Wa_info;
           R1 = _sb7a1::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb80j: // global
           _sb78B::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 48]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb78B::I64;
           P64[Sp + 72] = _sb7a1::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 8;
           call _sb78C() args: 0, res: 0, upd: 0;
     }
 },
 _cb7Wa() //  [R1]
         { info_tbl: [(cb7Wa,
                       label: block_cb7Wa_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Wa: // global
           P64[Sp + 80] = R1;
           Sp = Sp + 8;
           call _cb7Wb() args: 0, res: 0, upd: 0;
     }
 },
 _cb80w() //  [R1]
         { info_tbl: [(cb80w,
                       label: block_cb80w_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb80w: // global
           I64[Sp] = block_cb80y_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub81L; else goto cb80C;
       ub81L: // global
           call _cb80y(R1) args: 0, res: 0, upd: 0;
       cb80C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb80y() //  [R1]
         { info_tbl: [(cb80y,
                       label: block_cb80y_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb80y: // global
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 80] = P64[R1 + 7];
           call _sb78C() args: 0, res: 0, upd: 0;
     }
 },
 _sb78C() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb78C: // global
           I64[Sp - 8] = block_cb7VI_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub81S; else goto cb7VJ;
       ub81S: // global
           call _cb7VI(R1) args: 0, res: 0, upd: 0;
       cb7VJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7VI() //  [R1]
         { info_tbl: [(cb7VI,
                       label: block_cb7VI_info
                       rep:StackRep [False, False, False, True, True, False, True, False,
                                     False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7VI: // global
           _sb789::I64 = I64[Sp + 56];
           _sb78a::P64 = P64[Sp + 64];
           _sb78b::P64 = P64[Sp + 72];
           _sb78c::I64 = I64[Sp + 80];
           _sb78e::I64 = I64[Sp + 96];
           if (R1 & 7 == 1) goto cb7ZD; else goto cb809;
       cb7ZD: // global
           Hp = Hp + 96;
           _sb78G::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb80c; else goto cb7ZF;
       cb7ZF: // global
           I64[Hp - 88] = buf1_sb78H_info;
           P64[Hp - 72] = _sb78a::P64;
           P64[Hp - 64] = _sb78b::P64;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = _sb789::I64;
           I64[Hp - 40] = _sb78c::I64;
           I64[Hp - 32] = _sb78e::I64;
           I64[Hp - 24] = sat_sb79e_info;
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 24];
           _cb7VN::P64 = Hp - 88;
           P64[Hp] = _cb7VN::P64;
           I64[Sp + 8] = block_cb7VR_info;
           R2 = GHC.IO.Handle.Text.hGetChar3_closure+2;
           R1 = Hp - 23;
           P64[Sp + 96] = _cb7VN::P64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cb809: // global
           Hp = Hp + 96;
           _sb78G::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb80c; else goto cb80b;
       cb80c: // global
           HpAlloc = 96;
           R1 = _sb78G::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb80b: // global
           I64[Hp - 88] = sat_sb79S_info;
           P64[Hp - 72] = _sb78a::P64;
           P64[Hp - 64] = _sb78b::P64;
           I64[Hp - 56] = _sb789::I64;
           I64[Hp - 48] = _sb78c::I64;
           I64[Hp - 40] = _sb78e::I64;
           I64[Hp - 32] = I64[Sp + 32];
           _sb78f::P64 = P64[Sp + 104];
           _sb78q::P64 = P64[Sp + 16];
           _sb78E::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sb78q::P64 + 8] = Hp - 88;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb78q::P64);
           I64[Hp - 24] = sat_sb79W_info;
           P64[Hp - 8] = _sb78f::P64;
           P64[Hp] = _sb78E::P64;
           R1 = Hp - 24;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7VR() //  [R1]
         { info_tbl: [(cb7VR,
                       label: block_cb7VR_info
                       rep:StackRep [False, True, True, True, False, True, True, True,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7VR: // global
           I64[Sp] = block_cb7VT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub81D; else goto cb7VU;
       ub81D: // global
           call _cb7VT(R1) args: 0, res: 0, upd: 0;
       cb7VU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7VT() //  [R1]
         { info_tbl: [(cb7VT,
                       label: block_cb7VT_info
                       rep:StackRep [False, True, True, True, False, True, True, True,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7VT: // global
           if (R1 & 7 == 1) goto cb7ZL; else goto cb805;
       cb7ZL: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb7ZO; else goto cb7ZN;
       cb7ZO: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7ZN: // global
           I64[Hp - 88] = sat_sb79q_info;
           _cb7VN::P64 = P64[Sp + 88];
           P64[Hp - 72] = _cb7VN::P64;
           _sb78f::P64 = P64[Sp + 96];
           _sb78q::P64 = P64[Sp + 8];
           _sb78E::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sb78q::P64 + 8] = Hp - 88;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb78q::P64);
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sb78E::P64;
           P64[Hp - 48] = _sb78f::P64;
           I64[Hp - 40] = sat_sb79A_info;
           P64[Hp - 24] = _cb7VN::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           I64[Sp + 96] = block_cb7ZJ_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp + 96;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
       cb805: // global
           I64[Sp + 32] = block_cb7VZ_info;
           R1 = P64[R1 + 6];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto ub81E; else goto cb7W0;
       ub81E: // global
           call _cb7VZ(R1) args: 0, res: 0, upd: 0;
       cb7W0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7ZJ() //  [R1]
         { info_tbl: [(cb7ZJ,
                       label: block_cb7ZJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7ZJ: // global
           I64[Sp] = block_cb7ZS_info;
           R2 = R1;
           call go1_rb6WQ_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb7ZS() //  [R1]
         { info_tbl: [(cb7ZS,
                       label: block_cb7ZS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7ZS: // global
           if (R1 & 7 == 1) goto cb7ZZ; else goto cb803;
       cb7ZZ: // global
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.ioe_EOF1_entry() args: 8, res: 0, upd: 8;
       cb803: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb7VZ() //  [R1]
         { info_tbl: [(cb7VZ,
                       label: block_cb7VZ_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7VZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb808; else goto cb807;
       cb808: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb807: // global
           _sb79K::P64 = P64[R1 + 7];
           _sb79L::P64 = P64[R1 + 15];
           _sb79J::I64 = I64[R1 + 23];
           _sb79M::I64 = I64[R1 + 31];
           _sb79N::I64 = I64[R1 + 39];
           _sb79O::I64 = I64[R1 + 47];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 64];
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = _sb79J::I64;
           P64[Sp + 24] = _sb79K::P64;
           P64[Sp + 32] = _sb79L::P64;
           I64[Sp + 40] = _sb79M::I64;
           I64[Sp + 48] = _sb79N::I64;
           I64[Sp + 56] = _sb79O::I64;
           P64[Sp + 64] = Hp - 14;
           Sp = Sp + 8;
           call _cb7Vf() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.860469617 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine3_closure" {
     GHC.IO.Handle.Text.hGetLine3_closure:
         const GHC.IO.Handle.Text.hGetLine3_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine3_entry() //  [R2, R3, R4]
         { info_tbl: [(cb820,
                       label: GHC.IO.Handle.Text.hGetLine3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb820: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb821; else goto cb822;
       cb821: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetLine3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb822: // global
           I64[Sp - 24] = block_cb81X_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub826; else goto cb81Y;
       ub826: // global
           call _cb81X(R1) args: 0, res: 0, upd: 0;
       cb81Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb81X() //  [R1]
         { info_tbl: [(cb81X,
                       label: block_cb81X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb81X: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.861604711 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetLine5_bytes" {
     GHC.IO.Handle.Text.hGetLine5_bytes:
         I8[] [104,71,101,116,76,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.862349682 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine4_closure" {
     GHC.IO.Handle.Text.hGetLine4_closure:
         const GHC.IO.Handle.Text.hGetLine4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine4_entry() //  [R1]
         { info_tbl: [(cb82d,
                       label: GHC.IO.Handle.Text.hGetLine4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb82d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb82e; else goto cb82f;
       cb82e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb82f: // global
           (_cb82a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb82a::I64 == 0) goto cb82c; else goto cb82b;
       cb82c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb82b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb82a::I64;
           R2 = GHC.IO.Handle.Text.hGetLine5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.863582584 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine2_closure" {
     GHC.IO.Handle.Text.hGetLine2_closure:
         const GHC.IO.Handle.Text.hGetLine2_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine2_entry() //  [R2]
         { info_tbl: [(cb82n,
                       label: GHC.IO.Handle.Text.hGetLine2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb82n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb82r; else goto cb82s;
       cb82r: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetLine2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb82s: // global
           I64[Sp - 8] = block_cb82k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub82A; else goto cb82l;
       ub82A: // global
           call _cb82k(R1) args: 0, res: 0, upd: 0;
       cb82l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb82k() //  [R1]
         { info_tbl: [(cb82k,
                       label: block_cb82k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb82k: // global
           _sb7bd::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_cb82q_info;
           _sb7aU::P64 = R1;
           R1 = _sb7bd::P64;
           P64[Sp] = _sb7aU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub82z; else goto cb82u;
       ub82z: // global
           call _cb82q(R1) args: 0, res: 0, upd: 0;
       cb82u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb82q() //  [R1]
         { info_tbl: [(cb82q,
                       label: block_cb82q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb82q: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.864919004 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine1_closure" {
     GHC.IO.Handle.Text.hGetLine1_closure:
         const GHC.IO.Handle.Text.hGetLine1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine1_entry() //  [R2]
         { info_tbl: [(cb82F,
                       label: GHC.IO.Handle.Text.hGetLine1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb82F: // global
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.865784523 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine_closure" {
     GHC.IO.Handle.Text.hGetLine_closure:
         const GHC.IO.Handle.Text.hGetLine_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine_entry() //  [R2]
         { info_tbl: [(cb82M,
                       label: GHC.IO.Handle.Text.hGetLine_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb82M: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetLine1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.866901566 UTC

[section ""data" . lvl11_rb6WR_closure" {
     lvl11_rb6WR_closure:
         const lvl11_rb6WR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rb6WR_entry() //  [R1]
         { info_tbl: [(cb830,
                       label: lvl11_rb6WR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb830: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb831; else goto cb832;
       cb831: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb832: // global
           (_cb82S::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb82S::I64 == 0) goto cb82U; else goto cb82T;
       cb82U: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb82T: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb82S::I64;
           I64[Sp - 24] = block_cb82V_info;
           R6 = 0;
           R5 = GHC.IO.FD.$tcFD1_closure;
           R4 = GHC.IO.FD.$trModule_closure;
           R3 = 15546290101957756376;
           R2 = 10838815552519039062;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cb82V() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cb82V,
                       label: block_cb82V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb82V: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cb82W() args: 0, res: 0, upd: 0;
     }
 },
 _cb82W() //  []
         { info_tbl: [(cb82W,
                       label: block_cb82W_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb82W: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb835; else goto cb834;
       cb835: // global
           HpAlloc = 48;
           I64[Sp] = block_cb82W_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cb834: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.872347861 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking2_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking2_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking2_info;
         const 0;
 },
 sat_sb7ch_entry() //  [R1]
         { info_tbl: [(cb841,
                       label: sat_sb7ch_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb841: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb848; else goto cb849;
       cb848: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb849: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb83Y_info;
           _sb7bY::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7bY::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub84d; else goto cb83Z;
       ub84d: // global
           call _cb83Y(R1) args: 0, res: 0, upd: 0;
       cb83Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb83Y() //  [R1]
         { info_tbl: [(cb83Y,
                       label: block_cb83Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb83Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb84c; else goto cb84b;
       cb84c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb84b: // global
           _sb7cg::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7cg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7cl_entry() //  [R1]
         { info_tbl: [(cb84m,
                       label: sat_sb7cl_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb84m: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb84t; else goto cb84u;
       cb84t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb84u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb84j_info;
           _sb7bY::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7bY::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub84y; else goto cb84k;
       ub84y: // global
           call _cb84j(R1) args: 0, res: 0, upd: 0;
       cb84k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb84j() //  [R1]
         { info_tbl: [(cb84j,
                       label: block_cb84j_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb84j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb84x; else goto cb84w;
       cb84x: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb84w: // global
           _sb7ck::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7ck::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7cB_entry() //  [R1]
         { info_tbl: [(cb854,
                       label: sat_sb7cB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb854: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb85b; else goto cb85c;
       cb85b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb85c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb851_info;
           _sb7bX::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7bX::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub85g; else goto cb852;
       ub85g: // global
           call _cb851(R1) args: 0, res: 0, upd: 0;
       cb852: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb851() //  [R1]
         { info_tbl: [(cb851,
                       label: block_cb851_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb851: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb85f; else goto cb85e;
       cb85f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb85e: // global
           _sb7cA::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7cA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking2_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cb85h,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb85h: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cb85i; else goto cb85j;
       cb85i: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufNonBlocking2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb85j: // global
           I64[Sp - 40] = block_cb83c_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub85H; else goto cb83d;
       ub85H: // global
           call _cb83c(R1) args: 0, res: 0, upd: 0;
       cb83d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb83c() //  [R1]
         { info_tbl: [(cb83c,
                       label: block_cb83c_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb83c: // global
           I64[Sp - 8] = block_cb83h_info;
           _sb7by::P64 = R1;
           _sb7bE::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb7bE::P64;
           P64[Sp + 8] = _sb7by::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub85D; else goto cb83i;
       ub85D: // global
           call _cb83h(R1) args: 0, res: 0, upd: 0;
       cb83i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb83h() //  [R1]
         { info_tbl: [(cb83h,
                       label: block_cb83h_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb83h: // global
           I64[Sp - 40] = block_cb83m_info;
           _sb7bR::P64 = P64[R1 + 7];
           _sb7bS::P64 = P64[R1 + 15];
           _sb7bQ::I64 = I64[R1 + 23];
           _sb7bT::I64 = I64[R1 + 31];
           _sb7bU::I64 = I64[R1 + 39];
           _sb7bV::I64 = I64[R1 + 47];
           R1 = P64[Sp + 40];
           P64[Sp - 32] = _sb7bS::P64;
           I64[Sp - 24] = _sb7bT::I64;
           I64[Sp - 16] = _sb7bU::I64;
           I64[Sp - 8] = _sb7bV::I64;
           P64[Sp] = _sb7bR::P64;
           I64[Sp + 40] = _sb7bQ::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub85E; else goto cb83n;
       ub85E: // global
           call _cb83m(R1) args: 0, res: 0, upd: 0;
       cb83n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb83m() //  [R1]
         { info_tbl: [(cb83m,
                       label: block_cb83m_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb83m: // global
           _sb7bu::P64 = P64[Sp + 64];
           _sb7bX::I64 = I64[R1 + 7];
           _sb7bY::I64 = I64[Sp + 32] - I64[Sp + 24];
           if (%MO_S_Ge_W64(_sb7bX::I64,
                            _sb7bY::I64)) goto cb85o; else goto cb85z;
       cb85o: // global
           I64[Sp] = block_cb83x_info;
           R1 = _sb7bu::P64;
           I64[Sp + 32] = _sb7bY::I64;
           I64[Sp + 64] = _sb7bX::I64;
           if (R1 & 7 != 0) goto ub85F; else goto cb83y;
       ub85F: // global
           call _cb83x(R1) args: 0, res: 0, upd: 0;
       cb83y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb85z: // global
           I64[Sp] = block_cb84A_info;
           R1 = _sb7bu::P64;
           I64[Sp + 64] = _sb7bX::I64;
           if (R1 & 7 != 0) goto ub85G; else goto cb84B;
       ub85G: // global
           call _cb84A(R1) args: 0, res: 0, upd: 0;
       cb84B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb83x() //  [R1]
         { info_tbl: [(cb83x,
                       label: block_cb83x_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb83x: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb85r; else goto cb85q;
       cb85r: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb85q: // global
           _sb7bv::P64 = P64[Sp + 72];
           _sb7by::P64 = P64[Sp + 56];
           _sb7bE::P64 = P64[Sp + 48];
           _sb7bQ::I64 = I64[Sp + 80];
           _sb7bR::P64 = P64[Sp + 40];
           _sb7bS::P64 = P64[Sp + 8];
           _sb7bT::I64 = I64[Sp + 16];
           _sb7bX::I64 = I64[Sp + 64];
           _sb7bY::I64 = I64[Sp + 32];
           _sb7c1::I64 = I64[R1 + 7];
           (_sb7c7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sb7c1::I64, _sb7bQ::I64 + I64[Sp + 24], _sb7bY::I64);
           call MO_Touch(_sb7bR::P64);
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb7bR::P64;
           P64[Hp - 80] = _sb7bS::P64;
           I64[Hp - 72] = _sb7bQ::I64;
           I64[Hp - 64] = _sb7bT::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           call MO_WriteBarrier();
           P64[_sb7bE::P64 + 8] = Hp - 95;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7bE::P64);
           _sb7cb::I64 = _sb7bX::I64 - _sb7bY::I64;
           if (_sb7cb::I64 != 0) goto cb85x; else goto cb85y;
       cb85x: // global
           I64[Hp - 40] = sat_sb7ch_info;
           P64[Hp - 24] = _sb7bv::P64;
           I64[Hp - 16] = _sb7bY::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sb7c1::I64 + _sb7bY::I64;
           R6 = _sb7cb::I64;
           R5 = Hp - 40;
           R4 = Hp - 7;
           R3 = _sb7bT::I64;
           R2 = _sb7by::P64;
           Sp = Sp + 88;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cb85y: // global
           I64[Hp - 40] = sat_sb7cl_info;
           P64[Hp - 24] = _sb7bv::P64;
           I64[Hp - 16] = _sb7bY::I64;
           _cb84f::P64 = Hp - 40;
           Hp = Hp - 16;
           R1 = _cb84f::P64;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb84A() //  [R1]
         { info_tbl: [(cb84A,
                       label: block_cb84A_info
                       rep:StackRep [False, True, True, True, False, False, True, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb84A: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cb85C; else goto cb85B;
       cb85C: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb85B: // global
           _sb7bv::P64 = P64[Sp + 72];
           _sb7bE::P64 = P64[Sp + 48];
           _sb7bQ::I64 = I64[Sp + 80];
           _sb7bR::P64 = P64[Sp + 40];
           _sb7bS::P64 = P64[Sp + 8];
           _sb7bT::I64 = I64[Sp + 16];
           _sb7bU::I64 = I64[Sp + 24];
           _sb7bV::I64 = I64[Sp + 32];
           _sb7bX::I64 = I64[Sp + 64];
           (_sb7ct::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[R1 + 7], _sb7bQ::I64 + _sb7bU::I64, _sb7bX::I64);
           call MO_Touch(_sb7bR::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _sb7bR::P64;
           P64[Hp - 64] = _sb7bS::P64;
           I64[Hp - 56] = _sb7bQ::I64;
           I64[Hp - 48] = _sb7bT::I64;
           I64[Hp - 40] = _sb7bU::I64 + _sb7bX::I64;
           I64[Hp - 32] = _sb7bV::I64;
           call MO_WriteBarrier();
           P64[_sb7bE::P64 + 8] = Hp - 79;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7bE::P64);
           I64[Hp - 24] = sat_sb7cB_info;
           P64[Hp - 8] = _sb7bv::P64;
           I64[Hp] = _sb7bX::I64;
           R1 = Hp - 24;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Text.$wbufReadNBEmpty_closure" {
     GHC.IO.Handle.Text.$wbufReadNBEmpty_closure:
         const GHC.IO.Handle.Text.$wbufReadNBEmpty_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wbufReadNBEmpty_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb85J: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7dz_entry() //  [R1]
         { info_tbl: [(cb86v,
                       label: sat_sb7dz_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb86v: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb86C; else goto cb86D;
       cb86C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb86D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb86s_info;
           _sb7dv::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7dv::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub86H; else goto cb86t;
       ub86H: // global
           call _cb86s(R1) args: 0, res: 0, upd: 0;
       cb86t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb86s() //  [R1]
         { info_tbl: [(cb86s,
                       label: block_cb86s_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb86s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb86G; else goto cb86F;
       cb86G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb86F: // global
           _sb7dy::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7dy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ub883_srtd" {
     ub883_srtd:
         const Sb7vQ_srt+56;
         const 33;
         const 8321499137;
 },
 GHC.IO.Handle.Text.$wbufReadNBEmpty_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cb86I,
                       label: GHC.IO.Handle.Text.$wbufReadNBEmpty_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, True, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb86I: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cb86J; else goto cb86K;
       cb86J: // global
           R1 = GHC.IO.Handle.Text.$wbufReadNBEmpty_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cb86K: // global
           I64[Sp - 40] = block_cb85N_info;
           R1 = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub87Z; else goto cb85O;
       ub87Z: // global
           call _cb85N(R1) args: 0, res: 0, upd: 0;
       cb85O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub884_srtd" {
     ub884_srtd:
         const Sb7vQ_srt+56;
         const 33;
         const 8053063681;
 },
 _cb85N() //  [R1]
         { info_tbl: [(cb85N,
                       label: block_cb85N_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb85N: // global
           I64[Sp - 32] = block_cb85S_info;
           _sb7cI::P64 = R1;
           _sb7cK::P64 = P64[R1 + 15];
           _sb7cL::P64 = P64[R1 + 23];
           _sb7cO::P64 = P64[R1 + 47];
           R1 = P64[R1 + 31];
           P64[Sp - 24] = _sb7cK::P64;
           P64[Sp - 16] = _sb7cL::P64;
           P64[Sp - 8] = _sb7cO::P64;
           P64[Sp] = _sb7cI::P64;
           Sp = Sp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub885_srtd" {
     ub885_srtd:
         const Sb7vQ_srt+56;
         const 33;
         const 8053063681;
 },
 _cb85S() //  [R1]
         { info_tbl: [(cb85S,
                       label: block_cb85S_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb85S: // global
           if (%MO_S_Le_W64(I64[Sp + 64],
                            I64[Sp + 40])) goto ub87T; else goto cb87C;
       ub87T: // global
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _sb7d2() args: 0, res: 0, upd: 0;
       cb87C: // global
           I64[Sp - 8] = block_cb862_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 15];
           I64[Sp + 16] = I64[R1 + 7];
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb862() //  [R1]
         { info_tbl: [(cb862,
                       label: block_cb862_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb862: // global
           if (R1 & 7 == 1) goto ub87U; else goto cb87I;
       ub87U: // global
           Sp = Sp + 16;
           call _sb7d2() args: 0, res: 0, upd: 0;
       cb87I: // global
           I64[Sp] = block_cb867_info;
           R1 = P64[Sp + 56];
           if (R1 & 7 != 0) goto ub87W; else goto cb868;
       ub87W: // global
           call _cb867(R1) args: 0, res: 0, upd: 0;
       cb868: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _sb7d2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7d2: // global
           _sb7d6::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp + 8] = block_cb86Q_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _sb7d6::P64;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb86Q() //  [R1]
         { info_tbl: [(cb86Q,
                       label: block_cb86Q_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb86Q: // global
           I64[Sp] = block_cb86S_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub880; else goto cb86V;
       ub880: // global
           call _cb86S(R1) args: 0, res: 0, upd: 0;
       cb86V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb86S() //  [R1]
         { info_tbl: [(cb86S,
                       label: block_cb86S_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb86S: // global
           I64[Sp] = block_cb86Z_info;
           _sb7dc::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _sb7dc::P64;
           if (R1 & 7 != 0) goto ub881; else goto cb871;
       ub881: // global
           call _cb86Z(R1) args: 0, res: 0, upd: 0;
       cb871: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb86Z() //  [R1]
         { info_tbl: [(cb86Z,
                       label: block_cb86Z_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb86Z: // global
           if (R1 & 7 == 1) goto cb877; else goto cb87c;
       cb877: // global
           R1 = P64[Sp + 40];
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb87c: // global
           I64[Sp] = block_cb87a_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub882; else goto cb87d;
       ub882: // global
           call _cb87a(R1) args: 0, res: 0, upd: 0;
       cb87d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb87a() //  [R1]
         { info_tbl: [(cb87a,
                       label: block_cb87a_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb87a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb87j; else goto cb87i;
       cb87j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb87i: // global
           _sb7cF::P64 = P64[Sp + 40];
           _sb7dh::I64 = I64[R1 + 7];
           if (_sb7dh::I64 == 0) goto cb87z; else goto cb87y;
       cb87z: // global
           Hp = Hp - 16;
           R1 = _sb7cF::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb87y: // global
           _sb7cE::P64 = P64[Sp + 32];
           _sb7cG::I64 = I64[Sp + 48];
           _sb7cI::P64 = P64[Sp + 16];
           _sb7cO::P64 = P64[Sp + 8];
           _sb7dc::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sb7cO::P64 + 8] = _sb7dc::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7cO::P64);
           if (%MO_S_Gt_W64(_sb7cG::I64,
                            _sb7dh::I64)) goto cb87s; else goto cb87w;
       cb87s: // global
           Hp = Hp - 16;
           R6 = R1;
           R5 = _sb7cF::P64;
           R4 = _sb7cE::P64;
           R3 = _sb7dc::P64;
           R2 = _sb7cI::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cb87w: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7cG::I64;
           R6 = Hp - 7;
           R5 = _sb7cF::P64;
           R4 = _sb7cE::P64;
           R3 = _sb7dc::P64;
           R2 = _sb7cI::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb867() //  [R1]
         { info_tbl: [(cb867,
                       label: block_cb867_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb867: // global
           I64[Sp + 56] = block_cb86f_info;
           R6 = 0;
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp + 48] = I64[Sp + 72];
           Sp = Sp + 48;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb86f() //  [R1]
         { info_tbl: [(cb86f,
                       label: block_cb86f_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb86f: // global
           I64[Sp] = block_cb86h_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub87Y; else goto cb86i;
       ub87Y: // global
           call _cb86h(R1) args: 0, res: 0, upd: 0;
       cb86i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb86h() //  [R1]
         { info_tbl: [(cb86h,
                       label: block_cb86h_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb86h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb87N; else goto cb87M;
       cb87N: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb87M: // global
           _sb7cF::P64 = P64[Sp + 8];
           _sb7dv::I64 = I64[R1 + 7];
           if (_sb7dv::I64 != (-1)) goto cb87P; else goto cb87Q;
       cb87P: // global
           I64[Hp - 24] = sat_sb7dz_info;
           P64[Hp - 8] = _sb7cF::P64;
           I64[Hp] = _sb7dv::I64;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb87Q: // global
           Hp = Hp - 32;
           R1 = _sb7cF::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.881511693 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes" {
     GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes:
         I8[] [104,71,101,116,66,117,102,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.882302095 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking3_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking3_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking3_entry() //  [R1]
         { info_tbl: [(cb88c,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb88c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb88d; else goto cb88e;
       cb88d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb88e: // global
           (_cb889::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb889::I64 == 0) goto cb88b; else goto cb88a;
       cb88b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb88a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb889::I64;
           R2 = GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.885944712 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBufNonBlocking_closure" {
     GHC.IO.Handle.Text.$whGetBufNonBlocking_closure:
         const GHC.IO.Handle.Text.$whGetBufNonBlocking_info;
         const 0;
 },
 sat_sb7eF_entry() //  [R1]
         { info_tbl: [(cb890,
                       label: sat_sb7eF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb890: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb894; else goto cb895;
       cb894: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb895: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb88X_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub899; else goto cb88Y;
       ub899: // global
           call _cb88X(R1) args: 0, res: 0, upd: 0;
       cb88Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb88X() //  [R1]
         { info_tbl: [(cb88X,
                       label: block_cb88X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb88X: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb898; else goto cb897;
       cb898: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb897: // global
           _sb7eA::P64 = P64[R1 + 7];
           _sb7eB::P64 = P64[R1 + 15];
           _sb7ez::I64 = I64[R1 + 23];
           _sb7eC::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7eA::P64;
           P64[Hp - 32] = _sb7eB::P64;
           I64[Hp - 24] = _sb7ez::I64;
           I64[Hp - 16] = _sb7eC::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7eY_entry() //  [R1]
         { info_tbl: [(cb89w,
                       label: sat_sb7eY_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb89w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb89D; else goto cb89E;
       cb89D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb89E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb89t_info;
           _sb7eO::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7eO::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub89I; else goto cb89u;
       ub89I: // global
           call _cb89t(R1) args: 0, res: 0, upd: 0;
       cb89u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb89t() //  [R1]
         { info_tbl: [(cb89t,
                       label: block_cb89t_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb89t: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb89H; else goto cb89G;
       cb89H: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb89G: // global
           _sb7eS::P64 = P64[R1 + 7];
           _sb7eT::P64 = P64[R1 + 15];
           _sb7eR::I64 = I64[R1 + 23];
           _sb7eU::I64 = I64[R1 + 31];
           _sb7eW::I64 = I64[R1 + 47];
           _sb7eX::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7eS::P64;
           P64[Hp - 32] = _sb7eT::P64;
           I64[Hp - 24] = _sb7eR::I64;
           I64[Hp - 16] = _sb7eU::I64;
           I64[Hp - 8] = _sb7eX::I64;
           I64[Hp] = _sb7eW::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7fj_entry() //  [R1, R2]
         { info_tbl: [(cb89J,
                       label: sat_sb7fj_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb89J: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cb89K; else goto cb89L;
       cb89K: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb89L: // global
           I64[Sp - 32] = block_cb88u_info;
           _sb7dB::P64 = P64[R1 + 6];
           _sb7dG::P64 = P64[R1 + 14];
           _sb7dE::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb7dB::P64;
           I64[Sp - 16] = _sb7dE::I64;
           P64[Sp - 8] = _sb7dG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8bf; else goto cb88v;
       ub8bf: // global
           call _cb88u(R1) args: 0, res: 0, upd: 0;
       cb88v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb88u() //  [R1]
         { info_tbl: [(cb88u,
                       label: block_cb88u_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb88u: // global
           I64[Sp - 40] = block_cb88z_info;
           _sb7dJ::P64 = R1;
           _sb7dP::P64 = P64[R1 + 47];
           _sb7dR::P64 = P64[R1 + 63];
           _sb7dS::P64 = P64[R1 + 71];
           _sb7dV::P64 = P64[R1 + 95];
           R1 = P64[_sb7dS::P64 + 8];
           P64[Sp - 32] = _sb7dP::P64;
           P64[Sp - 24] = _sb7dR::P64;
           P64[Sp - 16] = _sb7dS::P64;
           P64[Sp - 8] = _sb7dV::P64;
           P64[Sp] = _sb7dJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8b5; else goto cb88A;
       ub8b5: // global
           call _cb88z(R1) args: 0, res: 0, upd: 0;
       cb88A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb88z() //  [R1]
         { info_tbl: [(cb88z,
                       label: block_cb88z_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb88z: // global
           I64[Sp - 16] = block_cb88G_info;
           _sb7e8::I64 = I64[R1 + 39];
           _sb7e9::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sb7e9::I64;
           I64[Sp] = _sb7e8::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub8b6; else goto cb88H;
       ub8b6: // global
           call _cb88G(R1) args: 0, res: 0, upd: 0;
       cb88H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb88G() //  [R1]
         { info_tbl: [(cb88G,
                       label: block_cb88G_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb88G: // global
           if (R1 & 7 == 1) goto cb8aJ; else goto ub8b0;
       cb8aJ: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ub8b1; else goto cb8a5;
       ub8b1: // global
           Sp = Sp + 24;
           goto ub8b9;
       cb8a5: // global
           _sb7er::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cb88O_info;
           R1 = _sb7er::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub8b7; else goto cb88P;
       ub8b7: // global
           call _cb88O(R1) args: 0, res: 0, upd: 0;
       cb88P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub8b0: // global
           Sp = Sp + 24;
           goto ub8b9;
       ub8b9: // global
           call _sb7ea() args: 0, res: 0, upd: 0;
     }
 },
 _cb88O() //  [R1]
         { info_tbl: [(cb88O,
                       label: block_cb88O_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb88O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8a8; else goto cb8a7;
       cb8a8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8a7: // global
           _sb7dS::P64 = P64[Sp + 24];
           _sb7et::P64 = P64[R1 + 7];
           _sb7eu::P64 = P64[R1 + 15];
           _sb7ex::P64 = P64[_sb7dS::P64 + 8];
           I64[Hp - 16] = sat_sb7eF_info;
           P64[Hp] = _sb7ex::P64;
           call MO_WriteBarrier();
           P64[_sb7dS::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dS::P64);
           I64[Sp] = block_cb89d_info;
           R1 = _sb7ex::P64;
           P64[Sp + 16] = _sb7eu::P64;
           P64[Sp + 24] = _sb7et::P64;
           if (R1 & 7 != 0) goto ub8ba; else goto cb89e;
       ub8ba: // global
           call _cb89d(R1) args: 0, res: 0, upd: 0;
       cb89e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb89d() //  [R1]
         { info_tbl: [(cb89d,
                       label: block_cb89d_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb89d: // global
           _sb7eO::I64 = I64[R1 + 39];
           if (_sb7eO::I64 != 0) goto cb8ab; else goto cb8aG;
       cb8ab: // global
           I64[Sp - 24] = block_cb89k_info;
           _sb7eJ::P64 = P64[R1 + 7];
           _sb7eK::P64 = P64[R1 + 15];
           _sb7eI::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sb7eK::P64;
           I64[Sp - 8] = _sb7eO::I64;
           P64[Sp] = _sb7eJ::P64;
           I64[Sp + 32] = _sb7eI::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8bb; else goto cb89l;
       ub8bb: // global
           call _cb89k(R1) args: 0, res: 0, upd: 0;
       cb89l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8aG: // global
           _sb7dP::P64 = P64[Sp + 8];
           _sb7eu::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sb7dP::P64 + 8] = _sb7eu::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dP::P64);
           Sp = Sp + 8;
           call _sb7ea() args: 0, res: 0, upd: 0;
     }
 },
 _cb89k() //  [R1]
         { info_tbl: [(cb89k,
                       label: block_cb89k_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb89k: // global
           if (R1 & 7 == 1) goto cb8ad; else goto cb8av;
       cb8ad: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb8ag; else goto cb8af;
       cb8ag: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8af: // global
           I64[Hp - 24] = sat_sb7eY_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sb7dP::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sb7dP::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dP::P64);
           Sp = Sp + 32;
           call _sb7ea() args: 0, res: 0, upd: 0;
       cb8av: // global
           I64[Sp] = block_cb8aj_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub8bd; else goto cb8ak;
       ub8bd: // global
           call _cb8aj(R1) args: 0, res: 0, upd: 0;
       cb8ak: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8aj() //  [R1]
         { info_tbl: [(cb8aj,
                       label: block_cb8aj_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8aj: // global
           I64[Sp - 8] = block_cb8ao_info;
           R2 = P64[Sp + 48];
           _sb7f2::P64 = P64[R1 + 7];
           _sb7f3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sb7f3::P64;
           P64[Sp + 48] = _sb7f2::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8ao() //  [R1]
         { info_tbl: [(cb8ao,
                       label: block_cb8ao_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ao: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8az; else goto cb8ay;
       cb8az: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8ay: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cb8ar_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8ar() //  [R1]
         { info_tbl: [(cb8ar,
                       label: block_cb8ar_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ar: // global
           I64[Sp] = block_cb8at_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8bg; else goto cb8aB;
       ub8bg: // global
           call _cb8at(R1) args: 0, res: 0, upd: 0;
       cb8aB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8at() //  [R1]
         { info_tbl: [(cb8at,
                       label: block_cb8at_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8at: // global
           _sb7dP::P64 = P64[Sp + 8];
           _sb7ff::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sb7dP::P64 + 8] = _sb7ff::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dP::P64);
           Sp = Sp + 8;
           call _sb7ea() args: 0, res: 0, upd: 0;
     }
 },
 _sb7ea() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7ea: // global
           _sb7ee::P64 = P64[P64[Sp] + 8];
           I64[Sp + 24] = block_cb89R_info;
           R1 = _sb7ee::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ub8bi; else goto cb89T;
       ub8bi: // global
           call _cb89R(R1) args: 0, res: 0, upd: 0;
       cb89T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb89R() //  [R1]
         { info_tbl: [(cb89R,
                       label: block_cb89R_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb89R: // global
           _sb7dB::P64 = P64[Sp + 16];
           _sb7dJ::P64 = P64[Sp + 8];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb8a2; else goto cb8a1;
       cb8a2: // global
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7dB::P64;
           R3 = I64[R1 + 31];
           R2 = _sb7dJ::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cb8a1: // global
           R6 = P64[Sp + 32];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7dB::P64;
           R3 = R1;
           R2 = _sb7dJ::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub8bu_srtd" {
     ub8bu_srtd:
         const Sb7vQ_srt+8;
         const 41;
         const 1700807051265;
 },
 GHC.IO.Handle.Text.$whGetBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8bm,
                       label: GHC.IO.Handle.Text.$whGetBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8bm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb8bq; else goto cb8bp;
       cb8bq: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBufNonBlocking_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8bp: // global
           if (R4 == 0) goto cb8bl; else goto cb8bk;
       cb8bl: // global
           Hp = Hp - 48;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8bk: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cb8bs; else goto cb8bt;
       cb8bs: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sb7fj_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = R4;
           R4 = Hp - 22;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cb8bt: // global
           Hp = Hp - 48;
           R4 = R4;
           R3 = GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.892471755 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking1_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking1_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8bC,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8bC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8bD; else goto cb8bE;
       cb8bD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufNonBlocking1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8bE: // global
           I64[Sp - 24] = block_cb8bz_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8bI; else goto cb8bA;
       ub8bI: // global
           call _cb8bz(R1) args: 0, res: 0, upd: 0;
       cb8bA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8bz() //  [R1]
         { info_tbl: [(cb8bz,
                       label: block_cb8bz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8bz: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBufNonBlocking_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.893739043 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8bN,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8bN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBufNonBlocking1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.89452378 UTC

[section ""cstring" . lvl12_rb6WS_bytes" {
     lvl12_rb6WS_bytes:
         I8[] [104,71,101,116,66,117,102,83,111,109,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.895254911 UTC

[section ""data" . lvl13_rb6WT_closure" {
     lvl13_rb6WT_closure:
         const lvl13_rb6WT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rb6WT_entry() //  [R1]
         { info_tbl: [(cb8bW,
                       label: lvl13_rb6WT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8bW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8bX; else goto cb8bY;
       cb8bX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8bY: // global
           (_cb8bT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8bT::I64 == 0) goto cb8bV; else goto cb8bU;
       cb8bV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8bU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8bT::I64;
           R2 = lvl12_rb6WS_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.900117783 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBufSome_closure" {
     GHC.IO.Handle.Text.$whGetBufSome_closure:
         const GHC.IO.Handle.Text.$whGetBufSome_info;
         const 0;
 },
 sat_sb7gT_entry() //  [R1]
         { info_tbl: [(cb8cO,
                       label: sat_sb7gT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8cO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8cS; else goto cb8cT;
       cb8cS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8cT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb8cL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8cX; else goto cb8cM;
       ub8cX: // global
           call _cb8cL(R1) args: 0, res: 0, upd: 0;
       cb8cM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb8cL() //  [R1]
         { info_tbl: [(cb8cL,
                       label: block_cb8cL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8cL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8cW; else goto cb8cV;
       cb8cW: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb8cV: // global
           _sb7gO::P64 = P64[R1 + 7];
           _sb7gP::P64 = P64[R1 + 15];
           _sb7gN::I64 = I64[R1 + 23];
           _sb7gQ::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7gO::P64;
           P64[Hp - 32] = _sb7gP::P64;
           I64[Hp - 24] = _sb7gN::I64;
           I64[Hp - 16] = _sb7gQ::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7hc_entry() //  [R1]
         { info_tbl: [(cb8dk,
                       label: sat_sb7hc_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8dk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb8dr; else goto cb8ds;
       cb8dr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8ds: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb8dh_info;
           _sb7h2::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7h2::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8dw; else goto cb8di;
       ub8dw: // global
           call _cb8dh(R1) args: 0, res: 0, upd: 0;
       cb8di: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb8dh() //  [R1]
         { info_tbl: [(cb8dh,
                       label: block_cb8dh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8dh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8dv; else goto cb8du;
       cb8dv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb8du: // global
           _sb7h6::P64 = P64[R1 + 7];
           _sb7h7::P64 = P64[R1 + 15];
           _sb7h5::I64 = I64[R1 + 23];
           _sb7h8::I64 = I64[R1 + 31];
           _sb7ha::I64 = I64[R1 + 47];
           _sb7hb::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7h6::P64;
           P64[Hp - 32] = _sb7h7::P64;
           I64[Hp - 24] = _sb7h5::I64;
           I64[Hp - 16] = _sb7h8::I64;
           I64[Hp - 8] = _sb7hb::I64;
           I64[Hp] = _sb7ha::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ub8gC_srtd" {
     ub8gC_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 sat_sb7hx_entry() //  [R1, R2]
         { info_tbl: [(cb8dx,
                       label: sat_sb7hx_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8dx: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cb8dy; else goto cb8dz;
       cb8dy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8dz: // global
           I64[Sp - 32] = block_cb8ce_info;
           _sb7fr::P64 = P64[R1 + 6];
           _sb7fw::P64 = P64[R1 + 14];
           _sb7fu::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb7fr::P64;
           I64[Sp - 16] = _sb7fu::I64;
           P64[Sp - 8] = _sb7fw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8gi; else goto cb8cf;
       ub8gi: // global
           call _cb8ce(R1) args: 0, res: 0, upd: 0;
       cb8cf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gD_srtd" {
     ub8gD_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8ce() //  [R1]
         { info_tbl: [(cb8ce,
                       label: block_cb8ce_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ce: // global
           I64[Sp - 56] = block_cb8cj_info;
           _sb7fz::P64 = R1;
           _sb7fB::P64 = P64[R1 + 15];
           _sb7fC::P64 = P64[R1 + 23];
           _sb7fF::P64 = P64[R1 + 47];
           _sb7fH::P64 = P64[R1 + 63];
           _sb7fI::P64 = P64[R1 + 71];
           _sb7fL::P64 = P64[R1 + 95];
           R1 = P64[R1 + 31];
           P64[Sp - 48] = _sb7fB::P64;
           P64[Sp - 40] = _sb7fC::P64;
           P64[Sp - 32] = _sb7fF::P64;
           P64[Sp - 24] = _sb7fH::P64;
           P64[Sp - 16] = _sb7fI::P64;
           P64[Sp - 8] = _sb7fL::P64;
           P64[Sp] = _sb7fz::P64;
           Sp = Sp - 56;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gE_srtd" {
     ub8gE_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8cj() //  [R1]
         { info_tbl: [(cb8cj,
                       label: block_cb8cj_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8cj: // global
           _sb7fV::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 24] = block_cb8cn_info;
           _sb7fQ::P64 = R1;
           _sb7fR::I64 = I64[R1 + 7];
           _sb7fS::I64 = I64[R1 + 15];
           R1 = _sb7fV::P64;
           I64[Sp - 16] = _sb7fR::I64;
           I64[Sp - 8] = _sb7fS::I64;
           P64[Sp] = _sb7fQ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8g8; else goto cb8co;
       ub8g8: // global
           call _cb8cn(R1) args: 0, res: 0, upd: 0;
       cb8co: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gF_srtd" {
     ub8gF_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8cn() //  [R1]
         { info_tbl: [(cb8cn,
                       label: block_cb8cn_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8cn: // global
           I64[Sp - 16] = block_cb8cu_info;
           _sb7g1::I64 = I64[R1 + 39];
           _sb7g2::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sb7g2::I64;
           I64[Sp] = _sb7g1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub8g9; else goto cb8cv;
       ub8g9: // global
           call _cb8cu(R1) args: 0, res: 0, upd: 0;
       cb8cv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gG_srtd" {
     ub8gG_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8cu() //  [R1]
         { info_tbl: [(cb8cu,
                       label: block_cb8cu_info
                       rep:StackRep [True, True, True, True, False, False, False, False,
                                     False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8cu: // global
           if (R1 & 7 == 1) goto cb8fI; else goto ub8g1;
       cb8fI: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ub8g2; else goto cb8f4;
       ub8g2: // global
           Sp = Sp + 24;
           goto ub8gc;
       cb8f4: // global
           _sb7gF::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cb8cC_info;
           R1 = _sb7gF::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub8ga; else goto cb8cD;
       ub8ga: // global
           call _cb8cC(R1) args: 0, res: 0, upd: 0;
       cb8cD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub8g1: // global
           Sp = Sp + 24;
           goto ub8gc;
       ub8gc: // global
           call _sb7g3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub8gH_srtd" {
     ub8gH_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8cC() //  [R1]
         { info_tbl: [(cb8cC,
                       label: block_cb8cC_info
                       rep:StackRep [True, True, False, False, False, False, True, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8cC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8f7; else goto cb8f6;
       cb8f7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8f6: // global
           _sb7fI::P64 = P64[Sp + 64];
           _sb7gH::P64 = P64[R1 + 7];
           _sb7gI::P64 = P64[R1 + 15];
           _sb7gL::P64 = P64[_sb7fI::P64 + 8];
           I64[Hp - 16] = sat_sb7gT_info;
           P64[Hp] = _sb7gL::P64;
           call MO_WriteBarrier();
           P64[_sb7fI::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fI::P64);
           I64[Sp] = block_cb8d1_info;
           R1 = _sb7gL::P64;
           P64[Sp + 56] = _sb7gI::P64;
           P64[Sp + 64] = _sb7gH::P64;
           if (R1 & 7 != 0) goto ub8gd; else goto cb8d2;
       ub8gd: // global
           call _cb8d1(R1) args: 0, res: 0, upd: 0;
       cb8d2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gI_srtd" {
     ub8gI_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8d1() //  [R1]
         { info_tbl: [(cb8d1,
                       label: block_cb8d1_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8d1: // global
           _sb7h2::I64 = I64[R1 + 39];
           if (_sb7h2::I64 != 0) goto cb8fa; else goto cb8fF;
       cb8fa: // global
           I64[Sp - 24] = block_cb8d8_info;
           _sb7gX::P64 = P64[R1 + 7];
           _sb7gY::P64 = P64[R1 + 15];
           _sb7gW::I64 = I64[R1 + 23];
           R1 = P64[Sp + 72];
           P64[Sp - 16] = _sb7gY::P64;
           I64[Sp - 8] = _sb7h2::I64;
           P64[Sp] = _sb7gX::P64;
           I64[Sp + 72] = _sb7gW::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8ge; else goto cb8d9;
       ub8ge: // global
           call _cb8d8(R1) args: 0, res: 0, upd: 0;
       cb8d9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8fF: // global
           _sb7fF::P64 = P64[Sp + 48];
           _sb7gI::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = _sb7gI::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           Sp = Sp + 8;
           call _sb7g3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub8gJ_srtd" {
     ub8gJ_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8d8() //  [R1]
         { info_tbl: [(cb8d8,
                       label: block_cb8d8_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8d8: // global
           if (R1 & 7 == 1) goto cb8fc; else goto cb8fu;
       cb8fc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb8ff; else goto cb8fe;
       cb8ff: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8fe: // global
           I64[Hp - 24] = sat_sb7hc_info;
           P64[Hp - 8] = P64[Sp + 80];
           I64[Hp] = I64[Sp + 16];
           _sb7fF::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           Sp = Sp + 32;
           call _sb7g3() args: 0, res: 0, upd: 0;
       cb8fu: // global
           I64[Sp] = block_cb8fi_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub8gg; else goto cb8fj;
       ub8gg: // global
           call _cb8fi(R1) args: 0, res: 0, upd: 0;
       cb8fj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gK_srtd" {
     ub8gK_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8fi() //  [R1]
         { info_tbl: [(cb8fi,
                       label: block_cb8fi_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8fi: // global
           I64[Sp - 8] = block_cb8fn_info;
           R2 = P64[Sp + 88];
           _sb7hg::P64 = P64[R1 + 7];
           _sb7hh::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sb7hh::P64;
           P64[Sp + 88] = _sb7hg::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gL_srtd" {
     ub8gL_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8fn() //  [R1]
         { info_tbl: [(cb8fn,
                       label: block_cb8fn_info
                       rep:StackRep [False, False, True, False, True, True, False, False,
                                     False, False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8fn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8fy; else goto cb8fx;
       cb8fy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8fx: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 104];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cb8fq_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 88];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 96];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gM_srtd" {
     ub8gM_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8fq() //  [R1]
         { info_tbl: [(cb8fq,
                       label: block_cb8fq_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8fq: // global
           I64[Sp] = block_cb8fs_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8go; else goto cb8fA;
       ub8go: // global
           call _cb8fs(R1) args: 0, res: 0, upd: 0;
       cb8fA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gN_srtd" {
     ub8gN_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8fs() //  [R1]
         { info_tbl: [(cb8fs,
                       label: block_cb8fs_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8fs: // global
           _sb7fF::P64 = P64[Sp + 48];
           _sb7ht::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = _sb7ht::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           Sp = Sp + 8;
           call _sb7g3() args: 0, res: 0, upd: 0;
     }
 },
 _sb7g3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7g3: // global
           _sb7g7::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 8] = block_cb8dG_info;
           R1 = _sb7g7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8gq; else goto cb8dI;
       ub8gq: // global
           call _cb8dG(R1) args: 0, res: 0, upd: 0;
       cb8dI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8gO_srtd" {
     ub8gO_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb8dG() //  [R1]
         { info_tbl: [(cb8dG,
                       label: block_cb8dG_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8dG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb8dO; else goto cb8dN;
       cb8dO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8dN: // global
           _sb7fu::I64 = I64[Sp + 96];
           _sb7gd::I64 = I64[R1 + 39];
           _sb7ge::I64 = I64[R1 + 47];
           if (_sb7gd::I64 == _sb7ge::I64) goto cb8f1; else goto cb8e3;
       cb8f1: // global
           if (%MO_S_Le_W64(_sb7fu::I64,
                            I64[R1 + 31])) goto cb8eG; else goto cb8eK;
       cb8eG: // global
           Hp = Hp - 16;
           P64[Sp + 72] = R1;
           Sp = Sp + 24;
           call _sb7gj() args: 0, res: 0, upd: 0;
       cb8eK: // global
           Hp = Hp - 16;
           I64[Sp] = block_cb8eJ_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 40];
           P64[Sp + 72] = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
       cb8e3: // global
           _sb7fr::P64 = P64[Sp + 88];
           _sb7fz::P64 = P64[Sp + 80];
           _sb7gg::I64 = _sb7ge::I64 - _sb7gd::I64;
           if (%MO_S_Gt_W64(_sb7fu::I64,
                            _sb7gg::I64)) goto cb8e0; else goto cb8e1;
       cb8e0: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7gg::I64;
           R6 = Hp - 7;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = R1;
           R2 = _sb7fz::P64;
           Sp = Sp + 112;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cb8e1: // global
           Hp = Hp - 16;
           R6 = P64[Sp + 104];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = R1;
           R2 = _sb7fz::P64;
           Sp = Sp + 112;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb8eJ() //  [R1]
         { info_tbl: [(cb8eJ,
                       label: block_cb8eJ_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8eJ: // global
           if (R1 & 7 == 1) goto ub8g7; else goto cb8eV;
       ub8g7: // global
           Sp = Sp + 24;
           call _sb7gj() args: 0, res: 0, upd: 0;
       cb8eV: // global
           I64[Sp] = block_cb8eT_info;
           R1 = P64[Sp + 88];
           if (R1 & 7 != 0) goto ub8gm; else goto cb8eW;
       ub8gm: // global
           call _cb8eT(R1) args: 0, res: 0, upd: 0;
       cb8eW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _sb7gj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7gj: // global
           I64[Sp + 16] = block_cb8ea_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp + 8] = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb8ea() //  [R1]
         { info_tbl: [(cb8ea,
                       label: block_cb8ea_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ea: // global
           I64[Sp] = block_cb8ec_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8gk; else goto cb8ed;
       ub8gk: // global
           call _cb8ec(R1) args: 0, res: 0, upd: 0;
       cb8ed: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8ec() //  [R1]
         { info_tbl: [(cb8ec,
                       label: block_cb8ec_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ec: // global
           I64[Sp] = block_cb8eh_info;
           _sb7gq::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 32] = _sb7gq::P64;
           if (R1 & 7 != 0) goto ub8gl; else goto cb8el;
       ub8gl: // global
           call _cb8eh(R1) args: 0, res: 0, upd: 0;
       cb8el: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8eh() //  [R1]
         { info_tbl: [(cb8eh,
                       label: block_cb8eh_info
                       rep:StackRep [False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8eh: // global
           _sb7gt::I64 = I64[R1 + 7];
           if (_sb7gt::I64 == 0) goto cb8eC; else goto cb8eB;
       cb8eC: // global
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8eB: // global
           _sb7fr::P64 = P64[Sp + 48];
           _sb7fu::I64 = I64[Sp + 56];
           _sb7fw::P64 = P64[Sp + 64];
           _sb7fz::P64 = P64[Sp + 40];
           _sb7fF::P64 = P64[Sp + 8];
           _sb7gq::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = _sb7gq::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           if (%MO_S_Gt_W64(_sb7gt::I64,
                            _sb7fu::I64)) goto cb8ey; else goto cb8ez;
       cb8ey: // global
           R6 = _sb7fw::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = _sb7gq::P64;
           R2 = _sb7fz::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cb8ez: // global
           R6 = R1;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = _sb7gq::P64;
           R2 = _sb7fz::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb8eT() //  [R1]
         { info_tbl: [(cb8eT,
                       label: block_cb8eT_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8eT: // global
           R6 = 0;
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 104] = I64[Sp + 96];
           Sp = Sp + 104;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub8gP_srtd" {
     ub8gP_srtd:
         const Sb7vQ_srt+8;
         const 46;
         const 66279935313985;
 },
 GHC.IO.Handle.Text.$whGetBufSome_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8gu,
                       label: GHC.IO.Handle.Text.$whGetBufSome_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8gu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb8gy; else goto cb8gx;
       cb8gy: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBufSome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8gx: // global
           if (R4 == 0) goto cb8gt; else goto cb8gs;
       cb8gt: // global
           Hp = Hp - 48;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8gs: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cb8gA; else goto cb8gB;
       cb8gA: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sb7hx_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = R4;
           R4 = Hp - 22;
           R3 = R2;
           R2 = lvl13_rb6WT_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cb8gB: // global
           Hp = Hp - 48;
           R4 = R4;
           R3 = lvl13_rb6WT_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.910123799 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufSome1_closure" {
     GHC.IO.Handle.Text.hGetBufSome1_closure:
         const GHC.IO.Handle.Text.hGetBufSome1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufSome1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8gX,
                       label: GHC.IO.Handle.Text.hGetBufSome1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8gX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8gY; else goto cb8gZ;
       cb8gY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufSome1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8gZ: // global
           I64[Sp - 24] = block_cb8gU_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8h3; else goto cb8gV;
       ub8h3: // global
           call _cb8gU(R1) args: 0, res: 0, upd: 0;
       cb8gV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8gU() //  [R1]
         { info_tbl: [(cb8gU,
                       label: block_cb8gU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8gU: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBufSome_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.911429187 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufSome_closure" {
     GHC.IO.Handle.Text.hGetBufSome_closure:
         const GHC.IO.Handle.Text.hGetBufSome_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufSome_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8h8,
                       label: GHC.IO.Handle.Text.hGetBufSome_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8h8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBufSome1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.919632368 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf4_closure" {
     GHC.IO.Handle.Text.hGetBuf4_closure:
         const GHC.IO.Handle.Text.hGetBuf4_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb8hi,
                       label: GHC.IO.Handle.Text.hGetBuf4_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8hi: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cb8hw; else goto cb8hx;
       cb8hw: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8hx: // global
           I64[Sp - 40] = block_cb8hf_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8j2; else goto cb8hg;
       ub8j2: // global
           call _cb8hf(R1) args: 0, res: 0, upd: 0;
       cb8hg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8hf() //  [R1]
         { info_tbl: [(cb8hf,
                       label: block_cb8hf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8hf: // global
           I64[Sp - 8] = block_cb8hl_info;
           _sb7hK::P64 = R1;
           _sb7hQ::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb7hQ::P64;
           P64[Sp + 8] = _sb7hK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8j1; else goto cb8hm;
       ub8j1: // global
           call _cb8hl(R1) args: 0, res: 0, upd: 0;
       cb8hm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8hl() //  [R1]
         { info_tbl: [(cb8hl,
                       label: block_cb8hl_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8hl: // global
           I64[Sp - 40] = block_cb8hq_info;
           _sb7i3::P64 = P64[R1 + 7];
           _sb7i4::P64 = P64[R1 + 15];
           _sb7i2::I64 = I64[R1 + 23];
           _sb7i5::I64 = I64[R1 + 31];
           _sb7i6::I64 = I64[R1 + 39];
           _sb7i7::I64 = I64[R1 + 47];
           R1 = P64[Sp + 32];
           P64[Sp - 32] = _sb7i4::P64;
           I64[Sp - 24] = _sb7i5::I64;
           I64[Sp - 16] = _sb7i6::I64;
           I64[Sp - 8] = _sb7i7::I64;
           P64[Sp] = _sb7i3::P64;
           I64[Sp + 32] = _sb7i2::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8j3; else goto cb8hr;
       ub8j3: // global
           call _cb8hq(R1) args: 0, res: 0, upd: 0;
       cb8hr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8hq() //  [R1]
         { info_tbl: [(cb8hq,
                       label: block_cb8hq_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8hq: // global
           I64[Sp] = block_cb8hv_info;
           _sb7i9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 80];
           I64[Sp + 80] = _sb7i9::I64;
           if (R1 & 7 != 0) goto ub8j4; else goto cb8hB;
       ub8j4: // global
           call _cb8hv(R1) args: 0, res: 0, upd: 0;
       cb8hB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8hv() //  [R1]
         { info_tbl: [(cb8hv,
                       label: block_cb8hv_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8hv: // global
           _sb7hG::P64 = P64[Sp + 64];
           _sb7ib::I64 = I64[R1 + 7];
           _sb7ic::I64 = I64[Sp + 32] - I64[Sp + 24];
           if (%MO_S_Ge_W64(_sb7ib::I64,
                            _sb7ic::I64)) goto cb8hO; else goto cb8iX;
       cb8hO: // global
           I64[Sp] = block_cb8hM_info;
           R1 = _sb7hG::P64;
           I64[Sp + 32] = _sb7ic::I64;
           I64[Sp + 64] = _sb7ib::I64;
           if (R1 & 7 != 0) goto ub8j5; else goto cb8hP;
       ub8j5: // global
           call _cb8hM(R1) args: 0, res: 0, upd: 0;
       cb8hP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8iX: // global
           I64[Sp] = block_cb8iw_info;
           R1 = _sb7hG::P64;
           I64[Sp + 64] = _sb7ib::I64;
           if (R1 & 7 != 0) goto ub8j6; else goto cb8ix;
       ub8j6: // global
           call _cb8iw(R1) args: 0, res: 0, upd: 0;
       cb8ix: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8hM() //  [R1]
         { info_tbl: [(cb8hM,
                       label: block_cb8hM_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8hM: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb8hV; else goto cb8hU;
       cb8hV: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8hU: // global
           _sb7hK::P64 = P64[Sp + 56];
           _sb7hQ::P64 = P64[Sp + 48];
           _sb7i2::I64 = I64[Sp + 72];
           _sb7i3::P64 = P64[Sp + 40];
           _sb7i4::P64 = P64[Sp + 8];
           _sb7i5::I64 = I64[Sp + 16];
           _sb7i9::I64 = I64[Sp + 80];
           _sb7ib::I64 = I64[Sp + 64];
           _sb7ic::I64 = I64[Sp + 32];
           _sb7if::I64 = I64[R1 + 7];
           (_sb7il::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sb7if::I64, _sb7i2::I64 + I64[Sp + 24], _sb7ic::I64);
           call MO_Touch(_sb7i3::P64);
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb7i3::P64;
           P64[Hp - 80] = _sb7i4::P64;
           I64[Hp - 72] = _sb7i2::I64;
           I64[Hp - 64] = _sb7i5::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           call MO_WriteBarrier();
           _cb8i7::P64 = Hp - 95;
           P64[_sb7hQ::P64 + 8] = _cb8i7::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7hQ::P64);
           _sb7ip::I64 = _sb7ib::I64 - _sb7ic::I64;
           if (_sb7ip::I64 != 0) goto cb8io; else goto cb8iu;
       cb8io: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sb7ip::I64;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _sb7i9::I64 + _sb7ic::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sb7if::I64 + _sb7ic::I64;
           R6 = Hp - 39;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = _cb8i7::P64;
           R2 = _sb7hK::P64;
           Sp = Sp + 88;
           call GHC.IO.Handle.Text.hGetBuf2_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cb8iu: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sb7i9::I64 + _sb7ic::I64;
           _cb8it::P64 = Hp - 39;
           Hp = Hp - 32;
           R1 = _cb8it::P64;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8iw() //  [R1]
         { info_tbl: [(cb8iw,
                       label: block_cb8iw_info
                       rep:StackRep [False, True, True, True, False, False, True, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8iw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cb8j0; else goto cb8iZ;
       cb8j0: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8iZ: // global
           _sb7hQ::P64 = P64[Sp + 48];
           _sb7i2::I64 = I64[Sp + 72];
           _sb7i3::P64 = P64[Sp + 40];
           _sb7i4::P64 = P64[Sp + 8];
           _sb7i5::I64 = I64[Sp + 16];
           _sb7i6::I64 = I64[Sp + 24];
           _sb7i7::I64 = I64[Sp + 32];
           _sb7i9::I64 = I64[Sp + 80];
           _sb7ib::I64 = I64[Sp + 64];
           (_sb7iE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[R1 + 7], _sb7i2::I64 + _sb7i6::I64, _sb7ib::I64);
           call MO_Touch(_sb7i3::P64);
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = _sb7i3::P64;
           P64[Hp - 48] = _sb7i4::P64;
           I64[Hp - 40] = _sb7i2::I64;
           I64[Hp - 32] = _sb7i5::I64;
           I64[Hp - 24] = _sb7i6::I64 + _sb7ib::I64;
           I64[Hp - 16] = _sb7i7::I64;
           call MO_WriteBarrier();
           P64[_sb7hQ::P64 + 8] = Hp - 63;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7hQ::P64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7i9::I64 + _sb7ib::I64;
           R1 = Hp - 7;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Text.hGetBuf2_closure" {
     GHC.IO.Handle.Text.hGetBuf2_closure:
         const GHC.IO.Handle.Text.hGetBuf2_info;
         const 0;
 },
 sat_sb7jB_entry() //  [R1]
         { info_tbl: [(cb8ky,
                       label: sat_sb7jB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ky: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb8kF; else goto cb8kG;
       cb8kF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8kG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb8kv_info;
           _sb7jw::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7jw::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8kK; else goto cb8kw;
       ub8kK: // global
           call _cb8kv(R1) args: 0, res: 0, upd: 0;
       cb8kw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb8kv() //  [R1]
         { info_tbl: [(cb8kv,
                       label: block_cb8kv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8kv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb8kJ; else goto cb8kI;
       cb8kJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb8kI: // global
           _sb7jA::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7jA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7jF_entry() //  [R1]
         { info_tbl: [(cb8kS,
                       label: sat_sb7jF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8kS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8kT; else goto cb8kU;
       cb8kT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8kU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.$fNumInt_$c+_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ub8ml_srtd" {
     ub8ml_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 6807523164161;
 },
 GHC.IO.Handle.Text.hGetBuf2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb8kV,
                       label: GHC.IO.Handle.Text.hGetBuf2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8kV: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb8kW; else goto cb8kX;
       cb8kW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8kX: // global
           I64[Sp - 40] = block_cb8jb_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8mi; else goto cb8jc;
       ub8mi: // global
           call _cb8jb(R1) args: 0, res: 0, upd: 0;
       cb8jc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8mm_srtd" {
     ub8mm_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 4608499908609;
 },
 _cb8jb() //  [R1]
         { info_tbl: [(cb8jb,
                       label: block_cb8jb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8jb: // global
           I64[Sp - 32] = block_cb8jg_info;
           _sb7iR::P64 = R1;
           _sb7iT::P64 = P64[R1 + 15];
           _sb7iU::P64 = P64[R1 + 23];
           _sb7iV::P64 = P64[R1 + 31];
           _sb7iX::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sb7iU::P64;
           P64[Sp - 16] = _sb7iV::P64;
           P64[Sp - 8] = _sb7iX::P64;
           P64[Sp] = _sb7iT::P64;
           P64[Sp + 8] = _sb7iR::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8m4; else goto cb8jh;
       ub8m4: // global
           call _cb8jg(R1) args: 0, res: 0, upd: 0;
       cb8jh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8mn_srtd" {
     ub8mn_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 4608499908609;
 },
 _cb8jg() //  [R1]
         { info_tbl: [(cb8jg,
                       label: block_cb8jg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8jg: // global
           I64[Sp - 8] = block_cb8jl_info;
           _sb7j8::P64 = R1;
           _sb7jc::I64 = I64[R1 + 31];
           R1 = P64[Sp + 64];
           I64[Sp] = _sb7jc::I64;
           P64[Sp + 64] = _sb7j8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8m5; else goto cb8jm;
       ub8m5: // global
           call _cb8jl(R1) args: 0, res: 0, upd: 0;
       cb8jm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8mo_srtd" {
     ub8mo_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 4608499908609;
 },
 _cb8jl() //  [R1]
         { info_tbl: [(cb8jl,
                       label: block_cb8jl_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8jl: // global
           _sb7jg::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sb7jg::I64,
                            I64[Sp + 8])) goto ub8lW; else goto cb8lq;
       ub8lW: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sb7jh() args: 0, res: 0, upd: 0;
       cb8lq: // global
           I64[Sp] = block_cb8jw_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 16];
           I64[Sp + 8] = _sb7jg::I64;
           P64[Sp + 16] = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8jw() //  [R1]
         { info_tbl: [(cb8jw,
                       label: block_cb8jw_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8jw: // global
           if (R1 & 7 == 1) goto ub8lX; else goto cb8lQ;
       ub8lX: // global
           Sp = Sp + 16;
           call _sb7jh() args: 0, res: 0, upd: 0;
       cb8lQ: // global
           I64[Sp + 40] = I64[Sp + 8];
           P64[Sp + 48] = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           P64[Sp + 72] = P64[Sp + 24];
           Sp = Sp + 40;
           call _cb8jH() args: 0, res: 0, upd: 0;
     }
 },
 _sb7jh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7jh: // global
           I64[Sp - 8] = block_cb8l4_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 8];
           P64[Sp - 16] = P64[Sp + 56];
           Sp = Sp - 32;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb8l4() //  [R1]
         { info_tbl: [(cb8l4,
                       label: block_cb8l4_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8l4: // global
           I64[Sp] = block_cb8l6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8mj; else goto cb8l7;
       ub8mj: // global
           call _cb8l6(R1) args: 0, res: 0, upd: 0;
       cb8l7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8l6() //  [R1]
         { info_tbl: [(cb8l6,
                       label: block_cb8l6_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8l6: // global
           I64[Sp] = block_cb8lb_info;
           _sb7jo::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 64] = _sb7jo::P64;
           if (R1 & 7 != 0) goto ub8mk; else goto cb8lf;
       ub8mk: // global
           call _cb8lb(R1) args: 0, res: 0, upd: 0;
       cb8lf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8lb() //  [R1]
         { info_tbl: [(cb8lb,
                       label: block_cb8lb_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8lb: // global
           _sb7iO::P64 = P64[Sp + 56];
           if (I64[R1 + 7] == 0) goto cb8ln; else goto cb8lm;
       cb8ln: // global
           R1 = _sb7iO::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8lm: // global
           _sb7iN::P64 = P64[Sp + 48];
           _sb7iR::P64 = P64[Sp + 40];
           _sb7iX::P64 = P64[Sp + 24];
           _sb7jf::P64 = P64[Sp + 8];
           _sb7jo::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sb7iX::P64 + 8] = _sb7jo::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7iX::P64);
           R6 = _sb7jf::P64;
           R5 = _sb7iO::P64;
           R4 = _sb7iN::P64;
           R3 = _sb7jo::P64;
           R2 = _sb7iR::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBuf4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb8jH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8jH: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cb8lE; else goto cb8lP;
       cb8lE: // global
           I64[Sp - 8] = block_cb8jN_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8m9; else goto cb8jO;
       ub8m9: // global
           call _cb8jN(R1) args: 0, res: 0, upd: 0;
       cb8jO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8lP: // global
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 24;
           call _cb8kM() args: 0, res: 0, upd: 0;
     }
 },
 _cb8jN() //  [R1]
         { info_tbl: [(cb8jN,
                       label: block_cb8jN_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8jN: // global
           I64[Sp] = block_cb8jS_info;
           _sb7jN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb7jN::I64;
           if (R1 & 7 != 0) goto ub8mb; else goto cb8jT;
       ub8mb: // global
           call _cb8jS(R1) args: 0, res: 0, upd: 0;
       cb8jT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8jS() //  [R1]
         { info_tbl: [(cb8jS,
                       label: block_cb8jS_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8jS: // global
           I64[Sp] = block_cb8jX_info;
           _sb7jP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sb7jP::I64;
           if (R1 & 7 != 0) goto ub8mc; else goto cb8jY;
       ub8mc: // global
           call _cb8jX(R1) args: 0, res: 0, upd: 0;
       cb8jY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8jX() //  [R1]
         { info_tbl: [(cb8jX,
                       label: block_cb8jX_info
                       rep:StackRep [True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8jX: // global
           _sb7jT::I64 = I64[Sp + 16] + I64[Sp + 40];
           I64[Sp] = block_cb8k8_info;
           R6 = 0;
           R5 = _sb7jT::I64;
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 8] = I64[Sp + 8];
           P64[Sp + 16] = R1;
           Sp = Sp - 8;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb8k8() //  [R1]
         { info_tbl: [(cb8k8,
                       label: block_cb8k8_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8k8: // global
           I64[Sp] = block_cb8ka_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8md; else goto cb8kb;
       ub8md: // global
           call _cb8ka(R1) args: 0, res: 0, upd: 0;
       cb8kb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8ka() //  [R1]
         { info_tbl: [(cb8ka,
                       label: block_cb8ka_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ka: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb8lL; else goto cb8lK;
       cb8lL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8lK: // global
           _sb7jP::I64 = I64[Sp + 40];
           _sb7k0::I64 = I64[R1 + 7];
           if (_sb7k0::I64 != 0) goto cb8lN; else goto cb8lO;
       cb8lN: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7jP::I64 + _sb7k0::I64;
           P64[Sp + 40] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 7;
           I64[Sp + 8] = I64[Sp + 8] - _sb7k0::I64;
           Sp = Sp + 8;
           call _cb8jH() args: 0, res: 0, upd: 0;
       cb8lO: // global
           Hp = Hp - 16;
           I64[Sp + 40] = _sb7jP::I64;
           Sp = Sp + 32;
           call _cb8kp() args: 0, res: 0, upd: 0;
     }
 },
 _cb8kp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8kp: // global
           Hp = Hp + 32;
           _sb7jw::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb8ly; else goto cb8lx;
       cb8ly: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cb8ko_info;
           R1 = _sb7jw::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb8lx: // global
           I64[Hp - 24] = sat_sb7jB_info;
           P64[Hp - 8] = P64[Sp];
           I64[Hp] = _sb7jw::I64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8ko() //  [R1]
         { info_tbl: [(cb8ko,
                       label: block_cb8ko_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ko: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb8kp() args: 0, res: 0, upd: 0;
     }
 },
 _cb8kM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8kM: // global
           Hp = Hp + 32;
           _sb7jD::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb8lB; else goto cb8lA;
       cb8lB: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cb8kL_info;
           R1 = _sb7jD::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8lA: // global
           I64[Hp - 24] = sat_sb7jF_info;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = _sb7jD::P64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8kL() //  [R1]
         { info_tbl: [(cb8kL,
                       label: block_cb8kL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8kL: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb8kM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.92821002 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetBuf6_bytes" {
     GHC.IO.Handle.Text.hGetBuf6_bytes:
         I8[] [104,71,101,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.928956847 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf5_closure" {
     GHC.IO.Handle.Text.hGetBuf5_closure:
         const GHC.IO.Handle.Text.hGetBuf5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf5_entry() //  [R1]
         { info_tbl: [(cb8mv,
                       label: GHC.IO.Handle.Text.hGetBuf5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8mv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8mw; else goto cb8mx;
       cb8mw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8mx: // global
           (_cb8ms::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8ms::I64 == 0) goto cb8mu; else goto cb8mt;
       cb8mu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8mt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8ms::I64;
           R2 = GHC.IO.Handle.Text.hGetBuf6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.932606674 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBuf_closure" {
     GHC.IO.Handle.Text.$whGetBuf_closure:
         const GHC.IO.Handle.Text.$whGetBuf_info;
         const 0;
 },
 sat_sb7l9_entry() //  [R1]
         { info_tbl: [(cb8nj,
                       label: sat_sb7l9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8nj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8nn; else goto cb8no;
       cb8nn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8no: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb8ng_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8ns; else goto cb8nh;
       ub8ns: // global
           call _cb8ng(R1) args: 0, res: 0, upd: 0;
       cb8nh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb8ng() //  [R1]
         { info_tbl: [(cb8ng,
                       label: block_cb8ng_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ng: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8nr; else goto cb8nq;
       cb8nr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb8nq: // global
           _sb7l4::P64 = P64[R1 + 7];
           _sb7l5::P64 = P64[R1 + 15];
           _sb7l3::I64 = I64[R1 + 23];
           _sb7l6::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7l4::P64;
           P64[Hp - 32] = _sb7l5::P64;
           I64[Hp - 24] = _sb7l3::I64;
           I64[Hp - 16] = _sb7l6::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7ls_entry() //  [R1]
         { info_tbl: [(cb8nP,
                       label: sat_sb7ls_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8nP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb8nW; else goto cb8nX;
       cb8nW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8nX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb8nM_info;
           _sb7li::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7li::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8o1; else goto cb8nN;
       ub8o1: // global
           call _cb8nM(R1) args: 0, res: 0, upd: 0;
       cb8nN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb8nM() //  [R1]
         { info_tbl: [(cb8nM,
                       label: block_cb8nM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8nM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8o0; else goto cb8nZ;
       cb8o0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb8nZ: // global
           _sb7lm::P64 = P64[R1 + 7];
           _sb7ln::P64 = P64[R1 + 15];
           _sb7ll::I64 = I64[R1 + 23];
           _sb7lo::I64 = I64[R1 + 31];
           _sb7lq::I64 = I64[R1 + 47];
           _sb7lr::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7lm::P64;
           P64[Hp - 32] = _sb7ln::P64;
           I64[Hp - 24] = _sb7ll::I64;
           I64[Hp - 16] = _sb7lo::I64;
           I64[Hp - 8] = _sb7lr::I64;
           I64[Hp] = _sb7lq::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7lN_entry() //  [R1, R2]
         { info_tbl: [(cb8o2,
                       label: sat_sb7lN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8o2: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb8o3; else goto cb8o4;
       cb8o3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8o4: // global
           I64[Sp - 24] = block_cb8mN_info;
           _sb7k5::P64 = P64[R1 + 6];
           _sb7ka::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sb7k5::P64;
           P64[Sp - 8] = _sb7ka::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8py; else goto cb8mO;
       ub8py: // global
           call _cb8mN(R1) args: 0, res: 0, upd: 0;
       cb8mO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8mN() //  [R1]
         { info_tbl: [(cb8mN,
                       label: block_cb8mN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8mN: // global
           I64[Sp - 40] = block_cb8mS_info;
           _sb7kd::P64 = R1;
           _sb7kj::P64 = P64[R1 + 47];
           _sb7kl::P64 = P64[R1 + 63];
           _sb7km::P64 = P64[R1 + 71];
           _sb7kp::P64 = P64[R1 + 95];
           R1 = P64[_sb7km::P64 + 8];
           P64[Sp - 32] = _sb7kj::P64;
           P64[Sp - 24] = _sb7kl::P64;
           P64[Sp - 16] = _sb7km::P64;
           P64[Sp - 8] = _sb7kp::P64;
           P64[Sp] = _sb7kd::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8po; else goto cb8mT;
       ub8po: // global
           call _cb8mS(R1) args: 0, res: 0, upd: 0;
       cb8mT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8mS() //  [R1]
         { info_tbl: [(cb8mS,
                       label: block_cb8mS_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8mS: // global
           I64[Sp - 16] = block_cb8mZ_info;
           _sb7kC::I64 = I64[R1 + 39];
           _sb7kD::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sb7kD::I64;
           I64[Sp] = _sb7kC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub8pp; else goto cb8n0;
       ub8pp: // global
           call _cb8mZ(R1) args: 0, res: 0, upd: 0;
       cb8n0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8mZ() //  [R1]
         { info_tbl: [(cb8mZ,
                       label: block_cb8mZ_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8mZ: // global
           if (R1 & 7 == 1) goto cb8p2; else goto ub8pj;
       cb8p2: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ub8pk; else goto cb8oo;
       ub8pk: // global
           Sp = Sp + 24;
           goto ub8ps;
       cb8oo: // global
           _sb7kV::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cb8n7_info;
           R1 = _sb7kV::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub8pq; else goto cb8n8;
       ub8pq: // global
           call _cb8n7(R1) args: 0, res: 0, upd: 0;
       cb8n8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub8pj: // global
           Sp = Sp + 24;
           goto ub8ps;
       ub8ps: // global
           call _sb7kE() args: 0, res: 0, upd: 0;
     }
 },
 _cb8n7() //  [R1]
         { info_tbl: [(cb8n7,
                       label: block_cb8n7_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8n7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8or; else goto cb8oq;
       cb8or: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8oq: // global
           _sb7km::P64 = P64[Sp + 24];
           _sb7kX::P64 = P64[R1 + 7];
           _sb7kY::P64 = P64[R1 + 15];
           _sb7l1::P64 = P64[_sb7km::P64 + 8];
           I64[Hp - 16] = sat_sb7l9_info;
           P64[Hp] = _sb7l1::P64;
           call MO_WriteBarrier();
           P64[_sb7km::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7km::P64);
           I64[Sp] = block_cb8nw_info;
           R1 = _sb7l1::P64;
           P64[Sp + 16] = _sb7kY::P64;
           P64[Sp + 24] = _sb7kX::P64;
           if (R1 & 7 != 0) goto ub8pt; else goto cb8nx;
       ub8pt: // global
           call _cb8nw(R1) args: 0, res: 0, upd: 0;
       cb8nx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8nw() //  [R1]
         { info_tbl: [(cb8nw,
                       label: block_cb8nw_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8nw: // global
           _sb7li::I64 = I64[R1 + 39];
           if (_sb7li::I64 != 0) goto cb8ou; else goto cb8oZ;
       cb8ou: // global
           I64[Sp - 24] = block_cb8nD_info;
           _sb7ld::P64 = P64[R1 + 7];
           _sb7le::P64 = P64[R1 + 15];
           _sb7lc::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sb7le::P64;
           I64[Sp - 8] = _sb7li::I64;
           P64[Sp] = _sb7ld::P64;
           I64[Sp + 32] = _sb7lc::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8pu; else goto cb8nE;
       ub8pu: // global
           call _cb8nD(R1) args: 0, res: 0, upd: 0;
       cb8nE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8oZ: // global
           _sb7kj::P64 = P64[Sp + 8];
           _sb7kY::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sb7kj::P64 + 8] = _sb7kY::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7kj::P64);
           Sp = Sp + 8;
           call _sb7kE() args: 0, res: 0, upd: 0;
     }
 },
 _cb8nD() //  [R1]
         { info_tbl: [(cb8nD,
                       label: block_cb8nD_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8nD: // global
           if (R1 & 7 == 1) goto cb8ow; else goto cb8oO;
       cb8ow: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb8oz; else goto cb8oy;
       cb8oz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8oy: // global
           I64[Hp - 24] = sat_sb7ls_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sb7kj::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sb7kj::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7kj::P64);
           Sp = Sp + 32;
           call _sb7kE() args: 0, res: 0, upd: 0;
       cb8oO: // global
           I64[Sp] = block_cb8oC_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub8pw; else goto cb8oD;
       ub8pw: // global
           call _cb8oC(R1) args: 0, res: 0, upd: 0;
       cb8oD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8oC() //  [R1]
         { info_tbl: [(cb8oC,
                       label: block_cb8oC_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8oC: // global
           I64[Sp - 8] = block_cb8oH_info;
           R2 = P64[Sp + 48];
           _sb7lw::P64 = P64[R1 + 7];
           _sb7lx::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sb7lx::P64;
           P64[Sp + 48] = _sb7lw::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8oH() //  [R1]
         { info_tbl: [(cb8oH,
                       label: block_cb8oH_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8oH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8oS; else goto cb8oR;
       cb8oS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8oR: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cb8oK_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8oK() //  [R1]
         { info_tbl: [(cb8oK,
                       label: block_cb8oK_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8oK: // global
           I64[Sp] = block_cb8oM_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8pz; else goto cb8oU;
       ub8pz: // global
           call _cb8oM(R1) args: 0, res: 0, upd: 0;
       cb8oU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8oM() //  [R1]
         { info_tbl: [(cb8oM,
                       label: block_cb8oM_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8oM: // global
           _sb7kj::P64 = P64[Sp + 8];
           _sb7lJ::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sb7kj::P64 + 8] = _sb7lJ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7kj::P64);
           Sp = Sp + 8;
           call _sb7kE() args: 0, res: 0, upd: 0;
     }
 },
 _sb7kE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7kE: // global
           _sb7kI::P64 = P64[P64[Sp] + 8];
           I64[Sp + 24] = block_cb8oa_info;
           R1 = _sb7kI::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ub8pB; else goto cb8oc;
       ub8pB: // global
           call _cb8oa(R1) args: 0, res: 0, upd: 0;
       cb8oc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8oa() //  [R1]
         { info_tbl: [(cb8oa,
                       label: block_cb8oa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8oa: // global
           _sb7k5::P64 = P64[Sp + 16];
           _sb7ka::P64 = P64[Sp + 24];
           _sb7kd::P64 = P64[Sp + 8];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb8ol; else goto cb8ok;
       cb8ol: // global
           R6 = _sb7ka::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7k5::P64;
           R3 = R1;
           R2 = _sb7kd::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.hGetBuf2_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cb8ok: // global
           R6 = _sb7ka::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7k5::P64;
           R3 = R1;
           R2 = _sb7kd::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.hGetBuf4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub8pN_srtd" {
     ub8pN_srtd:
         const Sb7vQ_srt+8;
         const 51;
         const 2111062325331969;
 },
 GHC.IO.Handle.Text.$whGetBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8pF,
                       label: GHC.IO.Handle.Text.$whGetBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8pF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb8pJ; else goto cb8pI;
       cb8pJ: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBuf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8pI: // global
           if (R4 == 0) goto cb8pE; else goto cb8pD;
       cb8pE: // global
           Hp = Hp - 40;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8pD: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cb8pL; else goto cb8pM;
       cb8pL: // global
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sb7lN_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 31;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetBuf5_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cb8pM: // global
           Hp = Hp - 40;
           R4 = R4;
           R3 = GHC.IO.Handle.Text.hGetBuf5_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.939025525 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf1_closure" {
     GHC.IO.Handle.Text.hGetBuf1_closure:
         const GHC.IO.Handle.Text.hGetBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8pV,
                       label: GHC.IO.Handle.Text.hGetBuf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8pV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8pW; else goto cb8pX;
       cb8pW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8pX: // global
           I64[Sp - 24] = block_cb8pS_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8q1; else goto cb8pT;
       ub8q1: // global
           call _cb8pS(R1) args: 0, res: 0, upd: 0;
       cb8pT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8pS() //  [R1]
         { info_tbl: [(cb8pS,
                       label: block_cb8pS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8pS: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBuf_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.940205451 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf_closure" {
     GHC.IO.Handle.Text.hGetBuf_closure:
         const GHC.IO.Handle.Text.hGetBuf_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8q6,
                       label: GHC.IO.Handle.Text.hGetBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8q6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBuf1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.940935547 UTC

[section ""cstring" . lvl14_rb6WU_bytes" {
     lvl14_rb6WU_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.941772219 UTC

[section ""data" . lvl15_rb6WV_closure" {
     lvl15_rb6WV_closure:
         const lvl15_rb6WV_info;
         const 0;
         const 0;
         const 0;
 },
 lvl15_rb6WV_entry() //  [R1]
         { info_tbl: [(cb8qf,
                       label: lvl15_rb6WV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8qf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8qg; else goto cb8qh;
       cb8qg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8qh: // global
           (_cb8qc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8qc::I64 == 0) goto cb8qe; else goto cb8qd;
       cb8qe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8qd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8qc::I64;
           R2 = lvl14_rb6WU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.942778366 UTC

[section ""data" . lvl16_rb6WW_closure" {
     lvl16_rb6WW_closure:
         const lvl16_rb6WW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_rb6WW_entry() //  [R1]
         { info_tbl: [(cb8qo,
                       label: lvl16_rb6WW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8qo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8qp; else goto cb8qq;
       cb8qp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8qq: // global
           (_cb8ql::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8ql::I64 == 0) goto cb8qn; else goto cb8qm;
       cb8qn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8qm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8ql::I64;
           R2 = GHC.IO.Handle.Text.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.943771556 UTC

[section ""data" . lvl17_rb6WX_closure" {
     lvl17_rb6WX_closure:
         const lvl17_rb6WX_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rb6WX_entry() //  [R1]
         { info_tbl: [(cb8qx,
                       label: lvl17_rb6WX_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8qx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8qy; else goto cb8qz;
       cb8qy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8qz: // global
           (_cb8qu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8qu::I64 == 0) goto cb8qw; else goto cb8qv;
       cb8qw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8qv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8qu::I64;
           R2 = GHC.IO.Handle.Text.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.944654512 UTC

[section ""cstring" . lvl18_rb6WY_bytes" {
     lvl18_rb6WY_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,84,101,120,116,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.945363833 UTC

[section ""data" . lvl19_rb6WZ_closure" {
     lvl19_rb6WZ_closure:
         const lvl19_rb6WZ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rb6WZ_entry() //  [R1]
         { info_tbl: [(cb8qG,
                       label: lvl19_rb6WZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8qG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8qH; else goto cb8qI;
       cb8qH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8qI: // global
           (_cb8qD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8qD::I64 == 0) goto cb8qF; else goto cb8qE;
       cb8qF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8qE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8qD::I64;
           R2 = lvl18_rb6WY_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.946204401 UTC

[section ""data" . lvl20_rb6X0_closure" {
     lvl20_rb6X0_closure:
         const GHC.Types.I#_con_info;
         const 785;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.94677565 UTC

[section ""data" . lvl21_rb6X1_closure" {
     lvl21_rb6X1_closure:
         const GHC.Types.I#_con_info;
         const 17;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.947328826 UTC

[section ""data" . lvl22_rb6X2_closure" {
     lvl22_rb6X2_closure:
         const GHC.Types.I#_con_info;
         const 38;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.947853149 UTC

[section ""data" . lvl23_rb6X3_closure" {
     lvl23_rb6X3_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl16_rb6WW_closure;
         const lvl17_rb6WX_closure;
         const lvl19_rb6WZ_closure;
         const lvl20_rb6X0_closure+1;
         const lvl21_rb6X1_closure+1;
         const lvl20_rb6X0_closure+1;
         const lvl22_rb6X2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.94847389 UTC

[section ""data" . lvl24_rb6X4_closure" {
     lvl24_rb6X4_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl15_rb6WV_closure;
         const lvl23_rb6X3_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.949031065 UTC

[section ""cstring" . lvl25_rb6X5_bytes" {
     lvl25_rb6X5_bytes:
         I8[] [84,111,100,111,58,32,104,80,117,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.94986914 UTC

[section ""data" . lvl26_rb6X6_closure" {
     lvl26_rb6X6_closure:
         const lvl26_rb6X6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_rb6X6_entry() //  [R1]
         { info_tbl: [(cb8qR,
                       label: lvl26_rb6X6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8qR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8qS; else goto cb8qT;
       cb8qS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8qT: // global
           (_cb8qM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8qM::I64 == 0) goto cb8qO; else goto cb8qN;
       cb8qO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8qN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8qM::I64;
           I64[Sp - 24] = block_cb8qP_info;
           R2 = lvl25_rb6X5_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb8qP() //  [R1]
         { info_tbl: [(cb8qP,
                       label: block_cb8qP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8qP: // global
           R3 = R1;
           R2 = lvl24_rb6X4_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.950871356 UTC

[section ""data" . lvl27_rb6X7_closure" {
     lvl27_rb6X7_closure:
         const GHC.Types.I#_con_info;
         const 790;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.951398625 UTC

[section ""data" . lvl28_rb6X8_closure" {
     lvl28_rb6X8_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl16_rb6WW_closure;
         const lvl17_rb6WX_closure;
         const lvl19_rb6WZ_closure;
         const lvl27_rb6X7_closure+1;
         const lvl21_rb6X1_closure+1;
         const lvl27_rb6X7_closure+1;
         const lvl22_rb6X2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.951970771 UTC

[section ""data" . lvl29_rb6X9_closure" {
     lvl29_rb6X9_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl15_rb6WV_closure;
         const lvl28_rb6X8_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.952752118 UTC

[section ""data" . lvl30_rb6Xa_closure" {
     lvl30_rb6Xa_closure:
         const lvl30_rb6Xa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_rb6Xa_entry() //  [R1]
         { info_tbl: [(cb8r5,
                       label: lvl30_rb6Xa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8r5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8r6; else goto cb8r7;
       cb8r6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8r7: // global
           (_cb8r0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8r0::I64 == 0) goto cb8r2; else goto cb8r1;
       cb8r2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8r1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8r0::I64;
           I64[Sp - 24] = block_cb8r3_info;
           R2 = lvl25_rb6X5_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb8r3() //  [R1]
         { info_tbl: [(cb8r3,
                       label: block_cb8r3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8r3: // global
           R3 = R1;
           R2 = lvl29_rb6X9_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.956184981 UTC

[section ""data" . GHC.IO.Handle.Text.$wbufWrite_closure" {
     GHC.IO.Handle.Text.$wbufWrite_closure:
         const GHC.IO.Handle.Text.$wbufWrite_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wbufWrite_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8rc: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wbufWrite_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub8ud_srtd" {
     ub8ud_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 17451452851027969;
 },
 GHC.IO.Handle.Text.$wbufWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb8rj,
                       label: GHC.IO.Handle.Text.$wbufWrite_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8rj: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cb8rr; else goto ub8tZ;
       cb8rr: // global
           R1 = GHC.IO.Handle.Text.$wbufWrite_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ub8tZ: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _cb8rd() args: 0, res: 0, upd: 0;
     }
 },
 _cb8rd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8rd: // global
           _sb7lW::P64 = P64[Sp];
           I64[Sp] = block_cb8rg_info;
           R1 = _sb7lW::P64;
           if (R1 & 7 != 0) goto ub8u3; else goto cb8rh;
       ub8u3: // global
           call _cb8rg(R1) args: 0, res: 0, upd: 0;
       cb8rh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8ue_srtd" {
     ub8ue_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb8rg() //  [R1]
         { info_tbl: [(cb8rg,
                       label: block_cb8rg_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8rg: // global
           I64[Sp - 32] = block_cb8rm_info;
           _sb7m1::P64 = R1;
           _sb7m3::P64 = P64[R1 + 15];
           _sb7m4::P64 = P64[R1 + 23];
           _sb7m7::P64 = P64[R1 + 47];
           R1 = P64[R1 + 31];
           P64[Sp - 24] = _sb7m3::P64;
           P64[Sp - 16] = _sb7m4::P64;
           P64[Sp - 8] = _sb7m7::P64;
           P64[Sp] = _sb7m1::P64;
           Sp = Sp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8uf_srtd" {
     ub8uf_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb8rm() //  [R1]
         { info_tbl: [(cb8rm,
                       label: block_cb8rm_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8rm: // global
           _sb7mn::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 24] = block_cb8rq_info;
           _sb7mi::P64 = R1;
           _sb7mj::I64 = I64[R1 + 7];
           _sb7mk::I64 = I64[R1 + 15];
           R1 = _sb7mn::P64;
           I64[Sp - 16] = _sb7mj::I64;
           I64[Sp - 8] = _sb7mk::I64;
           P64[Sp] = _sb7mi::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8u5; else goto cb8rv;
       ub8u5: // global
           call _cb8rq(R1) args: 0, res: 0, upd: 0;
       cb8rv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8ug_srtd" {
     ub8ug_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb8rq() //  [R1]
         { info_tbl: [(cb8rq,
                       label: block_cb8rq_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8rq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb8rB; else goto cb8rA;
       cb8rB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8rA: // global
           _sb7mq::P64 = P64[R1 + 7];
           _sb7mr::P64 = P64[R1 + 15];
           _sb7mp::I64 = I64[R1 + 23];
           _sb7ms::I64 = I64[R1 + 31];
           _sb7mt::I64 = I64[R1 + 39];
           _sb7mu::I64 = I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _sb7lY::I64 = I64[Sp + 72];
           I64[Hp] = _sb7lY::I64;
           _sb7m3::P64 = P64[Sp + 32];
           _sb7mi::P64 = P64[Sp + 24];
           _sb7mo::P64 = R1;
           _cb8rC::P64 = Hp - 7;
           if (%MO_S_Ge_W64(_sb7lY::I64,
                            _sb7ms::I64)) goto sb7mw; else goto cb8tI;
       cb8tI: // global
           if (%MO_S_Gt_W64(_sb7lY::I64,
                            _sb7ms::I64 - _sb7mu::I64)) goto sb7mw; else goto cb8t8;
       sb7mw: // global
           if (%MO_S_Le_W64(_sb7mu::I64, 0)) goto ub8u0; else goto cb8sP;
       ub8u0: // global
           I64[Sp + 32] = _sb7ms::I64;
           P64[Sp + 48] = _cb8rC::P64;
           Sp = Sp + 8;
           call _sb7mx() args: 0, res: 0, upd: 0;
       cb8sP: // global
           I64[Sp] = block_cb8sO_info;
           R2 = _sb7m3::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sb7mi::P64;
           P64[Sp - 8] = _sb7mo::P64;
           I64[Sp + 24] = _sb7ms::I64;
           P64[Sp + 32] = _cb8rC::P64;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cb8t8: // global
           I64[Sp - 8] = block_cb8t7_info;
           R1 = P64[Sp + 64];
           I64[Sp] = _sb7mu::I64;
           I64[Sp + 8] = _sb7mt::I64;
           I64[Sp + 16] = _sb7ms::I64;
           P64[Sp + 40] = _sb7mr::P64;
           P64[Sp + 56] = _sb7mq::P64;
           I64[Sp + 64] = _sb7mp::I64;
           P64[Sp + 80] = _cb8rC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8u6; else goto cb8t9;
       ub8u6: // global
           call _cb8t7(R1) args: 0, res: 0, upd: 0;
       cb8t9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8uh_srtd" {
     ub8uh_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb8sO() //  [R1]
         { info_tbl: [(cb8sO,
                       label: block_cb8sO_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8sO: // global
           _cb8rC::P64 = P64[Sp + 32];
           _sb7m7::P64 = P64[Sp + 48];
           _sb7ms::I64 = I64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sb7m7::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7m7::P64);
           P64[Sp + 48] = _cb8rC::P64;
           I64[Sp + 32] = _sb7ms::I64;
           Sp = Sp + 8;
           call _sb7mx() args: 0, res: 0, upd: 0;
     }
 },
 _sb7mx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7mx: // global
           _sb7lY::I64 = I64[Sp + 64];
           _sb7lZ::P64 = P64[Sp + 72];
           if (%MO_S_Ge_W64(_sb7lY::I64,
                            I64[Sp + 24])) goto cb8rU; else goto cb8sH;
       cb8rU: // global
           I64[Sp - 8] = block_cb8rS_info;
           R1 = _sb7lZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8ub; else goto cb8rV;
       ub8ub: // global
           call _cb8rS(R1) args: 0, res: 0, upd: 0;
       cb8rV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8sH: // global
           P64[Sp + 48] = P64[Sp + 48];
           P64[Sp + 56] = P64[Sp + 56];
           I64[Sp + 64] = _sb7lY::I64;
           P64[Sp + 72] = _sb7lZ::P64;
           Sp = Sp + 48;
           call _cb8rd() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub8ui_srtd" {
     ub8ui_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb8rS() //  [R1]
         { info_tbl: [(cb8rS,
                       label: block_cb8rS_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8rS: // global
           _sb7m4::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cb8s2; else goto cb8sn;
       cb8s2: // global
           I64[Sp] = block_cb8rZ_info;
           R3 = lvl11_rb6WR_closure;
           R2 = _sb7m4::P64;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
       cb8sn: // global
           I64[Sp] = block_cb8sl_info;
           R3 = lvl11_rb6WR_closure;
           R2 = _sb7m4::P64;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8rZ() //  [R1]
         { info_tbl: [(cb8rZ,
                       label: block_cb8rZ_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8rZ: // global
           if (R1 & 7 == 1) goto cb8s8; else goto cb8sd;
       cb8s8: // global
           R1 = lvl30_rb6Xa_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cb8sd: // global
           I64[Sp] = block_cb8sb_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto ub8u8; else goto cb8se;
       ub8u8: // global
           call _cb8sb(R1) args: 0, res: 0, upd: 0;
       cb8se: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8sb() //  [R1]
         { info_tbl: [(cb8sb,
                       label: block_cb8sb_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8sb: // global
           R5 = I64[Sp + 72];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 88;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb8sl() //  [R1]
         { info_tbl: [(cb8sl,
                       label: block_cb8sl_info
                       rep:StackRep [True, True, True, True, True, False, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8sl: // global
           if (R1 & 7 == 1) goto cb8st; else goto cb8sD;
       cb8st: // global
           R1 = lvl26_rb6X6_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cb8sD: // global
           I64[Sp] = block_cb8sw_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto ub8u9; else goto cb8sx;
       ub8u9: // global
           call _cb8sw(R1) args: 0, res: 0, upd: 0;
       cb8sx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8sw() //  [R1]
         { info_tbl: [(cb8sw,
                       label: block_cb8sw_info
                       rep:StackRep [True, True, True, True, True, False, True, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8sw: // global
           I64[Sp + 40] = block_cb8sB_info;
           R5 = I64[Sp + 72];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 40;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8sB() //  []
         { info_tbl: [(cb8sB,
                       label: block_cb8sB_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8sB: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8t7() //  [R1]
         { info_tbl: [(cb8t7,
                       label: block_cb8t7_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8t7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8tf; else goto cb8te;
       cb8tf: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8te: // global
           _cb8rC::P64 = P64[Sp + 88];
           _sb7lY::I64 = I64[Sp + 80];
           _sb7m3::P64 = P64[Sp + 40];
           _sb7m7::P64 = P64[Sp + 56];
           _sb7mp::I64 = I64[Sp + 72];
           _sb7mq::P64 = P64[Sp + 64];
           _sb7mr::P64 = P64[Sp + 48];
           _sb7ms::I64 = I64[Sp + 24];
           _sb7mt::I64 = I64[Sp + 16];
           _sb7mu::I64 = I64[Sp + 8];
           (_sb7n1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sb7mp::I64 + _sb7mu::I64, I64[R1 + 7], _sb7lY::I64);
           call MO_Touch(_sb7mq::P64);
           if (_sb7lY::I64 == _sb7ms::I64 - _sb7mu::I64) goto cb8tF; else goto cb8tx;
       cb8tF: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7mq::P64;
           P64[Hp - 32] = _sb7mr::P64;
           I64[Hp - 24] = _sb7mp::I64;
           I64[Hp - 16] = _sb7ms::I64;
           I64[Hp - 8] = _sb7mt::I64;
           I64[Hp] = _sb7mu::I64 + _sb7lY::I64;
           I64[Sp + 48] = block_cb8tE_info;
           R2 = _sb7m3::P64;
           I64[Sp + 24] = stg_ap_ppv_info;
           P64[Sp + 40] = Hp - 47;
           Sp = Sp + 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cb8tx: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7mq::P64;
           P64[Hp - 32] = _sb7mr::P64;
           I64[Hp - 24] = _sb7mp::I64;
           I64[Hp - 16] = _sb7ms::I64;
           I64[Hp - 8] = _sb7mt::I64;
           I64[Hp] = _sb7mu::I64 + _sb7lY::I64;
           call MO_WriteBarrier();
           P64[_sb7m7::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7m7::P64);
           R1 = _cb8rC::P64;
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8tE() //  [R1]
         { info_tbl: [(cb8tE,
                       label: block_cb8tE_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8tE: // global
           _cb8rC::P64 = P64[Sp + 40];
           _sb7m7::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7m7::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7m7::P64);
           R1 = _cb8rC::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.961613362 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutBuf4_bytes" {
     GHC.IO.Handle.Text.hPutBuf4_bytes:
         I8[] [104,80,117,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.962337638 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf3_closure" {
     GHC.IO.Handle.Text.hPutBuf3_closure:
         const GHC.IO.Handle.Text.hPutBuf3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf3_entry() //  [R1]
         { info_tbl: [(cb8up,
                       label: GHC.IO.Handle.Text.hPutBuf3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8up: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8uq; else goto cb8ur;
       cb8uq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8ur: // global
           (_cb8um::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8um::I64 == 0) goto cb8uo; else goto cb8un;
       cb8uo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8un: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8um::I64;
           R2 = GHC.IO.Handle.Text.hPutBuf4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.964681566 UTC

[section ""data" . GHC.IO.Handle.Text.$whPutBuf'_closure" {
     GHC.IO.Handle.Text.$whPutBuf'_closure:
         const GHC.IO.Handle.Text.$whPutBuf'_info;
         const 0;
 },
 GHC.IO.Handle.Text.$whPutBuf'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ut: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 act_sb7nl_entry() //  [R1, R2]
         { info_tbl: [(cb8uK,
                       label: act_sb7nl_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8uK: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb8uL; else goto cb8uM;
       cb8uL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8uM: // global
           I64[Sp - 32] = block_cb8uH_info;
           _sb7nf::P64 = P64[R1 + 6];
           _sb7nh::P64 = P64[R1 + 14];
           _sb7nj::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb7nf::P64;
           P64[Sp - 16] = _sb7nh::P64;
           I64[Sp - 8] = _sb7nj::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8vK; else goto cb8uI;
       ub8vK: // global
           call _cb8uH(R1) args: 0, res: 0, upd: 0;
       cb8uI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8uH() //  [R1]
         { info_tbl: [(cb8uH,
                       label: block_cb8uH_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8uH: // global
           I64[Sp - 8] = block_cb8uP_info;
           R5 = P64[Sp + 16];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = R1;
           P64[Sp] = P64[R1 + 55];
           P64[Sp + 8] = P64[R1 + 47];
           P64[Sp + 16] = P64[R1 + 31];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$wbufWrite_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8uP() //  [R1]
         { info_tbl: [(cb8uP,
                       label: block_cb8uP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8uP: // global
           I64[Sp] = block_cb8uR_info;
           _sb7nH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sb7nH::P64;
           if (R1 & 7 != 0) goto ub8vL; else goto cb8uU;
       ub8vL: // global
           call _cb8uR(R1) args: 0, res: 0, upd: 0;
       cb8uU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8uR() //  [R1]
         { info_tbl: [(cb8uR,
                       label: block_cb8uR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8uR: // global
           if (R1 & 7 == 3) goto ub8vH; else goto cb8v1;
       ub8vH: // global
           Sp = Sp + 8;
           call _cb8vB() args: 0, res: 0, upd: 0;
       cb8v1: // global
           _sb7nL::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cb8uY_info;
           R1 = _sb7nL::P64;
           if (R1 & 7 != 0) goto ub8vM; else goto cb8v2;
       ub8vM: // global
           call _cb8uY(R1) args: 0, res: 0, upd: 0;
       cb8v2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8uY() //  [R1]
         { info_tbl: [(cb8uY,
                       label: block_cb8uY_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8uY: // global
           I64[Sp] = block_cb8v6_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ub8vO; else goto cb8v8;
       ub8vO: // global
           call _cb8v6(R1) args: 0, res: 0, upd: 0;
       cb8v8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8v6() //  [R1]
         { info_tbl: [(cb8v6,
                       label: block_cb8v6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8v6: // global
           if (R1 & 7 == 1) goto ub8vI; else goto cb8vj;
       ub8vI: // global
           Sp = Sp + 8;
           call _cb8vB() args: 0, res: 0, upd: 0;
       cb8vj: // global
           _sb7nW::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cb8vh_info;
           R1 = _sb7nW::P64;
           if (R1 & 7 != 0) goto ub8vP; else goto cb8vk;
       ub8vP: // global
           call _cb8vh(R1) args: 0, res: 0, upd: 0;
       cb8vk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8vh() //  [R1]
         { info_tbl: [(cb8vh,
                       label: block_cb8vh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8vh: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ub8vJ; else goto cb8vu;
       ub8vJ: // global
           Sp = Sp + 8;
           call _cb8vB() args: 0, res: 0, upd: 0;
       cb8vu: // global
           I64[Sp] = block_cb8vs_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb8vB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8vB: // global
           R1 = P64[Sp];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8vs() //  [R1]
         { info_tbl: [(cb8vs,
                       label: block_cb8vs_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8vs: // global
           _sb7nu::P64 = P64[Sp + 16];
           _sb7nH::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7nu::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7nu::P64);
           R1 = _sb7nH::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub8wh_srtd" {
     ub8wh_srtd:
         const Sb7vQ_srt+8;
         const 62;
         const 3602879701896396803;
 },
 GHC.IO.Handle.Text.$whPutBuf'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb8vV,
                       label: GHC.IO.Handle.Text.$whPutBuf'_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8vV: // global
           _sb7nh::P64 = R5;
           _sb7ng::I64 = R4;
           _sb7nf::P64 = R3;
           _sb7ne::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cb8vW; else goto cb8vX;
       cb8vX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb8vZ; else goto cb8vY;
       cb8vZ: // global
           HpAlloc = 32;
           goto cb8vW;
       cb8vW: // global
           R1 = GHC.IO.Handle.Text.$whPutBuf'_closure;
           P64[Sp - 32] = _sb7ne::P64;
           P64[Sp - 24] = _sb7nf::P64;
           I64[Sp - 16] = _sb7ng::I64;
           P64[Sp - 8] = _sb7nh::P64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cb8vY: // global
           if (_sb7ng::I64 == 0) goto cb8vU; else goto cb8vT;
       cb8vU: // global
           Hp = Hp - 32;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8vT: // global
           if (%MO_S_Ge_W64(_sb7ng::I64, 0)) goto cb8w2; else goto cb8we;
       cb8w2: // global
           I64[Hp - 24] = act_sb7nl_info;
           P64[Hp - 16] = _sb7nf::P64;
           P64[Hp - 8] = _sb7nh::P64;
           I64[Hp] = _sb7ng::I64;
           I64[Sp - 16] = block_cb8w0_info;
           R1 = _sb7ne::P64;
           P64[Sp - 8] = Hp - 22;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub8wg; else goto cb8w3;
       ub8wg: // global
           call _cb8w0(R1) args: 0, res: 0, upd: 0;
       cb8w3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8we: // global
           Hp = Hp - 32;
           R4 = _sb7ng::I64;
           R3 = GHC.IO.Handle.Text.hPutBuf3_closure;
           R2 = _sb7ne::P64;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub8wi_srtd" {
     ub8wi_srtd:
         const Sb7vQ_srt+16;
         const 61;
         const 1152921504606846977;
 },
 _cb8w0() //  [R1]
         { info_tbl: [(cb8w0,
                       label: block_cb8w0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8w0: // global
           _cb8uC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cb8w9; else goto cb8wd;
       cb8w9: // global
           R5 = _cb8uC::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutBuf3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cb8wd: // global
           R5 = _cb8uC::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutBuf3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.969028642 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf2_closure" {
     GHC.IO.Handle.Text.hPutBuf2_closure:
         const GHC.IO.Handle.Text.hPutBuf2_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb8wq,
                       label: GHC.IO.Handle.Text.hPutBuf2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8wq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb8wr; else goto cb8ws;
       cb8wr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBuf2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8ws: // global
           I64[Sp - 32] = block_cb8wn_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8ww; else goto cb8wo;
       ub8ww: // global
           call _cb8wn(R1) args: 0, res: 0, upd: 0;
       cb8wo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8wn() //  [R1]
         { info_tbl: [(cb8wn,
                       label: block_cb8wn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8wn: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.970362752 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBufNonBlocking1_closure" {
     GHC.IO.Handle.Text.hPutBufNonBlocking1_closure:
         const GHC.IO.Handle.Text.hPutBufNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBufNonBlocking1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8wE,
                       label: GHC.IO.Handle.Text.hPutBufNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8wE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8wF; else goto cb8wG;
       cb8wF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBufNonBlocking1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8wG: // global
           I64[Sp - 24] = block_cb8wB_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8wK; else goto cb8wC;
       ub8wK: // global
           call _cb8wB(R1) args: 0, res: 0, upd: 0;
       cb8wC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8wB() //  [R1]
         { info_tbl: [(cb8wB,
                       label: block_cb8wB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8wB: // global
           R5 = GHC.Types.False_closure+1;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.971516408 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBufNonBlocking_closure" {
     GHC.IO.Handle.Text.hPutBufNonBlocking_closure:
         const GHC.IO.Handle.Text.hPutBufNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8wP,
                       label: GHC.IO.Handle.Text.hPutBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8wP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutBufNonBlocking1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.972520776 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf1_closure" {
     GHC.IO.Handle.Text.hPutBuf1_closure:
         const GHC.IO.Handle.Text.hPutBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8wZ,
                       label: GHC.IO.Handle.Text.hPutBuf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8wZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8x3; else goto cb8x4;
       cb8x3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBuf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8x4: // global
           I64[Sp - 24] = block_cb8wW_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8x8; else goto cb8wX;
       ub8x8: // global
           call _cb8wW(R1) args: 0, res: 0, upd: 0;
       cb8wX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8wW() //  [R1]
         { info_tbl: [(cb8wW,
                       label: block_cb8wW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8wW: // global
           _sb7ou::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cb8x2_info;
           R5 = GHC.Types.True_closure+2;
           R4 = I64[R1 + 7];
           R3 = _sb7ou::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8x2() //  []
         { info_tbl: [(cb8x2,
                       label: block_cb8x2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8x2: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.973849962 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf_closure" {
     GHC.IO.Handle.Text.hPutBuf_closure:
         const GHC.IO.Handle.Text.hPutBuf_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8xd,
                       label: GHC.IO.Handle.Text.hPutBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8xd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutBuf1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.974582363 UTC

[section ""cstring" . lvl31_rb6Xb_bytes" {
     lvl31_rb6Xb_bytes:
         I8[] [10]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.975335727 UTC

[section ""data" . lvl32_rb6Xc_closure" {
     lvl32_rb6Xc_closure:
         const lvl32_rb6Xc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl32_rb6Xc_entry() //  [R1]
         { info_tbl: [(cb8xm,
                       label: lvl32_rb6Xc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8xm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8xn; else goto cb8xo;
       cb8xn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8xo: // global
           (_cb8xj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8xj::I64 == 0) goto cb8xl; else goto cb8xk;
       cb8xl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8xk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8xj::I64;
           R2 = lvl31_rb6Xb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.980137992 UTC

[section ""data" . GHC.IO.Handle.Text.$wwriteBlocks_closure" {
     GHC.IO.Handle.Text.$wwriteBlocks_closure:
         const GHC.IO.Handle.Text.$wwriteBlocks_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wwriteBlocks_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8xq: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sb7r5_entry() //  [R1]
         { info_tbl: [(cb8xF,
                       label: sat_sb7r5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8xF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb8xG; else goto cb8xH;
       cb8xG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8xH: // global
           I64[Sp - 8] = block_cb8xy_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8xO; else goto cb8xz;
       ub8xO: // global
           call _cb8xy(R1) args: 0, res: 0, upd: 0;
       cb8xz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8xy() //  [R1]
         { info_tbl: [(cb8xy,
                       label: block_cb8xy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8xy: // global
           if (R1 & 7 == 1) goto cb8xC; else goto cb8xD;
       cb8xC: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8xD: // global
           R1 = lvl32_rb6Xc_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7pr_entry() //  [R1, R2]
         { info_tbl: [(cb8y3,
                       label: sat_sb7pr_info
                       rep:HeapRep 2 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8y3: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb8y9; else goto cb8ya;
       cb8y9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8ya: // global
           I64[Sp - 48] = block_cb8y0_info;
           _sb7oH::P64 = P64[R1 + 6];
           _sb7oO::P64 = P64[R1 + 14];
           _sb7oG::I64 = I64[R1 + 22];
           _sb7oI::I64 = I64[R1 + 30];
           _sb7oM::I64 = I64[R1 + 38];
           R1 = R2;
           I64[Sp - 40] = _sb7oG::I64;
           P64[Sp - 32] = _sb7oH::P64;
           I64[Sp - 24] = _sb7oI::I64;
           I64[Sp - 16] = _sb7oM::I64;
           P64[Sp - 8] = _sb7oO::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ub8yv; else goto cb8y1;
       ub8yv: // global
           call _cb8y0(R1) args: 0, res: 0, upd: 0;
       cb8y1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8y0() //  [R1]
         { info_tbl: [(cb8y0,
                       label: block_cb8y0_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8y0: // global
           _sb7oG::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cb8y6_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = _sb7oG::I64;
           R2 = R1;
           I64[Sp - 8] = 0;
           I64[Sp] = I64[Sp + 32];
           P64[Sp + 16] = P64[R1 + 79];
           P64[Sp + 32] = P64[R1 + 71];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb8y6() //  []
         { info_tbl: [(cb8y6,
                       label: block_cb8y6_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8y6: // global
           _sb7pd::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cb8y8_info;
           R1 = _sb7pd::P64;
           if (R1 & 7 != 0) goto ub8yw; else goto cb8yd;
       ub8yw: // global
           call _cb8y8(R1) args: 0, res: 0, upd: 0;
       cb8yd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8y8() //  [R1]
         { info_tbl: [(cb8y8,
                       label: block_cb8y8_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8y8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8yj; else goto cb8yi;
       cb8yj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8yi: // global
           if (I64[Sp + 16] == I64[R1 + 31]) goto cb8yo; else goto cb8yn;
       cb8yo: // global
           _sb7p1::P64 = P64[Sp + 8];
           _sb7po::P64 = P64[_sb7p1::P64 + 8];
           I64[Hp - 16] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sb7po::P64;
           call MO_WriteBarrier();
           P64[_sb7p1::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7p1::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8yn: // global
           Hp = Hp - 24;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7qq_entry() //  [R1, R2]
         { info_tbl: [(cb8zf,
                       label: sat_sb7qq_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8zf: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb8zl; else goto cb8zm;
       cb8zl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8zm: // global
           I64[Sp - 40] = block_cb8zc_info;
           _sb7oH::P64 = P64[R1 + 6];
           _sb7oG::I64 = I64[R1 + 14];
           _sb7oI::I64 = I64[R1 + 22];
           _sb7pN::I64 = I64[R1 + 30];
           R1 = R2;
           I64[Sp - 32] = _sb7oG::I64;
           P64[Sp - 24] = _sb7oH::P64;
           I64[Sp - 16] = _sb7oI::I64;
           I64[Sp - 8] = _sb7pN::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8zG; else goto cb8zd;
       ub8zG: // global
           call _cb8zc(R1) args: 0, res: 0, upd: 0;
       cb8zd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8zc() //  [R1]
         { info_tbl: [(cb8zc,
                       label: block_cb8zc_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8zc: // global
           _sb7oG::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cb8zi_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = _sb7oG::I64;
           R2 = R1;
           I64[Sp - 8] = 0;
           I64[Sp] = I64[Sp + 32];
           P64[Sp + 16] = P64[R1 + 47];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb8zi() //  []
         { info_tbl: [(cb8zi,
                       label: block_cb8zi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8zi: // global
           _sb7qd::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_cb8zk_info;
           R1 = _sb7qd::P64;
           if (R1 & 7 != 0) goto ub8zH; else goto cb8zp;
       ub8zH: // global
           call _cb8zk(R1) args: 0, res: 0, upd: 0;
       cb8zp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8zk() //  [R1]
         { info_tbl: [(cb8zk,
                       label: block_cb8zk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8zk: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb8zC; else goto cb8zz;
       cb8zC: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8zz: // global
           I64[Sp] = block_cb8zx_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb8zx() //  [R1]
         { info_tbl: [(cb8zx,
                       label: block_cb8zx_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8zx: // global
           _sb7pX::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7pX::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7pX::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7r0_entry() //  [R1, R2]
         { info_tbl: [(cb8zR,
                       label: sat_sb7r0_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8zR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb8zV; else goto cb8zW;
       cb8zV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8zW: // global
           I64[Sp - 40] = block_cb8zO_info;
           _sb7oH::P64 = P64[R1 + 6];
           _sb7oG::I64 = I64[R1 + 14];
           _sb7oI::I64 = I64[R1 + 22];
           _sb7pt::I64 = I64[R1 + 30];
           R1 = R2;
           I64[Sp - 32] = _sb7oG::I64;
           P64[Sp - 24] = _sb7oH::P64;
           I64[Sp - 16] = _sb7oI::I64;
           I64[Sp - 8] = _sb7pt::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8A0; else goto cb8zP;
       ub8A0: // global
           call _cb8zO(R1) args: 0, res: 0, upd: 0;
       cb8zP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8zO() //  [R1]
         { info_tbl: [(cb8zO,
                       label: block_cb8zO_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8zO: // global
           _sb7pt::I64 = I64[Sp + 32];
           I64[Sp + 32] = block_cb8zU_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = R1;
           I64[Sp + 16] = 0;
           I64[Sp + 24] = _sb7pt::I64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb8zU() //  []
         { info_tbl: [(cb8zU,
                       label: block_cb8zU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8zU: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$wwriteBlocks_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb8A1,
                       label: GHC.IO.Handle.Text.$wwriteBlocks_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, True, False, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8A1: // global
           _sb7oG::I64 = R6;
           _sb7oF::P64 = R5;
           _sb7oE::P64 = R4;
           _sb7oD::P64 = R3;
           _sb7oC::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cb8A2; else goto cb8A3;
       cb8A3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8A5; else goto cb8A4;
       cb8A5: // global
           HpAlloc = 24;
           goto cb8A2;
       cb8A2: // global
           R1 = GHC.IO.Handle.Text.$wwriteBlocks_closure;
           P64[Sp - 40] = _sb7oC::P64;
           P64[Sp - 32] = _sb7oD::P64;
           P64[Sp - 24] = _sb7oE::P64;
           P64[Sp - 16] = _sb7oF::P64;
           I64[Sp - 8] = _sb7oG::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb8A4: // global
           I64[Hp - 16] = sat_sb7r5_info;
           P64[Hp] = _sb7oE::P64;
           P64[Sp - 48] = _sb7oD::P64;
           P64[Sp - 40] = _sb7oF::P64;
           I64[Sp - 32] = _sb7oG::I64;
           I64[Sp - 24] = 0;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 16] = _sb7oC::P64;
           Sp = Sp - 48;
           call _cb8yz() args: 0, res: 0, upd: 0;
     }
 },
 _cb8yz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8yz: // global
           I64[Sp - 8] = block_cb8yC_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Bp; else goto cb8yD;
       ub8Bp: // global
           call _cb8yC(R1) args: 0, res: 0, upd: 0;
       cb8yD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8yC() //  [R1]
         { info_tbl: [(cb8yC,
                       label: block_cb8yC_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8yC: // global
           if (R1 & 7 == 1) goto cb8Ae; else goto cb8Aq;
       cb8Ae: // global
           I64[Sp] = block_cb8Ab_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ub8Bq; else goto cb8Af;
       ub8Bq: // global
           call _cb8Ab(R1) args: 0, res: 0, upd: 0;
       cb8Af: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8Aq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb8At; else goto cb8As;
       cb8At: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8As: // global
           _sb7oI::I64 = I64[Sp + 64];
           _sb7pt::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_sb7pt::I64 + 1,
                            _sb7oI::I64)) goto cb8Av; else goto cb8AZ;
       cb8Av: // global
           _sb7pB::P64 = P64[R1 + 6];
           _sb7pC::P64 = P64[R1 + 14];
           Hp = Hp - 40;
           I64[Sp] = block_cb8yO_info;
           R1 = _sb7pB::P64;
           P64[Sp + 40] = _sb7pC::P64;
           if (R1 & 7 != 0) goto ub8Br; else goto cb8yP;
       ub8Br: // global
           call _cb8yO(R1) args: 0, res: 0, upd: 0;
       cb8yP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8AZ: // global
           I64[Hp - 32] = sat_sb7r0_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = _sb7oI::I64;
           I64[Hp] = _sb7pt::I64;
           I64[Sp] = block_cb8AY_info;
           R4 = Hp - 30;
           R3 = P64[Sp + 72];
           R2 = lvl2_rb6WE_closure;
           P64[Sp + 40] = R1;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Ab() //  [R1]
         { info_tbl: [(cb8Ab,
                       label: block_cb8Ab_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Ab: // global
           _sb7pt::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cb8Al; else goto cb8Ap;
       cb8Al: // global
           I64[Sp + 48] = _sb7pt::I64;
           Sp = Sp + 24;
           call _cb8xS() args: 0, res: 0, upd: 0;
       cb8Ap: // global
           I64[Sp + 32] = _sb7pt::I64;
           P64[Sp + 40] = R1;
           P64[Sp + 48] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _cb8yz() args: 0, res: 0, upd: 0;
     }
 },
 _cb8xS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8xS: // global
           Hp = Hp + 72;
           _sb7oM::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cb8A8; else goto cb8A7;
       cb8A8: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cb8xR_info;
           R1 = _sb7oM::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb8A7: // global
           I64[Hp - 64] = GHC.ForeignPtr.ForeignPtr_con_info;
           _sb7oH::P64 = P64[Sp + 32];
           P64[Hp - 56] = _sb7oH::P64;
           _sb7oG::I64 = I64[Sp];
           I64[Hp - 48] = _sb7oG::I64;
           I64[Hp - 40] = sat_sb7pr_info;
           P64[Hp - 32] = _sb7oH::P64;
           P64[Hp - 24] = Hp - 63;
           I64[Hp - 16] = _sb7oG::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _sb7oM::I64;
           R4 = Hp - 38;
           R3 = P64[Sp + 48];
           R2 = lvl2_rb6WE_closure;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb8xR() //  [R1]
         { info_tbl: [(cb8xR,
                       label: block_cb8xR_info
                       rep:StackRep [True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8xR: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cb8xS() args: 0, res: 0, upd: 0;
     }
 },
 _cb8yO() //  [R1]
         { info_tbl: [(cb8yO,
                       label: block_cb8yO_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8yO: // global
           _sb7pH::I64 = I64[R1 + 7];
           if (_sb7pH::I64 != 10) goto cb8Ay; else goto cb8AM;
       cb8Ay: // global
           _sb7oH::P64 = P64[Sp + 56];
           _sb7pt::I64 = I64[Sp + 32];
           _sb7pv::P64 = P64[Sp + 48];
           _sb7pC::P64 = P64[Sp + 40];
           I32[I64[Sp + 24] + (_sb7pt::I64 << 2)] = %MO_UU_Conv_W64_W32(_sb7pH::I64);
           call MO_Touch(_sb7oH::P64);
           I64[Sp + 32] = _sb7pt::I64 + 1;
           P64[Sp + 40] = _sb7pC::P64;
           P64[Sp + 48] = _sb7pv::P64;
           Sp = Sp + 8;
           call _cb8yz() args: 0, res: 0, upd: 0;
       cb8AM: // global
           I64[Sp] = block_cb8Az_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ub8Bs; else goto cb8AN;
       ub8Bs: // global
           call _cb8Az(R1) args: 0, res: 0, upd: 0;
       cb8AN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Az() //  [R1]
         { info_tbl: [(cb8Az,
                       label: block_cb8Az_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Az: // global
           _sb7oD::P64 = P64[Sp + 8];
           _sb7oG::I64 = I64[Sp + 24];
           _sb7oH::P64 = P64[Sp + 56];
           _sb7pt::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cb8AT; else goto cb8AX;
       cb8AT: // global
           I32[_sb7oG::I64 + (_sb7pt::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb7oH::P64);
           _sb7pN::I64 = _sb7pt::I64 + 1;
           goto sb7pL;
       cb8AX: // global
           I32[_sb7oG::I64 + (_sb7pt::I64 << 2)] = 13 :: W32;
           call MO_Touch(_sb7oH::P64);
           _sb7qA::I64 = _sb7pt::I64 + 1;
           I32[_sb7oG::I64 + (_sb7qA::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb7oH::P64);
           _sb7pN::I64 = _sb7qA::I64 + 1;
           goto sb7pL;
       sb7pL: // global
           I64[Sp] = block_cb8z1_info;
           R1 = _sb7oD::P64;
           I64[Sp + 32] = _sb7pN::I64;
           if (R1 & 7 != 0) goto ub8By; else goto cb8z2;
       ub8By: // global
           call _cb8z1(R1) args: 0, res: 0, upd: 0;
       cb8z2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8z1() //  [R1]
         { info_tbl: [(cb8z1,
                       label: block_cb8z1_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8z1: // global
           _sb7pN::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cb8AE; else goto cb8AG;
       cb8AE: // global
           I64[Sp + 32] = _sb7pN::I64;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cb8yz() args: 0, res: 0, upd: 0;
       cb8AG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb8AJ; else goto cb8AI;
       cb8AJ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8AI: // global
           I64[Hp - 32] = sat_sb7qq_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = I64[Sp + 64];
           I64[Hp] = _sb7pN::I64;
           I64[Sp] = block_cb8AF_info;
           R4 = Hp - 30;
           R3 = P64[Sp + 72];
           R2 = lvl2_rb6WE_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8AF() //  []
         { info_tbl: [(cb8AF,
                       label: block_cb8AF_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8AF: // global
           I64[Sp + 32] = 0;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cb8yz() args: 0, res: 0, upd: 0;
     }
 },
 _cb8AY() //  []
         { info_tbl: [(cb8AY,
                       label: block_cb8AY_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8AY: // global
           I64[Sp + 32] = 0;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cb8yz() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.988100534 UTC

[section ""cstring" . lvl33_rb6Xd_bytes" {
     lvl33_rb6Xd_bytes:
         I8[] [110,111,32,98,117,102,102,101,114,33]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.988908555 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr4_closure" {
     GHC.IO.Handle.Text.hPutStr4_closure:
         const GHC.IO.Handle.Text.hPutStr4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr4_entry() //  [R1]
         { info_tbl: [(cb8BJ,
                       label: GHC.IO.Handle.Text.hPutStr4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8BJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8BK; else goto cb8BL;
       cb8BK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8BL: // global
           (_cb8BE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8BE::I64 == 0) goto cb8BG; else goto cb8BF;
       cb8BG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8BF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8BE::I64;
           I64[Sp - 24] = block_cb8BH_info;
           R2 = lvl33_rb6Xd_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb8BH() //  [R1]
         { info_tbl: [(cb8BH,
                       label: block_cb8BH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8BH: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.990134159 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr3_closure" {
     GHC.IO.Handle.Text.hPutStr3_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.NoBuffering_closure+1;
         const GHC.IO.Handle.Text.hPutStr4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.992199924 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr2_closure" {
     GHC.IO.Handle.Text.hPutStr2_closure:
         const GHC.IO.Handle.Text.hPutStr2_info;
         const 0;
 },
 sat_sb7s6_entry() //  [R1]
         { info_tbl: [(cb8Cj,
                       label: sat_sb7s6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Cj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb8Cs; else goto cb8Ct;
       cb8Cs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Ct: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb8Cg_info;
           _sb7rw::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sb7rw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8Cz; else goto cb8Ch;
       ub8Cz: // global
           call _cb8Cg(R1) args: 0, res: 0, upd: 0;
       cb8Ch: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb8Cg() //  [R1]
         { info_tbl: [(cb8Cg,
                       label: block_cb8Cg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Cg: // global
           I64[Sp - 8] = block_cb8Cm_info;
           _sb7rY::P64 = P64[R1 + 7];
           _sb7rX::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb7rY::P64;
           I64[Sp + 8] = _sb7rX::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Cy; else goto cb8Cn;
       ub8Cy: // global
           call _cb8Cm(R1) args: 0, res: 0, upd: 0;
       cb8Cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb8Cm() //  [R1]
         { info_tbl: [(cb8Cm,
                       label: block_cb8Cm_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Cm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8Cx; else goto cb8Cw;
       cb8Cx: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb8Cw: // global
           _sb7s3::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = _sb7s3::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hPutStr2_entry() //  [R2]
         { info_tbl: [(cb8CA,
                       label: GHC.IO.Handle.Text.hPutStr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8CA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb8CB; else goto cb8CC;
       cb8CB: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8CC: // global
           I64[Sp - 8] = block_cb8BT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Dx; else goto cb8BU;
       ub8Dx: // global
           call _cb8BT(R1) args: 0, res: 0, upd: 0;
       cb8BU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8BT() //  [R1]
         { info_tbl: [(cb8BT,
                       label: block_cb8BT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8BT: // global
           I64[Sp - 24] = block_cb8BY_info;
           _sb7ri::P64 = P64[R1 + 71];
           _sb7rj::P64 = P64[R1 + 79];
           _sb7ro::P64 = P64[R1 + 119];
           R1 = P64[R1 + 55];
           P64[Sp - 16] = _sb7rj::P64;
           P64[Sp - 8] = _sb7ro::P64;
           P64[Sp] = _sb7ri::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8Du; else goto cb8BZ;
       ub8Du: // global
           call _cb8BY(R1) args: 0, res: 0, upd: 0;
       cb8BZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8BY() //  [R1]
         { info_tbl: [(cb8BY,
                       label: block_cb8BY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8BY: // global
           if (R1 & 7 == 1) goto cb8Do; else goto cb8CG;
       cb8Do: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8Dr; else goto cb8Dq;
       cb8Dr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8Dq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Text.hPutStr3_closure+1;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8CG: // global
           _sb7rt::P64 = P64[P64[Sp + 8] + 8];
           _sb7rw::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 8] = block_cb8C3_info;
           _sb7rq::P64 = R1;
           R1 = _sb7rt::P64;
           P64[Sp] = _sb7rw::P64;
           P64[Sp + 24] = _sb7rq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Dv; else goto cb8C4;
       ub8Dv: // global
           call _cb8C3(R1) args: 0, res: 0, upd: 0;
       cb8C4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8C3() //  [R1]
         { info_tbl: [(cb8C3,
                       label: block_cb8C3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8C3: // global
           _sb7rw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cb8CL; else goto cb8Dh;
       cb8CL: // global
           I64[Sp + 16] = block_cb8CI_info;
           R1 = _sb7rw::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub8Dw; else goto cb8CM;
       ub8Dw: // global
           call _cb8CI(R1) args: 0, res: 0, upd: 0;
       cb8CM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8Dh: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cb8Dk; else goto cb8Dj;
       cb8Dk: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8Dj: // global
           _sb7rj::P64 = P64[Sp + 16];
           _sb7ro::P64 = P64[Sp + 24];
           _sb7rq::P64 = P64[Sp + 32];
           _sb7rT::P64 = P64[R1 + 6];
           _sb7rU::P64 = P64[R1 + 14];
           call MO_WriteBarrier();
           P64[_sb7rj::P64 + 8] = _sb7rU::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7rj::P64);
           I64[Hp - 72] = sat_sb7s6_info;
           P64[Hp - 56] = _sb7rw::P64;
           P64[Hp - 48] = _sb7rT::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = _sb7rq::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = _sb7ro::P64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8CI() //  [R1]
         { info_tbl: [(cb8CI,
                       label: block_cb8CI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8CI: // global
           _sb7rC::I64 = I64[R1 + 31];
           _sb7rF::I64 = _sb7rC::I64 << 2;
           if (%MO_S_Ge_W64(_sb7rF::I64, 0)) goto cb8D9; else goto cb8De;
       cb8D9: // global
           I64[Sp - 16] = block_cb8CX_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _sb7rF::I64;
           I64[Sp] = _sb7rC::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cb8De: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8CX() //  [R1]
         { info_tbl: [(cb8CX,
                       label: block_cb8CX_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8CX: // global
           I64[Sp] = block_cb8CZ_info;
           _sb7rJ::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _sb7rJ::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8CZ() //  [R1]
         { info_tbl: [(cb8CZ,
                       label: block_cb8CZ_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8CZ: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cb8Dd; else goto cb8Dc;
       cb8Dd: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8Dc: // global
           I64[Hp - 120] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 112] = R1;
           P64[Hp - 104] = P64[Sp + 8];
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = Hp - 118;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 72] = R1 + 16;
           I64[Hp - 64] = I64[Sp + 16];
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = Hp - 95;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.995931704 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutStr6_bytes" {
     GHC.IO.Handle.Text.hPutStr6_bytes:
         I8[] [104,80,117,116,83,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.996619126 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr5_closure" {
     GHC.IO.Handle.Text.hPutStr5_closure:
         const GHC.IO.Handle.Text.hPutStr5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr5_entry() //  [R1]
         { info_tbl: [(cb8DE,
                       label: GHC.IO.Handle.Text.hPutStr5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8DE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8DF; else goto cb8DG;
       cb8DF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8DG: // global
           (_cb8DB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8DB::I64 == 0) goto cb8DD; else goto cb8DC;
       cb8DD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8DC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8DB::I64;
           R2 = GHC.IO.Handle.Text.hPutStr6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:02.998817015 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr1_closure" {
     GHC.IO.Handle.Text.hPutStr1_closure:
         const GHC.IO.Handle.Text.hPutStr1_info;
         const 0;
 },
 section ""relreadonly" . ub8Fy_srtd" {
     ub8Fy_srtd:
         const Sb7vQ_srt+16;
         const 74;
         const 19;
         const 836;
 },
 GHC.IO.Handle.Text.hPutStr1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8DU,
                       label: GHC.IO.Handle.Text.hPutStr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8DU: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb8DV; else goto cb8DW;
       cb8DV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8DW: // global
           I64[Sp - 32] = block_cb8DN_info;
           R1 = R2;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8Fn; else goto cb8DO;
       ub8Fn: // global
           call _cb8DN(R1) args: 0, res: 0, upd: 0;
       cb8DO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8Fz_srtd" {
     ub8Fz_srtd:
         const Sb7vQ_srt+16;
         const 74;
         const 19;
         const 580;
 },
 _cb8DN() //  [R1]
         { info_tbl: [(cb8DN,
                       label: block_cb8DN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8DN: // global
           if (R1 & 7 == 1) goto cb8DR; else goto cb8DS;
       cb8DR: // global
           I64[Sp] = block_cb8EK_info;
           R5 = GHC.IO.Handle.Text.hPutStr2_closure+2;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutStr5_closure;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 8, upd: 8;
       cb8DS: // global
           I64[Sp] = block_cb8F2_info;
           R5 = GHC.IO.Handle.Text.hPutStr2_closure+2;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutStr5_closure;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8FA_srtd" {
     ub8FA_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb8EK() //  [R1]
         { info_tbl: [(cb8EK,
                       label: block_cb8EK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8EK: // global
           I64[Sp] = block_cb8EM_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8Fr; else goto cb8EN;
       ub8Fr: // global
           call _cb8EM(R1) args: 0, res: 0, upd: 0;
       cb8EN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8FB_srtd" {
     ub8FB_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb8EM() //  [R1]
         { info_tbl: [(cb8EM,
                       label: block_cb8EM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8EM: // global
           I64[Sp - 8] = block_cb8ER_info;
           _sb7sL::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sb7sL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Fs; else goto cb8EV;
       ub8Fs: // global
           call _cb8ER(R1) args: 0, res: 0, upd: 0;
       cb8EV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8FC_srtd" {
     ub8FC_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb8ER() //  [R1]
         { info_tbl: [(cb8ER,
                       label: block_cb8ER_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ER: // global
           _sb7si::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp - 8] = _sb7si::P64;
           Sp = Sp - 8;
           call _sb7se() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub8FD_srtd" {
     ub8FD_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb8F2() //  [R1]
         { info_tbl: [(cb8F2,
                       label: block_cb8F2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8F2: // global
           I64[Sp] = block_cb8F4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8Fu; else goto cb8F5;
       ub8Fu: // global
           call _cb8F4(R1) args: 0, res: 0, upd: 0;
       cb8F5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8FE_srtd" {
     ub8FE_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb8F4() //  [R1]
         { info_tbl: [(cb8F4,
                       label: block_cb8F4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8F4: // global
           I64[Sp - 8] = block_cb8F9_info;
           _sb7sX::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sb7sX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Fv; else goto cb8Fd;
       ub8Fv: // global
           call _cb8F9(R1) args: 0, res: 0, upd: 0;
       cb8Fd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8FF_srtd" {
     ub8FF_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb8F9() //  [R1]
         { info_tbl: [(cb8F9,
                       label: block_cb8F9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8F9: // global
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call _sb7se() args: 0, res: 0, upd: 0;
     }
 },
 _sb7se() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7se: // global
           I64[Sp - 8] = block_cb8E0_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Fx; else goto cb8E2;
       ub8Fx: // global
           call _cb8E0(R1) args: 0, res: 0, upd: 0;
       cb8E2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub8FG_srtd" {
     ub8FG_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb8E0() //  [R1]
         { info_tbl: [(cb8E0,
                       label: block_cb8E0_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8E0: // global
           _sb7sh::P64 = P64[Sp + 16];
           _cb8Fi::P64 = R1 & 7;
           if (_cb8Fi::P64 < 3) goto ub8Fk; else goto cb8EC;
       ub8Fk: // global
           if (_cb8Fi::P64 < 2) goto cb8Eb; else goto cb8Es;
       cb8Eb: // global
           I64[Sp + 24] = block_cb8E6_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.hPutStr7_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cb8Es: // global
           I64[Sp] = block_cb8Eq_info;
           R1 = _sb7sh::P64;
           if (R1 & 7 != 0) goto ub8Fo; else goto cb8Et;
       ub8Fo: // global
           call _cb8Eq(R1) args: 0, res: 0, upd: 0;
       cb8Et: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8EC: // global
           I64[Sp] = block_cb8EA_info;
           R1 = _sb7sh::P64;
           if (R1 & 7 != 0) goto ub8Fp; else goto cb8ED;
       ub8Fp: // global
           call _cb8EA(R1) args: 0, res: 0, upd: 0;
       cb8ED: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8E6() //  []
         { info_tbl: [(cb8E6,
                       label: block_cb8E6_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8E6: // global
           I64[Sp] = block_cb8E8_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto ub8Fq; else goto cb8Ed;
       ub8Fq: // global
           call _cb8E8(R1) args: 0, res: 0, upd: 0;
       cb8Ed: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8E8() //  [R1]
         { info_tbl: [(cb8E8,
                       label: block_cb8E8_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8E8: // global
           if (R1 & 7 == 1) goto cb8Ej; else goto cb8En;
       cb8Ej: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8En: // global
           R3 = 10;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb8Eq() //  [R1]
         { info_tbl: [(cb8Eq,
                       label: block_cb8Eq_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Eq: // global
           R6 = I64[R1 + 23];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = GHC.Types.True_closure+2;
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           _sb7sb::P64 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 31];
           P64[Sp + 48] = _sb7sb::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 _cb8EA() //  [R1]
         { info_tbl: [(cb8EA,
                       label: block_cb8EA_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8EA: // global
           R6 = I64[R1 + 23];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = GHC.Types.False_closure+1;
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           _sb7sb::P64 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 31];
           P64[Sp + 48] = _sb7sb::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.006369572 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr'_closure" {
     GHC.IO.Handle.Text.hPutStr'_closure:
         const GHC.IO.Handle.Text.hPutStr'_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr'_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8FL,
                       label: GHC.IO.Handle.Text.hPutStr'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8FL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.007181948 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr_closure" {
     GHC.IO.Handle.Text.hPutStr_closure:
         const GHC.IO.Handle.Text.hPutStr_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr_entry() //  [R2, R3]
         { info_tbl: [(cb8FS,
                       label: GHC.IO.Handle.Text.hPutStr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8FS: // global
           R4 = GHC.Types.False_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.007984864 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStrLn_closure" {
     GHC.IO.Handle.Text.hPutStrLn_closure:
         const GHC.IO.Handle.Text.hPutStrLn_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStrLn_entry() //  [R2, R3]
         { info_tbl: [(cb8FZ,
                       label: GHC.IO.Handle.Text.hPutStrLn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8FZ: // global
           R4 = GHC.Types.True_closure+2;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.008669138 UTC

[section ""cstring" . GHC.IO.Handle.Text.hWaitForInput3_bytes" {
     GHC.IO.Handle.Text.hWaitForInput3_bytes:
         I8[] [104,87,97,105,116,70,111,114,73,110,112,117,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.009502884 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput2_closure" {
     GHC.IO.Handle.Text.hWaitForInput2_closure:
         const GHC.IO.Handle.Text.hWaitForInput2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hWaitForInput2_entry() //  [R1]
         { info_tbl: [(cb8G8,
                       label: GHC.IO.Handle.Text.hWaitForInput2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8G8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8G9; else goto cb8Ga;
       cb8G9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Ga: // global
           (_cb8G5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8G5::I64 == 0) goto cb8G7; else goto cb8G6;
       cb8G7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8G6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8G5::I64;
           R2 = GHC.IO.Handle.Text.hWaitForInput3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.013483097 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput1_closure" {
     GHC.IO.Handle.Text.hWaitForInput1_closure:
         const GHC.IO.Handle.Text.hWaitForInput1_info;
         const 0;
 },
 lvl34_sb7t8_entry() //  [R1]
         { info_tbl: [(cb8Gm,
                       label: lvl34_sb7t8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Gm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8Gn; else goto cb8Go;
       cb8Gn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Go: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb8Gj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8Gt; else goto cb8Gk;
       ub8Gt: // global
           call _cb8Gj(R1) args: 0, res: 0, upd: 0;
       cb8Gk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb8Gj() //  [R1]
         { info_tbl: [(cb8Gj,
                       label: block_cb8Gj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Gj: // global
           R1 = I64[(%MO_S_Lt_W64(I64[R1 + 7],
                                  0) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7v9_entry() //  [R1, R2]
         { info_tbl: [(cb8GC,
                       label: sat_sb7v9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8GC: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb8GG; else goto cb8GH;
       cb8GG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8GH: // global
           I64[Sp - 24] = block_cb8Gz_info;
           _sb7t6::P64 = P64[R1 + 6];
           _sb7t8::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sb7t6::P64;
           P64[Sp - 8] = _sb7t8::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8Jo; else goto cb8GA;
       ub8Jo: // global
           call _cb8Gz(R1) args: 0, res: 0, upd: 0;
       cb8GA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Gz() //  [R1]
         { info_tbl: [(cb8Gz,
                       label: block_cb8Gz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Gz: // global
           I64[Sp - 56] = block_cb8GF_info;
           _sb7te::P64 = R1;
           _sb7tf::P64 = P64[R1 + 7];
           _sb7ti::P64 = P64[R1 + 31];
           _sb7tk::P64 = P64[R1 + 47];
           _sb7tm::P64 = P64[R1 + 63];
           _sb7tn::P64 = P64[R1 + 71];
           _sb7tq::P64 = P64[R1 + 95];
           R1 = P64[_sb7tn::P64 + 8];
           P64[Sp - 48] = _sb7tf::P64;
           P64[Sp - 40] = _sb7ti::P64;
           P64[Sp - 32] = _sb7tk::P64;
           P64[Sp - 24] = _sb7tm::P64;
           P64[Sp - 16] = _sb7tn::P64;
           P64[Sp - 8] = _sb7tq::P64;
           P64[Sp] = _sb7te::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ub8Jn; else goto cb8GJ;
       ub8Jn: // global
           call _cb8GF(R1) args: 0, res: 0, upd: 0;
       cb8GJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8GF() //  [R1]
         { info_tbl: [(cb8GF,
                       label: block_cb8GF_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8GF: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb8GV; else goto ub8Jj;
       cb8GV: // global
           I64[Sp] = block_cb8GU_info;
           _sb7ty::P64 = R1;
           R1 = P64[Sp + 72];
           P64[Sp + 72] = _sb7ty::P64;
           if (R1 & 7 != 0) goto ub8Jp; else goto cb8GW;
       ub8Jp: // global
           call _cb8GU(R1) args: 0, res: 0, upd: 0;
       cb8GW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub8Jj: // global
           Sp = Sp + 80;
           call _cb8Hh() args: 0, res: 0, upd: 0;
     }
 },
 _cb8GU() //  [R1]
         { info_tbl: [(cb8GU,
                       label: block_cb8GU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8GU: // global
           if (R1 & 7 == 1) goto cb8HR; else goto cb8J2;
       cb8HR: // global
           _sb7tJ::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cb8H2_info;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _sb7tJ::P64;
           if (R1 & 7 != 0) goto ub8Jr; else goto cb8HS;
       ub8Jr: // global
           call _cb8H2(R1) args: 0, res: 0, upd: 0;
       cb8HS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8J2: // global
           I64[Sp + 32] = block_cb8J0_info;
           R3 = P64[Sp + 72];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8H2() //  [R1]
         { info_tbl: [(cb8H2,
                       label: block_cb8H2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8H2: // global
           if (R1 & 7 == 1) goto cb8Ic; else goto cb8IM;
       cb8Ic: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8If; else goto cb8Ie;
       cb8If: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8Ie: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sb7tJ::P64 = P64[Sp + 48];
           P64[Hp] = _sb7tJ::P64;
           _sb7tm::P64 = P64[Sp + 32];
           _sb7ty::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb7tm::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tm::P64);
           I64[Sp] = block_cb8I0_info;
           R3 = _sb7ty::P64;
           R2 = _sb7tJ::P64;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cb8IM: // global
           I64[Sp] = block_cb8Ip_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub8Js; else goto cb8Iq;
       ub8Js: // global
           call _cb8Ip(R1) args: 0, res: 0, upd: 0;
       cb8Iq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8I0() //  [R1]
         { info_tbl: [(cb8I0,
                       label: block_cb8I0_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8I0: // global
           I64[Sp] = block_cb8I2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8Jw; else goto cb8I3;
       ub8Jw: // global
           call _cb8I2(R1) args: 0, res: 0, upd: 0;
       cb8I3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8I2() //  [R1]
         { info_tbl: [(cb8I2,
                       label: block_cb8I2_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8I2: // global
           _sb7tk::P64 = P64[Sp + 24];
           _sb7uv::P64 = P64[R1 + 15];
           _sb7uw::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sb7tk::P64 + 8] = _sb7uv::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tk::P64);
           I64[Sp] = block_cb8Ia_info;
           R1 = _sb7uw::P64;
           if (R1 & 7 != 0) goto ub8Jx; else goto cb8Ii;
       ub8Jx: // global
           call _cb8Ia(R1) args: 0, res: 0, upd: 0;
       cb8Ii: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Ia() //  [R1]
         { info_tbl: [(cb8Ia,
                       label: block_cb8Ia_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Ia: // global
           I64[Sp + 72] = I64[R1 + 23];
           P64[Sp + 48] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 24] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           Sp = Sp - 16;
           call _cb8H4() args: 0, res: 0, upd: 0;
     }
 },
 _cb8Ip() //  [R1]
         { info_tbl: [(cb8Ip,
                       label: block_cb8Ip_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Ip: // global
           I64[Sp - 16] = block_cb8Iu_info;
           _sb7uH::P64 = P64[R1 + 7];
           _sb7uI::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sb7uI::P64;
           P64[Sp] = _sb7uH::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Iu() //  [R1]
         { info_tbl: [(cb8Iu,
                       label: block_cb8Iu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Iu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8IQ; else goto cb8IP;
       cb8IQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8IP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sb7tJ::P64 = P64[Sp + 64];
           P64[Hp] = _sb7tJ::P64;
           _sb7tm::P64 = P64[Sp + 48];
           _sb7ty::P64 = P64[Sp + 88];
           _sb7uH::P64 = P64[Sp + 16];
           _sb7uI::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7tm::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tm::P64);
           I64[Sp + 16] = block_cb8IA_info;
           R5 = _sb7ty::P64;
           R4 = _sb7tJ::P64;
           R3 = _sb7uI::P64;
           R2 = _sb7uH::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8IA() //  [R1]
         { info_tbl: [(cb8IA,
                       label: block_cb8IA_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8IA: // global
           I64[Sp] = block_cb8IC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8Jz; else goto cb8ID;
       ub8Jz: // global
           call _cb8IC(R1) args: 0, res: 0, upd: 0;
       cb8ID: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8IC() //  [R1]
         { info_tbl: [(cb8IC,
                       label: block_cb8IC_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8IC: // global
           _sb7tk::P64 = P64[Sp + 24];
           _sb7uV::P64 = P64[R1 + 7];
           _sb7uW::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sb7tk::P64 + 8] = _sb7uV::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tk::P64);
           I64[Sp] = block_cb8IK_info;
           R1 = _sb7uW::P64;
           if (R1 & 7 != 0) goto ub8JA; else goto cb8IT;
       ub8JA: // global
           call _cb8IK(R1) args: 0, res: 0, upd: 0;
       cb8IT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8IK() //  [R1]
         { info_tbl: [(cb8IK,
                       label: block_cb8IK_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8IK: // global
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 24] = I64[R1 + 31];
           P64[Sp + 32] = P64[R1 + 15];
           P64[Sp + 48] = P64[R1 + 7];
           I64[Sp + 72] = I64[R1 + 23];
           Sp = Sp - 16;
           call _cb8H4() args: 0, res: 0, upd: 0;
     }
 },
 _cb8H4() //  []
         { info_tbl: [(cb8H4,
                       label: block_cb8H4_info
                       rep:StackRep [True, True, False, False, True, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8H4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8H9; else goto cb8H8;
       cb8H9: // global
           HpAlloc = 56;
           I64[Sp] = block_cb8H4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb8H8: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 48];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 40];
           _sb7tQ::I64 = I64[Sp + 16];
           I64[Hp - 8] = _sb7tQ::I64;
           _sb7tR::I64 = I64[Sp + 8];
           I64[Hp] = _sb7tR::I64;
           _sb7t6::P64 = P64[Sp + 80];
           _sb7tf::P64 = P64[Sp + 24];
           _sb7ti::P64 = P64[Sp + 32];
           _sb7tn::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           if (_sb7tQ::I64 == _sb7tR::I64) goto cb8Hn; else goto ub8Jm;
       cb8Hn: // global
           I64[Sp + 48] = block_cb8Hk_info;
           R2 = _sb7tf::P64;
           I64[Sp + 16] = stg_ap_pppv_info;
           P64[Sp + 24] = _sb7ti::P64;
           P64[Sp + 32] = GHC.Types.False_closure+1;
           P64[Sp + 40] = _sb7t6::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.ready_entry(R2) args: 40, res: 8, upd: 8;
       ub8Jm: // global
           Sp = Sp + 96;
           call _cb8Hh() args: 0, res: 0, upd: 0;
     }
 },
 _cb8Hk() //  [R1]
         { info_tbl: [(cb8Hk,
                       label: block_cb8Hk_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Hk: // global
           I64[Sp] = block_cb8Hm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8Ju; else goto cb8Hp;
       ub8Ju: // global
           call _cb8Hm(R1) args: 0, res: 0, upd: 0;
       cb8Hp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Hm() //  [R1]
         { info_tbl: [(cb8Hm,
                       label: block_cb8Hm_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Hm: // global
           if (R1 & 7 == 1) goto cb8Hv; else goto cb8HA;
       cb8Hv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8HA: // global
           _sb7u1::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_cb8Hy_info;
           R1 = _sb7u1::P64;
           if (R1 & 7 != 0) goto ub8Jv; else goto cb8HB;
       ub8Jv: // global
           call _cb8Hy(R1) args: 0, res: 0, upd: 0;
       cb8HB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Hy() //  [R1]
         { info_tbl: [(cb8Hy,
                       label: block_cb8Hy_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Hy: // global
           _sb7u4::P64 = P64[R1 + 7];
           _sb7u3::I64 = I64[R1 + 23];
           _sb7u7::I64 = I64[R1 + 39];
           if (_sb7u7::I64 == I64[R1 + 47]) goto cb8HN; else goto cb8HJ;
       cb8HN: // global
           I64[Sp] = block_cb8HM_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           I64[Sp + 24] = _sb7u7::I64;
           P64[Sp + 32] = _sb7u4::P64;
           I64[Sp + 40] = _sb7u3::I64;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb8HJ: // global
           _sb7tn::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           call MO_Touch(_sb7u4::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8HM() //  [R1]
         { info_tbl: [(cb8HM,
                       label: block_cb8HM_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8HM: // global
           _sb7tn::P64 = P64[Sp + 8];
           _sb7u3::I64 = I64[Sp + 40];
           _sb7u4::P64 = P64[Sp + 32];
           _sb7u7::I64 = I64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           call MO_Touch(_sb7u4::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8J0() //  [R1]
         { info_tbl: [(cb8J0,
                       label: block_cb8J0_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8J0: // global
           _sb7tn::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8Hh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Hh: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub8JH_srtd" {
     ub8JH_srtd:
         const Sb7vQ_srt+96;
         const 70;
         const 1;
         const 60;
 },
 GHC.IO.Handle.Text.hWaitForInput1_entry() //  [R2, R3]
         { info_tbl: [(cb8JC,
                       label: GHC.IO.Handle.Text.hWaitForInput1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8JC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb8JG; else goto cb8JF;
       cb8JG: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hWaitForInput1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8JF: // global
           I64[Hp - 40] = lvl34_sb7t8_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sb7v9_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hWaitForInput2_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.020280547 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput_closure" {
     GHC.IO.Handle.Text.hWaitForInput_closure:
         const GHC.IO.Handle.Text.hWaitForInput_info;
         const 0;
 },
 GHC.IO.Handle.Text.hWaitForInput_entry() //  [R2, R3]
         { info_tbl: [(cb8JM,
                       label: GHC.IO.Handle.Text.hWaitForInput_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8JM: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hWaitForInput1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.020984721 UTC

[section ""relreadonly" . Sb7vQ_srt" {
     Sb7vQ_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Text.$willegalBufferSize_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Text.$whPutChar_closure;
         const GHC.IO.Handle.Text.hPutChar2_closure;
         const GHC.IO.Handle.Text.hPutChar1_closure;
         const GHC.IO.Handle.Text.hPutStr7_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Text.hGetChar3_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Text.hGetChar2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.hGetChar6_closure;
         const GHC.IO.Handle.Text.hGetChar1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Text.hGetContents3_closure;
         const $wlvl_rb6WI_closure;
         const lvl6_rb6WK_closure;
         const lvl7_rb6WL_closure;
         const lvl9_rb6WN_closure;
         const lvl10_rb6WO_closure;
         const lvl4_rb6WH_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Text.hGetContents2_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
         const GHC.IO.Handle.Text.hGetContents1_closure;
         const GHC.IO.Handle.Internals.ioe_EOF1_closure;
         const GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure;
         const GHC.IO.Handle.Text.hGetLine3_closure;
         const GHC.IO.Handle.Text.hGetLine2_closure;
         const GHC.IO.Handle.Text.hGetLine4_closure;
         const GHC.IO.Handle.Text.hGetLine1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.Text.$wbufReadNBEmpty_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking2_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const lvl11_rb6WR_closure;
         const GHC.IO.Handle.Text.$whGetBufNonBlocking_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking1_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.Handle.Text.$whGetBufSome_closure;
         const lvl13_rb6WT_closure;
         const GHC.IO.Handle.Text.hGetBufSome1_closure;
         const GHC.IO.Handle.Text.hGetBuf2_closure;
         const GHC.IO.Handle.Text.hGetBuf4_closure;
         const GHC.IO.Handle.Text.$whGetBuf_closure;
         const GHC.IO.Handle.Text.hGetBuf5_closure;
         const GHC.IO.Handle.Text.hGetBuf1_closure;
         const GHC.Err.error_closure;
         const lvl24_rb6X4_closure;
         const lvl29_rb6X9_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const GHC.IO.Handle.Text.$wbufWrite_closure;
         const lvl26_rb6X6_closure;
         const lvl30_rb6Xa_closure;
         const GHC.IO.Handle.Text.$whPutBuf'_closure;
         const GHC.IO.Handle.Text.hPutBuf3_closure;
         const GHC.IO.Handle.Text.hPutBuf2_closure;
         const GHC.IO.Handle.Text.hPutBufNonBlocking1_closure;
         const GHC.IO.Handle.Text.hPutBuf1_closure;
         const lvl32_rb6Xc_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.Text.$wwriteBlocks_closure;
         const lvl2_rb6WE_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const GHC.IO.Handle.Text.hPutStr2_closure;
         const GHC.IO.Handle.Text.hPutStr3_closure;
         const GHC.IO.Handle.Text.hPutStr1_closure;
         const GHC.IO.Handle.Text.hPutStr5_closure;
         const GHC.IO.Handle.Text.$whPutChar_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Text.hWaitForInput1_closure;
         const GHC.IO.Handle.Text.hWaitForInput2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.022111576 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:03.022590571 UTC

[section ""cstring" . lvl_rb6WB_bytes" {
     lvl_rb6WB_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.023900052 UTC

[section ""data" . GHC.IO.Handle.Text.$willegalBufferSize_closure" {
     GHC.IO.Handle.Text.$willegalBufferSize_closure:
         const GHC.IO.Handle.Text.$willegalBufferSize_info;
         const 0;
 },
 sat_sb6Xn_entry() //  [R1]
         { info_tbl: [(cb8K8,
                       label: sat_sb6Xn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8K8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8K9; else goto cb8Ka;
       cb8K9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Ka: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb8K5_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb8K5() //  [R1, R2]
         { info_tbl: [(cb8K5,
                       label: block_cb8K5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8K5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8Kd; else goto cb8Kc;
       cb8Kd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cb8Kc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb6Xo_entry() //  [R1]
         { info_tbl: [(cb8Ke,
                       label: sat_sb6Xo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Ke: // global
           _sb6Xo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb8Kf; else goto cb8Kg;
       cb8Kg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8Ki; else goto cb8Kh;
       cb8Ki: // global
           HpAlloc = 24;
           goto cb8Kf;
       cb8Kf: // global
           R1 = _sb6Xo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Kh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb6Xo::P64;
           _sb6Xh::I64 = I64[_sb6Xo::P64 + 16];
           I64[Hp - 16] = sat_sb6Xn_info;
           I64[Hp] = _sb6Xh::I64;
           R3 = Hp - 16;
           R2 = lvl_rb6WB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb6Xq_entry() //  [R1]
         { info_tbl: [(cb8Kl,
                       label: sat_sb6Xq_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Kl: // global
           _sb6Xq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb8Km; else goto cb8Kn;
       cb8Kn: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb8Kp; else goto cb8Ko;
       cb8Kp: // global
           HpAlloc = 96;
           goto cb8Km;
       cb8Km: // global
           R1 = _sb6Xq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Ko: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb6Xq::P64;
           _sb6Xf::P64 = P64[_sb6Xq::P64 + 16];
           _sb6Xg::P64 = P64[_sb6Xq::P64 + 24];
           _sb6Xh::I64 = I64[_sb6Xq::P64 + 32];
           I64[Hp - 88] = sat_sb6Xo_info;
           I64[Hp - 72] = _sb6Xh::I64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sb6Xf::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = _sb6Xg::P64;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.$willegalBufferSize_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8Kq,
                       label: GHC.IO.Handle.Text.$willegalBufferSize_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Kq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb8Ku; else goto cb8Kt;
       cb8Ku: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$willegalBufferSize_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8Kt: // global
           I64[Hp - 32] = sat_sb6Xq_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.025970147 UTC

[section ""cstring" . GHC.IO.Handle.Text.$trModule4_bytes" {
     GHC.IO.Handle.Text.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.026536548 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule3_closure" {
     GHC.IO.Handle.Text.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Text.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.0270862 UTC

[section ""cstring" . GHC.IO.Handle.Text.$trModule2_bytes" {
     GHC.IO.Handle.Text.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,101,120,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.027608058 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule1_closure" {
     GHC.IO.Handle.Text.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Text.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.028157546 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule_closure" {
     GHC.IO.Handle.Text.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Text.$trModule3_closure+1;
         const GHC.IO.Handle.Text.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.029268721 UTC

[section ""data" . memcpy1_rb6WC_closure" {
     memcpy1_rb6WC_closure:
         const memcpy1_rb6WC_info;
 },
 memcpy1_rb6WC_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8KC,
                       label: memcpy1_rb6WC_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8KC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8KU; else goto cb8KV;
       cb8KU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = memcpy1_rb6WC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8KV: // global
           I64[Sp - 24] = block_cb8Kz_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8L2; else goto cb8KA;
       ub8L2: // global
           call _cb8Kz(R1) args: 0, res: 0, upd: 0;
       cb8KA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Kz() //  [R1]
         { info_tbl: [(cb8Kz,
                       label: block_cb8Kz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Kz: // global
           I64[Sp] = block_cb8KF_info;
           _sb6Xw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sb6Xw::I64;
           if (R1 & 7 != 0) goto ub8L1; else goto cb8KG;
       ub8L1: // global
           call _cb8KF(R1) args: 0, res: 0, upd: 0;
       cb8KG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8KF() //  [R1]
         { info_tbl: [(cb8KF,
                       label: block_cb8KF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8KF: // global
           I64[Sp] = block_cb8KK_info;
           _sb6Xy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb6Xy::I64;
           if (R1 & 7 != 0) goto ub8L3; else goto cb8KL;
       ub8L3: // global
           call _cb8KK(R1) args: 0, res: 0, upd: 0;
       cb8KL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8KK() //  [R1]
         { info_tbl: [(cb8KK,
                       label: block_cb8KK_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8KK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb8L0; else goto cb8KZ;
       cb8L0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8KZ: // global
           (_sb6XE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sb6XE::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.030902028 UTC

[section ""data" . GHC.IO.Handle.Text.memcpy_closure" {
     GHC.IO.Handle.Text.memcpy_closure:
         const GHC.IO.Handle.Text.memcpy_info;
 },
 GHC.IO.Handle.Text.memcpy_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8L8,
                       label: GHC.IO.Handle.Text.memcpy_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8L8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call memcpy1_rb6WC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.034092962 UTC

[section ""data" . GHC.IO.Handle.Text.$wcommitBuffer'_closure" {
     GHC.IO.Handle.Text.$wcommitBuffer'_closure:
         const GHC.IO.Handle.Text.$wcommitBuffer'_info;
 },
 GHC.IO.Handle.Text.$wcommitBuffer'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Lc: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wcommitBuffer'_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$wcommitBuffer'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb8Lj,
                       label: GHC.IO.Handle.Text.$wcommitBuffer'_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [True, False, True, True, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Lj: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb8Lk; else goto cb8Ll;
       cb8Lk: // global
           R1 = GHC.IO.Handle.Text.$wcommitBuffer'_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cb8Ll: // global
           I64[Sp - 40] = block_cb8Lg_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           I64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8NO; else goto cb8Lh;
       ub8NO: // global
           call _cb8Lg(R1) args: 0, res: 0, upd: 0;
       cb8Lh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Lg() //  [R1]
         { info_tbl: [(cb8Lg,
                       label: block_cb8Lg_info
                       rep:StackRep [False, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Lg: // global
           I64[Sp - 40] = block_cb8Lo_info;
           R6 = I64[Sp + 16];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 48];
           R2 = R1;
           I64[Sp - 56] = 0;
           I64[Sp - 48] = I64[Sp + 24];
           P64[Sp - 32] = P64[R1 + 31];
           P64[Sp - 24] = P64[R1 + 47];
           P64[Sp - 16] = P64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 79];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 56;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb8Lo() //  []
         { info_tbl: [(cb8Lo,
                       label: block_cb8Lo_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Lo: // global
           I64[Sp] = block_cb8Lq_info;
           R1 = P64[Sp + 72];
           if (R1 & 7 != 0) goto ub8NP; else goto cb8Lt;
       ub8NP: // global
           call _cb8Lq(R1) args: 0, res: 0, upd: 0;
       cb8Lt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Lq() //  [R1]
         { info_tbl: [(cb8Lq,
                       label: block_cb8Lq_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Lq: // global
           if (R1 & 7 == 1) goto cb8LA; else goto cb8Mf;
       cb8LA: // global
           I64[Sp + 16] = block_cb8Lx_info;
           R1 = P64[Sp + 80];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub8NQ; else goto cb8LB;
       ub8NQ: // global
           call _cb8Lx(R1) args: 0, res: 0, upd: 0;
       cb8LB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8Mf: // global
           _sb6Yw::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cb8Md_info;
           R1 = _sb6Yw::P64;
           if (R1 & 7 != 0) goto ub8NR; else goto cb8Mg;
       ub8NR: // global
           call _cb8Md(R1) args: 0, res: 0, upd: 0;
       cb8Mg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Lx() //  [R1]
         { info_tbl: [(cb8Lx,
                       label: block_cb8Lx_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Lx: // global
           if (R1 & 7 == 1) goto cb8LH; else goto cb8LP;
       cb8LH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8LK; else goto cb8LJ;
       cb8LK: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8LJ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8LP: // global
           _sb6Yd::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cb8LN_info;
           R1 = _sb6Yd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub8NS; else goto cb8LQ;
       ub8NS: // global
           call _cb8LN(R1) args: 0, res: 0, upd: 0;
       cb8LQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8LN() //  [R1]
         { info_tbl: [(cb8LN,
                       label: block_cb8LN_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8LN: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb8LW; else goto cb8LV;
       cb8LW: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8LV: // global
           _sb6XG::I64 = I64[Sp + 64];
           _sb6XH::P64 = P64[Sp + 24];
           _sb6XI::I64 = I64[Sp + 32];
           _sb6XJ::I64 = I64[Sp + 40];
           if (_sb6XI::I64 == I64[R1 + 31]) goto cb8Ma; else goto cb8M2;
       cb8Ma: // global
           _sb6XY::P64 = P64[Sp + 8];
           _sb6Yp::P64 = P64[_sb6XY::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           I64[Hp - 80] = _sb6XG::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sb6Yp::P64;
           call MO_WriteBarrier();
           P64[_sb6XY::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XY::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb6XH::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb6XG::I64;
           I64[Hp - 16] = _sb6XI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sb6XJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8M2: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sb6XG::I64;
           I64[Hp - 64] = _sb6XI::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sb6XJ::I64;
           _cb8M0::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cb8M0::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8Md() //  [R1]
         { info_tbl: [(cb8Md,
                       label: block_cb8Md_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Md: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb8N9; else goto cb8Mv;
       cb8N9: // global
           I64[Sp + 16] = block_cb8N8_info;
           R1 = P64[Sp + 80];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub8NT; else goto cb8Na;
       ub8NT: // global
           call _cb8N8(R1) args: 0, res: 0, upd: 0;
       cb8Na: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8Mv: // global
           _sb6XS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb8Mo_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sb6XS::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb8N8() //  [R1]
         { info_tbl: [(cb8N8,
                       label: block_cb8N8_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8N8: // global
           if (R1 & 7 == 1) goto cb8Ng; else goto cb8No;
       cb8Ng: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8Nj; else goto cb8Ni;
       cb8Nj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8Ni: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8No: // global
           _sb6Z8::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cb8Nm_info;
           R1 = _sb6Z8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub8NW; else goto cb8Np;
       ub8NW: // global
           call _cb8Nm(R1) args: 0, res: 0, upd: 0;
       cb8Np: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Nm() //  [R1]
         { info_tbl: [(cb8Nm,
                       label: block_cb8Nm_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Nm: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb8Nv; else goto cb8Nu;
       cb8Nv: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8Nu: // global
           _sb6XG::I64 = I64[Sp + 64];
           _sb6XH::P64 = P64[Sp + 24];
           _sb6XI::I64 = I64[Sp + 32];
           _sb6XJ::I64 = I64[Sp + 40];
           if (_sb6XI::I64 == I64[R1 + 31]) goto cb8NJ; else goto cb8NB;
       cb8NJ: // global
           _sb6XY::P64 = P64[Sp + 8];
           _sb6Zk::P64 = P64[_sb6XY::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           I64[Hp - 80] = _sb6XG::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sb6Zk::P64;
           call MO_WriteBarrier();
           P64[_sb6XY::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XY::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb6XH::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb6XG::I64;
           I64[Hp - 16] = _sb6XI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sb6XJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8NB: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sb6XG::I64;
           I64[Hp - 64] = _sb6XI::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sb6XJ::I64;
           _cb8Nz::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cb8Nz::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8Mo() //  [R1]
         { info_tbl: [(cb8Mo,
                       label: block_cb8Mo_info
                       rep:StackRep [False, False, False, True, False, True, True, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Mo: // global
           _sb6XL::P64 = P64[Sp + 72];
           _sb6XU::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb6XU::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XU::P64);
           I64[Sp + 8] = block_cb8Mt_info;
           R1 = _sb6XL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub8NU; else goto cb8Mx;
       ub8NU: // global
           call _cb8Mt(R1) args: 0, res: 0, upd: 0;
       cb8Mx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Mt() //  [R1]
         { info_tbl: [(cb8Mt,
                       label: block_cb8Mt_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Mt: // global
           if (R1 & 7 == 1) goto cb8MD; else goto cb8ML;
       cb8MD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8MG; else goto cb8MF;
       cb8MG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8MF: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8ML: // global
           _sb6YN::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cb8MJ_info;
           R1 = _sb6YN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub8NV; else goto cb8MM;
       ub8NV: // global
           call _cb8MJ(R1) args: 0, res: 0, upd: 0;
       cb8MM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8MJ() //  [R1]
         { info_tbl: [(cb8MJ,
                       label: block_cb8MJ_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8MJ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb8MS; else goto cb8MR;
       cb8MS: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8MR: // global
           _sb6XG::I64 = I64[Sp + 64];
           _sb6XH::P64 = P64[Sp + 24];
           _sb6XI::I64 = I64[Sp + 32];
           _sb6XJ::I64 = I64[Sp + 40];
           if (_sb6XI::I64 == I64[R1 + 31]) goto cb8N6; else goto cb8MY;
       cb8N6: // global
           _sb6XY::P64 = P64[Sp + 8];
           _sb6YZ::P64 = P64[_sb6XY::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           I64[Hp - 80] = _sb6XG::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sb6YZ::P64;
           call MO_WriteBarrier();
           P64[_sb6XY::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XY::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb6XH::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb6XG::I64;
           I64[Hp - 16] = _sb6XI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sb6XJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8MY: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sb6XG::I64;
           I64[Hp - 64] = _sb6XI::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sb6XJ::I64;
           _cb8MW::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cb8MW::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.04025939 UTC

[section ""data" . GHC.IO.Handle.Text.commitBuffer'1_closure" {
     GHC.IO.Handle.Text.commitBuffer'1_closure:
         const GHC.IO.Handle.Text.commitBuffer'1_info;
 },
 GHC.IO.Handle.Text.commitBuffer'1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb8O4,
                       label: GHC.IO.Handle.Text.commitBuffer'1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8O4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb8Od; else goto cb8Oe;
       cb8Od: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.commitBuffer'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cb8Oe: // global
           I64[Sp - 40] = block_cb8O1_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8On; else goto cb8O2;
       ub8On: // global
           call _cb8O1(R1) args: 0, res: 0, upd: 0;
       cb8O2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8O1() //  [R1]
         { info_tbl: [(cb8O1,
                       label: block_cb8O1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8O1: // global
           I64[Sp - 8] = block_cb8O7_info;
           _sb6Zy::P64 = P64[R1 + 7];
           _sb6Zx::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb6Zy::P64;
           I64[Sp + 8] = _sb6Zx::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Om; else goto cb8O8;
       ub8Om: // global
           call _cb8O7(R1) args: 0, res: 0, upd: 0;
       cb8O8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8O7() //  [R1]
         { info_tbl: [(cb8O7,
                       label: block_cb8O7_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8O7: // global
           I64[Sp] = block_cb8Oc_info;
           _sb6ZA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb6ZA::I64;
           if (R1 & 7 != 0) goto ub8Oo; else goto cb8Oh;
       ub8Oo: // global
           call _cb8Oc(R1) args: 0, res: 0, upd: 0;
       cb8Oh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Oc() //  [R1]
         { info_tbl: [(cb8Oc,
                       label: block_cb8Oc_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Oc: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wcommitBuffer'_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.04194139 UTC

[section ""data" . GHC.IO.Handle.Text.commitBuffer'_closure" {
     GHC.IO.Handle.Text.commitBuffer'_closure:
         const GHC.IO.Handle.Text.commitBuffer'_info;
 },
 GHC.IO.Handle.Text.commitBuffer'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb8Ot,
                       label: GHC.IO.Handle.Text.commitBuffer'_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Ot: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.commitBuffer'1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.042677218 UTC

[section ""cstring" . lvl1_rb6WD_bytes" {
     lvl1_rb6WD_bytes:
         I8[] [99,111,109,109,105,116,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.043395085 UTC

[section ""data" . lvl2_rb6WE_closure" {
     lvl2_rb6WE_closure:
         const lvl2_rb6WE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rb6WE_entry() //  [R1]
         { info_tbl: [(cb8OC,
                       label: lvl2_rb6WE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8OC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8OD; else goto cb8OE;
       cb8OD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8OE: // global
           (_cb8Oz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8Oz::I64 == 0) goto cb8OB; else goto cb8OA;
       cb8OB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8OA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8Oz::I64;
           R2 = lvl1_rb6WD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.044220293 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutChar3_bytes" {
     GHC.IO.Handle.Text.hPutChar3_bytes:
         I8[] [104,80,117,116,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.044936353 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar2_closure" {
     GHC.IO.Handle.Text.hPutChar2_closure:
         const GHC.IO.Handle.Text.hPutChar2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar2_entry() //  [R1]
         { info_tbl: [(cb8OL,
                       label: GHC.IO.Handle.Text.hPutChar2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8OL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8OM; else goto cb8ON;
       cb8OM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8ON: // global
           (_cb8OI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8OI::I64 == 0) goto cb8OK; else goto cb8OJ;
       cb8OK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8OJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8OI::I64;
           R2 = GHC.IO.Handle.Text.hPutChar3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.048068049 UTC

[section ""data" . GHC.IO.Handle.Text.$whPutChar_closure" {
     GHC.IO.Handle.Text.$whPutChar_closure:
         const GHC.IO.Handle.Text.$whPutChar_info;
         const 0;
 },
 act_sb6ZG_entry() //  [R1, R2]
         { info_tbl: [(cb8P0,
                       label: act_sb6ZG_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8P0: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cb8P1; else goto cb8P2;
       cb8P1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8P2: // global
           I64[Sp - 16] = block_cb8OX_info;
           _sb6ZE::I64 = I64[R1 + 6];
           R1 = R2;
           I64[Sp - 8] = _sb6ZE::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub8QG; else goto cb8OY;
       ub8QG: // global
           call _cb8OX(R1) args: 0, res: 0, upd: 0;
       cb8OY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8OX() //  [R1]
         { info_tbl: [(cb8OX,
                       label: block_cb8OX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8OX: // global
           _sb702::P64 = P64[P64[R1 + 71] + 8];
           _sb703::I64 = I64[Sp + 8];
           if (_sb703::I64 == 10) goto cb8PZ; else goto cb8Pj;
       cb8PZ: // global
           I64[Sp - 40] = block_cb8Pq_info;
           _sb6ZJ::P64 = R1;
           _sb6ZL::P64 = P64[R1 + 15];
           _sb6ZN::P64 = P64[R1 + 31];
           _sb6ZP::P64 = P64[R1 + 47];
           _sb6ZQ::P64 = P64[R1 + 55];
           R1 = P64[R1 + 119];
           P64[Sp - 32] = _sb6ZN::P64;
           P64[Sp - 24] = _sb6ZP::P64;
           P64[Sp - 16] = _sb6ZQ::P64;
           P64[Sp - 8] = _sb702::P64;
           P64[Sp] = _sb6ZL::P64;
           P64[Sp + 8] = _sb6ZJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub8QF; else goto cb8Q0;
       ub8QF: // global
           call _cb8Pq(R1) args: 0, res: 0, upd: 0;
       cb8Q0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8Pj: // global
           I64[Sp - 8] = block_cb8P8_info;
           _sb6ZJ::P64 = R1;
           R1 = _sb702::P64;
           I64[Sp] = _sb703::I64;
           P64[Sp + 8] = _sb6ZJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8QE; else goto cb8P9;
       ub8QE: // global
           call _cb8P8(R1) args: 0, res: 0, upd: 0;
       cb8P9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Pq() //  [R1]
         { info_tbl: [(cb8Pq,
                       label: block_cb8Pq_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Pq: // global
           _sb702::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cb8Q7; else goto cb8Qh;
       cb8Q7: // global
           I64[Sp] = block_cb8Q4_info;
           R1 = _sb702::P64;
           if (R1 & 7 != 0) goto ub8QH; else goto cb8Q8;
       ub8QH: // global
           call _cb8Q4(R1) args: 0, res: 0, upd: 0;
       cb8Q8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb8Qh: // global
           I64[Sp] = block_cb8Qf_info;
           R1 = _sb702::P64;
           if (R1 & 7 != 0) goto ub8QI; else goto cb8Qi;
       ub8QI: // global
           call _cb8Qf(R1) args: 0, res: 0, upd: 0;
       cb8Qi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Q4() //  [R1]
         { info_tbl: [(cb8Q4,
                       label: block_cb8Q4_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Q4: // global
           _sb70L::P64 = P64[R1 + 7];
           _sb70M::P64 = P64[R1 + 15];
           _sb70K::I64 = I64[R1 + 23];
           _sb70N::I64 = I64[R1 + 31];
           _sb70O::I64 = I64[R1 + 39];
           _sb70P::I64 = I64[R1 + 47];
           I32[_sb70K::I64 + (_sb70P::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb70L::P64);
           I64[Sp + 32] = _sb70K::I64;
           P64[Sp] = _sb70L::P64;
           P64[Sp - 32] = _sb70M::P64;
           I64[Sp - 24] = _sb70N::I64;
           I64[Sp - 16] = _sb70O::I64;
           I64[Sp - 8] = _sb70P::I64 + 1;
           Sp = Sp - 32;
           call _sb70h() args: 0, res: 0, upd: 0;
     }
 },
 _cb8Qf() //  [R1]
         { info_tbl: [(cb8Qf,
                       label: block_cb8Qf_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Qf: // global
           _sb70V::P64 = P64[R1 + 7];
           _sb70W::P64 = P64[R1 + 15];
           _sb70U::I64 = I64[R1 + 23];
           _sb70X::I64 = I64[R1 + 31];
           _sb70Y::I64 = I64[R1 + 39];
           _sb70Z::I64 = I64[R1 + 47];
           I32[_sb70U::I64 + (_sb70Z::I64 << 2)] = 13 :: W32;
           call MO_Touch(_sb70V::P64);
           _sb712::I64 = _sb70Z::I64 + 1;
           I32[_sb70U::I64 + (_sb712::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb70V::P64);
           P64[Sp - 32] = _sb70W::P64;
           I64[Sp - 24] = _sb70X::I64;
           I64[Sp - 16] = _sb70Y::I64;
           I64[Sp - 8] = _sb712::I64 + 1;
           P64[Sp] = _sb70V::P64;
           I64[Sp + 32] = _sb70U::I64;
           Sp = Sp - 32;
           call _sb70h() args: 0, res: 0, upd: 0;
     }
 },
 _sb70h() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb70h: // global
           _sb70k::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cb8Pu_info;
           R6 = I64[Sp + 8];
           R5 = P64[Sp];
           R4 = _sb70k::P64;
           R3 = I64[Sp + 64];
           R2 = P64[Sp + 80];
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb8Pu() //  []
         { info_tbl: [(cb8Pu,
                       label: block_cb8Pu_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Pu: // global
           I64[Sp] = block_cb8Pw_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto ub8QJ; else goto cb8Pz;
       ub8QJ: // global
           call _cb8Pw(R1) args: 0, res: 0, upd: 0;
       cb8Pz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Pw() //  [R1]
         { info_tbl: [(cb8Pw,
                       label: block_cb8Pw_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Pw: // global
           if (R1 & 7 == 2) goto cb8PK; else goto ub8QC;
       cb8PK: // global
           _sb70v::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cb8PI_info;
           R1 = _sb70v::P64;
           if (R1 & 7 != 0) goto ub8QK; else goto cb8PL;
       ub8QK: // global
           call _cb8PI(R1) args: 0, res: 0, upd: 0;
       cb8PL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub8QC: // global
           Sp = Sp + 56;
           call _cb8PY() args: 0, res: 0, upd: 0;
     }
 },
 _cb8PI() //  [R1]
         { info_tbl: [(cb8PI,
                       label: block_cb8PI_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8PI: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ub8QD; else goto cb8PV;
       ub8QD: // global
           Sp = Sp + 56;
           call _cb8PY() args: 0, res: 0, upd: 0;
       cb8PV: // global
           _sb6ZN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb8PT_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sb6ZN::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb8PT() //  [R1]
         { info_tbl: [(cb8PT,
                       label: block_cb8PT_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8PT: // global
           _sb6ZP::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb6ZP::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6ZP::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8PY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8PY: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8P8() //  [R1]
         { info_tbl: [(cb8P8,
                       label: block_cb8P8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8P8: // global
           _sb6ZJ::P64 = P64[Sp + 16];
           _sb706::P64 = P64[R1 + 7];
           _sb707::P64 = P64[R1 + 15];
           _sb705::I64 = I64[R1 + 23];
           _sb708::I64 = I64[R1 + 31];
           _sb709::I64 = I64[R1 + 39];
           _sb70a::I64 = I64[R1 + 47];
           I32[_sb705::I64 + (_sb70a::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp + 8]);
           call MO_Touch(_sb706::P64);
           I64[Sp + 16] = block_cb8Ph_info;
           R6 = _sb708::I64;
           R5 = _sb707::P64;
           R4 = _sb706::P64;
           R3 = _sb705::I64;
           R2 = _sb6ZJ::P64;
           I64[Sp] = _sb709::I64;
           I64[Sp + 8] = _sb70a::I64 + 1;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb8Ph() //  []
         { info_tbl: [(cb8Ph,
                       label: block_cb8Ph_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Ph: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$whPutChar_entry() //  [R2, R3]
         { info_tbl: [(cb8QW,
                       label: GHC.IO.Handle.Text.$whPutChar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8QW: // global
           _sb6ZE::I64 = R3;
           _sb6ZD::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cb8QX; else goto cb8QY;
       cb8QY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb8R0; else goto cb8QZ;
       cb8R0: // global
           HpAlloc = 16;
           goto cb8QX;
       cb8QX: // global
           R3 = _sb6ZE::I64;
           R2 = _sb6ZD::P64;
           R1 = GHC.IO.Handle.Text.$whPutChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8QZ: // global
           I64[Hp - 8] = act_sb6ZG_info;
           I64[Hp] = _sb6ZE::I64;
           I64[Sp - 16] = block_cb8QP_info;
           R1 = _sb6ZD::P64;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub8R7; else goto cb8QQ;
       ub8R7: // global
           call _cb8QP(R1) args: 0, res: 0, upd: 0;
       cb8QQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8QP() //  [R1]
         { info_tbl: [(cb8QP,
                       label: block_cb8QP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8QP: // global
           _cb8OS::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cb8QT; else goto cb8QU;
       cb8QT: // global
           R5 = _cb8OS::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutChar2_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cb8QU: // global
           R5 = _cb8OS::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutChar2_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.052761926 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar1_closure" {
     GHC.IO.Handle.Text.hPutChar1_closure:
         const GHC.IO.Handle.Text.hPutChar1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar1_entry() //  [R2, R3]
         { info_tbl: [(cb8Rf,
                       label: GHC.IO.Handle.Text.hPutChar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Rf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8Rg; else goto cb8Rh;
       cb8Rg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutChar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8Rh: // global
           I64[Sp - 16] = block_cb8Rc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub8Rl; else goto cb8Rd;
       ub8Rl: // global
           call _cb8Rc(R1) args: 0, res: 0, upd: 0;
       cb8Rd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Rc() //  [R1]
         { info_tbl: [(cb8Rc,
                       label: block_cb8Rc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Rc: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.054067411 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar_closure" {
     GHC.IO.Handle.Text.hPutChar_closure:
         const GHC.IO.Handle.Text.hPutChar_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar_entry() //  [R2, R3]
         { info_tbl: [(cb8Rq,
                       label: GHC.IO.Handle.Text.hPutChar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Rq: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutChar1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.055243107 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr7_closure" {
     GHC.IO.Handle.Text.hPutStr7_closure:
         const GHC.IO.Handle.Text.hPutStr7_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr7_entry() //  [R2, R3]
         { info_tbl: [(cb8RE,
                       label: GHC.IO.Handle.Text.hPutStr7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8RE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8RF; else goto ub8RW;
       cb8RF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ub8RW: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cb8Ru() args: 0, res: 0, upd: 0;
     }
 },
 _cb8Ru() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Ru: // global
           I64[Sp - 8] = block_cb8Rx_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8RY; else goto cb8Ry;
       ub8RY: // global
           call _cb8Rx(R1) args: 0, res: 0, upd: 0;
       cb8Ry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Rx() //  [R1]
         { info_tbl: [(cb8Rx,
                       label: block_cb8Rx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Rx: // global
           if (R1 & 7 == 1) goto cb8RB; else goto cb8RC;
       cb8RB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8RC: // global
           I64[Sp] = block_cb8RM_info;
           _sb71m::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sb71m::P64;
           if (R1 & 7 != 0) goto ub8RZ; else goto cb8RO;
       ub8RZ: // global
           call _cb8RM(R1) args: 0, res: 0, upd: 0;
       cb8RO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8RM() //  [R1]
         { info_tbl: [(cb8RM,
                       label: block_cb8RM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8RM: // global
           I64[Sp] = block_cb8RS_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8RS() //  []
         { info_tbl: [(cb8RS,
                       label: block_cb8RS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8RS: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cb8Ru() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.05750316 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar3_closure" {
     GHC.IO.Handle.Text.hGetChar3_closure:
         const GHC.IO.Handle.Text.hGetChar3_info;
         const 0;
 },
 sat_sb71H_entry() //  [R1]
         { info_tbl: [(cb8Sx,
                       label: sat_sb71H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Sx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8Sy; else goto cb8Sz;
       cb8Sy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Sz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetChar3_entry() //  [R2]
         { info_tbl: [(cb8SA,
                       label: GHC.IO.Handle.Text.hGetChar3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8SA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8SB; else goto cb8SC;
       cb8SB: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetChar3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8SC: // global
           I64[Sp - 8] = block_cb8S6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8SY; else goto cb8S7;
       ub8SY: // global
           call _cb8S6(R1) args: 0, res: 0, upd: 0;
       cb8S7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8S6() //  [R1]
         { info_tbl: [(cb8S6,
                       label: block_cb8S6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8S6: // global
           I64[Sp - 16] = block_cb8Sb_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Sb() //  [R1]
         { info_tbl: [(cb8Sb,
                       label: block_cb8Sb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Sb: // global
           I64[Sp] = block_cb8Sf_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Sf() //  [R1]
         { info_tbl: [(cb8Sf,
                       label: block_cb8Sf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Sf: // global
           if (R1 & 7 == 1) goto cb8SI; else goto cb8SK;
       cb8SI: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cb8SK: // global
           I64[Sp + 16] = block_cb8Sk_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Sk() //  [R1]
         { info_tbl: [(cb8Sk,
                       label: block_cb8Sk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Sk: // global
           I64[Sp - 8] = block_cb8So_info;
           _sb71z::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sb71z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8SX; else goto cb8Sp;
       ub8SX: // global
           call _cb8So(R1) args: 0, res: 0, upd: 0;
       cb8Sp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8So() //  [R1]
         { info_tbl: [(cb8So,
                       label: block_cb8So_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8So: // global
           if (I32[I64[R1 - 1] + 20] == 4 :: W32) goto cb8SU; else goto cb8SN;
       cb8SU: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8SN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8SQ; else goto cb8SP;
       cb8SQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8SP: // global
           I64[Hp - 16] = sat_sb71H_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.059527275 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetChar7_bytes" {
     GHC.IO.Handle.Text.hGetChar7_bytes:
         I8[] [104,71,101,116,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.060211687 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar6_closure" {
     GHC.IO.Handle.Text.hGetChar6_closure:
         const GHC.IO.Handle.Text.hGetChar6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar6_entry() //  [R1]
         { info_tbl: [(cb8T5,
                       label: GHC.IO.Handle.Text.hGetChar6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8T5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8T6; else goto cb8T7;
       cb8T6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8T7: // global
           (_cb8T2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb8T2::I64 == 0) goto cb8T4; else goto cb8T3;
       cb8T4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb8T3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb8T2::I64;
           R2 = GHC.IO.Handle.Text.hGetChar7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.06114083 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar5_closure" {
     GHC.IO.Handle.Text.hGetChar5_closure:
         const GHC.Types.C#_con_info;
         const 13;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.061758282 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar4_closure" {
     GHC.IO.Handle.Text.hGetChar4_closure:
         const GHC.Types.C#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.06669917 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar2_closure" {
     GHC.IO.Handle.Text.hGetChar2_closure:
         const GHC.IO.Handle.Text.hGetChar2_info;
         const 0;
 },
 sat_sb72q_entry() //  [R1]
         { info_tbl: [(cb8TW,
                       label: sat_sb72q_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8TW: // global
           _sb72q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb8TX; else goto cb8TY;
       cb8TY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8U0; else goto cb8TZ;
       cb8U0: // global
           HpAlloc = 56;
           goto cb8TX;
       cb8TX: // global
           R1 = _sb72q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8TZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb72q::P64;
           _sb72e::P64 = P64[_sb72q::P64 + 16];
           _sb72f::P64 = P64[_sb72q::P64 + 24];
           _sb72d::I64 = I64[_sb72q::P64 + 32];
           _sb72g::I64 = I64[_sb72q::P64 + 40];
           _sb72i::I64 = I64[_sb72q::P64 + 48];
           _sb72n::I64 = I64[_sb72q::P64 + 56];
           if (_sb72n::I64 == _sb72i::I64) goto cb8TV; else goto cb8TU;
       cb8TV: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb8TU: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = _sb72n::I64;
           I64[Hp] = _sb72i::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb72v_entry() //  [R1]
         { info_tbl: [(cb8Ue,
                       label: sat_sb72v_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Ue: // global
           _sb72v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb8Uf; else goto cb8Ug;
       cb8Ug: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8Ui; else goto cb8Uh;
       cb8Ui: // global
           HpAlloc = 56;
           goto cb8Uf;
       cb8Uf: // global
           R1 = _sb72v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Uh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb72v::P64;
           _sb72e::P64 = P64[_sb72v::P64 + 16];
           _sb72f::P64 = P64[_sb72v::P64 + 24];
           _sb72d::I64 = I64[_sb72v::P64 + 32];
           _sb72g::I64 = I64[_sb72v::P64 + 40];
           _sb72i::I64 = I64[_sb72v::P64 + 48];
           _sb72n::I64 = I64[_sb72v::P64 + 56];
           if (_sb72n::I64 == _sb72i::I64) goto cb8Ud; else goto cb8Uc;
       cb8Ud: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb8Uc: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = _sb72n::I64;
           I64[Hp] = _sb72i::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb72P_entry() //  [R1]
         { info_tbl: [(cb8UD,
                       label: sat_sb72P_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8UD: // global
           _sb72P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb8UE; else goto cb8UF;
       cb8UF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8UH; else goto cb8UG;
       cb8UH: // global
           HpAlloc = 56;
           goto cb8UE;
       cb8UE: // global
           R1 = _sb72P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8UG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb72P::P64;
           _sb72A::P64 = P64[_sb72P::P64 + 16];
           _sb72B::P64 = P64[_sb72P::P64 + 24];
           _sb72z::I64 = I64[_sb72P::P64 + 32];
           _sb72C::I64 = I64[_sb72P::P64 + 40];
           _sb72E::I64 = I64[_sb72P::P64 + 56];
           _sb72N::I64 = I64[_sb72P::P64 + 48] + 1;
           if (_sb72N::I64 == _sb72E::I64) goto cb8UR; else goto cb8UO;
       cb8UR: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72A::P64;
           P64[Hp - 32] = _sb72B::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb8UO: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72A::P64;
           P64[Hp - 32] = _sb72B::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = _sb72N::I64;
           I64[Hp] = _sb72E::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb73b_entry() //  [R1]
         { info_tbl: [(cb8V4,
                       label: sat_sb73b_info
                       rep:HeapRep 4 ptrs 4 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8V4: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cb8V5; else goto cb8V6;
       cb8V5: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb8V6: // global
           _sb71K::P64 = P64[R1 + 7];
           _sb72F::P64 = P64[R1 + 31];
           _sb72D::I64 = I64[R1 + 55];
           _sb72S::I64 = I64[R1 + 63] - _sb72D::I64;
           if (_sb72S::I64 != 0) goto ub8VN; else goto cb8V2;
       ub8VN: // global
           if (_sb72S::I64 != 1) goto ub8VP; else goto ub8VO;
       ub8VP: // global
           P64[Sp - 16] = _sb72F::P64;
           I64[Sp - 8] = _sb72S::I64;
           Sp = Sp - 16;
           call _cb8V9() args: 0, res: 0, upd: 0;
       ub8VO: // global
           P64[Sp - 64] = _sb71K::P64;
           I64[Sp - 56] = I64[R1 + 39];
           P64[Sp - 48] = P64[R1 + 15];
           P64[Sp - 40] = P64[R1 + 23];
           I64[Sp - 32] = I64[R1 + 47];
           I64[Sp - 24] = _sb72D::I64;
           P64[Sp - 16] = _sb72F::P64;
           I64[Sp - 8] = _sb72S::I64;
           Sp = Sp - 64;
           call _cb8Vs() args: 0, res: 0, upd: 0;
       cb8V2: // global
           I64[Sp - 8] = block_cb8Vj_info;
           R3 = _sb72F::P64;
           R2 = _sb71K::P64;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb8V9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8V9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb8Ve; else goto cb8Vd;
       cb8Ve: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb8V8_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb8Vd: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8V8() //  [R1]
         { info_tbl: [(cb8V8,
                       label: block_cb8V8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8V8: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb8V9() args: 0, res: 0, upd: 0;
     }
 },
 _cb8Vs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Vs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8Vw; else goto cb8Vv;
       cb8Vw: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cb8Vr_info;
           R1 = I64[Sp + 56];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb8Vv: // global
           _sb71K::P64 = P64[Sp];
           _sb72z::I64 = I64[Sp + 8];
           _sb72A::P64 = P64[Sp + 16];
           _sb72B::P64 = P64[Sp + 24];
           _sb72C::I64 = I64[Sp + 32];
           _sb72F::P64 = P64[Sp + 48];
           _sb730::I64 = %MO_UU_Conv_W32_W64(I32[_sb72z::I64 + (I64[Sp + 40] << 2)]);
           call MO_Touch(_sb72A::P64);
           if (_sb730::I64 == 13) goto cb8VJ; else goto cb8VC;
       cb8VJ: // global
           I32[_sb72z::I64] = 13 :: W32;
           call MO_Touch(_sb72A::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72A::P64;
           P64[Hp - 32] = _sb72B::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 56] = block_cb8VG_info;
           R3 = Hp - 47;
           R2 = _sb71K::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb8VC: // global
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = _sb72F::P64;
           _cb8VA::P64 = Hp - 46;
           Hp = Hp - 40;
           R1 = _cb8VA::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8Vr() //  [R1]
         { info_tbl: [(cb8Vr,
                       label: block_cb8Vr_info
                       rep:StackRep [False, True, False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Vr: // global
           I64[Sp + 64] = R1;
           Sp = Sp + 8;
           call _cb8Vs() args: 0, res: 0, upd: 0;
     }
 },
 _cb8VG() //  [R1]
         { info_tbl: [(cb8VG,
                       label: block_cb8VG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8VG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb8VM; else goto cb8VL;
       cb8VM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8VL: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8Vj() //  [R1]
         { info_tbl: [(cb8Vj,
                       label: block_cb8Vj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Vj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb8Vp; else goto cb8Vo;
       cb8Vp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8Vo: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb73x_entry() //  [R1]
         { info_tbl: [(cb8Wf,
                       label: sat_sb73x_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Wf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb8Wg; else goto cb8Wh;
       cb8Wg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Wh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb8Wc_info;
           _sb72D::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb72D::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub8Wz; else goto cb8Wd;
       ub8Wz: // global
           call _cb8Wc(R1) args: 0, res: 0, upd: 0;
       cb8Wd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb8Wc() //  [R1]
         { info_tbl: [(cb8Wc,
                       label: block_cb8Wc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Wc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb8Wm; else goto cb8Wl;
       cb8Wm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb8Wl: // global
           _sb73q::P64 = P64[R1 + 7];
           _sb73r::P64 = P64[R1 + 15];
           _sb73p::I64 = I64[R1 + 23];
           _sb73s::I64 = I64[R1 + 31];
           _sb73u::I64 = I64[R1 + 47];
           _sb73v::I64 = I64[Sp + 8] + 1;
           if (_sb73v::I64 == _sb73u::I64) goto cb8Wy; else goto cb8Wv;
       cb8Wy: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb73q::P64;
           P64[Hp - 32] = _sb73r::P64;
           I64[Hp - 24] = _sb73p::I64;
           I64[Hp - 16] = _sb73s::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb8Wv: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb73q::P64;
           P64[Hp - 32] = _sb73r::P64;
           I64[Hp - 24] = _sb73p::I64;
           I64[Hp - 16] = _sb73s::I64;
           I64[Hp - 8] = _sb73v::I64;
           I64[Hp] = _sb73u::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetChar2_entry() //  [R2]
         { info_tbl: [(cb8WA,
                       label: GHC.IO.Handle.Text.hGetChar2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8WA: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cb8WB; else goto cb8WC;
       cb8WB: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetChar2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8WC: // global
           I64[Sp - 8] = block_cb8Tc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Y4; else goto cb8Td;
       ub8Y4: // global
           call _cb8Tc(R1) args: 0, res: 0, upd: 0;
       cb8Td: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Tc() //  [R1]
         { info_tbl: [(cb8Tc,
                       label: block_cb8Tc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Tc: // global
           I64[Sp - 24] = block_cb8Th_info;
           _sb71K::P64 = R1;
           _sb71T::P64 = P64[R1 + 71];
           _sb71Y::P64 = P64[R1 + 111];
           R1 = P64[_sb71T::P64 + 8];
           P64[Sp - 16] = _sb71T::P64;
           P64[Sp - 8] = _sb71Y::P64;
           P64[Sp] = _sb71K::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub8XZ; else goto cb8Ti;
       ub8XZ: // global
           call _cb8Th(R1) args: 0, res: 0, upd: 0;
       cb8Ti: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Th() //  [R1]
         { info_tbl: [(cb8Th,
                       label: block_cb8Th_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Th: // global
           _sb729::I64 = I64[R1 + 39];
           _sb72a::I64 = I64[R1 + 47];
           if (_sb729::I64 == _sb72a::I64) goto cb8Xx; else goto cb8Xr;
       cb8Xx: // global
           I64[Sp] = block_cb8Xu_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb8Xr: // global
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sb729::I64;
           I64[Sp - 8] = _sb72a::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 40;
           call _sb72b() args: 0, res: 0, upd: 0;
     }
 },
 _cb8Xu() //  [R1]
         { info_tbl: [(cb8Xu,
                       label: block_cb8Xu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Xu: // global
           I64[Sp] = block_cb8Xw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8Y5; else goto cb8Xz;
       ub8Y5: // global
           call _cb8Xw(R1) args: 0, res: 0, upd: 0;
       cb8Xz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Xw() //  [R1]
         { info_tbl: [(cb8Xw,
                       label: block_cb8Xw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Xw: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sb72b() args: 0, res: 0, upd: 0;
     }
 },
 _sb72b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb72b: // global
           _sb71Y::P64 = P64[Sp + 56];
           _sb72h::I64 = I64[Sp + 24];
           _sb72l::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 40] + (_sb72h::I64 << 2)]);
           call MO_Touch(P64[Sp]);
           I64[Sp - 8] = block_cb8Tv_info;
           R1 = _sb71Y::P64;
           I64[Sp + 24] = _sb72h::I64 + 1;
           I64[Sp + 56] = _sb72l::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub8Y7; else goto cb8Tw;
       ub8Y7: // global
           call _cb8Tv(R1) args: 0, res: 0, upd: 0;
       cb8Tw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8Tv() //  [R1]
         { info_tbl: [(cb8Tv,
                       label: block_cb8Tv_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Tv: // global
           _sb71T::P64 = P64[Sp + 56];
           _sb72d::I64 = I64[Sp + 48];
           _sb72e::P64 = P64[Sp + 8];
           _sb72f::P64 = P64[Sp + 16];
           _sb72g::I64 = I64[Sp + 24];
           _sb72i::I64 = I64[Sp + 40];
           _sb72l::I64 = I64[Sp + 64];
           _sb72n::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cb8WL; else goto cb8WP;
       cb8WL: // global
           Hp = Hp + 80;
           _sb72o::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb8WS; else goto cb8WN;
       cb8WN: // global
           I64[Hp - 72] = sat_sb72q_info;
           P64[Hp - 56] = _sb72e::P64;
           P64[Hp - 48] = _sb72f::P64;
           I64[Hp - 40] = _sb72d::I64;
           I64[Hp - 32] = _sb72g::I64;
           I64[Hp - 24] = _sb72i::I64;
           I64[Hp - 16] = _sb72n::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 72;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sb72l::I64;
           R1 = Hp - 7;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8WP: // global
           Hp = Hp + 80;
           _sb72o::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb8WS; else goto cb8WR;
       cb8WS: // global
           HpAlloc = 80;
           R1 = _sb72o::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8WR: // global
           if (_sb72l::I64 == 13) goto cb8Xn; else goto cb8WY;
       cb8Xn: // global
           if (_sb72n::I64 == _sb72i::I64) goto cb8Xm; else goto cb8Xl;
       cb8Xm: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb72e::P64;
           P64[Hp - 56] = _sb72f::P64;
           I64[Hp - 48] = _sb72d::I64;
           I64[Hp - 40] = _sb72g::I64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           _cb8TL::P64 = Hp - 71;
           Hp = Hp - 24;
           I64[Sp + 64] = _sb72d::I64;
           P64[Sp + 48] = _sb72e::P64;
           P64[Sp + 40] = _sb72f::P64;
           I64[Sp + 32] = _sb72g::I64;
           I64[Sp + 24] = 0;
           I64[Sp + 16] = 0;
           P64[Sp + 8] = _cb8TL::P64;
           goto ub8Y2;
       cb8Xl: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb72e::P64;
           P64[Hp - 56] = _sb72f::P64;
           I64[Hp - 48] = _sb72d::I64;
           I64[Hp - 40] = _sb72g::I64;
           I64[Hp - 32] = _sb72n::I64;
           I64[Hp - 24] = _sb72i::I64;
           _cb8TJ::P64 = Hp - 71;
           Hp = Hp - 24;
           P64[Sp + 8] = _cb8TJ::P64;
           I64[Sp + 16] = _sb72i::I64;
           I64[Sp + 24] = _sb72n::I64;
           I64[Sp + 32] = _sb72g::I64;
           P64[Sp + 40] = _sb72f::P64;
           P64[Sp + 48] = _sb72e::P64;
           I64[Sp + 64] = _sb72d::I64;
           goto ub8Y2;
       ub8Y2: // global
           call _cb8Un() args: 0, res: 0, upd: 0;
       cb8WY: // global
           I64[Hp - 72] = sat_sb72v_info;
           P64[Hp - 56] = _sb72e::P64;
           P64[Hp - 48] = _sb72f::P64;
           I64[Hp - 40] = _sb72d::I64;
           I64[Hp - 32] = _sb72g::I64;
           I64[Hp - 24] = _sb72i::I64;
           I64[Hp - 16] = _sb72n::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 72;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sb72l::I64;
           R1 = Hp - 7;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8Un() //  []
         { info_tbl: [(cb8Un,
                       label: block_cb8Un_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Un: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cb8X1; else goto cb8X0;
       cb8X1: // global
           HpAlloc = 72;
           I64[Sp] = block_cb8Un_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb8X0: // global
           _sb72z::I64 = I64[Sp + 64];
           _sb72A::P64 = P64[Sp + 48];
           _sb72B::P64 = P64[Sp + 40];
           _sb72C::I64 = I64[Sp + 32];
           _sb72D::I64 = I64[Sp + 24];
           _sb72E::I64 = I64[Sp + 16];
           _sb72F::P64 = P64[Sp + 8];
           if (_sb72D::I64 == _sb72E::I64) goto cb8X7; else goto cb8X6;
       cb8X7: // global
           I64[Hp - 64] = sat_sb73b_info;
           P64[Hp - 56] = P64[Sp + 72];
           P64[Hp - 48] = _sb72A::P64;
           P64[Hp - 40] = _sb72B::P64;
           P64[Hp - 32] = _sb72F::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = _sb72D::I64;
           I64[Hp] = _sb72E::I64;
           I64[Sp] = block_cb8VW_info;
           R2 = GHC.IO.Handle.Text.hGetChar3_closure+2;
           R1 = Hp - 63;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cb8X6: // global
           _sb71T::P64 = P64[Sp + 56];
           _sb72J::I64 = %MO_UU_Conv_W32_W64(I32[_sb72z::I64 + (_sb72D::I64 << 2)]);
           call MO_Touch(_sb72A::P64);
           if (_sb72J::I64 == 10) goto cb8X4; else goto cb8X3;
       cb8X4: // global
           I64[Hp - 64] = sat_sb72P_info;
           P64[Hp - 48] = _sb72A::P64;
           P64[Hp - 40] = _sb72B::P64;
           I64[Hp - 32] = _sb72z::I64;
           I64[Hp - 24] = _sb72C::I64;
           I64[Hp - 16] = _sb72D::I64;
           I64[Hp - 8] = _sb72E::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           Hp = Hp - 8;
           R1 = GHC.IO.Handle.Text.hGetChar4_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8X3: // global
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = _sb72F::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           Hp = Hp - 72;
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8VW() //  [R1]
         { info_tbl: [(cb8VW,
                       label: block_cb8VW_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8VW: // global
           I64[Sp] = block_cb8VY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub8Y3; else goto cb8VZ;
       ub8Y3: // global
           call _cb8VY(R1) args: 0, res: 0, upd: 0;
       cb8VZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8VY() //  [R1]
         { info_tbl: [(cb8VY,
                       label: block_cb8VY_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8VY: // global
           _sb71T::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cb8Xc; else goto cb8Xd;
       cb8Xc: // global
           _sb72F::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = _sb72F::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8Xd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb8Xg; else goto cb8Xf;
       cb8Xg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8Xf: // global
           _sb72D::I64 = I64[Sp + 24];
           _sb73h::P64 = P64[R1 + 6];
           _sb73k::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 64] + (_sb72D::I64 << 2)]);
           call MO_Touch(P64[Sp + 48]);
           if (_sb73k::I64 == 10) goto cb8Xj; else goto cb8Xi;
       cb8Xj: // global
           I64[Hp - 24] = sat_sb73x_info;
           P64[Hp - 8] = _sb73h::P64;
           I64[Hp] = _sb72D::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           R1 = GHC.IO.Handle.Text.hGetChar4_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8Xi: // global
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = _sb73h::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           Hp = Hp - 32;
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.076249301 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar1_closure" {
     GHC.IO.Handle.Text.hGetChar1_closure:
         const GHC.IO.Handle.Text.hGetChar1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar1_entry() //  [R2]
         { info_tbl: [(cb8Yc,
                       label: GHC.IO.Handle.Text.hGetChar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Yc: // global
           R4 = GHC.IO.Handle.Text.hGetChar2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetChar6_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.077124923 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar_closure" {
     GHC.IO.Handle.Text.hGetChar_closure:
         const GHC.IO.Handle.Text.hGetChar_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar_entry() //  [R2]
         { info_tbl: [(cb8Yj,
                       label: GHC.IO.Handle.Text.hGetChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Yj: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.07783265 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf3_closure" {
     GHC.IO.Handle.Text.hGetBuf3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.079726007 UTC

[section ""data" . $wunpack_nl_rb6WF_closure" {
     $wunpack_nl_rb6WF_closure:
         const $wunpack_nl_rb6WF_info;
 },
 $wunpack_nl_rb6WF_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Yn: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2,
                                        R1) args: 8, res: 0, upd: 8;
     }
 },
 $wunpackRB_sb73Z_entry() //  [R1, R2, R3]
         { info_tbl: [(cb8Zc,
                       label: $wunpackRB_sb73Z_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Zc: // global
           _sb741::I64 = R3;
           _sb740::P64 = R2;
           _sb73Z::P64 = R1;
           goto cb8Yz;
       cb8Yz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb8Zg; else goto cb8Zf;
       cb8Zg: // global
           HpAlloc = 40;
           R3 = _sb741::I64;
           R2 = _sb740::P64;
           R1 = _sb73Z::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8Zf: // global
           _sb73Q::I64 = I64[_sb73Z::P64 + 13];
           if (%MO_S_Ge_W64(_sb741::I64,
                            _sb73Q::I64)) goto cb8Za; else goto cb8Zb;
       cb8Za: // global
           _sb73O::I64 = I64[_sb73Z::P64 + 5];
           _sb747::I64 = %MO_UU_Conv_W32_W64(I32[_sb73O::I64 + (_sb741::I64 << 2)]);
           if (_sb747::I64 != 10) goto cb8Zi; else goto cb8Zp;
       cb8Zi: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sb747::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sb740::P64;
           _sb741::I64 = _sb741::I64 - 1;
           _sb740::P64 = Hp - 14;
           goto cb8Yz;
       cb8Zp: // global
           if (%MO_S_Le_W64(_sb741::I64,
                            _sb73Q::I64)) goto cb8Zk; else goto cb8Zo;
       cb8Zk: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sb740::P64;
           _cb8YT::P64 = Hp - 30;
           Hp = Hp - 16;
           _sb741::I64 = _sb741::I64 - 1;
           _sb740::P64 = _cb8YT::P64;
           goto cb8Yz;
       cb8Zo: // global
           if (I32[_sb73O::I64 + ((_sb741::I64 + -1) << 2)] == 13 :: W32) goto cb8Zn; else goto cb8Zm;
       cb8Zn: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sb740::P64;
           _cb8Z8::P64 = Hp - 30;
           Hp = Hp - 16;
           _sb741::I64 = _sb741::I64 - 2;
           _sb740::P64 = _cb8Z8::P64;
           goto cb8Yz;
       cb8Zm: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sb740::P64;
           _cb8Z3::P64 = Hp - 30;
           Hp = Hp - 16;
           _sb741::I64 = _sb741::I64 - 1;
           _sb740::P64 = _cb8Z3::P64;
           goto cb8Yz;
       cb8Zb: // global
           Hp = Hp - 40;
           R1 = _sb740::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wunpack_nl_rb6WF_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb8Zt,
                       label: $wunpack_nl_rb6WF_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [True, False, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8Zt: // global
           _sb73S::P64 = R6;
           _sb73R::I64 = R5;
           _sb73Q::I64 = R4;
           _sb73P::P64 = R3;
           _sb73O::I64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cb8Zu; else goto cb8Zv;
       cb8Zv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8Zx; else goto cb8Zw;
       cb8Zx: // global
           HpAlloc = 24;
           goto cb8Zu;
       cb8Zu: // global
           R1 = $wunpack_nl_rb6WF_closure;
           I64[Sp - 40] = _sb73O::I64;
           P64[Sp - 32] = _sb73P::P64;
           I64[Sp - 24] = _sb73Q::I64;
           I64[Sp - 16] = _sb73R::I64;
           P64[Sp - 8] = _sb73S::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cb8Zw: // global
           if (_sb73Q::I64 == _sb73R::I64) goto cb8Zs; else goto cb8Zr;
       cb8Zs: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb73S::P64;
           P64[Hp] = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb8Zr: // global
           _sb73Y::I64 = %MO_UU_Conv_W32_W64(I32[_sb73O::I64 + ((_sb73R::I64 + -1) << 2)]);
           I64[Hp - 16] = $wunpackRB_sb73Z_info;
           I64[Hp - 8] = _sb73O::I64;
           I64[Hp] = _sb73Q::I64;
           _cb8Yx::P64 = Hp - 13;
           if (_sb73Y::I64 == 13) goto cb8ZZ; else goto cb8ZJ;
       cb8ZZ: // global
           I64[Sp - 24] = block_cb8ZR_info;
           R3 = _sb73R::I64 - 2;
           R2 = _sb73S::P64;
           R1 = _cb8Yx::P64;
           P64[Sp - 16] = _sb73P::P64;
           I64[Sp - 8] = _sb73R::I64;
           Sp = Sp - 24;
           call $wunpackRB_sb73Z_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       cb8ZJ: // global
           I64[Sp - 24] = block_cb8ZD_info;
           R3 = _sb73R::I64 - 1;
           R2 = _sb73S::P64;
           R1 = _cb8Yx::P64;
           P64[Sp - 16] = _sb73P::P64;
           I64[Sp - 8] = _sb73R::I64;
           Sp = Sp - 24;
           call $wunpackRB_sb73Z_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8ZR() //  [R1]
         { info_tbl: [(cb8ZR,
                       label: block_cb8ZR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ZR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb902; else goto cb901;
       cb902: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb901: // global
           _sb73R::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sb73R::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb8ZD() //  [R1]
         { info_tbl: [(cb8ZD,
                       label: block_cb8ZD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8ZD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb8ZM; else goto cb8ZL;
       cb8ZM: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8ZL: // global
           _sb73R::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sb73R::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.082664745 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetContents4_bytes" {
     GHC.IO.Handle.Text.hGetContents4_bytes:
         I8[] [104,71,101,116,67,111,110,116,101,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.083413605 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents3_closure" {
     GHC.IO.Handle.Text.hGetContents3_closure:
         const GHC.IO.Handle.Text.hGetContents3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetContents3_entry() //  [R1]
         { info_tbl: [(cb90b,
                       label: GHC.IO.Handle.Text.hGetContents3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb90b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb90c; else goto cb90d;
       cb90c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb90d: // global
           (_cb908::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb908::I64 == 0) goto cb90a; else goto cb909;
       cb90a: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb909: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb908::I64;
           R2 = GHC.IO.Handle.Text.hGetContents4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.084325676 UTC

[section ""cstring" . lvl3_rb6WG_bytes" {
     lvl3_rb6WG_bytes:
         I8[] [13]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.08501297 UTC

[section ""data" . lvl4_rb6WH_closure" {
     lvl4_rb6WH_closure:
         const lvl4_rb6WH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rb6WH_entry() //  [R1]
         { info_tbl: [(cb90k,
                       label: lvl4_rb6WH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb90k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb90l; else goto cb90m;
       cb90l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb90m: // global
           (_cb90h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb90h::I64 == 0) goto cb90j; else goto cb90i;
       cb90j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb90i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb90h::I64;
           R2 = lvl3_rb6WG_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.089764073 UTC

[section ""data" . $wlvl_rb6WI_closure" {
     $wlvl_rb6WI_closure:
         const $wlvl_rb6WI_info;
         const 0;
 },
 sat_sb74S_entry() //  [R1]
         { info_tbl: [(cb90C,
                       label: sat_sb74S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb90C: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb90D; else goto cb90E;
       cb90D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb90E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb90v_info;
           _sb74E::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sb74E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub915; else goto cb90w;
       ub915: // global
           call _cb90v(R1) args: 0, res: 0, upd: 0;
       cb90w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb90v() //  [R1]
         { info_tbl: [(cb90v,
                       label: block_cb90v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb90v: // global
           if (R1 & 7 == 1) goto cb90z; else goto cb90A;
       cb90z: // global
           _sb74E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb90H_info;
           R1 = _sb74E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ub914; else goto cb90J;
       ub914: // global
           call _cb90H(R1) args: 0, res: 0, upd: 0;
       cb90J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cb90A: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cb90H() //  [R1]
         { info_tbl: [(cb90H,
                       label: block_cb90H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb90H: // global
           if (R1 & 7 == 1) goto cb90P; else goto cb90W;
       cb90P: // global
           Hp = Hp + 16;
           _sb74L::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb90Z; else goto cb90R;
       cb90R: // global
           _sb74M::P64 = P64[_sb74L::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sb74M::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb90W: // global
           Hp = Hp + 16;
           _sb74L::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb90Z; else goto cb90Y;
       cb90Z: // global
           HpAlloc = 16;
           R1 = _sb74L::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb90Y: // global
           _sb74O::P64 = P64[_sb74L::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sb74O::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rb6WI_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb918,
                       label: $wlvl_rb6WI_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb918: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb91c; else goto cb91b;
       cb91c: // global
           HpAlloc = 104;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_rb6WI_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb91b: // global
           I64[Hp - 96] = sat_sb74S_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = Hp - 96;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.091656206 UTC

[section ""cstring" . lvl5_rb6WJ_bytes" {
     lvl5_rb6WJ_bytes:
         I8[] [100,101,108,97,121,101,100,32,114,101,97,100,32,111,110,32,99,108,111,115,101,100,32,104,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.092361347 UTC

[section ""data" . lvl6_rb6WK_closure" {
     lvl6_rb6WK_closure:
         const lvl6_rb6WK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rb6WK_entry() //  [R1]
         { info_tbl: [(cb91j,
                       label: lvl6_rb6WK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb91j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb91k; else goto cb91l;
       cb91k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb91l: // global
           (_cb91g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb91g::I64 == 0) goto cb91i; else goto cb91h;
       cb91i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb91h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb91g::I64;
           R2 = lvl5_rb6WJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.093627678 UTC

[section ""data" . lvl7_rb6WL_closure" {
     lvl7_rb6WL_closure:
         const lvl7_rb6WL_info;
         const 0;
 },
 sat_sb74Y_entry() //  [R1]
         { info_tbl: [(cb91w,
                       label: sat_sb74Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb91w: // global
           _sb74Y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb91x; else goto cb91y;
       cb91y: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cb91A; else goto cb91z;
       cb91A: // global
           HpAlloc = 72;
           goto cb91x;
       cb91x: // global
           R1 = _sb74Y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb91z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb74Y::P64;
           _sb74U::P64 = P64[_sb74Y::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sb74U::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = lvl6_rb6WK_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl7_rb6WL_entry() //  [R2]
         { info_tbl: [(cb91B,
                       label: lvl7_rb6WL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb91B: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb91F; else goto cb91E;
       cb91F: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl7_rb6WL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb91E: // global
           I64[Hp - 16] = sat_sb74Y_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.094817391 UTC

[section ""cstring" . lvl8_rb6WM_bytes" {
     lvl8_rb6WM_bytes:
         I8[] [105,108,108,101,103,97,108,32,104,97,110,100,108,101,32,116,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.09553133 UTC

[section ""data" . lvl9_rb6WN_closure" {
     lvl9_rb6WN_closure:
         const lvl9_rb6WN_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rb6WN_entry() //  [R1]
         { info_tbl: [(cb91M,
                       label: lvl9_rb6WN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb91M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb91N; else goto cb91O;
       cb91N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb91O: // global
           (_cb91J::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb91J::I64 == 0) goto cb91L; else goto cb91K;
       cb91L: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb91K: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb91J::I64;
           R2 = lvl8_rb6WM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.096728836 UTC

[section ""data" . lvl10_rb6WO_closure" {
     lvl10_rb6WO_closure:
         const lvl10_rb6WO_info;
         const 0;
 },
 sat_sb753_entry() //  [R1]
         { info_tbl: [(cb91Z,
                       label: sat_sb753_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb91Z: // global
           _sb753::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb920; else goto cb921;
       cb921: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cb923; else goto cb922;
       cb923: // global
           HpAlloc = 72;
           goto cb920;
       cb920: // global
           R1 = _sb753::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb922: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb753::P64;
           _sb74Z::P64 = P64[_sb753::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sb74Z::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = lvl9_rb6WN_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl10_rb6WO_entry() //  [R2]
         { info_tbl: [(cb924,
                       label: lvl10_rb6WO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb924: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb928; else goto cb927;
       cb928: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl10_rb6WO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb927: // global
           I64[Hp - 16] = sat_sb753_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.103448552 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents2_closure" {
     GHC.IO.Handle.Text.hGetContents2_closure:
         const GHC.IO.Handle.Text.hGetContents2_info;
         const 0;
 },
 sat_sb77n_entry() //  [R1]
         { info_tbl: [(cb937,
                       label: sat_sb77n_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb937: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb938; else goto cb939;
       cb938: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb939: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cb935_info;
           _sb754::P64 = P64[R1 + 16];
           _sb75v::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sb754::P64;
           P64[Sp - 24] = _sb75v::P64;
           Sp = Sp - 40;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb935() //  [R1]
         { info_tbl: [(cb935,
                       label: block_cb935_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb935: // global
           I64[Sp - 24] = block_cb93c_info;
           _sb77b::P64 = P64[R1 + 31];
           _sb77c::P64 = P64[R1 + 39];
           _sb77d::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _sb77c::P64;
           P64[Sp - 8] = _sb77d::P64;
           P64[Sp] = _sb77b::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub93B; else goto cb93e;
       ub93B: // global
           call _cb93c(R1) args: 0, res: 0, upd: 0;
       cb93e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb93c() //  [R1]
         { info_tbl: [(cb93c,
                       label: block_cb93c_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb93c: // global
           if (I32[I64[R1 - 1] + 20] == 4 :: W32) goto cb93p; else goto cb93k;
       cb93p: // global
           _sb75v::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cb93n_info;
           R1 = _sb75v::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ub93C; else goto cb93q;
       ub93C: // global
           call _cb93n(R1) args: 0, res: 0, upd: 0;
       cb93q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cb93k: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 24];
           R3 = R1;
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call $wlvl_rb6WI_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 _cb93n() //  [R1]
         { info_tbl: [(cb93n,
                       label: block_cb93n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb93n: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb93z; else goto cb93y;
       cb93z: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb93y: // global
           R1 = lvl4_rb6WH_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb77p_entry() //  [R1, R2]
         { info_tbl: [(cb93D,
                       label: sat_sb77p_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb93D: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cb93E; else goto cb93F;
       cb93E: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb93F: // global
           I64[Sp - 32] = block_cb92G_info;
           _sb754::P64 = P64[R1 + 6];
           _sb75b::P64 = P64[R1 + 14];
           _sb75v::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb754::P64;
           P64[Sp - 16] = _sb75b::P64;
           P64[Sp - 8] = _sb75v::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub93V; else goto cb92H;
       ub93V: // global
           call _cb92G(R1) args: 0, res: 0, upd: 0;
       cb92H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb92G() //  [R1]
         { info_tbl: [(cb92G,
                       label: block_cb92G_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb92G: // global
           I64[Sp - 16] = block_cb92L_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb92L() //  [R1]
         { info_tbl: [(cb92L,
                       label: block_cb92L_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb92L: // global
           I64[Sp] = block_cb92P_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb92P() //  [R1]
         { info_tbl: [(cb92P,
                       label: block_cb92P_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb92P: // global
           if (R1 & 7 == 1) goto cb93L; else goto cb93O;
       cb93L: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cb93O: // global
           I64[Sp] = block_cb92U_info;
           R2 = P64[Sp + 32];
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb92U() //  [R1]
         { info_tbl: [(cb92U,
                       label: block_cb92U_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb92U: // global
           I64[Sp] = block_cb92W_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub93U; else goto cb92X;
       ub93U: // global
           call _cb92W(R1) args: 0, res: 0, upd: 0;
       cb92X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb92W() //  [R1]
         { info_tbl: [(cb92W,
                       label: block_cb92W_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb92W: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cb93S; else goto cb93R;
       cb93S: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb93R: // global
           _sb775::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_sb77n_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb775::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb76m_entry() //  [R1]
         { info_tbl: [(cb94T,
                       label: sat_sb76m_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb94T: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb94U; else goto cb94V;
       cb94U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb94V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cb94Q_info;
           _sb75H::P64 = P64[R1 + 16];
           _sb75I::P64 = P64[R1 + 24];
           _sb75G::I64 = I64[R1 + 40];
           _sb75J::I64 = I64[R1 + 48];
           _sb75L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _sb75G::I64;
           P64[Sp - 48] = _sb75H::P64;
           P64[Sp - 40] = _sb75I::P64;
           I64[Sp - 32] = _sb75J::I64;
           I64[Sp - 24] = _sb75L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ub95a; else goto cb94R;
       ub95a: // global
           call _cb94Q(R1) args: 0, res: 0, upd: 0;
       cb94R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb94Q() //  [R1]
         { info_tbl: [(cb94Q,
                       label: block_cb94Q_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb94Q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb950; else goto cb94Z;
       cb950: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb94Z: // global
           _sb75G::I64 = I64[Sp + 8];
           _sb75H::P64 = P64[Sp + 16];
           _sb75I::P64 = P64[Sp + 24];
           _sb75J::I64 = I64[Sp + 32];
           _sb75L::I64 = I64[Sp + 40];
           _sb76k::I64 = I64[R1 + 7];
           if (_sb76k::I64 == _sb75L::I64) goto cb959; else goto cb956;
       cb959: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb75H::P64;
           P64[Hp - 32] = _sb75I::P64;
           I64[Hp - 24] = _sb75G::I64;
           I64[Hp - 16] = _sb75J::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb956: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb75H::P64;
           P64[Hp - 32] = _sb75I::P64;
           I64[Hp - 24] = _sb75G::I64;
           I64[Hp - 16] = _sb75J::I64;
           I64[Hp - 8] = _sb76k::I64;
           I64[Hp] = _sb75L::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb76T_entry() //  [R1]
         { info_tbl: [(cb95b,
                       label: sat_sb76T_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb95b: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cb95c; else goto cb95d;
       cb95c: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb95d: // global
           I64[Sp - 40] = block_cb941_info;
           _sb754::P64 = P64[R1 + 7];
           _sb75b::P64 = P64[R1 + 15];
           _sb75k::P64 = P64[R1 + 23];
           _sb75p::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sb754::P64;
           P64[Sp - 24] = _sb75b::P64;
           P64[Sp - 16] = _sb75k::P64;
           P64[Sp - 8] = _sb75p::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub97h; else goto cb942;
       ub97h: // global
           call _cb941(R1) args: 0, res: 0, upd: 0;
       cb942: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb941() //  [R1]
         { info_tbl: [(cb941,
                       label: block_cb941_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb941: // global
           _sb75C::I64 = I64[R1 + 39];
           _sb75D::I64 = I64[R1 + 47];
           _sb76p::I64 = _sb75D::I64 - _sb75C::I64;
           if (_sb76p::I64 == 0) goto cb96d; else goto ub96Z;
       cb96d: // global
           I64[Sp] = block_cb96a_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       ub96Z: // global
           _sb75z::P64 = P64[R1 + 7];
           _sb75A::P64 = P64[R1 + 15];
           _sb75y::I64 = I64[R1 + 23];
           _sb75B::I64 = I64[R1 + 31];
           if (_sb76p::I64 != 1) goto ub970; else goto cb96q;
       ub970: // global
           P64[Sp - 40] = _sb75z::P64;
           P64[Sp - 32] = _sb75A::P64;
           I64[Sp - 24] = _sb75B::I64;
           I64[Sp - 16] = _sb75C::I64;
           I64[Sp - 8] = _sb75D::I64;
           I64[Sp] = _sb75y::I64;
           Sp = Sp - 40;
           call _cb96y() args: 0, res: 0, upd: 0;
       cb96q: // global
           I64[Sp - 48] = block_cb96p_info;
           R1 = P64[Sp + 32];
           P64[Sp - 40] = _sb75z::P64;
           P64[Sp - 32] = _sb75A::P64;
           I64[Sp - 24] = _sb75B::I64;
           I64[Sp - 16] = _sb75C::I64;
           I64[Sp - 8] = _sb75D::I64;
           I64[Sp] = _sb75y::I64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ub97a; else goto cb96s;
       ub97a: // global
           call _cb96p(R1) args: 0, res: 0, upd: 0;
       cb96s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb96a() //  [R1]
         { info_tbl: [(cb96a,
                       label: block_cb96a_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb96a: // global
           I64[Sp] = block_cb96c_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub97j; else goto cb96g;
       ub97j: // global
           call _cb96c(R1) args: 0, res: 0, upd: 0;
       cb96g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb96c() //  [R1]
         { info_tbl: [(cb96c,
                       label: block_cb96c_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb96c: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 32] = I64[R1 + 39];
           I64[Sp - 40] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _cb96p() //  [R1]
         { info_tbl: [(cb96p,
                       label: block_cb96p_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb96p: // global
           if (R1 & 7 == 1) goto ub971; else goto cb96z;
       ub971: // global
           Sp = Sp + 8;
           call _cb96y() args: 0, res: 0, upd: 0;
       cb96z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb96E; else goto cb96D;
       cb96E: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb96D: // global
           _sb75b::P64 = P64[Sp + 64];
           _sb75y::I64 = I64[Sp + 48];
           _sb75z::P64 = P64[Sp + 8];
           _sb75A::P64 = P64[Sp + 16];
           _sb75B::I64 = I64[Sp + 24];
           _sb75C::I64 = I64[Sp + 32];
           _sb75D::I64 = I64[Sp + 40];
           _sb76D::I64 = %MO_UU_Conv_W32_W64(I32[_sb75y::I64 + (_sb75C::I64 << 2)]);
           call MO_Touch(_sb75z::P64);
           if (_sb76D::I64 == 13) goto cb96Q; else goto cb96I;
       cb96Q: // global
           I32[_sb75y::I64] = 13 :: W32;
           call MO_Touch(_sb75z::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb75z::P64;
           P64[Hp - 32] = _sb75A::P64;
           I64[Hp - 24] = _sb75y::I64;
           I64[Hp - 16] = _sb75B::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 48] = block_cb96N_info;
           R3 = Hp - 47;
           R2 = _sb75b::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb96I: // global
           Hp = Hp - 56;
           I64[Sp + 8] = _sb75D::I64;
           I64[Sp + 16] = _sb75C::I64;
           I64[Sp + 24] = _sb75B::I64;
           P64[Sp + 32] = _sb75A::P64;
           P64[Sp + 40] = _sb75z::P64;
           I64[Sp + 48] = _sb75y::I64;
           Sp = Sp + 8;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _cb96y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb96y: // global
           I64[Sp + 40] = I64[Sp + 40];
           _sb75L::I64 = I64[Sp + 32];
           P64[Sp + 32] = P64[Sp];
           _sb75K::I64 = I64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 8] = _sb75K::I64;
           I64[Sp] = _sb75L::I64;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _cb96N() //  [R1]
         { info_tbl: [(cb96N,
                       label: block_cb96N_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb96N: // global
           I64[Sp] = block_cb96P_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub97o; else goto cb96S;
       ub97o: // global
           call _cb96P(R1) args: 0, res: 0, upd: 0;
       cb96S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb96P() //  [R1]
         { info_tbl: [(cb96P,
                       label: block_cb96P_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb96P: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 32] = I64[R1 + 39];
           I64[Sp - 40] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _sb75E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb75E: // global
           I64[Sp - 8] = block_cb94b_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.hGetContents2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb94b() //  [R1]
         { info_tbl: [(cb94b,
                       label: block_cb94b_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb94b: // global
           I64[Sp] = block_cb94d_info;
           _sb75O::P64 = R1;
           R1 = P64[Sp + 80];
           P64[Sp + 80] = _sb75O::P64;
           if (R1 & 7 != 0) goto ub97c; else goto cb94e;
       ub97c: // global
           call _cb94d(R1) args: 0, res: 0, upd: 0;
       cb94e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb94d() //  [R1]
         { info_tbl: [(cb94d,
                       label: block_cb94d_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb94d: // global
           _sb75G::I64 = I64[Sp + 48];
           _sb75H::P64 = P64[Sp + 40];
           _sb75K::I64 = I64[Sp + 16];
           _sb75L::I64 = I64[Sp + 8];
           _sb75O::P64 = P64[Sp + 80];
           if (R1 & 7 == 1) goto cb95i; else goto cb95S;
       cb95i: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cb95l; else goto cb95k;
       cb95l: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb95k: // global
           if (_sb75K::I64 == _sb75L::I64) goto cb95M; else goto cb95F;
       cb95M: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb75H::P64;
           P64[Hp - 56] = P64[Sp + 32];
           I64[Hp - 48] = _sb75G::I64;
           I64[Hp - 40] = I64[Sp + 24];
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           _sb75b::P64 = P64[Sp + 64];
           _sb75k::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb75k::P64 + 8] = Hp - 71;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb75k::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb75b::P64;
           P64[Hp] = _sb75O::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb95F: // global
           Hp = Hp - 80;
           I64[Sp + 56] = _sb75L::I64 - 1;
           P64[Sp + 80] = _sb75O::P64;
           Sp = Sp + 8;
           call _cb94s() args: 0, res: 0, upd: 0;
       cb95S: // global
           I64[Sp] = block_cb94F_info;
           R6 = _sb75O::P64;
           R5 = _sb75L::I64;
           R4 = _sb75K::I64;
           R3 = _sb75H::P64;
           R2 = _sb75G::I64;
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb94s() //  []
         { info_tbl: [(cb94s,
                       label: block_cb94s_info
                       rep:StackRep [True, True, False, False, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb94s: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb95A; else goto cb95z;
       cb95A: // global
           HpAlloc = 40;
           I64[Sp] = block_cb94s_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb95z: // global
           _sb75Z::P64 = P64[Sp + 72];
           _sb760::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_sb760::I64,
                            I64[Sp + 8])) goto cb95C; else goto cb95D;
       cb95C: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 40] + (_sb760::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sb75Z::P64;
           P64[Sp + 72] = Hp - 14;
           I64[Sp + 48] = _sb760::I64 - 1;
           call _cb94s() args: 0, res: 0, upd: 0;
       cb95D: // global
           Hp = Hp - 40;
           P64[Sp + 72] = _sb75Z::P64;
           Sp = Sp + 16;
           call _cb95n() args: 0, res: 0, upd: 0;
     }
 },
 _cb95n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb95n: // global
           Hp = Hp + 80;
           _sb75T::P64 = P64[Sp + 56];
           if (Hp > HpLim) (likely: False) goto cb95x; else goto cb95w;
       cb95x: // global
           HpAlloc = 80;
           I64[Sp - 8] = block_cb95m_info;
           R1 = _sb75T::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb95w: // global
           _sb75b::P64 = P64[Sp + 40];
           _sb75k::P64 = P64[Sp + 48];
           _sb75G::I64 = I64[Sp + 24];
           _sb75H::P64 = P64[Sp + 16];
           _sb75I::P64 = P64[Sp + 8];
           _sb75J::I64 = I64[Sp];
           call MO_Touch(_sb75H::P64);
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb75H::P64;
           P64[Hp - 56] = _sb75I::P64;
           I64[Hp - 48] = _sb75G::I64;
           I64[Hp - 40] = _sb75J::I64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           call MO_WriteBarrier();
           P64[_sb75k::P64 + 8] = Hp - 71;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb75k::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb75b::P64;
           P64[Hp] = _sb75T::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb95m() //  [R1]
         { info_tbl: [(cb95m,
                       label: block_cb95m_info
                       rep:StackRep [True, False, False, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb95m: // global
           P64[Sp + 64] = R1;
           Sp = Sp + 8;
           call _cb95n() args: 0, res: 0, upd: 0;
     }
 },
 _cb94F() //  [R1]
         { info_tbl: [(cb94F,
                       label: block_cb94F_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb94F: // global
           I64[Sp] = block_cb94H_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub97g; else goto cb94I;
       ub97g: // global
           call _cb94H(R1) args: 0, res: 0, upd: 0;
       cb94I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb94H() //  [R1]
         { info_tbl: [(cb94H,
                       label: block_cb94H_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb94H: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cb95W; else goto cb95V;
       cb95W: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb95V: // global
           _sb76h::P64 = P64[R1 + 7];
           _sb76i::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sb76m_info;
           P64[Hp - 64] = P64[Sp + 40];
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sb76i::P64;
           I64[Hp - 40] = I64[Sp + 48];
           I64[Hp - 32] = I64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           _sb75b::P64 = P64[Sp + 64];
           _sb75k::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb75k::P64 + 8] = Hp - 80;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb75k::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb75b::P64;
           P64[Hp] = _sb76h::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 act_sb758_entry() //  [R1, R2]
         { info_tbl: [(cb97q,
                       label: act_sb758_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb97q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb97r; else goto cb97s;
       cb97r: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb97s: // global
           I64[Sp - 16] = block_cb92p_info;
           _sb754::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sb754::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub97I; else goto cb92q;
       ub97I: // global
           call _cb92p(R1) args: 0, res: 0, upd: 0;
       cb92q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb92p() //  [R1]
         { info_tbl: [(cb92p,
                       label: block_cb92p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb92p: // global
           I64[Sp - 24] = block_cb92u_info;
           _sb75b::P64 = R1;
           _sb75k::P64 = P64[R1 + 71];
           _sb75p::P64 = P64[R1 + 111];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sb75k::P64;
           P64[Sp - 8] = _sb75p::P64;
           P64[Sp] = _sb75b::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub97H; else goto cb92v;
       ub97H: // global
           call _cb92u(R1) args: 0, res: 0, upd: 0;
       cb92v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb92u() //  [R1]
         { info_tbl: [(cb92u,
                       label: block_cb92u_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb92u: // global
           _sb754::P64 = P64[Sp + 32];
           _cb97F::P64 = R1 & 7;
           if (_cb97F::P64 == 1) goto cb97A; else goto ub97G;
       cb97A: // global
           R2 = _sb754::P64;
           Sp = Sp + 40;
           call lvl7_rb6WL_entry(R2) args: 8, res: 0, upd: 8;
       ub97G: // global
           if (_cb97F::P64 == 2) goto cb97B; else goto cb97x;
       cb97B: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cb97E; else goto cb97D;
       cb97E: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb97D: // global
           _sb75k::P64 = P64[Sp + 8];
           _sb75v::P64 = P64[_sb75k::P64 + 8];
           I64[Hp - 72] = sat_sb77p_info;
           P64[Hp - 64] = _sb754::P64;
           _sb75b::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sb75b::P64;
           P64[Hp - 48] = _sb75v::P64;
           I64[Hp - 40] = sat_sb76T_info;
           P64[Hp - 32] = _sb754::P64;
           P64[Hp - 24] = _sb75b::P64;
           P64[Hp - 16] = _sb75k::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sb75v::P64;
           R2 = Hp - 70;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       cb97x: // global
           R2 = _sb754::P64;
           Sp = Sp + 40;
           call lvl10_rb6WO_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb77w_entry() //  [R1]
         { info_tbl: [(cb97Q,
                       label: sat_sb77w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb97Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb97R; else goto cb97S;
       cb97R: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb97S: // global
           I64[Sp - 16] = block_cb92i_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cb92i() //  []
         { info_tbl: [(cb92i,
                       label: block_cb92i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb92i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb97V; else goto cb97U;
       cb97V: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb97U: // global
           I64[Hp - 8] = act_sb758_info;
           _sb754::P64 = P64[Sp + 8];
           P64[Hp] = _sb754::P64;
           I64[Sp] = block_cb97J_info;
           R1 = _sb754::P64;
           P64[Sp + 8] = Hp - 6;
           if (R1 & 7 != 0) goto ub982; else goto cb97K;
       ub982: // global
           call _cb97J(R1) args: 0, res: 0, upd: 0;
       cb97K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb97J() //  [R1]
         { info_tbl: [(cb97J,
                       label: block_cb97J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb97J: // global
           _cb92k::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cb97N; else goto cb97O;
       cb97N: // global
           R5 = _cb92k::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cb97O: // global
           R5 = _cb92k::P64;
           R4 = P64[R1 + 14];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.hGetContents2_entry() //  [R2]
         { info_tbl: [(cb983,
                       label: GHC.IO.Handle.Text.hGetContents2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb983: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb987; else goto cb986;
       cb987: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetContents2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb986: // global
           I64[Hp - 8] = sat_sb77w_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.115196751 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents1_closure" {
     GHC.IO.Handle.Text.hGetContents1_closure:
         const GHC.IO.Handle.Text.hGetContents1_info;
         const 0;
 },
 sat_sb77V_entry() //  [R1]
         { info_tbl: [(cb98q,
                       label: sat_sb77V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb98q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb98u; else goto cb98v;
       cb98u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb98v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb98n_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub98z; else goto cb98o;
       ub98z: // global
           call _cb98n(R1) args: 0, res: 0, upd: 0;
       cb98o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb98n() //  [R1]
         { info_tbl: [(cb98n,
                       label: block_cb98n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb98n: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cb98y; else goto cb98x;
       cb98y: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb98x: // global
           _sb77F::P64 = P64[R1 + 7];
           _sb77G::P64 = P64[R1 + 15];
           _sb77H::P64 = P64[R1 + 23];
           _sb77I::P64 = P64[R1 + 31];
           _sb77K::P64 = P64[R1 + 47];
           _sb77L::P64 = P64[R1 + 55];
           _sb77M::P64 = P64[R1 + 63];
           _sb77N::P64 = P64[R1 + 71];
           _sb77O::P64 = P64[R1 + 79];
           _sb77P::P64 = P64[R1 + 87];
           _sb77Q::P64 = P64[R1 + 95];
           _sb77R::P64 = P64[R1 + 103];
           _sb77S::P64 = P64[R1 + 111];
           _sb77T::P64 = P64[R1 + 119];
           _sb77U::P64 = P64[R1 + 127];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sb77F::P64;
           P64[Hp - 112] = _sb77G::P64;
           P64[Hp - 104] = _sb77H::P64;
           P64[Hp - 96] = _sb77I::P64;
           P64[Hp - 88] = GHC.IO.Handle.Types.SemiClosedHandle_closure+2;
           P64[Hp - 80] = _sb77K::P64;
           P64[Hp - 72] = _sb77L::P64;
           P64[Hp - 64] = _sb77M::P64;
           P64[Hp - 56] = _sb77N::P64;
           P64[Hp - 48] = _sb77O::P64;
           P64[Hp - 40] = _sb77P::P64;
           P64[Hp - 32] = _sb77Q::P64;
           P64[Hp - 24] = _sb77R::P64;
           P64[Hp - 16] = _sb77S::P64;
           P64[Hp - 8] = _sb77T::P64;
           P64[Hp] = _sb77U::P64;
           R1 = Hp - 127;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb77X_entry() //  [R1, R2]
         { info_tbl: [(cb98B,
                       label: sat_sb77X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb98B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb98C; else goto cb98D;
       cb98C: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb98D: // global
           I64[Sp - 16] = block_cb98h_info;
           _sb77z::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sb77z::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Text.hGetContents2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb98h() //  [R1]
         { info_tbl: [(cb98h,
                       label: block_cb98h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb98h: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb98G; else goto cb98F;
       cb98G: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb98F: // global
           I64[Hp - 40] = sat_sb77V_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.hGetContents1_entry() //  [R2]
         { info_tbl: [(cb98H,
                       label: GHC.IO.Handle.Text.hGetContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb98H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb98L; else goto cb98K;
       cb98L: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb98K: // global
           I64[Hp - 8] = sat_sb77X_info;
           P64[Hp] = R2;
           R4 = Hp - 6;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.117478804 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents_closure" {
     GHC.IO.Handle.Text.hGetContents_closure:
         const GHC.IO.Handle.Text.hGetContents_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetContents_entry() //  [R2]
         { info_tbl: [(cb98Q,
                       label: GHC.IO.Handle.Text.hGetContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb98Q: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.118582836 UTC

[section ""data" . go_rb6WP_closure" {
     go_rb6WP_closure:
         const go_rb6WP_info;
 },
 sat_sb782_entry() //  [R1]
         { info_tbl: [(cb997,
                       label: sat_sb782_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb997: // global
           R2 = P64[R1 + 16];
           call go_rb6WP_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 go_rb6WP_entry() //  [R2]
         { info_tbl: [(cb99e,
                       label: go_rb6WP_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb99e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb99f; else goto cb99g;
       cb99f: // global
           R2 = R2;
           R1 = go_rb6WP_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb99g: // global
           I64[Sp - 8] = block_cb98X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub99m; else goto cb98Y;
       ub99m: // global
           call _cb98X(R1) args: 0, res: 0, upd: 0;
       cb98Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb98X() //  [R1]
         { info_tbl: [(cb98X,
                       label: block_cb98X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb98X: // global
           if (R1 & 7 == 1) goto cb99b; else goto cb99c;
       cb99b: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb99c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb99l; else goto cb99k;
       cb99l: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb99k: // global
           _sb780::P64 = P64[R1 + 6];
           _sb781::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sb782_info;
           P64[Hp] = _sb781::P64;
           R3 = Hp - 16;
           R2 = _sb780::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.120254798 UTC

[section ""data" . go1_rb6WQ_closure" {
     go1_rb6WQ_closure:
         const go1_rb6WQ_info;
 },
 sat_sb787_entry() //  [R1]
         { info_tbl: [(cb99B,
                       label: sat_sb787_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb99B: // global
           R2 = P64[R1 + 16];
           call go1_rb6WQ_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 go1_rb6WQ_entry() //  [R2]
         { info_tbl: [(cb99I,
                       label: go1_rb6WQ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb99I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb99J; else goto cb99K;
       cb99J: // global
           R2 = R2;
           R1 = go1_rb6WQ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb99K: // global
           I64[Sp - 8] = block_cb99r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub99Q; else goto cb99s;
       ub99Q: // global
           call _cb99r(R1) args: 0, res: 0, upd: 0;
       cb99s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb99r() //  [R1]
         { info_tbl: [(cb99r,
                       label: block_cb99r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb99r: // global
           if (R1 & 7 == 1) goto cb99F; else goto cb99G;
       cb99F: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb99G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb99P; else goto cb99O;
       cb99P: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb99O: // global
           _sb785::P64 = P64[R1 + 6];
           _sb786::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sb787_info;
           P64[Hp] = _sb786::P64;
           R3 = Hp - 16;
           R2 = _sb785::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.127636738 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure" {
     GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure:
         const GHC.IO.Handle.Text.$whGetLineBufferedLoop_info;
         const 0;
 },
 GHC.IO.Handle.Text.$whGetLineBufferedLoop_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb99S: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 buf1_sb78H_entry() //  [R1]
         { info_tbl: [(cb9bb,
                       label: buf1_sb78H_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9bb: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb9bc; else goto cb9bd;
       cb9bc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9bd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cb9b8_info;
           _sb78a::P64 = P64[R1 + 16];
           _sb78b::P64 = P64[R1 + 24];
           _sb789::I64 = I64[R1 + 40];
           _sb78c::I64 = I64[R1 + 48];
           _sb78e::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _sb789::I64;
           P64[Sp - 48] = _sb78a::P64;
           P64[Sp - 40] = _sb78b::P64;
           I64[Sp - 32] = _sb78c::I64;
           I64[Sp - 24] = _sb78e::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ub9bs; else goto cb9b9;
       ub9bs: // global
           call _cb9b8(R1) args: 0, res: 0, upd: 0;
       cb9b9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9b8() //  [R1]
         { info_tbl: [(cb9b8,
                       label: block_cb9b8_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9b8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9bi; else goto cb9bh;
       cb9bi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9bh: // global
           _sb789::I64 = I64[Sp + 8];
           _sb78a::P64 = P64[Sp + 16];
           _sb78b::P64 = P64[Sp + 24];
           _sb78c::I64 = I64[Sp + 32];
           _sb78e::I64 = I64[Sp + 40];
           _sb78J::I64 = I64[R1 + 7];
           if (_sb78J::I64 == _sb78e::I64) goto cb9br; else goto cb9bo;
       cb9br: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb9bo: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = _sb78J::I64;
           I64[Hp] = _sb78e::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79e_entry() //  [R1]
         { info_tbl: [(cb9bz,
                       label: sat_sb79e_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9bz: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb9bA; else goto cb9bB;
       cb9bA: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb9bB: // global
           I64[Sp - 24] = block_cb9bw_info;
           _sb78h::P64 = P64[R1 + 7];
           _sb78v::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _sb78h::P64;
           P64[Sp - 8] = _sb78v::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9cM; else goto cb9bx;
       ub9cM: // global
           call _cb9bw(R1) args: 0, res: 0, upd: 0;
       cb9bx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9bw() //  [R1]
         { info_tbl: [(cb9bw,
                       label: block_cb9bw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9bw: // global
           _sb78R::I64 = I64[R1 + 39];
           _sb78T::I64 = I64[R1 + 47] - _sb78R::I64;
           if (_sb78T::I64 == 0) goto cb9bY; else goto ub9cH;
       cb9bY: // global
           I64[Sp + 16] = block_cb9bV_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       ub9cH: // global
           if (_sb78T::I64 == 1) goto cb9c8; else goto ub9cI;
       cb9c8: // global
           I64[Sp - 40] = block_cb9c7_info;
           _sb78M::P64 = R1;
           _sb78O::P64 = P64[R1 + 7];
           _sb78P::P64 = P64[R1 + 15];
           _sb78N::I64 = I64[R1 + 23];
           _sb78Q::I64 = I64[R1 + 31];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _sb78O::P64;
           P64[Sp - 24] = _sb78P::P64;
           I64[Sp - 16] = _sb78Q::I64;
           I64[Sp - 8] = _sb78R::I64;
           I64[Sp] = _sb78N::I64;
           P64[Sp + 16] = _sb78M::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9cK; else goto cb9ca;
       ub9cK: // global
           call _cb9c7(R1) args: 0, res: 0, upd: 0;
       cb9ca: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub9cI: // global
           I64[Sp + 8] = _sb78T::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb9bJ() args: 0, res: 0, upd: 0;
     }
 },
 _cb9bV() //  [R1]
         { info_tbl: [(cb9bV,
                       label: block_cb9bV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9bV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9c2; else goto cb9c1;
       cb9c2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9c1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9c7() //  [R1]
         { info_tbl: [(cb9c7,
                       label: block_cb9c7_info
                       rep:StackRep [False, False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9c7: // global
           _sb78M::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cb9cg; else goto cb9ck;
       cb9cg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9cj; else goto cb9ci;
       cb9cj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9ci: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sb78M::P64;
           R1 = Hp - 6;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9ck: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9cp; else goto cb9co;
       cb9cp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9co: // global
           _sb78h::P64 = P64[Sp + 48];
           _sb78N::I64 = I64[Sp + 40];
           _sb78O::P64 = P64[Sp + 8];
           _sb78P::P64 = P64[Sp + 16];
           _sb78Q::I64 = I64[Sp + 24];
           _sb793::I64 = %MO_UU_Conv_W32_W64(I32[_sb78N::I64 + (I64[Sp + 32] << 2)]);
           call MO_Touch(_sb78O::P64);
           if (_sb793::I64 == 13) goto cb9cC; else goto cb9cv;
       cb9cC: // global
           I32[_sb78N::I64] = 13 :: W32;
           call MO_Touch(_sb78O::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78O::P64;
           P64[Hp - 32] = _sb78P::P64;
           I64[Hp - 24] = _sb78N::I64;
           I64[Hp - 16] = _sb78Q::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 56] = block_cb9cz_info;
           R3 = Hp - 47;
           R2 = _sb78h::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb9cv: // global
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = _sb78M::P64;
           _cb9ct::P64 = Hp - 46;
           Hp = Hp - 40;
           R1 = _cb9ct::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9cz() //  [R1]
         { info_tbl: [(cb9cz,
                       label: block_cb9cz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9cz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9cF; else goto cb9cE;
       cb9cF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9cE: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9bJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9bJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9bQ; else goto cb9bP;
       cb9bQ: // global
           HpAlloc = 16;
           _sb78T::I64 = I64[Sp];
           I64[Sp] = block_cb9bI_info;
           R1 = _sb78T::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb9bP: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9bI() //  [R1]
         { info_tbl: [(cb9bI,
                       label: block_cb9bI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9bI: // global
           I64[Sp] = R1;
           call _cb9bJ() args: 0, res: 0, upd: 0;
     }
 },
 sat_sb79q_entry() //  [R1]
         { info_tbl: [(cb9cW,
                       label: sat_sb79q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9cW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9d0; else goto cb9d1;
       cb9d0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9d1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb9cT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9d5; else goto cb9cU;
       ub9d5: // global
           call _cb9cT(R1) args: 0, res: 0, upd: 0;
       cb9cU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9cT() //  [R1]
         { info_tbl: [(cb9cT,
                       label: block_cb9cT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9cT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9d4; else goto cb9d3;
       cb9d4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9d3: // global
           _sb79l::P64 = P64[R1 + 7];
           _sb79m::P64 = P64[R1 + 15];
           _sb79k::I64 = I64[R1 + 23];
           _sb79n::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb79l::P64;
           P64[Hp - 32] = _sb79m::P64;
           I64[Hp - 24] = _sb79k::I64;
           I64[Hp - 16] = _sb79n::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79A_entry() //  [R1]
         { info_tbl: [(cb9dh,
                       label: sat_sb79A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9dh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9di; else goto cb9dj;
       cb9di: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9dj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb9de_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9ds; else goto cb9df;
       ub9ds: // global
           call _cb9de(R1) args: 0, res: 0, upd: 0;
       cb9df: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9de() //  [R1]
         { info_tbl: [(cb9de,
                       label: block_cb9de_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9de: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb9dr; else goto cb9dq;
       cb9dr: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb9dq: // global
           R1 = lvl4_rb6WH_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79S_entry() //  [R1]
         { info_tbl: [(cb9dB,
                       label: sat_sb79S_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9dB: // global
           _sb79S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb9dC; else goto cb9dD;
       cb9dD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9dF; else goto cb9dE;
       cb9dF: // global
           HpAlloc = 56;
           goto cb9dC;
       cb9dC: // global
           R1 = _sb79S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9dE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb79S::P64;
           _sb78a::P64 = P64[_sb79S::P64 + 16];
           _sb78b::P64 = P64[_sb79S::P64 + 24];
           _sb789::I64 = I64[_sb79S::P64 + 32];
           _sb78c::I64 = I64[_sb79S::P64 + 40];
           _sb78e::I64 = I64[_sb79S::P64 + 48];
           _sb79Q::I64 = I64[_sb79S::P64 + 56] + 1;
           if (_sb79Q::I64 == _sb78e::I64) goto cb9dP; else goto cb9dM;
       cb9dP: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cb9dM: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = _sb79Q::I64;
           I64[Hp] = _sb78e::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79W_entry() //  [R1]
         { info_tbl: [(cb9e0,
                       label: sat_sb79W_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9e0: // global
           _sb79W::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cb9e1; else goto cb9e2;
       cb9e2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9e4; else goto cb9e3;
       cb9e4: // global
           HpAlloc = 24;
           goto cb9e1;
       cb9e1: // global
           R1 = _sb79W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9e3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb79W::P64;
           _sb78f::P64 = P64[_sb79W::P64 + 16];
           _sb78E::P64 = P64[_sb79W::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sb78E::P64;
           P64[Hp] = _sb78f::P64;
           I64[Sp - 24] = block_cb9dY_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb9dY() //  [R1]
         { info_tbl: [(cb9dY,
                       label: block_cb9dY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9dY: // global
           R2 = R1;
           Sp = Sp + 8;
           call go_rb6WP_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cb9e8,
                       label: GHC.IO.Handle.Text.$whGetLineBufferedLoop_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9e8: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb9e9; else goto ub9g0;
       cb9e9: // global
           R1 = GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ub9g0: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cb99T() args: 0, res: 0, upd: 0;
     }
 },
 _cb99T() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb99T: // global
           _sb788::P64 = P64[Sp];
           I64[Sp] = block_cb99W_info;
           R1 = _sb788::P64;
           if (R1 & 7 != 0) goto ub9gd; else goto cb99X;
       ub9gd: // global
           call _cb99W(R1) args: 0, res: 0, upd: 0;
       cb99X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb99W() //  [R1]
         { info_tbl: [(cb99W,
                       label: block_cb99W_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb99W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9ed; else goto cb9ec;
       cb9ed: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9ec: // global
           _sb78q::P64 = P64[R1 + 71];
           _sb78v::P64 = P64[R1 + 111];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           P64[Sp - 32] = _sb78q::P64;
           P64[Sp - 24] = _sb78v::P64;
           P64[Sp - 16] = Hp - 15;
           I64[Sp - 8] = I64[Sp + 40];
           P64[Sp] = R1;
           Sp = Sp - 32;
           call _cb9fz() args: 0, res: 0, upd: 0;
     }
 },
 _cb9fz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9fz: // global
           _sb78e::I64 = I64[Sp + 80];
           if (I64[Sp + 24] == _sb78e::I64) goto cb9fT; else goto cb9fI;
       cb9fT: // global
           P64[Sp + 24] = GHC.Types.False_closure+1;
           I64[Sp + 16] = _sb78e::I64;
           call _sb78y() args: 0, res: 0, upd: 0;
       cb9fI: // global
           I64[Sp - 8] = block_cb9fG_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9gr; else goto cb9fJ;
       ub9gr: // global
           call _cb9fG(R1) args: 0, res: 0, upd: 0;
       cb9fJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9fG() //  [R1]
         { info_tbl: [(cb9fG,
                       label: block_cb9fG_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9fG: // global
           _sb7au::I64 = I64[Sp + 32];
           _sb7aC::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 15] + (_sb7au::I64 << 2)]);
           call MO_Touch(P64[R1 + 7]);
           if (_sb7aC::I64 == 10) goto cb9fS; else goto cb9fR;
       cb9fS: // global
           I64[Sp + 24] = _sb7au::I64;
           P64[Sp + 32] = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call _sb78y() args: 0, res: 0, upd: 0;
       cb9fR: // global
           P64[Sp + 24] = R1;
           I64[Sp + 32] = _sb7au::I64 + 1;
           Sp = Sp + 8;
           call _cb9fz() args: 0, res: 0, upd: 0;
     }
 },
 _sb78y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb78y: // global
           I64[Sp - 8] = block_cb9a9_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9gv; else goto cb9aa;
       ub9gv: // global
           call _cb9a9(R1) args: 0, res: 0, upd: 0;
       cb9aa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9a9() //  [R1]
         { info_tbl: [(cb9a9,
                       label: block_cb9a9_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9a9: // global
           _sb78d::I64 = I64[Sp + 80];
           _sb78B::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cb9eS; else goto cb9fe;
       cb9eS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9eV; else goto cb9eU;
       cb9eV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9eU: // global
           if (_sb78d::I64 == _sb78B::I64) goto cb9f7; else goto cb9f6;
       cb9f7: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb78B::I64;
           P64[Sp + 80] = GHC.Types.[]_closure+1;
           P64[Sp] = Hp - 7;
           call _sb78C() args: 0, res: 0, upd: 0;
       cb9f6: // global
           Hp = Hp - 16;
           I64[Sp - 8] = _sb78B::I64 - 1;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call _cb9aV() args: 0, res: 0, upd: 0;
       cb9fe: // global
           I64[Sp] = block_cb9fa_info;
           R6 = GHC.Types.[]_closure+1;
           R5 = _sb78B::I64;
           R4 = _sb78d::I64;
           R3 = P64[Sp + 56];
           R2 = I64[Sp + 48];
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9aV() //  []
         { info_tbl: [(cb9aV,
                       label: block_cb9aV_info
                       rep:StackRep [True, False, False, False, True, False, False, True,
                                     False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9aV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb9f1; else goto cb9f0;
       cb9f1: // global
           HpAlloc = 40;
           I64[Sp] = block_cb9aV_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb9f0: // global
           _sb7a5::P64 = P64[Sp + 16];
           _sb7a6::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_sb7a6::I64,
                            I64[Sp + 96])) goto cb9f3; else goto cb9f4;
       cb9f3: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 64] + (_sb7a6::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sb7a5::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 8] = _sb7a6::I64 - 1;
           call _cb9aV() args: 0, res: 0, upd: 0;
       cb9f4: // global
           Hp = Hp - 40;
           P64[Sp + 96] = _sb7a5::P64;
           Sp = Sp + 24;
           call _cb9aP() args: 0, res: 0, upd: 0;
     }
 },
 _cb9aP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9aP: // global
           Hp = Hp + 16;
           _sb7a1::P64 = P64[Sp + 72];
           if (Hp > HpLim) (likely: False) goto cb9eY; else goto cb9eX;
       cb9eY: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cb9aO_info;
           R1 = _sb7a1::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9eX: // global
           _sb78B::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 48]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb78B::I64;
           P64[Sp + 72] = _sb7a1::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 8;
           call _sb78C() args: 0, res: 0, upd: 0;
     }
 },
 _cb9aO() //  [R1]
         { info_tbl: [(cb9aO,
                       label: block_cb9aO_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9aO: // global
           P64[Sp + 80] = R1;
           Sp = Sp + 8;
           call _cb9aP() args: 0, res: 0, upd: 0;
     }
 },
 _cb9fa() //  [R1]
         { info_tbl: [(cb9fa,
                       label: block_cb9fa_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9fa: // global
           I64[Sp] = block_cb9fc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9gp; else goto cb9fg;
       ub9gp: // global
           call _cb9fc(R1) args: 0, res: 0, upd: 0;
       cb9fg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9fc() //  [R1]
         { info_tbl: [(cb9fc,
                       label: block_cb9fc_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9fc: // global
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 80] = P64[R1 + 7];
           call _sb78C() args: 0, res: 0, upd: 0;
     }
 },
 _sb78C() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb78C: // global
           I64[Sp - 8] = block_cb9am_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9gw; else goto cb9an;
       ub9gw: // global
           call _cb9am(R1) args: 0, res: 0, upd: 0;
       cb9an: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9am() //  [R1]
         { info_tbl: [(cb9am,
                       label: block_cb9am_info
                       rep:StackRep [False, False, False, True, True, False, True, False,
                                     False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9am: // global
           _sb789::I64 = I64[Sp + 56];
           _sb78a::P64 = P64[Sp + 64];
           _sb78b::P64 = P64[Sp + 72];
           _sb78c::I64 = I64[Sp + 80];
           _sb78e::I64 = I64[Sp + 96];
           if (R1 & 7 == 1) goto cb9eh; else goto cb9eN;
       cb9eh: // global
           Hp = Hp + 96;
           _sb78G::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb9eQ; else goto cb9ej;
       cb9ej: // global
           I64[Hp - 88] = buf1_sb78H_info;
           P64[Hp - 72] = _sb78a::P64;
           P64[Hp - 64] = _sb78b::P64;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = _sb789::I64;
           I64[Hp - 40] = _sb78c::I64;
           I64[Hp - 32] = _sb78e::I64;
           I64[Hp - 24] = sat_sb79e_info;
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 24];
           _cb9ar::P64 = Hp - 88;
           P64[Hp] = _cb9ar::P64;
           I64[Sp + 8] = block_cb9av_info;
           R2 = GHC.IO.Handle.Text.hGetChar3_closure+2;
           R1 = Hp - 23;
           P64[Sp + 96] = _cb9ar::P64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cb9eN: // global
           Hp = Hp + 96;
           _sb78G::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cb9eQ; else goto cb9eP;
       cb9eQ: // global
           HpAlloc = 96;
           R1 = _sb78G::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9eP: // global
           I64[Hp - 88] = sat_sb79S_info;
           P64[Hp - 72] = _sb78a::P64;
           P64[Hp - 64] = _sb78b::P64;
           I64[Hp - 56] = _sb789::I64;
           I64[Hp - 48] = _sb78c::I64;
           I64[Hp - 40] = _sb78e::I64;
           I64[Hp - 32] = I64[Sp + 32];
           _sb78f::P64 = P64[Sp + 104];
           _sb78q::P64 = P64[Sp + 16];
           _sb78E::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sb78q::P64 + 8] = Hp - 88;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb78q::P64);
           I64[Hp - 24] = sat_sb79W_info;
           P64[Hp - 8] = _sb78f::P64;
           P64[Hp] = _sb78E::P64;
           R1 = Hp - 24;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9av() //  [R1]
         { info_tbl: [(cb9av,
                       label: block_cb9av_info
                       rep:StackRep [False, True, True, True, False, True, True, True,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9av: // global
           I64[Sp] = block_cb9ax_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9gh; else goto cb9ay;
       ub9gh: // global
           call _cb9ax(R1) args: 0, res: 0, upd: 0;
       cb9ay: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9ax() //  [R1]
         { info_tbl: [(cb9ax,
                       label: block_cb9ax_info
                       rep:StackRep [False, True, True, True, False, True, True, True,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ax: // global
           if (R1 & 7 == 1) goto cb9ep; else goto cb9eJ;
       cb9ep: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb9es; else goto cb9er;
       cb9es: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9er: // global
           I64[Hp - 88] = sat_sb79q_info;
           _cb9ar::P64 = P64[Sp + 88];
           P64[Hp - 72] = _cb9ar::P64;
           _sb78f::P64 = P64[Sp + 96];
           _sb78q::P64 = P64[Sp + 8];
           _sb78E::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sb78q::P64 + 8] = Hp - 88;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb78q::P64);
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sb78E::P64;
           P64[Hp - 48] = _sb78f::P64;
           I64[Hp - 40] = sat_sb79A_info;
           P64[Hp - 24] = _cb9ar::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           I64[Sp + 96] = block_cb9en_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp + 96;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
       cb9eJ: // global
           I64[Sp + 32] = block_cb9aD_info;
           R1 = P64[R1 + 6];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto ub9gi; else goto cb9aE;
       ub9gi: // global
           call _cb9aD(R1) args: 0, res: 0, upd: 0;
       cb9aE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9en() //  [R1]
         { info_tbl: [(cb9en,
                       label: block_cb9en_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9en: // global
           I64[Sp] = block_cb9ew_info;
           R2 = R1;
           call go1_rb6WQ_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9ew() //  [R1]
         { info_tbl: [(cb9ew,
                       label: block_cb9ew_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ew: // global
           if (R1 & 7 == 1) goto cb9eD; else goto cb9eH;
       cb9eD: // global
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.ioe_EOF1_entry() args: 8, res: 0, upd: 8;
       cb9eH: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9aD() //  [R1]
         { info_tbl: [(cb9aD,
                       label: block_cb9aD_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9aD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9eM; else goto cb9eL;
       cb9eM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9eL: // global
           _sb79K::P64 = P64[R1 + 7];
           _sb79L::P64 = P64[R1 + 15];
           _sb79J::I64 = I64[R1 + 23];
           _sb79M::I64 = I64[R1 + 31];
           _sb79N::I64 = I64[R1 + 39];
           _sb79O::I64 = I64[R1 + 47];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 64];
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = _sb79J::I64;
           P64[Sp + 24] = _sb79K::P64;
           P64[Sp + 32] = _sb79L::P64;
           I64[Sp + 40] = _sb79M::I64;
           I64[Sp + 48] = _sb79N::I64;
           I64[Sp + 56] = _sb79O::I64;
           P64[Sp + 64] = Hp - 14;
           Sp = Sp + 8;
           call _cb99T() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.13968754 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine3_closure" {
     GHC.IO.Handle.Text.hGetLine3_closure:
         const GHC.IO.Handle.Text.hGetLine3_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine3_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9gE,
                       label: GHC.IO.Handle.Text.hGetLine3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9gE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9gF; else goto cb9gG;
       cb9gF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetLine3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9gG: // global
           I64[Sp - 24] = block_cb9gB_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9gK; else goto cb9gC;
       ub9gK: // global
           call _cb9gB(R1) args: 0, res: 0, upd: 0;
       cb9gC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9gB() //  [R1]
         { info_tbl: [(cb9gB,
                       label: block_cb9gB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9gB: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.140807519 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetLine5_bytes" {
     GHC.IO.Handle.Text.hGetLine5_bytes:
         I8[] [104,71,101,116,76,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.141598106 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine4_closure" {
     GHC.IO.Handle.Text.hGetLine4_closure:
         const GHC.IO.Handle.Text.hGetLine4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine4_entry() //  [R1]
         { info_tbl: [(cb9gR,
                       label: GHC.IO.Handle.Text.hGetLine4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9gR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9gS; else goto cb9gT;
       cb9gS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9gT: // global
           (_cb9gO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9gO::I64 == 0) goto cb9gQ; else goto cb9gP;
       cb9gQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9gP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9gO::I64;
           R2 = GHC.IO.Handle.Text.hGetLine5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.14282115 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine2_closure" {
     GHC.IO.Handle.Text.hGetLine2_closure:
         const GHC.IO.Handle.Text.hGetLine2_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine2_entry() //  [R2]
         { info_tbl: [(cb9h1,
                       label: GHC.IO.Handle.Text.hGetLine2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9h1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9h5; else goto cb9h6;
       cb9h5: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetLine2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9h6: // global
           I64[Sp - 8] = block_cb9gY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9he; else goto cb9gZ;
       ub9he: // global
           call _cb9gY(R1) args: 0, res: 0, upd: 0;
       cb9gZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9gY() //  [R1]
         { info_tbl: [(cb9gY,
                       label: block_cb9gY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9gY: // global
           _sb7bd::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_cb9h4_info;
           _sb7aU::P64 = R1;
           R1 = _sb7bd::P64;
           P64[Sp] = _sb7aU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9hd; else goto cb9h8;
       ub9hd: // global
           call _cb9h4(R1) args: 0, res: 0, upd: 0;
       cb9h8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9h4() //  [R1]
         { info_tbl: [(cb9h4,
                       label: block_cb9h4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9h4: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.144179263 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine1_closure" {
     GHC.IO.Handle.Text.hGetLine1_closure:
         const GHC.IO.Handle.Text.hGetLine1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine1_entry() //  [R2]
         { info_tbl: [(cb9hj,
                       label: GHC.IO.Handle.Text.hGetLine1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9hj: // global
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.14502756 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine_closure" {
     GHC.IO.Handle.Text.hGetLine_closure:
         const GHC.IO.Handle.Text.hGetLine_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine_entry() //  [R2]
         { info_tbl: [(cb9hq,
                       label: GHC.IO.Handle.Text.hGetLine_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9hq: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetLine1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.146169208 UTC

[section ""data" . lvl11_rb6WR_closure" {
     lvl11_rb6WR_closure:
         const lvl11_rb6WR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rb6WR_entry() //  [R1]
         { info_tbl: [(cb9hE,
                       label: lvl11_rb6WR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9hE: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb9hF; else goto cb9hG;
       cb9hF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9hG: // global
           (_cb9hw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9hw::I64 == 0) goto cb9hy; else goto cb9hx;
       cb9hy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9hx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9hw::I64;
           I64[Sp - 24] = block_cb9hz_info;
           R6 = 0;
           R5 = GHC.IO.FD.$tcFD1_closure;
           R4 = GHC.IO.FD.$trModule_closure;
           R3 = 15546290101957756376;
           R2 = 10838815552519039062;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cb9hz() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cb9hz,
                       label: block_cb9hz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9hz: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cb9hA() args: 0, res: 0, upd: 0;
     }
 },
 _cb9hA() //  []
         { info_tbl: [(cb9hA,
                       label: block_cb9hA_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9hA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb9hJ; else goto cb9hI;
       cb9hJ: // global
           HpAlloc = 48;
           I64[Sp] = block_cb9hA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cb9hI: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.151533693 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking2_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking2_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking2_info;
         const 0;
 },
 sat_sb7ch_entry() //  [R1]
         { info_tbl: [(cb9iF,
                       label: sat_sb7ch_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9iF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9iM; else goto cb9iN;
       cb9iM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9iN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb9iC_info;
           _sb7bY::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7bY::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9iR; else goto cb9iD;
       ub9iR: // global
           call _cb9iC(R1) args: 0, res: 0, upd: 0;
       cb9iD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9iC() //  [R1]
         { info_tbl: [(cb9iC,
                       label: block_cb9iC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9iC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9iQ; else goto cb9iP;
       cb9iQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9iP: // global
           _sb7cg::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7cg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7cl_entry() //  [R1]
         { info_tbl: [(cb9j0,
                       label: sat_sb7cl_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9j0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9j7; else goto cb9j8;
       cb9j7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9j8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb9iX_info;
           _sb7bY::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7bY::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9jc; else goto cb9iY;
       ub9jc: // global
           call _cb9iX(R1) args: 0, res: 0, upd: 0;
       cb9iY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9iX() //  [R1]
         { info_tbl: [(cb9iX,
                       label: block_cb9iX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9iX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9jb; else goto cb9ja;
       cb9jb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9ja: // global
           _sb7ck::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7ck::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7cB_entry() //  [R1]
         { info_tbl: [(cb9jI,
                       label: sat_sb7cB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9jI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9jP; else goto cb9jQ;
       cb9jP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9jQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb9jF_info;
           _sb7bX::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7bX::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9jU; else goto cb9jG;
       ub9jU: // global
           call _cb9jF(R1) args: 0, res: 0, upd: 0;
       cb9jG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9jF() //  [R1]
         { info_tbl: [(cb9jF,
                       label: block_cb9jF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9jF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9jT; else goto cb9jS;
       cb9jT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9jS: // global
           _sb7cA::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7cA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking2_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cb9jV,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9jV: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cb9jW; else goto cb9jX;
       cb9jW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufNonBlocking2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9jX: // global
           I64[Sp - 40] = block_cb9hQ_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9kl; else goto cb9hR;
       ub9kl: // global
           call _cb9hQ(R1) args: 0, res: 0, upd: 0;
       cb9hR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9hQ() //  [R1]
         { info_tbl: [(cb9hQ,
                       label: block_cb9hQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9hQ: // global
           I64[Sp - 8] = block_cb9hV_info;
           _sb7by::P64 = R1;
           _sb7bE::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb7bE::P64;
           P64[Sp + 8] = _sb7by::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9kh; else goto cb9hW;
       ub9kh: // global
           call _cb9hV(R1) args: 0, res: 0, upd: 0;
       cb9hW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9hV() //  [R1]
         { info_tbl: [(cb9hV,
                       label: block_cb9hV_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9hV: // global
           I64[Sp - 40] = block_cb9i0_info;
           _sb7bR::P64 = P64[R1 + 7];
           _sb7bS::P64 = P64[R1 + 15];
           _sb7bQ::I64 = I64[R1 + 23];
           _sb7bT::I64 = I64[R1 + 31];
           _sb7bU::I64 = I64[R1 + 39];
           _sb7bV::I64 = I64[R1 + 47];
           R1 = P64[Sp + 40];
           P64[Sp - 32] = _sb7bS::P64;
           I64[Sp - 24] = _sb7bT::I64;
           I64[Sp - 16] = _sb7bU::I64;
           I64[Sp - 8] = _sb7bV::I64;
           P64[Sp] = _sb7bR::P64;
           I64[Sp + 40] = _sb7bQ::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9ki; else goto cb9i1;
       ub9ki: // global
           call _cb9i0(R1) args: 0, res: 0, upd: 0;
       cb9i1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9i0() //  [R1]
         { info_tbl: [(cb9i0,
                       label: block_cb9i0_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9i0: // global
           _sb7bu::P64 = P64[Sp + 64];
           _sb7bX::I64 = I64[R1 + 7];
           _sb7bY::I64 = I64[Sp + 32] - I64[Sp + 24];
           if (%MO_S_Ge_W64(_sb7bX::I64,
                            _sb7bY::I64)) goto cb9k2; else goto cb9kd;
       cb9k2: // global
           I64[Sp] = block_cb9ib_info;
           R1 = _sb7bu::P64;
           I64[Sp + 32] = _sb7bY::I64;
           I64[Sp + 64] = _sb7bX::I64;
           if (R1 & 7 != 0) goto ub9kj; else goto cb9ic;
       ub9kj: // global
           call _cb9ib(R1) args: 0, res: 0, upd: 0;
       cb9ic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9kd: // global
           I64[Sp] = block_cb9je_info;
           R1 = _sb7bu::P64;
           I64[Sp + 64] = _sb7bX::I64;
           if (R1 & 7 != 0) goto ub9kk; else goto cb9jf;
       ub9kk: // global
           call _cb9je(R1) args: 0, res: 0, upd: 0;
       cb9jf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9ib() //  [R1]
         { info_tbl: [(cb9ib,
                       label: block_cb9ib_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ib: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb9k5; else goto cb9k4;
       cb9k5: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9k4: // global
           _sb7bv::P64 = P64[Sp + 72];
           _sb7by::P64 = P64[Sp + 56];
           _sb7bE::P64 = P64[Sp + 48];
           _sb7bQ::I64 = I64[Sp + 80];
           _sb7bR::P64 = P64[Sp + 40];
           _sb7bS::P64 = P64[Sp + 8];
           _sb7bT::I64 = I64[Sp + 16];
           _sb7bX::I64 = I64[Sp + 64];
           _sb7bY::I64 = I64[Sp + 32];
           _sb7c1::I64 = I64[R1 + 7];
           (_sb7c7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sb7c1::I64, _sb7bQ::I64 + I64[Sp + 24], _sb7bY::I64);
           call MO_Touch(_sb7bR::P64);
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb7bR::P64;
           P64[Hp - 80] = _sb7bS::P64;
           I64[Hp - 72] = _sb7bQ::I64;
           I64[Hp - 64] = _sb7bT::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           call MO_WriteBarrier();
           P64[_sb7bE::P64 + 8] = Hp - 95;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7bE::P64);
           _sb7cb::I64 = _sb7bX::I64 - _sb7bY::I64;
           if (_sb7cb::I64 != 0) goto cb9kb; else goto cb9kc;
       cb9kb: // global
           I64[Hp - 40] = sat_sb7ch_info;
           P64[Hp - 24] = _sb7bv::P64;
           I64[Hp - 16] = _sb7bY::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sb7c1::I64 + _sb7bY::I64;
           R6 = _sb7cb::I64;
           R5 = Hp - 40;
           R4 = Hp - 7;
           R3 = _sb7bT::I64;
           R2 = _sb7by::P64;
           Sp = Sp + 88;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cb9kc: // global
           I64[Hp - 40] = sat_sb7cl_info;
           P64[Hp - 24] = _sb7bv::P64;
           I64[Hp - 16] = _sb7bY::I64;
           _cb9iT::P64 = Hp - 40;
           Hp = Hp - 16;
           R1 = _cb9iT::P64;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9je() //  [R1]
         { info_tbl: [(cb9je,
                       label: block_cb9je_info
                       rep:StackRep [False, True, True, True, False, False, True, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9je: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cb9kg; else goto cb9kf;
       cb9kg: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9kf: // global
           _sb7bv::P64 = P64[Sp + 72];
           _sb7bE::P64 = P64[Sp + 48];
           _sb7bQ::I64 = I64[Sp + 80];
           _sb7bR::P64 = P64[Sp + 40];
           _sb7bS::P64 = P64[Sp + 8];
           _sb7bT::I64 = I64[Sp + 16];
           _sb7bU::I64 = I64[Sp + 24];
           _sb7bV::I64 = I64[Sp + 32];
           _sb7bX::I64 = I64[Sp + 64];
           (_sb7ct::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[R1 + 7], _sb7bQ::I64 + _sb7bU::I64, _sb7bX::I64);
           call MO_Touch(_sb7bR::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _sb7bR::P64;
           P64[Hp - 64] = _sb7bS::P64;
           I64[Hp - 56] = _sb7bQ::I64;
           I64[Hp - 48] = _sb7bT::I64;
           I64[Hp - 40] = _sb7bU::I64 + _sb7bX::I64;
           I64[Hp - 32] = _sb7bV::I64;
           call MO_WriteBarrier();
           P64[_sb7bE::P64 + 8] = Hp - 79;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7bE::P64);
           I64[Hp - 24] = sat_sb7cB_info;
           P64[Hp - 8] = _sb7bv::P64;
           I64[Hp] = _sb7bX::I64;
           R1 = Hp - 24;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Text.$wbufReadNBEmpty_closure" {
     GHC.IO.Handle.Text.$wbufReadNBEmpty_closure:
         const GHC.IO.Handle.Text.$wbufReadNBEmpty_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wbufReadNBEmpty_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9kn: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7dz_entry() //  [R1]
         { info_tbl: [(cb9l9,
                       label: sat_sb7dz_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9l9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9lg; else goto cb9lh;
       cb9lg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9lh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb9l6_info;
           _sb7dv::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7dv::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9ll; else goto cb9l7;
       ub9ll: // global
           call _cb9l6(R1) args: 0, res: 0, upd: 0;
       cb9l7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9l6() //  [R1]
         { info_tbl: [(cb9l6,
                       label: block_cb9l6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9l6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9lk; else goto cb9lj;
       cb9lk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9lj: // global
           _sb7dy::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7dy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ub9mH_srtd" {
     ub9mH_srtd:
         const Sb7vQ_srt+56;
         const 33;
         const 8321499137;
 },
 GHC.IO.Handle.Text.$wbufReadNBEmpty_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cb9lm,
                       label: GHC.IO.Handle.Text.$wbufReadNBEmpty_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, True, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9lm: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cb9ln; else goto cb9lo;
       cb9ln: // global
           R1 = GHC.IO.Handle.Text.$wbufReadNBEmpty_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cb9lo: // global
           I64[Sp - 40] = block_cb9kr_info;
           R1 = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9mD; else goto cb9ks;
       ub9mD: // global
           call _cb9kr(R1) args: 0, res: 0, upd: 0;
       cb9ks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9mI_srtd" {
     ub9mI_srtd:
         const Sb7vQ_srt+56;
         const 33;
         const 8053063681;
 },
 _cb9kr() //  [R1]
         { info_tbl: [(cb9kr,
                       label: block_cb9kr_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9kr: // global
           I64[Sp - 32] = block_cb9kw_info;
           _sb7cI::P64 = R1;
           _sb7cK::P64 = P64[R1 + 15];
           _sb7cL::P64 = P64[R1 + 23];
           _sb7cO::P64 = P64[R1 + 47];
           R1 = P64[R1 + 31];
           P64[Sp - 24] = _sb7cK::P64;
           P64[Sp - 16] = _sb7cL::P64;
           P64[Sp - 8] = _sb7cO::P64;
           P64[Sp] = _sb7cI::P64;
           Sp = Sp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9mJ_srtd" {
     ub9mJ_srtd:
         const Sb7vQ_srt+56;
         const 33;
         const 8053063681;
 },
 _cb9kw() //  [R1]
         { info_tbl: [(cb9kw,
                       label: block_cb9kw_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9kw: // global
           if (%MO_S_Le_W64(I64[Sp + 64],
                            I64[Sp + 40])) goto ub9mx; else goto cb9mg;
       ub9mx: // global
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _sb7d2() args: 0, res: 0, upd: 0;
       cb9mg: // global
           I64[Sp - 8] = block_cb9kG_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 15];
           I64[Sp + 16] = I64[R1 + 7];
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9kG() //  [R1]
         { info_tbl: [(cb9kG,
                       label: block_cb9kG_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9kG: // global
           if (R1 & 7 == 1) goto ub9my; else goto cb9mm;
       ub9my: // global
           Sp = Sp + 16;
           call _sb7d2() args: 0, res: 0, upd: 0;
       cb9mm: // global
           I64[Sp] = block_cb9kL_info;
           R1 = P64[Sp + 56];
           if (R1 & 7 != 0) goto ub9mA; else goto cb9kM;
       ub9mA: // global
           call _cb9kL(R1) args: 0, res: 0, upd: 0;
       cb9kM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _sb7d2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7d2: // global
           _sb7d6::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp + 8] = block_cb9lu_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _sb7d6::P64;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb9lu() //  [R1]
         { info_tbl: [(cb9lu,
                       label: block_cb9lu_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9lu: // global
           I64[Sp] = block_cb9lw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9mE; else goto cb9lz;
       ub9mE: // global
           call _cb9lw(R1) args: 0, res: 0, upd: 0;
       cb9lz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9lw() //  [R1]
         { info_tbl: [(cb9lw,
                       label: block_cb9lw_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9lw: // global
           I64[Sp] = block_cb9lD_info;
           _sb7dc::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _sb7dc::P64;
           if (R1 & 7 != 0) goto ub9mF; else goto cb9lF;
       ub9mF: // global
           call _cb9lD(R1) args: 0, res: 0, upd: 0;
       cb9lF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9lD() //  [R1]
         { info_tbl: [(cb9lD,
                       label: block_cb9lD_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9lD: // global
           if (R1 & 7 == 1) goto cb9lL; else goto cb9lQ;
       cb9lL: // global
           R1 = P64[Sp + 40];
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9lQ: // global
           I64[Sp] = block_cb9lO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub9mG; else goto cb9lR;
       ub9mG: // global
           call _cb9lO(R1) args: 0, res: 0, upd: 0;
       cb9lR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9lO() //  [R1]
         { info_tbl: [(cb9lO,
                       label: block_cb9lO_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9lO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9lX; else goto cb9lW;
       cb9lX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9lW: // global
           _sb7cF::P64 = P64[Sp + 40];
           _sb7dh::I64 = I64[R1 + 7];
           if (_sb7dh::I64 == 0) goto cb9md; else goto cb9mc;
       cb9md: // global
           Hp = Hp - 16;
           R1 = _sb7cF::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9mc: // global
           _sb7cE::P64 = P64[Sp + 32];
           _sb7cG::I64 = I64[Sp + 48];
           _sb7cI::P64 = P64[Sp + 16];
           _sb7cO::P64 = P64[Sp + 8];
           _sb7dc::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sb7cO::P64 + 8] = _sb7dc::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7cO::P64);
           if (%MO_S_Gt_W64(_sb7cG::I64,
                            _sb7dh::I64)) goto cb9m6; else goto cb9ma;
       cb9m6: // global
           Hp = Hp - 16;
           R6 = R1;
           R5 = _sb7cF::P64;
           R4 = _sb7cE::P64;
           R3 = _sb7dc::P64;
           R2 = _sb7cI::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cb9ma: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7cG::I64;
           R6 = Hp - 7;
           R5 = _sb7cF::P64;
           R4 = _sb7cE::P64;
           R3 = _sb7dc::P64;
           R2 = _sb7cI::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb9kL() //  [R1]
         { info_tbl: [(cb9kL,
                       label: block_cb9kL_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9kL: // global
           I64[Sp + 56] = block_cb9kT_info;
           R6 = 0;
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp + 48] = I64[Sp + 72];
           Sp = Sp + 48;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb9kT() //  [R1]
         { info_tbl: [(cb9kT,
                       label: block_cb9kT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9kT: // global
           I64[Sp] = block_cb9kV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9mC; else goto cb9kW;
       ub9mC: // global
           call _cb9kV(R1) args: 0, res: 0, upd: 0;
       cb9kW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9kV() //  [R1]
         { info_tbl: [(cb9kV,
                       label: block_cb9kV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9kV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb9mr; else goto cb9mq;
       cb9mr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9mq: // global
           _sb7cF::P64 = P64[Sp + 8];
           _sb7dv::I64 = I64[R1 + 7];
           if (_sb7dv::I64 != (-1)) goto cb9mt; else goto cb9mu;
       cb9mt: // global
           I64[Hp - 24] = sat_sb7dz_info;
           P64[Hp - 8] = _sb7cF::P64;
           I64[Hp] = _sb7dv::I64;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9mu: // global
           Hp = Hp - 32;
           R1 = _sb7cF::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.160620754 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes" {
     GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes:
         I8[] [104,71,101,116,66,117,102,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.161411944 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking3_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking3_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking3_entry() //  [R1]
         { info_tbl: [(cb9mQ,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9mQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9mR; else goto cb9mS;
       cb9mR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9mS: // global
           (_cb9mN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9mN::I64 == 0) goto cb9mP; else goto cb9mO;
       cb9mP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9mO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9mN::I64;
           R2 = GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.164982444 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBufNonBlocking_closure" {
     GHC.IO.Handle.Text.$whGetBufNonBlocking_closure:
         const GHC.IO.Handle.Text.$whGetBufNonBlocking_info;
         const 0;
 },
 sat_sb7eF_entry() //  [R1]
         { info_tbl: [(cb9nE,
                       label: sat_sb7eF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9nE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9nI; else goto cb9nJ;
       cb9nI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9nJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb9nB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9nN; else goto cb9nC;
       ub9nN: // global
           call _cb9nB(R1) args: 0, res: 0, upd: 0;
       cb9nC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9nB() //  [R1]
         { info_tbl: [(cb9nB,
                       label: block_cb9nB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9nB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9nM; else goto cb9nL;
       cb9nM: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9nL: // global
           _sb7eA::P64 = P64[R1 + 7];
           _sb7eB::P64 = P64[R1 + 15];
           _sb7ez::I64 = I64[R1 + 23];
           _sb7eC::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7eA::P64;
           P64[Hp - 32] = _sb7eB::P64;
           I64[Hp - 24] = _sb7ez::I64;
           I64[Hp - 16] = _sb7eC::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7eY_entry() //  [R1]
         { info_tbl: [(cb9oa,
                       label: sat_sb7eY_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9oa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9oh; else goto cb9oi;
       cb9oh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9oi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb9o7_info;
           _sb7eO::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7eO::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9om; else goto cb9o8;
       ub9om: // global
           call _cb9o7(R1) args: 0, res: 0, upd: 0;
       cb9o8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9o7() //  [R1]
         { info_tbl: [(cb9o7,
                       label: block_cb9o7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9o7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9ol; else goto cb9ok;
       cb9ol: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9ok: // global
           _sb7eS::P64 = P64[R1 + 7];
           _sb7eT::P64 = P64[R1 + 15];
           _sb7eR::I64 = I64[R1 + 23];
           _sb7eU::I64 = I64[R1 + 31];
           _sb7eW::I64 = I64[R1 + 47];
           _sb7eX::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7eS::P64;
           P64[Hp - 32] = _sb7eT::P64;
           I64[Hp - 24] = _sb7eR::I64;
           I64[Hp - 16] = _sb7eU::I64;
           I64[Hp - 8] = _sb7eX::I64;
           I64[Hp] = _sb7eW::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7fj_entry() //  [R1, R2]
         { info_tbl: [(cb9on,
                       label: sat_sb7fj_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9on: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cb9oo; else goto cb9op;
       cb9oo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9op: // global
           I64[Sp - 32] = block_cb9n8_info;
           _sb7dB::P64 = P64[R1 + 6];
           _sb7dG::P64 = P64[R1 + 14];
           _sb7dE::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb7dB::P64;
           I64[Sp - 16] = _sb7dE::I64;
           P64[Sp - 8] = _sb7dG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9pT; else goto cb9n9;
       ub9pT: // global
           call _cb9n8(R1) args: 0, res: 0, upd: 0;
       cb9n9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9n8() //  [R1]
         { info_tbl: [(cb9n8,
                       label: block_cb9n8_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9n8: // global
           I64[Sp - 40] = block_cb9nd_info;
           _sb7dJ::P64 = R1;
           _sb7dP::P64 = P64[R1 + 47];
           _sb7dR::P64 = P64[R1 + 63];
           _sb7dS::P64 = P64[R1 + 71];
           _sb7dV::P64 = P64[R1 + 95];
           R1 = P64[_sb7dS::P64 + 8];
           P64[Sp - 32] = _sb7dP::P64;
           P64[Sp - 24] = _sb7dR::P64;
           P64[Sp - 16] = _sb7dS::P64;
           P64[Sp - 8] = _sb7dV::P64;
           P64[Sp] = _sb7dJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9pJ; else goto cb9ne;
       ub9pJ: // global
           call _cb9nd(R1) args: 0, res: 0, upd: 0;
       cb9ne: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9nd() //  [R1]
         { info_tbl: [(cb9nd,
                       label: block_cb9nd_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9nd: // global
           I64[Sp - 16] = block_cb9nk_info;
           _sb7e8::I64 = I64[R1 + 39];
           _sb7e9::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sb7e9::I64;
           I64[Sp] = _sb7e8::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub9pK; else goto cb9nl;
       ub9pK: // global
           call _cb9nk(R1) args: 0, res: 0, upd: 0;
       cb9nl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9nk() //  [R1]
         { info_tbl: [(cb9nk,
                       label: block_cb9nk_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9nk: // global
           if (R1 & 7 == 1) goto cb9pn; else goto ub9pE;
       cb9pn: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ub9pF; else goto cb9oJ;
       ub9pF: // global
           Sp = Sp + 24;
           goto ub9pN;
       cb9oJ: // global
           _sb7er::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cb9ns_info;
           R1 = _sb7er::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub9pL; else goto cb9nt;
       ub9pL: // global
           call _cb9ns(R1) args: 0, res: 0, upd: 0;
       cb9nt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub9pE: // global
           Sp = Sp + 24;
           goto ub9pN;
       ub9pN: // global
           call _sb7ea() args: 0, res: 0, upd: 0;
     }
 },
 _cb9ns() //  [R1]
         { info_tbl: [(cb9ns,
                       label: block_cb9ns_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ns: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9oM; else goto cb9oL;
       cb9oM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9oL: // global
           _sb7dS::P64 = P64[Sp + 24];
           _sb7et::P64 = P64[R1 + 7];
           _sb7eu::P64 = P64[R1 + 15];
           _sb7ex::P64 = P64[_sb7dS::P64 + 8];
           I64[Hp - 16] = sat_sb7eF_info;
           P64[Hp] = _sb7ex::P64;
           call MO_WriteBarrier();
           P64[_sb7dS::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dS::P64);
           I64[Sp] = block_cb9nR_info;
           R1 = _sb7ex::P64;
           P64[Sp + 16] = _sb7eu::P64;
           P64[Sp + 24] = _sb7et::P64;
           if (R1 & 7 != 0) goto ub9pO; else goto cb9nS;
       ub9pO: // global
           call _cb9nR(R1) args: 0, res: 0, upd: 0;
       cb9nS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9nR() //  [R1]
         { info_tbl: [(cb9nR,
                       label: block_cb9nR_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9nR: // global
           _sb7eO::I64 = I64[R1 + 39];
           if (_sb7eO::I64 != 0) goto cb9oP; else goto cb9pk;
       cb9oP: // global
           I64[Sp - 24] = block_cb9nY_info;
           _sb7eJ::P64 = P64[R1 + 7];
           _sb7eK::P64 = P64[R1 + 15];
           _sb7eI::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sb7eK::P64;
           I64[Sp - 8] = _sb7eO::I64;
           P64[Sp] = _sb7eJ::P64;
           I64[Sp + 32] = _sb7eI::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9pP; else goto cb9nZ;
       ub9pP: // global
           call _cb9nY(R1) args: 0, res: 0, upd: 0;
       cb9nZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9pk: // global
           _sb7dP::P64 = P64[Sp + 8];
           _sb7eu::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sb7dP::P64 + 8] = _sb7eu::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dP::P64);
           Sp = Sp + 8;
           call _sb7ea() args: 0, res: 0, upd: 0;
     }
 },
 _cb9nY() //  [R1]
         { info_tbl: [(cb9nY,
                       label: block_cb9nY_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9nY: // global
           if (R1 & 7 == 1) goto cb9oR; else goto cb9p9;
       cb9oR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb9oU; else goto cb9oT;
       cb9oU: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9oT: // global
           I64[Hp - 24] = sat_sb7eY_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sb7dP::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sb7dP::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dP::P64);
           Sp = Sp + 32;
           call _sb7ea() args: 0, res: 0, upd: 0;
       cb9p9: // global
           I64[Sp] = block_cb9oX_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub9pR; else goto cb9oY;
       ub9pR: // global
           call _cb9oX(R1) args: 0, res: 0, upd: 0;
       cb9oY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9oX() //  [R1]
         { info_tbl: [(cb9oX,
                       label: block_cb9oX_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9oX: // global
           I64[Sp - 8] = block_cb9p2_info;
           R2 = P64[Sp + 48];
           _sb7f2::P64 = P64[R1 + 7];
           _sb7f3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sb7f3::P64;
           P64[Sp + 48] = _sb7f2::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9p2() //  [R1]
         { info_tbl: [(cb9p2,
                       label: block_cb9p2_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9p2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9pd; else goto cb9pc;
       cb9pd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9pc: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cb9p5_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9p5() //  [R1]
         { info_tbl: [(cb9p5,
                       label: block_cb9p5_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9p5: // global
           I64[Sp] = block_cb9p7_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9pU; else goto cb9pf;
       ub9pU: // global
           call _cb9p7(R1) args: 0, res: 0, upd: 0;
       cb9pf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9p7() //  [R1]
         { info_tbl: [(cb9p7,
                       label: block_cb9p7_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9p7: // global
           _sb7dP::P64 = P64[Sp + 8];
           _sb7ff::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sb7dP::P64 + 8] = _sb7ff::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dP::P64);
           Sp = Sp + 8;
           call _sb7ea() args: 0, res: 0, upd: 0;
     }
 },
 _sb7ea() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7ea: // global
           _sb7ee::P64 = P64[P64[Sp] + 8];
           I64[Sp + 24] = block_cb9ov_info;
           R1 = _sb7ee::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ub9pW; else goto cb9ox;
       ub9pW: // global
           call _cb9ov(R1) args: 0, res: 0, upd: 0;
       cb9ox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9ov() //  [R1]
         { info_tbl: [(cb9ov,
                       label: block_cb9ov_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ov: // global
           _sb7dB::P64 = P64[Sp + 16];
           _sb7dJ::P64 = P64[Sp + 8];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb9oG; else goto cb9oF;
       cb9oG: // global
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7dB::P64;
           R3 = I64[R1 + 31];
           R2 = _sb7dJ::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cb9oF: // global
           R6 = P64[Sp + 32];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7dB::P64;
           R3 = R1;
           R2 = _sb7dJ::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub9q8_srtd" {
     ub9q8_srtd:
         const Sb7vQ_srt+8;
         const 41;
         const 1700807051265;
 },
 GHC.IO.Handle.Text.$whGetBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9q0,
                       label: GHC.IO.Handle.Text.$whGetBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9q0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb9q4; else goto cb9q3;
       cb9q4: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBufNonBlocking_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9q3: // global
           if (R4 == 0) goto cb9pZ; else goto cb9pY;
       cb9pZ: // global
           Hp = Hp - 48;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9pY: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cb9q6; else goto cb9q7;
       cb9q6: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sb7fj_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = R4;
           R4 = Hp - 22;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cb9q7: // global
           Hp = Hp - 48;
           R4 = R4;
           R3 = GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.171682821 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking1_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking1_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9qg,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9qg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9qh; else goto cb9qi;
       cb9qh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufNonBlocking1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9qi: // global
           I64[Sp - 24] = block_cb9qd_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9qm; else goto cb9qe;
       ub9qm: // global
           call _cb9qd(R1) args: 0, res: 0, upd: 0;
       cb9qe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9qd() //  [R1]
         { info_tbl: [(cb9qd,
                       label: block_cb9qd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9qd: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBufNonBlocking_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.172893687 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9qr,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9qr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBufNonBlocking1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.1736644 UTC

[section ""cstring" . lvl12_rb6WS_bytes" {
     lvl12_rb6WS_bytes:
         I8[] [104,71,101,116,66,117,102,83,111,109,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.174406615 UTC

[section ""data" . lvl13_rb6WT_closure" {
     lvl13_rb6WT_closure:
         const lvl13_rb6WT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rb6WT_entry() //  [R1]
         { info_tbl: [(cb9qA,
                       label: lvl13_rb6WT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9qA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9qB; else goto cb9qC;
       cb9qB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9qC: // global
           (_cb9qx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9qx::I64 == 0) goto cb9qz; else goto cb9qy;
       cb9qz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9qy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9qx::I64;
           R2 = lvl12_rb6WS_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.179199117 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBufSome_closure" {
     GHC.IO.Handle.Text.$whGetBufSome_closure:
         const GHC.IO.Handle.Text.$whGetBufSome_info;
         const 0;
 },
 sat_sb7gT_entry() //  [R1]
         { info_tbl: [(cb9rs,
                       label: sat_sb7gT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9rs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9rw; else goto cb9rx;
       cb9rw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9rx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb9rp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9rB; else goto cb9rq;
       ub9rB: // global
           call _cb9rp(R1) args: 0, res: 0, upd: 0;
       cb9rq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9rp() //  [R1]
         { info_tbl: [(cb9rp,
                       label: block_cb9rp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9rp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9rA; else goto cb9rz;
       cb9rA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9rz: // global
           _sb7gO::P64 = P64[R1 + 7];
           _sb7gP::P64 = P64[R1 + 15];
           _sb7gN::I64 = I64[R1 + 23];
           _sb7gQ::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7gO::P64;
           P64[Hp - 32] = _sb7gP::P64;
           I64[Hp - 24] = _sb7gN::I64;
           I64[Hp - 16] = _sb7gQ::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7hc_entry() //  [R1]
         { info_tbl: [(cb9rY,
                       label: sat_sb7hc_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9rY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9s5; else goto cb9s6;
       cb9s5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9s6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb9rV_info;
           _sb7h2::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7h2::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9sa; else goto cb9rW;
       ub9sa: // global
           call _cb9rV(R1) args: 0, res: 0, upd: 0;
       cb9rW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9rV() //  [R1]
         { info_tbl: [(cb9rV,
                       label: block_cb9rV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9rV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9s9; else goto cb9s8;
       cb9s9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9s8: // global
           _sb7h6::P64 = P64[R1 + 7];
           _sb7h7::P64 = P64[R1 + 15];
           _sb7h5::I64 = I64[R1 + 23];
           _sb7h8::I64 = I64[R1 + 31];
           _sb7ha::I64 = I64[R1 + 47];
           _sb7hb::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7h6::P64;
           P64[Hp - 32] = _sb7h7::P64;
           I64[Hp - 24] = _sb7h5::I64;
           I64[Hp - 16] = _sb7h8::I64;
           I64[Hp - 8] = _sb7hb::I64;
           I64[Hp] = _sb7ha::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ub9vg_srtd" {
     ub9vg_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 sat_sb7hx_entry() //  [R1, R2]
         { info_tbl: [(cb9sb,
                       label: sat_sb7hx_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9sb: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cb9sc; else goto cb9sd;
       cb9sc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9sd: // global
           I64[Sp - 32] = block_cb9qS_info;
           _sb7fr::P64 = P64[R1 + 6];
           _sb7fw::P64 = P64[R1 + 14];
           _sb7fu::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb7fr::P64;
           I64[Sp - 16] = _sb7fu::I64;
           P64[Sp - 8] = _sb7fw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9uW; else goto cb9qT;
       ub9uW: // global
           call _cb9qS(R1) args: 0, res: 0, upd: 0;
       cb9qT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vh_srtd" {
     ub9vh_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9qS() //  [R1]
         { info_tbl: [(cb9qS,
                       label: block_cb9qS_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9qS: // global
           I64[Sp - 56] = block_cb9qX_info;
           _sb7fz::P64 = R1;
           _sb7fB::P64 = P64[R1 + 15];
           _sb7fC::P64 = P64[R1 + 23];
           _sb7fF::P64 = P64[R1 + 47];
           _sb7fH::P64 = P64[R1 + 63];
           _sb7fI::P64 = P64[R1 + 71];
           _sb7fL::P64 = P64[R1 + 95];
           R1 = P64[R1 + 31];
           P64[Sp - 48] = _sb7fB::P64;
           P64[Sp - 40] = _sb7fC::P64;
           P64[Sp - 32] = _sb7fF::P64;
           P64[Sp - 24] = _sb7fH::P64;
           P64[Sp - 16] = _sb7fI::P64;
           P64[Sp - 8] = _sb7fL::P64;
           P64[Sp] = _sb7fz::P64;
           Sp = Sp - 56;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vi_srtd" {
     ub9vi_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9qX() //  [R1]
         { info_tbl: [(cb9qX,
                       label: block_cb9qX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9qX: // global
           _sb7fV::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 24] = block_cb9r1_info;
           _sb7fQ::P64 = R1;
           _sb7fR::I64 = I64[R1 + 7];
           _sb7fS::I64 = I64[R1 + 15];
           R1 = _sb7fV::P64;
           I64[Sp - 16] = _sb7fR::I64;
           I64[Sp - 8] = _sb7fS::I64;
           P64[Sp] = _sb7fQ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9uM; else goto cb9r2;
       ub9uM: // global
           call _cb9r1(R1) args: 0, res: 0, upd: 0;
       cb9r2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vj_srtd" {
     ub9vj_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9r1() //  [R1]
         { info_tbl: [(cb9r1,
                       label: block_cb9r1_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9r1: // global
           I64[Sp - 16] = block_cb9r8_info;
           _sb7g1::I64 = I64[R1 + 39];
           _sb7g2::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sb7g2::I64;
           I64[Sp] = _sb7g1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub9uN; else goto cb9r9;
       ub9uN: // global
           call _cb9r8(R1) args: 0, res: 0, upd: 0;
       cb9r9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vk_srtd" {
     ub9vk_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9r8() //  [R1]
         { info_tbl: [(cb9r8,
                       label: block_cb9r8_info
                       rep:StackRep [True, True, True, True, False, False, False, False,
                                     False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9r8: // global
           if (R1 & 7 == 1) goto cb9um; else goto ub9uF;
       cb9um: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ub9uG; else goto cb9tI;
       ub9uG: // global
           Sp = Sp + 24;
           goto ub9uQ;
       cb9tI: // global
           _sb7gF::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cb9rg_info;
           R1 = _sb7gF::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub9uO; else goto cb9rh;
       ub9uO: // global
           call _cb9rg(R1) args: 0, res: 0, upd: 0;
       cb9rh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub9uF: // global
           Sp = Sp + 24;
           goto ub9uQ;
       ub9uQ: // global
           call _sb7g3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub9vl_srtd" {
     ub9vl_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9rg() //  [R1]
         { info_tbl: [(cb9rg,
                       label: block_cb9rg_info
                       rep:StackRep [True, True, False, False, False, False, True, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9rg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9tL; else goto cb9tK;
       cb9tL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9tK: // global
           _sb7fI::P64 = P64[Sp + 64];
           _sb7gH::P64 = P64[R1 + 7];
           _sb7gI::P64 = P64[R1 + 15];
           _sb7gL::P64 = P64[_sb7fI::P64 + 8];
           I64[Hp - 16] = sat_sb7gT_info;
           P64[Hp] = _sb7gL::P64;
           call MO_WriteBarrier();
           P64[_sb7fI::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fI::P64);
           I64[Sp] = block_cb9rF_info;
           R1 = _sb7gL::P64;
           P64[Sp + 56] = _sb7gI::P64;
           P64[Sp + 64] = _sb7gH::P64;
           if (R1 & 7 != 0) goto ub9uR; else goto cb9rG;
       ub9uR: // global
           call _cb9rF(R1) args: 0, res: 0, upd: 0;
       cb9rG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vm_srtd" {
     ub9vm_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9rF() //  [R1]
         { info_tbl: [(cb9rF,
                       label: block_cb9rF_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9rF: // global
           _sb7h2::I64 = I64[R1 + 39];
           if (_sb7h2::I64 != 0) goto cb9tO; else goto cb9uj;
       cb9tO: // global
           I64[Sp - 24] = block_cb9rM_info;
           _sb7gX::P64 = P64[R1 + 7];
           _sb7gY::P64 = P64[R1 + 15];
           _sb7gW::I64 = I64[R1 + 23];
           R1 = P64[Sp + 72];
           P64[Sp - 16] = _sb7gY::P64;
           I64[Sp - 8] = _sb7h2::I64;
           P64[Sp] = _sb7gX::P64;
           I64[Sp + 72] = _sb7gW::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9uS; else goto cb9rN;
       ub9uS: // global
           call _cb9rM(R1) args: 0, res: 0, upd: 0;
       cb9rN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9uj: // global
           _sb7fF::P64 = P64[Sp + 48];
           _sb7gI::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = _sb7gI::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           Sp = Sp + 8;
           call _sb7g3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub9vn_srtd" {
     ub9vn_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9rM() //  [R1]
         { info_tbl: [(cb9rM,
                       label: block_cb9rM_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9rM: // global
           if (R1 & 7 == 1) goto cb9tQ; else goto cb9u8;
       cb9tQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb9tT; else goto cb9tS;
       cb9tT: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9tS: // global
           I64[Hp - 24] = sat_sb7hc_info;
           P64[Hp - 8] = P64[Sp + 80];
           I64[Hp] = I64[Sp + 16];
           _sb7fF::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           Sp = Sp + 32;
           call _sb7g3() args: 0, res: 0, upd: 0;
       cb9u8: // global
           I64[Sp] = block_cb9tW_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub9uU; else goto cb9tX;
       ub9uU: // global
           call _cb9tW(R1) args: 0, res: 0, upd: 0;
       cb9tX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vo_srtd" {
     ub9vo_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9tW() //  [R1]
         { info_tbl: [(cb9tW,
                       label: block_cb9tW_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9tW: // global
           I64[Sp - 8] = block_cb9u1_info;
           R2 = P64[Sp + 88];
           _sb7hg::P64 = P64[R1 + 7];
           _sb7hh::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sb7hh::P64;
           P64[Sp + 88] = _sb7hg::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vp_srtd" {
     ub9vp_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9u1() //  [R1]
         { info_tbl: [(cb9u1,
                       label: block_cb9u1_info
                       rep:StackRep [False, False, True, False, True, True, False, False,
                                     False, False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9u1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9uc; else goto cb9ub;
       cb9uc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9ub: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 104];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cb9u4_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 88];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 96];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vq_srtd" {
     ub9vq_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9u4() //  [R1]
         { info_tbl: [(cb9u4,
                       label: block_cb9u4_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9u4: // global
           I64[Sp] = block_cb9u6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9v2; else goto cb9ue;
       ub9v2: // global
           call _cb9u6(R1) args: 0, res: 0, upd: 0;
       cb9ue: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vr_srtd" {
     ub9vr_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9u6() //  [R1]
         { info_tbl: [(cb9u6,
                       label: block_cb9u6_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9u6: // global
           _sb7fF::P64 = P64[Sp + 48];
           _sb7ht::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = _sb7ht::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           Sp = Sp + 8;
           call _sb7g3() args: 0, res: 0, upd: 0;
     }
 },
 _sb7g3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7g3: // global
           _sb7g7::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 8] = block_cb9sk_info;
           R1 = _sb7g7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9v4; else goto cb9sm;
       ub9v4: // global
           call _cb9sk(R1) args: 0, res: 0, upd: 0;
       cb9sm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9vs_srtd" {
     ub9vs_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cb9sk() //  [R1]
         { info_tbl: [(cb9sk,
                       label: block_cb9sk_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9sk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9ss; else goto cb9sr;
       cb9ss: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9sr: // global
           _sb7fu::I64 = I64[Sp + 96];
           _sb7gd::I64 = I64[R1 + 39];
           _sb7ge::I64 = I64[R1 + 47];
           if (_sb7gd::I64 == _sb7ge::I64) goto cb9tF; else goto cb9sH;
       cb9tF: // global
           if (%MO_S_Le_W64(_sb7fu::I64,
                            I64[R1 + 31])) goto cb9tk; else goto cb9to;
       cb9tk: // global
           Hp = Hp - 16;
           P64[Sp + 72] = R1;
           Sp = Sp + 24;
           call _sb7gj() args: 0, res: 0, upd: 0;
       cb9to: // global
           Hp = Hp - 16;
           I64[Sp] = block_cb9tn_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 40];
           P64[Sp + 72] = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
       cb9sH: // global
           _sb7fr::P64 = P64[Sp + 88];
           _sb7fz::P64 = P64[Sp + 80];
           _sb7gg::I64 = _sb7ge::I64 - _sb7gd::I64;
           if (%MO_S_Gt_W64(_sb7fu::I64,
                            _sb7gg::I64)) goto cb9sE; else goto cb9sF;
       cb9sE: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7gg::I64;
           R6 = Hp - 7;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = R1;
           R2 = _sb7fz::P64;
           Sp = Sp + 112;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cb9sF: // global
           Hp = Hp - 16;
           R6 = P64[Sp + 104];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = R1;
           R2 = _sb7fz::P64;
           Sp = Sp + 112;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb9tn() //  [R1]
         { info_tbl: [(cb9tn,
                       label: block_cb9tn_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9tn: // global
           if (R1 & 7 == 1) goto ub9uL; else goto cb9tz;
       ub9uL: // global
           Sp = Sp + 24;
           call _sb7gj() args: 0, res: 0, upd: 0;
       cb9tz: // global
           I64[Sp] = block_cb9tx_info;
           R1 = P64[Sp + 88];
           if (R1 & 7 != 0) goto ub9v0; else goto cb9tA;
       ub9v0: // global
           call _cb9tx(R1) args: 0, res: 0, upd: 0;
       cb9tA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _sb7gj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7gj: // global
           I64[Sp + 16] = block_cb9sO_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp + 8] = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb9sO() //  [R1]
         { info_tbl: [(cb9sO,
                       label: block_cb9sO_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9sO: // global
           I64[Sp] = block_cb9sQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9uY; else goto cb9sR;
       ub9uY: // global
           call _cb9sQ(R1) args: 0, res: 0, upd: 0;
       cb9sR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9sQ() //  [R1]
         { info_tbl: [(cb9sQ,
                       label: block_cb9sQ_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9sQ: // global
           I64[Sp] = block_cb9sV_info;
           _sb7gq::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 32] = _sb7gq::P64;
           if (R1 & 7 != 0) goto ub9uZ; else goto cb9sZ;
       ub9uZ: // global
           call _cb9sV(R1) args: 0, res: 0, upd: 0;
       cb9sZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9sV() //  [R1]
         { info_tbl: [(cb9sV,
                       label: block_cb9sV_info
                       rep:StackRep [False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9sV: // global
           _sb7gt::I64 = I64[R1 + 7];
           if (_sb7gt::I64 == 0) goto cb9tg; else goto cb9tf;
       cb9tg: // global
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9tf: // global
           _sb7fr::P64 = P64[Sp + 48];
           _sb7fu::I64 = I64[Sp + 56];
           _sb7fw::P64 = P64[Sp + 64];
           _sb7fz::P64 = P64[Sp + 40];
           _sb7fF::P64 = P64[Sp + 8];
           _sb7gq::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = _sb7gq::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           if (%MO_S_Gt_W64(_sb7gt::I64,
                            _sb7fu::I64)) goto cb9tc; else goto cb9td;
       cb9tc: // global
           R6 = _sb7fw::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = _sb7gq::P64;
           R2 = _sb7fz::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cb9td: // global
           R6 = R1;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = _sb7gq::P64;
           R2 = _sb7fz::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb9tx() //  [R1]
         { info_tbl: [(cb9tx,
                       label: block_cb9tx_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9tx: // global
           R6 = 0;
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 104] = I64[Sp + 96];
           Sp = Sp + 104;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub9vt_srtd" {
     ub9vt_srtd:
         const Sb7vQ_srt+8;
         const 46;
         const 66279935313985;
 },
 GHC.IO.Handle.Text.$whGetBufSome_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9v8,
                       label: GHC.IO.Handle.Text.$whGetBufSome_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9v8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb9vc; else goto cb9vb;
       cb9vc: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBufSome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9vb: // global
           if (R4 == 0) goto cb9v7; else goto cb9v6;
       cb9v7: // global
           Hp = Hp - 48;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9v6: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cb9ve; else goto cb9vf;
       cb9ve: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sb7hx_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = R4;
           R4 = Hp - 22;
           R3 = R2;
           R2 = lvl13_rb6WT_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cb9vf: // global
           Hp = Hp - 48;
           R4 = R4;
           R3 = lvl13_rb6WT_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.192846351 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufSome1_closure" {
     GHC.IO.Handle.Text.hGetBufSome1_closure:
         const GHC.IO.Handle.Text.hGetBufSome1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufSome1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9vB,
                       label: GHC.IO.Handle.Text.hGetBufSome1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9vB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9vC; else goto cb9vD;
       cb9vC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufSome1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9vD: // global
           I64[Sp - 24] = block_cb9vy_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9vH; else goto cb9vz;
       ub9vH: // global
           call _cb9vy(R1) args: 0, res: 0, upd: 0;
       cb9vz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9vy() //  [R1]
         { info_tbl: [(cb9vy,
                       label: block_cb9vy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9vy: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBufSome_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.19410242 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufSome_closure" {
     GHC.IO.Handle.Text.hGetBufSome_closure:
         const GHC.IO.Handle.Text.hGetBufSome_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufSome_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9vM,
                       label: GHC.IO.Handle.Text.hGetBufSome_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9vM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBufSome1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.198814991 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf4_closure" {
     GHC.IO.Handle.Text.hGetBuf4_closure:
         const GHC.IO.Handle.Text.hGetBuf4_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb9vW,
                       label: GHC.IO.Handle.Text.hGetBuf4_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9vW: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cb9wa; else goto cb9wb;
       cb9wa: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9wb: // global
           I64[Sp - 40] = block_cb9vT_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9xG; else goto cb9vU;
       ub9xG: // global
           call _cb9vT(R1) args: 0, res: 0, upd: 0;
       cb9vU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9vT() //  [R1]
         { info_tbl: [(cb9vT,
                       label: block_cb9vT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9vT: // global
           I64[Sp - 8] = block_cb9vZ_info;
           _sb7hK::P64 = R1;
           _sb7hQ::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb7hQ::P64;
           P64[Sp + 8] = _sb7hK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9xF; else goto cb9w0;
       ub9xF: // global
           call _cb9vZ(R1) args: 0, res: 0, upd: 0;
       cb9w0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9vZ() //  [R1]
         { info_tbl: [(cb9vZ,
                       label: block_cb9vZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9vZ: // global
           I64[Sp - 40] = block_cb9w4_info;
           _sb7i3::P64 = P64[R1 + 7];
           _sb7i4::P64 = P64[R1 + 15];
           _sb7i2::I64 = I64[R1 + 23];
           _sb7i5::I64 = I64[R1 + 31];
           _sb7i6::I64 = I64[R1 + 39];
           _sb7i7::I64 = I64[R1 + 47];
           R1 = P64[Sp + 32];
           P64[Sp - 32] = _sb7i4::P64;
           I64[Sp - 24] = _sb7i5::I64;
           I64[Sp - 16] = _sb7i6::I64;
           I64[Sp - 8] = _sb7i7::I64;
           P64[Sp] = _sb7i3::P64;
           I64[Sp + 32] = _sb7i2::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9xH; else goto cb9w5;
       ub9xH: // global
           call _cb9w4(R1) args: 0, res: 0, upd: 0;
       cb9w5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9w4() //  [R1]
         { info_tbl: [(cb9w4,
                       label: block_cb9w4_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9w4: // global
           I64[Sp] = block_cb9w9_info;
           _sb7i9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 80];
           I64[Sp + 80] = _sb7i9::I64;
           if (R1 & 7 != 0) goto ub9xI; else goto cb9wf;
       ub9xI: // global
           call _cb9w9(R1) args: 0, res: 0, upd: 0;
       cb9wf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9w9() //  [R1]
         { info_tbl: [(cb9w9,
                       label: block_cb9w9_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9w9: // global
           _sb7hG::P64 = P64[Sp + 64];
           _sb7ib::I64 = I64[R1 + 7];
           _sb7ic::I64 = I64[Sp + 32] - I64[Sp + 24];
           if (%MO_S_Ge_W64(_sb7ib::I64,
                            _sb7ic::I64)) goto cb9ws; else goto cb9xB;
       cb9ws: // global
           I64[Sp] = block_cb9wq_info;
           R1 = _sb7hG::P64;
           I64[Sp + 32] = _sb7ic::I64;
           I64[Sp + 64] = _sb7ib::I64;
           if (R1 & 7 != 0) goto ub9xJ; else goto cb9wt;
       ub9xJ: // global
           call _cb9wq(R1) args: 0, res: 0, upd: 0;
       cb9wt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9xB: // global
           I64[Sp] = block_cb9xa_info;
           R1 = _sb7hG::P64;
           I64[Sp + 64] = _sb7ib::I64;
           if (R1 & 7 != 0) goto ub9xK; else goto cb9xb;
       ub9xK: // global
           call _cb9xa(R1) args: 0, res: 0, upd: 0;
       cb9xb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9wq() //  [R1]
         { info_tbl: [(cb9wq,
                       label: block_cb9wq_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9wq: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cb9wz; else goto cb9wy;
       cb9wz: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9wy: // global
           _sb7hK::P64 = P64[Sp + 56];
           _sb7hQ::P64 = P64[Sp + 48];
           _sb7i2::I64 = I64[Sp + 72];
           _sb7i3::P64 = P64[Sp + 40];
           _sb7i4::P64 = P64[Sp + 8];
           _sb7i5::I64 = I64[Sp + 16];
           _sb7i9::I64 = I64[Sp + 80];
           _sb7ib::I64 = I64[Sp + 64];
           _sb7ic::I64 = I64[Sp + 32];
           _sb7if::I64 = I64[R1 + 7];
           (_sb7il::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sb7if::I64, _sb7i2::I64 + I64[Sp + 24], _sb7ic::I64);
           call MO_Touch(_sb7i3::P64);
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb7i3::P64;
           P64[Hp - 80] = _sb7i4::P64;
           I64[Hp - 72] = _sb7i2::I64;
           I64[Hp - 64] = _sb7i5::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           call MO_WriteBarrier();
           _cb9wL::P64 = Hp - 95;
           P64[_sb7hQ::P64 + 8] = _cb9wL::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7hQ::P64);
           _sb7ip::I64 = _sb7ib::I64 - _sb7ic::I64;
           if (_sb7ip::I64 != 0) goto cb9x2; else goto cb9x8;
       cb9x2: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sb7ip::I64;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _sb7i9::I64 + _sb7ic::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sb7if::I64 + _sb7ic::I64;
           R6 = Hp - 39;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = _cb9wL::P64;
           R2 = _sb7hK::P64;
           Sp = Sp + 88;
           call GHC.IO.Handle.Text.hGetBuf2_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cb9x8: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sb7i9::I64 + _sb7ic::I64;
           _cb9x7::P64 = Hp - 39;
           Hp = Hp - 32;
           R1 = _cb9x7::P64;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9xa() //  [R1]
         { info_tbl: [(cb9xa,
                       label: block_cb9xa_info
                       rep:StackRep [False, True, True, True, False, False, True, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9xa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cb9xE; else goto cb9xD;
       cb9xE: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9xD: // global
           _sb7hQ::P64 = P64[Sp + 48];
           _sb7i2::I64 = I64[Sp + 72];
           _sb7i3::P64 = P64[Sp + 40];
           _sb7i4::P64 = P64[Sp + 8];
           _sb7i5::I64 = I64[Sp + 16];
           _sb7i6::I64 = I64[Sp + 24];
           _sb7i7::I64 = I64[Sp + 32];
           _sb7i9::I64 = I64[Sp + 80];
           _sb7ib::I64 = I64[Sp + 64];
           (_sb7iE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[R1 + 7], _sb7i2::I64 + _sb7i6::I64, _sb7ib::I64);
           call MO_Touch(_sb7i3::P64);
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = _sb7i3::P64;
           P64[Hp - 48] = _sb7i4::P64;
           I64[Hp - 40] = _sb7i2::I64;
           I64[Hp - 32] = _sb7i5::I64;
           I64[Hp - 24] = _sb7i6::I64 + _sb7ib::I64;
           I64[Hp - 16] = _sb7i7::I64;
           call MO_WriteBarrier();
           P64[_sb7hQ::P64 + 8] = Hp - 63;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7hQ::P64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7i9::I64 + _sb7ib::I64;
           R1 = Hp - 7;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Text.hGetBuf2_closure" {
     GHC.IO.Handle.Text.hGetBuf2_closure:
         const GHC.IO.Handle.Text.hGetBuf2_info;
         const 0;
 },
 sat_sb7jB_entry() //  [R1]
         { info_tbl: [(cb9zc,
                       label: sat_sb7jB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9zc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9zj; else goto cb9zk;
       cb9zj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9zk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb9z9_info;
           _sb7jw::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7jw::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9zo; else goto cb9za;
       ub9zo: // global
           call _cb9z9(R1) args: 0, res: 0, upd: 0;
       cb9za: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9z9() //  [R1]
         { info_tbl: [(cb9z9,
                       label: block_cb9z9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9z9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9zn; else goto cb9zm;
       cb9zn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9zm: // global
           _sb7jA::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7jA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7jF_entry() //  [R1]
         { info_tbl: [(cb9zw,
                       label: sat_sb7jF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9zw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9zx; else goto cb9zy;
       cb9zx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9zy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.$fNumInt_$c+_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ub9AZ_srtd" {
     ub9AZ_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 6807523164161;
 },
 GHC.IO.Handle.Text.hGetBuf2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb9zz,
                       label: GHC.IO.Handle.Text.hGetBuf2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9zz: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb9zA; else goto cb9zB;
       cb9zA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9zB: // global
           I64[Sp - 40] = block_cb9xP_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9AW; else goto cb9xQ;
       ub9AW: // global
           call _cb9xP(R1) args: 0, res: 0, upd: 0;
       cb9xQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9B0_srtd" {
     ub9B0_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 4608499908609;
 },
 _cb9xP() //  [R1]
         { info_tbl: [(cb9xP,
                       label: block_cb9xP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9xP: // global
           I64[Sp - 32] = block_cb9xU_info;
           _sb7iR::P64 = R1;
           _sb7iT::P64 = P64[R1 + 15];
           _sb7iU::P64 = P64[R1 + 23];
           _sb7iV::P64 = P64[R1 + 31];
           _sb7iX::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sb7iU::P64;
           P64[Sp - 16] = _sb7iV::P64;
           P64[Sp - 8] = _sb7iX::P64;
           P64[Sp] = _sb7iT::P64;
           P64[Sp + 8] = _sb7iR::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9AI; else goto cb9xV;
       ub9AI: // global
           call _cb9xU(R1) args: 0, res: 0, upd: 0;
       cb9xV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9B1_srtd" {
     ub9B1_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 4608499908609;
 },
 _cb9xU() //  [R1]
         { info_tbl: [(cb9xU,
                       label: block_cb9xU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9xU: // global
           I64[Sp - 8] = block_cb9xZ_info;
           _sb7j8::P64 = R1;
           _sb7jc::I64 = I64[R1 + 31];
           R1 = P64[Sp + 64];
           I64[Sp] = _sb7jc::I64;
           P64[Sp + 64] = _sb7j8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9AJ; else goto cb9y0;
       ub9AJ: // global
           call _cb9xZ(R1) args: 0, res: 0, upd: 0;
       cb9y0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9B2_srtd" {
     ub9B2_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 4608499908609;
 },
 _cb9xZ() //  [R1]
         { info_tbl: [(cb9xZ,
                       label: block_cb9xZ_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9xZ: // global
           _sb7jg::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sb7jg::I64,
                            I64[Sp + 8])) goto ub9AA; else goto cb9A4;
       ub9AA: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sb7jh() args: 0, res: 0, upd: 0;
       cb9A4: // global
           I64[Sp] = block_cb9ya_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 16];
           I64[Sp + 8] = _sb7jg::I64;
           P64[Sp + 16] = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9ya() //  [R1]
         { info_tbl: [(cb9ya,
                       label: block_cb9ya_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ya: // global
           if (R1 & 7 == 1) goto ub9AB; else goto cb9Au;
       ub9AB: // global
           Sp = Sp + 16;
           call _sb7jh() args: 0, res: 0, upd: 0;
       cb9Au: // global
           I64[Sp + 40] = I64[Sp + 8];
           P64[Sp + 48] = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           P64[Sp + 72] = P64[Sp + 24];
           Sp = Sp + 40;
           call _cb9yl() args: 0, res: 0, upd: 0;
     }
 },
 _sb7jh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7jh: // global
           I64[Sp - 8] = block_cb9zI_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 8];
           P64[Sp - 16] = P64[Sp + 56];
           Sp = Sp - 32;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb9zI() //  [R1]
         { info_tbl: [(cb9zI,
                       label: block_cb9zI_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9zI: // global
           I64[Sp] = block_cb9zK_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9AX; else goto cb9zL;
       ub9AX: // global
           call _cb9zK(R1) args: 0, res: 0, upd: 0;
       cb9zL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9zK() //  [R1]
         { info_tbl: [(cb9zK,
                       label: block_cb9zK_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9zK: // global
           I64[Sp] = block_cb9zP_info;
           _sb7jo::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 64] = _sb7jo::P64;
           if (R1 & 7 != 0) goto ub9AY; else goto cb9zT;
       ub9AY: // global
           call _cb9zP(R1) args: 0, res: 0, upd: 0;
       cb9zT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9zP() //  [R1]
         { info_tbl: [(cb9zP,
                       label: block_cb9zP_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9zP: // global
           _sb7iO::P64 = P64[Sp + 56];
           if (I64[R1 + 7] == 0) goto cb9A1; else goto cb9A0;
       cb9A1: // global
           R1 = _sb7iO::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9A0: // global
           _sb7iN::P64 = P64[Sp + 48];
           _sb7iR::P64 = P64[Sp + 40];
           _sb7iX::P64 = P64[Sp + 24];
           _sb7jf::P64 = P64[Sp + 8];
           _sb7jo::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sb7iX::P64 + 8] = _sb7jo::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7iX::P64);
           R6 = _sb7jf::P64;
           R5 = _sb7iO::P64;
           R4 = _sb7iN::P64;
           R3 = _sb7jo::P64;
           R2 = _sb7iR::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBuf4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb9yl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9yl: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cb9Ai; else goto cb9At;
       cb9Ai: // global
           I64[Sp - 8] = block_cb9yr_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9AN; else goto cb9ys;
       ub9AN: // global
           call _cb9yr(R1) args: 0, res: 0, upd: 0;
       cb9ys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9At: // global
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 24;
           call _cb9zq() args: 0, res: 0, upd: 0;
     }
 },
 _cb9yr() //  [R1]
         { info_tbl: [(cb9yr,
                       label: block_cb9yr_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9yr: // global
           I64[Sp] = block_cb9yw_info;
           _sb7jN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb7jN::I64;
           if (R1 & 7 != 0) goto ub9AP; else goto cb9yx;
       ub9AP: // global
           call _cb9yw(R1) args: 0, res: 0, upd: 0;
       cb9yx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9yw() //  [R1]
         { info_tbl: [(cb9yw,
                       label: block_cb9yw_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9yw: // global
           I64[Sp] = block_cb9yB_info;
           _sb7jP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sb7jP::I64;
           if (R1 & 7 != 0) goto ub9AQ; else goto cb9yC;
       ub9AQ: // global
           call _cb9yB(R1) args: 0, res: 0, upd: 0;
       cb9yC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9yB() //  [R1]
         { info_tbl: [(cb9yB,
                       label: block_cb9yB_info
                       rep:StackRep [True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9yB: // global
           _sb7jT::I64 = I64[Sp + 16] + I64[Sp + 40];
           I64[Sp] = block_cb9yM_info;
           R6 = 0;
           R5 = _sb7jT::I64;
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 8] = I64[Sp + 8];
           P64[Sp + 16] = R1;
           Sp = Sp - 8;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cb9yM() //  [R1]
         { info_tbl: [(cb9yM,
                       label: block_cb9yM_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9yM: // global
           I64[Sp] = block_cb9yO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9AR; else goto cb9yP;
       ub9AR: // global
           call _cb9yO(R1) args: 0, res: 0, upd: 0;
       cb9yP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9yO() //  [R1]
         { info_tbl: [(cb9yO,
                       label: block_cb9yO_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9yO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9Ap; else goto cb9Ao;
       cb9Ap: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9Ao: // global
           _sb7jP::I64 = I64[Sp + 40];
           _sb7k0::I64 = I64[R1 + 7];
           if (_sb7k0::I64 != 0) goto cb9Ar; else goto cb9As;
       cb9Ar: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7jP::I64 + _sb7k0::I64;
           P64[Sp + 40] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 7;
           I64[Sp + 8] = I64[Sp + 8] - _sb7k0::I64;
           Sp = Sp + 8;
           call _cb9yl() args: 0, res: 0, upd: 0;
       cb9As: // global
           Hp = Hp - 16;
           I64[Sp + 40] = _sb7jP::I64;
           Sp = Sp + 32;
           call _cb9z3() args: 0, res: 0, upd: 0;
     }
 },
 _cb9z3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9z3: // global
           Hp = Hp + 32;
           _sb7jw::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb9Ac; else goto cb9Ab;
       cb9Ac: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cb9z2_info;
           R1 = _sb7jw::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb9Ab: // global
           I64[Hp - 24] = sat_sb7jB_info;
           P64[Hp - 8] = P64[Sp];
           I64[Hp] = _sb7jw::I64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9z2() //  [R1]
         { info_tbl: [(cb9z2,
                       label: block_cb9z2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9z2: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb9z3() args: 0, res: 0, upd: 0;
     }
 },
 _cb9zq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9zq: // global
           Hp = Hp + 32;
           _sb7jD::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cb9Af; else goto cb9Ae;
       cb9Af: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cb9zp_info;
           R1 = _sb7jD::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9Ae: // global
           I64[Hp - 24] = sat_sb7jF_info;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = _sb7jD::P64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9zp() //  [R1]
         { info_tbl: [(cb9zp,
                       label: block_cb9zp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9zp: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cb9zq() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.207502116 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetBuf6_bytes" {
     GHC.IO.Handle.Text.hGetBuf6_bytes:
         I8[] [104,71,101,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.208297947 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf5_closure" {
     GHC.IO.Handle.Text.hGetBuf5_closure:
         const GHC.IO.Handle.Text.hGetBuf5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf5_entry() //  [R1]
         { info_tbl: [(cb9B9,
                       label: GHC.IO.Handle.Text.hGetBuf5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9B9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9Ba; else goto cb9Bb;
       cb9Ba: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9Bb: // global
           (_cb9B6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9B6::I64 == 0) goto cb9B8; else goto cb9B7;
       cb9B8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9B7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9B6::I64;
           R2 = GHC.IO.Handle.Text.hGetBuf6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.211904117 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBuf_closure" {
     GHC.IO.Handle.Text.$whGetBuf_closure:
         const GHC.IO.Handle.Text.$whGetBuf_info;
         const 0;
 },
 sat_sb7l9_entry() //  [R1]
         { info_tbl: [(cb9BX,
                       label: sat_sb7l9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9BX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9C1; else goto cb9C2;
       cb9C1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9C2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb9BU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9C6; else goto cb9BV;
       ub9C6: // global
           call _cb9BU(R1) args: 0, res: 0, upd: 0;
       cb9BV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9BU() //  [R1]
         { info_tbl: [(cb9BU,
                       label: block_cb9BU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9BU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9C5; else goto cb9C4;
       cb9C5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9C4: // global
           _sb7l4::P64 = P64[R1 + 7];
           _sb7l5::P64 = P64[R1 + 15];
           _sb7l3::I64 = I64[R1 + 23];
           _sb7l6::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7l4::P64;
           P64[Hp - 32] = _sb7l5::P64;
           I64[Hp - 24] = _sb7l3::I64;
           I64[Hp - 16] = _sb7l6::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7ls_entry() //  [R1]
         { info_tbl: [(cb9Ct,
                       label: sat_sb7ls_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ct: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9CA; else goto cb9CB;
       cb9CA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9CB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb9Cq_info;
           _sb7li::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7li::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9CF; else goto cb9Cr;
       ub9CF: // global
           call _cb9Cq(R1) args: 0, res: 0, upd: 0;
       cb9Cr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9Cq() //  [R1]
         { info_tbl: [(cb9Cq,
                       label: block_cb9Cq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Cq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9CE; else goto cb9CD;
       cb9CE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9CD: // global
           _sb7lm::P64 = P64[R1 + 7];
           _sb7ln::P64 = P64[R1 + 15];
           _sb7ll::I64 = I64[R1 + 23];
           _sb7lo::I64 = I64[R1 + 31];
           _sb7lq::I64 = I64[R1 + 47];
           _sb7lr::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7lm::P64;
           P64[Hp - 32] = _sb7ln::P64;
           I64[Hp - 24] = _sb7ll::I64;
           I64[Hp - 16] = _sb7lo::I64;
           I64[Hp - 8] = _sb7lr::I64;
           I64[Hp] = _sb7lq::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7lN_entry() //  [R1, R2]
         { info_tbl: [(cb9CG,
                       label: sat_sb7lN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9CG: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb9CH; else goto cb9CI;
       cb9CH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9CI: // global
           I64[Sp - 24] = block_cb9Br_info;
           _sb7k5::P64 = P64[R1 + 6];
           _sb7ka::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sb7k5::P64;
           P64[Sp - 8] = _sb7ka::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9Ec; else goto cb9Bs;
       ub9Ec: // global
           call _cb9Br(R1) args: 0, res: 0, upd: 0;
       cb9Bs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Br() //  [R1]
         { info_tbl: [(cb9Br,
                       label: block_cb9Br_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Br: // global
           I64[Sp - 40] = block_cb9Bw_info;
           _sb7kd::P64 = R1;
           _sb7kj::P64 = P64[R1 + 47];
           _sb7kl::P64 = P64[R1 + 63];
           _sb7km::P64 = P64[R1 + 71];
           _sb7kp::P64 = P64[R1 + 95];
           R1 = P64[_sb7km::P64 + 8];
           P64[Sp - 32] = _sb7kj::P64;
           P64[Sp - 24] = _sb7kl::P64;
           P64[Sp - 16] = _sb7km::P64;
           P64[Sp - 8] = _sb7kp::P64;
           P64[Sp] = _sb7kd::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9E2; else goto cb9Bx;
       ub9E2: // global
           call _cb9Bw(R1) args: 0, res: 0, upd: 0;
       cb9Bx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Bw() //  [R1]
         { info_tbl: [(cb9Bw,
                       label: block_cb9Bw_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Bw: // global
           I64[Sp - 16] = block_cb9BD_info;
           _sb7kC::I64 = I64[R1 + 39];
           _sb7kD::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sb7kD::I64;
           I64[Sp] = _sb7kC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub9E3; else goto cb9BE;
       ub9E3: // global
           call _cb9BD(R1) args: 0, res: 0, upd: 0;
       cb9BE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9BD() //  [R1]
         { info_tbl: [(cb9BD,
                       label: block_cb9BD_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9BD: // global
           if (R1 & 7 == 1) goto cb9DG; else goto ub9DX;
       cb9DG: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ub9DY; else goto cb9D2;
       ub9DY: // global
           Sp = Sp + 24;
           goto ub9E6;
       cb9D2: // global
           _sb7kV::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cb9BL_info;
           R1 = _sb7kV::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub9E4; else goto cb9BM;
       ub9E4: // global
           call _cb9BL(R1) args: 0, res: 0, upd: 0;
       cb9BM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub9DX: // global
           Sp = Sp + 24;
           goto ub9E6;
       ub9E6: // global
           call _sb7kE() args: 0, res: 0, upd: 0;
     }
 },
 _cb9BL() //  [R1]
         { info_tbl: [(cb9BL,
                       label: block_cb9BL_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9BL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9D5; else goto cb9D4;
       cb9D5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9D4: // global
           _sb7km::P64 = P64[Sp + 24];
           _sb7kX::P64 = P64[R1 + 7];
           _sb7kY::P64 = P64[R1 + 15];
           _sb7l1::P64 = P64[_sb7km::P64 + 8];
           I64[Hp - 16] = sat_sb7l9_info;
           P64[Hp] = _sb7l1::P64;
           call MO_WriteBarrier();
           P64[_sb7km::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7km::P64);
           I64[Sp] = block_cb9Ca_info;
           R1 = _sb7l1::P64;
           P64[Sp + 16] = _sb7kY::P64;
           P64[Sp + 24] = _sb7kX::P64;
           if (R1 & 7 != 0) goto ub9E7; else goto cb9Cb;
       ub9E7: // global
           call _cb9Ca(R1) args: 0, res: 0, upd: 0;
       cb9Cb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Ca() //  [R1]
         { info_tbl: [(cb9Ca,
                       label: block_cb9Ca_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ca: // global
           _sb7li::I64 = I64[R1 + 39];
           if (_sb7li::I64 != 0) goto cb9D8; else goto cb9DD;
       cb9D8: // global
           I64[Sp - 24] = block_cb9Ch_info;
           _sb7ld::P64 = P64[R1 + 7];
           _sb7le::P64 = P64[R1 + 15];
           _sb7lc::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sb7le::P64;
           I64[Sp - 8] = _sb7li::I64;
           P64[Sp] = _sb7ld::P64;
           I64[Sp + 32] = _sb7lc::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9E8; else goto cb9Ci;
       ub9E8: // global
           call _cb9Ch(R1) args: 0, res: 0, upd: 0;
       cb9Ci: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9DD: // global
           _sb7kj::P64 = P64[Sp + 8];
           _sb7kY::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sb7kj::P64 + 8] = _sb7kY::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7kj::P64);
           Sp = Sp + 8;
           call _sb7kE() args: 0, res: 0, upd: 0;
     }
 },
 _cb9Ch() //  [R1]
         { info_tbl: [(cb9Ch,
                       label: block_cb9Ch_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ch: // global
           if (R1 & 7 == 1) goto cb9Da; else goto cb9Ds;
       cb9Da: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb9Dd; else goto cb9Dc;
       cb9Dd: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9Dc: // global
           I64[Hp - 24] = sat_sb7ls_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sb7kj::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sb7kj::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7kj::P64);
           Sp = Sp + 32;
           call _sb7kE() args: 0, res: 0, upd: 0;
       cb9Ds: // global
           I64[Sp] = block_cb9Dg_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub9Ea; else goto cb9Dh;
       ub9Ea: // global
           call _cb9Dg(R1) args: 0, res: 0, upd: 0;
       cb9Dh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Dg() //  [R1]
         { info_tbl: [(cb9Dg,
                       label: block_cb9Dg_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Dg: // global
           I64[Sp - 8] = block_cb9Dl_info;
           R2 = P64[Sp + 48];
           _sb7lw::P64 = P64[R1 + 7];
           _sb7lx::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sb7lx::P64;
           P64[Sp + 48] = _sb7lw::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Dl() //  [R1]
         { info_tbl: [(cb9Dl,
                       label: block_cb9Dl_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Dl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9Dw; else goto cb9Dv;
       cb9Dw: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9Dv: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cb9Do_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Do() //  [R1]
         { info_tbl: [(cb9Do,
                       label: block_cb9Do_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Do: // global
           I64[Sp] = block_cb9Dq_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9Ed; else goto cb9Dy;
       ub9Ed: // global
           call _cb9Dq(R1) args: 0, res: 0, upd: 0;
       cb9Dy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Dq() //  [R1]
         { info_tbl: [(cb9Dq,
                       label: block_cb9Dq_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Dq: // global
           _sb7kj::P64 = P64[Sp + 8];
           _sb7lJ::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sb7kj::P64 + 8] = _sb7lJ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7kj::P64);
           Sp = Sp + 8;
           call _sb7kE() args: 0, res: 0, upd: 0;
     }
 },
 _sb7kE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7kE: // global
           _sb7kI::P64 = P64[P64[Sp] + 8];
           I64[Sp + 24] = block_cb9CO_info;
           R1 = _sb7kI::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ub9Ef; else goto cb9CQ;
       ub9Ef: // global
           call _cb9CO(R1) args: 0, res: 0, upd: 0;
       cb9CQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9CO() //  [R1]
         { info_tbl: [(cb9CO,
                       label: block_cb9CO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9CO: // global
           _sb7k5::P64 = P64[Sp + 16];
           _sb7ka::P64 = P64[Sp + 24];
           _sb7kd::P64 = P64[Sp + 8];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb9CZ; else goto cb9CY;
       cb9CZ: // global
           R6 = _sb7ka::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7k5::P64;
           R3 = R1;
           R2 = _sb7kd::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.hGetBuf2_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cb9CY: // global
           R6 = _sb7ka::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7k5::P64;
           R3 = R1;
           R2 = _sb7kd::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.hGetBuf4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub9Er_srtd" {
     ub9Er_srtd:
         const Sb7vQ_srt+8;
         const 51;
         const 2111062325331969;
 },
 GHC.IO.Handle.Text.$whGetBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9Ej,
                       label: GHC.IO.Handle.Text.$whGetBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ej: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb9En; else goto cb9Em;
       cb9En: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBuf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9Em: // global
           if (R4 == 0) goto cb9Ei; else goto cb9Eh;
       cb9Ei: // global
           Hp = Hp - 40;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9Eh: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cb9Ep; else goto cb9Eq;
       cb9Ep: // global
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sb7lN_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 31;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetBuf5_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cb9Eq: // global
           Hp = Hp - 40;
           R4 = R4;
           R3 = GHC.IO.Handle.Text.hGetBuf5_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.218511331 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf1_closure" {
     GHC.IO.Handle.Text.hGetBuf1_closure:
         const GHC.IO.Handle.Text.hGetBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9Ez,
                       label: GHC.IO.Handle.Text.hGetBuf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ez: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9EA; else goto cb9EB;
       cb9EA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9EB: // global
           I64[Sp - 24] = block_cb9Ew_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9EF; else goto cb9Ex;
       ub9EF: // global
           call _cb9Ew(R1) args: 0, res: 0, upd: 0;
       cb9Ex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Ew() //  [R1]
         { info_tbl: [(cb9Ew,
                       label: block_cb9Ew_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ew: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBuf_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.219724005 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf_closure" {
     GHC.IO.Handle.Text.hGetBuf_closure:
         const GHC.IO.Handle.Text.hGetBuf_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9EK,
                       label: GHC.IO.Handle.Text.hGetBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9EK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBuf1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.220458845 UTC

[section ""cstring" . lvl14_rb6WU_bytes" {
     lvl14_rb6WU_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.221211836 UTC

[section ""data" . lvl15_rb6WV_closure" {
     lvl15_rb6WV_closure:
         const lvl15_rb6WV_info;
         const 0;
         const 0;
         const 0;
 },
 lvl15_rb6WV_entry() //  [R1]
         { info_tbl: [(cb9ET,
                       label: lvl15_rb6WV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ET: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9EU; else goto cb9EV;
       cb9EU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9EV: // global
           (_cb9EQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9EQ::I64 == 0) goto cb9ES; else goto cb9ER;
       cb9ES: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9ER: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9EQ::I64;
           R2 = lvl14_rb6WU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.222267336 UTC

[section ""data" . lvl16_rb6WW_closure" {
     lvl16_rb6WW_closure:
         const lvl16_rb6WW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_rb6WW_entry() //  [R1]
         { info_tbl: [(cb9F2,
                       label: lvl16_rb6WW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9F2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9F3; else goto cb9F4;
       cb9F3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9F4: // global
           (_cb9EZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9EZ::I64 == 0) goto cb9F1; else goto cb9F0;
       cb9F1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9F0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9EZ::I64;
           R2 = GHC.IO.Handle.Text.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.223279417 UTC

[section ""data" . lvl17_rb6WX_closure" {
     lvl17_rb6WX_closure:
         const lvl17_rb6WX_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rb6WX_entry() //  [R1]
         { info_tbl: [(cb9Fb,
                       label: lvl17_rb6WX_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Fb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9Fc; else goto cb9Fd;
       cb9Fc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9Fd: // global
           (_cb9F8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9F8::I64 == 0) goto cb9Fa; else goto cb9F9;
       cb9Fa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9F9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9F8::I64;
           R2 = GHC.IO.Handle.Text.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.224126126 UTC

[section ""cstring" . lvl18_rb6WY_bytes" {
     lvl18_rb6WY_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,84,101,120,116,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.224824703 UTC

[section ""data" . lvl19_rb6WZ_closure" {
     lvl19_rb6WZ_closure:
         const lvl19_rb6WZ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rb6WZ_entry() //  [R1]
         { info_tbl: [(cb9Fk,
                       label: lvl19_rb6WZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Fk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9Fl; else goto cb9Fm;
       cb9Fl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9Fm: // global
           (_cb9Fh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9Fh::I64 == 0) goto cb9Fj; else goto cb9Fi;
       cb9Fj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9Fi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9Fh::I64;
           R2 = lvl18_rb6WY_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.225848818 UTC

[section ""data" . lvl20_rb6X0_closure" {
     lvl20_rb6X0_closure:
         const GHC.Types.I#_con_info;
         const 785;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.226401975 UTC

[section ""data" . lvl21_rb6X1_closure" {
     lvl21_rb6X1_closure:
         const GHC.Types.I#_con_info;
         const 17;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.226943859 UTC

[section ""data" . lvl22_rb6X2_closure" {
     lvl22_rb6X2_closure:
         const GHC.Types.I#_con_info;
         const 38;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.227521282 UTC

[section ""data" . lvl23_rb6X3_closure" {
     lvl23_rb6X3_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl16_rb6WW_closure;
         const lvl17_rb6WX_closure;
         const lvl19_rb6WZ_closure;
         const lvl20_rb6X0_closure+1;
         const lvl21_rb6X1_closure+1;
         const lvl20_rb6X0_closure+1;
         const lvl22_rb6X2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.228165208 UTC

[section ""data" . lvl24_rb6X4_closure" {
     lvl24_rb6X4_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl15_rb6WV_closure;
         const lvl23_rb6X3_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.228763719 UTC

[section ""cstring" . lvl25_rb6X5_bytes" {
     lvl25_rb6X5_bytes:
         I8[] [84,111,100,111,58,32,104,80,117,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.229596387 UTC

[section ""data" . lvl26_rb6X6_closure" {
     lvl26_rb6X6_closure:
         const lvl26_rb6X6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_rb6X6_entry() //  [R1]
         { info_tbl: [(cb9Fv,
                       label: lvl26_rb6X6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Fv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9Fw; else goto cb9Fx;
       cb9Fw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9Fx: // global
           (_cb9Fq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9Fq::I64 == 0) goto cb9Fs; else goto cb9Fr;
       cb9Fs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9Fr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9Fq::I64;
           I64[Sp - 24] = block_cb9Ft_info;
           R2 = lvl25_rb6X5_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb9Ft() //  [R1]
         { info_tbl: [(cb9Ft,
                       label: block_cb9Ft_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ft: // global
           R3 = R1;
           R2 = lvl24_rb6X4_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.230601701 UTC

[section ""data" . lvl27_rb6X7_closure" {
     lvl27_rb6X7_closure:
         const GHC.Types.I#_con_info;
         const 790;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.231130053 UTC

[section ""data" . lvl28_rb6X8_closure" {
     lvl28_rb6X8_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl16_rb6WW_closure;
         const lvl17_rb6WX_closure;
         const lvl19_rb6WZ_closure;
         const lvl27_rb6X7_closure+1;
         const lvl21_rb6X1_closure+1;
         const lvl27_rb6X7_closure+1;
         const lvl22_rb6X2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.231704795 UTC

[section ""data" . lvl29_rb6X9_closure" {
     lvl29_rb6X9_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl15_rb6WV_closure;
         const lvl28_rb6X8_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.232463316 UTC

[section ""data" . lvl30_rb6Xa_closure" {
     lvl30_rb6Xa_closure:
         const lvl30_rb6Xa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_rb6Xa_entry() //  [R1]
         { info_tbl: [(cb9FJ,
                       label: lvl30_rb6Xa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9FJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9FK; else goto cb9FL;
       cb9FK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9FL: // global
           (_cb9FE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9FE::I64 == 0) goto cb9FG; else goto cb9FF;
       cb9FG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9FF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9FE::I64;
           I64[Sp - 24] = block_cb9FH_info;
           R2 = lvl25_rb6X5_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb9FH() //  [R1]
         { info_tbl: [(cb9FH,
                       label: block_cb9FH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9FH: // global
           R3 = R1;
           R2 = lvl29_rb6X9_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.235814693 UTC

[section ""data" . GHC.IO.Handle.Text.$wbufWrite_closure" {
     GHC.IO.Handle.Text.$wbufWrite_closure:
         const GHC.IO.Handle.Text.$wbufWrite_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wbufWrite_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9FQ: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wbufWrite_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub9IR_srtd" {
     ub9IR_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 17451452851027969;
 },
 GHC.IO.Handle.Text.$wbufWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb9FX,
                       label: GHC.IO.Handle.Text.$wbufWrite_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9FX: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cb9G5; else goto ub9ID;
       cb9G5: // global
           R1 = GHC.IO.Handle.Text.$wbufWrite_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ub9ID: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _cb9FR() args: 0, res: 0, upd: 0;
     }
 },
 _cb9FR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9FR: // global
           _sb7lW::P64 = P64[Sp];
           I64[Sp] = block_cb9FU_info;
           R1 = _sb7lW::P64;
           if (R1 & 7 != 0) goto ub9IH; else goto cb9FV;
       ub9IH: // global
           call _cb9FU(R1) args: 0, res: 0, upd: 0;
       cb9FV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9IS_srtd" {
     ub9IS_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb9FU() //  [R1]
         { info_tbl: [(cb9FU,
                       label: block_cb9FU_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9FU: // global
           I64[Sp - 32] = block_cb9G0_info;
           _sb7m1::P64 = R1;
           _sb7m3::P64 = P64[R1 + 15];
           _sb7m4::P64 = P64[R1 + 23];
           _sb7m7::P64 = P64[R1 + 47];
           R1 = P64[R1 + 31];
           P64[Sp - 24] = _sb7m3::P64;
           P64[Sp - 16] = _sb7m4::P64;
           P64[Sp - 8] = _sb7m7::P64;
           P64[Sp] = _sb7m1::P64;
           Sp = Sp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9IT_srtd" {
     ub9IT_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb9G0() //  [R1]
         { info_tbl: [(cb9G0,
                       label: block_cb9G0_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9G0: // global
           _sb7mn::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 24] = block_cb9G4_info;
           _sb7mi::P64 = R1;
           _sb7mj::I64 = I64[R1 + 7];
           _sb7mk::I64 = I64[R1 + 15];
           R1 = _sb7mn::P64;
           I64[Sp - 16] = _sb7mj::I64;
           I64[Sp - 8] = _sb7mk::I64;
           P64[Sp] = _sb7mi::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9IJ; else goto cb9G9;
       ub9IJ: // global
           call _cb9G4(R1) args: 0, res: 0, upd: 0;
       cb9G9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9IU_srtd" {
     ub9IU_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb9G4() //  [R1]
         { info_tbl: [(cb9G4,
                       label: block_cb9G4_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9G4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9Gf; else goto cb9Ge;
       cb9Gf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9Ge: // global
           _sb7mq::P64 = P64[R1 + 7];
           _sb7mr::P64 = P64[R1 + 15];
           _sb7mp::I64 = I64[R1 + 23];
           _sb7ms::I64 = I64[R1 + 31];
           _sb7mt::I64 = I64[R1 + 39];
           _sb7mu::I64 = I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _sb7lY::I64 = I64[Sp + 72];
           I64[Hp] = _sb7lY::I64;
           _sb7m3::P64 = P64[Sp + 32];
           _sb7mi::P64 = P64[Sp + 24];
           _sb7mo::P64 = R1;
           _cb9Gg::P64 = Hp - 7;
           if (%MO_S_Ge_W64(_sb7lY::I64,
                            _sb7ms::I64)) goto sb7mw; else goto cb9Im;
       cb9Im: // global
           if (%MO_S_Gt_W64(_sb7lY::I64,
                            _sb7ms::I64 - _sb7mu::I64)) goto sb7mw; else goto cb9HM;
       sb7mw: // global
           if (%MO_S_Le_W64(_sb7mu::I64, 0)) goto ub9IE; else goto cb9Ht;
       ub9IE: // global
           I64[Sp + 32] = _sb7ms::I64;
           P64[Sp + 48] = _cb9Gg::P64;
           Sp = Sp + 8;
           call _sb7mx() args: 0, res: 0, upd: 0;
       cb9Ht: // global
           I64[Sp] = block_cb9Hs_info;
           R2 = _sb7m3::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sb7mi::P64;
           P64[Sp - 8] = _sb7mo::P64;
           I64[Sp + 24] = _sb7ms::I64;
           P64[Sp + 32] = _cb9Gg::P64;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cb9HM: // global
           I64[Sp - 8] = block_cb9HL_info;
           R1 = P64[Sp + 64];
           I64[Sp] = _sb7mu::I64;
           I64[Sp + 8] = _sb7mt::I64;
           I64[Sp + 16] = _sb7ms::I64;
           P64[Sp + 40] = _sb7mr::P64;
           P64[Sp + 56] = _sb7mq::P64;
           I64[Sp + 64] = _sb7mp::I64;
           P64[Sp + 80] = _cb9Gg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9IK; else goto cb9HN;
       ub9IK: // global
           call _cb9HL(R1) args: 0, res: 0, upd: 0;
       cb9HN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9IV_srtd" {
     ub9IV_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb9Hs() //  [R1]
         { info_tbl: [(cb9Hs,
                       label: block_cb9Hs_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Hs: // global
           _cb9Gg::P64 = P64[Sp + 32];
           _sb7m7::P64 = P64[Sp + 48];
           _sb7ms::I64 = I64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sb7m7::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7m7::P64);
           P64[Sp + 48] = _cb9Gg::P64;
           I64[Sp + 32] = _sb7ms::I64;
           Sp = Sp + 8;
           call _sb7mx() args: 0, res: 0, upd: 0;
     }
 },
 _sb7mx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7mx: // global
           _sb7lY::I64 = I64[Sp + 64];
           _sb7lZ::P64 = P64[Sp + 72];
           if (%MO_S_Ge_W64(_sb7lY::I64,
                            I64[Sp + 24])) goto cb9Gy; else goto cb9Hl;
       cb9Gy: // global
           I64[Sp - 8] = block_cb9Gw_info;
           R1 = _sb7lZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9IP; else goto cb9Gz;
       ub9IP: // global
           call _cb9Gw(R1) args: 0, res: 0, upd: 0;
       cb9Gz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9Hl: // global
           P64[Sp + 48] = P64[Sp + 48];
           P64[Sp + 56] = P64[Sp + 56];
           I64[Sp + 64] = _sb7lY::I64;
           P64[Sp + 72] = _sb7lZ::P64;
           Sp = Sp + 48;
           call _cb9FR() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub9IW_srtd" {
     ub9IW_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cb9Gw() //  [R1]
         { info_tbl: [(cb9Gw,
                       label: block_cb9Gw_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Gw: // global
           _sb7m4::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cb9GG; else goto cb9H1;
       cb9GG: // global
           I64[Sp] = block_cb9GD_info;
           R3 = lvl11_rb6WR_closure;
           R2 = _sb7m4::P64;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
       cb9H1: // global
           I64[Sp] = block_cb9GZ_info;
           R3 = lvl11_rb6WR_closure;
           R2 = _sb7m4::P64;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9GD() //  [R1]
         { info_tbl: [(cb9GD,
                       label: block_cb9GD_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9GD: // global
           if (R1 & 7 == 1) goto cb9GM; else goto cb9GR;
       cb9GM: // global
           R1 = lvl30_rb6Xa_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cb9GR: // global
           I64[Sp] = block_cb9GP_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto ub9IM; else goto cb9GS;
       ub9IM: // global
           call _cb9GP(R1) args: 0, res: 0, upd: 0;
       cb9GS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9GP() //  [R1]
         { info_tbl: [(cb9GP,
                       label: block_cb9GP_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9GP: // global
           R5 = I64[Sp + 72];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 88;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb9GZ() //  [R1]
         { info_tbl: [(cb9GZ,
                       label: block_cb9GZ_info
                       rep:StackRep [True, True, True, True, True, False, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9GZ: // global
           if (R1 & 7 == 1) goto cb9H7; else goto cb9Hh;
       cb9H7: // global
           R1 = lvl26_rb6X6_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cb9Hh: // global
           I64[Sp] = block_cb9Ha_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto ub9IN; else goto cb9Hb;
       ub9IN: // global
           call _cb9Ha(R1) args: 0, res: 0, upd: 0;
       cb9Hb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Ha() //  [R1]
         { info_tbl: [(cb9Ha,
                       label: block_cb9Ha_info
                       rep:StackRep [True, True, True, True, True, False, True, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ha: // global
           I64[Sp + 40] = block_cb9Hf_info;
           R5 = I64[Sp + 72];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 40;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Hf() //  []
         { info_tbl: [(cb9Hf,
                       label: block_cb9Hf_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Hf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9HL() //  [R1]
         { info_tbl: [(cb9HL,
                       label: block_cb9HL_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9HL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9HT; else goto cb9HS;
       cb9HT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9HS: // global
           _cb9Gg::P64 = P64[Sp + 88];
           _sb7lY::I64 = I64[Sp + 80];
           _sb7m3::P64 = P64[Sp + 40];
           _sb7m7::P64 = P64[Sp + 56];
           _sb7mp::I64 = I64[Sp + 72];
           _sb7mq::P64 = P64[Sp + 64];
           _sb7mr::P64 = P64[Sp + 48];
           _sb7ms::I64 = I64[Sp + 24];
           _sb7mt::I64 = I64[Sp + 16];
           _sb7mu::I64 = I64[Sp + 8];
           (_sb7n1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sb7mp::I64 + _sb7mu::I64, I64[R1 + 7], _sb7lY::I64);
           call MO_Touch(_sb7mq::P64);
           if (_sb7lY::I64 == _sb7ms::I64 - _sb7mu::I64) goto cb9Ij; else goto cb9Ib;
       cb9Ij: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7mq::P64;
           P64[Hp - 32] = _sb7mr::P64;
           I64[Hp - 24] = _sb7mp::I64;
           I64[Hp - 16] = _sb7ms::I64;
           I64[Hp - 8] = _sb7mt::I64;
           I64[Hp] = _sb7mu::I64 + _sb7lY::I64;
           I64[Sp + 48] = block_cb9Ii_info;
           R2 = _sb7m3::P64;
           I64[Sp + 24] = stg_ap_ppv_info;
           P64[Sp + 40] = Hp - 47;
           Sp = Sp + 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cb9Ib: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7mq::P64;
           P64[Hp - 32] = _sb7mr::P64;
           I64[Hp - 24] = _sb7mp::I64;
           I64[Hp - 16] = _sb7ms::I64;
           I64[Hp - 8] = _sb7mt::I64;
           I64[Hp] = _sb7mu::I64 + _sb7lY::I64;
           call MO_WriteBarrier();
           P64[_sb7m7::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7m7::P64);
           R1 = _cb9Gg::P64;
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9Ii() //  [R1]
         { info_tbl: [(cb9Ii,
                       label: block_cb9Ii_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ii: // global
           _cb9Gg::P64 = P64[Sp + 40];
           _sb7m7::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7m7::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7m7::P64);
           R1 = _cb9Gg::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.241537819 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutBuf4_bytes" {
     GHC.IO.Handle.Text.hPutBuf4_bytes:
         I8[] [104,80,117,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.242255933 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf3_closure" {
     GHC.IO.Handle.Text.hPutBuf3_closure:
         const GHC.IO.Handle.Text.hPutBuf3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf3_entry() //  [R1]
         { info_tbl: [(cb9J3,
                       label: GHC.IO.Handle.Text.hPutBuf3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9J3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9J4; else goto cb9J5;
       cb9J4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9J5: // global
           (_cb9J0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9J0::I64 == 0) goto cb9J2; else goto cb9J1;
       cb9J2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9J1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9J0::I64;
           R2 = GHC.IO.Handle.Text.hPutBuf4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.244621723 UTC

[section ""data" . GHC.IO.Handle.Text.$whPutBuf'_closure" {
     GHC.IO.Handle.Text.$whPutBuf'_closure:
         const GHC.IO.Handle.Text.$whPutBuf'_info;
         const 0;
 },
 GHC.IO.Handle.Text.$whPutBuf'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9J7: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 act_sb7nl_entry() //  [R1, R2]
         { info_tbl: [(cb9Jo,
                       label: act_sb7nl_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Jo: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cb9Jp; else goto cb9Jq;
       cb9Jp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9Jq: // global
           I64[Sp - 32] = block_cb9Jl_info;
           _sb7nf::P64 = P64[R1 + 6];
           _sb7nh::P64 = P64[R1 + 14];
           _sb7nj::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb7nf::P64;
           P64[Sp - 16] = _sb7nh::P64;
           I64[Sp - 8] = _sb7nj::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9Ko; else goto cb9Jm;
       ub9Ko: // global
           call _cb9Jl(R1) args: 0, res: 0, upd: 0;
       cb9Jm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Jl() //  [R1]
         { info_tbl: [(cb9Jl,
                       label: block_cb9Jl_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Jl: // global
           I64[Sp - 8] = block_cb9Jt_info;
           R5 = P64[Sp + 16];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = R1;
           P64[Sp] = P64[R1 + 55];
           P64[Sp + 8] = P64[R1 + 47];
           P64[Sp + 16] = P64[R1 + 31];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$wbufWrite_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Jt() //  [R1]
         { info_tbl: [(cb9Jt,
                       label: block_cb9Jt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Jt: // global
           I64[Sp] = block_cb9Jv_info;
           _sb7nH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sb7nH::P64;
           if (R1 & 7 != 0) goto ub9Kp; else goto cb9Jy;
       ub9Kp: // global
           call _cb9Jv(R1) args: 0, res: 0, upd: 0;
       cb9Jy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Jv() //  [R1]
         { info_tbl: [(cb9Jv,
                       label: block_cb9Jv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Jv: // global
           if (R1 & 7 == 3) goto ub9Kl; else goto cb9JF;
       ub9Kl: // global
           Sp = Sp + 8;
           call _cb9Kf() args: 0, res: 0, upd: 0;
       cb9JF: // global
           _sb7nL::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cb9JC_info;
           R1 = _sb7nL::P64;
           if (R1 & 7 != 0) goto ub9Kq; else goto cb9JG;
       ub9Kq: // global
           call _cb9JC(R1) args: 0, res: 0, upd: 0;
       cb9JG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9JC() //  [R1]
         { info_tbl: [(cb9JC,
                       label: block_cb9JC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9JC: // global
           I64[Sp] = block_cb9JK_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ub9Ks; else goto cb9JM;
       ub9Ks: // global
           call _cb9JK(R1) args: 0, res: 0, upd: 0;
       cb9JM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9JK() //  [R1]
         { info_tbl: [(cb9JK,
                       label: block_cb9JK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9JK: // global
           if (R1 & 7 == 1) goto ub9Km; else goto cb9JX;
       ub9Km: // global
           Sp = Sp + 8;
           call _cb9Kf() args: 0, res: 0, upd: 0;
       cb9JX: // global
           _sb7nW::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cb9JV_info;
           R1 = _sb7nW::P64;
           if (R1 & 7 != 0) goto ub9Kt; else goto cb9JY;
       ub9Kt: // global
           call _cb9JV(R1) args: 0, res: 0, upd: 0;
       cb9JY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9JV() //  [R1]
         { info_tbl: [(cb9JV,
                       label: block_cb9JV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9JV: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ub9Kn; else goto cb9K8;
       ub9Kn: // global
           Sp = Sp + 8;
           call _cb9Kf() args: 0, res: 0, upd: 0;
       cb9K8: // global
           I64[Sp] = block_cb9K6_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb9Kf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Kf: // global
           R1 = P64[Sp];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9K6() //  [R1]
         { info_tbl: [(cb9K6,
                       label: block_cb9K6_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9K6: // global
           _sb7nu::P64 = P64[Sp + 16];
           _sb7nH::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7nu::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7nu::P64);
           R1 = _sb7nH::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub9KV_srtd" {
     ub9KV_srtd:
         const Sb7vQ_srt+8;
         const 62;
         const 3602879701896396803;
 },
 GHC.IO.Handle.Text.$whPutBuf'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb9Kz,
                       label: GHC.IO.Handle.Text.$whPutBuf'_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Kz: // global
           _sb7nh::P64 = R5;
           _sb7ng::I64 = R4;
           _sb7nf::P64 = R3;
           _sb7ne::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cb9KA; else goto cb9KB;
       cb9KB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb9KD; else goto cb9KC;
       cb9KD: // global
           HpAlloc = 32;
           goto cb9KA;
       cb9KA: // global
           R1 = GHC.IO.Handle.Text.$whPutBuf'_closure;
           P64[Sp - 32] = _sb7ne::P64;
           P64[Sp - 24] = _sb7nf::P64;
           I64[Sp - 16] = _sb7ng::I64;
           P64[Sp - 8] = _sb7nh::P64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cb9KC: // global
           if (_sb7ng::I64 == 0) goto cb9Ky; else goto cb9Kx;
       cb9Ky: // global
           Hp = Hp - 32;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9Kx: // global
           if (%MO_S_Ge_W64(_sb7ng::I64, 0)) goto cb9KG; else goto cb9KS;
       cb9KG: // global
           I64[Hp - 24] = act_sb7nl_info;
           P64[Hp - 16] = _sb7nf::P64;
           P64[Hp - 8] = _sb7nh::P64;
           I64[Hp] = _sb7ng::I64;
           I64[Sp - 16] = block_cb9KE_info;
           R1 = _sb7ne::P64;
           P64[Sp - 8] = Hp - 22;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub9KU; else goto cb9KH;
       ub9KU: // global
           call _cb9KE(R1) args: 0, res: 0, upd: 0;
       cb9KH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9KS: // global
           Hp = Hp - 32;
           R4 = _sb7ng::I64;
           R3 = GHC.IO.Handle.Text.hPutBuf3_closure;
           R2 = _sb7ne::P64;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub9KW_srtd" {
     ub9KW_srtd:
         const Sb7vQ_srt+16;
         const 61;
         const 1152921504606846977;
 },
 _cb9KE() //  [R1]
         { info_tbl: [(cb9KE,
                       label: block_cb9KE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9KE: // global
           _cb9Jg::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cb9KN; else goto cb9KR;
       cb9KN: // global
           R5 = _cb9Jg::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutBuf3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cb9KR: // global
           R5 = _cb9Jg::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutBuf3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.248557994 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf2_closure" {
     GHC.IO.Handle.Text.hPutBuf2_closure:
         const GHC.IO.Handle.Text.hPutBuf2_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb9L4,
                       label: GHC.IO.Handle.Text.hPutBuf2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9L4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb9L5; else goto cb9L6;
       cb9L5: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBuf2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9L6: // global
           I64[Sp - 32] = block_cb9L1_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9La; else goto cb9L2;
       ub9La: // global
           call _cb9L1(R1) args: 0, res: 0, upd: 0;
       cb9L2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9L1() //  [R1]
         { info_tbl: [(cb9L1,
                       label: block_cb9L1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9L1: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.250182955 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBufNonBlocking1_closure" {
     GHC.IO.Handle.Text.hPutBufNonBlocking1_closure:
         const GHC.IO.Handle.Text.hPutBufNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBufNonBlocking1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9Li,
                       label: GHC.IO.Handle.Text.hPutBufNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Li: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9Lj; else goto cb9Lk;
       cb9Lj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBufNonBlocking1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9Lk: // global
           I64[Sp - 24] = block_cb9Lf_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9Lo; else goto cb9Lg;
       ub9Lo: // global
           call _cb9Lf(R1) args: 0, res: 0, upd: 0;
       cb9Lg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Lf() //  [R1]
         { info_tbl: [(cb9Lf,
                       label: block_cb9Lf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Lf: // global
           R5 = GHC.Types.False_closure+1;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.251354829 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBufNonBlocking_closure" {
     GHC.IO.Handle.Text.hPutBufNonBlocking_closure:
         const GHC.IO.Handle.Text.hPutBufNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9Lt,
                       label: GHC.IO.Handle.Text.hPutBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Lt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutBufNonBlocking1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.252383762 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf1_closure" {
     GHC.IO.Handle.Text.hPutBuf1_closure:
         const GHC.IO.Handle.Text.hPutBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9LD,
                       label: GHC.IO.Handle.Text.hPutBuf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9LD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9LH; else goto cb9LI;
       cb9LH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBuf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9LI: // global
           I64[Sp - 24] = block_cb9LA_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9LM; else goto cb9LB;
       ub9LM: // global
           call _cb9LA(R1) args: 0, res: 0, upd: 0;
       cb9LB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9LA() //  [R1]
         { info_tbl: [(cb9LA,
                       label: block_cb9LA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9LA: // global
           _sb7ou::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cb9LG_info;
           R5 = GHC.Types.True_closure+2;
           R4 = I64[R1 + 7];
           R3 = _sb7ou::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9LG() //  []
         { info_tbl: [(cb9LG,
                       label: block_cb9LG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9LG: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.253714738 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf_closure" {
     GHC.IO.Handle.Text.hPutBuf_closure:
         const GHC.IO.Handle.Text.hPutBuf_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9LR,
                       label: GHC.IO.Handle.Text.hPutBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9LR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutBuf1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.254436584 UTC

[section ""cstring" . lvl31_rb6Xb_bytes" {
     lvl31_rb6Xb_bytes:
         I8[] [10]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.255137117 UTC

[section ""data" . lvl32_rb6Xc_closure" {
     lvl32_rb6Xc_closure:
         const lvl32_rb6Xc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl32_rb6Xc_entry() //  [R1]
         { info_tbl: [(cb9M0,
                       label: lvl32_rb6Xc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9M0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9M1; else goto cb9M2;
       cb9M1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9M2: // global
           (_cb9LX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9LX::I64 == 0) goto cb9LZ; else goto cb9LY;
       cb9LZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9LY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9LX::I64;
           R2 = lvl31_rb6Xb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.259794789 UTC

[section ""data" . GHC.IO.Handle.Text.$wwriteBlocks_closure" {
     GHC.IO.Handle.Text.$wwriteBlocks_closure:
         const GHC.IO.Handle.Text.$wwriteBlocks_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wwriteBlocks_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9M4: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sb7r5_entry() //  [R1]
         { info_tbl: [(cb9Mj,
                       label: sat_sb7r5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Mj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb9Mk; else goto cb9Ml;
       cb9Mk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9Ml: // global
           I64[Sp - 8] = block_cb9Mc_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9Ms; else goto cb9Md;
       ub9Ms: // global
           call _cb9Mc(R1) args: 0, res: 0, upd: 0;
       cb9Md: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Mc() //  [R1]
         { info_tbl: [(cb9Mc,
                       label: block_cb9Mc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Mc: // global
           if (R1 & 7 == 1) goto cb9Mg; else goto cb9Mh;
       cb9Mg: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9Mh: // global
           R1 = lvl32_rb6Xc_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7pr_entry() //  [R1, R2]
         { info_tbl: [(cb9MH,
                       label: sat_sb7pr_info
                       rep:HeapRep 2 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9MH: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb9MN; else goto cb9MO;
       cb9MN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9MO: // global
           I64[Sp - 48] = block_cb9ME_info;
           _sb7oH::P64 = P64[R1 + 6];
           _sb7oO::P64 = P64[R1 + 14];
           _sb7oG::I64 = I64[R1 + 22];
           _sb7oI::I64 = I64[R1 + 30];
           _sb7oM::I64 = I64[R1 + 38];
           R1 = R2;
           I64[Sp - 40] = _sb7oG::I64;
           P64[Sp - 32] = _sb7oH::P64;
           I64[Sp - 24] = _sb7oI::I64;
           I64[Sp - 16] = _sb7oM::I64;
           P64[Sp - 8] = _sb7oO::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ub9N9; else goto cb9MF;
       ub9N9: // global
           call _cb9ME(R1) args: 0, res: 0, upd: 0;
       cb9MF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9ME() //  [R1]
         { info_tbl: [(cb9ME,
                       label: block_cb9ME_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ME: // global
           _sb7oG::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cb9MK_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = _sb7oG::I64;
           R2 = R1;
           I64[Sp - 8] = 0;
           I64[Sp] = I64[Sp + 32];
           P64[Sp + 16] = P64[R1 + 79];
           P64[Sp + 32] = P64[R1 + 71];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb9MK() //  []
         { info_tbl: [(cb9MK,
                       label: block_cb9MK_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9MK: // global
           _sb7pd::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cb9MM_info;
           R1 = _sb7pd::P64;
           if (R1 & 7 != 0) goto ub9Na; else goto cb9MR;
       ub9Na: // global
           call _cb9MM(R1) args: 0, res: 0, upd: 0;
       cb9MR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9MM() //  [R1]
         { info_tbl: [(cb9MM,
                       label: block_cb9MM_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9MM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9MX; else goto cb9MW;
       cb9MX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9MW: // global
           if (I64[Sp + 16] == I64[R1 + 31]) goto cb9N2; else goto cb9N1;
       cb9N2: // global
           _sb7p1::P64 = P64[Sp + 8];
           _sb7po::P64 = P64[_sb7p1::P64 + 8];
           I64[Hp - 16] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sb7po::P64;
           call MO_WriteBarrier();
           P64[_sb7p1::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7p1::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9N1: // global
           Hp = Hp - 24;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7qq_entry() //  [R1, R2]
         { info_tbl: [(cb9NT,
                       label: sat_sb7qq_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9NT: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb9NZ; else goto cb9O0;
       cb9NZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9O0: // global
           I64[Sp - 40] = block_cb9NQ_info;
           _sb7oH::P64 = P64[R1 + 6];
           _sb7oG::I64 = I64[R1 + 14];
           _sb7oI::I64 = I64[R1 + 22];
           _sb7pN::I64 = I64[R1 + 30];
           R1 = R2;
           I64[Sp - 32] = _sb7oG::I64;
           P64[Sp - 24] = _sb7oH::P64;
           I64[Sp - 16] = _sb7oI::I64;
           I64[Sp - 8] = _sb7pN::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9Ok; else goto cb9NR;
       ub9Ok: // global
           call _cb9NQ(R1) args: 0, res: 0, upd: 0;
       cb9NR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9NQ() //  [R1]
         { info_tbl: [(cb9NQ,
                       label: block_cb9NQ_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9NQ: // global
           _sb7oG::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cb9NW_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = _sb7oG::I64;
           R2 = R1;
           I64[Sp - 8] = 0;
           I64[Sp] = I64[Sp + 32];
           P64[Sp + 16] = P64[R1 + 47];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb9NW() //  []
         { info_tbl: [(cb9NW,
                       label: block_cb9NW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9NW: // global
           _sb7qd::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_cb9NY_info;
           R1 = _sb7qd::P64;
           if (R1 & 7 != 0) goto ub9Ol; else goto cb9O3;
       ub9Ol: // global
           call _cb9NY(R1) args: 0, res: 0, upd: 0;
       cb9O3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9NY() //  [R1]
         { info_tbl: [(cb9NY,
                       label: block_cb9NY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9NY: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb9Og; else goto cb9Od;
       cb9Og: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9Od: // global
           I64[Sp] = block_cb9Ob_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cb9Ob() //  [R1]
         { info_tbl: [(cb9Ob,
                       label: block_cb9Ob_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ob: // global
           _sb7pX::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7pX::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7pX::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7r0_entry() //  [R1, R2]
         { info_tbl: [(cb9Ov,
                       label: sat_sb7r0_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ov: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb9Oz; else goto cb9OA;
       cb9Oz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9OA: // global
           I64[Sp - 40] = block_cb9Os_info;
           _sb7oH::P64 = P64[R1 + 6];
           _sb7oG::I64 = I64[R1 + 14];
           _sb7oI::I64 = I64[R1 + 22];
           _sb7pt::I64 = I64[R1 + 30];
           R1 = R2;
           I64[Sp - 32] = _sb7oG::I64;
           P64[Sp - 24] = _sb7oH::P64;
           I64[Sp - 16] = _sb7oI::I64;
           I64[Sp - 8] = _sb7pt::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ub9OE; else goto cb9Ot;
       ub9OE: // global
           call _cb9Os(R1) args: 0, res: 0, upd: 0;
       cb9Ot: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Os() //  [R1]
         { info_tbl: [(cb9Os,
                       label: block_cb9Os_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Os: // global
           _sb7pt::I64 = I64[Sp + 32];
           I64[Sp + 32] = block_cb9Oy_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = R1;
           I64[Sp + 16] = 0;
           I64[Sp + 24] = _sb7pt::I64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cb9Oy() //  []
         { info_tbl: [(cb9Oy,
                       label: block_cb9Oy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Oy: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$wwriteBlocks_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cb9OF,
                       label: GHC.IO.Handle.Text.$wwriteBlocks_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, True, False, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9OF: // global
           _sb7oG::I64 = R6;
           _sb7oF::P64 = R5;
           _sb7oE::P64 = R4;
           _sb7oD::P64 = R3;
           _sb7oC::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cb9OG; else goto cb9OH;
       cb9OH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9OJ; else goto cb9OI;
       cb9OJ: // global
           HpAlloc = 24;
           goto cb9OG;
       cb9OG: // global
           R1 = GHC.IO.Handle.Text.$wwriteBlocks_closure;
           P64[Sp - 40] = _sb7oC::P64;
           P64[Sp - 32] = _sb7oD::P64;
           P64[Sp - 24] = _sb7oE::P64;
           P64[Sp - 16] = _sb7oF::P64;
           I64[Sp - 8] = _sb7oG::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cb9OI: // global
           I64[Hp - 16] = sat_sb7r5_info;
           P64[Hp] = _sb7oE::P64;
           P64[Sp - 48] = _sb7oD::P64;
           P64[Sp - 40] = _sb7oF::P64;
           I64[Sp - 32] = _sb7oG::I64;
           I64[Sp - 24] = 0;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 16] = _sb7oC::P64;
           Sp = Sp - 48;
           call _cb9Nd() args: 0, res: 0, upd: 0;
     }
 },
 _cb9Nd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Nd: // global
           I64[Sp - 8] = block_cb9Ng_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9Q3; else goto cb9Nh;
       ub9Q3: // global
           call _cb9Ng(R1) args: 0, res: 0, upd: 0;
       cb9Nh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Ng() //  [R1]
         { info_tbl: [(cb9Ng,
                       label: block_cb9Ng_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ng: // global
           if (R1 & 7 == 1) goto cb9OS; else goto cb9P4;
       cb9OS: // global
           I64[Sp] = block_cb9OP_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ub9Q4; else goto cb9OT;
       ub9Q4: // global
           call _cb9OP(R1) args: 0, res: 0, upd: 0;
       cb9OT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9P4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb9P7; else goto cb9P6;
       cb9P7: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9P6: // global
           _sb7oI::I64 = I64[Sp + 64];
           _sb7pt::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_sb7pt::I64 + 1,
                            _sb7oI::I64)) goto cb9P9; else goto cb9PD;
       cb9P9: // global
           _sb7pB::P64 = P64[R1 + 6];
           _sb7pC::P64 = P64[R1 + 14];
           Hp = Hp - 40;
           I64[Sp] = block_cb9Ns_info;
           R1 = _sb7pB::P64;
           P64[Sp + 40] = _sb7pC::P64;
           if (R1 & 7 != 0) goto ub9Q5; else goto cb9Nt;
       ub9Q5: // global
           call _cb9Ns(R1) args: 0, res: 0, upd: 0;
       cb9Nt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9PD: // global
           I64[Hp - 32] = sat_sb7r0_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = _sb7oI::I64;
           I64[Hp] = _sb7pt::I64;
           I64[Sp] = block_cb9PC_info;
           R4 = Hp - 30;
           R3 = P64[Sp + 72];
           R2 = lvl2_rb6WE_closure;
           P64[Sp + 40] = R1;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9OP() //  [R1]
         { info_tbl: [(cb9OP,
                       label: block_cb9OP_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9OP: // global
           _sb7pt::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cb9OZ; else goto cb9P3;
       cb9OZ: // global
           I64[Sp + 48] = _sb7pt::I64;
           Sp = Sp + 24;
           call _cb9Mw() args: 0, res: 0, upd: 0;
       cb9P3: // global
           I64[Sp + 32] = _sb7pt::I64;
           P64[Sp + 40] = R1;
           P64[Sp + 48] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _cb9Nd() args: 0, res: 0, upd: 0;
     }
 },
 _cb9Mw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Mw: // global
           Hp = Hp + 72;
           _sb7oM::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cb9OM; else goto cb9OL;
       cb9OM: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cb9Mv_info;
           R1 = _sb7oM::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb9OL: // global
           I64[Hp - 64] = GHC.ForeignPtr.ForeignPtr_con_info;
           _sb7oH::P64 = P64[Sp + 32];
           P64[Hp - 56] = _sb7oH::P64;
           _sb7oG::I64 = I64[Sp];
           I64[Hp - 48] = _sb7oG::I64;
           I64[Hp - 40] = sat_sb7pr_info;
           P64[Hp - 32] = _sb7oH::P64;
           P64[Hp - 24] = Hp - 63;
           I64[Hp - 16] = _sb7oG::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _sb7oM::I64;
           R4 = Hp - 38;
           R3 = P64[Sp + 48];
           R2 = lvl2_rb6WE_closure;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb9Mv() //  [R1]
         { info_tbl: [(cb9Mv,
                       label: block_cb9Mv_info
                       rep:StackRep [True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Mv: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cb9Mw() args: 0, res: 0, upd: 0;
     }
 },
 _cb9Ns() //  [R1]
         { info_tbl: [(cb9Ns,
                       label: block_cb9Ns_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ns: // global
           _sb7pH::I64 = I64[R1 + 7];
           if (_sb7pH::I64 != 10) goto cb9Pc; else goto cb9Pq;
       cb9Pc: // global
           _sb7oH::P64 = P64[Sp + 56];
           _sb7pt::I64 = I64[Sp + 32];
           _sb7pv::P64 = P64[Sp + 48];
           _sb7pC::P64 = P64[Sp + 40];
           I32[I64[Sp + 24] + (_sb7pt::I64 << 2)] = %MO_UU_Conv_W64_W32(_sb7pH::I64);
           call MO_Touch(_sb7oH::P64);
           I64[Sp + 32] = _sb7pt::I64 + 1;
           P64[Sp + 40] = _sb7pC::P64;
           P64[Sp + 48] = _sb7pv::P64;
           Sp = Sp + 8;
           call _cb9Nd() args: 0, res: 0, upd: 0;
       cb9Pq: // global
           I64[Sp] = block_cb9Pd_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ub9Q6; else goto cb9Pr;
       ub9Q6: // global
           call _cb9Pd(R1) args: 0, res: 0, upd: 0;
       cb9Pr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Pd() //  [R1]
         { info_tbl: [(cb9Pd,
                       label: block_cb9Pd_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Pd: // global
           _sb7oD::P64 = P64[Sp + 8];
           _sb7oG::I64 = I64[Sp + 24];
           _sb7oH::P64 = P64[Sp + 56];
           _sb7pt::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cb9Px; else goto cb9PB;
       cb9Px: // global
           I32[_sb7oG::I64 + (_sb7pt::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb7oH::P64);
           _sb7pN::I64 = _sb7pt::I64 + 1;
           goto sb7pL;
       cb9PB: // global
           I32[_sb7oG::I64 + (_sb7pt::I64 << 2)] = 13 :: W32;
           call MO_Touch(_sb7oH::P64);
           _sb7qA::I64 = _sb7pt::I64 + 1;
           I32[_sb7oG::I64 + (_sb7qA::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb7oH::P64);
           _sb7pN::I64 = _sb7qA::I64 + 1;
           goto sb7pL;
       sb7pL: // global
           I64[Sp] = block_cb9NF_info;
           R1 = _sb7oD::P64;
           I64[Sp + 32] = _sb7pN::I64;
           if (R1 & 7 != 0) goto ub9Qc; else goto cb9NG;
       ub9Qc: // global
           call _cb9NF(R1) args: 0, res: 0, upd: 0;
       cb9NG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9NF() //  [R1]
         { info_tbl: [(cb9NF,
                       label: block_cb9NF_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9NF: // global
           _sb7pN::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cb9Pi; else goto cb9Pk;
       cb9Pi: // global
           I64[Sp + 32] = _sb7pN::I64;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cb9Nd() args: 0, res: 0, upd: 0;
       cb9Pk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb9Pn; else goto cb9Pm;
       cb9Pn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9Pm: // global
           I64[Hp - 32] = sat_sb7qq_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = I64[Sp + 64];
           I64[Hp] = _sb7pN::I64;
           I64[Sp] = block_cb9Pj_info;
           R4 = Hp - 30;
           R3 = P64[Sp + 72];
           R2 = lvl2_rb6WE_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Pj() //  []
         { info_tbl: [(cb9Pj,
                       label: block_cb9Pj_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Pj: // global
           I64[Sp + 32] = 0;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cb9Nd() args: 0, res: 0, upd: 0;
     }
 },
 _cb9PC() //  []
         { info_tbl: [(cb9PC,
                       label: block_cb9PC_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9PC: // global
           I64[Sp + 32] = 0;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cb9Nd() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.268045579 UTC

[section ""cstring" . lvl33_rb6Xd_bytes" {
     lvl33_rb6Xd_bytes:
         I8[] [110,111,32,98,117,102,102,101,114,33]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.268868949 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr4_closure" {
     GHC.IO.Handle.Text.hPutStr4_closure:
         const GHC.IO.Handle.Text.hPutStr4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr4_entry() //  [R1]
         { info_tbl: [(cb9Qn,
                       label: GHC.IO.Handle.Text.hPutStr4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Qn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9Qo; else goto cb9Qp;
       cb9Qo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9Qp: // global
           (_cb9Qi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9Qi::I64 == 0) goto cb9Qk; else goto cb9Qj;
       cb9Qk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9Qj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9Qi::I64;
           I64[Sp - 24] = block_cb9Ql_info;
           R2 = lvl33_rb6Xd_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb9Ql() //  [R1]
         { info_tbl: [(cb9Ql,
                       label: block_cb9Ql_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Ql: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.269966744 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr3_closure" {
     GHC.IO.Handle.Text.hPutStr3_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.NoBuffering_closure+1;
         const GHC.IO.Handle.Text.hPutStr4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.272089233 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr2_closure" {
     GHC.IO.Handle.Text.hPutStr2_closure:
         const GHC.IO.Handle.Text.hPutStr2_info;
         const 0;
 },
 sat_sb7s6_entry() //  [R1]
         { info_tbl: [(cb9QX,
                       label: sat_sb7s6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9QX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb9R6; else goto cb9R7;
       cb9R6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9R7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cb9QU_info;
           _sb7rw::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sb7rw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9Rd; else goto cb9QV;
       ub9Rd: // global
           call _cb9QU(R1) args: 0, res: 0, upd: 0;
       cb9QV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9QU() //  [R1]
         { info_tbl: [(cb9QU,
                       label: block_cb9QU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9QU: // global
           I64[Sp - 8] = block_cb9R0_info;
           _sb7rY::P64 = P64[R1 + 7];
           _sb7rX::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb7rY::P64;
           I64[Sp + 8] = _sb7rX::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9Rc; else goto cb9R1;
       ub9Rc: // global
           call _cb9R0(R1) args: 0, res: 0, upd: 0;
       cb9R1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9R0() //  [R1]
         { info_tbl: [(cb9R0,
                       label: block_cb9R0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9R0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9Rb; else goto cb9Ra;
       cb9Rb: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cb9Ra: // global
           _sb7s3::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = _sb7s3::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hPutStr2_entry() //  [R2]
         { info_tbl: [(cb9Re,
                       label: GHC.IO.Handle.Text.hPutStr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Re: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb9Rf; else goto cb9Rg;
       cb9Rf: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9Rg: // global
           I64[Sp - 8] = block_cb9Qx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9Sb; else goto cb9Qy;
       ub9Sb: // global
           call _cb9Qx(R1) args: 0, res: 0, upd: 0;
       cb9Qy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Qx() //  [R1]
         { info_tbl: [(cb9Qx,
                       label: block_cb9Qx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Qx: // global
           I64[Sp - 24] = block_cb9QC_info;
           _sb7ri::P64 = P64[R1 + 71];
           _sb7rj::P64 = P64[R1 + 79];
           _sb7ro::P64 = P64[R1 + 119];
           R1 = P64[R1 + 55];
           P64[Sp - 16] = _sb7rj::P64;
           P64[Sp - 8] = _sb7ro::P64;
           P64[Sp] = _sb7ri::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9S8; else goto cb9QD;
       ub9S8: // global
           call _cb9QC(R1) args: 0, res: 0, upd: 0;
       cb9QD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9QC() //  [R1]
         { info_tbl: [(cb9QC,
                       label: block_cb9QC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9QC: // global
           if (R1 & 7 == 1) goto cb9S2; else goto cb9Rk;
       cb9S2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9S5; else goto cb9S4;
       cb9S5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9S4: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Text.hPutStr3_closure+1;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9Rk: // global
           _sb7rt::P64 = P64[P64[Sp + 8] + 8];
           _sb7rw::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 8] = block_cb9QH_info;
           _sb7rq::P64 = R1;
           R1 = _sb7rt::P64;
           P64[Sp] = _sb7rw::P64;
           P64[Sp + 24] = _sb7rq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9S9; else goto cb9QI;
       ub9S9: // global
           call _cb9QH(R1) args: 0, res: 0, upd: 0;
       cb9QI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9QH() //  [R1]
         { info_tbl: [(cb9QH,
                       label: block_cb9QH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9QH: // global
           _sb7rw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cb9Rp; else goto cb9RV;
       cb9Rp: // global
           I64[Sp + 16] = block_cb9Rm_info;
           R1 = _sb7rw::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ub9Sa; else goto cb9Rq;
       ub9Sa: // global
           call _cb9Rm(R1) args: 0, res: 0, upd: 0;
       cb9Rq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9RV: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cb9RY; else goto cb9RX;
       cb9RY: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9RX: // global
           _sb7rj::P64 = P64[Sp + 16];
           _sb7ro::P64 = P64[Sp + 24];
           _sb7rq::P64 = P64[Sp + 32];
           _sb7rT::P64 = P64[R1 + 6];
           _sb7rU::P64 = P64[R1 + 14];
           call MO_WriteBarrier();
           P64[_sb7rj::P64 + 8] = _sb7rU::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7rj::P64);
           I64[Hp - 72] = sat_sb7s6_info;
           P64[Hp - 56] = _sb7rw::P64;
           P64[Hp - 48] = _sb7rT::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = _sb7rq::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = _sb7ro::P64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9Rm() //  [R1]
         { info_tbl: [(cb9Rm,
                       label: block_cb9Rm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Rm: // global
           _sb7rC::I64 = I64[R1 + 31];
           _sb7rF::I64 = _sb7rC::I64 << 2;
           if (%MO_S_Ge_W64(_sb7rF::I64, 0)) goto cb9RN; else goto cb9RS;
       cb9RN: // global
           I64[Sp - 16] = block_cb9RB_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _sb7rF::I64;
           I64[Sp] = _sb7rC::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cb9RS: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9RB() //  [R1]
         { info_tbl: [(cb9RB,
                       label: block_cb9RB_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9RB: // global
           I64[Sp] = block_cb9RD_info;
           _sb7rJ::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _sb7rJ::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9RD() //  [R1]
         { info_tbl: [(cb9RD,
                       label: block_cb9RD_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9RD: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cb9RR; else goto cb9RQ;
       cb9RR: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9RQ: // global
           I64[Hp - 120] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 112] = R1;
           P64[Hp - 104] = P64[Sp + 8];
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = Hp - 118;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 72] = R1 + 16;
           I64[Hp - 64] = I64[Sp + 16];
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = Hp - 95;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.276055556 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutStr6_bytes" {
     GHC.IO.Handle.Text.hPutStr6_bytes:
         I8[] [104,80,117,116,83,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.280248651 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr5_closure" {
     GHC.IO.Handle.Text.hPutStr5_closure:
         const GHC.IO.Handle.Text.hPutStr5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr5_entry() //  [R1]
         { info_tbl: [(cb9Si,
                       label: GHC.IO.Handle.Text.hPutStr5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Si: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9Sj; else goto cb9Sk;
       cb9Sj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9Sk: // global
           (_cb9Sf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9Sf::I64 == 0) goto cb9Sh; else goto cb9Sg;
       cb9Sh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9Sg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9Sf::I64;
           R2 = GHC.IO.Handle.Text.hPutStr6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.282520817 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr1_closure" {
     GHC.IO.Handle.Text.hPutStr1_closure:
         const GHC.IO.Handle.Text.hPutStr1_info;
         const 0;
 },
 section ""relreadonly" . ub9Uc_srtd" {
     ub9Uc_srtd:
         const Sb7vQ_srt+16;
         const 74;
         const 19;
         const 836;
 },
 GHC.IO.Handle.Text.hPutStr1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9Sy,
                       label: GHC.IO.Handle.Text.hPutStr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Sy: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cb9Sz; else goto cb9SA;
       cb9Sz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9SA: // global
           I64[Sp - 32] = block_cb9Sr_info;
           R1 = R2;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub9U1; else goto cb9Ss;
       ub9U1: // global
           call _cb9Sr(R1) args: 0, res: 0, upd: 0;
       cb9Ss: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9Ud_srtd" {
     ub9Ud_srtd:
         const Sb7vQ_srt+16;
         const 74;
         const 19;
         const 580;
 },
 _cb9Sr() //  [R1]
         { info_tbl: [(cb9Sr,
                       label: block_cb9Sr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Sr: // global
           if (R1 & 7 == 1) goto cb9Sv; else goto cb9Sw;
       cb9Sv: // global
           I64[Sp] = block_cb9To_info;
           R5 = GHC.IO.Handle.Text.hPutStr2_closure+2;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutStr5_closure;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 8, upd: 8;
       cb9Sw: // global
           I64[Sp] = block_cb9TG_info;
           R5 = GHC.IO.Handle.Text.hPutStr2_closure+2;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutStr5_closure;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9Ue_srtd" {
     ub9Ue_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb9To() //  [R1]
         { info_tbl: [(cb9To,
                       label: block_cb9To_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9To: // global
           I64[Sp] = block_cb9Tq_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9U5; else goto cb9Tr;
       ub9U5: // global
           call _cb9Tq(R1) args: 0, res: 0, upd: 0;
       cb9Tr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9Uf_srtd" {
     ub9Uf_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb9Tq() //  [R1]
         { info_tbl: [(cb9Tq,
                       label: block_cb9Tq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Tq: // global
           I64[Sp - 8] = block_cb9Tv_info;
           _sb7sL::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sb7sL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9U6; else goto cb9Tz;
       ub9U6: // global
           call _cb9Tv(R1) args: 0, res: 0, upd: 0;
       cb9Tz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9Ug_srtd" {
     ub9Ug_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb9Tv() //  [R1]
         { info_tbl: [(cb9Tv,
                       label: block_cb9Tv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Tv: // global
           _sb7si::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp - 8] = _sb7si::P64;
           Sp = Sp - 8;
           call _sb7se() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ub9Uh_srtd" {
     ub9Uh_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb9TG() //  [R1]
         { info_tbl: [(cb9TG,
                       label: block_cb9TG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9TG: // global
           I64[Sp] = block_cb9TI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9U8; else goto cb9TJ;
       ub9U8: // global
           call _cb9TI(R1) args: 0, res: 0, upd: 0;
       cb9TJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9Ui_srtd" {
     ub9Ui_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb9TI() //  [R1]
         { info_tbl: [(cb9TI,
                       label: block_cb9TI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9TI: // global
           I64[Sp - 8] = block_cb9TN_info;
           _sb7sX::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sb7sX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9U9; else goto cb9TR;
       ub9U9: // global
           call _cb9TN(R1) args: 0, res: 0, upd: 0;
       cb9TR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9Uj_srtd" {
     ub9Uj_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb9TN() //  [R1]
         { info_tbl: [(cb9TN,
                       label: block_cb9TN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9TN: // global
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call _sb7se() args: 0, res: 0, upd: 0;
     }
 },
 _sb7se() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7se: // global
           I64[Sp - 8] = block_cb9SE_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ub9Ub; else goto cb9SG;
       ub9Ub: // global
           call _cb9SE(R1) args: 0, res: 0, upd: 0;
       cb9SG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ub9Uk_srtd" {
     ub9Uk_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cb9SE() //  [R1]
         { info_tbl: [(cb9SE,
                       label: block_cb9SE_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9SE: // global
           _sb7sh::P64 = P64[Sp + 16];
           _cb9TW::P64 = R1 & 7;
           if (_cb9TW::P64 < 3) goto ub9TY; else goto cb9Tg;
       ub9TY: // global
           if (_cb9TW::P64 < 2) goto cb9SP; else goto cb9T6;
       cb9SP: // global
           I64[Sp + 24] = block_cb9SK_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.hPutStr7_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cb9T6: // global
           I64[Sp] = block_cb9T4_info;
           R1 = _sb7sh::P64;
           if (R1 & 7 != 0) goto ub9U2; else goto cb9T7;
       ub9U2: // global
           call _cb9T4(R1) args: 0, res: 0, upd: 0;
       cb9T7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9Tg: // global
           I64[Sp] = block_cb9Te_info;
           R1 = _sb7sh::P64;
           if (R1 & 7 != 0) goto ub9U3; else goto cb9Th;
       ub9U3: // global
           call _cb9Te(R1) args: 0, res: 0, upd: 0;
       cb9Th: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9SK() //  []
         { info_tbl: [(cb9SK,
                       label: block_cb9SK_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9SK: // global
           I64[Sp] = block_cb9SM_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto ub9U4; else goto cb9SR;
       ub9U4: // global
           call _cb9SM(R1) args: 0, res: 0, upd: 0;
       cb9SR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9SM() //  [R1]
         { info_tbl: [(cb9SM,
                       label: block_cb9SM_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9SM: // global
           if (R1 & 7 == 1) goto cb9SX; else goto cb9T1;
       cb9SX: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9T1: // global
           R3 = 10;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 _cb9T4() //  [R1]
         { info_tbl: [(cb9T4,
                       label: block_cb9T4_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9T4: // global
           R6 = I64[R1 + 23];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = GHC.Types.True_closure+2;
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           _sb7sb::P64 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 31];
           P64[Sp + 48] = _sb7sb::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 _cb9Te() //  [R1]
         { info_tbl: [(cb9Te,
                       label: block_cb9Te_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Te: // global
           R6 = I64[R1 + 23];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = GHC.Types.False_closure+1;
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           _sb7sb::P64 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 31];
           P64[Sp + 48] = _sb7sb::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.286749095 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr'_closure" {
     GHC.IO.Handle.Text.hPutStr'_closure:
         const GHC.IO.Handle.Text.hPutStr'_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr'_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9Up,
                       label: GHC.IO.Handle.Text.hPutStr'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Up: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.287605976 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr_closure" {
     GHC.IO.Handle.Text.hPutStr_closure:
         const GHC.IO.Handle.Text.hPutStr_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr_entry() //  [R2, R3]
         { info_tbl: [(cb9Uw,
                       label: GHC.IO.Handle.Text.hPutStr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Uw: // global
           R4 = GHC.Types.False_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.288424595 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStrLn_closure" {
     GHC.IO.Handle.Text.hPutStrLn_closure:
         const GHC.IO.Handle.Text.hPutStrLn_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStrLn_entry() //  [R2, R3]
         { info_tbl: [(cb9UD,
                       label: GHC.IO.Handle.Text.hPutStrLn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9UD: // global
           R4 = GHC.Types.True_closure+2;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.289151787 UTC

[section ""cstring" . GHC.IO.Handle.Text.hWaitForInput3_bytes" {
     GHC.IO.Handle.Text.hWaitForInput3_bytes:
         I8[] [104,87,97,105,116,70,111,114,73,110,112,117,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.289910388 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput2_closure" {
     GHC.IO.Handle.Text.hWaitForInput2_closure:
         const GHC.IO.Handle.Text.hWaitForInput2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hWaitForInput2_entry() //  [R1]
         { info_tbl: [(cb9UM,
                       label: GHC.IO.Handle.Text.hWaitForInput2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9UM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9UN; else goto cb9UO;
       cb9UN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9UO: // global
           (_cb9UJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cb9UJ::I64 == 0) goto cb9UL; else goto cb9UK;
       cb9UL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cb9UK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb9UJ::I64;
           R2 = GHC.IO.Handle.Text.hWaitForInput3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.293943421 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput1_closure" {
     GHC.IO.Handle.Text.hWaitForInput1_closure:
         const GHC.IO.Handle.Text.hWaitForInput1_info;
         const 0;
 },
 lvl34_sb7t8_entry() //  [R1]
         { info_tbl: [(cb9V0,
                       label: lvl34_sb7t8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9V0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9V1; else goto cb9V2;
       cb9V1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9V2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb9UX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9V7; else goto cb9UY;
       ub9V7: // global
           call _cb9UX(R1) args: 0, res: 0, upd: 0;
       cb9UY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cb9UX() //  [R1]
         { info_tbl: [(cb9UX,
                       label: block_cb9UX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9UX: // global
           R1 = I64[(%MO_S_Lt_W64(I64[R1 + 7],
                                  0) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7v9_entry() //  [R1, R2]
         { info_tbl: [(cb9Vg,
                       label: sat_sb7v9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Vg: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cb9Vk; else goto cb9Vl;
       cb9Vk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9Vl: // global
           I64[Sp - 24] = block_cb9Vd_info;
           _sb7t6::P64 = P64[R1 + 6];
           _sb7t8::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sb7t6::P64;
           P64[Sp - 8] = _sb7t8::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ub9Y2; else goto cb9Ve;
       ub9Y2: // global
           call _cb9Vd(R1) args: 0, res: 0, upd: 0;
       cb9Ve: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Vd() //  [R1]
         { info_tbl: [(cb9Vd,
                       label: block_cb9Vd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Vd: // global
           I64[Sp - 56] = block_cb9Vj_info;
           _sb7te::P64 = R1;
           _sb7tf::P64 = P64[R1 + 7];
           _sb7ti::P64 = P64[R1 + 31];
           _sb7tk::P64 = P64[R1 + 47];
           _sb7tm::P64 = P64[R1 + 63];
           _sb7tn::P64 = P64[R1 + 71];
           _sb7tq::P64 = P64[R1 + 95];
           R1 = P64[_sb7tn::P64 + 8];
           P64[Sp - 48] = _sb7tf::P64;
           P64[Sp - 40] = _sb7ti::P64;
           P64[Sp - 32] = _sb7tk::P64;
           P64[Sp - 24] = _sb7tm::P64;
           P64[Sp - 16] = _sb7tn::P64;
           P64[Sp - 8] = _sb7tq::P64;
           P64[Sp] = _sb7te::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ub9Y1; else goto cb9Vn;
       ub9Y1: // global
           call _cb9Vj(R1) args: 0, res: 0, upd: 0;
       cb9Vn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Vj() //  [R1]
         { info_tbl: [(cb9Vj,
                       label: block_cb9Vj_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Vj: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cb9Vz; else goto ub9XX;
       cb9Vz: // global
           I64[Sp] = block_cb9Vy_info;
           _sb7ty::P64 = R1;
           R1 = P64[Sp + 72];
           P64[Sp + 72] = _sb7ty::P64;
           if (R1 & 7 != 0) goto ub9Y3; else goto cb9VA;
       ub9Y3: // global
           call _cb9Vy(R1) args: 0, res: 0, upd: 0;
       cb9VA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ub9XX: // global
           Sp = Sp + 80;
           call _cb9VV() args: 0, res: 0, upd: 0;
     }
 },
 _cb9Vy() //  [R1]
         { info_tbl: [(cb9Vy,
                       label: block_cb9Vy_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Vy: // global
           if (R1 & 7 == 1) goto cb9Wv; else goto cb9XG;
       cb9Wv: // global
           _sb7tJ::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cb9VG_info;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _sb7tJ::P64;
           if (R1 & 7 != 0) goto ub9Y5; else goto cb9Ww;
       ub9Y5: // global
           call _cb9VG(R1) args: 0, res: 0, upd: 0;
       cb9Ww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cb9XG: // global
           I64[Sp + 32] = block_cb9XE_info;
           R3 = P64[Sp + 72];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9VG() //  [R1]
         { info_tbl: [(cb9VG,
                       label: block_cb9VG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9VG: // global
           if (R1 & 7 == 1) goto cb9WQ; else goto cb9Xq;
       cb9WQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9WT; else goto cb9WS;
       cb9WT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9WS: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sb7tJ::P64 = P64[Sp + 48];
           P64[Hp] = _sb7tJ::P64;
           _sb7tm::P64 = P64[Sp + 32];
           _sb7ty::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb7tm::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tm::P64);
           I64[Sp] = block_cb9WE_info;
           R3 = _sb7ty::P64;
           R2 = _sb7tJ::P64;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cb9Xq: // global
           I64[Sp] = block_cb9X3_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ub9Y6; else goto cb9X4;
       ub9Y6: // global
           call _cb9X3(R1) args: 0, res: 0, upd: 0;
       cb9X4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9WE() //  [R1]
         { info_tbl: [(cb9WE,
                       label: block_cb9WE_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9WE: // global
           I64[Sp] = block_cb9WG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9Ya; else goto cb9WH;
       ub9Ya: // global
           call _cb9WG(R1) args: 0, res: 0, upd: 0;
       cb9WH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9WG() //  [R1]
         { info_tbl: [(cb9WG,
                       label: block_cb9WG_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9WG: // global
           _sb7tk::P64 = P64[Sp + 24];
           _sb7uv::P64 = P64[R1 + 15];
           _sb7uw::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sb7tk::P64 + 8] = _sb7uv::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tk::P64);
           I64[Sp] = block_cb9WO_info;
           R1 = _sb7uw::P64;
           if (R1 & 7 != 0) goto ub9Yb; else goto cb9WW;
       ub9Yb: // global
           call _cb9WO(R1) args: 0, res: 0, upd: 0;
       cb9WW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9WO() //  [R1]
         { info_tbl: [(cb9WO,
                       label: block_cb9WO_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9WO: // global
           I64[Sp + 72] = I64[R1 + 23];
           P64[Sp + 48] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 24] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           Sp = Sp - 16;
           call _cb9VI() args: 0, res: 0, upd: 0;
     }
 },
 _cb9X3() //  [R1]
         { info_tbl: [(cb9X3,
                       label: block_cb9X3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9X3: // global
           I64[Sp - 16] = block_cb9X8_info;
           _sb7uH::P64 = P64[R1 + 7];
           _sb7uI::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sb7uI::P64;
           P64[Sp] = _sb7uH::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9X8() //  [R1]
         { info_tbl: [(cb9X8,
                       label: block_cb9X8_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9X8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9Xu; else goto cb9Xt;
       cb9Xu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9Xt: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sb7tJ::P64 = P64[Sp + 64];
           P64[Hp] = _sb7tJ::P64;
           _sb7tm::P64 = P64[Sp + 48];
           _sb7ty::P64 = P64[Sp + 88];
           _sb7uH::P64 = P64[Sp + 16];
           _sb7uI::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7tm::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tm::P64);
           I64[Sp + 16] = block_cb9Xe_info;
           R5 = _sb7ty::P64;
           R4 = _sb7tJ::P64;
           R3 = _sb7uI::P64;
           R2 = _sb7uH::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Xe() //  [R1]
         { info_tbl: [(cb9Xe,
                       label: block_cb9Xe_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Xe: // global
           I64[Sp] = block_cb9Xg_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9Yd; else goto cb9Xh;
       ub9Yd: // global
           call _cb9Xg(R1) args: 0, res: 0, upd: 0;
       cb9Xh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Xg() //  [R1]
         { info_tbl: [(cb9Xg,
                       label: block_cb9Xg_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Xg: // global
           _sb7tk::P64 = P64[Sp + 24];
           _sb7uV::P64 = P64[R1 + 7];
           _sb7uW::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sb7tk::P64 + 8] = _sb7uV::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tk::P64);
           I64[Sp] = block_cb9Xo_info;
           R1 = _sb7uW::P64;
           if (R1 & 7 != 0) goto ub9Ye; else goto cb9Xx;
       ub9Ye: // global
           call _cb9Xo(R1) args: 0, res: 0, upd: 0;
       cb9Xx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Xo() //  [R1]
         { info_tbl: [(cb9Xo,
                       label: block_cb9Xo_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Xo: // global
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 24] = I64[R1 + 31];
           P64[Sp + 32] = P64[R1 + 15];
           P64[Sp + 48] = P64[R1 + 7];
           I64[Sp + 72] = I64[R1 + 23];
           Sp = Sp - 16;
           call _cb9VI() args: 0, res: 0, upd: 0;
     }
 },
 _cb9VI() //  []
         { info_tbl: [(cb9VI,
                       label: block_cb9VI_info
                       rep:StackRep [True, True, False, False, True, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9VI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb9VN; else goto cb9VM;
       cb9VN: // global
           HpAlloc = 56;
           I64[Sp] = block_cb9VI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cb9VM: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 48];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 40];
           _sb7tQ::I64 = I64[Sp + 16];
           I64[Hp - 8] = _sb7tQ::I64;
           _sb7tR::I64 = I64[Sp + 8];
           I64[Hp] = _sb7tR::I64;
           _sb7t6::P64 = P64[Sp + 80];
           _sb7tf::P64 = P64[Sp + 24];
           _sb7ti::P64 = P64[Sp + 32];
           _sb7tn::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           if (_sb7tQ::I64 == _sb7tR::I64) goto cb9W1; else goto ub9Y0;
       cb9W1: // global
           I64[Sp + 48] = block_cb9VY_info;
           R2 = _sb7tf::P64;
           I64[Sp + 16] = stg_ap_pppv_info;
           P64[Sp + 24] = _sb7ti::P64;
           P64[Sp + 32] = GHC.Types.False_closure+1;
           P64[Sp + 40] = _sb7t6::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.ready_entry(R2) args: 40, res: 8, upd: 8;
       ub9Y0: // global
           Sp = Sp + 96;
           call _cb9VV() args: 0, res: 0, upd: 0;
     }
 },
 _cb9VY() //  [R1]
         { info_tbl: [(cb9VY,
                       label: block_cb9VY_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9VY: // global
           I64[Sp] = block_cb9W0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ub9Y8; else goto cb9W3;
       ub9Y8: // global
           call _cb9W0(R1) args: 0, res: 0, upd: 0;
       cb9W3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9W0() //  [R1]
         { info_tbl: [(cb9W0,
                       label: block_cb9W0_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9W0: // global
           if (R1 & 7 == 1) goto cb9W9; else goto cb9We;
       cb9W9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cb9We: // global
           _sb7u1::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_cb9Wc_info;
           R1 = _sb7u1::P64;
           if (R1 & 7 != 0) goto ub9Y9; else goto cb9Wf;
       ub9Y9: // global
           call _cb9Wc(R1) args: 0, res: 0, upd: 0;
       cb9Wf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9Wc() //  [R1]
         { info_tbl: [(cb9Wc,
                       label: block_cb9Wc_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Wc: // global
           _sb7u4::P64 = P64[R1 + 7];
           _sb7u3::I64 = I64[R1 + 23];
           _sb7u7::I64 = I64[R1 + 39];
           if (_sb7u7::I64 == I64[R1 + 47]) goto cb9Wr; else goto cb9Wn;
       cb9Wr: // global
           I64[Sp] = block_cb9Wq_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           I64[Sp + 24] = _sb7u7::I64;
           P64[Sp + 32] = _sb7u4::P64;
           I64[Sp + 40] = _sb7u3::I64;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cb9Wn: // global
           _sb7tn::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           call MO_Touch(_sb7u4::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9Wq() //  [R1]
         { info_tbl: [(cb9Wq,
                       label: block_cb9Wq_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Wq: // global
           _sb7tn::P64 = P64[Sp + 8];
           _sb7u3::I64 = I64[Sp + 40];
           _sb7u4::P64 = P64[Sp + 32];
           _sb7u7::I64 = I64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           call MO_Touch(_sb7u4::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9XE() //  [R1]
         { info_tbl: [(cb9XE,
                       label: block_cb9XE_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9XE: // global
           _sb7tn::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cb9VV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9VV: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ub9Yl_srtd" {
     ub9Yl_srtd:
         const Sb7vQ_srt+96;
         const 70;
         const 1;
         const 60;
 },
 GHC.IO.Handle.Text.hWaitForInput1_entry() //  [R2, R3]
         { info_tbl: [(cb9Yg,
                       label: GHC.IO.Handle.Text.hWaitForInput1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Yg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb9Yk; else goto cb9Yj;
       cb9Yk: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hWaitForInput1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9Yj: // global
           I64[Hp - 40] = lvl34_sb7t8_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sb7v9_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hWaitForInput2_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.30093974 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput_closure" {
     GHC.IO.Handle.Text.hWaitForInput_closure:
         const GHC.IO.Handle.Text.hWaitForInput_info;
         const 0;
 },
 GHC.IO.Handle.Text.hWaitForInput_entry() //  [R2, R3]
         { info_tbl: [(cb9Yq,
                       label: GHC.IO.Handle.Text.hWaitForInput_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Yq: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hWaitForInput1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.301654135 UTC

[section ""relreadonly" . Sb7vQ_srt" {
     Sb7vQ_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Text.$willegalBufferSize_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Text.$whPutChar_closure;
         const GHC.IO.Handle.Text.hPutChar2_closure;
         const GHC.IO.Handle.Text.hPutChar1_closure;
         const GHC.IO.Handle.Text.hPutStr7_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Text.hGetChar3_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Text.hGetChar2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.hGetChar6_closure;
         const GHC.IO.Handle.Text.hGetChar1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Text.hGetContents3_closure;
         const $wlvl_rb6WI_closure;
         const lvl6_rb6WK_closure;
         const lvl7_rb6WL_closure;
         const lvl9_rb6WN_closure;
         const lvl10_rb6WO_closure;
         const lvl4_rb6WH_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Text.hGetContents2_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
         const GHC.IO.Handle.Text.hGetContents1_closure;
         const GHC.IO.Handle.Internals.ioe_EOF1_closure;
         const GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure;
         const GHC.IO.Handle.Text.hGetLine3_closure;
         const GHC.IO.Handle.Text.hGetLine2_closure;
         const GHC.IO.Handle.Text.hGetLine4_closure;
         const GHC.IO.Handle.Text.hGetLine1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.Text.$wbufReadNBEmpty_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking2_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const lvl11_rb6WR_closure;
         const GHC.IO.Handle.Text.$whGetBufNonBlocking_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking1_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.Handle.Text.$whGetBufSome_closure;
         const lvl13_rb6WT_closure;
         const GHC.IO.Handle.Text.hGetBufSome1_closure;
         const GHC.IO.Handle.Text.hGetBuf2_closure;
         const GHC.IO.Handle.Text.hGetBuf4_closure;
         const GHC.IO.Handle.Text.$whGetBuf_closure;
         const GHC.IO.Handle.Text.hGetBuf5_closure;
         const GHC.IO.Handle.Text.hGetBuf1_closure;
         const GHC.Err.error_closure;
         const lvl24_rb6X4_closure;
         const lvl29_rb6X9_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const GHC.IO.Handle.Text.$wbufWrite_closure;
         const lvl26_rb6X6_closure;
         const lvl30_rb6Xa_closure;
         const GHC.IO.Handle.Text.$whPutBuf'_closure;
         const GHC.IO.Handle.Text.hPutBuf3_closure;
         const GHC.IO.Handle.Text.hPutBuf2_closure;
         const GHC.IO.Handle.Text.hPutBufNonBlocking1_closure;
         const GHC.IO.Handle.Text.hPutBuf1_closure;
         const lvl32_rb6Xc_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.Text.$wwriteBlocks_closure;
         const lvl2_rb6WE_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const GHC.IO.Handle.Text.hPutStr2_closure;
         const GHC.IO.Handle.Text.hPutStr3_closure;
         const GHC.IO.Handle.Text.hPutStr1_closure;
         const GHC.IO.Handle.Text.hPutStr5_closure;
         const GHC.IO.Handle.Text.$whPutChar_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Text.hWaitForInput1_closure;
         const GHC.IO.Handle.Text.hWaitForInput2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.302878516 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:03.304026063 UTC

[section ""cstring" . lvl_rb6WB_bytes" {
     lvl_rb6WB_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.306590272 UTC

[section ""data" . GHC.IO.Handle.Text.$willegalBufferSize_closure" {
     GHC.IO.Handle.Text.$willegalBufferSize_closure:
         const GHC.IO.Handle.Text.$willegalBufferSize_info;
         const 0;
 },
 sat_sb6Xn_entry() //  [R1]
         { info_tbl: [(cb9YN,
                       label: sat_sb6Xn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9YN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb9YO; else goto cb9YP;
       cb9YO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9YP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cb9YK_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb9YK() //  [R1, R2]
         { info_tbl: [(cb9YK,
                       label: block_cb9YK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9YK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9YS; else goto cb9YR;
       cb9YS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cb9YR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb6Xo_entry() //  [R1]
         { info_tbl: [(cb9YT,
                       label: sat_sb6Xo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9YT: // global
           _sb6Xo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb9YU; else goto cb9YV;
       cb9YV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9YX; else goto cb9YW;
       cb9YX: // global
           HpAlloc = 24;
           goto cb9YU;
       cb9YU: // global
           R1 = _sb6Xo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9YW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb6Xo::P64;
           _sb6Xh::I64 = I64[_sb6Xo::P64 + 16];
           I64[Hp - 16] = sat_sb6Xn_info;
           I64[Hp] = _sb6Xh::I64;
           R3 = Hp - 16;
           R2 = lvl_rb6WB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb6Xq_entry() //  [R1]
         { info_tbl: [(cb9Z0,
                       label: sat_sb6Xq_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Z0: // global
           _sb6Xq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb9Z1; else goto cb9Z2;
       cb9Z2: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cb9Z4; else goto cb9Z3;
       cb9Z4: // global
           HpAlloc = 96;
           goto cb9Z1;
       cb9Z1: // global
           R1 = _sb6Xq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb9Z3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb6Xq::P64;
           _sb6Xf::P64 = P64[_sb6Xq::P64 + 16];
           _sb6Xg::P64 = P64[_sb6Xq::P64 + 24];
           _sb6Xh::I64 = I64[_sb6Xq::P64 + 32];
           I64[Hp - 88] = sat_sb6Xo_info;
           I64[Hp - 72] = _sb6Xh::I64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sb6Xf::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = _sb6Xg::P64;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.$willegalBufferSize_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9Z5,
                       label: GHC.IO.Handle.Text.$willegalBufferSize_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9Z5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb9Z9; else goto cb9Z8;
       cb9Z9: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$willegalBufferSize_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb9Z8: // global
           I64[Hp - 32] = sat_sb6Xq_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.318360825 UTC

[section ""cstring" . GHC.IO.Handle.Text.$trModule4_bytes" {
     GHC.IO.Handle.Text.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.319942341 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule3_closure" {
     GHC.IO.Handle.Text.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Text.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.321835259 UTC

[section ""cstring" . GHC.IO.Handle.Text.$trModule2_bytes" {
     GHC.IO.Handle.Text.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,101,120,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.323391053 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule1_closure" {
     GHC.IO.Handle.Text.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Text.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.324975306 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule_closure" {
     GHC.IO.Handle.Text.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Text.$trModule3_closure+1;
         const GHC.IO.Handle.Text.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.329177798 UTC

[section ""data" . memcpy1_rb6WC_closure" {
     memcpy1_rb6WC_closure:
         const memcpy1_rb6WC_info;
 },
 memcpy1_rb6WC_entry() //  [R2, R3, R4]
         { info_tbl: [(cb9ZI,
                       label: memcpy1_rb6WC_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ZI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cba00; else goto cba01;
       cba00: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = memcpy1_rb6WC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cba01: // global
           I64[Sp - 24] = block_cb9ZF_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uba08; else goto cb9ZG;
       uba08: // global
           call _cb9ZF(R1) args: 0, res: 0, upd: 0;
       cb9ZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9ZF() //  [R1]
         { info_tbl: [(cb9ZF,
                       label: block_cb9ZF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ZF: // global
           I64[Sp] = block_cb9ZL_info;
           _sb6Xw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sb6Xw::I64;
           if (R1 & 7 != 0) goto uba07; else goto cb9ZM;
       uba07: // global
           call _cb9ZL(R1) args: 0, res: 0, upd: 0;
       cb9ZM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9ZL() //  [R1]
         { info_tbl: [(cb9ZL,
                       label: block_cb9ZL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ZL: // global
           I64[Sp] = block_cb9ZQ_info;
           _sb6Xy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb6Xy::I64;
           if (R1 & 7 != 0) goto uba09; else goto cb9ZR;
       uba09: // global
           call _cb9ZQ(R1) args: 0, res: 0, upd: 0;
       cb9ZR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9ZQ() //  [R1]
         { info_tbl: [(cb9ZQ,
                       label: block_cb9ZQ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9ZQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cba06; else goto cba05;
       cba06: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cba05: // global
           (_sb6XE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sb6XE::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.338486065 UTC

[section ""data" . GHC.IO.Handle.Text.memcpy_closure" {
     GHC.IO.Handle.Text.memcpy_closure:
         const GHC.IO.Handle.Text.memcpy_info;
 },
 GHC.IO.Handle.Text.memcpy_entry() //  [R2, R3, R4]
         { info_tbl: [(cba0w,
                       label: GHC.IO.Handle.Text.memcpy_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba0w: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call memcpy1_rb6WC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.344012876 UTC

[section ""data" . GHC.IO.Handle.Text.$wcommitBuffer'_closure" {
     GHC.IO.Handle.Text.$wcommitBuffer'_closure:
         const GHC.IO.Handle.Text.$wcommitBuffer'_info;
 },
 GHC.IO.Handle.Text.$wcommitBuffer'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba0E: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wcommitBuffer'_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$wcommitBuffer'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cba0L,
                       label: GHC.IO.Handle.Text.$wcommitBuffer'_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [True, False, True, True, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba0L: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cba0M; else goto cba0N;
       cba0M: // global
           R1 = GHC.IO.Handle.Text.$wcommitBuffer'_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cba0N: // global
           I64[Sp - 40] = block_cba0I_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           I64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uba3g; else goto cba0J;
       uba3g: // global
           call _cba0I(R1) args: 0, res: 0, upd: 0;
       cba0J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba0I() //  [R1]
         { info_tbl: [(cba0I,
                       label: block_cba0I_info
                       rep:StackRep [False, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba0I: // global
           I64[Sp - 40] = block_cba0Q_info;
           R6 = I64[Sp + 16];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 48];
           R2 = R1;
           I64[Sp - 56] = 0;
           I64[Sp - 48] = I64[Sp + 24];
           P64[Sp - 32] = P64[R1 + 31];
           P64[Sp - 24] = P64[R1 + 47];
           P64[Sp - 16] = P64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 79];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 56;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cba0Q() //  []
         { info_tbl: [(cba0Q,
                       label: block_cba0Q_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba0Q: // global
           I64[Sp] = block_cba0S_info;
           R1 = P64[Sp + 72];
           if (R1 & 7 != 0) goto uba3h; else goto cba0V;
       uba3h: // global
           call _cba0S(R1) args: 0, res: 0, upd: 0;
       cba0V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba0S() //  [R1]
         { info_tbl: [(cba0S,
                       label: block_cba0S_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba0S: // global
           if (R1 & 7 == 1) goto cba12; else goto cba1H;
       cba12: // global
           I64[Sp + 16] = block_cba0Z_info;
           R1 = P64[Sp + 80];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uba3i; else goto cba13;
       uba3i: // global
           call _cba0Z(R1) args: 0, res: 0, upd: 0;
       cba13: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cba1H: // global
           _sb6Yw::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cba1F_info;
           R1 = _sb6Yw::P64;
           if (R1 & 7 != 0) goto uba3j; else goto cba1I;
       uba3j: // global
           call _cba1F(R1) args: 0, res: 0, upd: 0;
       cba1I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba0Z() //  [R1]
         { info_tbl: [(cba0Z,
                       label: block_cba0Z_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba0Z: // global
           if (R1 & 7 == 1) goto cba19; else goto cba1h;
       cba19: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cba1c; else goto cba1b;
       cba1c: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cba1b: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cba1h: // global
           _sb6Yd::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cba1f_info;
           R1 = _sb6Yd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uba3k; else goto cba1i;
       uba3k: // global
           call _cba1f(R1) args: 0, res: 0, upd: 0;
       cba1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba1f() //  [R1]
         { info_tbl: [(cba1f,
                       label: block_cba1f_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba1f: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cba1o; else goto cba1n;
       cba1o: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cba1n: // global
           _sb6XG::I64 = I64[Sp + 64];
           _sb6XH::P64 = P64[Sp + 24];
           _sb6XI::I64 = I64[Sp + 32];
           _sb6XJ::I64 = I64[Sp + 40];
           if (_sb6XI::I64 == I64[R1 + 31]) goto cba1C; else goto cba1u;
       cba1C: // global
           _sb6XY::P64 = P64[Sp + 8];
           _sb6Yp::P64 = P64[_sb6XY::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           I64[Hp - 80] = _sb6XG::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sb6Yp::P64;
           call MO_WriteBarrier();
           P64[_sb6XY::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XY::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb6XH::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb6XG::I64;
           I64[Hp - 16] = _sb6XI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sb6XJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cba1u: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sb6XG::I64;
           I64[Hp - 64] = _sb6XI::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sb6XJ::I64;
           _cba1s::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cba1s::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cba1F() //  [R1]
         { info_tbl: [(cba1F,
                       label: block_cba1F_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba1F: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cba2B; else goto cba1X;
       cba2B: // global
           I64[Sp + 16] = block_cba2A_info;
           R1 = P64[Sp + 80];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uba3l; else goto cba2C;
       uba3l: // global
           call _cba2A(R1) args: 0, res: 0, upd: 0;
       cba2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cba1X: // global
           _sb6XS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cba1Q_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sb6XS::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cba2A() //  [R1]
         { info_tbl: [(cba2A,
                       label: block_cba2A_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba2A: // global
           if (R1 & 7 == 1) goto cba2I; else goto cba2Q;
       cba2I: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cba2L; else goto cba2K;
       cba2L: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cba2K: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cba2Q: // global
           _sb6Z8::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cba2O_info;
           R1 = _sb6Z8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uba3o; else goto cba2R;
       uba3o: // global
           call _cba2O(R1) args: 0, res: 0, upd: 0;
       cba2R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba2O() //  [R1]
         { info_tbl: [(cba2O,
                       label: block_cba2O_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba2O: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cba2X; else goto cba2W;
       cba2X: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cba2W: // global
           _sb6XG::I64 = I64[Sp + 64];
           _sb6XH::P64 = P64[Sp + 24];
           _sb6XI::I64 = I64[Sp + 32];
           _sb6XJ::I64 = I64[Sp + 40];
           if (_sb6XI::I64 == I64[R1 + 31]) goto cba3b; else goto cba33;
       cba3b: // global
           _sb6XY::P64 = P64[Sp + 8];
           _sb6Zk::P64 = P64[_sb6XY::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           I64[Hp - 80] = _sb6XG::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sb6Zk::P64;
           call MO_WriteBarrier();
           P64[_sb6XY::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XY::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb6XH::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb6XG::I64;
           I64[Hp - 16] = _sb6XI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sb6XJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cba33: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sb6XG::I64;
           I64[Hp - 64] = _sb6XI::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sb6XJ::I64;
           _cba31::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cba31::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cba1Q() //  [R1]
         { info_tbl: [(cba1Q,
                       label: block_cba1Q_info
                       rep:StackRep [False, False, False, True, False, True, True, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba1Q: // global
           _sb6XL::P64 = P64[Sp + 72];
           _sb6XU::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb6XU::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XU::P64);
           I64[Sp + 8] = block_cba1V_info;
           R1 = _sb6XL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uba3m; else goto cba1Z;
       uba3m: // global
           call _cba1V(R1) args: 0, res: 0, upd: 0;
       cba1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba1V() //  [R1]
         { info_tbl: [(cba1V,
                       label: block_cba1V_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba1V: // global
           if (R1 & 7 == 1) goto cba25; else goto cba2d;
       cba25: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cba28; else goto cba27;
       cba28: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cba27: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cba2d: // global
           _sb6YN::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cba2b_info;
           R1 = _sb6YN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uba3n; else goto cba2e;
       uba3n: // global
           call _cba2b(R1) args: 0, res: 0, upd: 0;
       cba2e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba2b() //  [R1]
         { info_tbl: [(cba2b,
                       label: block_cba2b_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba2b: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cba2k; else goto cba2j;
       cba2k: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cba2j: // global
           _sb6XG::I64 = I64[Sp + 64];
           _sb6XH::P64 = P64[Sp + 24];
           _sb6XI::I64 = I64[Sp + 32];
           _sb6XJ::I64 = I64[Sp + 40];
           if (_sb6XI::I64 == I64[R1 + 31]) goto cba2y; else goto cba2q;
       cba2y: // global
           _sb6XY::P64 = P64[Sp + 8];
           _sb6YZ::P64 = P64[_sb6XY::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           I64[Hp - 80] = _sb6XG::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sb6YZ::P64;
           call MO_WriteBarrier();
           P64[_sb6XY::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6XY::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb6XH::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sb6XG::I64;
           I64[Hp - 16] = _sb6XI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sb6XJ::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cba2q: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb6XH::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sb6XG::I64;
           I64[Hp - 64] = _sb6XI::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sb6XJ::I64;
           _cba2o::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cba2o::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.377876223 UTC

[section ""data" . GHC.IO.Handle.Text.commitBuffer'1_closure" {
     GHC.IO.Handle.Text.commitBuffer'1_closure:
         const GHC.IO.Handle.Text.commitBuffer'1_info;
 },
 GHC.IO.Handle.Text.commitBuffer'1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cba57,
                       label: GHC.IO.Handle.Text.commitBuffer'1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba57: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cba5g; else goto cba5h;
       cba5g: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.commitBuffer'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cba5h: // global
           I64[Sp - 40] = block_cba54_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uba5q; else goto cba55;
       uba5q: // global
           call _cba54(R1) args: 0, res: 0, upd: 0;
       cba55: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba54() //  [R1]
         { info_tbl: [(cba54,
                       label: block_cba54_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba54: // global
           I64[Sp - 8] = block_cba5a_info;
           _sb6Zy::P64 = P64[R1 + 7];
           _sb6Zx::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb6Zy::P64;
           I64[Sp + 8] = _sb6Zx::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uba5p; else goto cba5b;
       uba5p: // global
           call _cba5a(R1) args: 0, res: 0, upd: 0;
       cba5b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba5a() //  [R1]
         { info_tbl: [(cba5a,
                       label: block_cba5a_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba5a: // global
           I64[Sp] = block_cba5f_info;
           _sb6ZA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sb6ZA::I64;
           if (R1 & 7 != 0) goto uba5r; else goto cba5k;
       uba5r: // global
           call _cba5f(R1) args: 0, res: 0, upd: 0;
       cba5k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba5f() //  [R1]
         { info_tbl: [(cba5f,
                       label: block_cba5f_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba5f: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wcommitBuffer'_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.38741306 UTC

[section ""data" . GHC.IO.Handle.Text.commitBuffer'_closure" {
     GHC.IO.Handle.Text.commitBuffer'_closure:
         const GHC.IO.Handle.Text.commitBuffer'_info;
 },
 GHC.IO.Handle.Text.commitBuffer'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cba5N,
                       label: GHC.IO.Handle.Text.commitBuffer'_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba5N: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.commitBuffer'1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.390645751 UTC

[section ""cstring" . lvl1_rb6WD_bytes" {
     lvl1_rb6WD_bytes:
         I8[] [99,111,109,109,105,116,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.392485369 UTC

[section ""data" . lvl2_rb6WE_closure" {
     lvl2_rb6WE_closure:
         const lvl2_rb6WE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rb6WE_entry() //  [R1]
         { info_tbl: [(cba61,
                       label: lvl2_rb6WE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba61: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cba62; else goto cba63;
       cba62: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cba63: // global
           (_cba5Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cba5Y::I64 == 0) goto cba60; else goto cba5Z;
       cba60: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cba5Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cba5Y::I64;
           R2 = lvl1_rb6WD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.396227147 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutChar3_bytes" {
     GHC.IO.Handle.Text.hPutChar3_bytes:
         I8[] [104,80,117,116,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.398334571 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar2_closure" {
     GHC.IO.Handle.Text.hPutChar2_closure:
         const GHC.IO.Handle.Text.hPutChar2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar2_entry() //  [R1]
         { info_tbl: [(cba6i,
                       label: GHC.IO.Handle.Text.hPutChar2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba6i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cba6j; else goto cba6k;
       cba6j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cba6k: // global
           (_cba6f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cba6f::I64 == 0) goto cba6h; else goto cba6g;
       cba6h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cba6g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cba6f::I64;
           R2 = GHC.IO.Handle.Text.hPutChar3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.404172227 UTC

[section ""data" . GHC.IO.Handle.Text.$whPutChar_closure" {
     GHC.IO.Handle.Text.$whPutChar_closure:
         const GHC.IO.Handle.Text.$whPutChar_info;
         const 0;
 },
 act_sb6ZG_entry() //  [R1, R2]
         { info_tbl: [(cba6E,
                       label: act_sb6ZG_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba6E: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cba6F; else goto cba6G;
       cba6F: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cba6G: // global
           I64[Sp - 16] = block_cba6B_info;
           _sb6ZE::I64 = I64[R1 + 6];
           R1 = R2;
           I64[Sp - 8] = _sb6ZE::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uba8k; else goto cba6C;
       uba8k: // global
           call _cba6B(R1) args: 0, res: 0, upd: 0;
       cba6C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba6B() //  [R1]
         { info_tbl: [(cba6B,
                       label: block_cba6B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba6B: // global
           _sb702::P64 = P64[P64[R1 + 71] + 8];
           _sb703::I64 = I64[Sp + 8];
           if (_sb703::I64 == 10) goto cba7D; else goto cba6X;
       cba7D: // global
           I64[Sp - 40] = block_cba74_info;
           _sb6ZJ::P64 = R1;
           _sb6ZL::P64 = P64[R1 + 15];
           _sb6ZN::P64 = P64[R1 + 31];
           _sb6ZP::P64 = P64[R1 + 47];
           _sb6ZQ::P64 = P64[R1 + 55];
           R1 = P64[R1 + 119];
           P64[Sp - 32] = _sb6ZN::P64;
           P64[Sp - 24] = _sb6ZP::P64;
           P64[Sp - 16] = _sb6ZQ::P64;
           P64[Sp - 8] = _sb702::P64;
           P64[Sp] = _sb6ZL::P64;
           P64[Sp + 8] = _sb6ZJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uba8j; else goto cba7E;
       uba8j: // global
           call _cba74(R1) args: 0, res: 0, upd: 0;
       cba7E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cba6X: // global
           I64[Sp - 8] = block_cba6M_info;
           _sb6ZJ::P64 = R1;
           R1 = _sb702::P64;
           I64[Sp] = _sb703::I64;
           P64[Sp + 8] = _sb6ZJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uba8i; else goto cba6N;
       uba8i: // global
           call _cba6M(R1) args: 0, res: 0, upd: 0;
       cba6N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba74() //  [R1]
         { info_tbl: [(cba74,
                       label: block_cba74_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba74: // global
           _sb702::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cba7L; else goto cba7V;
       cba7L: // global
           I64[Sp] = block_cba7I_info;
           R1 = _sb702::P64;
           if (R1 & 7 != 0) goto uba8l; else goto cba7M;
       uba8l: // global
           call _cba7I(R1) args: 0, res: 0, upd: 0;
       cba7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cba7V: // global
           I64[Sp] = block_cba7T_info;
           R1 = _sb702::P64;
           if (R1 & 7 != 0) goto uba8m; else goto cba7W;
       uba8m: // global
           call _cba7T(R1) args: 0, res: 0, upd: 0;
       cba7W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba7I() //  [R1]
         { info_tbl: [(cba7I,
                       label: block_cba7I_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba7I: // global
           _sb70L::P64 = P64[R1 + 7];
           _sb70M::P64 = P64[R1 + 15];
           _sb70K::I64 = I64[R1 + 23];
           _sb70N::I64 = I64[R1 + 31];
           _sb70O::I64 = I64[R1 + 39];
           _sb70P::I64 = I64[R1 + 47];
           I32[_sb70K::I64 + (_sb70P::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb70L::P64);
           I64[Sp + 32] = _sb70K::I64;
           P64[Sp] = _sb70L::P64;
           P64[Sp - 32] = _sb70M::P64;
           I64[Sp - 24] = _sb70N::I64;
           I64[Sp - 16] = _sb70O::I64;
           I64[Sp - 8] = _sb70P::I64 + 1;
           Sp = Sp - 32;
           call _sb70h() args: 0, res: 0, upd: 0;
     }
 },
 _cba7T() //  [R1]
         { info_tbl: [(cba7T,
                       label: block_cba7T_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba7T: // global
           _sb70V::P64 = P64[R1 + 7];
           _sb70W::P64 = P64[R1 + 15];
           _sb70U::I64 = I64[R1 + 23];
           _sb70X::I64 = I64[R1 + 31];
           _sb70Y::I64 = I64[R1 + 39];
           _sb70Z::I64 = I64[R1 + 47];
           I32[_sb70U::I64 + (_sb70Z::I64 << 2)] = 13 :: W32;
           call MO_Touch(_sb70V::P64);
           _sb712::I64 = _sb70Z::I64 + 1;
           I32[_sb70U::I64 + (_sb712::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb70V::P64);
           P64[Sp - 32] = _sb70W::P64;
           I64[Sp - 24] = _sb70X::I64;
           I64[Sp - 16] = _sb70Y::I64;
           I64[Sp - 8] = _sb712::I64 + 1;
           P64[Sp] = _sb70V::P64;
           I64[Sp + 32] = _sb70U::I64;
           Sp = Sp - 32;
           call _sb70h() args: 0, res: 0, upd: 0;
     }
 },
 _sb70h() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb70h: // global
           _sb70k::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cba78_info;
           R6 = I64[Sp + 8];
           R5 = P64[Sp];
           R4 = _sb70k::P64;
           R3 = I64[Sp + 64];
           R2 = P64[Sp + 80];
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cba78() //  []
         { info_tbl: [(cba78,
                       label: block_cba78_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba78: // global
           I64[Sp] = block_cba7a_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto uba8n; else goto cba7d;
       uba8n: // global
           call _cba7a(R1) args: 0, res: 0, upd: 0;
       cba7d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba7a() //  [R1]
         { info_tbl: [(cba7a,
                       label: block_cba7a_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba7a: // global
           if (R1 & 7 == 2) goto cba7o; else goto uba8g;
       cba7o: // global
           _sb70v::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cba7m_info;
           R1 = _sb70v::P64;
           if (R1 & 7 != 0) goto uba8o; else goto cba7p;
       uba8o: // global
           call _cba7m(R1) args: 0, res: 0, upd: 0;
       cba7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uba8g: // global
           Sp = Sp + 56;
           call _cba7C() args: 0, res: 0, upd: 0;
     }
 },
 _cba7m() //  [R1]
         { info_tbl: [(cba7m,
                       label: block_cba7m_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba7m: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto uba8h; else goto cba7z;
       uba8h: // global
           Sp = Sp + 56;
           call _cba7C() args: 0, res: 0, upd: 0;
       cba7z: // global
           _sb6ZN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cba7x_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sb6ZN::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cba7x() //  [R1]
         { info_tbl: [(cba7x,
                       label: block_cba7x_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba7x: // global
           _sb6ZP::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb6ZP::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb6ZP::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cba7C() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba7C: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cba6M() //  [R1]
         { info_tbl: [(cba6M,
                       label: block_cba6M_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba6M: // global
           _sb6ZJ::P64 = P64[Sp + 16];
           _sb706::P64 = P64[R1 + 7];
           _sb707::P64 = P64[R1 + 15];
           _sb705::I64 = I64[R1 + 23];
           _sb708::I64 = I64[R1 + 31];
           _sb709::I64 = I64[R1 + 39];
           _sb70a::I64 = I64[R1 + 47];
           I32[_sb705::I64 + (_sb70a::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp + 8]);
           call MO_Touch(_sb706::P64);
           I64[Sp + 16] = block_cba6V_info;
           R6 = _sb708::I64;
           R5 = _sb707::P64;
           R4 = _sb706::P64;
           R3 = _sb705::I64;
           R2 = _sb6ZJ::P64;
           I64[Sp] = _sb709::I64;
           I64[Sp + 8] = _sb70a::I64 + 1;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cba6V() //  []
         { info_tbl: [(cba6V,
                       label: block_cba6V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba6V: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$whPutChar_entry() //  [R2, R3]
         { info_tbl: [(cba8A,
                       label: GHC.IO.Handle.Text.$whPutChar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba8A: // global
           _sb6ZE::I64 = R3;
           _sb6ZD::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cba8B; else goto cba8C;
       cba8C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cba8E; else goto cba8D;
       cba8E: // global
           HpAlloc = 16;
           goto cba8B;
       cba8B: // global
           R3 = _sb6ZE::I64;
           R2 = _sb6ZD::P64;
           R1 = GHC.IO.Handle.Text.$whPutChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cba8D: // global
           I64[Hp - 8] = act_sb6ZG_info;
           I64[Hp] = _sb6ZE::I64;
           I64[Sp - 16] = block_cba8t_info;
           R1 = _sb6ZD::P64;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uba8L; else goto cba8u;
       uba8L: // global
           call _cba8t(R1) args: 0, res: 0, upd: 0;
       cba8u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cba8t() //  [R1]
         { info_tbl: [(cba8t,
                       label: block_cba8t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba8t: // global
           _cba6w::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cba8x; else goto cba8y;
       cba8x: // global
           R5 = _cba6w::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutChar2_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cba8y: // global
           R5 = _cba6w::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutChar2_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.434495478 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar1_closure" {
     GHC.IO.Handle.Text.hPutChar1_closure:
         const GHC.IO.Handle.Text.hPutChar1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar1_entry() //  [R2, R3]
         { info_tbl: [(cbaa3,
                       label: GHC.IO.Handle.Text.hPutChar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaa3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbaa4; else goto cbaa5;
       cbaa4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutChar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbaa5: // global
           I64[Sp - 16] = block_cbaa0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubaa9; else goto cbaa1;
       ubaa9: // global
           call _cbaa0(R1) args: 0, res: 0, upd: 0;
       cbaa1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaa0() //  [R1]
         { info_tbl: [(cbaa0,
                       label: block_cbaa0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaa0: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.439797389 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar_closure" {
     GHC.IO.Handle.Text.hPutChar_closure:
         const GHC.IO.Handle.Text.hPutChar_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar_entry() //  [R2, R3]
         { info_tbl: [(cbaan,
                       label: GHC.IO.Handle.Text.hPutChar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaan: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutChar1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.443913038 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr7_closure" {
     GHC.IO.Handle.Text.hPutStr7_closure:
         const GHC.IO.Handle.Text.hPutStr7_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr7_entry() //  [R2, R3]
         { info_tbl: [(cbaaF,
                       label: GHC.IO.Handle.Text.hPutStr7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaaF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbaaG; else goto ubaaX;
       cbaaG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubaaX: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbaav() args: 0, res: 0, upd: 0;
     }
 },
 _cbaav() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaav: // global
           I64[Sp - 8] = block_cbaay_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaaZ; else goto cbaaz;
       ubaaZ: // global
           call _cbaay(R1) args: 0, res: 0, upd: 0;
       cbaaz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaay() //  [R1]
         { info_tbl: [(cbaay,
                       label: block_cbaay_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaay: // global
           if (R1 & 7 == 1) goto cbaaC; else goto cbaaD;
       cbaaC: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbaaD: // global
           I64[Sp] = block_cbaaN_info;
           _sb71m::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sb71m::P64;
           if (R1 & 7 != 0) goto ubab0; else goto cbaaP;
       ubab0: // global
           call _cbaaN(R1) args: 0, res: 0, upd: 0;
       cbaaP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaaN() //  [R1]
         { info_tbl: [(cbaaN,
                       label: block_cbaaN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaaN: // global
           I64[Sp] = block_cbaaT_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbaaT() //  []
         { info_tbl: [(cbaaT,
                       label: block_cbaaT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaaT: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cbaav() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.454960218 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar3_closure" {
     GHC.IO.Handle.Text.hGetChar3_closure:
         const GHC.IO.Handle.Text.hGetChar3_info;
         const 0;
 },
 sat_sb71H_entry() //  [R1]
         { info_tbl: [(cbabV,
                       label: sat_sb71H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbabV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbabW; else goto cbabX;
       cbabW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbabX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetChar3_entry() //  [R2]
         { info_tbl: [(cbabY,
                       label: GHC.IO.Handle.Text.hGetChar3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbabY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbabZ; else goto cbac0;
       cbabZ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetChar3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbac0: // global
           I64[Sp - 8] = block_cbabu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubacm; else goto cbabv;
       ubacm: // global
           call _cbabu(R1) args: 0, res: 0, upd: 0;
       cbabv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbabu() //  [R1]
         { info_tbl: [(cbabu,
                       label: block_cbabu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbabu: // global
           I64[Sp - 16] = block_cbabz_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbabz() //  [R1]
         { info_tbl: [(cbabz,
                       label: block_cbabz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbabz: // global
           I64[Sp] = block_cbabD_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbabD() //  [R1]
         { info_tbl: [(cbabD,
                       label: block_cbabD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbabD: // global
           if (R1 & 7 == 1) goto cbac6; else goto cbac8;
       cbac6: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbac8: // global
           I64[Sp + 16] = block_cbabI_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbabI() //  [R1]
         { info_tbl: [(cbabI,
                       label: block_cbabI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbabI: // global
           I64[Sp - 8] = block_cbabM_info;
           _sb71z::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sb71z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubacl; else goto cbabN;
       ubacl: // global
           call _cbabM(R1) args: 0, res: 0, upd: 0;
       cbabN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbabM() //  [R1]
         { info_tbl: [(cbabM,
                       label: block_cbabM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbabM: // global
           if (I32[I64[R1 - 1] + 20] == 4 :: W32) goto cbaci; else goto cbacb;
       cbaci: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbacb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbace; else goto cbacd;
       cbace: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbacd: // global
           I64[Hp - 16] = sat_sb71H_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.468847001 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetChar7_bytes" {
     GHC.IO.Handle.Text.hGetChar7_bytes:
         I8[] [104,71,101,116,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.470909525 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar6_closure" {
     GHC.IO.Handle.Text.hGetChar6_closure:
         const GHC.IO.Handle.Text.hGetChar6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar6_entry() //  [R1]
         { info_tbl: [(cbad0,
                       label: GHC.IO.Handle.Text.hGetChar6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbad0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbad1; else goto cbad2;
       cbad1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbad2: // global
           (_cbacX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbacX::I64 == 0) goto cbacZ; else goto cbacY;
       cbacZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbacY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbacX::I64;
           R2 = GHC.IO.Handle.Text.hGetChar7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.474705979 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar5_closure" {
     GHC.IO.Handle.Text.hGetChar5_closure:
         const GHC.Types.C#_con_info;
         const 13;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.47638276 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar4_closure" {
     GHC.IO.Handle.Text.hGetChar4_closure:
         const GHC.Types.C#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.482852424 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar2_closure" {
     GHC.IO.Handle.Text.hGetChar2_closure:
         const GHC.IO.Handle.Text.hGetChar2_info;
         const 0;
 },
 sat_sb72q_entry() //  [R1]
         { info_tbl: [(cbae0,
                       label: sat_sb72q_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbae0: // global
           _sb72q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbae1; else goto cbae2;
       cbae2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbae4; else goto cbae3;
       cbae4: // global
           HpAlloc = 56;
           goto cbae1;
       cbae1: // global
           R1 = _sb72q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbae3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb72q::P64;
           _sb72e::P64 = P64[_sb72q::P64 + 16];
           _sb72f::P64 = P64[_sb72q::P64 + 24];
           _sb72d::I64 = I64[_sb72q::P64 + 32];
           _sb72g::I64 = I64[_sb72q::P64 + 40];
           _sb72i::I64 = I64[_sb72q::P64 + 48];
           _sb72n::I64 = I64[_sb72q::P64 + 56];
           if (_sb72n::I64 == _sb72i::I64) goto cbadZ; else goto cbadY;
       cbadZ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbadY: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = _sb72n::I64;
           I64[Hp] = _sb72i::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb72v_entry() //  [R1]
         { info_tbl: [(cbaei,
                       label: sat_sb72v_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaei: // global
           _sb72v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbaej; else goto cbaek;
       cbaek: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbaem; else goto cbael;
       cbaem: // global
           HpAlloc = 56;
           goto cbaej;
       cbaej: // global
           R1 = _sb72v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbael: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb72v::P64;
           _sb72e::P64 = P64[_sb72v::P64 + 16];
           _sb72f::P64 = P64[_sb72v::P64 + 24];
           _sb72d::I64 = I64[_sb72v::P64 + 32];
           _sb72g::I64 = I64[_sb72v::P64 + 40];
           _sb72i::I64 = I64[_sb72v::P64 + 48];
           _sb72n::I64 = I64[_sb72v::P64 + 56];
           if (_sb72n::I64 == _sb72i::I64) goto cbaeh; else goto cbaeg;
       cbaeh: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbaeg: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72e::P64;
           P64[Hp - 32] = _sb72f::P64;
           I64[Hp - 24] = _sb72d::I64;
           I64[Hp - 16] = _sb72g::I64;
           I64[Hp - 8] = _sb72n::I64;
           I64[Hp] = _sb72i::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb72P_entry() //  [R1]
         { info_tbl: [(cbaeH,
                       label: sat_sb72P_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaeH: // global
           _sb72P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbaeI; else goto cbaeJ;
       cbaeJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbaeL; else goto cbaeK;
       cbaeL: // global
           HpAlloc = 56;
           goto cbaeI;
       cbaeI: // global
           R1 = _sb72P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaeK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb72P::P64;
           _sb72A::P64 = P64[_sb72P::P64 + 16];
           _sb72B::P64 = P64[_sb72P::P64 + 24];
           _sb72z::I64 = I64[_sb72P::P64 + 32];
           _sb72C::I64 = I64[_sb72P::P64 + 40];
           _sb72E::I64 = I64[_sb72P::P64 + 56];
           _sb72N::I64 = I64[_sb72P::P64 + 48] + 1;
           if (_sb72N::I64 == _sb72E::I64) goto cbaeV; else goto cbaeS;
       cbaeV: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72A::P64;
           P64[Hp - 32] = _sb72B::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbaeS: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72A::P64;
           P64[Hp - 32] = _sb72B::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = _sb72N::I64;
           I64[Hp] = _sb72E::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb73b_entry() //  [R1]
         { info_tbl: [(cbaf8,
                       label: sat_sb73b_info
                       rep:HeapRep 4 ptrs 4 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaf8: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbaf9; else goto cbafa;
       cbaf9: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbafa: // global
           _sb71K::P64 = P64[R1 + 7];
           _sb72F::P64 = P64[R1 + 31];
           _sb72D::I64 = I64[R1 + 55];
           _sb72S::I64 = I64[R1 + 63] - _sb72D::I64;
           if (_sb72S::I64 != 0) goto ubafR; else goto cbaf6;
       ubafR: // global
           if (_sb72S::I64 != 1) goto ubafT; else goto ubafS;
       ubafT: // global
           P64[Sp - 16] = _sb72F::P64;
           I64[Sp - 8] = _sb72S::I64;
           Sp = Sp - 16;
           call _cbafd() args: 0, res: 0, upd: 0;
       ubafS: // global
           P64[Sp - 64] = _sb71K::P64;
           I64[Sp - 56] = I64[R1 + 39];
           P64[Sp - 48] = P64[R1 + 15];
           P64[Sp - 40] = P64[R1 + 23];
           I64[Sp - 32] = I64[R1 + 47];
           I64[Sp - 24] = _sb72D::I64;
           P64[Sp - 16] = _sb72F::P64;
           I64[Sp - 8] = _sb72S::I64;
           Sp = Sp - 64;
           call _cbafw() args: 0, res: 0, upd: 0;
       cbaf6: // global
           I64[Sp - 8] = block_cbafn_info;
           R3 = _sb72F::P64;
           R2 = _sb71K::P64;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbafd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbafd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbafi; else goto cbafh;
       cbafi: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cbafc_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbafh: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbafc() //  [R1]
         { info_tbl: [(cbafc,
                       label: block_cbafc_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbafc: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cbafd() args: 0, res: 0, upd: 0;
     }
 },
 _cbafw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbafw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbafA; else goto cbafz;
       cbafA: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cbafv_info;
           R1 = I64[Sp + 56];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbafz: // global
           _sb71K::P64 = P64[Sp];
           _sb72z::I64 = I64[Sp + 8];
           _sb72A::P64 = P64[Sp + 16];
           _sb72B::P64 = P64[Sp + 24];
           _sb72C::I64 = I64[Sp + 32];
           _sb72F::P64 = P64[Sp + 48];
           _sb730::I64 = %MO_UU_Conv_W32_W64(I32[_sb72z::I64 + (I64[Sp + 40] << 2)]);
           call MO_Touch(_sb72A::P64);
           if (_sb730::I64 == 13) goto cbafN; else goto cbafG;
       cbafN: // global
           I32[_sb72z::I64] = 13 :: W32;
           call MO_Touch(_sb72A::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb72A::P64;
           P64[Hp - 32] = _sb72B::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 56] = block_cbafK_info;
           R3 = Hp - 47;
           R2 = _sb71K::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbafG: // global
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = _sb72F::P64;
           _cbafE::P64 = Hp - 46;
           Hp = Hp - 40;
           R1 = _cbafE::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbafv() //  [R1]
         { info_tbl: [(cbafv,
                       label: block_cbafv_info
                       rep:StackRep [False, True, False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbafv: // global
           I64[Sp + 64] = R1;
           Sp = Sp + 8;
           call _cbafw() args: 0, res: 0, upd: 0;
     }
 },
 _cbafK() //  [R1]
         { info_tbl: [(cbafK,
                       label: block_cbafK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbafK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbafQ; else goto cbafP;
       cbafQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbafP: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbafn() //  [R1]
         { info_tbl: [(cbafn,
                       label: block_cbafn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbafn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaft; else goto cbafs;
       cbaft: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbafs: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb73x_entry() //  [R1]
         { info_tbl: [(cbagj,
                       label: sat_sb73x_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbagj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbagk; else goto cbagl;
       cbagk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbagl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbagg_info;
           _sb72D::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb72D::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubagD; else goto cbagh;
       ubagD: // global
           call _cbagg(R1) args: 0, res: 0, upd: 0;
       cbagh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbagg() //  [R1]
         { info_tbl: [(cbagg,
                       label: block_cbagg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbagg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbagq; else goto cbagp;
       cbagq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbagp: // global
           _sb73q::P64 = P64[R1 + 7];
           _sb73r::P64 = P64[R1 + 15];
           _sb73p::I64 = I64[R1 + 23];
           _sb73s::I64 = I64[R1 + 31];
           _sb73u::I64 = I64[R1 + 47];
           _sb73v::I64 = I64[Sp + 8] + 1;
           if (_sb73v::I64 == _sb73u::I64) goto cbagC; else goto cbagz;
       cbagC: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb73q::P64;
           P64[Hp - 32] = _sb73r::P64;
           I64[Hp - 24] = _sb73p::I64;
           I64[Hp - 16] = _sb73s::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbagz: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb73q::P64;
           P64[Hp - 32] = _sb73r::P64;
           I64[Hp - 24] = _sb73p::I64;
           I64[Hp - 16] = _sb73s::I64;
           I64[Hp - 8] = _sb73v::I64;
           I64[Hp] = _sb73u::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetChar2_entry() //  [R2]
         { info_tbl: [(cbagE,
                       label: GHC.IO.Handle.Text.hGetChar2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbagE: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cbagF; else goto cbagG;
       cbagF: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetChar2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbagG: // global
           I64[Sp - 8] = block_cbadg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubai8; else goto cbadh;
       ubai8: // global
           call _cbadg(R1) args: 0, res: 0, upd: 0;
       cbadh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbadg() //  [R1]
         { info_tbl: [(cbadg,
                       label: block_cbadg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbadg: // global
           I64[Sp - 24] = block_cbadl_info;
           _sb71K::P64 = R1;
           _sb71T::P64 = P64[R1 + 71];
           _sb71Y::P64 = P64[R1 + 111];
           R1 = P64[_sb71T::P64 + 8];
           P64[Sp - 16] = _sb71T::P64;
           P64[Sp - 8] = _sb71Y::P64;
           P64[Sp] = _sb71K::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubai3; else goto cbadm;
       ubai3: // global
           call _cbadl(R1) args: 0, res: 0, upd: 0;
       cbadm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbadl() //  [R1]
         { info_tbl: [(cbadl,
                       label: block_cbadl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbadl: // global
           _sb729::I64 = I64[R1 + 39];
           _sb72a::I64 = I64[R1 + 47];
           if (_sb729::I64 == _sb72a::I64) goto cbahB; else goto cbahv;
       cbahB: // global
           I64[Sp] = block_cbahy_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbahv: // global
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sb729::I64;
           I64[Sp - 8] = _sb72a::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 40;
           call _sb72b() args: 0, res: 0, upd: 0;
     }
 },
 _cbahy() //  [R1]
         { info_tbl: [(cbahy,
                       label: block_cbahy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbahy: // global
           I64[Sp] = block_cbahA_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubai9; else goto cbahD;
       ubai9: // global
           call _cbahA(R1) args: 0, res: 0, upd: 0;
       cbahD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbahA() //  [R1]
         { info_tbl: [(cbahA,
                       label: block_cbahA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbahA: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sb72b() args: 0, res: 0, upd: 0;
     }
 },
 _sb72b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb72b: // global
           _sb71Y::P64 = P64[Sp + 56];
           _sb72h::I64 = I64[Sp + 24];
           _sb72l::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 40] + (_sb72h::I64 << 2)]);
           call MO_Touch(P64[Sp]);
           I64[Sp - 8] = block_cbadz_info;
           R1 = _sb71Y::P64;
           I64[Sp + 24] = _sb72h::I64 + 1;
           I64[Sp + 56] = _sb72l::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaib; else goto cbadA;
       ubaib: // global
           call _cbadz(R1) args: 0, res: 0, upd: 0;
       cbadA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbadz() //  [R1]
         { info_tbl: [(cbadz,
                       label: block_cbadz_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbadz: // global
           _sb71T::P64 = P64[Sp + 56];
           _sb72d::I64 = I64[Sp + 48];
           _sb72e::P64 = P64[Sp + 8];
           _sb72f::P64 = P64[Sp + 16];
           _sb72g::I64 = I64[Sp + 24];
           _sb72i::I64 = I64[Sp + 40];
           _sb72l::I64 = I64[Sp + 64];
           _sb72n::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cbagP; else goto cbagT;
       cbagP: // global
           Hp = Hp + 80;
           _sb72o::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbagW; else goto cbagR;
       cbagR: // global
           I64[Hp - 72] = sat_sb72q_info;
           P64[Hp - 56] = _sb72e::P64;
           P64[Hp - 48] = _sb72f::P64;
           I64[Hp - 40] = _sb72d::I64;
           I64[Hp - 32] = _sb72g::I64;
           I64[Hp - 24] = _sb72i::I64;
           I64[Hp - 16] = _sb72n::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 72;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sb72l::I64;
           R1 = Hp - 7;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbagT: // global
           Hp = Hp + 80;
           _sb72o::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbagW; else goto cbagV;
       cbagW: // global
           HpAlloc = 80;
           R1 = _sb72o::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbagV: // global
           if (_sb72l::I64 == 13) goto cbahr; else goto cbah2;
       cbahr: // global
           if (_sb72n::I64 == _sb72i::I64) goto cbahq; else goto cbahp;
       cbahq: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb72e::P64;
           P64[Hp - 56] = _sb72f::P64;
           I64[Hp - 48] = _sb72d::I64;
           I64[Hp - 40] = _sb72g::I64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           _cbadP::P64 = Hp - 71;
           Hp = Hp - 24;
           I64[Sp + 64] = _sb72d::I64;
           P64[Sp + 48] = _sb72e::P64;
           P64[Sp + 40] = _sb72f::P64;
           I64[Sp + 32] = _sb72g::I64;
           I64[Sp + 24] = 0;
           I64[Sp + 16] = 0;
           P64[Sp + 8] = _cbadP::P64;
           goto ubai6;
       cbahp: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb72e::P64;
           P64[Hp - 56] = _sb72f::P64;
           I64[Hp - 48] = _sb72d::I64;
           I64[Hp - 40] = _sb72g::I64;
           I64[Hp - 32] = _sb72n::I64;
           I64[Hp - 24] = _sb72i::I64;
           _cbadN::P64 = Hp - 71;
           Hp = Hp - 24;
           P64[Sp + 8] = _cbadN::P64;
           I64[Sp + 16] = _sb72i::I64;
           I64[Sp + 24] = _sb72n::I64;
           I64[Sp + 32] = _sb72g::I64;
           P64[Sp + 40] = _sb72f::P64;
           P64[Sp + 48] = _sb72e::P64;
           I64[Sp + 64] = _sb72d::I64;
           goto ubai6;
       ubai6: // global
           call _cbaer() args: 0, res: 0, upd: 0;
       cbah2: // global
           I64[Hp - 72] = sat_sb72v_info;
           P64[Hp - 56] = _sb72e::P64;
           P64[Hp - 48] = _sb72f::P64;
           I64[Hp - 40] = _sb72d::I64;
           I64[Hp - 32] = _sb72g::I64;
           I64[Hp - 24] = _sb72i::I64;
           I64[Hp - 16] = _sb72n::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 72;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sb72l::I64;
           R1 = Hp - 7;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbaer() //  []
         { info_tbl: [(cbaer,
                       label: block_cbaer_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaer: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbah5; else goto cbah4;
       cbah5: // global
           HpAlloc = 72;
           I64[Sp] = block_cbaer_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbah4: // global
           _sb72z::I64 = I64[Sp + 64];
           _sb72A::P64 = P64[Sp + 48];
           _sb72B::P64 = P64[Sp + 40];
           _sb72C::I64 = I64[Sp + 32];
           _sb72D::I64 = I64[Sp + 24];
           _sb72E::I64 = I64[Sp + 16];
           _sb72F::P64 = P64[Sp + 8];
           if (_sb72D::I64 == _sb72E::I64) goto cbahb; else goto cbaha;
       cbahb: // global
           I64[Hp - 64] = sat_sb73b_info;
           P64[Hp - 56] = P64[Sp + 72];
           P64[Hp - 48] = _sb72A::P64;
           P64[Hp - 40] = _sb72B::P64;
           P64[Hp - 32] = _sb72F::P64;
           I64[Hp - 24] = _sb72z::I64;
           I64[Hp - 16] = _sb72C::I64;
           I64[Hp - 8] = _sb72D::I64;
           I64[Hp] = _sb72E::I64;
           I64[Sp] = block_cbag0_info;
           R2 = GHC.IO.Handle.Text.hGetChar3_closure+2;
           R1 = Hp - 63;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cbaha: // global
           _sb71T::P64 = P64[Sp + 56];
           _sb72J::I64 = %MO_UU_Conv_W32_W64(I32[_sb72z::I64 + (_sb72D::I64 << 2)]);
           call MO_Touch(_sb72A::P64);
           if (_sb72J::I64 == 10) goto cbah8; else goto cbah7;
       cbah8: // global
           I64[Hp - 64] = sat_sb72P_info;
           P64[Hp - 48] = _sb72A::P64;
           P64[Hp - 40] = _sb72B::P64;
           I64[Hp - 32] = _sb72z::I64;
           I64[Hp - 24] = _sb72C::I64;
           I64[Hp - 16] = _sb72D::I64;
           I64[Hp - 8] = _sb72E::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           Hp = Hp - 8;
           R1 = GHC.IO.Handle.Text.hGetChar4_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbah7: // global
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = _sb72F::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           Hp = Hp - 72;
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbag0() //  [R1]
         { info_tbl: [(cbag0,
                       label: block_cbag0_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbag0: // global
           I64[Sp] = block_cbag2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubai7; else goto cbag3;
       ubai7: // global
           call _cbag2(R1) args: 0, res: 0, upd: 0;
       cbag3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbag2() //  [R1]
         { info_tbl: [(cbag2,
                       label: block_cbag2_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbag2: // global
           _sb71T::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cbahg; else goto cbahh;
       cbahg: // global
           _sb72F::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = _sb72F::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbahh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbahk; else goto cbahj;
       cbahk: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbahj: // global
           _sb72D::I64 = I64[Sp + 24];
           _sb73h::P64 = P64[R1 + 6];
           _sb73k::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 64] + (_sb72D::I64 << 2)]);
           call MO_Touch(P64[Sp + 48]);
           if (_sb73k::I64 == 10) goto cbahn; else goto cbahm;
       cbahn: // global
           I64[Hp - 24] = sat_sb73x_info;
           P64[Hp - 8] = _sb73h::P64;
           I64[Hp] = _sb72D::I64;
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           R1 = GHC.IO.Handle.Text.hGetChar4_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbahm: // global
           call MO_WriteBarrier();
           P64[_sb71T::P64 + 8] = _sb73h::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb71T::P64);
           Hp = Hp - 32;
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.534484639 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar1_closure" {
     GHC.IO.Handle.Text.hGetChar1_closure:
         const GHC.IO.Handle.Text.hGetChar1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar1_entry() //  [R2]
         { info_tbl: [(cbakp,
                       label: GHC.IO.Handle.Text.hGetChar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbakp: // global
           R4 = GHC.IO.Handle.Text.hGetChar2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetChar6_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.53794978 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar_closure" {
     GHC.IO.Handle.Text.hGetChar_closure:
         const GHC.IO.Handle.Text.hGetChar_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar_entry() //  [R2]
         { info_tbl: [(cbakA,
                       label: GHC.IO.Handle.Text.hGetChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbakA: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.541596484 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf3_closure" {
     GHC.IO.Handle.Text.hGetBuf3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.544646859 UTC

[section ""data" . $wunpack_nl_rb6WF_closure" {
     $wunpack_nl_rb6WF_closure:
         const $wunpack_nl_rb6WF_info;
 },
 $wunpack_nl_rb6WF_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbakJ: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2,
                                        R1) args: 8, res: 0, upd: 8;
     }
 },
 $wunpackRB_sb73Z_entry() //  [R1, R2, R3]
         { info_tbl: [(cbaly,
                       label: $wunpackRB_sb73Z_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaly: // global
           _sb741::I64 = R3;
           _sb740::P64 = R2;
           _sb73Z::P64 = R1;
           goto cbakV;
       cbakV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbalC; else goto cbalB;
       cbalC: // global
           HpAlloc = 40;
           R3 = _sb741::I64;
           R2 = _sb740::P64;
           R1 = _sb73Z::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbalB: // global
           _sb73Q::I64 = I64[_sb73Z::P64 + 13];
           if (%MO_S_Ge_W64(_sb741::I64,
                            _sb73Q::I64)) goto cbalw; else goto cbalx;
       cbalw: // global
           _sb73O::I64 = I64[_sb73Z::P64 + 5];
           _sb747::I64 = %MO_UU_Conv_W32_W64(I32[_sb73O::I64 + (_sb741::I64 << 2)]);
           if (_sb747::I64 != 10) goto cbalE; else goto cbalL;
       cbalE: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sb747::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sb740::P64;
           _sb741::I64 = _sb741::I64 - 1;
           _sb740::P64 = Hp - 14;
           goto cbakV;
       cbalL: // global
           if (%MO_S_Le_W64(_sb741::I64,
                            _sb73Q::I64)) goto cbalG; else goto cbalK;
       cbalG: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sb740::P64;
           _cbalf::P64 = Hp - 30;
           Hp = Hp - 16;
           _sb741::I64 = _sb741::I64 - 1;
           _sb740::P64 = _cbalf::P64;
           goto cbakV;
       cbalK: // global
           if (I32[_sb73O::I64 + ((_sb741::I64 + -1) << 2)] == 13 :: W32) goto cbalJ; else goto cbalI;
       cbalJ: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sb740::P64;
           _cbalu::P64 = Hp - 30;
           Hp = Hp - 16;
           _sb741::I64 = _sb741::I64 - 2;
           _sb740::P64 = _cbalu::P64;
           goto cbakV;
       cbalI: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sb740::P64;
           _cbalp::P64 = Hp - 30;
           Hp = Hp - 16;
           _sb741::I64 = _sb741::I64 - 1;
           _sb740::P64 = _cbalp::P64;
           goto cbakV;
       cbalx: // global
           Hp = Hp - 40;
           R1 = _sb740::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wunpack_nl_rb6WF_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbalP,
                       label: $wunpack_nl_rb6WF_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [True, False, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbalP: // global
           _sb73S::P64 = R6;
           _sb73R::I64 = R5;
           _sb73Q::I64 = R4;
           _sb73P::P64 = R3;
           _sb73O::I64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbalQ; else goto cbalR;
       cbalR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbalT; else goto cbalS;
       cbalT: // global
           HpAlloc = 24;
           goto cbalQ;
       cbalQ: // global
           R1 = $wunpack_nl_rb6WF_closure;
           I64[Sp - 40] = _sb73O::I64;
           P64[Sp - 32] = _sb73P::P64;
           I64[Sp - 24] = _sb73Q::I64;
           I64[Sp - 16] = _sb73R::I64;
           P64[Sp - 8] = _sb73S::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cbalS: // global
           if (_sb73Q::I64 == _sb73R::I64) goto cbalO; else goto cbalN;
       cbalO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb73S::P64;
           P64[Hp] = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbalN: // global
           _sb73Y::I64 = %MO_UU_Conv_W32_W64(I32[_sb73O::I64 + ((_sb73R::I64 + -1) << 2)]);
           I64[Hp - 16] = $wunpackRB_sb73Z_info;
           I64[Hp - 8] = _sb73O::I64;
           I64[Hp] = _sb73Q::I64;
           _cbakT::P64 = Hp - 13;
           if (_sb73Y::I64 == 13) goto cbaml; else goto cbam5;
       cbaml: // global
           I64[Sp - 24] = block_cbamd_info;
           R3 = _sb73R::I64 - 2;
           R2 = _sb73S::P64;
           R1 = _cbakT::P64;
           P64[Sp - 16] = _sb73P::P64;
           I64[Sp - 8] = _sb73R::I64;
           Sp = Sp - 24;
           call $wunpackRB_sb73Z_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       cbam5: // global
           I64[Sp - 24] = block_cbalZ_info;
           R3 = _sb73R::I64 - 1;
           R2 = _sb73S::P64;
           R1 = _cbakT::P64;
           P64[Sp - 16] = _sb73P::P64;
           I64[Sp - 8] = _sb73R::I64;
           Sp = Sp - 24;
           call $wunpackRB_sb73Z_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbamd() //  [R1]
         { info_tbl: [(cbamd,
                       label: block_cbamd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbamd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbamo; else goto cbamn;
       cbamo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbamn: // global
           _sb73R::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sb73R::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbalZ() //  [R1]
         { info_tbl: [(cbalZ,
                       label: block_cbalZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbalZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbam8; else goto cbam7;
       cbam8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbam7: // global
           _sb73R::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sb73R::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.558907605 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetContents4_bytes" {
     GHC.IO.Handle.Text.hGetContents4_bytes:
         I8[] [104,71,101,116,67,111,110,116,101,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.56084244 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents3_closure" {
     GHC.IO.Handle.Text.hGetContents3_closure:
         const GHC.IO.Handle.Text.hGetContents3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetContents3_entry() //  [R1]
         { info_tbl: [(cban2,
                       label: GHC.IO.Handle.Text.hGetContents3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cban2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cban3; else goto cban4;
       cban3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cban4: // global
           (_cbamZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbamZ::I64 == 0) goto cban1; else goto cban0;
       cban1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cban0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbamZ::I64;
           R2 = GHC.IO.Handle.Text.hGetContents4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.564755297 UTC

[section ""cstring" . lvl3_rb6WG_bytes" {
     lvl3_rb6WG_bytes:
         I8[] [13]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.566612356 UTC

[section ""data" . lvl4_rb6WH_closure" {
     lvl4_rb6WH_closure:
         const lvl4_rb6WH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rb6WH_entry() //  [R1]
         { info_tbl: [(cbanj,
                       label: lvl4_rb6WH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbanj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbank; else goto cbanl;
       cbank: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbanl: // global
           (_cbang::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbang::I64 == 0) goto cbani; else goto cbanh;
       cbani: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbanh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbang::I64;
           R2 = lvl3_rb6WG_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.571328416 UTC

[section ""data" . $wlvl_rb6WI_closure" {
     $wlvl_rb6WI_closure:
         const $wlvl_rb6WI_info;
         const 0;
 },
 sat_sb74S_entry() //  [R1]
         { info_tbl: [(cbanI,
                       label: sat_sb74S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbanI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbanJ; else goto cbanK;
       cbanJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbanK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbanB_info;
           _sb74E::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sb74E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubaob; else goto cbanC;
       ubaob: // global
           call _cbanB(R1) args: 0, res: 0, upd: 0;
       cbanC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbanB() //  [R1]
         { info_tbl: [(cbanB,
                       label: block_cbanB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbanB: // global
           if (R1 & 7 == 1) goto cbanF; else goto cbanG;
       cbanF: // global
           _sb74E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbanN_info;
           R1 = _sb74E::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubaoa; else goto cbanP;
       ubaoa: // global
           call _cbanN(R1) args: 0, res: 0, upd: 0;
       cbanP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbanG: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cbanN() //  [R1]
         { info_tbl: [(cbanN,
                       label: block_cbanN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbanN: // global
           if (R1 & 7 == 1) goto cbanV; else goto cbao2;
       cbanV: // global
           Hp = Hp + 16;
           _sb74L::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbao5; else goto cbanX;
       cbanX: // global
           _sb74M::P64 = P64[_sb74L::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sb74M::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbao2: // global
           Hp = Hp + 16;
           _sb74L::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbao5; else goto cbao4;
       cbao5: // global
           HpAlloc = 16;
           R1 = _sb74L::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbao4: // global
           _sb74O::P64 = P64[_sb74L::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sb74O::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rb6WI_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbaoe,
                       label: $wlvl_rb6WI_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaoe: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbaoi; else goto cbaoh;
       cbaoi: // global
           HpAlloc = 104;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_rb6WI_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbaoh: // global
           I64[Hp - 96] = sat_sb74S_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = Hp - 96;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.582479984 UTC

[section ""cstring" . lvl5_rb6WJ_bytes" {
     lvl5_rb6WJ_bytes:
         I8[] [100,101,108,97,121,101,100,32,114,101,97,100,32,111,110,32,99,108,111,115,101,100,32,104,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.584366702 UTC

[section ""data" . lvl6_rb6WK_closure" {
     lvl6_rb6WK_closure:
         const lvl6_rb6WK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rb6WK_entry() //  [R1]
         { info_tbl: [(cbaoQ,
                       label: lvl6_rb6WK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaoQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbaoR; else goto cbaoS;
       cbaoR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaoS: // global
           (_cbaoN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbaoN::I64 == 0) goto cbaoP; else goto cbaoO;
       cbaoP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbaoO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbaoN::I64;
           R2 = lvl5_rb6WJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.588522733 UTC

[section ""data" . lvl7_rb6WL_closure" {
     lvl7_rb6WL_closure:
         const lvl7_rb6WL_info;
         const 0;
 },
 sat_sb74Y_entry() //  [R1]
         { info_tbl: [(cbapa,
                       label: sat_sb74Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbapa: // global
           _sb74Y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbapb; else goto cbapc;
       cbapc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbape; else goto cbapd;
       cbape: // global
           HpAlloc = 72;
           goto cbapb;
       cbapb: // global
           R1 = _sb74Y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbapd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb74Y::P64;
           _sb74U::P64 = P64[_sb74Y::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sb74U::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = lvl6_rb6WK_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl7_rb6WL_entry() //  [R2]
         { info_tbl: [(cbapf,
                       label: lvl7_rb6WL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbapf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbapj; else goto cbapi;
       cbapj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl7_rb6WL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbapi: // global
           I64[Hp - 16] = sat_sb74Y_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.594649173 UTC

[section ""cstring" . lvl8_rb6WM_bytes" {
     lvl8_rb6WM_bytes:
         I8[] [105,108,108,101,103,97,108,32,104,97,110,100,108,101,32,116,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.596496108 UTC

[section ""data" . lvl9_rb6WN_closure" {
     lvl9_rb6WN_closure:
         const lvl9_rb6WN_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rb6WN_entry() //  [R1]
         { info_tbl: [(cbapA,
                       label: lvl9_rb6WN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbapA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbapB; else goto cbapC;
       cbapB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbapC: // global
           (_cbapx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbapx::I64 == 0) goto cbapz; else goto cbapy;
       cbapz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbapy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbapx::I64;
           R2 = lvl8_rb6WM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.600495996 UTC

[section ""data" . lvl10_rb6WO_closure" {
     lvl10_rb6WO_closure:
         const lvl10_rb6WO_info;
         const 0;
 },
 sat_sb753_entry() //  [R1]
         { info_tbl: [(cbapU,
                       label: sat_sb753_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbapU: // global
           _sb753::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbapV; else goto cbapW;
       cbapW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbapY; else goto cbapX;
       cbapY: // global
           HpAlloc = 72;
           goto cbapV;
       cbapV: // global
           R1 = _sb753::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbapX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb753::P64;
           _sb74Z::P64 = P64[_sb753::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sb74Z::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = lvl9_rb6WN_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl10_rb6WO_entry() //  [R2]
         { info_tbl: [(cbapZ,
                       label: lvl10_rb6WO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbapZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbaq3; else goto cbaq2;
       cbaq3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl10_rb6WO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbaq2: // global
           I64[Hp - 16] = sat_sb753_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.612177029 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents2_closure" {
     GHC.IO.Handle.Text.hGetContents2_closure:
         const GHC.IO.Handle.Text.hGetContents2_info;
         const 0;
 },
 sat_sb77n_entry() //  [R1]
         { info_tbl: [(cbarb,
                       label: sat_sb77n_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbarb: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbarc; else goto cbard;
       cbarc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbard: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbar9_info;
           _sb754::P64 = P64[R1 + 16];
           _sb75v::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sb754::P64;
           P64[Sp - 24] = _sb75v::P64;
           Sp = Sp - 40;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbar9() //  [R1]
         { info_tbl: [(cbar9,
                       label: block_cbar9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbar9: // global
           I64[Sp - 24] = block_cbarg_info;
           _sb77b::P64 = P64[R1 + 31];
           _sb77c::P64 = P64[R1 + 39];
           _sb77d::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _sb77c::P64;
           P64[Sp - 8] = _sb77d::P64;
           P64[Sp] = _sb77b::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubarF; else goto cbari;
       ubarF: // global
           call _cbarg(R1) args: 0, res: 0, upd: 0;
       cbari: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbarg() //  [R1]
         { info_tbl: [(cbarg,
                       label: block_cbarg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbarg: // global
           if (I32[I64[R1 - 1] + 20] == 4 :: W32) goto cbart; else goto cbaro;
       cbart: // global
           _sb75v::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbarr_info;
           R1 = _sb75v::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ubarG; else goto cbaru;
       ubarG: // global
           call _cbarr(R1) args: 0, res: 0, upd: 0;
       cbaru: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbaro: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 24];
           R3 = R1;
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call $wlvl_rb6WI_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 _cbarr() //  [R1]
         { info_tbl: [(cbarr,
                       label: block_cbarr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbarr: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbarD; else goto cbarC;
       cbarD: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbarC: // global
           R1 = lvl4_rb6WH_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb77p_entry() //  [R1, R2]
         { info_tbl: [(cbarH,
                       label: sat_sb77p_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbarH: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbarI; else goto cbarJ;
       cbarI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbarJ: // global
           I64[Sp - 32] = block_cbaqK_info;
           _sb754::P64 = P64[R1 + 6];
           _sb75b::P64 = P64[R1 + 14];
           _sb75v::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb754::P64;
           P64[Sp - 16] = _sb75b::P64;
           P64[Sp - 8] = _sb75v::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubarZ; else goto cbaqL;
       ubarZ: // global
           call _cbaqK(R1) args: 0, res: 0, upd: 0;
       cbaqL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaqK() //  [R1]
         { info_tbl: [(cbaqK,
                       label: block_cbaqK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaqK: // global
           I64[Sp - 16] = block_cbaqP_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbaqP() //  [R1]
         { info_tbl: [(cbaqP,
                       label: block_cbaqP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaqP: // global
           I64[Sp] = block_cbaqT_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbaqT() //  [R1]
         { info_tbl: [(cbaqT,
                       label: block_cbaqT_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaqT: // global
           if (R1 & 7 == 1) goto cbarP; else goto cbarS;
       cbarP: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbarS: // global
           I64[Sp] = block_cbaqY_info;
           R2 = P64[Sp + 32];
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbaqY() //  [R1]
         { info_tbl: [(cbaqY,
                       label: block_cbaqY_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaqY: // global
           I64[Sp] = block_cbar0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubarY; else goto cbar1;
       ubarY: // global
           call _cbar0(R1) args: 0, res: 0, upd: 0;
       cbar1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbar0() //  [R1]
         { info_tbl: [(cbar0,
                       label: block_cbar0_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbar0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbarW; else goto cbarV;
       cbarW: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbarV: // global
           _sb775::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_sb77n_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb775::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb76m_entry() //  [R1]
         { info_tbl: [(cbasX,
                       label: sat_sb76m_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbasX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbasY; else goto cbasZ;
       cbasY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbasZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cbasU_info;
           _sb75H::P64 = P64[R1 + 16];
           _sb75I::P64 = P64[R1 + 24];
           _sb75G::I64 = I64[R1 + 40];
           _sb75J::I64 = I64[R1 + 48];
           _sb75L::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _sb75G::I64;
           P64[Sp - 48] = _sb75H::P64;
           P64[Sp - 40] = _sb75I::P64;
           I64[Sp - 32] = _sb75J::I64;
           I64[Sp - 24] = _sb75L::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubate; else goto cbasV;
       ubate: // global
           call _cbasU(R1) args: 0, res: 0, upd: 0;
       cbasV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbasU() //  [R1]
         { info_tbl: [(cbasU,
                       label: block_cbasU_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbasU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbat4; else goto cbat3;
       cbat4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbat3: // global
           _sb75G::I64 = I64[Sp + 8];
           _sb75H::P64 = P64[Sp + 16];
           _sb75I::P64 = P64[Sp + 24];
           _sb75J::I64 = I64[Sp + 32];
           _sb75L::I64 = I64[Sp + 40];
           _sb76k::I64 = I64[R1 + 7];
           if (_sb76k::I64 == _sb75L::I64) goto cbatd; else goto cbata;
       cbatd: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb75H::P64;
           P64[Hp - 32] = _sb75I::P64;
           I64[Hp - 24] = _sb75G::I64;
           I64[Hp - 16] = _sb75J::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbata: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb75H::P64;
           P64[Hp - 32] = _sb75I::P64;
           I64[Hp - 24] = _sb75G::I64;
           I64[Hp - 16] = _sb75J::I64;
           I64[Hp - 8] = _sb76k::I64;
           I64[Hp] = _sb75L::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb76T_entry() //  [R1]
         { info_tbl: [(cbatf,
                       label: sat_sb76T_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbatf: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbatg; else goto cbath;
       cbatg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbath: // global
           I64[Sp - 40] = block_cbas5_info;
           _sb754::P64 = P64[R1 + 7];
           _sb75b::P64 = P64[R1 + 15];
           _sb75k::P64 = P64[R1 + 23];
           _sb75p::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sb754::P64;
           P64[Sp - 24] = _sb75b::P64;
           P64[Sp - 16] = _sb75k::P64;
           P64[Sp - 8] = _sb75p::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubavl; else goto cbas6;
       ubavl: // global
           call _cbas5(R1) args: 0, res: 0, upd: 0;
       cbas6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbas5() //  [R1]
         { info_tbl: [(cbas5,
                       label: block_cbas5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbas5: // global
           _sb75C::I64 = I64[R1 + 39];
           _sb75D::I64 = I64[R1 + 47];
           _sb76p::I64 = _sb75D::I64 - _sb75C::I64;
           if (_sb76p::I64 == 0) goto cbauh; else goto ubav3;
       cbauh: // global
           I64[Sp] = block_cbaue_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       ubav3: // global
           _sb75z::P64 = P64[R1 + 7];
           _sb75A::P64 = P64[R1 + 15];
           _sb75y::I64 = I64[R1 + 23];
           _sb75B::I64 = I64[R1 + 31];
           if (_sb76p::I64 != 1) goto ubav4; else goto cbauu;
       ubav4: // global
           P64[Sp - 40] = _sb75z::P64;
           P64[Sp - 32] = _sb75A::P64;
           I64[Sp - 24] = _sb75B::I64;
           I64[Sp - 16] = _sb75C::I64;
           I64[Sp - 8] = _sb75D::I64;
           I64[Sp] = _sb75y::I64;
           Sp = Sp - 40;
           call _cbauC() args: 0, res: 0, upd: 0;
       cbauu: // global
           I64[Sp - 48] = block_cbaut_info;
           R1 = P64[Sp + 32];
           P64[Sp - 40] = _sb75z::P64;
           P64[Sp - 32] = _sb75A::P64;
           I64[Sp - 24] = _sb75B::I64;
           I64[Sp - 16] = _sb75C::I64;
           I64[Sp - 8] = _sb75D::I64;
           I64[Sp] = _sb75y::I64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ubave; else goto cbauw;
       ubave: // global
           call _cbaut(R1) args: 0, res: 0, upd: 0;
       cbauw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaue() //  [R1]
         { info_tbl: [(cbaue,
                       label: block_cbaue_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaue: // global
           I64[Sp] = block_cbaug_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubavn; else goto cbauk;
       ubavn: // global
           call _cbaug(R1) args: 0, res: 0, upd: 0;
       cbauk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaug() //  [R1]
         { info_tbl: [(cbaug,
                       label: block_cbaug_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaug: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 32] = I64[R1 + 39];
           I64[Sp - 40] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _cbaut() //  [R1]
         { info_tbl: [(cbaut,
                       label: block_cbaut_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaut: // global
           if (R1 & 7 == 1) goto ubav5; else goto cbauD;
       ubav5: // global
           Sp = Sp + 8;
           call _cbauC() args: 0, res: 0, upd: 0;
       cbauD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbauI; else goto cbauH;
       cbauI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbauH: // global
           _sb75b::P64 = P64[Sp + 64];
           _sb75y::I64 = I64[Sp + 48];
           _sb75z::P64 = P64[Sp + 8];
           _sb75A::P64 = P64[Sp + 16];
           _sb75B::I64 = I64[Sp + 24];
           _sb75C::I64 = I64[Sp + 32];
           _sb75D::I64 = I64[Sp + 40];
           _sb76D::I64 = %MO_UU_Conv_W32_W64(I32[_sb75y::I64 + (_sb75C::I64 << 2)]);
           call MO_Touch(_sb75z::P64);
           if (_sb76D::I64 == 13) goto cbauU; else goto cbauM;
       cbauU: // global
           I32[_sb75y::I64] = 13 :: W32;
           call MO_Touch(_sb75z::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb75z::P64;
           P64[Hp - 32] = _sb75A::P64;
           I64[Hp - 24] = _sb75y::I64;
           I64[Hp - 16] = _sb75B::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 48] = block_cbauR_info;
           R3 = Hp - 47;
           R2 = _sb75b::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbauM: // global
           Hp = Hp - 56;
           I64[Sp + 8] = _sb75D::I64;
           I64[Sp + 16] = _sb75C::I64;
           I64[Sp + 24] = _sb75B::I64;
           P64[Sp + 32] = _sb75A::P64;
           P64[Sp + 40] = _sb75z::P64;
           I64[Sp + 48] = _sb75y::I64;
           Sp = Sp + 8;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _cbauC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbauC: // global
           I64[Sp + 40] = I64[Sp + 40];
           _sb75L::I64 = I64[Sp + 32];
           P64[Sp + 32] = P64[Sp];
           _sb75K::I64 = I64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 8] = _sb75K::I64;
           I64[Sp] = _sb75L::I64;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _cbauR() //  [R1]
         { info_tbl: [(cbauR,
                       label: block_cbauR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbauR: // global
           I64[Sp] = block_cbauT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubavs; else goto cbauW;
       ubavs: // global
           call _cbauT(R1) args: 0, res: 0, upd: 0;
       cbauW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbauT() //  [R1]
         { info_tbl: [(cbauT,
                       label: block_cbauT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbauT: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 32] = I64[R1 + 39];
           I64[Sp - 40] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sb75E() args: 0, res: 0, upd: 0;
     }
 },
 _sb75E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb75E: // global
           I64[Sp - 8] = block_cbasf_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.hGetContents2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbasf() //  [R1]
         { info_tbl: [(cbasf,
                       label: block_cbasf_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbasf: // global
           I64[Sp] = block_cbash_info;
           _sb75O::P64 = R1;
           R1 = P64[Sp + 80];
           P64[Sp + 80] = _sb75O::P64;
           if (R1 & 7 != 0) goto ubavg; else goto cbasi;
       ubavg: // global
           call _cbash(R1) args: 0, res: 0, upd: 0;
       cbasi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbash() //  [R1]
         { info_tbl: [(cbash,
                       label: block_cbash_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbash: // global
           _sb75G::I64 = I64[Sp + 48];
           _sb75H::P64 = P64[Sp + 40];
           _sb75K::I64 = I64[Sp + 16];
           _sb75L::I64 = I64[Sp + 8];
           _sb75O::P64 = P64[Sp + 80];
           if (R1 & 7 == 1) goto cbatm; else goto cbatW;
       cbatm: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbatp; else goto cbato;
       cbatp: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbato: // global
           if (_sb75K::I64 == _sb75L::I64) goto cbatQ; else goto cbatJ;
       cbatQ: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb75H::P64;
           P64[Hp - 56] = P64[Sp + 32];
           I64[Hp - 48] = _sb75G::I64;
           I64[Hp - 40] = I64[Sp + 24];
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           _sb75b::P64 = P64[Sp + 64];
           _sb75k::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb75k::P64 + 8] = Hp - 71;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb75k::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb75b::P64;
           P64[Hp] = _sb75O::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbatJ: // global
           Hp = Hp - 80;
           I64[Sp + 56] = _sb75L::I64 - 1;
           P64[Sp + 80] = _sb75O::P64;
           Sp = Sp + 8;
           call _cbasw() args: 0, res: 0, upd: 0;
       cbatW: // global
           I64[Sp] = block_cbasJ_info;
           R6 = _sb75O::P64;
           R5 = _sb75L::I64;
           R4 = _sb75K::I64;
           R3 = _sb75H::P64;
           R2 = _sb75G::I64;
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbasw() //  []
         { info_tbl: [(cbasw,
                       label: block_cbasw_info
                       rep:StackRep [True, True, False, False, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbasw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbatE; else goto cbatD;
       cbatE: // global
           HpAlloc = 40;
           I64[Sp] = block_cbasw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbatD: // global
           _sb75Z::P64 = P64[Sp + 72];
           _sb760::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_sb760::I64,
                            I64[Sp + 8])) goto cbatG; else goto cbatH;
       cbatG: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 40] + (_sb760::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sb75Z::P64;
           P64[Sp + 72] = Hp - 14;
           I64[Sp + 48] = _sb760::I64 - 1;
           call _cbasw() args: 0, res: 0, upd: 0;
       cbatH: // global
           Hp = Hp - 40;
           P64[Sp + 72] = _sb75Z::P64;
           Sp = Sp + 16;
           call _cbatr() args: 0, res: 0, upd: 0;
     }
 },
 _cbatr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbatr: // global
           Hp = Hp + 80;
           _sb75T::P64 = P64[Sp + 56];
           if (Hp > HpLim) (likely: False) goto cbatB; else goto cbatA;
       cbatB: // global
           HpAlloc = 80;
           I64[Sp - 8] = block_cbatq_info;
           R1 = _sb75T::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbatA: // global
           _sb75b::P64 = P64[Sp + 40];
           _sb75k::P64 = P64[Sp + 48];
           _sb75G::I64 = I64[Sp + 24];
           _sb75H::P64 = P64[Sp + 16];
           _sb75I::P64 = P64[Sp + 8];
           _sb75J::I64 = I64[Sp];
           call MO_Touch(_sb75H::P64);
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sb75H::P64;
           P64[Hp - 56] = _sb75I::P64;
           I64[Hp - 48] = _sb75G::I64;
           I64[Hp - 40] = _sb75J::I64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           call MO_WriteBarrier();
           P64[_sb75k::P64 + 8] = Hp - 71;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb75k::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb75b::P64;
           P64[Hp] = _sb75T::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbatq() //  [R1]
         { info_tbl: [(cbatq,
                       label: block_cbatq_info
                       rep:StackRep [True, False, False, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbatq: // global
           P64[Sp + 64] = R1;
           Sp = Sp + 8;
           call _cbatr() args: 0, res: 0, upd: 0;
     }
 },
 _cbasJ() //  [R1]
         { info_tbl: [(cbasJ,
                       label: block_cbasJ_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbasJ: // global
           I64[Sp] = block_cbasL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubavk; else goto cbasM;
       ubavk: // global
           call _cbasL(R1) args: 0, res: 0, upd: 0;
       cbasM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbasL() //  [R1]
         { info_tbl: [(cbasL,
                       label: block_cbasL_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbasL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbau0; else goto cbatZ;
       cbau0: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbatZ: // global
           _sb76h::P64 = P64[R1 + 7];
           _sb76i::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sb76m_info;
           P64[Hp - 64] = P64[Sp + 40];
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sb76i::P64;
           I64[Hp - 40] = I64[Sp + 48];
           I64[Hp - 32] = I64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           _sb75b::P64 = P64[Sp + 64];
           _sb75k::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb75k::P64 + 8] = Hp - 80;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb75k::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sb75b::P64;
           P64[Hp] = _sb76h::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 act_sb758_entry() //  [R1, R2]
         { info_tbl: [(cbavu,
                       label: act_sb758_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbavu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbavv; else goto cbavw;
       cbavv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbavw: // global
           I64[Sp - 16] = block_cbaqt_info;
           _sb754::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sb754::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubavM; else goto cbaqu;
       ubavM: // global
           call _cbaqt(R1) args: 0, res: 0, upd: 0;
       cbaqu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaqt() //  [R1]
         { info_tbl: [(cbaqt,
                       label: block_cbaqt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaqt: // global
           I64[Sp - 24] = block_cbaqy_info;
           _sb75b::P64 = R1;
           _sb75k::P64 = P64[R1 + 71];
           _sb75p::P64 = P64[R1 + 111];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sb75k::P64;
           P64[Sp - 8] = _sb75p::P64;
           P64[Sp] = _sb75b::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubavL; else goto cbaqz;
       ubavL: // global
           call _cbaqy(R1) args: 0, res: 0, upd: 0;
       cbaqz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaqy() //  [R1]
         { info_tbl: [(cbaqy,
                       label: block_cbaqy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaqy: // global
           _sb754::P64 = P64[Sp + 32];
           _cbavJ::P64 = R1 & 7;
           if (_cbavJ::P64 == 1) goto cbavE; else goto ubavK;
       cbavE: // global
           R2 = _sb754::P64;
           Sp = Sp + 40;
           call lvl7_rb6WL_entry(R2) args: 8, res: 0, upd: 8;
       ubavK: // global
           if (_cbavJ::P64 == 2) goto cbavF; else goto cbavB;
       cbavF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbavI; else goto cbavH;
       cbavI: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbavH: // global
           _sb75k::P64 = P64[Sp + 8];
           _sb75v::P64 = P64[_sb75k::P64 + 8];
           I64[Hp - 72] = sat_sb77p_info;
           P64[Hp - 64] = _sb754::P64;
           _sb75b::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sb75b::P64;
           P64[Hp - 48] = _sb75v::P64;
           I64[Hp - 40] = sat_sb76T_info;
           P64[Hp - 32] = _sb754::P64;
           P64[Hp - 24] = _sb75b::P64;
           P64[Hp - 16] = _sb75k::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sb75v::P64;
           R2 = Hp - 70;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       cbavB: // global
           R2 = _sb754::P64;
           Sp = Sp + 40;
           call lvl10_rb6WO_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb77w_entry() //  [R1]
         { info_tbl: [(cbavU,
                       label: sat_sb77w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbavU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbavV; else goto cbavW;
       cbavV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbavW: // global
           I64[Sp - 16] = block_cbaqm_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cbaqm() //  []
         { info_tbl: [(cbaqm,
                       label: block_cbaqm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaqm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbavZ; else goto cbavY;
       cbavZ: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbavY: // global
           I64[Hp - 8] = act_sb758_info;
           _sb754::P64 = P64[Sp + 8];
           P64[Hp] = _sb754::P64;
           I64[Sp] = block_cbavN_info;
           R1 = _sb754::P64;
           P64[Sp + 8] = Hp - 6;
           if (R1 & 7 != 0) goto ubaw6; else goto cbavO;
       ubaw6: // global
           call _cbavN(R1) args: 0, res: 0, upd: 0;
       cbavO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbavN() //  [R1]
         { info_tbl: [(cbavN,
                       label: block_cbavN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbavN: // global
           _cbaqo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbavR; else goto cbavS;
       cbavR: // global
           R5 = _cbaqo::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cbavS: // global
           R5 = _cbaqo::P64;
           R4 = P64[R1 + 14];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.hGetContents2_entry() //  [R2]
         { info_tbl: [(cbaw7,
                       label: GHC.IO.Handle.Text.hGetContents2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaw7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbawb; else goto cbawa;
       cbawb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetContents2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbawa: // global
           I64[Hp - 8] = sat_sb77w_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.685157855 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents1_closure" {
     GHC.IO.Handle.Text.hGetContents1_closure:
         const GHC.IO.Handle.Text.hGetContents1_info;
         const 0;
 },
 sat_sb77V_entry() //  [R1]
         { info_tbl: [(cbazu,
                       label: sat_sb77V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbazu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbazy; else goto cbazz;
       cbazy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbazz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbazr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubazD; else goto cbazs;
       ubazD: // global
           call _cbazr(R1) args: 0, res: 0, upd: 0;
       cbazs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbazr() //  [R1]
         { info_tbl: [(cbazr,
                       label: block_cbazr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbazr: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbazC; else goto cbazB;
       cbazC: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbazB: // global
           _sb77F::P64 = P64[R1 + 7];
           _sb77G::P64 = P64[R1 + 15];
           _sb77H::P64 = P64[R1 + 23];
           _sb77I::P64 = P64[R1 + 31];
           _sb77K::P64 = P64[R1 + 47];
           _sb77L::P64 = P64[R1 + 55];
           _sb77M::P64 = P64[R1 + 63];
           _sb77N::P64 = P64[R1 + 71];
           _sb77O::P64 = P64[R1 + 79];
           _sb77P::P64 = P64[R1 + 87];
           _sb77Q::P64 = P64[R1 + 95];
           _sb77R::P64 = P64[R1 + 103];
           _sb77S::P64 = P64[R1 + 111];
           _sb77T::P64 = P64[R1 + 119];
           _sb77U::P64 = P64[R1 + 127];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sb77F::P64;
           P64[Hp - 112] = _sb77G::P64;
           P64[Hp - 104] = _sb77H::P64;
           P64[Hp - 96] = _sb77I::P64;
           P64[Hp - 88] = GHC.IO.Handle.Types.SemiClosedHandle_closure+2;
           P64[Hp - 80] = _sb77K::P64;
           P64[Hp - 72] = _sb77L::P64;
           P64[Hp - 64] = _sb77M::P64;
           P64[Hp - 56] = _sb77N::P64;
           P64[Hp - 48] = _sb77O::P64;
           P64[Hp - 40] = _sb77P::P64;
           P64[Hp - 32] = _sb77Q::P64;
           P64[Hp - 24] = _sb77R::P64;
           P64[Hp - 16] = _sb77S::P64;
           P64[Hp - 8] = _sb77T::P64;
           P64[Hp] = _sb77U::P64;
           R1 = Hp - 127;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb77X_entry() //  [R1, R2]
         { info_tbl: [(cbazF,
                       label: sat_sb77X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbazF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbazG; else goto cbazH;
       cbazG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbazH: // global
           I64[Sp - 16] = block_cbazl_info;
           _sb77z::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sb77z::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Text.hGetContents2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbazl() //  [R1]
         { info_tbl: [(cbazl,
                       label: block_cbazl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbazl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbazK; else goto cbazJ;
       cbazK: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbazJ: // global
           I64[Hp - 40] = sat_sb77V_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.hGetContents1_entry() //  [R2]
         { info_tbl: [(cbazL,
                       label: GHC.IO.Handle.Text.hGetContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbazL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbazP; else goto cbazO;
       cbazP: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbazO: // global
           I64[Hp - 8] = sat_sb77X_info;
           P64[Hp] = R2;
           R4 = Hp - 6;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.698033873 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents_closure" {
     GHC.IO.Handle.Text.hGetContents_closure:
         const GHC.IO.Handle.Text.hGetContents_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetContents_entry() //  [R2]
         { info_tbl: [(cbaAh,
                       label: GHC.IO.Handle.Text.hGetContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaAh: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.701690719 UTC

[section ""data" . go_rb6WP_closure" {
     go_rb6WP_closure:
         const go_rb6WP_info;
 },
 sat_sb782_entry() //  [R1]
         { info_tbl: [(cbaAC,
                       label: sat_sb782_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaAC: // global
           R2 = P64[R1 + 16];
           call go_rb6WP_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 go_rb6WP_entry() //  [R2]
         { info_tbl: [(cbaAJ,
                       label: go_rb6WP_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaAJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbaAK; else goto cbaAL;
       cbaAK: // global
           R2 = R2;
           R1 = go_rb6WP_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbaAL: // global
           I64[Sp - 8] = block_cbaAs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaAR; else goto cbaAt;
       ubaAR: // global
           call _cbaAs(R1) args: 0, res: 0, upd: 0;
       cbaAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaAs() //  [R1]
         { info_tbl: [(cbaAs,
                       label: block_cbaAs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaAs: // global
           if (R1 & 7 == 1) goto cbaAG; else goto cbaAH;
       cbaAG: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbaAH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbaAQ; else goto cbaAP;
       cbaAQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaAP: // global
           _sb780::P64 = P64[R1 + 6];
           _sb781::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sb782_info;
           P64[Hp] = _sb781::P64;
           R3 = Hp - 16;
           R2 = _sb780::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.709788525 UTC

[section ""data" . go1_rb6WQ_closure" {
     go1_rb6WQ_closure:
         const go1_rb6WQ_info;
 },
 sat_sb787_entry() //  [R1]
         { info_tbl: [(cbaBl,
                       label: sat_sb787_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaBl: // global
           R2 = P64[R1 + 16];
           call go1_rb6WQ_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 go1_rb6WQ_entry() //  [R2]
         { info_tbl: [(cbaBs,
                       label: go1_rb6WQ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaBs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbaBt; else goto cbaBu;
       cbaBt: // global
           R2 = R2;
           R1 = go1_rb6WQ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbaBu: // global
           I64[Sp - 8] = block_cbaBb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaBA; else goto cbaBc;
       ubaBA: // global
           call _cbaBb(R1) args: 0, res: 0, upd: 0;
       cbaBc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaBb() //  [R1]
         { info_tbl: [(cbaBb,
                       label: block_cbaBb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaBb: // global
           if (R1 & 7 == 1) goto cbaBp; else goto cbaBq;
       cbaBp: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbaBq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbaBz; else goto cbaBy;
       cbaBz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaBy: // global
           _sb785::P64 = P64[R1 + 6];
           _sb786::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sb787_info;
           P64[Hp] = _sb786::P64;
           R3 = Hp - 16;
           R2 = _sb785::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.723292671 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure" {
     GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure:
         const GHC.IO.Handle.Text.$whGetLineBufferedLoop_info;
         const 0;
 },
 GHC.IO.Handle.Text.$whGetLineBufferedLoop_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaBR: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 buf1_sb78H_entry() //  [R1]
         { info_tbl: [(cbaDa,
                       label: buf1_sb78H_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaDa: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbaDb; else goto cbaDc;
       cbaDb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaDc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cbaD7_info;
           _sb78a::P64 = P64[R1 + 16];
           _sb78b::P64 = P64[R1 + 24];
           _sb789::I64 = I64[R1 + 40];
           _sb78c::I64 = I64[R1 + 48];
           _sb78e::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _sb789::I64;
           P64[Sp - 48] = _sb78a::P64;
           P64[Sp - 40] = _sb78b::P64;
           I64[Sp - 32] = _sb78c::I64;
           I64[Sp - 24] = _sb78e::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubaDr; else goto cbaD8;
       ubaDr: // global
           call _cbaD7(R1) args: 0, res: 0, upd: 0;
       cbaD8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbaD7() //  [R1]
         { info_tbl: [(cbaD7,
                       label: block_cbaD7_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaD7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbaDh; else goto cbaDg;
       cbaDh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbaDg: // global
           _sb789::I64 = I64[Sp + 8];
           _sb78a::P64 = P64[Sp + 16];
           _sb78b::P64 = P64[Sp + 24];
           _sb78c::I64 = I64[Sp + 32];
           _sb78e::I64 = I64[Sp + 40];
           _sb78J::I64 = I64[R1 + 7];
           if (_sb78J::I64 == _sb78e::I64) goto cbaDq; else goto cbaDn;
       cbaDq: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbaDn: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = _sb78J::I64;
           I64[Hp] = _sb78e::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79e_entry() //  [R1]
         { info_tbl: [(cbaDy,
                       label: sat_sb79e_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaDy: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbaDz; else goto cbaDA;
       cbaDz: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbaDA: // global
           I64[Sp - 24] = block_cbaDv_info;
           _sb78h::P64 = P64[R1 + 7];
           _sb78v::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _sb78h::P64;
           P64[Sp - 8] = _sb78v::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubaEL; else goto cbaDw;
       ubaEL: // global
           call _cbaDv(R1) args: 0, res: 0, upd: 0;
       cbaDw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaDv() //  [R1]
         { info_tbl: [(cbaDv,
                       label: block_cbaDv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaDv: // global
           _sb78R::I64 = I64[R1 + 39];
           _sb78T::I64 = I64[R1 + 47] - _sb78R::I64;
           if (_sb78T::I64 == 0) goto cbaDX; else goto ubaEG;
       cbaDX: // global
           I64[Sp + 16] = block_cbaDU_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       ubaEG: // global
           if (_sb78T::I64 == 1) goto cbaE7; else goto ubaEH;
       cbaE7: // global
           I64[Sp - 40] = block_cbaE6_info;
           _sb78M::P64 = R1;
           _sb78O::P64 = P64[R1 + 7];
           _sb78P::P64 = P64[R1 + 15];
           _sb78N::I64 = I64[R1 + 23];
           _sb78Q::I64 = I64[R1 + 31];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _sb78O::P64;
           P64[Sp - 24] = _sb78P::P64;
           I64[Sp - 16] = _sb78Q::I64;
           I64[Sp - 8] = _sb78R::I64;
           I64[Sp] = _sb78N::I64;
           P64[Sp + 16] = _sb78M::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubaEJ; else goto cbaE9;
       ubaEJ: // global
           call _cbaE6(R1) args: 0, res: 0, upd: 0;
       cbaE9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubaEH: // global
           I64[Sp + 8] = _sb78T::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cbaDI() args: 0, res: 0, upd: 0;
     }
 },
 _cbaDU() //  [R1]
         { info_tbl: [(cbaDU,
                       label: block_cbaDU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaDU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaE1; else goto cbaE0;
       cbaE1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaE0: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbaE6() //  [R1]
         { info_tbl: [(cbaE6,
                       label: block_cbaE6_info
                       rep:StackRep [False, False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaE6: // global
           _sb78M::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cbaEf; else goto cbaEj;
       cbaEf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaEi; else goto cbaEh;
       cbaEi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaEh: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sb78M::P64;
           R1 = Hp - 6;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbaEj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbaEo; else goto cbaEn;
       cbaEo: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaEn: // global
           _sb78h::P64 = P64[Sp + 48];
           _sb78N::I64 = I64[Sp + 40];
           _sb78O::P64 = P64[Sp + 8];
           _sb78P::P64 = P64[Sp + 16];
           _sb78Q::I64 = I64[Sp + 24];
           _sb793::I64 = %MO_UU_Conv_W32_W64(I32[_sb78N::I64 + (I64[Sp + 32] << 2)]);
           call MO_Touch(_sb78O::P64);
           if (_sb793::I64 == 13) goto cbaEB; else goto cbaEu;
       cbaEB: // global
           I32[_sb78N::I64] = 13 :: W32;
           call MO_Touch(_sb78O::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78O::P64;
           P64[Hp - 32] = _sb78P::P64;
           I64[Hp - 24] = _sb78N::I64;
           I64[Hp - 16] = _sb78Q::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 56] = block_cbaEy_info;
           R3 = Hp - 47;
           R2 = _sb78h::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbaEu: // global
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = _sb78M::P64;
           _cbaEs::P64 = Hp - 46;
           Hp = Hp - 40;
           R1 = _cbaEs::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbaEy() //  [R1]
         { info_tbl: [(cbaEy,
                       label: block_cbaEy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaEy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaEE; else goto cbaED;
       cbaEE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaED: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbaDI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaDI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaDP; else goto cbaDO;
       cbaDP: // global
           HpAlloc = 16;
           _sb78T::I64 = I64[Sp];
           I64[Sp] = block_cbaDH_info;
           R1 = _sb78T::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbaDO: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbaDH() //  [R1]
         { info_tbl: [(cbaDH,
                       label: block_cbaDH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaDH: // global
           I64[Sp] = R1;
           call _cbaDI() args: 0, res: 0, upd: 0;
     }
 },
 sat_sb79q_entry() //  [R1]
         { info_tbl: [(cbaEV,
                       label: sat_sb79q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaEV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbaEZ; else goto cbaF0;
       cbaEZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaF0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbaES_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubaF4; else goto cbaET;
       ubaF4: // global
           call _cbaES(R1) args: 0, res: 0, upd: 0;
       cbaET: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbaES() //  [R1]
         { info_tbl: [(cbaES,
                       label: block_cbaES_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaES: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbaF3; else goto cbaF2;
       cbaF3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbaF2: // global
           _sb79l::P64 = P64[R1 + 7];
           _sb79m::P64 = P64[R1 + 15];
           _sb79k::I64 = I64[R1 + 23];
           _sb79n::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb79l::P64;
           P64[Hp - 32] = _sb79m::P64;
           I64[Hp - 24] = _sb79k::I64;
           I64[Hp - 16] = _sb79n::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79A_entry() //  [R1]
         { info_tbl: [(cbaFg,
                       label: sat_sb79A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaFg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbaFh; else goto cbaFi;
       cbaFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaFi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbaFd_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubaFr; else goto cbaFe;
       ubaFr: // global
           call _cbaFd(R1) args: 0, res: 0, upd: 0;
       cbaFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbaFd() //  [R1]
         { info_tbl: [(cbaFd,
                       label: block_cbaFd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaFd: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbaFq; else goto cbaFp;
       cbaFq: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbaFp: // global
           R1 = lvl4_rb6WH_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79S_entry() //  [R1]
         { info_tbl: [(cbaFA,
                       label: sat_sb79S_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaFA: // global
           _sb79S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbaFB; else goto cbaFC;
       cbaFC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbaFE; else goto cbaFD;
       cbaFE: // global
           HpAlloc = 56;
           goto cbaFB;
       cbaFB: // global
           R1 = _sb79S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaFD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb79S::P64;
           _sb78a::P64 = P64[_sb79S::P64 + 16];
           _sb78b::P64 = P64[_sb79S::P64 + 24];
           _sb789::I64 = I64[_sb79S::P64 + 32];
           _sb78c::I64 = I64[_sb79S::P64 + 40];
           _sb78e::I64 = I64[_sb79S::P64 + 48];
           _sb79Q::I64 = I64[_sb79S::P64 + 56] + 1;
           if (_sb79Q::I64 == _sb78e::I64) goto cbaFO; else goto cbaFL;
       cbaFO: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbaFL: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb78a::P64;
           P64[Hp - 32] = _sb78b::P64;
           I64[Hp - 24] = _sb789::I64;
           I64[Hp - 16] = _sb78c::I64;
           I64[Hp - 8] = _sb79Q::I64;
           I64[Hp] = _sb78e::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb79W_entry() //  [R1]
         { info_tbl: [(cbaFZ,
                       label: sat_sb79W_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaFZ: // global
           _sb79W::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbaG0; else goto cbaG1;
       cbaG1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbaG3; else goto cbaG2;
       cbaG3: // global
           HpAlloc = 24;
           goto cbaG0;
       cbaG0: // global
           R1 = _sb79W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaG2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sb79W::P64;
           _sb78f::P64 = P64[_sb79W::P64 + 16];
           _sb78E::P64 = P64[_sb79W::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sb78E::P64;
           P64[Hp] = _sb78f::P64;
           I64[Sp - 24] = block_cbaFX_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbaFX() //  [R1]
         { info_tbl: [(cbaFX,
                       label: block_cbaFX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaFX: // global
           R2 = R1;
           Sp = Sp + 8;
           call go_rb6WP_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cbaG7,
                       label: GHC.IO.Handle.Text.$whGetLineBufferedLoop_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaG7: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cbaG8; else goto ubaHZ;
       cbaG8: // global
           R1 = GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ubaHZ: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cbaBS() args: 0, res: 0, upd: 0;
     }
 },
 _cbaBS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaBS: // global
           _sb788::P64 = P64[Sp];
           I64[Sp] = block_cbaBV_info;
           R1 = _sb788::P64;
           if (R1 & 7 != 0) goto ubaIc; else goto cbaBW;
       ubaIc: // global
           call _cbaBV(R1) args: 0, res: 0, upd: 0;
       cbaBW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaBV() //  [R1]
         { info_tbl: [(cbaBV,
                       label: block_cbaBV_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaBV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbaGc; else goto cbaGb;
       cbaGc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaGb: // global
           _sb78q::P64 = P64[R1 + 71];
           _sb78v::P64 = P64[R1 + 111];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           P64[Sp - 32] = _sb78q::P64;
           P64[Sp - 24] = _sb78v::P64;
           P64[Sp - 16] = Hp - 15;
           I64[Sp - 8] = I64[Sp + 40];
           P64[Sp] = R1;
           Sp = Sp - 32;
           call _cbaHy() args: 0, res: 0, upd: 0;
     }
 },
 _cbaHy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaHy: // global
           _sb78e::I64 = I64[Sp + 80];
           if (I64[Sp + 24] == _sb78e::I64) goto cbaHS; else goto cbaHH;
       cbaHS: // global
           P64[Sp + 24] = GHC.Types.False_closure+1;
           I64[Sp + 16] = _sb78e::I64;
           call _sb78y() args: 0, res: 0, upd: 0;
       cbaHH: // global
           I64[Sp - 8] = block_cbaHF_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaIq; else goto cbaHI;
       ubaIq: // global
           call _cbaHF(R1) args: 0, res: 0, upd: 0;
       cbaHI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaHF() //  [R1]
         { info_tbl: [(cbaHF,
                       label: block_cbaHF_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaHF: // global
           _sb7au::I64 = I64[Sp + 32];
           _sb7aC::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 15] + (_sb7au::I64 << 2)]);
           call MO_Touch(P64[R1 + 7]);
           if (_sb7aC::I64 == 10) goto cbaHR; else goto cbaHQ;
       cbaHR: // global
           I64[Sp + 24] = _sb7au::I64;
           P64[Sp + 32] = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call _sb78y() args: 0, res: 0, upd: 0;
       cbaHQ: // global
           P64[Sp + 24] = R1;
           I64[Sp + 32] = _sb7au::I64 + 1;
           Sp = Sp + 8;
           call _cbaHy() args: 0, res: 0, upd: 0;
     }
 },
 _sb78y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb78y: // global
           I64[Sp - 8] = block_cbaC8_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaIu; else goto cbaC9;
       ubaIu: // global
           call _cbaC8(R1) args: 0, res: 0, upd: 0;
       cbaC9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaC8() //  [R1]
         { info_tbl: [(cbaC8,
                       label: block_cbaC8_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaC8: // global
           _sb78d::I64 = I64[Sp + 80];
           _sb78B::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cbaGR; else goto cbaHd;
       cbaGR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaGU; else goto cbaGT;
       cbaGU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaGT: // global
           if (_sb78d::I64 == _sb78B::I64) goto cbaH6; else goto cbaH5;
       cbaH6: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb78B::I64;
           P64[Sp + 80] = GHC.Types.[]_closure+1;
           P64[Sp] = Hp - 7;
           call _sb78C() args: 0, res: 0, upd: 0;
       cbaH5: // global
           Hp = Hp - 16;
           I64[Sp - 8] = _sb78B::I64 - 1;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call _cbaCU() args: 0, res: 0, upd: 0;
       cbaHd: // global
           I64[Sp] = block_cbaH9_info;
           R6 = GHC.Types.[]_closure+1;
           R5 = _sb78B::I64;
           R4 = _sb78d::I64;
           R3 = P64[Sp + 56];
           R2 = I64[Sp + 48];
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbaCU() //  []
         { info_tbl: [(cbaCU,
                       label: block_cbaCU_info
                       rep:StackRep [True, False, False, False, True, False, False, True,
                                     False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaCU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbaH0; else goto cbaGZ;
       cbaH0: // global
           HpAlloc = 40;
           I64[Sp] = block_cbaCU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbaGZ: // global
           _sb7a5::P64 = P64[Sp + 16];
           _sb7a6::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_sb7a6::I64,
                            I64[Sp + 96])) goto cbaH2; else goto cbaH3;
       cbaH2: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 64] + (_sb7a6::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sb7a5::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 8] = _sb7a6::I64 - 1;
           call _cbaCU() args: 0, res: 0, upd: 0;
       cbaH3: // global
           Hp = Hp - 40;
           P64[Sp + 96] = _sb7a5::P64;
           Sp = Sp + 24;
           call _cbaCO() args: 0, res: 0, upd: 0;
     }
 },
 _cbaCO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaCO: // global
           Hp = Hp + 16;
           _sb7a1::P64 = P64[Sp + 72];
           if (Hp > HpLim) (likely: False) goto cbaGX; else goto cbaGW;
       cbaGX: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cbaCN_info;
           R1 = _sb7a1::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaGW: // global
           _sb78B::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 48]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb78B::I64;
           P64[Sp + 72] = _sb7a1::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 8;
           call _sb78C() args: 0, res: 0, upd: 0;
     }
 },
 _cbaCN() //  [R1]
         { info_tbl: [(cbaCN,
                       label: block_cbaCN_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaCN: // global
           P64[Sp + 80] = R1;
           Sp = Sp + 8;
           call _cbaCO() args: 0, res: 0, upd: 0;
     }
 },
 _cbaH9() //  [R1]
         { info_tbl: [(cbaH9,
                       label: block_cbaH9_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaH9: // global
           I64[Sp] = block_cbaHb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubaIo; else goto cbaHf;
       ubaIo: // global
           call _cbaHb(R1) args: 0, res: 0, upd: 0;
       cbaHf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaHb() //  [R1]
         { info_tbl: [(cbaHb,
                       label: block_cbaHb_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaHb: // global
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 80] = P64[R1 + 7];
           call _sb78C() args: 0, res: 0, upd: 0;
     }
 },
 _sb78C() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb78C: // global
           I64[Sp - 8] = block_cbaCl_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaIv; else goto cbaCm;
       ubaIv: // global
           call _cbaCl(R1) args: 0, res: 0, upd: 0;
       cbaCm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaCl() //  [R1]
         { info_tbl: [(cbaCl,
                       label: block_cbaCl_info
                       rep:StackRep [False, False, False, True, True, False, True, False,
                                     False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaCl: // global
           _sb789::I64 = I64[Sp + 56];
           _sb78a::P64 = P64[Sp + 64];
           _sb78b::P64 = P64[Sp + 72];
           _sb78c::I64 = I64[Sp + 80];
           _sb78e::I64 = I64[Sp + 96];
           if (R1 & 7 == 1) goto cbaGg; else goto cbaGM;
       cbaGg: // global
           Hp = Hp + 96;
           _sb78G::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbaGP; else goto cbaGi;
       cbaGi: // global
           I64[Hp - 88] = buf1_sb78H_info;
           P64[Hp - 72] = _sb78a::P64;
           P64[Hp - 64] = _sb78b::P64;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = _sb789::I64;
           I64[Hp - 40] = _sb78c::I64;
           I64[Hp - 32] = _sb78e::I64;
           I64[Hp - 24] = sat_sb79e_info;
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 24];
           _cbaCq::P64 = Hp - 88;
           P64[Hp] = _cbaCq::P64;
           I64[Sp + 8] = block_cbaCu_info;
           R2 = GHC.IO.Handle.Text.hGetChar3_closure+2;
           R1 = Hp - 23;
           P64[Sp + 96] = _cbaCq::P64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cbaGM: // global
           Hp = Hp + 96;
           _sb78G::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbaGP; else goto cbaGO;
       cbaGP: // global
           HpAlloc = 96;
           R1 = _sb78G::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaGO: // global
           I64[Hp - 88] = sat_sb79S_info;
           P64[Hp - 72] = _sb78a::P64;
           P64[Hp - 64] = _sb78b::P64;
           I64[Hp - 56] = _sb789::I64;
           I64[Hp - 48] = _sb78c::I64;
           I64[Hp - 40] = _sb78e::I64;
           I64[Hp - 32] = I64[Sp + 32];
           _sb78f::P64 = P64[Sp + 104];
           _sb78q::P64 = P64[Sp + 16];
           _sb78E::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sb78q::P64 + 8] = Hp - 88;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb78q::P64);
           I64[Hp - 24] = sat_sb79W_info;
           P64[Hp - 8] = _sb78f::P64;
           P64[Hp] = _sb78E::P64;
           R1 = Hp - 24;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbaCu() //  [R1]
         { info_tbl: [(cbaCu,
                       label: block_cbaCu_info
                       rep:StackRep [False, True, True, True, False, True, True, True,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaCu: // global
           I64[Sp] = block_cbaCw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubaIg; else goto cbaCx;
       ubaIg: // global
           call _cbaCw(R1) args: 0, res: 0, upd: 0;
       cbaCx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaCw() //  [R1]
         { info_tbl: [(cbaCw,
                       label: block_cbaCw_info
                       rep:StackRep [False, True, True, True, False, True, True, True,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaCw: // global
           if (R1 & 7 == 1) goto cbaGo; else goto cbaGI;
       cbaGo: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbaGr; else goto cbaGq;
       cbaGr: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaGq: // global
           I64[Hp - 88] = sat_sb79q_info;
           _cbaCq::P64 = P64[Sp + 88];
           P64[Hp - 72] = _cbaCq::P64;
           _sb78f::P64 = P64[Sp + 96];
           _sb78q::P64 = P64[Sp + 8];
           _sb78E::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sb78q::P64 + 8] = Hp - 88;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb78q::P64);
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sb78E::P64;
           P64[Hp - 48] = _sb78f::P64;
           I64[Hp - 40] = sat_sb79A_info;
           P64[Hp - 24] = _cbaCq::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           I64[Sp + 96] = block_cbaGm_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp + 96;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
       cbaGI: // global
           I64[Sp + 32] = block_cbaCC_info;
           R1 = P64[R1 + 6];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto ubaIh; else goto cbaCD;
       ubaIh: // global
           call _cbaCC(R1) args: 0, res: 0, upd: 0;
       cbaCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaGm() //  [R1]
         { info_tbl: [(cbaGm,
                       label: block_cbaGm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaGm: // global
           I64[Sp] = block_cbaGv_info;
           R2 = R1;
           call go1_rb6WQ_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbaGv() //  [R1]
         { info_tbl: [(cbaGv,
                       label: block_cbaGv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaGv: // global
           if (R1 & 7 == 1) goto cbaGC; else goto cbaGG;
       cbaGC: // global
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.ioe_EOF1_entry() args: 8, res: 0, upd: 8;
       cbaGG: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbaCC() //  [R1]
         { info_tbl: [(cbaCC,
                       label: block_cbaCC_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaCC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbaGL; else goto cbaGK;
       cbaGL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaGK: // global
           _sb79K::P64 = P64[R1 + 7];
           _sb79L::P64 = P64[R1 + 15];
           _sb79J::I64 = I64[R1 + 23];
           _sb79M::I64 = I64[R1 + 31];
           _sb79N::I64 = I64[R1 + 39];
           _sb79O::I64 = I64[R1 + 47];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 64];
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = _sb79J::I64;
           P64[Sp + 24] = _sb79K::P64;
           P64[Sp + 32] = _sb79L::P64;
           I64[Sp + 40] = _sb79M::I64;
           I64[Sp + 48] = _sb79N::I64;
           I64[Sp + 56] = _sb79O::I64;
           P64[Sp + 64] = Hp - 14;
           Sp = Sp + 8;
           call _cbaBS() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.795564601 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine3_closure" {
     GHC.IO.Handle.Text.hGetLine3_closure:
         const GHC.IO.Handle.Text.hGetLine3_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbaLx,
                       label: GHC.IO.Handle.Text.hGetLine3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaLx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbaLy; else goto cbaLz;
       cbaLy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetLine3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbaLz: // global
           I64[Sp - 24] = block_cbaLu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubaLD; else goto cbaLv;
       ubaLD: // global
           call _cbaLu(R1) args: 0, res: 0, upd: 0;
       cbaLv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaLu() //  [R1]
         { info_tbl: [(cbaLu,
                       label: block_cbaLu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaLu: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.801958688 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetLine5_bytes" {
     GHC.IO.Handle.Text.hGetLine5_bytes:
         I8[] [104,71,101,116,76,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.803803839 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine4_closure" {
     GHC.IO.Handle.Text.hGetLine4_closure:
         const GHC.IO.Handle.Text.hGetLine4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine4_entry() //  [R1]
         { info_tbl: [(cbaLW,
                       label: GHC.IO.Handle.Text.hGetLine4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaLW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbaLX; else goto cbaLY;
       cbaLX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaLY: // global
           (_cbaLT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbaLT::I64 == 0) goto cbaLV; else goto cbaLU;
       cbaLV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbaLU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbaLT::I64;
           R2 = GHC.IO.Handle.Text.hGetLine5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.808059323 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine2_closure" {
     GHC.IO.Handle.Text.hGetLine2_closure:
         const GHC.IO.Handle.Text.hGetLine2_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine2_entry() //  [R2]
         { info_tbl: [(cbaMd,
                       label: GHC.IO.Handle.Text.hGetLine2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaMd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbaMh; else goto cbaMi;
       cbaMh: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetLine2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbaMi: // global
           I64[Sp - 8] = block_cbaMa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaMq; else goto cbaMb;
       ubaMq: // global
           call _cbaMa(R1) args: 0, res: 0, upd: 0;
       cbaMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaMa() //  [R1]
         { info_tbl: [(cbaMa,
                       label: block_cbaMa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaMa: // global
           _sb7bd::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_cbaMg_info;
           _sb7aU::P64 = R1;
           R1 = _sb7bd::P64;
           P64[Sp] = _sb7aU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaMp; else goto cbaMk;
       ubaMp: // global
           call _cbaMg(R1) args: 0, res: 0, upd: 0;
       cbaMk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaMg() //  [R1]
         { info_tbl: [(cbaMg,
                       label: block_cbaMg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaMg: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.815768876 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine1_closure" {
     GHC.IO.Handle.Text.hGetLine1_closure:
         const GHC.IO.Handle.Text.hGetLine1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine1_entry() //  [R2]
         { info_tbl: [(cbaML,
                       label: GHC.IO.Handle.Text.hGetLine1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaML: // global
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.819246386 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine_closure" {
     GHC.IO.Handle.Text.hGetLine_closure:
         const GHC.IO.Handle.Text.hGetLine_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine_entry() //  [R2]
         { info_tbl: [(cbaMW,
                       label: GHC.IO.Handle.Text.hGetLine_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaMW: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetLine1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.822893622 UTC

[section ""data" . lvl11_rb6WR_closure" {
     lvl11_rb6WR_closure:
         const lvl11_rb6WR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rb6WR_entry() //  [R1]
         { info_tbl: [(cbaNe,
                       label: lvl11_rb6WR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaNe: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbaNf; else goto cbaNg;
       cbaNf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaNg: // global
           (_cbaN6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbaN6::I64 == 0) goto cbaN8; else goto cbaN7;
       cbaN8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbaN7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbaN6::I64;
           I64[Sp - 24] = block_cbaN9_info;
           R6 = 0;
           R5 = GHC.IO.FD.$tcFD1_closure;
           R4 = GHC.IO.FD.$trModule_closure;
           R3 = 15546290101957756376;
           R2 = 10838815552519039062;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbaN9() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbaN9,
                       label: block_cbaN9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaN9: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbaNa() args: 0, res: 0, upd: 0;
     }
 },
 _cbaNa() //  []
         { info_tbl: [(cbaNa,
                       label: block_cbaNa_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaNa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbaNj; else goto cbaNi;
       cbaNj: // global
           HpAlloc = 48;
           I64[Sp] = block_cbaNa_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbaNi: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.834937463 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking2_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking2_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking2_info;
         const 0;
 },
 sat_sb7ch_entry() //  [R1]
         { info_tbl: [(cbaOy,
                       label: sat_sb7ch_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaOy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbaOF; else goto cbaOG;
       cbaOF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaOG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbaOv_info;
           _sb7bY::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7bY::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubaOK; else goto cbaOw;
       ubaOK: // global
           call _cbaOv(R1) args: 0, res: 0, upd: 0;
       cbaOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbaOv() //  [R1]
         { info_tbl: [(cbaOv,
                       label: block_cbaOv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaOv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaOJ; else goto cbaOI;
       cbaOJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbaOI: // global
           _sb7cg::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7cg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7cl_entry() //  [R1]
         { info_tbl: [(cbaOT,
                       label: sat_sb7cl_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaOT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbaP0; else goto cbaP1;
       cbaP0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaP1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbaOQ_info;
           _sb7bY::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7bY::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubaP5; else goto cbaOR;
       ubaP5: // global
           call _cbaOQ(R1) args: 0, res: 0, upd: 0;
       cbaOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbaOQ() //  [R1]
         { info_tbl: [(cbaOQ,
                       label: block_cbaOQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaOQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaP4; else goto cbaP3;
       cbaP4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbaP3: // global
           _sb7ck::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7ck::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7cB_entry() //  [R1]
         { info_tbl: [(cbaPB,
                       label: sat_sb7cB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaPB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbaPI; else goto cbaPJ;
       cbaPI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaPJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbaPy_info;
           _sb7bX::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7bX::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubaPN; else goto cbaPz;
       ubaPN: // global
           call _cbaPy(R1) args: 0, res: 0, upd: 0;
       cbaPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbaPy() //  [R1]
         { info_tbl: [(cbaPy,
                       label: block_cbaPy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaPy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaPM; else goto cbaPL;
       cbaPM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbaPL: // global
           _sb7cA::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7cA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking2_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cbaPO,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaPO: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbaPP; else goto cbaPQ;
       cbaPP: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufNonBlocking2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbaPQ: // global
           I64[Sp - 40] = block_cbaNJ_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubaQe; else goto cbaNK;
       ubaQe: // global
           call _cbaNJ(R1) args: 0, res: 0, upd: 0;
       cbaNK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaNJ() //  [R1]
         { info_tbl: [(cbaNJ,
                       label: block_cbaNJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaNJ: // global
           I64[Sp - 8] = block_cbaNO_info;
           _sb7by::P64 = R1;
           _sb7bE::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb7bE::P64;
           P64[Sp + 8] = _sb7by::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubaQa; else goto cbaNP;
       ubaQa: // global
           call _cbaNO(R1) args: 0, res: 0, upd: 0;
       cbaNP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaNO() //  [R1]
         { info_tbl: [(cbaNO,
                       label: block_cbaNO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaNO: // global
           I64[Sp - 40] = block_cbaNT_info;
           _sb7bR::P64 = P64[R1 + 7];
           _sb7bS::P64 = P64[R1 + 15];
           _sb7bQ::I64 = I64[R1 + 23];
           _sb7bT::I64 = I64[R1 + 31];
           _sb7bU::I64 = I64[R1 + 39];
           _sb7bV::I64 = I64[R1 + 47];
           R1 = P64[Sp + 40];
           P64[Sp - 32] = _sb7bS::P64;
           I64[Sp - 24] = _sb7bT::I64;
           I64[Sp - 16] = _sb7bU::I64;
           I64[Sp - 8] = _sb7bV::I64;
           P64[Sp] = _sb7bR::P64;
           I64[Sp + 40] = _sb7bQ::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubaQb; else goto cbaNU;
       ubaQb: // global
           call _cbaNT(R1) args: 0, res: 0, upd: 0;
       cbaNU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaNT() //  [R1]
         { info_tbl: [(cbaNT,
                       label: block_cbaNT_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaNT: // global
           _sb7bu::P64 = P64[Sp + 64];
           _sb7bX::I64 = I64[R1 + 7];
           _sb7bY::I64 = I64[Sp + 32] - I64[Sp + 24];
           if (%MO_S_Ge_W64(_sb7bX::I64,
                            _sb7bY::I64)) goto cbaPV; else goto cbaQ6;
       cbaPV: // global
           I64[Sp] = block_cbaO4_info;
           R1 = _sb7bu::P64;
           I64[Sp + 32] = _sb7bY::I64;
           I64[Sp + 64] = _sb7bX::I64;
           if (R1 & 7 != 0) goto ubaQc; else goto cbaO5;
       ubaQc: // global
           call _cbaO4(R1) args: 0, res: 0, upd: 0;
       cbaO5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbaQ6: // global
           I64[Sp] = block_cbaP7_info;
           R1 = _sb7bu::P64;
           I64[Sp + 64] = _sb7bX::I64;
           if (R1 & 7 != 0) goto ubaQd; else goto cbaP8;
       ubaQd: // global
           call _cbaP7(R1) args: 0, res: 0, upd: 0;
       cbaP8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaO4() //  [R1]
         { info_tbl: [(cbaO4,
                       label: block_cbaO4_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaO4: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbaPY; else goto cbaPX;
       cbaPY: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaPX: // global
           _sb7bv::P64 = P64[Sp + 72];
           _sb7by::P64 = P64[Sp + 56];
           _sb7bE::P64 = P64[Sp + 48];
           _sb7bQ::I64 = I64[Sp + 80];
           _sb7bR::P64 = P64[Sp + 40];
           _sb7bS::P64 = P64[Sp + 8];
           _sb7bT::I64 = I64[Sp + 16];
           _sb7bX::I64 = I64[Sp + 64];
           _sb7bY::I64 = I64[Sp + 32];
           _sb7c1::I64 = I64[R1 + 7];
           (_sb7c7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sb7c1::I64, _sb7bQ::I64 + I64[Sp + 24], _sb7bY::I64);
           call MO_Touch(_sb7bR::P64);
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb7bR::P64;
           P64[Hp - 80] = _sb7bS::P64;
           I64[Hp - 72] = _sb7bQ::I64;
           I64[Hp - 64] = _sb7bT::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           call MO_WriteBarrier();
           P64[_sb7bE::P64 + 8] = Hp - 95;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7bE::P64);
           _sb7cb::I64 = _sb7bX::I64 - _sb7bY::I64;
           if (_sb7cb::I64 != 0) goto cbaQ4; else goto cbaQ5;
       cbaQ4: // global
           I64[Hp - 40] = sat_sb7ch_info;
           P64[Hp - 24] = _sb7bv::P64;
           I64[Hp - 16] = _sb7bY::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sb7c1::I64 + _sb7bY::I64;
           R6 = _sb7cb::I64;
           R5 = Hp - 40;
           R4 = Hp - 7;
           R3 = _sb7bT::I64;
           R2 = _sb7by::P64;
           Sp = Sp + 88;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cbaQ5: // global
           I64[Hp - 40] = sat_sb7cl_info;
           P64[Hp - 24] = _sb7bv::P64;
           I64[Hp - 16] = _sb7bY::I64;
           _cbaOM::P64 = Hp - 40;
           Hp = Hp - 16;
           R1 = _cbaOM::P64;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbaP7() //  [R1]
         { info_tbl: [(cbaP7,
                       label: block_cbaP7_info
                       rep:StackRep [False, True, True, True, False, False, True, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaP7: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbaQ9; else goto cbaQ8;
       cbaQ9: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaQ8: // global
           _sb7bv::P64 = P64[Sp + 72];
           _sb7bE::P64 = P64[Sp + 48];
           _sb7bQ::I64 = I64[Sp + 80];
           _sb7bR::P64 = P64[Sp + 40];
           _sb7bS::P64 = P64[Sp + 8];
           _sb7bT::I64 = I64[Sp + 16];
           _sb7bU::I64 = I64[Sp + 24];
           _sb7bV::I64 = I64[Sp + 32];
           _sb7bX::I64 = I64[Sp + 64];
           (_sb7ct::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[R1 + 7], _sb7bQ::I64 + _sb7bU::I64, _sb7bX::I64);
           call MO_Touch(_sb7bR::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _sb7bR::P64;
           P64[Hp - 64] = _sb7bS::P64;
           I64[Hp - 56] = _sb7bQ::I64;
           I64[Hp - 48] = _sb7bT::I64;
           I64[Hp - 40] = _sb7bU::I64 + _sb7bX::I64;
           I64[Hp - 32] = _sb7bV::I64;
           call MO_WriteBarrier();
           P64[_sb7bE::P64 + 8] = Hp - 79;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7bE::P64);
           I64[Hp - 24] = sat_sb7cB_info;
           P64[Hp - 8] = _sb7bv::P64;
           I64[Hp] = _sb7bX::I64;
           R1 = Hp - 24;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Text.$wbufReadNBEmpty_closure" {
     GHC.IO.Handle.Text.$wbufReadNBEmpty_closure:
         const GHC.IO.Handle.Text.$wbufReadNBEmpty_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wbufReadNBEmpty_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaQg: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7dz_entry() //  [R1]
         { info_tbl: [(cbaR2,
                       label: sat_sb7dz_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaR2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbaR9; else goto cbaRa;
       cbaR9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaRa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbaQZ_info;
           _sb7dv::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7dv::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubaRe; else goto cbaR0;
       ubaRe: // global
           call _cbaQZ(R1) args: 0, res: 0, upd: 0;
       cbaR0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbaQZ() //  [R1]
         { info_tbl: [(cbaQZ,
                       label: block_cbaQZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaQZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaRd; else goto cbaRc;
       cbaRd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbaRc: // global
           _sb7dy::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7dy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubaSA_srtd" {
     ubaSA_srtd:
         const Sb7vQ_srt+56;
         const 33;
         const 8321499137;
 },
 GHC.IO.Handle.Text.$wbufReadNBEmpty_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cbaRf,
                       label: GHC.IO.Handle.Text.$wbufReadNBEmpty_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, True, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaRf: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cbaRg; else goto cbaRh;
       cbaRg: // global
           R1 = GHC.IO.Handle.Text.$wbufReadNBEmpty_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cbaRh: // global
           I64[Sp - 40] = block_cbaQk_info;
           R1 = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubaSw; else goto cbaQl;
       ubaSw: // global
           call _cbaQk(R1) args: 0, res: 0, upd: 0;
       cbaQl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubaSB_srtd" {
     ubaSB_srtd:
         const Sb7vQ_srt+56;
         const 33;
         const 8053063681;
 },
 _cbaQk() //  [R1]
         { info_tbl: [(cbaQk,
                       label: block_cbaQk_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaQk: // global
           I64[Sp - 32] = block_cbaQp_info;
           _sb7cI::P64 = R1;
           _sb7cK::P64 = P64[R1 + 15];
           _sb7cL::P64 = P64[R1 + 23];
           _sb7cO::P64 = P64[R1 + 47];
           R1 = P64[R1 + 31];
           P64[Sp - 24] = _sb7cK::P64;
           P64[Sp - 16] = _sb7cL::P64;
           P64[Sp - 8] = _sb7cO::P64;
           P64[Sp] = _sb7cI::P64;
           Sp = Sp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubaSC_srtd" {
     ubaSC_srtd:
         const Sb7vQ_srt+56;
         const 33;
         const 8053063681;
 },
 _cbaQp() //  [R1]
         { info_tbl: [(cbaQp,
                       label: block_cbaQp_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaQp: // global
           if (%MO_S_Le_W64(I64[Sp + 64],
                            I64[Sp + 40])) goto ubaSq; else goto cbaS9;
       ubaSq: // global
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _sb7d2() args: 0, res: 0, upd: 0;
       cbaS9: // global
           I64[Sp - 8] = block_cbaQz_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 15];
           I64[Sp + 16] = I64[R1 + 7];
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbaQz() //  [R1]
         { info_tbl: [(cbaQz,
                       label: block_cbaQz_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaQz: // global
           if (R1 & 7 == 1) goto ubaSr; else goto cbaSf;
       ubaSr: // global
           Sp = Sp + 16;
           call _sb7d2() args: 0, res: 0, upd: 0;
       cbaSf: // global
           I64[Sp] = block_cbaQE_info;
           R1 = P64[Sp + 56];
           if (R1 & 7 != 0) goto ubaSt; else goto cbaQF;
       ubaSt: // global
           call _cbaQE(R1) args: 0, res: 0, upd: 0;
       cbaQF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _sb7d2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7d2: // global
           _sb7d6::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp + 8] = block_cbaRn_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _sb7d6::P64;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbaRn() //  [R1]
         { info_tbl: [(cbaRn,
                       label: block_cbaRn_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaRn: // global
           I64[Sp] = block_cbaRp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubaSx; else goto cbaRs;
       ubaSx: // global
           call _cbaRp(R1) args: 0, res: 0, upd: 0;
       cbaRs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaRp() //  [R1]
         { info_tbl: [(cbaRp,
                       label: block_cbaRp_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaRp: // global
           I64[Sp] = block_cbaRw_info;
           _sb7dc::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _sb7dc::P64;
           if (R1 & 7 != 0) goto ubaSy; else goto cbaRy;
       ubaSy: // global
           call _cbaRw(R1) args: 0, res: 0, upd: 0;
       cbaRy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaRw() //  [R1]
         { info_tbl: [(cbaRw,
                       label: block_cbaRw_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaRw: // global
           if (R1 & 7 == 1) goto cbaRE; else goto cbaRJ;
       cbaRE: // global
           R1 = P64[Sp + 40];
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbaRJ: // global
           I64[Sp] = block_cbaRH_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubaSz; else goto cbaRK;
       ubaSz: // global
           call _cbaRH(R1) args: 0, res: 0, upd: 0;
       cbaRK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaRH() //  [R1]
         { info_tbl: [(cbaRH,
                       label: block_cbaRH_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaRH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbaRQ; else goto cbaRP;
       cbaRQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaRP: // global
           _sb7cF::P64 = P64[Sp + 40];
           _sb7dh::I64 = I64[R1 + 7];
           if (_sb7dh::I64 == 0) goto cbaS6; else goto cbaS5;
       cbaS6: // global
           Hp = Hp - 16;
           R1 = _sb7cF::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbaS5: // global
           _sb7cE::P64 = P64[Sp + 32];
           _sb7cG::I64 = I64[Sp + 48];
           _sb7cI::P64 = P64[Sp + 16];
           _sb7cO::P64 = P64[Sp + 8];
           _sb7dc::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sb7cO::P64 + 8] = _sb7dc::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7cO::P64);
           if (%MO_S_Gt_W64(_sb7cG::I64,
                            _sb7dh::I64)) goto cbaRZ; else goto cbaS3;
       cbaRZ: // global
           Hp = Hp - 16;
           R6 = R1;
           R5 = _sb7cF::P64;
           R4 = _sb7cE::P64;
           R3 = _sb7dc::P64;
           R2 = _sb7cI::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cbaS3: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7cG::I64;
           R6 = Hp - 7;
           R5 = _sb7cF::P64;
           R4 = _sb7cE::P64;
           R3 = _sb7dc::P64;
           R2 = _sb7cI::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbaQE() //  [R1]
         { info_tbl: [(cbaQE,
                       label: block_cbaQE_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaQE: // global
           I64[Sp + 56] = block_cbaQM_info;
           R6 = 0;
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp + 48] = I64[Sp + 72];
           Sp = Sp + 48;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbaQM() //  [R1]
         { info_tbl: [(cbaQM,
                       label: block_cbaQM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaQM: // global
           I64[Sp] = block_cbaQO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubaSv; else goto cbaQP;
       ubaSv: // global
           call _cbaQO(R1) args: 0, res: 0, upd: 0;
       cbaQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaQO() //  [R1]
         { info_tbl: [(cbaQO,
                       label: block_cbaQO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaQO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbaSk; else goto cbaSj;
       cbaSk: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaSj: // global
           _sb7cF::P64 = P64[Sp + 8];
           _sb7dv::I64 = I64[R1 + 7];
           if (_sb7dv::I64 != (-1)) goto cbaSm; else goto cbaSn;
       cbaSm: // global
           I64[Hp - 24] = sat_sb7dz_info;
           P64[Hp - 8] = _sb7cF::P64;
           I64[Hp] = _sb7dv::I64;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbaSn: // global
           Hp = Hp - 32;
           R1 = _sb7cF::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.895331806 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes" {
     GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes:
         I8[] [104,71,101,116,66,117,102,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.897306517 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking3_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking3_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking3_entry() //  [R1]
         { info_tbl: [(cbaV5,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaV5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbaV6; else goto cbaV7;
       cbaV6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaV7: // global
           (_cbaV2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbaV2::I64 == 0) goto cbaV4; else goto cbaV3;
       cbaV4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbaV3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbaV2::I64;
           R2 = GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.904445047 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBufNonBlocking_closure" {
     GHC.IO.Handle.Text.$whGetBufNonBlocking_closure:
         const GHC.IO.Handle.Text.$whGetBufNonBlocking_info;
         const 0;
 },
 sat_sb7eF_entry() //  [R1]
         { info_tbl: [(cbaW0,
                       label: sat_sb7eF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaW0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbaW4; else goto cbaW5;
       cbaW4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaW5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbaVX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubaW9; else goto cbaVY;
       ubaW9: // global
           call _cbaVX(R1) args: 0, res: 0, upd: 0;
       cbaVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbaVX() //  [R1]
         { info_tbl: [(cbaVX,
                       label: block_cbaVX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaVX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbaW8; else goto cbaW7;
       cbaW8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbaW7: // global
           _sb7eA::P64 = P64[R1 + 7];
           _sb7eB::P64 = P64[R1 + 15];
           _sb7ez::I64 = I64[R1 + 23];
           _sb7eC::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7eA::P64;
           P64[Hp - 32] = _sb7eB::P64;
           I64[Hp - 24] = _sb7ez::I64;
           I64[Hp - 16] = _sb7eC::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7eY_entry() //  [R1]
         { info_tbl: [(cbaWw,
                       label: sat_sb7eY_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaWw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbaWD; else goto cbaWE;
       cbaWD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbaWE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbaWt_info;
           _sb7eO::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7eO::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubaWI; else goto cbaWu;
       ubaWI: // global
           call _cbaWt(R1) args: 0, res: 0, upd: 0;
       cbaWu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbaWt() //  [R1]
         { info_tbl: [(cbaWt,
                       label: block_cbaWt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaWt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbaWH; else goto cbaWG;
       cbaWH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbaWG: // global
           _sb7eS::P64 = P64[R1 + 7];
           _sb7eT::P64 = P64[R1 + 15];
           _sb7eR::I64 = I64[R1 + 23];
           _sb7eU::I64 = I64[R1 + 31];
           _sb7eW::I64 = I64[R1 + 47];
           _sb7eX::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7eS::P64;
           P64[Hp - 32] = _sb7eT::P64;
           I64[Hp - 24] = _sb7eR::I64;
           I64[Hp - 16] = _sb7eU::I64;
           I64[Hp - 8] = _sb7eX::I64;
           I64[Hp] = _sb7eW::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7fj_entry() //  [R1, R2]
         { info_tbl: [(cbaWJ,
                       label: sat_sb7fj_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaWJ: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cbaWK; else goto cbaWL;
       cbaWK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbaWL: // global
           I64[Sp - 32] = block_cbaVu_info;
           _sb7dB::P64 = P64[R1 + 6];
           _sb7dG::P64 = P64[R1 + 14];
           _sb7dE::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb7dB::P64;
           I64[Sp - 16] = _sb7dE::I64;
           P64[Sp - 8] = _sb7dG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubaYf; else goto cbaVv;
       ubaYf: // global
           call _cbaVu(R1) args: 0, res: 0, upd: 0;
       cbaVv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaVu() //  [R1]
         { info_tbl: [(cbaVu,
                       label: block_cbaVu_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaVu: // global
           I64[Sp - 40] = block_cbaVz_info;
           _sb7dJ::P64 = R1;
           _sb7dP::P64 = P64[R1 + 47];
           _sb7dR::P64 = P64[R1 + 63];
           _sb7dS::P64 = P64[R1 + 71];
           _sb7dV::P64 = P64[R1 + 95];
           R1 = P64[_sb7dS::P64 + 8];
           P64[Sp - 32] = _sb7dP::P64;
           P64[Sp - 24] = _sb7dR::P64;
           P64[Sp - 16] = _sb7dS::P64;
           P64[Sp - 8] = _sb7dV::P64;
           P64[Sp] = _sb7dJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubaY5; else goto cbaVA;
       ubaY5: // global
           call _cbaVz(R1) args: 0, res: 0, upd: 0;
       cbaVA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaVz() //  [R1]
         { info_tbl: [(cbaVz,
                       label: block_cbaVz_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaVz: // global
           I64[Sp - 16] = block_cbaVG_info;
           _sb7e8::I64 = I64[R1 + 39];
           _sb7e9::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sb7e9::I64;
           I64[Sp] = _sb7e8::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubaY6; else goto cbaVH;
       ubaY6: // global
           call _cbaVG(R1) args: 0, res: 0, upd: 0;
       cbaVH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaVG() //  [R1]
         { info_tbl: [(cbaVG,
                       label: block_cbaVG_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaVG: // global
           if (R1 & 7 == 1) goto cbaXJ; else goto ubaY0;
       cbaXJ: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubaY1; else goto cbaX5;
       ubaY1: // global
           Sp = Sp + 24;
           goto ubaY9;
       cbaX5: // global
           _sb7er::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cbaVO_info;
           R1 = _sb7er::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubaY7; else goto cbaVP;
       ubaY7: // global
           call _cbaVO(R1) args: 0, res: 0, upd: 0;
       cbaVP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubaY0: // global
           Sp = Sp + 24;
           goto ubaY9;
       ubaY9: // global
           call _sb7ea() args: 0, res: 0, upd: 0;
     }
 },
 _cbaVO() //  [R1]
         { info_tbl: [(cbaVO,
                       label: block_cbaVO_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaVO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbaX8; else goto cbaX7;
       cbaX8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaX7: // global
           _sb7dS::P64 = P64[Sp + 24];
           _sb7et::P64 = P64[R1 + 7];
           _sb7eu::P64 = P64[R1 + 15];
           _sb7ex::P64 = P64[_sb7dS::P64 + 8];
           I64[Hp - 16] = sat_sb7eF_info;
           P64[Hp] = _sb7ex::P64;
           call MO_WriteBarrier();
           P64[_sb7dS::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dS::P64);
           I64[Sp] = block_cbaWd_info;
           R1 = _sb7ex::P64;
           P64[Sp + 16] = _sb7eu::P64;
           P64[Sp + 24] = _sb7et::P64;
           if (R1 & 7 != 0) goto ubaYa; else goto cbaWe;
       ubaYa: // global
           call _cbaWd(R1) args: 0, res: 0, upd: 0;
       cbaWe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaWd() //  [R1]
         { info_tbl: [(cbaWd,
                       label: block_cbaWd_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaWd: // global
           _sb7eO::I64 = I64[R1 + 39];
           if (_sb7eO::I64 != 0) goto cbaXb; else goto cbaXG;
       cbaXb: // global
           I64[Sp - 24] = block_cbaWk_info;
           _sb7eJ::P64 = P64[R1 + 7];
           _sb7eK::P64 = P64[R1 + 15];
           _sb7eI::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sb7eK::P64;
           I64[Sp - 8] = _sb7eO::I64;
           P64[Sp] = _sb7eJ::P64;
           I64[Sp + 32] = _sb7eI::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubaYb; else goto cbaWl;
       ubaYb: // global
           call _cbaWk(R1) args: 0, res: 0, upd: 0;
       cbaWl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbaXG: // global
           _sb7dP::P64 = P64[Sp + 8];
           _sb7eu::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sb7dP::P64 + 8] = _sb7eu::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dP::P64);
           Sp = Sp + 8;
           call _sb7ea() args: 0, res: 0, upd: 0;
     }
 },
 _cbaWk() //  [R1]
         { info_tbl: [(cbaWk,
                       label: block_cbaWk_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaWk: // global
           if (R1 & 7 == 1) goto cbaXd; else goto cbaXv;
       cbaXd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbaXg; else goto cbaXf;
       cbaXg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaXf: // global
           I64[Hp - 24] = sat_sb7eY_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sb7dP::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sb7dP::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dP::P64);
           Sp = Sp + 32;
           call _sb7ea() args: 0, res: 0, upd: 0;
       cbaXv: // global
           I64[Sp] = block_cbaXj_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubaYd; else goto cbaXk;
       ubaYd: // global
           call _cbaXj(R1) args: 0, res: 0, upd: 0;
       cbaXk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaXj() //  [R1]
         { info_tbl: [(cbaXj,
                       label: block_cbaXj_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaXj: // global
           I64[Sp - 8] = block_cbaXo_info;
           R2 = P64[Sp + 48];
           _sb7f2::P64 = P64[R1 + 7];
           _sb7f3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sb7f3::P64;
           P64[Sp + 48] = _sb7f2::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaXo() //  [R1]
         { info_tbl: [(cbaXo,
                       label: block_cbaXo_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaXo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbaXz; else goto cbaXy;
       cbaXz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaXy: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cbaXr_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbaXr() //  [R1]
         { info_tbl: [(cbaXr,
                       label: block_cbaXr_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaXr: // global
           I64[Sp] = block_cbaXt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubaYg; else goto cbaXB;
       ubaYg: // global
           call _cbaXt(R1) args: 0, res: 0, upd: 0;
       cbaXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaXt() //  [R1]
         { info_tbl: [(cbaXt,
                       label: block_cbaXt_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaXt: // global
           _sb7dP::P64 = P64[Sp + 8];
           _sb7ff::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sb7dP::P64 + 8] = _sb7ff::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7dP::P64);
           Sp = Sp + 8;
           call _sb7ea() args: 0, res: 0, upd: 0;
     }
 },
 _sb7ea() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7ea: // global
           _sb7ee::P64 = P64[P64[Sp] + 8];
           I64[Sp + 24] = block_cbaWR_info;
           R1 = _sb7ee::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubaYi; else goto cbaWT;
       ubaYi: // global
           call _cbaWR(R1) args: 0, res: 0, upd: 0;
       cbaWT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaWR() //  [R1]
         { info_tbl: [(cbaWR,
                       label: block_cbaWR_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaWR: // global
           _sb7dB::P64 = P64[Sp + 16];
           _sb7dJ::P64 = P64[Sp + 8];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbaX2; else goto cbaX1;
       cbaX2: // global
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7dB::P64;
           R3 = I64[R1 + 31];
           R2 = _sb7dJ::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cbaX1: // global
           R6 = P64[Sp + 32];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7dB::P64;
           R3 = R1;
           R2 = _sb7dJ::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubaYu_srtd" {
     ubaYu_srtd:
         const Sb7vQ_srt+8;
         const 41;
         const 1700807051265;
 },
 GHC.IO.Handle.Text.$whGetBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cbaYm,
                       label: GHC.IO.Handle.Text.$whGetBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaYm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbaYq; else goto cbaYp;
       cbaYq: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBufNonBlocking_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbaYp: // global
           if (R4 == 0) goto cbaYl; else goto cbaYk;
       cbaYl: // global
           Hp = Hp - 48;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbaYk: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cbaYs; else goto cbaYt;
       cbaYs: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sb7fj_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = R4;
           R4 = Hp - 22;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cbaYt: // global
           Hp = Hp - 48;
           R4 = R4;
           R3 = GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.944240039 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking1_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking1_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbb08,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb08: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbb09; else goto cbb0a;
       cbb09: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufNonBlocking1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbb0a: // global
           I64[Sp - 24] = block_cbb05_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubb0e; else goto cbb06;
       ubb0e: // global
           call _cbb05(R1) args: 0, res: 0, upd: 0;
       cbb06: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbb05() //  [R1]
         { info_tbl: [(cbb05,
                       label: block_cbb05_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb05: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBufNonBlocking_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.949737854 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cbb0s,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb0s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBufNonBlocking1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.952870317 UTC

[section ""cstring" . lvl12_rb6WS_bytes" {
     lvl12_rb6WS_bytes:
         I8[] [104,71,101,116,66,117,102,83,111,109,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.954720028 UTC

[section ""data" . lvl13_rb6WT_closure" {
     lvl13_rb6WT_closure:
         const lvl13_rb6WT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rb6WT_entry() //  [R1]
         { info_tbl: [(cbb0G,
                       label: lvl13_rb6WT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb0G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbb0H; else goto cbb0I;
       cbb0H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbb0I: // global
           (_cbb0D::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbb0D::I64 == 0) goto cbb0F; else goto cbb0E;
       cbb0F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbb0E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbb0D::I64;
           R2 = lvl12_rb6WS_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:03.96234239 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBufSome_closure" {
     GHC.IO.Handle.Text.$whGetBufSome_closure:
         const GHC.IO.Handle.Text.$whGetBufSome_info;
         const 0;
 },
 sat_sb7gT_entry() //  [R1]
         { info_tbl: [(cbb1F,
                       label: sat_sb7gT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb1F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbb1J; else goto cbb1K;
       cbb1J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbb1K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbb1C_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubb1O; else goto cbb1D;
       ubb1O: // global
           call _cbb1C(R1) args: 0, res: 0, upd: 0;
       cbb1D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbb1C() //  [R1]
         { info_tbl: [(cbb1C,
                       label: block_cbb1C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb1C: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbb1N; else goto cbb1M;
       cbb1N: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbb1M: // global
           _sb7gO::P64 = P64[R1 + 7];
           _sb7gP::P64 = P64[R1 + 15];
           _sb7gN::I64 = I64[R1 + 23];
           _sb7gQ::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7gO::P64;
           P64[Hp - 32] = _sb7gP::P64;
           I64[Hp - 24] = _sb7gN::I64;
           I64[Hp - 16] = _sb7gQ::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7hc_entry() //  [R1]
         { info_tbl: [(cbb2b,
                       label: sat_sb7hc_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb2b: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbb2i; else goto cbb2j;
       cbb2i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbb2j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbb28_info;
           _sb7h2::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7h2::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubb2n; else goto cbb29;
       ubb2n: // global
           call _cbb28(R1) args: 0, res: 0, upd: 0;
       cbb29: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbb28() //  [R1]
         { info_tbl: [(cbb28,
                       label: block_cbb28_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb28: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbb2m; else goto cbb2l;
       cbb2m: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbb2l: // global
           _sb7h6::P64 = P64[R1 + 7];
           _sb7h7::P64 = P64[R1 + 15];
           _sb7h5::I64 = I64[R1 + 23];
           _sb7h8::I64 = I64[R1 + 31];
           _sb7ha::I64 = I64[R1 + 47];
           _sb7hb::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7h6::P64;
           P64[Hp - 32] = _sb7h7::P64;
           I64[Hp - 24] = _sb7h5::I64;
           I64[Hp - 16] = _sb7h8::I64;
           I64[Hp - 8] = _sb7hb::I64;
           I64[Hp] = _sb7ha::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubb5t_srtd" {
     ubb5t_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 sat_sb7hx_entry() //  [R1, R2]
         { info_tbl: [(cbb2o,
                       label: sat_sb7hx_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb2o: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cbb2p; else goto cbb2q;
       cbb2p: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbb2q: // global
           I64[Sp - 32] = block_cbb15_info;
           _sb7fr::P64 = P64[R1 + 6];
           _sb7fw::P64 = P64[R1 + 14];
           _sb7fu::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb7fr::P64;
           I64[Sp - 16] = _sb7fu::I64;
           P64[Sp - 8] = _sb7fw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubb59; else goto cbb16;
       ubb59: // global
           call _cbb15(R1) args: 0, res: 0, upd: 0;
       cbb16: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5u_srtd" {
     ubb5u_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb15() //  [R1]
         { info_tbl: [(cbb15,
                       label: block_cbb15_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb15: // global
           I64[Sp - 56] = block_cbb1a_info;
           _sb7fz::P64 = R1;
           _sb7fB::P64 = P64[R1 + 15];
           _sb7fC::P64 = P64[R1 + 23];
           _sb7fF::P64 = P64[R1 + 47];
           _sb7fH::P64 = P64[R1 + 63];
           _sb7fI::P64 = P64[R1 + 71];
           _sb7fL::P64 = P64[R1 + 95];
           R1 = P64[R1 + 31];
           P64[Sp - 48] = _sb7fB::P64;
           P64[Sp - 40] = _sb7fC::P64;
           P64[Sp - 32] = _sb7fF::P64;
           P64[Sp - 24] = _sb7fH::P64;
           P64[Sp - 16] = _sb7fI::P64;
           P64[Sp - 8] = _sb7fL::P64;
           P64[Sp] = _sb7fz::P64;
           Sp = Sp - 56;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5v_srtd" {
     ubb5v_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb1a() //  [R1]
         { info_tbl: [(cbb1a,
                       label: block_cbb1a_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb1a: // global
           _sb7fV::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 24] = block_cbb1e_info;
           _sb7fQ::P64 = R1;
           _sb7fR::I64 = I64[R1 + 7];
           _sb7fS::I64 = I64[R1 + 15];
           R1 = _sb7fV::P64;
           I64[Sp - 16] = _sb7fR::I64;
           I64[Sp - 8] = _sb7fS::I64;
           P64[Sp] = _sb7fQ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubb4Z; else goto cbb1f;
       ubb4Z: // global
           call _cbb1e(R1) args: 0, res: 0, upd: 0;
       cbb1f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5w_srtd" {
     ubb5w_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb1e() //  [R1]
         { info_tbl: [(cbb1e,
                       label: block_cbb1e_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb1e: // global
           I64[Sp - 16] = block_cbb1l_info;
           _sb7g1::I64 = I64[R1 + 39];
           _sb7g2::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sb7g2::I64;
           I64[Sp] = _sb7g1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubb50; else goto cbb1m;
       ubb50: // global
           call _cbb1l(R1) args: 0, res: 0, upd: 0;
       cbb1m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5x_srtd" {
     ubb5x_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb1l() //  [R1]
         { info_tbl: [(cbb1l,
                       label: block_cbb1l_info
                       rep:StackRep [True, True, True, True, False, False, False, False,
                                     False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb1l: // global
           if (R1 & 7 == 1) goto cbb4z; else goto ubb4S;
       cbb4z: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubb4T; else goto cbb3V;
       ubb4T: // global
           Sp = Sp + 24;
           goto ubb53;
       cbb3V: // global
           _sb7gF::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cbb1t_info;
           R1 = _sb7gF::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubb51; else goto cbb1u;
       ubb51: // global
           call _cbb1t(R1) args: 0, res: 0, upd: 0;
       cbb1u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubb4S: // global
           Sp = Sp + 24;
           goto ubb53;
       ubb53: // global
           call _sb7g3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubb5y_srtd" {
     ubb5y_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb1t() //  [R1]
         { info_tbl: [(cbb1t,
                       label: block_cbb1t_info
                       rep:StackRep [True, True, False, False, False, False, True, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb1t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbb3Y; else goto cbb3X;
       cbb3Y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbb3X: // global
           _sb7fI::P64 = P64[Sp + 64];
           _sb7gH::P64 = P64[R1 + 7];
           _sb7gI::P64 = P64[R1 + 15];
           _sb7gL::P64 = P64[_sb7fI::P64 + 8];
           I64[Hp - 16] = sat_sb7gT_info;
           P64[Hp] = _sb7gL::P64;
           call MO_WriteBarrier();
           P64[_sb7fI::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fI::P64);
           I64[Sp] = block_cbb1S_info;
           R1 = _sb7gL::P64;
           P64[Sp + 56] = _sb7gI::P64;
           P64[Sp + 64] = _sb7gH::P64;
           if (R1 & 7 != 0) goto ubb54; else goto cbb1T;
       ubb54: // global
           call _cbb1S(R1) args: 0, res: 0, upd: 0;
       cbb1T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5z_srtd" {
     ubb5z_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb1S() //  [R1]
         { info_tbl: [(cbb1S,
                       label: block_cbb1S_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb1S: // global
           _sb7h2::I64 = I64[R1 + 39];
           if (_sb7h2::I64 != 0) goto cbb41; else goto cbb4w;
       cbb41: // global
           I64[Sp - 24] = block_cbb1Z_info;
           _sb7gX::P64 = P64[R1 + 7];
           _sb7gY::P64 = P64[R1 + 15];
           _sb7gW::I64 = I64[R1 + 23];
           R1 = P64[Sp + 72];
           P64[Sp - 16] = _sb7gY::P64;
           I64[Sp - 8] = _sb7h2::I64;
           P64[Sp] = _sb7gX::P64;
           I64[Sp + 72] = _sb7gW::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubb55; else goto cbb20;
       ubb55: // global
           call _cbb1Z(R1) args: 0, res: 0, upd: 0;
       cbb20: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbb4w: // global
           _sb7fF::P64 = P64[Sp + 48];
           _sb7gI::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = _sb7gI::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           Sp = Sp + 8;
           call _sb7g3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubb5A_srtd" {
     ubb5A_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb1Z() //  [R1]
         { info_tbl: [(cbb1Z,
                       label: block_cbb1Z_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb1Z: // global
           if (R1 & 7 == 1) goto cbb43; else goto cbb4l;
       cbb43: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbb46; else goto cbb45;
       cbb46: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbb45: // global
           I64[Hp - 24] = sat_sb7hc_info;
           P64[Hp - 8] = P64[Sp + 80];
           I64[Hp] = I64[Sp + 16];
           _sb7fF::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           Sp = Sp + 32;
           call _sb7g3() args: 0, res: 0, upd: 0;
       cbb4l: // global
           I64[Sp] = block_cbb49_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubb57; else goto cbb4a;
       ubb57: // global
           call _cbb49(R1) args: 0, res: 0, upd: 0;
       cbb4a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5B_srtd" {
     ubb5B_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb49() //  [R1]
         { info_tbl: [(cbb49,
                       label: block_cbb49_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb49: // global
           I64[Sp - 8] = block_cbb4e_info;
           R2 = P64[Sp + 88];
           _sb7hg::P64 = P64[R1 + 7];
           _sb7hh::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sb7hh::P64;
           P64[Sp + 88] = _sb7hg::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5C_srtd" {
     ubb5C_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb4e() //  [R1]
         { info_tbl: [(cbb4e,
                       label: block_cbb4e_info
                       rep:StackRep [False, False, True, False, True, True, False, False,
                                     False, False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb4e: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbb4p; else goto cbb4o;
       cbb4p: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbb4o: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 104];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cbb4h_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 88];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 96];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5D_srtd" {
     ubb5D_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb4h() //  [R1]
         { info_tbl: [(cbb4h,
                       label: block_cbb4h_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb4h: // global
           I64[Sp] = block_cbb4j_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubb5f; else goto cbb4r;
       ubb5f: // global
           call _cbb4j(R1) args: 0, res: 0, upd: 0;
       cbb4r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5E_srtd" {
     ubb5E_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb4j() //  [R1]
         { info_tbl: [(cbb4j,
                       label: block_cbb4j_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb4j: // global
           _sb7fF::P64 = P64[Sp + 48];
           _sb7ht::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = _sb7ht::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           Sp = Sp + 8;
           call _sb7g3() args: 0, res: 0, upd: 0;
     }
 },
 _sb7g3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7g3: // global
           _sb7g7::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 8] = block_cbb2x_info;
           R1 = _sb7g7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubb5h; else goto cbb2z;
       ubb5h: // global
           call _cbb2x(R1) args: 0, res: 0, upd: 0;
       cbb2z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubb5F_srtd" {
     ubb5F_srtd:
         const Sb7vQ_srt+56;
         const 38;
         const 210990268417;
 },
 _cbb2x() //  [R1]
         { info_tbl: [(cbb2x,
                       label: block_cbb2x_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb2x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbb2F; else goto cbb2E;
       cbb2F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbb2E: // global
           _sb7fu::I64 = I64[Sp + 96];
           _sb7gd::I64 = I64[R1 + 39];
           _sb7ge::I64 = I64[R1 + 47];
           if (_sb7gd::I64 == _sb7ge::I64) goto cbb3S; else goto cbb2U;
       cbb3S: // global
           if (%MO_S_Le_W64(_sb7fu::I64,
                            I64[R1 + 31])) goto cbb3x; else goto cbb3B;
       cbb3x: // global
           Hp = Hp - 16;
           P64[Sp + 72] = R1;
           Sp = Sp + 24;
           call _sb7gj() args: 0, res: 0, upd: 0;
       cbb3B: // global
           Hp = Hp - 16;
           I64[Sp] = block_cbb3A_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 40];
           P64[Sp + 72] = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
       cbb2U: // global
           _sb7fr::P64 = P64[Sp + 88];
           _sb7fz::P64 = P64[Sp + 80];
           _sb7gg::I64 = _sb7ge::I64 - _sb7gd::I64;
           if (%MO_S_Gt_W64(_sb7fu::I64,
                            _sb7gg::I64)) goto cbb2R; else goto cbb2S;
       cbb2R: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7gg::I64;
           R6 = Hp - 7;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = R1;
           R2 = _sb7fz::P64;
           Sp = Sp + 112;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cbb2S: // global
           Hp = Hp - 16;
           R6 = P64[Sp + 104];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = R1;
           R2 = _sb7fz::P64;
           Sp = Sp + 112;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbb3A() //  [R1]
         { info_tbl: [(cbb3A,
                       label: block_cbb3A_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb3A: // global
           if (R1 & 7 == 1) goto ubb4Y; else goto cbb3M;
       ubb4Y: // global
           Sp = Sp + 24;
           call _sb7gj() args: 0, res: 0, upd: 0;
       cbb3M: // global
           I64[Sp] = block_cbb3K_info;
           R1 = P64[Sp + 88];
           if (R1 & 7 != 0) goto ubb5d; else goto cbb3N;
       ubb5d: // global
           call _cbb3K(R1) args: 0, res: 0, upd: 0;
       cbb3N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _sb7gj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7gj: // global
           I64[Sp + 16] = block_cbb31_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp + 8] = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbb31() //  [R1]
         { info_tbl: [(cbb31,
                       label: block_cbb31_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb31: // global
           I64[Sp] = block_cbb33_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubb5b; else goto cbb34;
       ubb5b: // global
           call _cbb33(R1) args: 0, res: 0, upd: 0;
       cbb34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbb33() //  [R1]
         { info_tbl: [(cbb33,
                       label: block_cbb33_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb33: // global
           I64[Sp] = block_cbb38_info;
           _sb7gq::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 32] = _sb7gq::P64;
           if (R1 & 7 != 0) goto ubb5c; else goto cbb3c;
       ubb5c: // global
           call _cbb38(R1) args: 0, res: 0, upd: 0;
       cbb3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbb38() //  [R1]
         { info_tbl: [(cbb38,
                       label: block_cbb38_info
                       rep:StackRep [False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb38: // global
           _sb7gt::I64 = I64[R1 + 7];
           if (_sb7gt::I64 == 0) goto cbb3t; else goto cbb3s;
       cbb3t: // global
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbb3s: // global
           _sb7fr::P64 = P64[Sp + 48];
           _sb7fu::I64 = I64[Sp + 56];
           _sb7fw::P64 = P64[Sp + 64];
           _sb7fz::P64 = P64[Sp + 40];
           _sb7fF::P64 = P64[Sp + 8];
           _sb7gq::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sb7fF::P64 + 8] = _sb7gq::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7fF::P64);
           if (%MO_S_Gt_W64(_sb7gt::I64,
                            _sb7fu::I64)) goto cbb3p; else goto cbb3q;
       cbb3p: // global
           R6 = _sb7fw::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = _sb7gq::P64;
           R2 = _sb7fz::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cbb3q: // global
           R6 = R1;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7fr::P64;
           R3 = _sb7gq::P64;
           R2 = _sb7fz::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbb3K() //  [R1]
         { info_tbl: [(cbb3K,
                       label: block_cbb3K_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb3K: // global
           R6 = 0;
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 104] = I64[Sp + 96];
           Sp = Sp + 104;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubb5G_srtd" {
     ubb5G_srtd:
         const Sb7vQ_srt+8;
         const 46;
         const 66279935313985;
 },
 GHC.IO.Handle.Text.$whGetBufSome_entry() //  [R2, R3, R4]
         { info_tbl: [(cbb5l,
                       label: GHC.IO.Handle.Text.$whGetBufSome_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb5l: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbb5p; else goto cbb5o;
       cbb5p: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBufSome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbb5o: // global
           if (R4 == 0) goto cbb5k; else goto cbb5j;
       cbb5k: // global
           Hp = Hp - 48;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbb5j: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cbb5r; else goto cbb5s;
       cbb5r: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sb7hx_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = R4;
           R4 = Hp - 22;
           R3 = R2;
           R2 = lvl13_rb6WT_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cbb5s: // global
           Hp = Hp - 48;
           R4 = R4;
           R3 = lvl13_rb6WT_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.024787208 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufSome1_closure" {
     GHC.IO.Handle.Text.hGetBufSome1_closure:
         const GHC.IO.Handle.Text.hGetBufSome1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufSome1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbb81,
                       label: GHC.IO.Handle.Text.hGetBufSome1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb81: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbb82; else goto cbb83;
       cbb82: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufSome1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbb83: // global
           I64[Sp - 24] = block_cbb7Y_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubb87; else goto cbb7Z;
       ubb87: // global
           call _cbb7Y(R1) args: 0, res: 0, upd: 0;
       cbb7Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbb7Y() //  [R1]
         { info_tbl: [(cbb7Y,
                       label: block_cbb7Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb7Y: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBufSome_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.030204692 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufSome_closure" {
     GHC.IO.Handle.Text.hGetBufSome_closure:
         const GHC.IO.Handle.Text.hGetBufSome_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufSome_entry() //  [R2, R3, R4]
         { info_tbl: [(cbb8l,
                       label: GHC.IO.Handle.Text.hGetBufSome_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb8l: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBufSome1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.03776466 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf4_closure" {
     GHC.IO.Handle.Text.hGetBuf4_closure:
         const GHC.IO.Handle.Text.hGetBuf4_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbb8z,
                       label: GHC.IO.Handle.Text.hGetBuf4_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb8z: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbb8N; else goto cbb8O;
       cbb8N: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbb8O: // global
           I64[Sp - 40] = block_cbb8w_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubbaj; else goto cbb8x;
       ubbaj: // global
           call _cbb8w(R1) args: 0, res: 0, upd: 0;
       cbb8x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbb8w() //  [R1]
         { info_tbl: [(cbb8w,
                       label: block_cbb8w_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb8w: // global
           I64[Sp - 8] = block_cbb8C_info;
           _sb7hK::P64 = R1;
           _sb7hQ::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb7hQ::P64;
           P64[Sp + 8] = _sb7hK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbai; else goto cbb8D;
       ubbai: // global
           call _cbb8C(R1) args: 0, res: 0, upd: 0;
       cbb8D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbb8C() //  [R1]
         { info_tbl: [(cbb8C,
                       label: block_cbb8C_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb8C: // global
           I64[Sp - 40] = block_cbb8H_info;
           _sb7i3::P64 = P64[R1 + 7];
           _sb7i4::P64 = P64[R1 + 15];
           _sb7i2::I64 = I64[R1 + 23];
           _sb7i5::I64 = I64[R1 + 31];
           _sb7i6::I64 = I64[R1 + 39];
           _sb7i7::I64 = I64[R1 + 47];
           R1 = P64[Sp + 32];
           P64[Sp - 32] = _sb7i4::P64;
           I64[Sp - 24] = _sb7i5::I64;
           I64[Sp - 16] = _sb7i6::I64;
           I64[Sp - 8] = _sb7i7::I64;
           P64[Sp] = _sb7i3::P64;
           I64[Sp + 32] = _sb7i2::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubbak; else goto cbb8I;
       ubbak: // global
           call _cbb8H(R1) args: 0, res: 0, upd: 0;
       cbb8I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbb8H() //  [R1]
         { info_tbl: [(cbb8H,
                       label: block_cbb8H_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb8H: // global
           I64[Sp] = block_cbb8M_info;
           _sb7i9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 80];
           I64[Sp + 80] = _sb7i9::I64;
           if (R1 & 7 != 0) goto ubbal; else goto cbb8S;
       ubbal: // global
           call _cbb8M(R1) args: 0, res: 0, upd: 0;
       cbb8S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbb8M() //  [R1]
         { info_tbl: [(cbb8M,
                       label: block_cbb8M_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb8M: // global
           _sb7hG::P64 = P64[Sp + 64];
           _sb7ib::I64 = I64[R1 + 7];
           _sb7ic::I64 = I64[Sp + 32] - I64[Sp + 24];
           if (%MO_S_Ge_W64(_sb7ib::I64,
                            _sb7ic::I64)) goto cbb95; else goto cbbae;
       cbb95: // global
           I64[Sp] = block_cbb93_info;
           R1 = _sb7hG::P64;
           I64[Sp + 32] = _sb7ic::I64;
           I64[Sp + 64] = _sb7ib::I64;
           if (R1 & 7 != 0) goto ubbam; else goto cbb96;
       ubbam: // global
           call _cbb93(R1) args: 0, res: 0, upd: 0;
       cbb96: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbae: // global
           I64[Sp] = block_cbb9N_info;
           R1 = _sb7hG::P64;
           I64[Sp + 64] = _sb7ib::I64;
           if (R1 & 7 != 0) goto ubban; else goto cbb9O;
       ubban: // global
           call _cbb9N(R1) args: 0, res: 0, upd: 0;
       cbb9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbb93() //  [R1]
         { info_tbl: [(cbb93,
                       label: block_cbb93_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb93: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbb9c; else goto cbb9b;
       cbb9c: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbb9b: // global
           _sb7hK::P64 = P64[Sp + 56];
           _sb7hQ::P64 = P64[Sp + 48];
           _sb7i2::I64 = I64[Sp + 72];
           _sb7i3::P64 = P64[Sp + 40];
           _sb7i4::P64 = P64[Sp + 8];
           _sb7i5::I64 = I64[Sp + 16];
           _sb7i9::I64 = I64[Sp + 80];
           _sb7ib::I64 = I64[Sp + 64];
           _sb7ic::I64 = I64[Sp + 32];
           _sb7if::I64 = I64[R1 + 7];
           (_sb7il::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sb7if::I64, _sb7i2::I64 + I64[Sp + 24], _sb7ic::I64);
           call MO_Touch(_sb7i3::P64);
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sb7i3::P64;
           P64[Hp - 80] = _sb7i4::P64;
           I64[Hp - 72] = _sb7i2::I64;
           I64[Hp - 64] = _sb7i5::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           call MO_WriteBarrier();
           _cbb9o::P64 = Hp - 95;
           P64[_sb7hQ::P64 + 8] = _cbb9o::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7hQ::P64);
           _sb7ip::I64 = _sb7ib::I64 - _sb7ic::I64;
           if (_sb7ip::I64 != 0) goto cbb9F; else goto cbb9L;
       cbb9F: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sb7ip::I64;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _sb7i9::I64 + _sb7ic::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sb7if::I64 + _sb7ic::I64;
           R6 = Hp - 39;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = _cbb9o::P64;
           R2 = _sb7hK::P64;
           Sp = Sp + 88;
           call GHC.IO.Handle.Text.hGetBuf2_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cbb9L: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sb7i9::I64 + _sb7ic::I64;
           _cbb9K::P64 = Hp - 39;
           Hp = Hp - 32;
           R1 = _cbb9K::P64;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbb9N() //  [R1]
         { info_tbl: [(cbb9N,
                       label: block_cbb9N_info
                       rep:StackRep [False, True, True, True, False, False, True, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbb9N: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbbah; else goto cbbag;
       cbbah: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbag: // global
           _sb7hQ::P64 = P64[Sp + 48];
           _sb7i2::I64 = I64[Sp + 72];
           _sb7i3::P64 = P64[Sp + 40];
           _sb7i4::P64 = P64[Sp + 8];
           _sb7i5::I64 = I64[Sp + 16];
           _sb7i6::I64 = I64[Sp + 24];
           _sb7i7::I64 = I64[Sp + 32];
           _sb7i9::I64 = I64[Sp + 80];
           _sb7ib::I64 = I64[Sp + 64];
           (_sb7iE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[R1 + 7], _sb7i2::I64 + _sb7i6::I64, _sb7ib::I64);
           call MO_Touch(_sb7i3::P64);
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = _sb7i3::P64;
           P64[Hp - 48] = _sb7i4::P64;
           I64[Hp - 40] = _sb7i2::I64;
           I64[Hp - 32] = _sb7i5::I64;
           I64[Hp - 24] = _sb7i6::I64 + _sb7ib::I64;
           I64[Hp - 16] = _sb7i7::I64;
           call MO_WriteBarrier();
           P64[_sb7hQ::P64 + 8] = Hp - 63;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7hQ::P64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7i9::I64 + _sb7ib::I64;
           R1 = Hp - 7;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Text.hGetBuf2_closure" {
     GHC.IO.Handle.Text.hGetBuf2_closure:
         const GHC.IO.Handle.Text.hGetBuf2_info;
         const 0;
 },
 sat_sb7jB_entry() //  [R1]
         { info_tbl: [(cbbbP,
                       label: sat_sb7jB_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbbP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbbbW; else goto cbbbX;
       cbbbW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbbX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbbbM_info;
           _sb7jw::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7jw::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubbc1; else goto cbbbN;
       ubbc1: // global
           call _cbbbM(R1) args: 0, res: 0, upd: 0;
       cbbbN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbbbM() //  [R1]
         { info_tbl: [(cbbbM,
                       label: block_cbbbM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbbM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbbc0; else goto cbbbZ;
       cbbc0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbbbZ: // global
           _sb7jA::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7jA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7jF_entry() //  [R1]
         { info_tbl: [(cbbc9,
                       label: sat_sb7jF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbc9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbbca; else goto cbbcb;
       cbbca: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbcb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.$fNumInt_$c+_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubbdC_srtd" {
     ubbdC_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 6807523164161;
 },
 GHC.IO.Handle.Text.hGetBuf2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbbcc,
                       label: GHC.IO.Handle.Text.hGetBuf2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbcc: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cbbcd; else goto cbbce;
       cbbcd: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbbce: // global
           I64[Sp - 40] = block_cbbas_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubbdz; else goto cbbat;
       ubbdz: // global
           call _cbbas(R1) args: 0, res: 0, upd: 0;
       cbbat: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbdD_srtd" {
     ubbdD_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 4608499908609;
 },
 _cbbas() //  [R1]
         { info_tbl: [(cbbas,
                       label: block_cbbas_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbas: // global
           I64[Sp - 32] = block_cbbax_info;
           _sb7iR::P64 = R1;
           _sb7iT::P64 = P64[R1 + 15];
           _sb7iU::P64 = P64[R1 + 23];
           _sb7iV::P64 = P64[R1 + 31];
           _sb7iX::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sb7iU::P64;
           P64[Sp - 16] = _sb7iV::P64;
           P64[Sp - 8] = _sb7iX::P64;
           P64[Sp] = _sb7iT::P64;
           P64[Sp + 8] = _sb7iR::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubbdl; else goto cbbay;
       ubbdl: // global
           call _cbbax(R1) args: 0, res: 0, upd: 0;
       cbbay: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbdE_srtd" {
     ubbdE_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 4608499908609;
 },
 _cbbax() //  [R1]
         { info_tbl: [(cbbax,
                       label: block_cbbax_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbax: // global
           I64[Sp - 8] = block_cbbaC_info;
           _sb7j8::P64 = R1;
           _sb7jc::I64 = I64[R1 + 31];
           R1 = P64[Sp + 64];
           I64[Sp] = _sb7jc::I64;
           P64[Sp + 64] = _sb7j8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbdm; else goto cbbaD;
       ubbdm: // global
           call _cbbaC(R1) args: 0, res: 0, upd: 0;
       cbbaD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbdF_srtd" {
     ubbdF_srtd:
         const Sb7vQ_srt+56;
         const 43;
         const 4608499908609;
 },
 _cbbaC() //  [R1]
         { info_tbl: [(cbbaC,
                       label: block_cbbaC_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbaC: // global
           _sb7jg::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sb7jg::I64,
                            I64[Sp + 8])) goto ubbdd; else goto cbbcH;
       ubbdd: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sb7jh() args: 0, res: 0, upd: 0;
       cbbcH: // global
           I64[Sp] = block_cbbaN_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 16];
           I64[Sp + 8] = _sb7jg::I64;
           P64[Sp + 16] = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbaN() //  [R1]
         { info_tbl: [(cbbaN,
                       label: block_cbbaN_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbaN: // global
           if (R1 & 7 == 1) goto ubbde; else goto cbbd7;
       ubbde: // global
           Sp = Sp + 16;
           call _sb7jh() args: 0, res: 0, upd: 0;
       cbbd7: // global
           I64[Sp + 40] = I64[Sp + 8];
           P64[Sp + 48] = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           P64[Sp + 72] = P64[Sp + 24];
           Sp = Sp + 40;
           call _cbbaY() args: 0, res: 0, upd: 0;
     }
 },
 _sb7jh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7jh: // global
           I64[Sp - 8] = block_cbbcl_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 8];
           P64[Sp - 16] = P64[Sp + 56];
           Sp = Sp - 32;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbbcl() //  [R1]
         { info_tbl: [(cbbcl,
                       label: block_cbbcl_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbcl: // global
           I64[Sp] = block_cbbcn_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubbdA; else goto cbbco;
       ubbdA: // global
           call _cbbcn(R1) args: 0, res: 0, upd: 0;
       cbbco: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbcn() //  [R1]
         { info_tbl: [(cbbcn,
                       label: block_cbbcn_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbcn: // global
           I64[Sp] = block_cbbcs_info;
           _sb7jo::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 64] = _sb7jo::P64;
           if (R1 & 7 != 0) goto ubbdB; else goto cbbcw;
       ubbdB: // global
           call _cbbcs(R1) args: 0, res: 0, upd: 0;
       cbbcw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbcs() //  [R1]
         { info_tbl: [(cbbcs,
                       label: block_cbbcs_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbcs: // global
           _sb7iO::P64 = P64[Sp + 56];
           if (I64[R1 + 7] == 0) goto cbbcE; else goto cbbcD;
       cbbcE: // global
           R1 = _sb7iO::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbbcD: // global
           _sb7iN::P64 = P64[Sp + 48];
           _sb7iR::P64 = P64[Sp + 40];
           _sb7iX::P64 = P64[Sp + 24];
           _sb7jf::P64 = P64[Sp + 8];
           _sb7jo::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sb7iX::P64 + 8] = _sb7jo::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7iX::P64);
           R6 = _sb7jf::P64;
           R5 = _sb7iO::P64;
           R4 = _sb7iN::P64;
           R3 = _sb7jo::P64;
           R2 = _sb7iR::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBuf4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbbaY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbaY: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cbbcV; else goto cbbd6;
       cbbcV: // global
           I64[Sp - 8] = block_cbbb4_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbdq; else goto cbbb5;
       ubbdq: // global
           call _cbbb4(R1) args: 0, res: 0, upd: 0;
       cbbb5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbd6: // global
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 24;
           call _cbbc3() args: 0, res: 0, upd: 0;
     }
 },
 _cbbb4() //  [R1]
         { info_tbl: [(cbbb4,
                       label: block_cbbb4_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbb4: // global
           I64[Sp] = block_cbbb9_info;
           _sb7jN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sb7jN::I64;
           if (R1 & 7 != 0) goto ubbds; else goto cbbba;
       ubbds: // global
           call _cbbb9(R1) args: 0, res: 0, upd: 0;
       cbbba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbb9() //  [R1]
         { info_tbl: [(cbbb9,
                       label: block_cbbb9_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbb9: // global
           I64[Sp] = block_cbbbe_info;
           _sb7jP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sb7jP::I64;
           if (R1 & 7 != 0) goto ubbdt; else goto cbbbf;
       ubbdt: // global
           call _cbbbe(R1) args: 0, res: 0, upd: 0;
       cbbbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbbe() //  [R1]
         { info_tbl: [(cbbbe,
                       label: block_cbbbe_info
                       rep:StackRep [True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbbe: // global
           _sb7jT::I64 = I64[Sp + 16] + I64[Sp + 40];
           I64[Sp] = block_cbbbp_info;
           R6 = 0;
           R5 = _sb7jT::I64;
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 8] = I64[Sp + 8];
           P64[Sp + 16] = R1;
           Sp = Sp - 8;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbbbp() //  [R1]
         { info_tbl: [(cbbbp,
                       label: block_cbbbp_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbbp: // global
           I64[Sp] = block_cbbbr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubbdu; else goto cbbbs;
       ubbdu: // global
           call _cbbbr(R1) args: 0, res: 0, upd: 0;
       cbbbs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbbr() //  [R1]
         { info_tbl: [(cbbbr,
                       label: block_cbbbr_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbbr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbbd2; else goto cbbd1;
       cbbd2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbd1: // global
           _sb7jP::I64 = I64[Sp + 40];
           _sb7k0::I64 = I64[R1 + 7];
           if (_sb7k0::I64 != 0) goto cbbd4; else goto cbbd5;
       cbbd4: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sb7jP::I64 + _sb7k0::I64;
           P64[Sp + 40] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 7;
           I64[Sp + 8] = I64[Sp + 8] - _sb7k0::I64;
           Sp = Sp + 8;
           call _cbbaY() args: 0, res: 0, upd: 0;
       cbbd5: // global
           Hp = Hp - 16;
           I64[Sp + 40] = _sb7jP::I64;
           Sp = Sp + 32;
           call _cbbbG() args: 0, res: 0, upd: 0;
     }
 },
 _cbbbG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbbG: // global
           Hp = Hp + 32;
           _sb7jw::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cbbcP; else goto cbbcO;
       cbbcP: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cbbbF_info;
           R1 = _sb7jw::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbbcO: // global
           I64[Hp - 24] = sat_sb7jB_info;
           P64[Hp - 8] = P64[Sp];
           I64[Hp] = _sb7jw::I64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbbF() //  [R1]
         { info_tbl: [(cbbbF,
                       label: block_cbbbF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbbF: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cbbbG() args: 0, res: 0, upd: 0;
     }
 },
 _cbbc3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbc3: // global
           Hp = Hp + 32;
           _sb7jD::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cbbcS; else goto cbbcR;
       cbbcS: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cbbc2_info;
           R1 = _sb7jD::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbcR: // global
           I64[Hp - 24] = sat_sb7jF_info;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = _sb7jD::P64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbc2() //  [R1]
         { info_tbl: [(cbbc2,
                       label: block_cbbc2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbc2: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cbbc3() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.098518161 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetBuf6_bytes" {
     GHC.IO.Handle.Text.hGetBuf6_bytes:
         I8[] [104,71,101,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.10047065 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf5_closure" {
     GHC.IO.Handle.Text.hGetBuf5_closure:
         const GHC.IO.Handle.Text.hGetBuf5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf5_entry() //  [R1]
         { info_tbl: [(cbbgh,
                       label: GHC.IO.Handle.Text.hGetBuf5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbgh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbbgi; else goto cbbgj;
       cbbgi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbgj: // global
           (_cbbge::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbge::I64 == 0) goto cbbgg; else goto cbbgf;
       cbbgg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbgf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbge::I64;
           R2 = GHC.IO.Handle.Text.hGetBuf6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.107136602 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBuf_closure" {
     GHC.IO.Handle.Text.$whGetBuf_closure:
         const GHC.IO.Handle.Text.$whGetBuf_info;
         const 0;
 },
 sat_sb7l9_entry() //  [R1]
         { info_tbl: [(cbbhc,
                       label: sat_sb7l9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbhc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbbhg; else goto cbbhh;
       cbbhg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbhh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbbh9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubbhl; else goto cbbha;
       ubbhl: // global
           call _cbbh9(R1) args: 0, res: 0, upd: 0;
       cbbha: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbbh9() //  [R1]
         { info_tbl: [(cbbh9,
                       label: block_cbbh9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbh9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbhk; else goto cbbhj;
       cbbhk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbbhj: // global
           _sb7l4::P64 = P64[R1 + 7];
           _sb7l5::P64 = P64[R1 + 15];
           _sb7l3::I64 = I64[R1 + 23];
           _sb7l6::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7l4::P64;
           P64[Hp - 32] = _sb7l5::P64;
           I64[Hp - 24] = _sb7l3::I64;
           I64[Hp - 16] = _sb7l6::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7ls_entry() //  [R1]
         { info_tbl: [(cbbhI,
                       label: sat_sb7ls_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbhI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbbhP; else goto cbbhQ;
       cbbhP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbhQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbbhF_info;
           _sb7li::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sb7li::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubbhU; else goto cbbhG;
       ubbhU: // global
           call _cbbhF(R1) args: 0, res: 0, upd: 0;
       cbbhG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbbhF() //  [R1]
         { info_tbl: [(cbbhF,
                       label: block_cbbhF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbhF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbhT; else goto cbbhS;
       cbbhT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbbhS: // global
           _sb7lm::P64 = P64[R1 + 7];
           _sb7ln::P64 = P64[R1 + 15];
           _sb7ll::I64 = I64[R1 + 23];
           _sb7lo::I64 = I64[R1 + 31];
           _sb7lq::I64 = I64[R1 + 47];
           _sb7lr::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7lm::P64;
           P64[Hp - 32] = _sb7ln::P64;
           I64[Hp - 24] = _sb7ll::I64;
           I64[Hp - 16] = _sb7lo::I64;
           I64[Hp - 8] = _sb7lr::I64;
           I64[Hp] = _sb7lq::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7lN_entry() //  [R1, R2]
         { info_tbl: [(cbbhV,
                       label: sat_sb7lN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbhV: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cbbhW; else goto cbbhX;
       cbbhW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbhX: // global
           I64[Sp - 24] = block_cbbgG_info;
           _sb7k5::P64 = P64[R1 + 6];
           _sb7ka::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sb7k5::P64;
           P64[Sp - 8] = _sb7ka::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubbjr; else goto cbbgH;
       ubbjr: // global
           call _cbbgG(R1) args: 0, res: 0, upd: 0;
       cbbgH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbgG() //  [R1]
         { info_tbl: [(cbbgG,
                       label: block_cbbgG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbgG: // global
           I64[Sp - 40] = block_cbbgL_info;
           _sb7kd::P64 = R1;
           _sb7kj::P64 = P64[R1 + 47];
           _sb7kl::P64 = P64[R1 + 63];
           _sb7km::P64 = P64[R1 + 71];
           _sb7kp::P64 = P64[R1 + 95];
           R1 = P64[_sb7km::P64 + 8];
           P64[Sp - 32] = _sb7kj::P64;
           P64[Sp - 24] = _sb7kl::P64;
           P64[Sp - 16] = _sb7km::P64;
           P64[Sp - 8] = _sb7kp::P64;
           P64[Sp] = _sb7kd::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubbjh; else goto cbbgM;
       ubbjh: // global
           call _cbbgL(R1) args: 0, res: 0, upd: 0;
       cbbgM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbgL() //  [R1]
         { info_tbl: [(cbbgL,
                       label: block_cbbgL_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbgL: // global
           I64[Sp - 16] = block_cbbgS_info;
           _sb7kC::I64 = I64[R1 + 39];
           _sb7kD::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sb7kD::I64;
           I64[Sp] = _sb7kC::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubbji; else goto cbbgT;
       ubbji: // global
           call _cbbgS(R1) args: 0, res: 0, upd: 0;
       cbbgT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbgS() //  [R1]
         { info_tbl: [(cbbgS,
                       label: block_cbbgS_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbgS: // global
           if (R1 & 7 == 1) goto cbbiV; else goto ubbjc;
       cbbiV: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubbjd; else goto cbbih;
       ubbjd: // global
           Sp = Sp + 24;
           goto ubbjl;
       cbbih: // global
           _sb7kV::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cbbh0_info;
           R1 = _sb7kV::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubbjj; else goto cbbh1;
       ubbjj: // global
           call _cbbh0(R1) args: 0, res: 0, upd: 0;
       cbbh1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubbjc: // global
           Sp = Sp + 24;
           goto ubbjl;
       ubbjl: // global
           call _sb7kE() args: 0, res: 0, upd: 0;
     }
 },
 _cbbh0() //  [R1]
         { info_tbl: [(cbbh0,
                       label: block_cbbh0_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbh0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbbik; else goto cbbij;
       cbbik: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbij: // global
           _sb7km::P64 = P64[Sp + 24];
           _sb7kX::P64 = P64[R1 + 7];
           _sb7kY::P64 = P64[R1 + 15];
           _sb7l1::P64 = P64[_sb7km::P64 + 8];
           I64[Hp - 16] = sat_sb7l9_info;
           P64[Hp] = _sb7l1::P64;
           call MO_WriteBarrier();
           P64[_sb7km::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7km::P64);
           I64[Sp] = block_cbbhp_info;
           R1 = _sb7l1::P64;
           P64[Sp + 16] = _sb7kY::P64;
           P64[Sp + 24] = _sb7kX::P64;
           if (R1 & 7 != 0) goto ubbjm; else goto cbbhq;
       ubbjm: // global
           call _cbbhp(R1) args: 0, res: 0, upd: 0;
       cbbhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbhp() //  [R1]
         { info_tbl: [(cbbhp,
                       label: block_cbbhp_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbhp: // global
           _sb7li::I64 = I64[R1 + 39];
           if (_sb7li::I64 != 0) goto cbbin; else goto cbbiS;
       cbbin: // global
           I64[Sp - 24] = block_cbbhw_info;
           _sb7ld::P64 = P64[R1 + 7];
           _sb7le::P64 = P64[R1 + 15];
           _sb7lc::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sb7le::P64;
           I64[Sp - 8] = _sb7li::I64;
           P64[Sp] = _sb7ld::P64;
           I64[Sp + 32] = _sb7lc::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubbjn; else goto cbbhx;
       ubbjn: // global
           call _cbbhw(R1) args: 0, res: 0, upd: 0;
       cbbhx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbiS: // global
           _sb7kj::P64 = P64[Sp + 8];
           _sb7kY::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sb7kj::P64 + 8] = _sb7kY::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7kj::P64);
           Sp = Sp + 8;
           call _sb7kE() args: 0, res: 0, upd: 0;
     }
 },
 _cbbhw() //  [R1]
         { info_tbl: [(cbbhw,
                       label: block_cbbhw_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbhw: // global
           if (R1 & 7 == 1) goto cbbip; else goto cbbiH;
       cbbip: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbbis; else goto cbbir;
       cbbis: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbir: // global
           I64[Hp - 24] = sat_sb7ls_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sb7kj::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sb7kj::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7kj::P64);
           Sp = Sp + 32;
           call _sb7kE() args: 0, res: 0, upd: 0;
       cbbiH: // global
           I64[Sp] = block_cbbiv_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubbjp; else goto cbbiw;
       ubbjp: // global
           call _cbbiv(R1) args: 0, res: 0, upd: 0;
       cbbiw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbiv() //  [R1]
         { info_tbl: [(cbbiv,
                       label: block_cbbiv_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbiv: // global
           I64[Sp - 8] = block_cbbiA_info;
           R2 = P64[Sp + 48];
           _sb7lw::P64 = P64[R1 + 7];
           _sb7lx::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sb7lx::P64;
           P64[Sp + 48] = _sb7lw::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbiA() //  [R1]
         { info_tbl: [(cbbiA,
                       label: block_cbbiA_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbiA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbiL; else goto cbbiK;
       cbbiL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbiK: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cbbiD_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbiD() //  [R1]
         { info_tbl: [(cbbiD,
                       label: block_cbbiD_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbiD: // global
           I64[Sp] = block_cbbiF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubbjs; else goto cbbiN;
       ubbjs: // global
           call _cbbiF(R1) args: 0, res: 0, upd: 0;
       cbbiN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbiF() //  [R1]
         { info_tbl: [(cbbiF,
                       label: block_cbbiF_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbiF: // global
           _sb7kj::P64 = P64[Sp + 8];
           _sb7lJ::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sb7kj::P64 + 8] = _sb7lJ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7kj::P64);
           Sp = Sp + 8;
           call _sb7kE() args: 0, res: 0, upd: 0;
     }
 },
 _sb7kE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7kE: // global
           _sb7kI::P64 = P64[P64[Sp] + 8];
           I64[Sp + 24] = block_cbbi3_info;
           R1 = _sb7kI::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubbju; else goto cbbi5;
       ubbju: // global
           call _cbbi3(R1) args: 0, res: 0, upd: 0;
       cbbi5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbi3() //  [R1]
         { info_tbl: [(cbbi3,
                       label: block_cbbi3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbi3: // global
           _sb7k5::P64 = P64[Sp + 16];
           _sb7ka::P64 = P64[Sp + 24];
           _sb7kd::P64 = P64[Sp + 8];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbbie; else goto cbbid;
       cbbie: // global
           R6 = _sb7ka::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7k5::P64;
           R3 = R1;
           R2 = _sb7kd::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.hGetBuf2_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cbbid: // global
           R6 = _sb7ka::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sb7k5::P64;
           R3 = R1;
           R2 = _sb7kd::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.hGetBuf4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubbjG_srtd" {
     ubbjG_srtd:
         const Sb7vQ_srt+8;
         const 51;
         const 2111062325331969;
 },
 GHC.IO.Handle.Text.$whGetBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbbjy,
                       label: GHC.IO.Handle.Text.$whGetBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbjy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbbjC; else goto cbbjB;
       cbbjC: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBuf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbbjB: // global
           if (R4 == 0) goto cbbjx; else goto cbbjw;
       cbbjx: // global
           Hp = Hp - 40;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbbjw: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cbbjE; else goto cbbjF;
       cbbjE: // global
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sb7lN_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 31;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetBuf5_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cbbjF: // global
           Hp = Hp - 40;
           R4 = R4;
           R3 = GHC.IO.Handle.Text.hGetBuf5_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.146648731 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf1_closure" {
     GHC.IO.Handle.Text.hGetBuf1_closure:
         const GHC.IO.Handle.Text.hGetBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbblk,
                       label: GHC.IO.Handle.Text.hGetBuf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbblk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbbll; else goto cbblm;
       cbbll: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbblm: // global
           I64[Sp - 24] = block_cbblh_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubblq; else goto cbbli;
       ubblq: // global
           call _cbblh(R1) args: 0, res: 0, upd: 0;
       cbbli: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbblh() //  [R1]
         { info_tbl: [(cbblh,
                       label: block_cbblh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbblh: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBuf_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.152444257 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf_closure" {
     GHC.IO.Handle.Text.hGetBuf_closure:
         const GHC.IO.Handle.Text.hGetBuf_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbblE,
                       label: GHC.IO.Handle.Text.hGetBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbblE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBuf1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.155618609 UTC

[section ""cstring" . lvl14_rb6WU_bytes" {
     lvl14_rb6WU_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.157442242 UTC

[section ""data" . lvl15_rb6WV_closure" {
     lvl15_rb6WV_closure:
         const lvl15_rb6WV_info;
         const 0;
         const 0;
         const 0;
 },
 lvl15_rb6WV_entry() //  [R1]
         { info_tbl: [(cbblS,
                       label: lvl15_rb6WV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbblS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbblT; else goto cbblU;
       cbblT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbblU: // global
           (_cbblP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbblP::I64 == 0) goto cbblR; else goto cbblQ;
       cbblR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbblQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbblP::I64;
           R2 = lvl14_rb6WU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.161631955 UTC

[section ""data" . lvl16_rb6WW_closure" {
     lvl16_rb6WW_closure:
         const lvl16_rb6WW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_rb6WW_entry() //  [R1]
         { info_tbl: [(cbbm8,
                       label: lvl16_rb6WW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbm8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbbm9; else goto cbbma;
       cbbm9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbma: // global
           (_cbbm5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbm5::I64 == 0) goto cbbm7; else goto cbbm6;
       cbbm7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbm6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbm5::I64;
           R2 = GHC.IO.Handle.Text.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.165570673 UTC

[section ""data" . lvl17_rb6WX_closure" {
     lvl17_rb6WX_closure:
         const lvl17_rb6WX_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rb6WX_entry() //  [R1]
         { info_tbl: [(cbbmo,
                       label: lvl17_rb6WX_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbmo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbbmp; else goto cbbmq;
       cbbmp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbmq: // global
           (_cbbml::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbml::I64 == 0) goto cbbmn; else goto cbbmm;
       cbbmn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbmm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbml::I64;
           R2 = GHC.IO.Handle.Text.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.169226763 UTC

[section ""cstring" . lvl18_rb6WY_bytes" {
     lvl18_rb6WY_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,84,101,120,116,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.171052024 UTC

[section ""data" . lvl19_rb6WZ_closure" {
     lvl19_rb6WZ_closure:
         const lvl19_rb6WZ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rb6WZ_entry() //  [R1]
         { info_tbl: [(cbbmF,
                       label: lvl19_rb6WZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbmF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbbmG; else goto cbbmH;
       cbbmG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbmH: // global
           (_cbbmC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbmC::I64 == 0) goto cbbmE; else goto cbbmD;
       cbbmE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbmD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbmC::I64;
           R2 = lvl18_rb6WY_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.175729106 UTC

[section ""data" . lvl20_rb6X0_closure" {
     lvl20_rb6X0_closure:
         const GHC.Types.I#_con_info;
         const 785;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.177415544 UTC

[section ""data" . lvl21_rb6X1_closure" {
     lvl21_rb6X1_closure:
         const GHC.Types.I#_con_info;
         const 17;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.179084436 UTC

[section ""data" . lvl22_rb6X2_closure" {
     lvl22_rb6X2_closure:
         const GHC.Types.I#_con_info;
         const 38;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.18076254 UTC

[section ""data" . lvl23_rb6X3_closure" {
     lvl23_rb6X3_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl16_rb6WW_closure;
         const lvl17_rb6WX_closure;
         const lvl19_rb6WZ_closure;
         const lvl20_rb6X0_closure+1;
         const lvl21_rb6X1_closure+1;
         const lvl20_rb6X0_closure+1;
         const lvl22_rb6X2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.182762692 UTC

[section ""data" . lvl24_rb6X4_closure" {
     lvl24_rb6X4_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl15_rb6WV_closure;
         const lvl23_rb6X3_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.18445992 UTC

[section ""cstring" . lvl25_rb6X5_bytes" {
     lvl25_rb6X5_bytes:
         I8[] [84,111,100,111,58,32,104,80,117,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.186425762 UTC

[section ""data" . lvl26_rb6X6_closure" {
     lvl26_rb6X6_closure:
         const lvl26_rb6X6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_rb6X6_entry() //  [R1]
         { info_tbl: [(cbbn3,
                       label: lvl26_rb6X6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbn3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbbn4; else goto cbbn5;
       cbbn4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbn5: // global
           (_cbbmY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbmY::I64 == 0) goto cbbn0; else goto cbbmZ;
       cbbn0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbmZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbmY::I64;
           I64[Sp - 24] = block_cbbn1_info;
           R2 = lvl25_rb6X5_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbbn1() //  [R1]
         { info_tbl: [(cbbn1,
                       label: block_cbbn1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbn1: // global
           R3 = R1;
           R2 = lvl24_rb6X4_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.191810479 UTC

[section ""data" . lvl27_rb6X7_closure" {
     lvl27_rb6X7_closure:
         const GHC.Types.I#_con_info;
         const 790;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.193445988 UTC

[section ""data" . lvl28_rb6X8_closure" {
     lvl28_rb6X8_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl16_rb6WW_closure;
         const lvl17_rb6WX_closure;
         const lvl19_rb6WZ_closure;
         const lvl27_rb6X7_closure+1;
         const lvl21_rb6X1_closure+1;
         const lvl27_rb6X7_closure+1;
         const lvl22_rb6X2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.19515192 UTC

[section ""data" . lvl29_rb6X9_closure" {
     lvl29_rb6X9_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl15_rb6WV_closure;
         const lvl28_rb6X8_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.197155326 UTC

[section ""data" . lvl30_rb6Xa_closure" {
     lvl30_rb6Xa_closure:
         const lvl30_rb6Xa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_rb6Xa_entry() //  [R1]
         { info_tbl: [(cbbnu,
                       label: lvl30_rb6Xa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbnu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbbnv; else goto cbbnw;
       cbbnv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbnw: // global
           (_cbbnp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbnp::I64 == 0) goto cbbnr; else goto cbbnq;
       cbbnr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbnq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbnp::I64;
           I64[Sp - 24] = block_cbbns_info;
           R2 = lvl25_rb6X5_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbbns() //  [R1]
         { info_tbl: [(cbbns,
                       label: block_cbbns_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbns: // global
           R3 = R1;
           R2 = lvl29_rb6X9_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.21055167 UTC

[section ""data" . GHC.IO.Handle.Text.$wbufWrite_closure" {
     GHC.IO.Handle.Text.$wbufWrite_closure:
         const GHC.IO.Handle.Text.$wbufWrite_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wbufWrite_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbnL: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wbufWrite_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubbqM_srtd" {
     ubbqM_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 17451452851027969;
 },
 GHC.IO.Handle.Text.$wbufWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbbnS,
                       label: GHC.IO.Handle.Text.$wbufWrite_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbnS: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cbbo0; else goto ubbqy;
       cbbo0: // global
           R1 = GHC.IO.Handle.Text.$wbufWrite_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ubbqy: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _cbbnM() args: 0, res: 0, upd: 0;
     }
 },
 _cbbnM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbnM: // global
           _sb7lW::P64 = P64[Sp];
           I64[Sp] = block_cbbnP_info;
           R1 = _sb7lW::P64;
           if (R1 & 7 != 0) goto ubbqC; else goto cbbnQ;
       ubbqC: // global
           call _cbbnP(R1) args: 0, res: 0, upd: 0;
       cbbnQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbqN_srtd" {
     ubbqN_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbbnP() //  [R1]
         { info_tbl: [(cbbnP,
                       label: block_cbbnP_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbnP: // global
           I64[Sp - 32] = block_cbbnV_info;
           _sb7m1::P64 = R1;
           _sb7m3::P64 = P64[R1 + 15];
           _sb7m4::P64 = P64[R1 + 23];
           _sb7m7::P64 = P64[R1 + 47];
           R1 = P64[R1 + 31];
           P64[Sp - 24] = _sb7m3::P64;
           P64[Sp - 16] = _sb7m4::P64;
           P64[Sp - 8] = _sb7m7::P64;
           P64[Sp] = _sb7m1::P64;
           Sp = Sp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbqO_srtd" {
     ubbqO_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbbnV() //  [R1]
         { info_tbl: [(cbbnV,
                       label: block_cbbnV_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbnV: // global
           _sb7mn::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 24] = block_cbbnZ_info;
           _sb7mi::P64 = R1;
           _sb7mj::I64 = I64[R1 + 7];
           _sb7mk::I64 = I64[R1 + 15];
           R1 = _sb7mn::P64;
           I64[Sp - 16] = _sb7mj::I64;
           I64[Sp - 8] = _sb7mk::I64;
           P64[Sp] = _sb7mi::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubbqE; else goto cbbo4;
       ubbqE: // global
           call _cbbnZ(R1) args: 0, res: 0, upd: 0;
       cbbo4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbqP_srtd" {
     ubbqP_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbbnZ() //  [R1]
         { info_tbl: [(cbbnZ,
                       label: block_cbbnZ_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbnZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbboa; else goto cbbo9;
       cbboa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbo9: // global
           _sb7mq::P64 = P64[R1 + 7];
           _sb7mr::P64 = P64[R1 + 15];
           _sb7mp::I64 = I64[R1 + 23];
           _sb7ms::I64 = I64[R1 + 31];
           _sb7mt::I64 = I64[R1 + 39];
           _sb7mu::I64 = I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _sb7lY::I64 = I64[Sp + 72];
           I64[Hp] = _sb7lY::I64;
           _sb7m3::P64 = P64[Sp + 32];
           _sb7mi::P64 = P64[Sp + 24];
           _sb7mo::P64 = R1;
           _cbbob::P64 = Hp - 7;
           if (%MO_S_Ge_W64(_sb7lY::I64,
                            _sb7ms::I64)) goto sb7mw; else goto cbbqh;
       cbbqh: // global
           if (%MO_S_Gt_W64(_sb7lY::I64,
                            _sb7ms::I64 - _sb7mu::I64)) goto sb7mw; else goto cbbpH;
       sb7mw: // global
           if (%MO_S_Le_W64(_sb7mu::I64, 0)) goto ubbqz; else goto cbbpo;
       ubbqz: // global
           I64[Sp + 32] = _sb7ms::I64;
           P64[Sp + 48] = _cbbob::P64;
           Sp = Sp + 8;
           call _sb7mx() args: 0, res: 0, upd: 0;
       cbbpo: // global
           I64[Sp] = block_cbbpn_info;
           R2 = _sb7m3::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sb7mi::P64;
           P64[Sp - 8] = _sb7mo::P64;
           I64[Sp + 24] = _sb7ms::I64;
           P64[Sp + 32] = _cbbob::P64;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cbbpH: // global
           I64[Sp - 8] = block_cbbpG_info;
           R1 = P64[Sp + 64];
           I64[Sp] = _sb7mu::I64;
           I64[Sp + 8] = _sb7mt::I64;
           I64[Sp + 16] = _sb7ms::I64;
           P64[Sp + 40] = _sb7mr::P64;
           P64[Sp + 56] = _sb7mq::P64;
           I64[Sp + 64] = _sb7mp::I64;
           P64[Sp + 80] = _cbbob::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbqF; else goto cbbpI;
       ubbqF: // global
           call _cbbpG(R1) args: 0, res: 0, upd: 0;
       cbbpI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbqQ_srtd" {
     ubbqQ_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbbpn() //  [R1]
         { info_tbl: [(cbbpn,
                       label: block_cbbpn_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbpn: // global
           _cbbob::P64 = P64[Sp + 32];
           _sb7m7::P64 = P64[Sp + 48];
           _sb7ms::I64 = I64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sb7m7::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7m7::P64);
           P64[Sp + 48] = _cbbob::P64;
           I64[Sp + 32] = _sb7ms::I64;
           Sp = Sp + 8;
           call _sb7mx() args: 0, res: 0, upd: 0;
     }
 },
 _sb7mx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7mx: // global
           _sb7lY::I64 = I64[Sp + 64];
           _sb7lZ::P64 = P64[Sp + 72];
           if (%MO_S_Ge_W64(_sb7lY::I64,
                            I64[Sp + 24])) goto cbbot; else goto cbbpg;
       cbbot: // global
           I64[Sp - 8] = block_cbbor_info;
           R1 = _sb7lZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbqK; else goto cbbou;
       ubbqK: // global
           call _cbbor(R1) args: 0, res: 0, upd: 0;
       cbbou: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbpg: // global
           P64[Sp + 48] = P64[Sp + 48];
           P64[Sp + 56] = P64[Sp + 56];
           I64[Sp + 64] = _sb7lY::I64;
           P64[Sp + 72] = _sb7lZ::P64;
           Sp = Sp + 48;
           call _cbbnM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubbqR_srtd" {
     ubbqR_srtd:
         const Sb7vQ_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbbor() //  [R1]
         { info_tbl: [(cbbor,
                       label: block_cbbor_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbor: // global
           _sb7m4::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbboB; else goto cbboW;
       cbboB: // global
           I64[Sp] = block_cbboy_info;
           R3 = lvl11_rb6WR_closure;
           R2 = _sb7m4::P64;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
       cbboW: // global
           I64[Sp] = block_cbboU_info;
           R3 = lvl11_rb6WR_closure;
           R2 = _sb7m4::P64;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbboy() //  [R1]
         { info_tbl: [(cbboy,
                       label: block_cbboy_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbboy: // global
           if (R1 & 7 == 1) goto cbboH; else goto cbboM;
       cbboH: // global
           R1 = lvl30_rb6Xa_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbboM: // global
           I64[Sp] = block_cbboK_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto ubbqH; else goto cbboN;
       ubbqH: // global
           call _cbboK(R1) args: 0, res: 0, upd: 0;
       cbboN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbboK() //  [R1]
         { info_tbl: [(cbboK,
                       label: block_cbboK_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbboK: // global
           R5 = I64[Sp + 72];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 88;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbboU() //  [R1]
         { info_tbl: [(cbboU,
                       label: block_cbboU_info
                       rep:StackRep [True, True, True, True, True, False, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbboU: // global
           if (R1 & 7 == 1) goto cbbp2; else goto cbbpc;
       cbbp2: // global
           R1 = lvl26_rb6X6_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbbpc: // global
           I64[Sp] = block_cbbp5_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto ubbqI; else goto cbbp6;
       ubbqI: // global
           call _cbbp5(R1) args: 0, res: 0, upd: 0;
       cbbp6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbp5() //  [R1]
         { info_tbl: [(cbbp5,
                       label: block_cbbp5_info
                       rep:StackRep [True, True, True, True, True, False, True, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbp5: // global
           I64[Sp + 40] = block_cbbpa_info;
           R5 = I64[Sp + 72];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 40;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbpa() //  []
         { info_tbl: [(cbbpa,
                       label: block_cbbpa_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbpa: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbpG() //  [R1]
         { info_tbl: [(cbbpG,
                       label: block_cbbpG_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbpG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbpO; else goto cbbpN;
       cbbpO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbpN: // global
           _cbbob::P64 = P64[Sp + 88];
           _sb7lY::I64 = I64[Sp + 80];
           _sb7m3::P64 = P64[Sp + 40];
           _sb7m7::P64 = P64[Sp + 56];
           _sb7mp::I64 = I64[Sp + 72];
           _sb7mq::P64 = P64[Sp + 64];
           _sb7mr::P64 = P64[Sp + 48];
           _sb7ms::I64 = I64[Sp + 24];
           _sb7mt::I64 = I64[Sp + 16];
           _sb7mu::I64 = I64[Sp + 8];
           (_sb7n1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sb7mp::I64 + _sb7mu::I64, I64[R1 + 7], _sb7lY::I64);
           call MO_Touch(_sb7mq::P64);
           if (_sb7lY::I64 == _sb7ms::I64 - _sb7mu::I64) goto cbbqe; else goto cbbq6;
       cbbqe: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7mq::P64;
           P64[Hp - 32] = _sb7mr::P64;
           I64[Hp - 24] = _sb7mp::I64;
           I64[Hp - 16] = _sb7ms::I64;
           I64[Hp - 8] = _sb7mt::I64;
           I64[Hp] = _sb7mu::I64 + _sb7lY::I64;
           I64[Sp + 48] = block_cbbqd_info;
           R2 = _sb7m3::P64;
           I64[Sp + 24] = stg_ap_ppv_info;
           P64[Sp + 40] = Hp - 47;
           Sp = Sp + 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cbbq6: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sb7mq::P64;
           P64[Hp - 32] = _sb7mr::P64;
           I64[Hp - 24] = _sb7mp::I64;
           I64[Hp - 16] = _sb7ms::I64;
           I64[Hp - 8] = _sb7mt::I64;
           I64[Hp] = _sb7mu::I64 + _sb7lY::I64;
           call MO_WriteBarrier();
           P64[_sb7m7::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7m7::P64);
           R1 = _cbbob::P64;
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbqd() //  [R1]
         { info_tbl: [(cbbqd,
                       label: block_cbbqd_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbqd: // global
           _cbbob::P64 = P64[Sp + 40];
           _sb7m7::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7m7::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7m7::P64);
           R1 = _cbbob::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.25063418 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutBuf4_bytes" {
     GHC.IO.Handle.Text.hPutBuf4_bytes:
         I8[] [104,80,117,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.252873433 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf3_closure" {
     GHC.IO.Handle.Text.hPutBuf3_closure:
         const GHC.IO.Handle.Text.hPutBuf3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf3_entry() //  [R1]
         { info_tbl: [(cbbso,
                       label: GHC.IO.Handle.Text.hPutBuf3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbso: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbbsp; else goto cbbsq;
       cbbsp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbsq: // global
           (_cbbsl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbsl::I64 == 0) goto cbbsn; else goto cbbsm;
       cbbsn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbsm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbsl::I64;
           R2 = GHC.IO.Handle.Text.hPutBuf4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.258961942 UTC

[section ""data" . GHC.IO.Handle.Text.$whPutBuf'_closure" {
     GHC.IO.Handle.Text.$whPutBuf'_closure:
         const GHC.IO.Handle.Text.$whPutBuf'_info;
         const 0;
 },
 GHC.IO.Handle.Text.$whPutBuf'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbsz: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 act_sb7nl_entry() //  [R1, R2]
         { info_tbl: [(cbbsQ,
                       label: act_sb7nl_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbsQ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbbsR; else goto cbbsS;
       cbbsR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbsS: // global
           I64[Sp - 32] = block_cbbsN_info;
           _sb7nf::P64 = P64[R1 + 6];
           _sb7nh::P64 = P64[R1 + 14];
           _sb7nj::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sb7nf::P64;
           P64[Sp - 16] = _sb7nh::P64;
           I64[Sp - 8] = _sb7nj::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubbtQ; else goto cbbsO;
       ubbtQ: // global
           call _cbbsN(R1) args: 0, res: 0, upd: 0;
       cbbsO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbsN() //  [R1]
         { info_tbl: [(cbbsN,
                       label: block_cbbsN_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbsN: // global
           I64[Sp - 8] = block_cbbsV_info;
           R5 = P64[Sp + 16];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = R1;
           P64[Sp] = P64[R1 + 55];
           P64[Sp + 8] = P64[R1 + 47];
           P64[Sp + 16] = P64[R1 + 31];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$wbufWrite_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbsV() //  [R1]
         { info_tbl: [(cbbsV,
                       label: block_cbbsV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbsV: // global
           I64[Sp] = block_cbbsX_info;
           _sb7nH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sb7nH::P64;
           if (R1 & 7 != 0) goto ubbtR; else goto cbbt0;
       ubbtR: // global
           call _cbbsX(R1) args: 0, res: 0, upd: 0;
       cbbt0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbsX() //  [R1]
         { info_tbl: [(cbbsX,
                       label: block_cbbsX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbsX: // global
           if (R1 & 7 == 3) goto ubbtN; else goto cbbt7;
       ubbtN: // global
           Sp = Sp + 8;
           call _cbbtH() args: 0, res: 0, upd: 0;
       cbbt7: // global
           _sb7nL::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbbt4_info;
           R1 = _sb7nL::P64;
           if (R1 & 7 != 0) goto ubbtS; else goto cbbt8;
       ubbtS: // global
           call _cbbt4(R1) args: 0, res: 0, upd: 0;
       cbbt8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbt4() //  [R1]
         { info_tbl: [(cbbt4,
                       label: block_cbbt4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbt4: // global
           I64[Sp] = block_cbbtc_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubbtU; else goto cbbte;
       ubbtU: // global
           call _cbbtc(R1) args: 0, res: 0, upd: 0;
       cbbte: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbtc() //  [R1]
         { info_tbl: [(cbbtc,
                       label: block_cbbtc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbtc: // global
           if (R1 & 7 == 1) goto ubbtO; else goto cbbtp;
       ubbtO: // global
           Sp = Sp + 8;
           call _cbbtH() args: 0, res: 0, upd: 0;
       cbbtp: // global
           _sb7nW::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbbtn_info;
           R1 = _sb7nW::P64;
           if (R1 & 7 != 0) goto ubbtV; else goto cbbtq;
       ubbtV: // global
           call _cbbtn(R1) args: 0, res: 0, upd: 0;
       cbbtq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbtn() //  [R1]
         { info_tbl: [(cbbtn,
                       label: block_cbbtn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbtn: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubbtP; else goto cbbtA;
       ubbtP: // global
           Sp = Sp + 8;
           call _cbbtH() args: 0, res: 0, upd: 0;
       cbbtA: // global
           I64[Sp] = block_cbbty_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbbtH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbtH: // global
           R1 = P64[Sp];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbty() //  [R1]
         { info_tbl: [(cbbty,
                       label: block_cbbty_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbty: // global
           _sb7nu::P64 = P64[Sp + 16];
           _sb7nH::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7nu::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7nu::P64);
           R1 = _sb7nH::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubbun_srtd" {
     ubbun_srtd:
         const Sb7vQ_srt+8;
         const 62;
         const 3602879701896396803;
 },
 GHC.IO.Handle.Text.$whPutBuf'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbbu1,
                       label: GHC.IO.Handle.Text.$whPutBuf'_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbu1: // global
           _sb7nh::P64 = R5;
           _sb7ng::I64 = R4;
           _sb7nf::P64 = R3;
           _sb7ne::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbbu2; else goto cbbu3;
       cbbu3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbbu5; else goto cbbu4;
       cbbu5: // global
           HpAlloc = 32;
           goto cbbu2;
       cbbu2: // global
           R1 = GHC.IO.Handle.Text.$whPutBuf'_closure;
           P64[Sp - 32] = _sb7ne::P64;
           P64[Sp - 24] = _sb7nf::P64;
           I64[Sp - 16] = _sb7ng::I64;
           P64[Sp - 8] = _sb7nh::P64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cbbu4: // global
           if (_sb7ng::I64 == 0) goto cbbu0; else goto cbbtZ;
       cbbu0: // global
           Hp = Hp - 32;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbbtZ: // global
           if (%MO_S_Ge_W64(_sb7ng::I64, 0)) goto cbbu8; else goto cbbuk;
       cbbu8: // global
           I64[Hp - 24] = act_sb7nl_info;
           P64[Hp - 16] = _sb7nf::P64;
           P64[Hp - 8] = _sb7nh::P64;
           I64[Hp] = _sb7ng::I64;
           I64[Sp - 16] = block_cbbu6_info;
           R1 = _sb7ne::P64;
           P64[Sp - 8] = Hp - 22;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubbum; else goto cbbu9;
       ubbum: // global
           call _cbbu6(R1) args: 0, res: 0, upd: 0;
       cbbu9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbuk: // global
           Hp = Hp - 32;
           R4 = _sb7ng::I64;
           R3 = GHC.IO.Handle.Text.hPutBuf3_closure;
           R2 = _sb7ne::P64;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubbuo_srtd" {
     ubbuo_srtd:
         const Sb7vQ_srt+16;
         const 61;
         const 1152921504606846977;
 },
 _cbbu6() //  [R1]
         { info_tbl: [(cbbu6,
                       label: block_cbbu6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbu6: // global
           _cbbsI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbbuf; else goto cbbuj;
       cbbuf: // global
           R5 = _cbbsI::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutBuf3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cbbuj: // global
           R5 = _cbbsI::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutBuf3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.283594996 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf2_closure" {
     GHC.IO.Handle.Text.hPutBuf2_closure:
         const GHC.IO.Handle.Text.hPutBuf2_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbbvy,
                       label: GHC.IO.Handle.Text.hPutBuf2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbvy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbbvz; else goto cbbvA;
       cbbvz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBuf2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbbvA: // global
           I64[Sp - 32] = block_cbbvv_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubbvE; else goto cbbvw;
       ubbvE: // global
           call _cbbvv(R1) args: 0, res: 0, upd: 0;
       cbbvw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbvv() //  [R1]
         { info_tbl: [(cbbvv,
                       label: block_cbbvv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbvv: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.289194561 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBufNonBlocking1_closure" {
     GHC.IO.Handle.Text.hPutBufNonBlocking1_closure:
         const GHC.IO.Handle.Text.hPutBufNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBufNonBlocking1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbbvV,
                       label: GHC.IO.Handle.Text.hPutBufNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbvV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbbvW; else goto cbbvX;
       cbbvW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBufNonBlocking1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbbvX: // global
           I64[Sp - 24] = block_cbbvS_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubbw1; else goto cbbvT;
       ubbw1: // global
           call _cbbvS(R1) args: 0, res: 0, upd: 0;
       cbbvT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbvS() //  [R1]
         { info_tbl: [(cbbvS,
                       label: block_cbbvS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbvS: // global
           R5 = GHC.Types.False_closure+1;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.295462737 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBufNonBlocking_closure" {
     GHC.IO.Handle.Text.hPutBufNonBlocking_closure:
         const GHC.IO.Handle.Text.hPutBufNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cbbwf,
                       label: GHC.IO.Handle.Text.hPutBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbwf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutBufNonBlocking1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.298980006 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf1_closure" {
     GHC.IO.Handle.Text.hPutBuf1_closure:
         const GHC.IO.Handle.Text.hPutBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbbwt,
                       label: GHC.IO.Handle.Text.hPutBuf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbwt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbbwx; else goto cbbwy;
       cbbwx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBuf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbbwy: // global
           I64[Sp - 24] = block_cbbwq_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubbwC; else goto cbbwr;
       ubbwC: // global
           call _cbbwq(R1) args: 0, res: 0, upd: 0;
       cbbwr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbwq() //  [R1]
         { info_tbl: [(cbbwq,
                       label: block_cbbwq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbwq: // global
           _sb7ou::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbbww_info;
           R5 = GHC.Types.True_closure+2;
           R4 = I64[R1 + 7];
           R3 = _sb7ou::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbww() //  []
         { info_tbl: [(cbbww,
                       label: block_cbbww_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbww: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.306249037 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf_closure" {
     GHC.IO.Handle.Text.hPutBuf_closure:
         const GHC.IO.Handle.Text.hPutBuf_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbbwU,
                       label: GHC.IO.Handle.Text.hPutBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbwU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutBuf1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.309438062 UTC

[section ""cstring" . lvl31_rb6Xb_bytes" {
     lvl31_rb6Xb_bytes:
         I8[] [10]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.311245927 UTC

[section ""data" . lvl32_rb6Xc_closure" {
     lvl32_rb6Xc_closure:
         const lvl32_rb6Xc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl32_rb6Xc_entry() //  [R1]
         { info_tbl: [(cbbx8,
                       label: lvl32_rb6Xc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbx8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbbx9; else goto cbbxa;
       cbbx9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbxa: // global
           (_cbbx5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbx5::I64 == 0) goto cbbx7; else goto cbbx6;
       cbbx7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbx6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbx5::I64;
           R2 = lvl31_rb6Xb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.319174359 UTC

[section ""data" . GHC.IO.Handle.Text.$wwriteBlocks_closure" {
     GHC.IO.Handle.Text.$wwriteBlocks_closure:
         const GHC.IO.Handle.Text.$wwriteBlocks_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wwriteBlocks_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbxj: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sb7r5_entry() //  [R1]
         { info_tbl: [(cbbxy,
                       label: sat_sb7r5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbxy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbbxz; else goto cbbxA;
       cbbxz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbxA: // global
           I64[Sp - 8] = block_cbbxr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbxH; else goto cbbxs;
       ubbxH: // global
           call _cbbxr(R1) args: 0, res: 0, upd: 0;
       cbbxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbxr() //  [R1]
         { info_tbl: [(cbbxr,
                       label: block_cbbxr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbxr: // global
           if (R1 & 7 == 1) goto cbbxv; else goto cbbxw;
       cbbxv: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbbxw: // global
           R1 = lvl32_rb6Xc_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7pr_entry() //  [R1, R2]
         { info_tbl: [(cbbxW,
                       label: sat_sb7pr_info
                       rep:HeapRep 2 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbxW: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbby2; else goto cbby3;
       cbby2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbby3: // global
           I64[Sp - 48] = block_cbbxT_info;
           _sb7oH::P64 = P64[R1 + 6];
           _sb7oO::P64 = P64[R1 + 14];
           _sb7oG::I64 = I64[R1 + 22];
           _sb7oI::I64 = I64[R1 + 30];
           _sb7oM::I64 = I64[R1 + 38];
           R1 = R2;
           I64[Sp - 40] = _sb7oG::I64;
           P64[Sp - 32] = _sb7oH::P64;
           I64[Sp - 24] = _sb7oI::I64;
           I64[Sp - 16] = _sb7oM::I64;
           P64[Sp - 8] = _sb7oO::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ubbyo; else goto cbbxU;
       ubbyo: // global
           call _cbbxT(R1) args: 0, res: 0, upd: 0;
       cbbxU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbxT() //  [R1]
         { info_tbl: [(cbbxT,
                       label: block_cbbxT_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbxT: // global
           _sb7oG::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cbbxZ_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = _sb7oG::I64;
           R2 = R1;
           I64[Sp - 8] = 0;
           I64[Sp] = I64[Sp + 32];
           P64[Sp + 16] = P64[R1 + 79];
           P64[Sp + 32] = P64[R1 + 71];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbbxZ() //  []
         { info_tbl: [(cbbxZ,
                       label: block_cbbxZ_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbxZ: // global
           _sb7pd::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbby1_info;
           R1 = _sb7pd::P64;
           if (R1 & 7 != 0) goto ubbyp; else goto cbby6;
       ubbyp: // global
           call _cbby1(R1) args: 0, res: 0, upd: 0;
       cbby6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbby1() //  [R1]
         { info_tbl: [(cbby1,
                       label: block_cbby1_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbby1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbbyc; else goto cbbyb;
       cbbyc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbyb: // global
           if (I64[Sp + 16] == I64[R1 + 31]) goto cbbyh; else goto cbbyg;
       cbbyh: // global
           _sb7p1::P64 = P64[Sp + 8];
           _sb7po::P64 = P64[_sb7p1::P64 + 8];
           I64[Hp - 16] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sb7po::P64;
           call MO_WriteBarrier();
           P64[_sb7p1::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7p1::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbbyg: // global
           Hp = Hp - 24;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7qq_entry() //  [R1, R2]
         { info_tbl: [(cbbz8,
                       label: sat_sb7qq_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbz8: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbbze; else goto cbbzf;
       cbbze: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbzf: // global
           I64[Sp - 40] = block_cbbz5_info;
           _sb7oH::P64 = P64[R1 + 6];
           _sb7oG::I64 = I64[R1 + 14];
           _sb7oI::I64 = I64[R1 + 22];
           _sb7pN::I64 = I64[R1 + 30];
           R1 = R2;
           I64[Sp - 32] = _sb7oG::I64;
           P64[Sp - 24] = _sb7oH::P64;
           I64[Sp - 16] = _sb7oI::I64;
           I64[Sp - 8] = _sb7pN::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubbzz; else goto cbbz6;
       ubbzz: // global
           call _cbbz5(R1) args: 0, res: 0, upd: 0;
       cbbz6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbz5() //  [R1]
         { info_tbl: [(cbbz5,
                       label: block_cbbz5_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbz5: // global
           _sb7oG::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cbbzb_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = _sb7oG::I64;
           R2 = R1;
           I64[Sp - 8] = 0;
           I64[Sp] = I64[Sp + 32];
           P64[Sp + 16] = P64[R1 + 47];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbbzb() //  []
         { info_tbl: [(cbbzb,
                       label: block_cbbzb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbzb: // global
           _sb7qd::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_cbbzd_info;
           R1 = _sb7qd::P64;
           if (R1 & 7 != 0) goto ubbzA; else goto cbbzi;
       ubbzA: // global
           call _cbbzd(R1) args: 0, res: 0, upd: 0;
       cbbzi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbzd() //  [R1]
         { info_tbl: [(cbbzd,
                       label: block_cbbzd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbzd: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbbzv; else goto cbbzs;
       cbbzv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbbzs: // global
           I64[Sp] = block_cbbzq_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbbzq() //  [R1]
         { info_tbl: [(cbbzq,
                       label: block_cbbzq_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbzq: // global
           _sb7pX::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7pX::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7pX::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sb7r0_entry() //  [R1, R2]
         { info_tbl: [(cbbzK,
                       label: sat_sb7r0_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbzK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbbzO; else goto cbbzP;
       cbbzO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbzP: // global
           I64[Sp - 40] = block_cbbzH_info;
           _sb7oH::P64 = P64[R1 + 6];
           _sb7oG::I64 = I64[R1 + 14];
           _sb7oI::I64 = I64[R1 + 22];
           _sb7pt::I64 = I64[R1 + 30];
           R1 = R2;
           I64[Sp - 32] = _sb7oG::I64;
           P64[Sp - 24] = _sb7oH::P64;
           I64[Sp - 16] = _sb7oI::I64;
           I64[Sp - 8] = _sb7pt::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubbzT; else goto cbbzI;
       ubbzT: // global
           call _cbbzH(R1) args: 0, res: 0, upd: 0;
       cbbzI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbzH() //  [R1]
         { info_tbl: [(cbbzH,
                       label: block_cbbzH_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbzH: // global
           _sb7pt::I64 = I64[Sp + 32];
           I64[Sp + 32] = block_cbbzN_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = R1;
           I64[Sp + 16] = 0;
           I64[Sp + 24] = _sb7pt::I64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbbzN() //  []
         { info_tbl: [(cbbzN,
                       label: block_cbbzN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbzN: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$wwriteBlocks_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbbzU,
                       label: GHC.IO.Handle.Text.$wwriteBlocks_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, True, False, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbzU: // global
           _sb7oG::I64 = R6;
           _sb7oF::P64 = R5;
           _sb7oE::P64 = R4;
           _sb7oD::P64 = R3;
           _sb7oC::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cbbzV; else goto cbbzW;
       cbbzW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbbzY; else goto cbbzX;
       cbbzY: // global
           HpAlloc = 24;
           goto cbbzV;
       cbbzV: // global
           R1 = GHC.IO.Handle.Text.$wwriteBlocks_closure;
           P64[Sp - 40] = _sb7oC::P64;
           P64[Sp - 32] = _sb7oD::P64;
           P64[Sp - 24] = _sb7oE::P64;
           P64[Sp - 16] = _sb7oF::P64;
           I64[Sp - 8] = _sb7oG::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cbbzX: // global
           I64[Hp - 16] = sat_sb7r5_info;
           P64[Hp] = _sb7oE::P64;
           P64[Sp - 48] = _sb7oD::P64;
           P64[Sp - 40] = _sb7oF::P64;
           I64[Sp - 32] = _sb7oG::I64;
           I64[Sp - 24] = 0;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 16] = _sb7oC::P64;
           Sp = Sp - 48;
           call _cbbys() args: 0, res: 0, upd: 0;
     }
 },
 _cbbys() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbys: // global
           I64[Sp - 8] = block_cbbyv_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbBi; else goto cbbyw;
       ubbBi: // global
           call _cbbyv(R1) args: 0, res: 0, upd: 0;
       cbbyw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbyv() //  [R1]
         { info_tbl: [(cbbyv,
                       label: block_cbbyv_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbyv: // global
           if (R1 & 7 == 1) goto cbbA7; else goto cbbAj;
       cbbA7: // global
           I64[Sp] = block_cbbA4_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ubbBj; else goto cbbA8;
       ubbBj: // global
           call _cbbA4(R1) args: 0, res: 0, upd: 0;
       cbbA8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbAj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbbAm; else goto cbbAl;
       cbbAm: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbAl: // global
           _sb7oI::I64 = I64[Sp + 64];
           _sb7pt::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_sb7pt::I64 + 1,
                            _sb7oI::I64)) goto cbbAo; else goto cbbAS;
       cbbAo: // global
           _sb7pB::P64 = P64[R1 + 6];
           _sb7pC::P64 = P64[R1 + 14];
           Hp = Hp - 40;
           I64[Sp] = block_cbbyH_info;
           R1 = _sb7pB::P64;
           P64[Sp + 40] = _sb7pC::P64;
           if (R1 & 7 != 0) goto ubbBk; else goto cbbyI;
       ubbBk: // global
           call _cbbyH(R1) args: 0, res: 0, upd: 0;
       cbbyI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbAS: // global
           I64[Hp - 32] = sat_sb7r0_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = _sb7oI::I64;
           I64[Hp] = _sb7pt::I64;
           I64[Sp] = block_cbbAR_info;
           R4 = Hp - 30;
           R3 = P64[Sp + 72];
           R2 = lvl2_rb6WE_closure;
           P64[Sp + 40] = R1;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbA4() //  [R1]
         { info_tbl: [(cbbA4,
                       label: block_cbbA4_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbA4: // global
           _sb7pt::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cbbAe; else goto cbbAi;
       cbbAe: // global
           I64[Sp + 48] = _sb7pt::I64;
           Sp = Sp + 24;
           call _cbbxL() args: 0, res: 0, upd: 0;
       cbbAi: // global
           I64[Sp + 32] = _sb7pt::I64;
           P64[Sp + 40] = R1;
           P64[Sp + 48] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _cbbys() args: 0, res: 0, upd: 0;
     }
 },
 _cbbxL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbxL: // global
           Hp = Hp + 72;
           _sb7oM::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cbbA1; else goto cbbA0;
       cbbA1: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cbbxK_info;
           R1 = _sb7oM::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbbA0: // global
           I64[Hp - 64] = GHC.ForeignPtr.ForeignPtr_con_info;
           _sb7oH::P64 = P64[Sp + 32];
           P64[Hp - 56] = _sb7oH::P64;
           _sb7oG::I64 = I64[Sp];
           I64[Hp - 48] = _sb7oG::I64;
           I64[Hp - 40] = sat_sb7pr_info;
           P64[Hp - 32] = _sb7oH::P64;
           P64[Hp - 24] = Hp - 63;
           I64[Hp - 16] = _sb7oG::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _sb7oM::I64;
           R4 = Hp - 38;
           R3 = P64[Sp + 48];
           R2 = lvl2_rb6WE_closure;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbbxK() //  [R1]
         { info_tbl: [(cbbxK,
                       label: block_cbbxK_info
                       rep:StackRep [True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbxK: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cbbxL() args: 0, res: 0, upd: 0;
     }
 },
 _cbbyH() //  [R1]
         { info_tbl: [(cbbyH,
                       label: block_cbbyH_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbyH: // global
           _sb7pH::I64 = I64[R1 + 7];
           if (_sb7pH::I64 != 10) goto cbbAr; else goto cbbAF;
       cbbAr: // global
           _sb7oH::P64 = P64[Sp + 56];
           _sb7pt::I64 = I64[Sp + 32];
           _sb7pv::P64 = P64[Sp + 48];
           _sb7pC::P64 = P64[Sp + 40];
           I32[I64[Sp + 24] + (_sb7pt::I64 << 2)] = %MO_UU_Conv_W64_W32(_sb7pH::I64);
           call MO_Touch(_sb7oH::P64);
           I64[Sp + 32] = _sb7pt::I64 + 1;
           P64[Sp + 40] = _sb7pC::P64;
           P64[Sp + 48] = _sb7pv::P64;
           Sp = Sp + 8;
           call _cbbys() args: 0, res: 0, upd: 0;
       cbbAF: // global
           I64[Sp] = block_cbbAs_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubbBl; else goto cbbAG;
       ubbBl: // global
           call _cbbAs(R1) args: 0, res: 0, upd: 0;
       cbbAG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbAs() //  [R1]
         { info_tbl: [(cbbAs,
                       label: block_cbbAs_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbAs: // global
           _sb7oD::P64 = P64[Sp + 8];
           _sb7oG::I64 = I64[Sp + 24];
           _sb7oH::P64 = P64[Sp + 56];
           _sb7pt::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cbbAM; else goto cbbAQ;
       cbbAM: // global
           I32[_sb7oG::I64 + (_sb7pt::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb7oH::P64);
           _sb7pN::I64 = _sb7pt::I64 + 1;
           goto sb7pL;
       cbbAQ: // global
           I32[_sb7oG::I64 + (_sb7pt::I64 << 2)] = 13 :: W32;
           call MO_Touch(_sb7oH::P64);
           _sb7qA::I64 = _sb7pt::I64 + 1;
           I32[_sb7oG::I64 + (_sb7qA::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sb7oH::P64);
           _sb7pN::I64 = _sb7qA::I64 + 1;
           goto sb7pL;
       sb7pL: // global
           I64[Sp] = block_cbbyU_info;
           R1 = _sb7oD::P64;
           I64[Sp + 32] = _sb7pN::I64;
           if (R1 & 7 != 0) goto ubbBr; else goto cbbyV;
       ubbBr: // global
           call _cbbyU(R1) args: 0, res: 0, upd: 0;
       cbbyV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbyU() //  [R1]
         { info_tbl: [(cbbyU,
                       label: block_cbbyU_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbyU: // global
           _sb7pN::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cbbAx; else goto cbbAz;
       cbbAx: // global
           I64[Sp + 32] = _sb7pN::I64;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cbbys() args: 0, res: 0, upd: 0;
       cbbAz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbbAC; else goto cbbAB;
       cbbAC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbAB: // global
           I64[Hp - 32] = sat_sb7qq_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = I64[Sp + 64];
           I64[Hp] = _sb7pN::I64;
           I64[Sp] = block_cbbAy_info;
           R4 = Hp - 30;
           R3 = P64[Sp + 72];
           R2 = lvl2_rb6WE_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbAy() //  []
         { info_tbl: [(cbbAy,
                       label: block_cbbAy_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbAy: // global
           I64[Sp + 32] = 0;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cbbys() args: 0, res: 0, upd: 0;
     }
 },
 _cbbAR() //  []
         { info_tbl: [(cbbAR,
                       label: block_cbbAR_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbAR: // global
           I64[Sp + 32] = 0;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cbbys() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.372712885 UTC

[section ""cstring" . lvl33_rb6Xd_bytes" {
     lvl33_rb6Xd_bytes:
         I8[] [110,111,32,98,117,102,102,101,114,33]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.374811377 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr4_closure" {
     GHC.IO.Handle.Text.hPutStr4_closure:
         const GHC.IO.Handle.Text.hPutStr4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr4_entry() //  [R1]
         { info_tbl: [(cbbDW,
                       label: GHC.IO.Handle.Text.hPutStr4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbDW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbbDX; else goto cbbDY;
       cbbDX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbDY: // global
           (_cbbDR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbDR::I64 == 0) goto cbbDT; else goto cbbDS;
       cbbDT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbDS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbDR::I64;
           I64[Sp - 24] = block_cbbDU_info;
           R2 = lvl33_rb6Xd_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbbDU() //  [R1]
         { info_tbl: [(cbbDU,
                       label: block_cbbDU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbDU: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.380870878 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr3_closure" {
     GHC.IO.Handle.Text.hPutStr3_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.NoBuffering_closure+1;
         const GHC.IO.Handle.Text.hPutStr4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.384233564 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr2_closure" {
     GHC.IO.Handle.Text.hPutStr2_closure:
         const GHC.IO.Handle.Text.hPutStr2_info;
         const 0;
 },
 sat_sb7s6_entry() //  [R1]
         { info_tbl: [(cbbEH,
                       label: sat_sb7s6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbEH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbbEQ; else goto cbbER;
       cbbEQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbER: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbbEE_info;
           _sb7rw::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sb7rw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubbEX; else goto cbbEF;
       ubbEX: // global
           call _cbbEE(R1) args: 0, res: 0, upd: 0;
       cbbEF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbbEE() //  [R1]
         { info_tbl: [(cbbEE,
                       label: block_cbbEE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbEE: // global
           I64[Sp - 8] = block_cbbEK_info;
           _sb7rY::P64 = P64[R1 + 7];
           _sb7rX::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sb7rY::P64;
           I64[Sp + 8] = _sb7rX::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbEW; else goto cbbEL;
       ubbEW: // global
           call _cbbEK(R1) args: 0, res: 0, upd: 0;
       cbbEL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbbEK() //  [R1]
         { info_tbl: [(cbbEK,
                       label: block_cbbEK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbEK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbEV; else goto cbbEU;
       cbbEV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbbEU: // global
           _sb7s3::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = _sb7s3::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hPutStr2_entry() //  [R2]
         { info_tbl: [(cbbEY,
                       label: GHC.IO.Handle.Text.hPutStr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbEY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbbEZ; else goto cbbF0;
       cbbEZ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbF0: // global
           I64[Sp - 8] = block_cbbEh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbFV; else goto cbbEi;
       ubbFV: // global
           call _cbbEh(R1) args: 0, res: 0, upd: 0;
       cbbEi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbEh() //  [R1]
         { info_tbl: [(cbbEh,
                       label: block_cbbEh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbEh: // global
           I64[Sp - 24] = block_cbbEm_info;
           _sb7ri::P64 = P64[R1 + 71];
           _sb7rj::P64 = P64[R1 + 79];
           _sb7ro::P64 = P64[R1 + 119];
           R1 = P64[R1 + 55];
           P64[Sp - 16] = _sb7rj::P64;
           P64[Sp - 8] = _sb7ro::P64;
           P64[Sp] = _sb7ri::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubbFS; else goto cbbEn;
       ubbFS: // global
           call _cbbEm(R1) args: 0, res: 0, upd: 0;
       cbbEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbEm() //  [R1]
         { info_tbl: [(cbbEm,
                       label: block_cbbEm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbEm: // global
           if (R1 & 7 == 1) goto cbbFM; else goto cbbF4;
       cbbFM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbbFP; else goto cbbFO;
       cbbFP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbFO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Text.hPutStr3_closure+1;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbbF4: // global
           _sb7rt::P64 = P64[P64[Sp + 8] + 8];
           _sb7rw::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 8] = block_cbbEr_info;
           _sb7rq::P64 = R1;
           R1 = _sb7rt::P64;
           P64[Sp] = _sb7rw::P64;
           P64[Sp + 24] = _sb7rq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbFT; else goto cbbEs;
       ubbFT: // global
           call _cbbEr(R1) args: 0, res: 0, upd: 0;
       cbbEs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbEr() //  [R1]
         { info_tbl: [(cbbEr,
                       label: block_cbbEr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbEr: // global
           _sb7rw::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbbF9; else goto cbbFF;
       cbbF9: // global
           I64[Sp + 16] = block_cbbF6_info;
           R1 = _sb7rw::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubbFU; else goto cbbFa;
       ubbFU: // global
           call _cbbF6(R1) args: 0, res: 0, upd: 0;
       cbbFa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbFF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbbFI; else goto cbbFH;
       cbbFI: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbFH: // global
           _sb7rj::P64 = P64[Sp + 16];
           _sb7ro::P64 = P64[Sp + 24];
           _sb7rq::P64 = P64[Sp + 32];
           _sb7rT::P64 = P64[R1 + 6];
           _sb7rU::P64 = P64[R1 + 14];
           call MO_WriteBarrier();
           P64[_sb7rj::P64 + 8] = _sb7rU::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7rj::P64);
           I64[Hp - 72] = sat_sb7s6_info;
           P64[Hp - 56] = _sb7rw::P64;
           P64[Hp - 48] = _sb7rT::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = _sb7rq::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = _sb7ro::P64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbF6() //  [R1]
         { info_tbl: [(cbbF6,
                       label: block_cbbF6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbF6: // global
           _sb7rC::I64 = I64[R1 + 31];
           _sb7rF::I64 = _sb7rC::I64 << 2;
           if (%MO_S_Ge_W64(_sb7rF::I64, 0)) goto cbbFx; else goto cbbFC;
       cbbFx: // global
           I64[Sp - 16] = block_cbbFl_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _sb7rF::I64;
           I64[Sp] = _sb7rC::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbbFC: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbFl() //  [R1]
         { info_tbl: [(cbbFl,
                       label: block_cbbFl_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbFl: // global
           I64[Sp] = block_cbbFn_info;
           _sb7rJ::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _sb7rJ::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbFn() //  [R1]
         { info_tbl: [(cbbFn,
                       label: block_cbbFn_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbFn: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cbbFB; else goto cbbFA;
       cbbFB: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbFA: // global
           I64[Hp - 120] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 112] = R1;
           P64[Hp - 104] = P64[Sp + 8];
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = Hp - 118;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 72] = R1 + 16;
           I64[Hp - 64] = I64[Sp + 16];
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = Hp - 95;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.40731623 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutStr6_bytes" {
     GHC.IO.Handle.Text.hPutStr6_bytes:
         I8[] [104,80,117,116,83,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.409550454 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr5_closure" {
     GHC.IO.Handle.Text.hPutStr5_closure:
         const GHC.IO.Handle.Text.hPutStr5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr5_entry() //  [R1]
         { info_tbl: [(cbbH4,
                       label: GHC.IO.Handle.Text.hPutStr5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbH4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbbH5; else goto cbbH6;
       cbbH5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbH6: // global
           (_cbbH1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbH1::I64 == 0) goto cbbH3; else goto cbbH2;
       cbbH3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbH2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbH1::I64;
           R2 = GHC.IO.Handle.Text.hPutStr6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.414769971 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr1_closure" {
     GHC.IO.Handle.Text.hPutStr1_closure:
         const GHC.IO.Handle.Text.hPutStr1_info;
         const 0;
 },
 section ""relreadonly" . ubbJ5_srtd" {
     ubbJ5_srtd:
         const Sb7vQ_srt+16;
         const 74;
         const 19;
         const 836;
 },
 GHC.IO.Handle.Text.hPutStr1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbbHr,
                       label: GHC.IO.Handle.Text.hPutStr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbHr: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbbHs; else goto cbbHt;
       cbbHs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbbHt: // global
           I64[Sp - 32] = block_cbbHk_info;
           R1 = R2;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubbIU; else goto cbbHl;
       ubbIU: // global
           call _cbbHk(R1) args: 0, res: 0, upd: 0;
       cbbHl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbJ6_srtd" {
     ubbJ6_srtd:
         const Sb7vQ_srt+16;
         const 74;
         const 19;
         const 580;
 },
 _cbbHk() //  [R1]
         { info_tbl: [(cbbHk,
                       label: block_cbbHk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbHk: // global
           if (R1 & 7 == 1) goto cbbHo; else goto cbbHp;
       cbbHo: // global
           I64[Sp] = block_cbbIh_info;
           R5 = GHC.IO.Handle.Text.hPutStr2_closure+2;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutStr5_closure;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 8, upd: 8;
       cbbHp: // global
           I64[Sp] = block_cbbIz_info;
           R5 = GHC.IO.Handle.Text.hPutStr2_closure+2;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutStr5_closure;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbJ7_srtd" {
     ubbJ7_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbbIh() //  [R1]
         { info_tbl: [(cbbIh,
                       label: block_cbbIh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbIh: // global
           I64[Sp] = block_cbbIj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubbIY; else goto cbbIk;
       ubbIY: // global
           call _cbbIj(R1) args: 0, res: 0, upd: 0;
       cbbIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbJ8_srtd" {
     ubbJ8_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbbIj() //  [R1]
         { info_tbl: [(cbbIj,
                       label: block_cbbIj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbIj: // global
           I64[Sp - 8] = block_cbbIo_info;
           _sb7sL::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sb7sL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbIZ; else goto cbbIs;
       ubbIZ: // global
           call _cbbIo(R1) args: 0, res: 0, upd: 0;
       cbbIs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbJ9_srtd" {
     ubbJ9_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbbIo() //  [R1]
         { info_tbl: [(cbbIo,
                       label: block_cbbIo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbIo: // global
           _sb7si::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp - 8] = _sb7si::P64;
           Sp = Sp - 8;
           call _sb7se() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubbJa_srtd" {
     ubbJa_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbbIz() //  [R1]
         { info_tbl: [(cbbIz,
                       label: block_cbbIz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbIz: // global
           I64[Sp] = block_cbbIB_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubbJ1; else goto cbbIC;
       ubbJ1: // global
           call _cbbIB(R1) args: 0, res: 0, upd: 0;
       cbbIC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbJb_srtd" {
     ubbJb_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbbIB() //  [R1]
         { info_tbl: [(cbbIB,
                       label: block_cbbIB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbIB: // global
           I64[Sp - 8] = block_cbbIG_info;
           _sb7sX::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sb7sX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbJ2; else goto cbbIK;
       ubbJ2: // global
           call _cbbIG(R1) args: 0, res: 0, upd: 0;
       cbbIK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbJc_srtd" {
     ubbJc_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbbIG() //  [R1]
         { info_tbl: [(cbbIG,
                       label: block_cbbIG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbIG: // global
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call _sb7se() args: 0, res: 0, upd: 0;
     }
 },
 _sb7se() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sb7se: // global
           I64[Sp - 8] = block_cbbHx_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubbJ4; else goto cbbHz;
       ubbJ4: // global
           call _cbbHx(R1) args: 0, res: 0, upd: 0;
       cbbHz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubbJd_srtd" {
     ubbJd_srtd:
         const Sb7vQ_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbbHx() //  [R1]
         { info_tbl: [(cbbHx,
                       label: block_cbbHx_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbHx: // global
           _sb7sh::P64 = P64[Sp + 16];
           _cbbIP::P64 = R1 & 7;
           if (_cbbIP::P64 < 3) goto ubbIR; else goto cbbI9;
       ubbIR: // global
           if (_cbbIP::P64 < 2) goto cbbHI; else goto cbbHZ;
       cbbHI: // global
           I64[Sp + 24] = block_cbbHD_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.hPutStr7_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cbbHZ: // global
           I64[Sp] = block_cbbHX_info;
           R1 = _sb7sh::P64;
           if (R1 & 7 != 0) goto ubbIV; else goto cbbI0;
       ubbIV: // global
           call _cbbHX(R1) args: 0, res: 0, upd: 0;
       cbbI0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbI9: // global
           I64[Sp] = block_cbbI7_info;
           R1 = _sb7sh::P64;
           if (R1 & 7 != 0) goto ubbIW; else goto cbbIa;
       ubbIW: // global
           call _cbbI7(R1) args: 0, res: 0, upd: 0;
       cbbIa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbHD() //  []
         { info_tbl: [(cbbHD,
                       label: block_cbbHD_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbHD: // global
           I64[Sp] = block_cbbHF_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto ubbIX; else goto cbbHK;
       ubbIX: // global
           call _cbbHF(R1) args: 0, res: 0, upd: 0;
       cbbHK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbHF() //  [R1]
         { info_tbl: [(cbbHF,
                       label: block_cbbHF_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbHF: // global
           if (R1 & 7 == 1) goto cbbHQ; else goto cbbHU;
       cbbHQ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbbHU: // global
           R3 = 10;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbbHX() //  [R1]
         { info_tbl: [(cbbHX,
                       label: block_cbbHX_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbHX: // global
           R6 = I64[R1 + 23];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = GHC.Types.True_closure+2;
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           _sb7sb::P64 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 31];
           P64[Sp + 48] = _sb7sb::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 _cbbI7() //  [R1]
         { info_tbl: [(cbbI7,
                       label: block_cbbI7_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbI7: // global
           R6 = I64[R1 + 23];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = GHC.Types.False_closure+1;
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           _sb7sb::P64 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 31];
           P64[Sp + 48] = _sb7sb::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.447159248 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr'_closure" {
     GHC.IO.Handle.Text.hPutStr'_closure:
         const GHC.IO.Handle.Text.hPutStr'_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr'_entry() //  [R2, R3, R4]
         { info_tbl: [(cbbKw,
                       label: GHC.IO.Handle.Text.hPutStr'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbKw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.450869242 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr_closure" {
     GHC.IO.Handle.Text.hPutStr_closure:
         const GHC.IO.Handle.Text.hPutStr_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr_entry() //  [R2, R3]
         { info_tbl: [(cbbKH,
                       label: GHC.IO.Handle.Text.hPutStr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbKH: // global
           R4 = GHC.Types.False_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.45473052 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStrLn_closure" {
     GHC.IO.Handle.Text.hPutStrLn_closure:
         const GHC.IO.Handle.Text.hPutStrLn_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStrLn_entry() //  [R2, R3]
         { info_tbl: [(cbbKS,
                       label: GHC.IO.Handle.Text.hPutStrLn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbKS: // global
           R4 = GHC.Types.True_closure+2;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.457926341 UTC

[section ""cstring" . GHC.IO.Handle.Text.hWaitForInput3_bytes" {
     GHC.IO.Handle.Text.hWaitForInput3_bytes:
         I8[] [104,87,97,105,116,70,111,114,73,110,112,117,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.459797053 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput2_closure" {
     GHC.IO.Handle.Text.hWaitForInput2_closure:
         const GHC.IO.Handle.Text.hWaitForInput2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hWaitForInput2_entry() //  [R1]
         { info_tbl: [(cbbL6,
                       label: GHC.IO.Handle.Text.hWaitForInput2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbL6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbbL7; else goto cbbL8;
       cbbL7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbL8: // global
           (_cbbL3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbbL3::I64 == 0) goto cbbL5; else goto cbbL4;
       cbbL5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbbL4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbbL3::I64;
           R2 = GHC.IO.Handle.Text.hWaitForInput3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.467411791 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput1_closure" {
     GHC.IO.Handle.Text.hWaitForInput1_closure:
         const GHC.IO.Handle.Text.hWaitForInput1_info;
         const 0;
 },
 lvl34_sb7t8_entry() //  [R1]
         { info_tbl: [(cbbLr,
                       label: lvl34_sb7t8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbLr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbbLs; else goto cbbLt;
       cbbLs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbbLt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbbLo_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubbLy; else goto cbbLp;
       ubbLy: // global
           call _cbbLo(R1) args: 0, res: 0, upd: 0;
       cbbLp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbbLo() //  [R1]
         { info_tbl: [(cbbLo,
                       label: block_cbbLo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbLo: // global
           R1 = I64[(%MO_S_Lt_W64(I64[R1 + 7],
                                  0) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sb7v9_entry() //  [R1, R2]
         { info_tbl: [(cbbLH,
                       label: sat_sb7v9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbLH: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cbbLL; else goto cbbLM;
       cbbLL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbLM: // global
           I64[Sp - 24] = block_cbbLE_info;
           _sb7t6::P64 = P64[R1 + 6];
           _sb7t8::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sb7t6::P64;
           P64[Sp - 8] = _sb7t8::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubbOt; else goto cbbLF;
       ubbOt: // global
           call _cbbLE(R1) args: 0, res: 0, upd: 0;
       cbbLF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbLE() //  [R1]
         { info_tbl: [(cbbLE,
                       label: block_cbbLE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbLE: // global
           I64[Sp - 56] = block_cbbLK_info;
           _sb7te::P64 = R1;
           _sb7tf::P64 = P64[R1 + 7];
           _sb7ti::P64 = P64[R1 + 31];
           _sb7tk::P64 = P64[R1 + 47];
           _sb7tm::P64 = P64[R1 + 63];
           _sb7tn::P64 = P64[R1 + 71];
           _sb7tq::P64 = P64[R1 + 95];
           R1 = P64[_sb7tn::P64 + 8];
           P64[Sp - 48] = _sb7tf::P64;
           P64[Sp - 40] = _sb7ti::P64;
           P64[Sp - 32] = _sb7tk::P64;
           P64[Sp - 24] = _sb7tm::P64;
           P64[Sp - 16] = _sb7tn::P64;
           P64[Sp - 8] = _sb7tq::P64;
           P64[Sp] = _sb7te::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ubbOs; else goto cbbLO;
       ubbOs: // global
           call _cbbLK(R1) args: 0, res: 0, upd: 0;
       cbbLO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbLK() //  [R1]
         { info_tbl: [(cbbLK,
                       label: block_cbbLK_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbLK: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbbM0; else goto ubbOo;
       cbbM0: // global
           I64[Sp] = block_cbbLZ_info;
           _sb7ty::P64 = R1;
           R1 = P64[Sp + 72];
           P64[Sp + 72] = _sb7ty::P64;
           if (R1 & 7 != 0) goto ubbOu; else goto cbbM1;
       ubbOu: // global
           call _cbbLZ(R1) args: 0, res: 0, upd: 0;
       cbbM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubbOo: // global
           Sp = Sp + 80;
           call _cbbMm() args: 0, res: 0, upd: 0;
     }
 },
 _cbbLZ() //  [R1]
         { info_tbl: [(cbbLZ,
                       label: block_cbbLZ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbLZ: // global
           if (R1 & 7 == 1) goto cbbMW; else goto cbbO7;
       cbbMW: // global
           _sb7tJ::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbbM7_info;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _sb7tJ::P64;
           if (R1 & 7 != 0) goto ubbOw; else goto cbbMX;
       ubbOw: // global
           call _cbbM7(R1) args: 0, res: 0, upd: 0;
       cbbMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbbO7: // global
           I64[Sp + 32] = block_cbbO5_info;
           R3 = P64[Sp + 72];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbM7() //  [R1]
         { info_tbl: [(cbbM7,
                       label: block_cbbM7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbM7: // global
           if (R1 & 7 == 1) goto cbbNh; else goto cbbNR;
       cbbNh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbbNk; else goto cbbNj;
       cbbNk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbNj: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sb7tJ::P64 = P64[Sp + 48];
           P64[Hp] = _sb7tJ::P64;
           _sb7tm::P64 = P64[Sp + 32];
           _sb7ty::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sb7tm::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tm::P64);
           I64[Sp] = block_cbbN5_info;
           R3 = _sb7ty::P64;
           R2 = _sb7tJ::P64;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cbbNR: // global
           I64[Sp] = block_cbbNu_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubbOx; else goto cbbNv;
       ubbOx: // global
           call _cbbNu(R1) args: 0, res: 0, upd: 0;
       cbbNv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbN5() //  [R1]
         { info_tbl: [(cbbN5,
                       label: block_cbbN5_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbN5: // global
           I64[Sp] = block_cbbN7_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubbOB; else goto cbbN8;
       ubbOB: // global
           call _cbbN7(R1) args: 0, res: 0, upd: 0;
       cbbN8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbN7() //  [R1]
         { info_tbl: [(cbbN7,
                       label: block_cbbN7_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbN7: // global
           _sb7tk::P64 = P64[Sp + 24];
           _sb7uv::P64 = P64[R1 + 15];
           _sb7uw::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sb7tk::P64 + 8] = _sb7uv::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tk::P64);
           I64[Sp] = block_cbbNf_info;
           R1 = _sb7uw::P64;
           if (R1 & 7 != 0) goto ubbOC; else goto cbbNn;
       ubbOC: // global
           call _cbbNf(R1) args: 0, res: 0, upd: 0;
       cbbNn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbNf() //  [R1]
         { info_tbl: [(cbbNf,
                       label: block_cbbNf_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbNf: // global
           I64[Sp + 72] = I64[R1 + 23];
           P64[Sp + 48] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 24] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           Sp = Sp - 16;
           call _cbbM9() args: 0, res: 0, upd: 0;
     }
 },
 _cbbNu() //  [R1]
         { info_tbl: [(cbbNu,
                       label: block_cbbNu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbNu: // global
           I64[Sp - 16] = block_cbbNz_info;
           _sb7uH::P64 = P64[R1 + 7];
           _sb7uI::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sb7uI::P64;
           P64[Sp] = _sb7uH::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbNz() //  [R1]
         { info_tbl: [(cbbNz,
                       label: block_cbbNz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbNz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbbNV; else goto cbbNU;
       cbbNV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbbNU: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sb7tJ::P64 = P64[Sp + 64];
           P64[Hp] = _sb7tJ::P64;
           _sb7tm::P64 = P64[Sp + 48];
           _sb7ty::P64 = P64[Sp + 88];
           _sb7uH::P64 = P64[Sp + 16];
           _sb7uI::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7tm::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tm::P64);
           I64[Sp + 16] = block_cbbNF_info;
           R5 = _sb7ty::P64;
           R4 = _sb7tJ::P64;
           R3 = _sb7uI::P64;
           R2 = _sb7uH::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbbNF() //  [R1]
         { info_tbl: [(cbbNF,
                       label: block_cbbNF_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbNF: // global
           I64[Sp] = block_cbbNH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubbOE; else goto cbbNI;
       ubbOE: // global
           call _cbbNH(R1) args: 0, res: 0, upd: 0;
       cbbNI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbNH() //  [R1]
         { info_tbl: [(cbbNH,
                       label: block_cbbNH_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbNH: // global
           _sb7tk::P64 = P64[Sp + 24];
           _sb7uV::P64 = P64[R1 + 7];
           _sb7uW::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sb7tk::P64 + 8] = _sb7uV::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tk::P64);
           I64[Sp] = block_cbbNP_info;
           R1 = _sb7uW::P64;
           if (R1 & 7 != 0) goto ubbOF; else goto cbbNY;
       ubbOF: // global
           call _cbbNP(R1) args: 0, res: 0, upd: 0;
       cbbNY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbNP() //  [R1]
         { info_tbl: [(cbbNP,
                       label: block_cbbNP_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbNP: // global
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 24] = I64[R1 + 31];
           P64[Sp + 32] = P64[R1 + 15];
           P64[Sp + 48] = P64[R1 + 7];
           I64[Sp + 72] = I64[R1 + 23];
           Sp = Sp - 16;
           call _cbbM9() args: 0, res: 0, upd: 0;
     }
 },
 _cbbM9() //  []
         { info_tbl: [(cbbM9,
                       label: block_cbbM9_info
                       rep:StackRep [True, True, False, False, True, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbM9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbMe; else goto cbbMd;
       cbbMe: // global
           HpAlloc = 56;
           I64[Sp] = block_cbbM9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbbMd: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 48];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 40];
           _sb7tQ::I64 = I64[Sp + 16];
           I64[Hp - 8] = _sb7tQ::I64;
           _sb7tR::I64 = I64[Sp + 8];
           I64[Hp] = _sb7tR::I64;
           _sb7t6::P64 = P64[Sp + 80];
           _sb7tf::P64 = P64[Sp + 24];
           _sb7ti::P64 = P64[Sp + 32];
           _sb7tn::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           if (_sb7tQ::I64 == _sb7tR::I64) goto cbbMs; else goto ubbOr;
       cbbMs: // global
           I64[Sp + 48] = block_cbbMp_info;
           R2 = _sb7tf::P64;
           I64[Sp + 16] = stg_ap_pppv_info;
           P64[Sp + 24] = _sb7ti::P64;
           P64[Sp + 32] = GHC.Types.False_closure+1;
           P64[Sp + 40] = _sb7t6::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.ready_entry(R2) args: 40, res: 8, upd: 8;
       ubbOr: // global
           Sp = Sp + 96;
           call _cbbMm() args: 0, res: 0, upd: 0;
     }
 },
 _cbbMp() //  [R1]
         { info_tbl: [(cbbMp,
                       label: block_cbbMp_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbMp: // global
           I64[Sp] = block_cbbMr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubbOz; else goto cbbMu;
       ubbOz: // global
           call _cbbMr(R1) args: 0, res: 0, upd: 0;
       cbbMu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbMr() //  [R1]
         { info_tbl: [(cbbMr,
                       label: block_cbbMr_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbMr: // global
           if (R1 & 7 == 1) goto cbbMA; else goto cbbMF;
       cbbMA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbbMF: // global
           _sb7u1::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_cbbMD_info;
           R1 = _sb7u1::P64;
           if (R1 & 7 != 0) goto ubbOA; else goto cbbMG;
       ubbOA: // global
           call _cbbMD(R1) args: 0, res: 0, upd: 0;
       cbbMG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbMD() //  [R1]
         { info_tbl: [(cbbMD,
                       label: block_cbbMD_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbMD: // global
           _sb7u4::P64 = P64[R1 + 7];
           _sb7u3::I64 = I64[R1 + 23];
           _sb7u7::I64 = I64[R1 + 39];
           if (_sb7u7::I64 == I64[R1 + 47]) goto cbbMS; else goto cbbMO;
       cbbMS: // global
           I64[Sp] = block_cbbMR_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           I64[Sp + 24] = _sb7u7::I64;
           P64[Sp + 32] = _sb7u4::P64;
           I64[Sp + 40] = _sb7u3::I64;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbbMO: // global
           _sb7tn::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           call MO_Touch(_sb7u4::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbMR() //  [R1]
         { info_tbl: [(cbbMR,
                       label: block_cbbMR_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbMR: // global
           _sb7tn::P64 = P64[Sp + 8];
           _sb7u3::I64 = I64[Sp + 40];
           _sb7u4::P64 = P64[Sp + 32];
           _sb7u7::I64 = I64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           call MO_Touch(_sb7u4::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbO5() //  [R1]
         { info_tbl: [(cbbO5,
                       label: block_cbbO5_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbO5: // global
           _sb7tn::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sb7tn::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sb7tn::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbbMm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbMm: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubbOM_srtd" {
     ubbOM_srtd:
         const Sb7vQ_srt+96;
         const 70;
         const 1;
         const 60;
 },
 GHC.IO.Handle.Text.hWaitForInput1_entry() //  [R2, R3]
         { info_tbl: [(cbbOH,
                       label: GHC.IO.Handle.Text.hWaitForInput1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbOH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbbOL; else goto cbbOK;
       cbbOL: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hWaitForInput1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbbOK: // global
           I64[Hp - 40] = lvl34_sb7t8_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sb7v9_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hWaitForInput2_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.514415185 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput_closure" {
     GHC.IO.Handle.Text.hWaitForInput_closure:
         const GHC.IO.Handle.Text.hWaitForInput_info;
         const 0;
 },
 GHC.IO.Handle.Text.hWaitForInput_entry() //  [R2, R3]
         { info_tbl: [(cbbQW,
                       label: GHC.IO.Handle.Text.hWaitForInput_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbQW: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hWaitForInput1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:04.518085639 UTC

[section ""relreadonly" . Sb7vQ_srt" {
     Sb7vQ_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Text.$willegalBufferSize_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Text.$whPutChar_closure;
         const GHC.IO.Handle.Text.hPutChar2_closure;
         const GHC.IO.Handle.Text.hPutChar1_closure;
         const GHC.IO.Handle.Text.hPutStr7_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Text.hGetChar3_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Text.hGetChar2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.hGetChar6_closure;
         const GHC.IO.Handle.Text.hGetChar1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Text.hGetContents3_closure;
         const $wlvl_rb6WI_closure;
         const lvl6_rb6WK_closure;
         const lvl7_rb6WL_closure;
         const lvl9_rb6WN_closure;
         const lvl10_rb6WO_closure;
         const lvl4_rb6WH_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Text.hGetContents2_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
         const GHC.IO.Handle.Text.hGetContents1_closure;
         const GHC.IO.Handle.Internals.ioe_EOF1_closure;
         const GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure;
         const GHC.IO.Handle.Text.hGetLine3_closure;
         const GHC.IO.Handle.Text.hGetLine2_closure;
         const GHC.IO.Handle.Text.hGetLine4_closure;
         const GHC.IO.Handle.Text.hGetLine1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.Text.$wbufReadNBEmpty_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking2_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const lvl11_rb6WR_closure;
         const GHC.IO.Handle.Text.$whGetBufNonBlocking_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking1_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.Handle.Text.$whGetBufSome_closure;
         const lvl13_rb6WT_closure;
         const GHC.IO.Handle.Text.hGetBufSome1_closure;
         const GHC.IO.Handle.Text.hGetBuf2_closure;
         const GHC.IO.Handle.Text.hGetBuf4_closure;
         const GHC.IO.Handle.Text.$whGetBuf_closure;
         const GHC.IO.Handle.Text.hGetBuf5_closure;
         const GHC.IO.Handle.Text.hGetBuf1_closure;
         const GHC.Err.error_closure;
         const lvl24_rb6X4_closure;
         const lvl29_rb6X9_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const GHC.IO.Handle.Text.$wbufWrite_closure;
         const lvl26_rb6X6_closure;
         const lvl30_rb6Xa_closure;
         const GHC.IO.Handle.Text.$whPutBuf'_closure;
         const GHC.IO.Handle.Text.hPutBuf3_closure;
         const GHC.IO.Handle.Text.hPutBuf2_closure;
         const GHC.IO.Handle.Text.hPutBufNonBlocking1_closure;
         const GHC.IO.Handle.Text.hPutBuf1_closure;
         const lvl32_rb6Xc_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.Text.$wwriteBlocks_closure;
         const lvl2_rb6WE_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const GHC.IO.Handle.Text.hPutStr2_closure;
         const GHC.IO.Handle.Text.hPutStr3_closure;
         const GHC.IO.Handle.Text.hPutStr1_closure;
         const GHC.IO.Handle.Text.hPutStr5_closure;
         const GHC.IO.Handle.Text.$whPutChar_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Text.hWaitForInput1_closure;
         const GHC.IO.Handle.Text.hWaitForInput2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.488863589 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:10.489975451 UTC

[section ""cstring" . lvl_rb6WB_bytes" {
     lvl_rb6WB_bytes:
         I8[] [105,108,108,101,103,97,108,32,98,117,102,102,101,114,32,115,105,122,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.492540723 UTC

[section ""data" . GHC.IO.Handle.Text.$willegalBufferSize_closure" {
     GHC.IO.Handle.Text.$willegalBufferSize_closure:
         const GHC.IO.Handle.Text.$willegalBufferSize_info;
         const 0;
 },
 sat_sbbRc_entry() //  [R1]
         { info_tbl: [(cbcpj,
                       label: sat_sbbRc_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcpj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbcpk; else goto cbcpl;
       cbcpk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcpl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbcpg_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 9;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbcpg() //  [R1, R2]
         { info_tbl: [(cbcpg,
                       label: block_cbcpg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcpg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbcpo; else goto cbcpn;
       cbcpo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbcpn: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbbRd_entry() //  [R1]
         { info_tbl: [(cbcpp,
                       label: sat_sbbRd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcpp: // global
           _sbbRd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcpq; else goto cbcpr;
       cbcpr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbcpt; else goto cbcps;
       cbcpt: // global
           HpAlloc = 24;
           goto cbcpq;
       cbcpq: // global
           R1 = _sbbRd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcps: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbbRd::P64;
           _sbbR6::I64 = I64[_sbbRd::P64 + 16];
           I64[Hp - 16] = sat_sbbRc_info;
           I64[Hp] = _sbbR6::I64;
           R3 = Hp - 16;
           R2 = lvl_rb6WB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbbRf_entry() //  [R1]
         { info_tbl: [(cbcpw,
                       label: sat_sbbRf_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcpw: // global
           _sbbRf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcpx; else goto cbcpy;
       cbcpy: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbcpA; else goto cbcpz;
       cbcpA: // global
           HpAlloc = 96;
           goto cbcpx;
       cbcpx: // global
           R1 = _sbbRf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcpz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbbRf::P64;
           _sbbR4::P64 = P64[_sbbRf::P64 + 16];
           _sbbR5::P64 = P64[_sbbRf::P64 + 24];
           _sbbR6::I64 = I64[_sbbRf::P64 + 32];
           I64[Hp - 88] = sat_sbbRd_info;
           I64[Hp - 72] = _sbbR6::I64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbbR4::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.InvalidArgument_closure+1;
           P64[Hp - 24] = _sbbR5::P64;
           P64[Hp - 16] = Hp - 88;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.$willegalBufferSize_entry() //  [R2, R3, R4]
         { info_tbl: [(cbcpB,
                       label: GHC.IO.Handle.Text.$willegalBufferSize_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcpB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbcpF; else goto cbcpE;
       cbcpF: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$willegalBufferSize_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbcpE: // global
           I64[Hp - 32] = sat_sbbRf_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           I64[Hp] = R4;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.504713273 UTC

[section ""cstring" . GHC.IO.Handle.Text.$trModule4_bytes" {
     GHC.IO.Handle.Text.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.506386622 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule3_closure" {
     GHC.IO.Handle.Text.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Text.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.508134174 UTC

[section ""cstring" . GHC.IO.Handle.Text.$trModule2_bytes" {
     GHC.IO.Handle.Text.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101,46,84,101,120,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.509807147 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule1_closure" {
     GHC.IO.Handle.Text.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.Text.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.511474022 UTC

[section ""data" . GHC.IO.Handle.Text.$trModule_closure" {
     GHC.IO.Handle.Text.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.Text.$trModule3_closure+1;
         const GHC.IO.Handle.Text.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.514193381 UTC

[section ""data" . memcpy1_rb6WC_closure" {
     memcpy1_rb6WC_closure:
         const memcpy1_rb6WC_info;
 },
 memcpy1_rb6WC_entry() //  [R2, R3, R4]
         { info_tbl: [(cbcqw,
                       label: memcpy1_rb6WC_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcqw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbcqO; else goto cbcqP;
       cbcqO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = memcpy1_rb6WC_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbcqP: // global
           I64[Sp - 24] = block_cbcqt_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubcqW; else goto cbcqu;
       ubcqW: // global
           call _cbcqt(R1) args: 0, res: 0, upd: 0;
       cbcqu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcqt() //  [R1]
         { info_tbl: [(cbcqt,
                       label: block_cbcqt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcqt: // global
           I64[Sp] = block_cbcqz_info;
           _sbbRl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sbbRl::I64;
           if (R1 & 7 != 0) goto ubcqV; else goto cbcqA;
       ubcqV: // global
           call _cbcqz(R1) args: 0, res: 0, upd: 0;
       cbcqA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcqz() //  [R1]
         { info_tbl: [(cbcqz,
                       label: block_cbcqz_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcqz: // global
           I64[Sp] = block_cbcqE_info;
           _sbbRn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sbbRn::I64;
           if (R1 & 7 != 0) goto ubcqX; else goto cbcqF;
       ubcqX: // global
           call _cbcqE(R1) args: 0, res: 0, upd: 0;
       cbcqF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcqE() //  [R1]
         { info_tbl: [(cbcqE,
                       label: block_cbcqE_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcqE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbcqU; else goto cbcqT;
       cbcqU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcqT: // global
           (_sbbRt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbbRt::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.524700121 UTC

[section ""data" . GHC.IO.Handle.Text.memcpy_closure" {
     GHC.IO.Handle.Text.memcpy_closure:
         const GHC.IO.Handle.Text.memcpy_info;
 },
 GHC.IO.Handle.Text.memcpy_entry() //  [R2, R3, R4]
         { info_tbl: [(cbcro,
                       label: GHC.IO.Handle.Text.memcpy_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcro: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call memcpy1_rb6WC_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.530388494 UTC

[section ""data" . GHC.IO.Handle.Text.$wcommitBuffer'_closure" {
     GHC.IO.Handle.Text.$wcommitBuffer'_closure:
         const GHC.IO.Handle.Text.$wcommitBuffer'_info;
 },
 GHC.IO.Handle.Text.$wcommitBuffer'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcrw: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wcommitBuffer'_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$wcommitBuffer'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbcrD,
                       label: GHC.IO.Handle.Text.$wcommitBuffer'_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [True, False, True, True, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcrD: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cbcrE; else goto cbcrF;
       cbcrE: // global
           R1 = GHC.IO.Handle.Text.$wcommitBuffer'_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cbcrF: // global
           I64[Sp - 40] = block_cbcrA_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           I64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubcu8; else goto cbcrB;
       ubcu8: // global
           call _cbcrA(R1) args: 0, res: 0, upd: 0;
       cbcrB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcrA() //  [R1]
         { info_tbl: [(cbcrA,
                       label: block_cbcrA_info
                       rep:StackRep [False, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcrA: // global
           I64[Sp - 40] = block_cbcrI_info;
           R6 = I64[Sp + 16];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 8];
           R3 = I64[Sp + 48];
           R2 = R1;
           I64[Sp - 56] = 0;
           I64[Sp - 48] = I64[Sp + 24];
           P64[Sp - 32] = P64[R1 + 31];
           P64[Sp - 24] = P64[R1 + 47];
           P64[Sp - 16] = P64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 79];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 56;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbcrI() //  []
         { info_tbl: [(cbcrI,
                       label: block_cbcrI_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcrI: // global
           I64[Sp] = block_cbcrK_info;
           R1 = P64[Sp + 72];
           if (R1 & 7 != 0) goto ubcu9; else goto cbcrN;
       ubcu9: // global
           call _cbcrK(R1) args: 0, res: 0, upd: 0;
       cbcrN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcrK() //  [R1]
         { info_tbl: [(cbcrK,
                       label: block_cbcrK_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcrK: // global
           if (R1 & 7 == 1) goto cbcrU; else goto cbcsz;
       cbcrU: // global
           I64[Sp + 16] = block_cbcrR_info;
           R1 = P64[Sp + 80];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubcua; else goto cbcrV;
       ubcua: // global
           call _cbcrR(R1) args: 0, res: 0, upd: 0;
       cbcrV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbcsz: // global
           _sbbSl::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbcsx_info;
           R1 = _sbbSl::P64;
           if (R1 & 7 != 0) goto ubcub; else goto cbcsA;
       ubcub: // global
           call _cbcsx(R1) args: 0, res: 0, upd: 0;
       cbcsA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcrR() //  [R1]
         { info_tbl: [(cbcrR,
                       label: block_cbcrR_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcrR: // global
           if (R1 & 7 == 1) goto cbcs1; else goto cbcs9;
       cbcs1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbcs4; else goto cbcs3;
       cbcs4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcs3: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcs9: // global
           _sbbS2::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cbcs7_info;
           R1 = _sbbS2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubcuc; else goto cbcsa;
       ubcuc: // global
           call _cbcs7(R1) args: 0, res: 0, upd: 0;
       cbcsa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcs7() //  [R1]
         { info_tbl: [(cbcs7,
                       label: block_cbcs7_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcs7: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbcsg; else goto cbcsf;
       cbcsg: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcsf: // global
           _sbbRv::I64 = I64[Sp + 64];
           _sbbRw::P64 = P64[Sp + 24];
           _sbbRx::I64 = I64[Sp + 32];
           _sbbRy::I64 = I64[Sp + 40];
           if (_sbbRx::I64 == I64[R1 + 31]) goto cbcsu; else goto cbcsm;
       cbcsu: // global
           _sbbRN::P64 = P64[Sp + 8];
           _sbbSe::P64 = P64[_sbbRN::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sbbRw::P64;
           I64[Hp - 80] = _sbbRv::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sbbSe::P64;
           call MO_WriteBarrier();
           P64[_sbbRN::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbRN::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbRw::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sbbRv::I64;
           I64[Hp - 16] = _sbbRx::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sbbRy::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcsm: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sbbRw::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sbbRv::I64;
           I64[Hp - 64] = _sbbRx::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sbbRy::I64;
           _cbcsk::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cbcsk::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcsx() //  [R1]
         { info_tbl: [(cbcsx,
                       label: block_cbcsx_info
                       rep:StackRep [False, False, False, False, False, False, True, True,
                                     True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcsx: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbctt; else goto cbcsP;
       cbctt: // global
           I64[Sp + 16] = block_cbcts_info;
           R1 = P64[Sp + 80];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubcud; else goto cbctu;
       ubcud: // global
           call _cbcts(R1) args: 0, res: 0, upd: 0;
       cbctu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbcsP: // global
           _sbbRH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbcsI_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sbbRH::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbcts() //  [R1]
         { info_tbl: [(cbcts,
                       label: block_cbcts_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcts: // global
           if (R1 & 7 == 1) goto cbctA; else goto cbctI;
       cbctA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbctD; else goto cbctC;
       cbctD: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbctC: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbctI: // global
           _sbbSX::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cbctG_info;
           R1 = _sbbSX::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubcug; else goto cbctJ;
       ubcug: // global
           call _cbctG(R1) args: 0, res: 0, upd: 0;
       cbctJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbctG() //  [R1]
         { info_tbl: [(cbctG,
                       label: block_cbctG_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbctG: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbctP; else goto cbctO;
       cbctP: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbctO: // global
           _sbbRv::I64 = I64[Sp + 64];
           _sbbRw::P64 = P64[Sp + 24];
           _sbbRx::I64 = I64[Sp + 32];
           _sbbRy::I64 = I64[Sp + 40];
           if (_sbbRx::I64 == I64[R1 + 31]) goto cbcu3; else goto cbctV;
       cbcu3: // global
           _sbbRN::P64 = P64[Sp + 8];
           _sbbT9::P64 = P64[_sbbRN::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sbbRw::P64;
           I64[Hp - 80] = _sbbRv::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sbbT9::P64;
           call MO_WriteBarrier();
           P64[_sbbRN::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbRN::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbRw::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sbbRv::I64;
           I64[Hp - 16] = _sbbRx::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sbbRy::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbctV: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sbbRw::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sbbRv::I64;
           I64[Hp - 64] = _sbbRx::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sbbRy::I64;
           _cbctT::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cbctT::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcsI() //  [R1]
         { info_tbl: [(cbcsI,
                       label: block_cbcsI_info
                       rep:StackRep [False, False, False, True, False, True, True, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcsI: // global
           _sbbRA::P64 = P64[Sp + 72];
           _sbbRJ::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbbRJ::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbRJ::P64);
           I64[Sp + 8] = block_cbcsN_info;
           R1 = _sbbRA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubcue; else goto cbcsR;
       ubcue: // global
           call _cbcsN(R1) args: 0, res: 0, upd: 0;
       cbcsR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcsN() //  [R1]
         { info_tbl: [(cbcsN,
                       label: block_cbcsN_info
                       rep:StackRep [False, False, True, False, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcsN: // global
           if (R1 & 7 == 1) goto cbcsX; else goto cbct5;
       cbcsX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbct0; else goto cbcsZ;
       cbct0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcsZ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 40];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 48];
           R1 = Hp - 47;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbct5: // global
           _sbbSC::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cbct3_info;
           R1 = _sbbSC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubcuf; else goto cbct6;
       ubcuf: // global
           call _cbct3(R1) args: 0, res: 0, upd: 0;
       cbct6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbct3() //  [R1]
         { info_tbl: [(cbct3,
                       label: block_cbct3_info
                       rep:StackRep [False, True, False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbct3: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbctc; else goto cbctb;
       cbctc: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbctb: // global
           _sbbRv::I64 = I64[Sp + 64];
           _sbbRw::P64 = P64[Sp + 24];
           _sbbRx::I64 = I64[Sp + 32];
           _sbbRy::I64 = I64[Sp + 40];
           if (_sbbRx::I64 == I64[R1 + 31]) goto cbctq; else goto cbcti;
       cbctq: // global
           _sbbRN::P64 = P64[Sp + 8];
           _sbbSO::P64 = P64[_sbbRN::P64 + 8];
           I64[Hp - 96] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 88] = _sbbRw::P64;
           I64[Hp - 80] = _sbbRv::I64;
           I64[Hp - 72] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 64] = Hp - 95;
           P64[Hp - 56] = _sbbSO::P64;
           call MO_WriteBarrier();
           P64[_sbbRN::P64 + 8] = Hp - 70;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbRN::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbRw::P64;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = _sbbRv::I64;
           I64[Hp - 16] = _sbbRx::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _sbbRy::I64;
           R1 = Hp - 47;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcti: // global
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sbbRw::P64;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 72] = _sbbRv::I64;
           I64[Hp - 64] = _sbbRx::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = _sbbRy::I64;
           _cbctg::P64 = Hp - 95;
           Hp = Hp - 48;
           R1 = _cbctg::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.564495089 UTC

[section ""data" . GHC.IO.Handle.Text.commitBuffer'1_closure" {
     GHC.IO.Handle.Text.commitBuffer'1_closure:
         const GHC.IO.Handle.Text.commitBuffer'1_info;
 },
 GHC.IO.Handle.Text.commitBuffer'1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbcwJ,
                       label: GHC.IO.Handle.Text.commitBuffer'1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcwJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbcwS; else goto cbcwT;
       cbcwS: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.commitBuffer'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbcwT: // global
           I64[Sp - 40] = block_cbcwG_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubcx2; else goto cbcwH;
       ubcx2: // global
           call _cbcwG(R1) args: 0, res: 0, upd: 0;
       cbcwH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcwG() //  [R1]
         { info_tbl: [(cbcwG,
                       label: block_cbcwG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcwG: // global
           I64[Sp - 8] = block_cbcwM_info;
           _sbbTn::P64 = P64[R1 + 7];
           _sbbTm::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbbTn::P64;
           I64[Sp + 8] = _sbbTm::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubcx1; else goto cbcwN;
       ubcx1: // global
           call _cbcwM(R1) args: 0, res: 0, upd: 0;
       cbcwN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcwM() //  [R1]
         { info_tbl: [(cbcwM,
                       label: block_cbcwM_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcwM: // global
           I64[Sp] = block_cbcwR_info;
           _sbbTp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sbbTp::I64;
           if (R1 & 7 != 0) goto ubcx3; else goto cbcwW;
       ubcx3: // global
           call _cbcwR(R1) args: 0, res: 0, upd: 0;
       cbcwW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcwR() //  [R1]
         { info_tbl: [(cbcwR,
                       label: block_cbcwR_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcwR: // global
           R6 = P64[Sp + 32];
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wcommitBuffer'_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.574582543 UTC

[section ""data" . GHC.IO.Handle.Text.commitBuffer'_closure" {
     GHC.IO.Handle.Text.commitBuffer'_closure:
         const GHC.IO.Handle.Text.commitBuffer'_info;
 },
 GHC.IO.Handle.Text.commitBuffer'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbcxs,
                       label: GHC.IO.Handle.Text.commitBuffer'_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcxs: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.commitBuffer'1_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.577899952 UTC

[section ""cstring" . lvl1_rb6WD_bytes" {
     lvl1_rb6WD_bytes:
         I8[] [99,111,109,109,105,116,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.579704633 UTC

[section ""data" . lvl2_rb6WE_closure" {
     lvl2_rb6WE_closure:
         const lvl2_rb6WE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rb6WE_entry() //  [R1]
         { info_tbl: [(cbcxG,
                       label: lvl2_rb6WE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcxG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcxH; else goto cbcxI;
       cbcxH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcxI: // global
           (_cbcxD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbcxD::I64 == 0) goto cbcxF; else goto cbcxE;
       cbcxF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbcxE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbcxD::I64;
           R2 = lvl1_rb6WD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.583942606 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutChar3_bytes" {
     GHC.IO.Handle.Text.hPutChar3_bytes:
         I8[] [104,80,117,116,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.585770074 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar2_closure" {
     GHC.IO.Handle.Text.hPutChar2_closure:
         const GHC.IO.Handle.Text.hPutChar2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar2_entry() //  [R1]
         { info_tbl: [(cbcxY,
                       label: GHC.IO.Handle.Text.hPutChar2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcxY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcxZ; else goto cbcy0;
       cbcxZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcy0: // global
           (_cbcxV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbcxV::I64 == 0) goto cbcxX; else goto cbcxW;
       cbcxX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbcxW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbcxV::I64;
           R2 = GHC.IO.Handle.Text.hPutChar3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.592094961 UTC

[section ""data" . GHC.IO.Handle.Text.$whPutChar_closure" {
     GHC.IO.Handle.Text.$whPutChar_closure:
         const GHC.IO.Handle.Text.$whPutChar_info;
         const 0;
 },
 act_sbbTv_entry() //  [R1, R2]
         { info_tbl: [(cbcyl,
                       label: act_sbbTv_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcyl: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbcym; else goto cbcyn;
       cbcym: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcyn: // global
           I64[Sp - 16] = block_cbcyi_info;
           _sbbTt::I64 = I64[R1 + 6];
           R1 = R2;
           I64[Sp - 8] = _sbbTt::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubcA1; else goto cbcyj;
       ubcA1: // global
           call _cbcyi(R1) args: 0, res: 0, upd: 0;
       cbcyj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcyi() //  [R1]
         { info_tbl: [(cbcyi,
                       label: block_cbcyi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcyi: // global
           _sbbTR::P64 = P64[P64[R1 + 71] + 8];
           _sbbTS::I64 = I64[Sp + 8];
           if (_sbbTS::I64 == 10) goto cbczk; else goto cbcyE;
       cbczk: // global
           I64[Sp - 40] = block_cbcyL_info;
           _sbbTy::P64 = R1;
           _sbbTA::P64 = P64[R1 + 15];
           _sbbTC::P64 = P64[R1 + 31];
           _sbbTE::P64 = P64[R1 + 47];
           _sbbTF::P64 = P64[R1 + 55];
           R1 = P64[R1 + 119];
           P64[Sp - 32] = _sbbTC::P64;
           P64[Sp - 24] = _sbbTE::P64;
           P64[Sp - 16] = _sbbTF::P64;
           P64[Sp - 8] = _sbbTR::P64;
           P64[Sp] = _sbbTA::P64;
           P64[Sp + 8] = _sbbTy::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubcA0; else goto cbczl;
       ubcA0: // global
           call _cbcyL(R1) args: 0, res: 0, upd: 0;
       cbczl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbcyE: // global
           I64[Sp - 8] = block_cbcyt_info;
           _sbbTy::P64 = R1;
           R1 = _sbbTR::P64;
           I64[Sp] = _sbbTS::I64;
           P64[Sp + 8] = _sbbTy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubczZ; else goto cbcyu;
       ubczZ: // global
           call _cbcyt(R1) args: 0, res: 0, upd: 0;
       cbcyu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcyL() //  [R1]
         { info_tbl: [(cbcyL,
                       label: block_cbcyL_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcyL: // global
           _sbbTR::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cbczs; else goto cbczC;
       cbczs: // global
           I64[Sp] = block_cbczp_info;
           R1 = _sbbTR::P64;
           if (R1 & 7 != 0) goto ubcA2; else goto cbczt;
       ubcA2: // global
           call _cbczp(R1) args: 0, res: 0, upd: 0;
       cbczt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbczC: // global
           I64[Sp] = block_cbczA_info;
           R1 = _sbbTR::P64;
           if (R1 & 7 != 0) goto ubcA3; else goto cbczD;
       ubcA3: // global
           call _cbczA(R1) args: 0, res: 0, upd: 0;
       cbczD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbczp() //  [R1]
         { info_tbl: [(cbczp,
                       label: block_cbczp_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbczp: // global
           _sbbUA::P64 = P64[R1 + 7];
           _sbbUB::P64 = P64[R1 + 15];
           _sbbUz::I64 = I64[R1 + 23];
           _sbbUC::I64 = I64[R1 + 31];
           _sbbUD::I64 = I64[R1 + 39];
           _sbbUE::I64 = I64[R1 + 47];
           I32[_sbbUz::I64 + (_sbbUE::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sbbUA::P64);
           I64[Sp + 32] = _sbbUz::I64;
           P64[Sp] = _sbbUA::P64;
           P64[Sp - 32] = _sbbUB::P64;
           I64[Sp - 24] = _sbbUC::I64;
           I64[Sp - 16] = _sbbUD::I64;
           I64[Sp - 8] = _sbbUE::I64 + 1;
           Sp = Sp - 32;
           call _sbbU6() args: 0, res: 0, upd: 0;
     }
 },
 _cbczA() //  [R1]
         { info_tbl: [(cbczA,
                       label: block_cbczA_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbczA: // global
           _sbbUK::P64 = P64[R1 + 7];
           _sbbUL::P64 = P64[R1 + 15];
           _sbbUJ::I64 = I64[R1 + 23];
           _sbbUM::I64 = I64[R1 + 31];
           _sbbUN::I64 = I64[R1 + 39];
           _sbbUO::I64 = I64[R1 + 47];
           I32[_sbbUJ::I64 + (_sbbUO::I64 << 2)] = 13 :: W32;
           call MO_Touch(_sbbUK::P64);
           _sbbUR::I64 = _sbbUO::I64 + 1;
           I32[_sbbUJ::I64 + (_sbbUR::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sbbUK::P64);
           P64[Sp - 32] = _sbbUL::P64;
           I64[Sp - 24] = _sbbUM::I64;
           I64[Sp - 16] = _sbbUN::I64;
           I64[Sp - 8] = _sbbUR::I64 + 1;
           P64[Sp] = _sbbUK::P64;
           I64[Sp + 32] = _sbbUJ::I64;
           Sp = Sp - 32;
           call _sbbU6() args: 0, res: 0, upd: 0;
     }
 },
 _sbbU6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbbU6: // global
           _sbbU9::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cbcyP_info;
           R6 = I64[Sp + 8];
           R5 = P64[Sp];
           R4 = _sbbU9::P64;
           R3 = I64[Sp + 64];
           R2 = P64[Sp + 80];
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbcyP() //  []
         { info_tbl: [(cbcyP,
                       label: block_cbcyP_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcyP: // global
           I64[Sp] = block_cbcyR_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto ubcA4; else goto cbcyU;
       ubcA4: // global
           call _cbcyR(R1) args: 0, res: 0, upd: 0;
       cbcyU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcyR() //  [R1]
         { info_tbl: [(cbcyR,
                       label: block_cbcyR_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcyR: // global
           if (R1 & 7 == 2) goto cbcz5; else goto ubczX;
       cbcz5: // global
           _sbbUk::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbcz3_info;
           R1 = _sbbUk::P64;
           if (R1 & 7 != 0) goto ubcA5; else goto cbcz6;
       ubcA5: // global
           call _cbcz3(R1) args: 0, res: 0, upd: 0;
       cbcz6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubczX: // global
           Sp = Sp + 56;
           call _cbczj() args: 0, res: 0, upd: 0;
     }
 },
 _cbcz3() //  [R1]
         { info_tbl: [(cbcz3,
                       label: block_cbcz3_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcz3: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubczY; else goto cbczg;
       ubczY: // global
           Sp = Sp + 56;
           call _cbczj() args: 0, res: 0, upd: 0;
       cbczg: // global
           _sbbTC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbcze_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sbbTC::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbcze() //  [R1]
         { info_tbl: [(cbcze,
                       label: block_cbcze_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcze: // global
           _sbbTE::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbbTE::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbTE::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbczj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbczj: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcyt() //  [R1]
         { info_tbl: [(cbcyt,
                       label: block_cbcyt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcyt: // global
           _sbbTy::P64 = P64[Sp + 16];
           _sbbTV::P64 = P64[R1 + 7];
           _sbbTW::P64 = P64[R1 + 15];
           _sbbTU::I64 = I64[R1 + 23];
           _sbbTX::I64 = I64[R1 + 31];
           _sbbTY::I64 = I64[R1 + 39];
           _sbbTZ::I64 = I64[R1 + 47];
           I32[_sbbTU::I64 + (_sbbTZ::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp + 8]);
           call MO_Touch(_sbbTV::P64);
           I64[Sp + 16] = block_cbcyC_info;
           R6 = _sbbTX::I64;
           R5 = _sbbTW::P64;
           R4 = _sbbTV::P64;
           R3 = _sbbTU::I64;
           R2 = _sbbTy::P64;
           I64[Sp] = _sbbTY::I64;
           I64[Sp + 8] = _sbbTZ::I64 + 1;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbcyC() //  []
         { info_tbl: [(cbcyC,
                       label: block_cbcyC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcyC: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$whPutChar_entry() //  [R2, R3]
         { info_tbl: [(cbcAh,
                       label: GHC.IO.Handle.Text.$whPutChar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcAh: // global
           _sbbTt::I64 = R3;
           _sbbTs::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcAi; else goto cbcAj;
       cbcAj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbcAl; else goto cbcAk;
       cbcAl: // global
           HpAlloc = 16;
           goto cbcAi;
       cbcAi: // global
           R3 = _sbbTt::I64;
           R2 = _sbbTs::P64;
           R1 = GHC.IO.Handle.Text.$whPutChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbcAk: // global
           I64[Hp - 8] = act_sbbTv_info;
           I64[Hp] = _sbbTt::I64;
           I64[Sp - 16] = block_cbcAa_info;
           R1 = _sbbTs::P64;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubcAs; else goto cbcAb;
       ubcAs: // global
           call _cbcAa(R1) args: 0, res: 0, upd: 0;
       cbcAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcAa() //  [R1]
         { info_tbl: [(cbcAa,
                       label: block_cbcAa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcAa: // global
           _cbcyd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbcAe; else goto cbcAf;
       cbcAe: // global
           R5 = _cbcyd::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutChar2_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cbcAf: // global
           R5 = _cbcyd::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutChar2_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.622681669 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar1_closure" {
     GHC.IO.Handle.Text.hPutChar1_closure:
         const GHC.IO.Handle.Text.hPutChar1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar1_entry() //  [R2, R3]
         { info_tbl: [(cbcC0,
                       label: GHC.IO.Handle.Text.hPutChar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcC0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcC1; else goto cbcC2;
       cbcC1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutChar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbcC2: // global
           I64[Sp - 16] = block_cbcBX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubcC6; else goto cbcBY;
       ubcC6: // global
           call _cbcBX(R1) args: 0, res: 0, upd: 0;
       cbcBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcBX() //  [R1]
         { info_tbl: [(cbcBX,
                       label: block_cbcBX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcBX: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.628522379 UTC

[section ""data" . GHC.IO.Handle.Text.hPutChar_closure" {
     GHC.IO.Handle.Text.hPutChar_closure:
         const GHC.IO.Handle.Text.hPutChar_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutChar_entry() //  [R2, R3]
         { info_tbl: [(cbcCl,
                       label: GHC.IO.Handle.Text.hPutChar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcCl: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutChar1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.63235828 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr7_closure" {
     GHC.IO.Handle.Text.hPutStr7_closure:
         const GHC.IO.Handle.Text.hPutStr7_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr7_entry() //  [R2, R3]
         { info_tbl: [(cbcCD,
                       label: GHC.IO.Handle.Text.hPutStr7_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcCD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbcCE; else goto ubcCV;
       cbcCE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubcCV: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbcCt() args: 0, res: 0, upd: 0;
     }
 },
 _cbcCt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcCt: // global
           I64[Sp - 8] = block_cbcCw_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubcCX; else goto cbcCx;
       ubcCX: // global
           call _cbcCw(R1) args: 0, res: 0, upd: 0;
       cbcCx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcCw() //  [R1]
         { info_tbl: [(cbcCw,
                       label: block_cbcCw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcCw: // global
           if (R1 & 7 == 1) goto cbcCA; else goto cbcCB;
       cbcCA: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcCB: // global
           I64[Sp] = block_cbcCL_info;
           _sbbVb::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sbbVb::P64;
           if (R1 & 7 != 0) goto ubcCY; else goto cbcCN;
       ubcCY: // global
           call _cbcCL(R1) args: 0, res: 0, upd: 0;
       cbcCN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcCL() //  [R1]
         { info_tbl: [(cbcCL,
                       label: block_cbcCL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcCL: // global
           I64[Sp] = block_cbcCR_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbcCR() //  []
         { info_tbl: [(cbcCR,
                       label: block_cbcCR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcCR: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cbcCt() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.643132779 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar3_closure" {
     GHC.IO.Handle.Text.hGetChar3_closure:
         const GHC.IO.Handle.Text.hGetChar3_info;
         const 0;
 },
 sat_sbbVw_entry() //  [R1]
         { info_tbl: [(cbcDX,
                       label: sat_sbbVw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcDX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcDY; else goto cbcDZ;
       cbcDY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcDZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetChar3_entry() //  [R2]
         { info_tbl: [(cbcE0,
                       label: GHC.IO.Handle.Text.hGetChar3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcE0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbcE1; else goto cbcE2;
       cbcE1: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetChar3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcE2: // global
           I64[Sp - 8] = block_cbcDw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubcEo; else goto cbcDx;
       ubcEo: // global
           call _cbcDw(R1) args: 0, res: 0, upd: 0;
       cbcDx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcDw() //  [R1]
         { info_tbl: [(cbcDw,
                       label: block_cbcDw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcDw: // global
           I64[Sp - 16] = block_cbcDB_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbcDB() //  [R1]
         { info_tbl: [(cbcDB,
                       label: block_cbcDB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcDB: // global
           I64[Sp] = block_cbcDF_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbcDF() //  [R1]
         { info_tbl: [(cbcDF,
                       label: block_cbcDF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcDF: // global
           if (R1 & 7 == 1) goto cbcE8; else goto cbcEa;
       cbcE8: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbcEa: // global
           I64[Sp + 16] = block_cbcDK_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcDK() //  [R1]
         { info_tbl: [(cbcDK,
                       label: block_cbcDK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcDK: // global
           I64[Sp - 8] = block_cbcDO_info;
           _sbbVo::P64 = R1;
           R1 = P64[R1 + 15];
           P64[Sp] = _sbbVo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubcEn; else goto cbcDP;
       ubcEn: // global
           call _cbcDO(R1) args: 0, res: 0, upd: 0;
       cbcDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcDO() //  [R1]
         { info_tbl: [(cbcDO,
                       label: block_cbcDO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcDO: // global
           if (I32[I64[R1 - 1] + 20] == 4 :: W32) goto cbcEk; else goto cbcEd;
       cbcEk: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcEd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbcEg; else goto cbcEf;
       cbcEg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcEf: // global
           I64[Hp - 16] = sat_sbbVw_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.658398218 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetChar7_bytes" {
     GHC.IO.Handle.Text.hGetChar7_bytes:
         I8[] [104,71,101,116,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.660379688 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar6_closure" {
     GHC.IO.Handle.Text.hGetChar6_closure:
         const GHC.IO.Handle.Text.hGetChar6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar6_entry() //  [R1]
         { info_tbl: [(cbcFa,
                       label: GHC.IO.Handle.Text.hGetChar6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcFa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcFb; else goto cbcFc;
       cbcFb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcFc: // global
           (_cbcF7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbcF7::I64 == 0) goto cbcF9; else goto cbcF8;
       cbcF9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbcF8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbcF7::I64;
           R2 = GHC.IO.Handle.Text.hGetChar7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.664292501 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar5_closure" {
     GHC.IO.Handle.Text.hGetChar5_closure:
         const GHC.Types.C#_con_info;
         const 13;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.665966353 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar4_closure" {
     GHC.IO.Handle.Text.hGetChar4_closure:
         const GHC.Types.C#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.672098048 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar2_closure" {
     GHC.IO.Handle.Text.hGetChar2_closure:
         const GHC.IO.Handle.Text.hGetChar2_info;
         const 0;
 },
 sat_sbbWf_entry() //  [R1]
         { info_tbl: [(cbcGb,
                       label: sat_sbbWf_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcGb: // global
           _sbbWf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcGc; else goto cbcGd;
       cbcGd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbcGf; else goto cbcGe;
       cbcGf: // global
           HpAlloc = 56;
           goto cbcGc;
       cbcGc: // global
           R1 = _sbbWf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcGe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbbWf::P64;
           _sbbW3::P64 = P64[_sbbWf::P64 + 16];
           _sbbW4::P64 = P64[_sbbWf::P64 + 24];
           _sbbW2::I64 = I64[_sbbWf::P64 + 32];
           _sbbW5::I64 = I64[_sbbWf::P64 + 40];
           _sbbW7::I64 = I64[_sbbWf::P64 + 48];
           _sbbWc::I64 = I64[_sbbWf::P64 + 56];
           if (_sbbWc::I64 == _sbbW7::I64) goto cbcGa; else goto cbcG9;
       cbcGa: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbW3::P64;
           P64[Hp - 32] = _sbbW4::P64;
           I64[Hp - 24] = _sbbW2::I64;
           I64[Hp - 16] = _sbbW5::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbcG9: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbW3::P64;
           P64[Hp - 32] = _sbbW4::P64;
           I64[Hp - 24] = _sbbW2::I64;
           I64[Hp - 16] = _sbbW5::I64;
           I64[Hp - 8] = _sbbWc::I64;
           I64[Hp] = _sbbW7::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbbWk_entry() //  [R1]
         { info_tbl: [(cbcGt,
                       label: sat_sbbWk_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcGt: // global
           _sbbWk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcGu; else goto cbcGv;
       cbcGv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbcGx; else goto cbcGw;
       cbcGx: // global
           HpAlloc = 56;
           goto cbcGu;
       cbcGu: // global
           R1 = _sbbWk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcGw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbbWk::P64;
           _sbbW3::P64 = P64[_sbbWk::P64 + 16];
           _sbbW4::P64 = P64[_sbbWk::P64 + 24];
           _sbbW2::I64 = I64[_sbbWk::P64 + 32];
           _sbbW5::I64 = I64[_sbbWk::P64 + 40];
           _sbbW7::I64 = I64[_sbbWk::P64 + 48];
           _sbbWc::I64 = I64[_sbbWk::P64 + 56];
           if (_sbbWc::I64 == _sbbW7::I64) goto cbcGs; else goto cbcGr;
       cbcGs: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbW3::P64;
           P64[Hp - 32] = _sbbW4::P64;
           I64[Hp - 24] = _sbbW2::I64;
           I64[Hp - 16] = _sbbW5::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbcGr: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbW3::P64;
           P64[Hp - 32] = _sbbW4::P64;
           I64[Hp - 24] = _sbbW2::I64;
           I64[Hp - 16] = _sbbW5::I64;
           I64[Hp - 8] = _sbbWc::I64;
           I64[Hp] = _sbbW7::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbbWE_entry() //  [R1]
         { info_tbl: [(cbcGS,
                       label: sat_sbbWE_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcGS: // global
           _sbbWE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcGT; else goto cbcGU;
       cbcGU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbcGW; else goto cbcGV;
       cbcGW: // global
           HpAlloc = 56;
           goto cbcGT;
       cbcGT: // global
           R1 = _sbbWE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcGV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbbWE::P64;
           _sbbWp::P64 = P64[_sbbWE::P64 + 16];
           _sbbWq::P64 = P64[_sbbWE::P64 + 24];
           _sbbWo::I64 = I64[_sbbWE::P64 + 32];
           _sbbWr::I64 = I64[_sbbWE::P64 + 40];
           _sbbWt::I64 = I64[_sbbWE::P64 + 56];
           _sbbWC::I64 = I64[_sbbWE::P64 + 48] + 1;
           if (_sbbWC::I64 == _sbbWt::I64) goto cbcH6; else goto cbcH3;
       cbcH6: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbWp::P64;
           P64[Hp - 32] = _sbbWq::P64;
           I64[Hp - 24] = _sbbWo::I64;
           I64[Hp - 16] = _sbbWr::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbcH3: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbWp::P64;
           P64[Hp - 32] = _sbbWq::P64;
           I64[Hp - 24] = _sbbWo::I64;
           I64[Hp - 16] = _sbbWr::I64;
           I64[Hp - 8] = _sbbWC::I64;
           I64[Hp] = _sbbWt::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbbX0_entry() //  [R1]
         { info_tbl: [(cbcHj,
                       label: sat_sbbX0_info
                       rep:HeapRep 4 ptrs 4 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcHj: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbcHk; else goto cbcHl;
       cbcHk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbcHl: // global
           _sbbVz::P64 = P64[R1 + 7];
           _sbbWu::P64 = P64[R1 + 31];
           _sbbWs::I64 = I64[R1 + 55];
           _sbbWH::I64 = I64[R1 + 63] - _sbbWs::I64;
           if (_sbbWH::I64 != 0) goto ubcI2; else goto cbcHh;
       ubcI2: // global
           if (_sbbWH::I64 != 1) goto ubcI4; else goto ubcI3;
       ubcI4: // global
           P64[Sp - 16] = _sbbWu::P64;
           I64[Sp - 8] = _sbbWH::I64;
           Sp = Sp - 16;
           call _cbcHo() args: 0, res: 0, upd: 0;
       ubcI3: // global
           P64[Sp - 64] = _sbbVz::P64;
           I64[Sp - 56] = I64[R1 + 39];
           P64[Sp - 48] = P64[R1 + 15];
           P64[Sp - 40] = P64[R1 + 23];
           I64[Sp - 32] = I64[R1 + 47];
           I64[Sp - 24] = _sbbWs::I64;
           P64[Sp - 16] = _sbbWu::P64;
           I64[Sp - 8] = _sbbWH::I64;
           Sp = Sp - 64;
           call _cbcHH() args: 0, res: 0, upd: 0;
       cbcHh: // global
           I64[Sp - 8] = block_cbcHy_info;
           R3 = _sbbWu::P64;
           R2 = _sbbVz::P64;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbcHo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcHo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbcHt; else goto cbcHs;
       cbcHt: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cbcHn_info;
           R1 = I64[Sp + 8];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbcHs: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcHn() //  [R1]
         { info_tbl: [(cbcHn,
                       label: block_cbcHn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcHn: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cbcHo() args: 0, res: 0, upd: 0;
     }
 },
 _cbcHH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcHH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbcHL; else goto cbcHK;
       cbcHL: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cbcHG_info;
           R1 = I64[Sp + 56];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbcHK: // global
           _sbbVz::P64 = P64[Sp];
           _sbbWo::I64 = I64[Sp + 8];
           _sbbWp::P64 = P64[Sp + 16];
           _sbbWq::P64 = P64[Sp + 24];
           _sbbWr::I64 = I64[Sp + 32];
           _sbbWu::P64 = P64[Sp + 48];
           _sbbWP::I64 = %MO_UU_Conv_W32_W64(I32[_sbbWo::I64 + (I64[Sp + 40] << 2)]);
           call MO_Touch(_sbbWp::P64);
           if (_sbbWP::I64 == 13) goto cbcHY; else goto cbcHR;
       cbcHY: // global
           I32[_sbbWo::I64] = 13 :: W32;
           call MO_Touch(_sbbWp::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbWp::P64;
           P64[Hp - 32] = _sbbWq::P64;
           I64[Hp - 24] = _sbbWo::I64;
           I64[Hp - 16] = _sbbWr::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 56] = block_cbcHV_info;
           R3 = Hp - 47;
           R2 = _sbbVz::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbcHR: // global
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = _sbbWu::P64;
           _cbcHP::P64 = Hp - 46;
           Hp = Hp - 40;
           R1 = _cbcHP::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcHG() //  [R1]
         { info_tbl: [(cbcHG,
                       label: block_cbcHG_info
                       rep:StackRep [False, True, False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcHG: // global
           I64[Sp + 64] = R1;
           Sp = Sp + 8;
           call _cbcHH() args: 0, res: 0, upd: 0;
     }
 },
 _cbcHV() //  [R1]
         { info_tbl: [(cbcHV,
                       label: block_cbcHV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcHV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbcI1; else goto cbcI0;
       cbcI1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcI0: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcHy() //  [R1]
         { info_tbl: [(cbcHy,
                       label: block_cbcHy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcHy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbcHE; else goto cbcHD;
       cbcHE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcHD: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbbXm_entry() //  [R1]
         { info_tbl: [(cbcIu,
                       label: sat_sbbXm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcIu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbcIv; else goto cbcIw;
       cbcIv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcIw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbcIr_info;
           _sbbWs::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbbWs::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubcIO; else goto cbcIs;
       ubcIO: // global
           call _cbcIr(R1) args: 0, res: 0, upd: 0;
       cbcIs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbcIr() //  [R1]
         { info_tbl: [(cbcIr,
                       label: block_cbcIr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcIr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbcIB; else goto cbcIA;
       cbcIB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbcIA: // global
           _sbbXf::P64 = P64[R1 + 7];
           _sbbXg::P64 = P64[R1 + 15];
           _sbbXe::I64 = I64[R1 + 23];
           _sbbXh::I64 = I64[R1 + 31];
           _sbbXj::I64 = I64[R1 + 47];
           _sbbXk::I64 = I64[Sp + 8] + 1;
           if (_sbbXk::I64 == _sbbXj::I64) goto cbcIN; else goto cbcIK;
       cbcIN: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbXf::P64;
           P64[Hp - 32] = _sbbXg::P64;
           I64[Hp - 24] = _sbbXe::I64;
           I64[Hp - 16] = _sbbXh::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbcIK: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbXf::P64;
           P64[Hp - 32] = _sbbXg::P64;
           I64[Hp - 24] = _sbbXe::I64;
           I64[Hp - 16] = _sbbXh::I64;
           I64[Hp - 8] = _sbbXk::I64;
           I64[Hp] = _sbbXj::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetChar2_entry() //  [R2]
         { info_tbl: [(cbcIP,
                       label: GHC.IO.Handle.Text.hGetChar2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcIP: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cbcIQ; else goto cbcIR;
       cbcIQ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetChar2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcIR: // global
           I64[Sp - 8] = block_cbcFr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubcKj; else goto cbcFs;
       ubcKj: // global
           call _cbcFr(R1) args: 0, res: 0, upd: 0;
       cbcFs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcFr() //  [R1]
         { info_tbl: [(cbcFr,
                       label: block_cbcFr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcFr: // global
           I64[Sp - 24] = block_cbcFw_info;
           _sbbVz::P64 = R1;
           _sbbVI::P64 = P64[R1 + 71];
           _sbbVN::P64 = P64[R1 + 111];
           R1 = P64[_sbbVI::P64 + 8];
           P64[Sp - 16] = _sbbVI::P64;
           P64[Sp - 8] = _sbbVN::P64;
           P64[Sp] = _sbbVz::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubcKe; else goto cbcFx;
       ubcKe: // global
           call _cbcFw(R1) args: 0, res: 0, upd: 0;
       cbcFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcFw() //  [R1]
         { info_tbl: [(cbcFw,
                       label: block_cbcFw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcFw: // global
           _sbbVY::I64 = I64[R1 + 39];
           _sbbVZ::I64 = I64[R1 + 47];
           if (_sbbVY::I64 == _sbbVZ::I64) goto cbcJM; else goto cbcJG;
       cbcJM: // global
           I64[Sp] = block_cbcJJ_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbcJG: // global
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = _sbbVY::I64;
           I64[Sp - 8] = _sbbVZ::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 40;
           call _sbbW0() args: 0, res: 0, upd: 0;
     }
 },
 _cbcJJ() //  [R1]
         { info_tbl: [(cbcJJ,
                       label: block_cbcJJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcJJ: // global
           I64[Sp] = block_cbcJL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubcKk; else goto cbcJO;
       ubcKk: // global
           call _cbcJL(R1) args: 0, res: 0, upd: 0;
       cbcJO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcJL() //  [R1]
         { info_tbl: [(cbcJL,
                       label: block_cbcJL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcJL: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sbbW0() args: 0, res: 0, upd: 0;
     }
 },
 _sbbW0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbbW0: // global
           _sbbVN::P64 = P64[Sp + 56];
           _sbbW6::I64 = I64[Sp + 24];
           _sbbWa::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 40] + (_sbbW6::I64 << 2)]);
           call MO_Touch(P64[Sp]);
           I64[Sp - 8] = block_cbcFK_info;
           R1 = _sbbVN::P64;
           I64[Sp + 24] = _sbbW6::I64 + 1;
           I64[Sp + 56] = _sbbWa::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubcKm; else goto cbcFL;
       ubcKm: // global
           call _cbcFK(R1) args: 0, res: 0, upd: 0;
       cbcFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcFK() //  [R1]
         { info_tbl: [(cbcFK,
                       label: block_cbcFK_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcFK: // global
           _sbbVI::P64 = P64[Sp + 56];
           _sbbW2::I64 = I64[Sp + 48];
           _sbbW3::P64 = P64[Sp + 8];
           _sbbW4::P64 = P64[Sp + 16];
           _sbbW5::I64 = I64[Sp + 24];
           _sbbW7::I64 = I64[Sp + 40];
           _sbbWa::I64 = I64[Sp + 64];
           _sbbWc::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cbcJ0; else goto cbcJ4;
       cbcJ0: // global
           Hp = Hp + 80;
           _sbbWd::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbcJ7; else goto cbcJ2;
       cbcJ2: // global
           I64[Hp - 72] = sat_sbbWf_info;
           P64[Hp - 56] = _sbbW3::P64;
           P64[Hp - 48] = _sbbW4::P64;
           I64[Hp - 40] = _sbbW2::I64;
           I64[Hp - 32] = _sbbW5::I64;
           I64[Hp - 24] = _sbbW7::I64;
           I64[Hp - 16] = _sbbWc::I64;
           call MO_WriteBarrier();
           P64[_sbbVI::P64 + 8] = Hp - 72;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbVI::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sbbWa::I64;
           R1 = Hp - 7;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcJ4: // global
           Hp = Hp + 80;
           _sbbWd::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbcJ7; else goto cbcJ6;
       cbcJ7: // global
           HpAlloc = 80;
           R1 = _sbbWd::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcJ6: // global
           if (_sbbWa::I64 == 13) goto cbcJC; else goto cbcJd;
       cbcJC: // global
           if (_sbbWc::I64 == _sbbW7::I64) goto cbcJB; else goto cbcJA;
       cbcJB: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sbbW3::P64;
           P64[Hp - 56] = _sbbW4::P64;
           I64[Hp - 48] = _sbbW2::I64;
           I64[Hp - 40] = _sbbW5::I64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           _cbcG0::P64 = Hp - 71;
           Hp = Hp - 24;
           I64[Sp + 64] = _sbbW2::I64;
           P64[Sp + 48] = _sbbW3::P64;
           P64[Sp + 40] = _sbbW4::P64;
           I64[Sp + 32] = _sbbW5::I64;
           I64[Sp + 24] = 0;
           I64[Sp + 16] = 0;
           P64[Sp + 8] = _cbcG0::P64;
           goto ubcKh;
       cbcJA: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sbbW3::P64;
           P64[Hp - 56] = _sbbW4::P64;
           I64[Hp - 48] = _sbbW2::I64;
           I64[Hp - 40] = _sbbW5::I64;
           I64[Hp - 32] = _sbbWc::I64;
           I64[Hp - 24] = _sbbW7::I64;
           _cbcFY::P64 = Hp - 71;
           Hp = Hp - 24;
           P64[Sp + 8] = _cbcFY::P64;
           I64[Sp + 16] = _sbbW7::I64;
           I64[Sp + 24] = _sbbWc::I64;
           I64[Sp + 32] = _sbbW5::I64;
           P64[Sp + 40] = _sbbW4::P64;
           P64[Sp + 48] = _sbbW3::P64;
           I64[Sp + 64] = _sbbW2::I64;
           goto ubcKh;
       ubcKh: // global
           call _cbcGC() args: 0, res: 0, upd: 0;
       cbcJd: // global
           I64[Hp - 72] = sat_sbbWk_info;
           P64[Hp - 56] = _sbbW3::P64;
           P64[Hp - 48] = _sbbW4::P64;
           I64[Hp - 40] = _sbbW2::I64;
           I64[Hp - 32] = _sbbW5::I64;
           I64[Hp - 24] = _sbbW7::I64;
           I64[Hp - 16] = _sbbWc::I64;
           call MO_WriteBarrier();
           P64[_sbbVI::P64 + 8] = Hp - 72;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbVI::P64);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sbbWa::I64;
           R1 = Hp - 7;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcGC() //  []
         { info_tbl: [(cbcGC,
                       label: block_cbcGC_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcGC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbcJg; else goto cbcJf;
       cbcJg: // global
           HpAlloc = 72;
           I64[Sp] = block_cbcGC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbcJf: // global
           _sbbWo::I64 = I64[Sp + 64];
           _sbbWp::P64 = P64[Sp + 48];
           _sbbWq::P64 = P64[Sp + 40];
           _sbbWr::I64 = I64[Sp + 32];
           _sbbWs::I64 = I64[Sp + 24];
           _sbbWt::I64 = I64[Sp + 16];
           _sbbWu::P64 = P64[Sp + 8];
           if (_sbbWs::I64 == _sbbWt::I64) goto cbcJm; else goto cbcJl;
       cbcJm: // global
           I64[Hp - 64] = sat_sbbX0_info;
           P64[Hp - 56] = P64[Sp + 72];
           P64[Hp - 48] = _sbbWp::P64;
           P64[Hp - 40] = _sbbWq::P64;
           P64[Hp - 32] = _sbbWu::P64;
           I64[Hp - 24] = _sbbWo::I64;
           I64[Hp - 16] = _sbbWr::I64;
           I64[Hp - 8] = _sbbWs::I64;
           I64[Hp] = _sbbWt::I64;
           I64[Sp] = block_cbcIb_info;
           R2 = GHC.IO.Handle.Text.hGetChar3_closure+2;
           R1 = Hp - 63;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cbcJl: // global
           _sbbVI::P64 = P64[Sp + 56];
           _sbbWy::I64 = %MO_UU_Conv_W32_W64(I32[_sbbWo::I64 + (_sbbWs::I64 << 2)]);
           call MO_Touch(_sbbWp::P64);
           if (_sbbWy::I64 == 10) goto cbcJj; else goto cbcJi;
       cbcJj: // global
           I64[Hp - 64] = sat_sbbWE_info;
           P64[Hp - 48] = _sbbWp::P64;
           P64[Hp - 40] = _sbbWq::P64;
           I64[Hp - 32] = _sbbWo::I64;
           I64[Hp - 24] = _sbbWr::I64;
           I64[Hp - 16] = _sbbWs::I64;
           I64[Hp - 8] = _sbbWt::I64;
           call MO_WriteBarrier();
           P64[_sbbVI::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbVI::P64);
           Hp = Hp - 8;
           R1 = GHC.IO.Handle.Text.hGetChar4_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcJi: // global
           call MO_WriteBarrier();
           P64[_sbbVI::P64 + 8] = _sbbWu::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbVI::P64);
           Hp = Hp - 72;
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcIb() //  [R1]
         { info_tbl: [(cbcIb,
                       label: block_cbcIb_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcIb: // global
           I64[Sp] = block_cbcId_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubcKi; else goto cbcIe;
       ubcKi: // global
           call _cbcId(R1) args: 0, res: 0, upd: 0;
       cbcIe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcId() //  [R1]
         { info_tbl: [(cbcId,
                       label: block_cbcId_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcId: // global
           _sbbVI::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cbcJr; else goto cbcJs;
       cbcJr: // global
           _sbbWu::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbbVI::P64 + 8] = _sbbWu::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbVI::P64);
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcJs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbcJv; else goto cbcJu;
       cbcJv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcJu: // global
           _sbbWs::I64 = I64[Sp + 24];
           _sbbX6::P64 = P64[R1 + 6];
           _sbbX9::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 64] + (_sbbWs::I64 << 2)]);
           call MO_Touch(P64[Sp + 48]);
           if (_sbbX9::I64 == 10) goto cbcJy; else goto cbcJx;
       cbcJy: // global
           I64[Hp - 24] = sat_sbbXm_info;
           P64[Hp - 8] = _sbbX6::P64;
           I64[Hp] = _sbbWs::I64;
           call MO_WriteBarrier();
           P64[_sbbVI::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbVI::P64);
           R1 = GHC.IO.Handle.Text.hGetChar4_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcJx: // global
           call MO_WriteBarrier();
           P64[_sbbVI::P64 + 8] = _sbbX6::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbVI::P64);
           Hp = Hp - 32;
           R1 = GHC.IO.Handle.Text.hGetChar5_closure+1;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.725379596 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar1_closure" {
     GHC.IO.Handle.Text.hGetChar1_closure:
         const GHC.IO.Handle.Text.hGetChar1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar1_entry() //  [R2]
         { info_tbl: [(cbcNd,
                       label: GHC.IO.Handle.Text.hGetChar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcNd: // global
           R4 = GHC.IO.Handle.Text.hGetChar2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetChar6_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.7288572 UTC

[section ""data" . GHC.IO.Handle.Text.hGetChar_closure" {
     GHC.IO.Handle.Text.hGetChar_closure:
         const GHC.IO.Handle.Text.hGetChar_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetChar_entry() //  [R2]
         { info_tbl: [(cbcNo,
                       label: GHC.IO.Handle.Text.hGetChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcNo: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.732303828 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf3_closure" {
     GHC.IO.Handle.Text.hGetBuf3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.735425153 UTC

[section ""data" . $wunpack_nl_rb6WF_closure" {
     $wunpack_nl_rb6WF_closure:
         const $wunpack_nl_rb6WF_info;
 },
 $wunpack_nl_rb6WF_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcNx: // global
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2,
                                        R1) args: 8, res: 0, upd: 8;
     }
 },
 $wunpackRB_sbbXO_entry() //  [R1, R2, R3]
         { info_tbl: [(cbcOm,
                       label: $wunpackRB_sbbXO_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcOm: // global
           _sbbXQ::I64 = R3;
           _sbbXP::P64 = R2;
           _sbbXO::P64 = R1;
           goto cbcNJ;
       cbcNJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbcOq; else goto cbcOp;
       cbcOq: // global
           HpAlloc = 40;
           R3 = _sbbXQ::I64;
           R2 = _sbbXP::P64;
           R1 = _sbbXO::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbcOp: // global
           _sbbXF::I64 = I64[_sbbXO::P64 + 13];
           if (%MO_S_Ge_W64(_sbbXQ::I64,
                            _sbbXF::I64)) goto cbcOk; else goto cbcOl;
       cbcOk: // global
           _sbbXD::I64 = I64[_sbbXO::P64 + 5];
           _sbbXW::I64 = %MO_UU_Conv_W32_W64(I32[_sbbXD::I64 + (_sbbXQ::I64 << 2)]);
           if (_sbbXW::I64 != 10) goto cbcOs; else goto cbcOz;
       cbcOs: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sbbXW::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sbbXP::P64;
           _sbbXQ::I64 = _sbbXQ::I64 - 1;
           _sbbXP::P64 = Hp - 14;
           goto cbcNJ;
       cbcOz: // global
           if (%MO_S_Le_W64(_sbbXQ::I64,
                            _sbbXF::I64)) goto cbcOu; else goto cbcOy;
       cbcOu: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sbbXP::P64;
           _cbcO3::P64 = Hp - 30;
           Hp = Hp - 16;
           _sbbXQ::I64 = _sbbXQ::I64 - 1;
           _sbbXP::P64 = _cbcO3::P64;
           goto cbcNJ;
       cbcOy: // global
           if (I32[_sbbXD::I64 + ((_sbbXQ::I64 + -1) << 2)] == 13 :: W32) goto cbcOx; else goto cbcOw;
       cbcOx: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sbbXP::P64;
           _cbcOi::P64 = Hp - 30;
           Hp = Hp - 16;
           _sbbXQ::I64 = _sbbXQ::I64 - 2;
           _sbbXP::P64 = _cbcOi::P64;
           goto cbcNJ;
       cbcOw: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetChar4_closure+1;
           P64[Hp - 16] = _sbbXP::P64;
           _cbcOd::P64 = Hp - 30;
           Hp = Hp - 16;
           _sbbXQ::I64 = _sbbXQ::I64 - 1;
           _sbbXP::P64 = _cbcOd::P64;
           goto cbcNJ;
       cbcOl: // global
           Hp = Hp - 40;
           R1 = _sbbXP::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wunpack_nl_rb6WF_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbcOD,
                       label: $wunpack_nl_rb6WF_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [True, False, True, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcOD: // global
           _sbbXH::P64 = R6;
           _sbbXG::I64 = R5;
           _sbbXF::I64 = R4;
           _sbbXE::P64 = R3;
           _sbbXD::I64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbcOE; else goto cbcOF;
       cbcOF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbcOH; else goto cbcOG;
       cbcOH: // global
           HpAlloc = 24;
           goto cbcOE;
       cbcOE: // global
           R1 = $wunpack_nl_rb6WF_closure;
           I64[Sp - 40] = _sbbXD::I64;
           P64[Sp - 32] = _sbbXE::P64;
           I64[Sp - 24] = _sbbXF::I64;
           I64[Sp - 16] = _sbbXG::I64;
           P64[Sp - 8] = _sbbXH::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cbcOG: // global
           if (_sbbXF::I64 == _sbbXG::I64) goto cbcOC; else goto cbcOB;
       cbcOC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbbXH::P64;
           P64[Hp] = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcOB: // global
           _sbbXN::I64 = %MO_UU_Conv_W32_W64(I32[_sbbXD::I64 + ((_sbbXG::I64 + -1) << 2)]);
           I64[Hp - 16] = $wunpackRB_sbbXO_info;
           I64[Hp - 8] = _sbbXD::I64;
           I64[Hp] = _sbbXF::I64;
           _cbcNH::P64 = Hp - 13;
           if (_sbbXN::I64 == 13) goto cbcP9; else goto cbcOT;
       cbcP9: // global
           I64[Sp - 24] = block_cbcP1_info;
           R3 = _sbbXG::I64 - 2;
           R2 = _sbbXH::P64;
           R1 = _cbcNH::P64;
           P64[Sp - 16] = _sbbXE::P64;
           I64[Sp - 8] = _sbbXG::I64;
           Sp = Sp - 24;
           call $wunpackRB_sbbXO_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
       cbcOT: // global
           I64[Sp - 24] = block_cbcON_info;
           R3 = _sbbXG::I64 - 1;
           R2 = _sbbXH::P64;
           R1 = _cbcNH::P64;
           P64[Sp - 16] = _sbbXE::P64;
           I64[Sp - 8] = _sbbXG::I64;
           Sp = Sp - 24;
           call $wunpackRB_sbbXO_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcP1() //  [R1]
         { info_tbl: [(cbcP1,
                       label: block_cbcP1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcP1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbcPc; else goto cbcPb;
       cbcPc: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcPb: // global
           _sbbXG::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sbbXG::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcON() //  [R1]
         { info_tbl: [(cbcON,
                       label: block_cbcON_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcON: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbcOW; else goto cbcOV;
       cbcOW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcOV: // global
           _sbbXG::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sbbXG::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.75029442 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetContents4_bytes" {
     GHC.IO.Handle.Text.hGetContents4_bytes:
         I8[] [104,71,101,116,67,111,110,116,101,110,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.752243728 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents3_closure" {
     GHC.IO.Handle.Text.hGetContents3_closure:
         const GHC.IO.Handle.Text.hGetContents3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetContents3_entry() //  [R1]
         { info_tbl: [(cbcQ7,
                       label: GHC.IO.Handle.Text.hGetContents3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcQ7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcQ8; else goto cbcQ9;
       cbcQ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcQ9: // global
           (_cbcQ4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbcQ4::I64 == 0) goto cbcQ6; else goto cbcQ5;
       cbcQ6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbcQ5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbcQ4::I64;
           R2 = GHC.IO.Handle.Text.hGetContents4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.7561213 UTC

[section ""cstring" . lvl3_rb6WG_bytes" {
     lvl3_rb6WG_bytes:
         I8[] [13]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.757936644 UTC

[section ""data" . lvl4_rb6WH_closure" {
     lvl4_rb6WH_closure:
         const lvl4_rb6WH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rb6WH_entry() //  [R1]
         { info_tbl: [(cbcQp,
                       label: lvl4_rb6WH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcQp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcQq; else goto cbcQr;
       cbcQq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcQr: // global
           (_cbcQm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbcQm::I64 == 0) goto cbcQo; else goto cbcQn;
       cbcQo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbcQn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbcQm::I64;
           R2 = lvl3_rb6WG_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.762898766 UTC

[section ""data" . $wlvl_rb6WI_closure" {
     $wlvl_rb6WI_closure:
         const $wlvl_rb6WI_info;
         const 0;
 },
 sat_sbbYH_entry() //  [R1]
         { info_tbl: [(cbcQP,
                       label: sat_sbbYH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcQP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbcQQ; else goto cbcQR;
       cbcQQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcQR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbcQI_info;
           _sbbYt::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbbYt::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubcRi; else goto cbcQJ;
       ubcRi: // global
           call _cbcQI(R1) args: 0, res: 0, upd: 0;
       cbcQJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbcQI() //  [R1]
         { info_tbl: [(cbcQI,
                       label: block_cbcQI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcQI: // global
           if (R1 & 7 == 1) goto cbcQM; else goto cbcQN;
       cbcQM: // global
           _sbbYt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbcQU_info;
           R1 = _sbbYt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubcRh; else goto cbcQW;
       ubcRh: // global
           call _cbcQU(R1) args: 0, res: 0, upd: 0;
       cbcQW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbcQN: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cbcQU() //  [R1]
         { info_tbl: [(cbcQU,
                       label: block_cbcQU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcQU: // global
           if (R1 & 7 == 1) goto cbcR2; else goto cbcR9;
       cbcR2: // global
           Hp = Hp + 16;
           _sbbYA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbcRc; else goto cbcR4;
       cbcR4: // global
           _sbbYB::P64 = P64[_sbbYA::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbbYB::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbcR9: // global
           Hp = Hp + 16;
           _sbbYA::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbcRc; else goto cbcRb;
       cbcRc: // global
           HpAlloc = 16;
           R1 = _sbbYA::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbcRb: // global
           _sbbYD::P64 = P64[_sbbYA::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbbYD::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rb6WI_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbcRl,
                       label: $wlvl_rb6WI_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcRl: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbcRp; else goto cbcRo;
       cbcRp: // global
           HpAlloc = 104;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_rb6WI_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbcRo: // global
           I64[Hp - 96] = sat_sbbYH_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = Hp - 96;
           R3 = Hp - 47;
           R2 = GHC.IO.Exception.$fExceptionIOException_closure;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.77305472 UTC

[section ""cstring" . lvl5_rb6WJ_bytes" {
     lvl5_rb6WJ_bytes:
         I8[] [100,101,108,97,121,101,100,32,114,101,97,100,32,111,110,32,99,108,111,115,101,100,32,104,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.774927999 UTC

[section ""data" . lvl6_rb6WK_closure" {
     lvl6_rb6WK_closure:
         const lvl6_rb6WK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rb6WK_entry() //  [R1]
         { info_tbl: [(cbcS6,
                       label: lvl6_rb6WK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcS6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcS7; else goto cbcS8;
       cbcS7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcS8: // global
           (_cbcS3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbcS3::I64 == 0) goto cbcS5; else goto cbcS4;
       cbcS5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbcS4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbcS3::I64;
           R2 = lvl5_rb6WJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.78007502 UTC

[section ""data" . lvl7_rb6WL_closure" {
     lvl7_rb6WL_closure:
         const lvl7_rb6WL_info;
         const 0;
 },
 sat_sbbYN_entry() //  [R1]
         { info_tbl: [(cbcSr,
                       label: sat_sbbYN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcSr: // global
           _sbbYN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcSs; else goto cbcSt;
       cbcSt: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbcSv; else goto cbcSu;
       cbcSv: // global
           HpAlloc = 72;
           goto cbcSs;
       cbcSs: // global
           R1 = _sbbYN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcSu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbbYN::P64;
           _sbbYJ::P64 = P64[_sbbYN::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbbYJ::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = lvl6_rb6WK_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl7_rb6WL_entry() //  [R2]
         { info_tbl: [(cbcSw,
                       label: lvl7_rb6WL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcSw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbcSA; else goto cbcSz;
       cbcSA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl7_rb6WL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcSz: // global
           I64[Hp - 16] = sat_sbbYN_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.786068231 UTC

[section ""cstring" . lvl8_rb6WM_bytes" {
     lvl8_rb6WM_bytes:
         I8[] [105,108,108,101,103,97,108,32,104,97,110,100,108,101,32,116,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.787943101 UTC

[section ""data" . lvl9_rb6WN_closure" {
     lvl9_rb6WN_closure:
         const lvl9_rb6WN_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rb6WN_entry() //  [R1]
         { info_tbl: [(cbcT3,
                       label: lvl9_rb6WN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcT3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcT4; else goto cbcT5;
       cbcT4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcT5: // global
           (_cbcT0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbcT0::I64 == 0) goto cbcT2; else goto cbcT1;
       cbcT2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbcT1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbcT0::I64;
           R2 = lvl8_rb6WM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.792143202 UTC

[section ""data" . lvl10_rb6WO_closure" {
     lvl10_rb6WO_closure:
         const lvl10_rb6WO_info;
         const 0;
 },
 sat_sbbYS_entry() //  [R1]
         { info_tbl: [(cbcTo,
                       label: sat_sbbYS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcTo: // global
           _sbbYS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcTp; else goto cbcTq;
       cbcTq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbcTs; else goto cbcTr;
       cbcTs: // global
           HpAlloc = 72;
           goto cbcTp;
       cbcTp: // global
           R1 = _sbbYS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcTr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbbYS::P64;
           _sbbYO::P64 = P64[_sbbYS::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbbYO::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = GHC.IO.Handle.Text.hGetContents3_closure;
           P64[Hp - 16] = lvl9_rb6WN_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl10_rb6WO_entry() //  [R2]
         { info_tbl: [(cbcTt,
                       label: lvl10_rb6WO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcTt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbcTx; else goto cbcTw;
       cbcTx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = lvl10_rb6WO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcTw: // global
           I64[Hp - 16] = sat_sbbYS_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.804115317 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents2_closure" {
     GHC.IO.Handle.Text.hGetContents2_closure:
         const GHC.IO.Handle.Text.hGetContents2_info;
         const 0;
 },
 sat_sbc1c_entry() //  [R1]
         { info_tbl: [(cbcUR,
                       label: sat_sbc1c_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcUR: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbcUS; else goto cbcUT;
       cbcUS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcUT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbcUP_info;
           _sbbYT::P64 = P64[R1 + 16];
           _sbbZk::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbbYT::P64;
           P64[Sp - 24] = _sbbZk::P64;
           Sp = Sp - 40;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbcUP() //  [R1]
         { info_tbl: [(cbcUP,
                       label: block_cbcUP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcUP: // global
           I64[Sp - 24] = block_cbcUW_info;
           _sbc10::P64 = P64[R1 + 31];
           _sbc11::P64 = P64[R1 + 39];
           _sbc12::P64 = P64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 16] = _sbc11::P64;
           P64[Sp - 8] = _sbc12::P64;
           P64[Sp] = _sbc10::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubcVl; else goto cbcUY;
       ubcVl: // global
           call _cbcUW(R1) args: 0, res: 0, upd: 0;
       cbcUY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbcUW() //  [R1]
         { info_tbl: [(cbcUW,
                       label: block_cbcUW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcUW: // global
           if (I32[I64[R1 - 1] + 20] == 4 :: W32) goto cbcV9; else goto cbcV4;
       cbcV9: // global
           _sbbZk::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbcV7_info;
           R1 = _sbbZk::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ubcVm; else goto cbcVa;
       ubcVm: // global
           call _cbcV7(R1) args: 0, res: 0, upd: 0;
       cbcVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbcV4: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 24];
           R3 = R1;
           R2 = P64[Sp + 32];
           Sp = Sp + 48;
           call $wlvl_rb6WI_entry(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 _cbcV7() //  [R1]
         { info_tbl: [(cbcV7,
                       label: block_cbcV7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcV7: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbcVj; else goto cbcVi;
       cbcVj: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbcVi: // global
           R1 = lvl4_rb6WH_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc1e_entry() //  [R1, R2]
         { info_tbl: [(cbcVn,
                       label: sat_sbc1e_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcVn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbcVo; else goto cbcVp;
       cbcVo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcVp: // global
           I64[Sp - 32] = block_cbcUq_info;
           _sbbYT::P64 = P64[R1 + 6];
           _sbbZ0::P64 = P64[R1 + 14];
           _sbbZk::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sbbYT::P64;
           P64[Sp - 16] = _sbbZ0::P64;
           P64[Sp - 8] = _sbbZk::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubcVF; else goto cbcUr;
       ubcVF: // global
           call _cbcUq(R1) args: 0, res: 0, upd: 0;
       cbcUr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcUq() //  [R1]
         { info_tbl: [(cbcUq,
                       label: block_cbcUq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcUq: // global
           I64[Sp - 16] = block_cbcUv_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbcUv() //  [R1]
         { info_tbl: [(cbcUv,
                       label: block_cbcUv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcUv: // global
           I64[Sp] = block_cbcUz_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbcUz() //  [R1]
         { info_tbl: [(cbcUz,
                       label: block_cbcUz_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcUz: // global
           if (R1 & 7 == 1) goto cbcVv; else goto cbcVy;
       cbcVv: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbcVy: // global
           I64[Sp] = block_cbcUE_info;
           R2 = P64[Sp + 32];
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbcUE() //  [R1]
         { info_tbl: [(cbcUE,
                       label: block_cbcUE_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcUE: // global
           I64[Sp] = block_cbcUG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubcVE; else goto cbcUH;
       ubcVE: // global
           call _cbcUG(R1) args: 0, res: 0, upd: 0;
       cbcUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcUG() //  [R1]
         { info_tbl: [(cbcUG,
                       label: block_cbcUG_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcUG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbcVC; else goto cbcVB;
       cbcVC: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcVB: // global
           _sbc0U::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_sbc1c_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbc0U::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbc0b_entry() //  [R1]
         { info_tbl: [(cbcWD,
                       label: sat_sbc0b_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcWD: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbcWE; else goto cbcWF;
       cbcWE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbcWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cbcWA_info;
           _sbbZw::P64 = P64[R1 + 16];
           _sbbZx::P64 = P64[R1 + 24];
           _sbbZv::I64 = I64[R1 + 40];
           _sbbZy::I64 = I64[R1 + 48];
           _sbbZA::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _sbbZv::I64;
           P64[Sp - 48] = _sbbZw::P64;
           P64[Sp - 40] = _sbbZx::P64;
           I64[Sp - 32] = _sbbZy::I64;
           I64[Sp - 24] = _sbbZA::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubcWU; else goto cbcWB;
       ubcWU: // global
           call _cbcWA(R1) args: 0, res: 0, upd: 0;
       cbcWB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbcWA() //  [R1]
         { info_tbl: [(cbcWA,
                       label: block_cbcWA_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcWA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbcWK; else goto cbcWJ;
       cbcWK: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbcWJ: // global
           _sbbZv::I64 = I64[Sp + 8];
           _sbbZw::P64 = P64[Sp + 16];
           _sbbZx::P64 = P64[Sp + 24];
           _sbbZy::I64 = I64[Sp + 32];
           _sbbZA::I64 = I64[Sp + 40];
           _sbc09::I64 = I64[R1 + 7];
           if (_sbc09::I64 == _sbbZA::I64) goto cbcWT; else goto cbcWQ;
       cbcWT: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbZw::P64;
           P64[Hp - 32] = _sbbZx::P64;
           I64[Hp - 24] = _sbbZv::I64;
           I64[Hp - 16] = _sbbZy::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbcWQ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbZw::P64;
           P64[Hp - 32] = _sbbZx::P64;
           I64[Hp - 24] = _sbbZv::I64;
           I64[Hp - 16] = _sbbZy::I64;
           I64[Hp - 8] = _sbc09::I64;
           I64[Hp] = _sbbZA::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc0I_entry() //  [R1]
         { info_tbl: [(cbcWV,
                       label: sat_sbc0I_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcWV: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbcWW; else goto cbcWX;
       cbcWW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbcWX: // global
           I64[Sp - 40] = block_cbcVL_info;
           _sbbYT::P64 = P64[R1 + 7];
           _sbbZ0::P64 = P64[R1 + 15];
           _sbbZ9::P64 = P64[R1 + 23];
           _sbbZe::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 32] = _sbbYT::P64;
           P64[Sp - 24] = _sbbZ0::P64;
           P64[Sp - 16] = _sbbZ9::P64;
           P64[Sp - 8] = _sbbZe::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubcZ1; else goto cbcVM;
       ubcZ1: // global
           call _cbcVL(R1) args: 0, res: 0, upd: 0;
       cbcVM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcVL() //  [R1]
         { info_tbl: [(cbcVL,
                       label: block_cbcVL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcVL: // global
           _sbbZr::I64 = I64[R1 + 39];
           _sbbZs::I64 = I64[R1 + 47];
           _sbc0e::I64 = _sbbZs::I64 - _sbbZr::I64;
           if (_sbc0e::I64 == 0) goto cbcXX; else goto ubcYJ;
       cbcXX: // global
           I64[Sp] = block_cbcXU_info;
           R3 = R1;
           R2 = P64[Sp + 16];
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       ubcYJ: // global
           _sbbZo::P64 = P64[R1 + 7];
           _sbbZp::P64 = P64[R1 + 15];
           _sbbZn::I64 = I64[R1 + 23];
           _sbbZq::I64 = I64[R1 + 31];
           if (_sbc0e::I64 != 1) goto ubcYK; else goto cbcYa;
       ubcYK: // global
           P64[Sp - 40] = _sbbZo::P64;
           P64[Sp - 32] = _sbbZp::P64;
           I64[Sp - 24] = _sbbZq::I64;
           I64[Sp - 16] = _sbbZr::I64;
           I64[Sp - 8] = _sbbZs::I64;
           I64[Sp] = _sbbZn::I64;
           Sp = Sp - 40;
           call _cbcYi() args: 0, res: 0, upd: 0;
       cbcYa: // global
           I64[Sp - 48] = block_cbcY9_info;
           R1 = P64[Sp + 32];
           P64[Sp - 40] = _sbbZo::P64;
           P64[Sp - 32] = _sbbZp::P64;
           I64[Sp - 24] = _sbbZq::I64;
           I64[Sp - 16] = _sbbZr::I64;
           I64[Sp - 8] = _sbbZs::I64;
           I64[Sp] = _sbbZn::I64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ubcYU; else goto cbcYc;
       ubcYU: // global
           call _cbcY9(R1) args: 0, res: 0, upd: 0;
       cbcYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcXU() //  [R1]
         { info_tbl: [(cbcXU,
                       label: block_cbcXU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcXU: // global
           I64[Sp] = block_cbcXW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubcZ3; else goto cbcY0;
       ubcZ3: // global
           call _cbcXW(R1) args: 0, res: 0, upd: 0;
       cbcY0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcXW() //  [R1]
         { info_tbl: [(cbcXW,
                       label: block_cbcXW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcXW: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 32] = I64[R1 + 39];
           I64[Sp - 40] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sbbZt() args: 0, res: 0, upd: 0;
     }
 },
 _cbcY9() //  [R1]
         { info_tbl: [(cbcY9,
                       label: block_cbcY9_info
                       rep:StackRep [False, False, True, True, True, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcY9: // global
           if (R1 & 7 == 1) goto ubcYL; else goto cbcYj;
       ubcYL: // global
           Sp = Sp + 8;
           call _cbcYi() args: 0, res: 0, upd: 0;
       cbcYj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbcYo; else goto cbcYn;
       cbcYo: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcYn: // global
           _sbbZ0::P64 = P64[Sp + 64];
           _sbbZn::I64 = I64[Sp + 48];
           _sbbZo::P64 = P64[Sp + 8];
           _sbbZp::P64 = P64[Sp + 16];
           _sbbZq::I64 = I64[Sp + 24];
           _sbbZr::I64 = I64[Sp + 32];
           _sbbZs::I64 = I64[Sp + 40];
           _sbc0s::I64 = %MO_UU_Conv_W32_W64(I32[_sbbZn::I64 + (_sbbZr::I64 << 2)]);
           call MO_Touch(_sbbZo::P64);
           if (_sbc0s::I64 == 13) goto cbcYA; else goto cbcYs;
       cbcYA: // global
           I32[_sbbZn::I64] = 13 :: W32;
           call MO_Touch(_sbbZo::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbbZo::P64;
           P64[Hp - 32] = _sbbZp::P64;
           I64[Hp - 24] = _sbbZn::I64;
           I64[Hp - 16] = _sbbZq::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 48] = block_cbcYx_info;
           R3 = Hp - 47;
           R2 = _sbbZ0::P64;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbcYs: // global
           Hp = Hp - 56;
           I64[Sp + 8] = _sbbZs::I64;
           I64[Sp + 16] = _sbbZr::I64;
           I64[Sp + 24] = _sbbZq::I64;
           P64[Sp + 32] = _sbbZp::P64;
           P64[Sp + 40] = _sbbZo::P64;
           I64[Sp + 48] = _sbbZn::I64;
           Sp = Sp + 8;
           call _sbbZt() args: 0, res: 0, upd: 0;
     }
 },
 _cbcYi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcYi: // global
           I64[Sp + 40] = I64[Sp + 40];
           _sbbZA::I64 = I64[Sp + 32];
           P64[Sp + 32] = P64[Sp];
           _sbbZz::I64 = I64[Sp + 24];
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16];
           I64[Sp + 8] = _sbbZz::I64;
           I64[Sp] = _sbbZA::I64;
           call _sbbZt() args: 0, res: 0, upd: 0;
     }
 },
 _cbcYx() //  [R1]
         { info_tbl: [(cbcYx,
                       label: block_cbcYx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcYx: // global
           I64[Sp] = block_cbcYz_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubcZ8; else goto cbcYC;
       ubcZ8: // global
           call _cbcYz(R1) args: 0, res: 0, upd: 0;
       cbcYC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcYz() //  [R1]
         { info_tbl: [(cbcYz,
                       label: block_cbcYz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcYz: // global
           I64[Sp] = I64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp - 16] = P64[R1 + 15];
           I64[Sp - 24] = I64[R1 + 31];
           I64[Sp - 32] = I64[R1 + 39];
           I64[Sp - 40] = I64[R1 + 47];
           Sp = Sp - 40;
           call _sbbZt() args: 0, res: 0, upd: 0;
     }
 },
 _sbbZt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbbZt: // global
           I64[Sp - 8] = block_cbcVV_info;
           R2 = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.hGetContents2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbcVV() //  [R1]
         { info_tbl: [(cbcVV,
                       label: block_cbcVV_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcVV: // global
           I64[Sp] = block_cbcVX_info;
           _sbbZD::P64 = R1;
           R1 = P64[Sp + 80];
           P64[Sp + 80] = _sbbZD::P64;
           if (R1 & 7 != 0) goto ubcYW; else goto cbcVY;
       ubcYW: // global
           call _cbcVX(R1) args: 0, res: 0, upd: 0;
       cbcVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcVX() //  [R1]
         { info_tbl: [(cbcVX,
                       label: block_cbcVX_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcVX: // global
           _sbbZv::I64 = I64[Sp + 48];
           _sbbZw::P64 = P64[Sp + 40];
           _sbbZz::I64 = I64[Sp + 16];
           _sbbZA::I64 = I64[Sp + 8];
           _sbbZD::P64 = P64[Sp + 80];
           if (R1 & 7 == 1) goto cbcX2; else goto cbcXC;
       cbcX2: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbcX5; else goto cbcX4;
       cbcX5: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcX4: // global
           if (_sbbZz::I64 == _sbbZA::I64) goto cbcXw; else goto cbcXp;
       cbcXw: // global
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sbbZw::P64;
           P64[Hp - 56] = P64[Sp + 32];
           I64[Hp - 48] = _sbbZv::I64;
           I64[Hp - 40] = I64[Sp + 24];
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           _sbbZ0::P64 = P64[Sp + 64];
           _sbbZ9::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sbbZ9::P64 + 8] = Hp - 71;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbZ9::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbbZ0::P64;
           P64[Hp] = _sbbZD::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbcXp: // global
           Hp = Hp - 80;
           I64[Sp + 56] = _sbbZA::I64 - 1;
           P64[Sp + 80] = _sbbZD::P64;
           Sp = Sp + 8;
           call _cbcWc() args: 0, res: 0, upd: 0;
       cbcXC: // global
           I64[Sp] = block_cbcWp_info;
           R6 = _sbbZD::P64;
           R5 = _sbbZA::I64;
           R4 = _sbbZz::I64;
           R3 = _sbbZw::P64;
           R2 = _sbbZv::I64;
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbcWc() //  []
         { info_tbl: [(cbcWc,
                       label: block_cbcWc_info
                       rep:StackRep [True, True, False, False, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcWc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbcXk; else goto cbcXj;
       cbcXk: // global
           HpAlloc = 40;
           I64[Sp] = block_cbcWc_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbcXj: // global
           _sbbZO::P64 = P64[Sp + 72];
           _sbbZP::I64 = I64[Sp + 48];
           if (%MO_S_Ge_W64(_sbbZP::I64,
                            I64[Sp + 8])) goto cbcXm; else goto cbcXn;
       cbcXm: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 40] + (_sbbZP::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sbbZO::P64;
           P64[Sp + 72] = Hp - 14;
           I64[Sp + 48] = _sbbZP::I64 - 1;
           call _cbcWc() args: 0, res: 0, upd: 0;
       cbcXn: // global
           Hp = Hp - 40;
           P64[Sp + 72] = _sbbZO::P64;
           Sp = Sp + 16;
           call _cbcX7() args: 0, res: 0, upd: 0;
     }
 },
 _cbcX7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcX7: // global
           Hp = Hp + 80;
           _sbbZI::P64 = P64[Sp + 56];
           if (Hp > HpLim) (likely: False) goto cbcXh; else goto cbcXg;
       cbcXh: // global
           HpAlloc = 80;
           I64[Sp - 8] = block_cbcX6_info;
           R1 = _sbbZI::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcXg: // global
           _sbbZ0::P64 = P64[Sp + 40];
           _sbbZ9::P64 = P64[Sp + 48];
           _sbbZv::I64 = I64[Sp + 24];
           _sbbZw::P64 = P64[Sp + 16];
           _sbbZx::P64 = P64[Sp + 8];
           _sbbZy::I64 = I64[Sp];
           call MO_Touch(_sbbZw::P64);
           I64[Hp - 72] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 64] = _sbbZw::P64;
           P64[Hp - 56] = _sbbZx::P64;
           I64[Hp - 48] = _sbbZv::I64;
           I64[Hp - 40] = _sbbZy::I64;
           I64[Hp - 32] = 0;
           I64[Hp - 24] = 0;
           call MO_WriteBarrier();
           P64[_sbbZ9::P64 + 8] = Hp - 71;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbZ9::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbbZ0::P64;
           P64[Hp] = _sbbZI::P64;
           R1 = Hp - 15;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbcX6() //  [R1]
         { info_tbl: [(cbcX6,
                       label: block_cbcX6_info
                       rep:StackRep [True, False, False, True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcX6: // global
           P64[Sp + 64] = R1;
           Sp = Sp + 8;
           call _cbcX7() args: 0, res: 0, upd: 0;
     }
 },
 _cbcWp() //  [R1]
         { info_tbl: [(cbcWp,
                       label: block_cbcWp_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcWp: // global
           I64[Sp] = block_cbcWr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubcZ0; else goto cbcWs;
       ubcZ0: // global
           call _cbcWr(R1) args: 0, res: 0, upd: 0;
       cbcWs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcWr() //  [R1]
         { info_tbl: [(cbcWr,
                       label: block_cbcWr_info
                       rep:StackRep [True, True, True, False, False, True, True, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcWr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbcXG; else goto cbcXF;
       cbcXG: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcXF: // global
           _sbc06::P64 = P64[R1 + 7];
           _sbc07::P64 = P64[R1 + 15];
           I64[Hp - 80] = sat_sbc0b_info;
           P64[Hp - 64] = P64[Sp + 40];
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = _sbc07::P64;
           I64[Hp - 40] = I64[Sp + 48];
           I64[Hp - 32] = I64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 8];
           _sbbZ0::P64 = P64[Sp + 64];
           _sbbZ9::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sbbZ9::P64 + 8] = Hp - 80;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbbZ9::P64);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbbZ0::P64;
           P64[Hp] = _sbc06::P64;
           R1 = Hp - 15;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 act_sbbYX_entry() //  [R1, R2]
         { info_tbl: [(cbcZa,
                       label: act_sbbYX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcZa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbcZb; else goto cbcZc;
       cbcZb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcZc: // global
           I64[Sp - 16] = block_cbcU9_info;
           _sbbYT::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbbYT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubcZs; else goto cbcUa;
       ubcZs: // global
           call _cbcU9(R1) args: 0, res: 0, upd: 0;
       cbcUa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcU9() //  [R1]
         { info_tbl: [(cbcU9,
                       label: block_cbcU9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcU9: // global
           I64[Sp - 24] = block_cbcUe_info;
           _sbbZ0::P64 = R1;
           _sbbZ9::P64 = P64[R1 + 71];
           _sbbZe::P64 = P64[R1 + 111];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbbZ9::P64;
           P64[Sp - 8] = _sbbZe::P64;
           P64[Sp] = _sbbZ0::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubcZr; else goto cbcUf;
       ubcZr: // global
           call _cbcUe(R1) args: 0, res: 0, upd: 0;
       cbcUf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcUe() //  [R1]
         { info_tbl: [(cbcUe,
                       label: block_cbcUe_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcUe: // global
           _sbbYT::P64 = P64[Sp + 32];
           _cbcZp::P64 = R1 & 7;
           if (_cbcZp::P64 == 1) goto cbcZk; else goto ubcZq;
       cbcZk: // global
           R2 = _sbbYT::P64;
           Sp = Sp + 40;
           call lvl7_rb6WL_entry(R2) args: 8, res: 0, upd: 8;
       ubcZq: // global
           if (_cbcZp::P64 == 2) goto cbcZl; else goto cbcZh;
       cbcZl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbcZo; else goto cbcZn;
       cbcZo: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbcZn: // global
           _sbbZ9::P64 = P64[Sp + 8];
           _sbbZk::P64 = P64[_sbbZ9::P64 + 8];
           I64[Hp - 72] = sat_sbc1e_info;
           P64[Hp - 64] = _sbbYT::P64;
           _sbbZ0::P64 = P64[Sp + 24];
           P64[Hp - 56] = _sbbZ0::P64;
           P64[Hp - 48] = _sbbZk::P64;
           I64[Hp - 40] = sat_sbc0I_info;
           P64[Hp - 32] = _sbbYT::P64;
           P64[Hp - 24] = _sbbZ0::P64;
           P64[Hp - 16] = _sbbZ9::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbbZk::P64;
           R2 = Hp - 70;
           R1 = Hp - 39;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       cbcZh: // global
           R2 = _sbbYT::P64;
           Sp = Sp + 40;
           call lvl10_rb6WO_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbc1l_entry() //  [R1]
         { info_tbl: [(cbcZA,
                       label: sat_sbc1l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcZA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbcZB; else goto cbcZC;
       cbcZB: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbcZC: // global
           I64[Sp - 16] = block_cbcU2_info;
           P64[Sp - 8] = P64[R1 + 7];
           Sp = Sp - 16;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cbcU2() //  []
         { info_tbl: [(cbcU2,
                       label: block_cbcU2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcU2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbcZF; else goto cbcZE;
       cbcZF: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbcZE: // global
           I64[Hp - 8] = act_sbbYX_info;
           _sbbYT::P64 = P64[Sp + 8];
           P64[Hp] = _sbbYT::P64;
           I64[Sp] = block_cbcZt_info;
           R1 = _sbbYT::P64;
           P64[Sp + 8] = Hp - 6;
           if (R1 & 7 != 0) goto ubcZM; else goto cbcZu;
       ubcZM: // global
           call _cbcZt(R1) args: 0, res: 0, upd: 0;
       cbcZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbcZt() //  [R1]
         { info_tbl: [(cbcZt,
                       label: block_cbcZt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcZt: // global
           _cbcU4::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbcZx; else goto cbcZy;
       cbcZx: // global
           R5 = _cbcU4::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cbcZy: // global
           R5 = _cbcU4::P64;
           R4 = P64[R1 + 14];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.hGetContents2_entry() //  [R2]
         { info_tbl: [(cbcZN,
                       label: GHC.IO.Handle.Text.hGetContents2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcZN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbcZR; else goto cbcZQ;
       cbcZR: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetContents2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcZQ: // global
           I64[Hp - 8] = sat_sbc1l_info;
           P64[Hp] = R2;
           R2 = Hp - 7;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.878448253 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents1_closure" {
     GHC.IO.Handle.Text.hGetContents1_closure:
         const GHC.IO.Handle.Text.hGetContents1_info;
         const 0;
 },
 sat_sbc1K_entry() //  [R1]
         { info_tbl: [(cbd3T,
                       label: sat_sbc1K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd3T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbd3X; else goto cbd3Y;
       cbd3X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbd3Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbd3Q_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubd42; else goto cbd3R;
       ubd42: // global
           call _cbd3Q(R1) args: 0, res: 0, upd: 0;
       cbd3R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbd3Q() //  [R1]
         { info_tbl: [(cbd3Q,
                       label: block_cbd3Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd3Q: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbd41; else goto cbd40;
       cbd41: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbd40: // global
           _sbc1u::P64 = P64[R1 + 7];
           _sbc1v::P64 = P64[R1 + 15];
           _sbc1w::P64 = P64[R1 + 23];
           _sbc1x::P64 = P64[R1 + 31];
           _sbc1z::P64 = P64[R1 + 47];
           _sbc1A::P64 = P64[R1 + 55];
           _sbc1B::P64 = P64[R1 + 63];
           _sbc1C::P64 = P64[R1 + 71];
           _sbc1D::P64 = P64[R1 + 79];
           _sbc1E::P64 = P64[R1 + 87];
           _sbc1F::P64 = P64[R1 + 95];
           _sbc1G::P64 = P64[R1 + 103];
           _sbc1H::P64 = P64[R1 + 111];
           _sbc1I::P64 = P64[R1 + 119];
           _sbc1J::P64 = P64[R1 + 127];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbc1u::P64;
           P64[Hp - 112] = _sbc1v::P64;
           P64[Hp - 104] = _sbc1w::P64;
           P64[Hp - 96] = _sbc1x::P64;
           P64[Hp - 88] = GHC.IO.Handle.Types.SemiClosedHandle_closure+2;
           P64[Hp - 80] = _sbc1z::P64;
           P64[Hp - 72] = _sbc1A::P64;
           P64[Hp - 64] = _sbc1B::P64;
           P64[Hp - 56] = _sbc1C::P64;
           P64[Hp - 48] = _sbc1D::P64;
           P64[Hp - 40] = _sbc1E::P64;
           P64[Hp - 32] = _sbc1F::P64;
           P64[Hp - 24] = _sbc1G::P64;
           P64[Hp - 16] = _sbc1H::P64;
           P64[Hp - 8] = _sbc1I::P64;
           P64[Hp] = _sbc1J::P64;
           R1 = Hp - 127;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc1M_entry() //  [R1, R2]
         { info_tbl: [(cbd44,
                       label: sat_sbc1M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd44: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbd45; else goto cbd46;
       cbd45: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbd46: // global
           I64[Sp - 16] = block_cbd3K_info;
           _sbc1o::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbc1o::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Text.hGetContents2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbd3K() //  [R1]
         { info_tbl: [(cbd3K,
                       label: block_cbd3K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd3K: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbd49; else goto cbd48;
       cbd49: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbd48: // global
           I64[Hp - 40] = sat_sbc1K_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.hGetContents1_entry() //  [R2]
         { info_tbl: [(cbd4a,
                       label: GHC.IO.Handle.Text.hGetContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd4a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbd4e; else goto cbd4d;
       cbd4e: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbd4d: // global
           I64[Hp - 8] = sat_sbc1M_info;
           P64[Hp] = R2;
           R4 = Hp - 6;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetContents3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.890817384 UTC

[section ""data" . GHC.IO.Handle.Text.hGetContents_closure" {
     GHC.IO.Handle.Text.hGetContents_closure:
         const GHC.IO.Handle.Text.hGetContents_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetContents_entry() //  [R2]
         { info_tbl: [(cbd4P,
                       label: GHC.IO.Handle.Text.hGetContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd4P: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.894522187 UTC

[section ""data" . go_rb6WP_closure" {
     go_rb6WP_closure:
         const go_rb6WP_info;
 },
 sat_sbc1R_entry() //  [R1]
         { info_tbl: [(cbd5a,
                       label: sat_sbc1R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd5a: // global
           R2 = P64[R1 + 16];
           call go_rb6WP_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 go_rb6WP_entry() //  [R2]
         { info_tbl: [(cbd5h,
                       label: go_rb6WP_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd5h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbd5i; else goto cbd5j;
       cbd5i: // global
           R2 = R2;
           R1 = go_rb6WP_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbd5j: // global
           I64[Sp - 8] = block_cbd50_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubd5p; else goto cbd51;
       ubd5p: // global
           call _cbd50(R1) args: 0, res: 0, upd: 0;
       cbd51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbd50() //  [R1]
         { info_tbl: [(cbd50,
                       label: block_cbd50_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd50: // global
           if (R1 & 7 == 1) goto cbd5e; else goto cbd5f;
       cbd5e: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbd5f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbd5o; else goto cbd5n;
       cbd5o: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbd5n: // global
           _sbc1P::P64 = P64[R1 + 6];
           _sbc1Q::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sbc1R_info;
           P64[Hp] = _sbc1Q::P64;
           R3 = Hp - 16;
           R2 = _sbc1P::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.902490743 UTC

[section ""data" . go1_rb6WQ_closure" {
     go1_rb6WQ_closure:
         const go1_rb6WQ_info;
 },
 sat_sbc1W_entry() //  [R1]
         { info_tbl: [(cbd5W,
                       label: sat_sbc1W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd5W: // global
           R2 = P64[R1 + 16];
           call go1_rb6WQ_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 go1_rb6WQ_entry() //  [R2]
         { info_tbl: [(cbd63,
                       label: go1_rb6WQ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd63: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbd64; else goto cbd65;
       cbd64: // global
           R2 = R2;
           R1 = go1_rb6WQ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbd65: // global
           I64[Sp - 8] = block_cbd5M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubd6b; else goto cbd5N;
       ubd6b: // global
           call _cbd5M(R1) args: 0, res: 0, upd: 0;
       cbd5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbd5M() //  [R1]
         { info_tbl: [(cbd5M,
                       label: block_cbd5M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd5M: // global
           if (R1 & 7 == 1) goto cbd60; else goto cbd61;
       cbd60: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbd61: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbd6a; else goto cbd69;
       cbd6a: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbd69: // global
           _sbc1U::P64 = P64[R1 + 6];
           _sbc1V::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sbc1W_info;
           P64[Hp] = _sbc1V::P64;
           R3 = Hp - 16;
           R2 = _sbc1U::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.916847866 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure" {
     GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure:
         const GHC.IO.Handle.Text.$whGetLineBufferedLoop_info;
         const 0;
 },
 GHC.IO.Handle.Text.$whGetLineBufferedLoop_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd6v: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2,
                                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 buf1_sbc2w_entry() //  [R1]
         { info_tbl: [(cbd7O,
                       label: buf1_sbc2w_info
                       rep:HeapRep 3 ptrs 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd7O: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbd7P; else goto cbd7Q;
       cbd7P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbd7Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cbd7L_info;
           _sbc1Z::P64 = P64[R1 + 16];
           _sbc20::P64 = P64[R1 + 24];
           _sbc1Y::I64 = I64[R1 + 40];
           _sbc21::I64 = I64[R1 + 48];
           _sbc23::I64 = I64[R1 + 56];
           R1 = P64[R1 + 32];
           I64[Sp - 56] = _sbc1Y::I64;
           P64[Sp - 48] = _sbc1Z::P64;
           P64[Sp - 40] = _sbc20::P64;
           I64[Sp - 32] = _sbc21::I64;
           I64[Sp - 24] = _sbc23::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubd85; else goto cbd7M;
       ubd85: // global
           call _cbd7L(R1) args: 0, res: 0, upd: 0;
       cbd7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbd7L() //  [R1]
         { info_tbl: [(cbd7L,
                       label: block_cbd7L_info
                       rep:StackRep [True, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd7L: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbd7V; else goto cbd7U;
       cbd7V: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbd7U: // global
           _sbc1Y::I64 = I64[Sp + 8];
           _sbc1Z::P64 = P64[Sp + 16];
           _sbc20::P64 = P64[Sp + 24];
           _sbc21::I64 = I64[Sp + 32];
           _sbc23::I64 = I64[Sp + 40];
           _sbc2y::I64 = I64[R1 + 7];
           if (_sbc2y::I64 == _sbc23::I64) goto cbd84; else goto cbd81;
       cbd84: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbc1Z::P64;
           P64[Hp - 32] = _sbc20::P64;
           I64[Hp - 24] = _sbc1Y::I64;
           I64[Hp - 16] = _sbc21::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbd81: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbc1Z::P64;
           P64[Hp - 32] = _sbc20::P64;
           I64[Hp - 24] = _sbc1Y::I64;
           I64[Hp - 16] = _sbc21::I64;
           I64[Hp - 8] = _sbc2y::I64;
           I64[Hp] = _sbc23::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc33_entry() //  [R1]
         { info_tbl: [(cbd8c,
                       label: sat_sbc33_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd8c: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbd8d; else goto cbd8e;
       cbd8d: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbd8e: // global
           I64[Sp - 24] = block_cbd89_info;
           _sbc26::P64 = P64[R1 + 7];
           _sbc2k::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp - 16] = _sbc26::P64;
           P64[Sp - 8] = _sbc2k::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubd9p; else goto cbd8a;
       ubd9p: // global
           call _cbd89(R1) args: 0, res: 0, upd: 0;
       cbd8a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbd89() //  [R1]
         { info_tbl: [(cbd89,
                       label: block_cbd89_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd89: // global
           _sbc2G::I64 = I64[R1 + 39];
           _sbc2I::I64 = I64[R1 + 47] - _sbc2G::I64;
           if (_sbc2I::I64 == 0) goto cbd8B; else goto ubd9k;
       cbd8B: // global
           I64[Sp + 16] = block_cbd8y_info;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       ubd9k: // global
           if (_sbc2I::I64 == 1) goto cbd8L; else goto ubd9l;
       cbd8L: // global
           I64[Sp - 40] = block_cbd8K_info;
           _sbc2B::P64 = R1;
           _sbc2D::P64 = P64[R1 + 7];
           _sbc2E::P64 = P64[R1 + 15];
           _sbc2C::I64 = I64[R1 + 23];
           _sbc2F::I64 = I64[R1 + 31];
           R1 = P64[Sp + 16];
           P64[Sp - 32] = _sbc2D::P64;
           P64[Sp - 24] = _sbc2E::P64;
           I64[Sp - 16] = _sbc2F::I64;
           I64[Sp - 8] = _sbc2G::I64;
           I64[Sp] = _sbc2C::I64;
           P64[Sp + 16] = _sbc2B::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubd9n; else goto cbd8N;
       ubd9n: // global
           call _cbd8K(R1) args: 0, res: 0, upd: 0;
       cbd8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubd9l: // global
           I64[Sp + 8] = _sbc2I::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cbd8m() args: 0, res: 0, upd: 0;
     }
 },
 _cbd8y() //  [R1]
         { info_tbl: [(cbd8y,
                       label: block_cbd8y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd8y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbd8F; else goto cbd8E;
       cbd8F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbd8E: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbd8K() //  [R1]
         { info_tbl: [(cbd8K,
                       label: block_cbd8K_info
                       rep:StackRep [False, False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd8K: // global
           _sbc2B::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cbd8T; else goto cbd8X;
       cbd8T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbd8W; else goto cbd8V;
       cbd8W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbd8V: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbc2B::P64;
           R1 = Hp - 6;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbd8X: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbd92; else goto cbd91;
       cbd92: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbd91: // global
           _sbc26::P64 = P64[Sp + 48];
           _sbc2C::I64 = I64[Sp + 40];
           _sbc2D::P64 = P64[Sp + 8];
           _sbc2E::P64 = P64[Sp + 16];
           _sbc2F::I64 = I64[Sp + 24];
           _sbc2S::I64 = %MO_UU_Conv_W32_W64(I32[_sbc2C::I64 + (I64[Sp + 32] << 2)]);
           call MO_Touch(_sbc2D::P64);
           if (_sbc2S::I64 == 13) goto cbd9f; else goto cbd98;
       cbd9f: // global
           I32[_sbc2C::I64] = 13 :: W32;
           call MO_Touch(_sbc2D::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbc2D::P64;
           P64[Hp - 32] = _sbc2E::P64;
           I64[Hp - 24] = _sbc2C::I64;
           I64[Hp - 16] = _sbc2F::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 1;
           I64[Sp + 56] = block_cbd9c_info;
           R3 = Hp - 47;
           R2 = _sbc26::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbd98: // global
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = _sbc2B::P64;
           _cbd96::P64 = Hp - 46;
           Hp = Hp - 40;
           R1 = _cbd96::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbd9c() //  [R1]
         { info_tbl: [(cbd9c,
                       label: block_cbd9c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd9c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbd9i; else goto cbd9h;
       cbd9i: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbd9h: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbd8m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd8m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbd8t; else goto cbd8s;
       cbd8t: // global
           HpAlloc = 16;
           _sbc2I::I64 = I64[Sp];
           I64[Sp] = block_cbd8l_info;
           R1 = _sbc2I::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbd8s: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbd8l() //  [R1]
         { info_tbl: [(cbd8l,
                       label: block_cbd8l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd8l: // global
           I64[Sp] = R1;
           call _cbd8m() args: 0, res: 0, upd: 0;
     }
 },
 sat_sbc3f_entry() //  [R1]
         { info_tbl: [(cbd9z,
                       label: sat_sbc3f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd9z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbd9D; else goto cbd9E;
       cbd9D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbd9E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbd9w_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubd9I; else goto cbd9x;
       ubd9I: // global
           call _cbd9w(R1) args: 0, res: 0, upd: 0;
       cbd9x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbd9w() //  [R1]
         { info_tbl: [(cbd9w,
                       label: block_cbd9w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd9w: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbd9H; else goto cbd9G;
       cbd9H: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbd9G: // global
           _sbc3a::P64 = P64[R1 + 7];
           _sbc3b::P64 = P64[R1 + 15];
           _sbc39::I64 = I64[R1 + 23];
           _sbc3c::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbc3a::P64;
           P64[Hp - 32] = _sbc3b::P64;
           I64[Hp - 24] = _sbc39::I64;
           I64[Hp - 16] = _sbc3c::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc3p_entry() //  [R1]
         { info_tbl: [(cbd9U,
                       label: sat_sbc3p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd9U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbd9V; else goto cbd9W;
       cbd9V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbd9W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbd9R_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubda5; else goto cbd9S;
       ubda5: // global
           call _cbd9R(R1) args: 0, res: 0, upd: 0;
       cbd9S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbd9R() //  [R1]
         { info_tbl: [(cbd9R,
                       label: block_cbd9R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd9R: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbda4; else goto cbda3;
       cbda4: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbda3: // global
           R1 = lvl4_rb6WH_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc3H_entry() //  [R1]
         { info_tbl: [(cbdae,
                       label: sat_sbc3H_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdae: // global
           _sbc3H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbdaf; else goto cbdag;
       cbdag: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdai; else goto cbdah;
       cbdai: // global
           HpAlloc = 56;
           goto cbdaf;
       cbdaf: // global
           R1 = _sbc3H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdah: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbc3H::P64;
           _sbc1Z::P64 = P64[_sbc3H::P64 + 16];
           _sbc20::P64 = P64[_sbc3H::P64 + 24];
           _sbc1Y::I64 = I64[_sbc3H::P64 + 32];
           _sbc21::I64 = I64[_sbc3H::P64 + 40];
           _sbc23::I64 = I64[_sbc3H::P64 + 48];
           _sbc3F::I64 = I64[_sbc3H::P64 + 56] + 1;
           if (_sbc3F::I64 == _sbc23::I64) goto cbdas; else goto cbdap;
       cbdas: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbc1Z::P64;
           P64[Hp - 32] = _sbc20::P64;
           I64[Hp - 24] = _sbc1Y::I64;
           I64[Hp - 16] = _sbc21::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbdap: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbc1Z::P64;
           P64[Hp - 32] = _sbc20::P64;
           I64[Hp - 24] = _sbc1Y::I64;
           I64[Hp - 16] = _sbc21::I64;
           I64[Hp - 8] = _sbc3F::I64;
           I64[Hp] = _sbc23::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc3L_entry() //  [R1]
         { info_tbl: [(cbdaD,
                       label: sat_sbc3L_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdaD: // global
           _sbc3L::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbdaE; else goto cbdaF;
       cbdaF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbdaH; else goto cbdaG;
       cbdaH: // global
           HpAlloc = 24;
           goto cbdaE;
       cbdaE: // global
           R1 = _sbc3L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdaG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbc3L::P64;
           _sbc24::P64 = P64[_sbc3L::P64 + 16];
           _sbc2t::P64 = P64[_sbc3L::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sbc2t::P64;
           P64[Hp] = _sbc24::P64;
           I64[Sp - 24] = block_cbdaB_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbdaB() //  [R1]
         { info_tbl: [(cbdaB,
                       label: block_cbdaB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdaB: // global
           R2 = R1;
           Sp = Sp + 8;
           call go_rb6WP_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry() //  [R2, R3, R4,
                                                        R5, R6]
         { info_tbl: [(cbdaL,
                       label: GHC.IO.Handle.Text.$whGetLineBufferedLoop_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdaL: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cbdaM; else goto ubdcD;
       cbdaM: // global
           R1 = GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ubdcD: // global
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cbd6w() args: 0, res: 0, upd: 0;
     }
 },
 _cbd6w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd6w: // global
           _sbc1X::P64 = P64[Sp];
           I64[Sp] = block_cbd6z_info;
           R1 = _sbc1X::P64;
           if (R1 & 7 != 0) goto ubdcQ; else goto cbd6A;
       ubdcQ: // global
           call _cbd6z(R1) args: 0, res: 0, upd: 0;
       cbd6A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbd6z() //  [R1]
         { info_tbl: [(cbd6z,
                       label: block_cbd6z_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd6z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbdaQ; else goto cbdaP;
       cbdaQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdaP: // global
           _sbc2f::P64 = P64[R1 + 71];
           _sbc2k::P64 = P64[R1 + 111];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = I64[Sp + 8];
           P64[Sp - 32] = _sbc2f::P64;
           P64[Sp - 24] = _sbc2k::P64;
           P64[Sp - 16] = Hp - 15;
           I64[Sp - 8] = I64[Sp + 40];
           P64[Sp] = R1;
           Sp = Sp - 32;
           call _cbdcc() args: 0, res: 0, upd: 0;
     }
 },
 _cbdcc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdcc: // global
           _sbc23::I64 = I64[Sp + 80];
           if (I64[Sp + 24] == _sbc23::I64) goto cbdcw; else goto cbdcl;
       cbdcw: // global
           P64[Sp + 24] = GHC.Types.False_closure+1;
           I64[Sp + 16] = _sbc23::I64;
           call _sbc2n() args: 0, res: 0, upd: 0;
       cbdcl: // global
           I64[Sp - 8] = block_cbdcj_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdd4; else goto cbdcm;
       ubdd4: // global
           call _cbdcj(R1) args: 0, res: 0, upd: 0;
       cbdcm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdcj() //  [R1]
         { info_tbl: [(cbdcj,
                       label: block_cbdcj_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdcj: // global
           _sbc4j::I64 = I64[Sp + 32];
           _sbc4r::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 15] + (_sbc4j::I64 << 2)]);
           call MO_Touch(P64[R1 + 7]);
           if (_sbc4r::I64 == 10) goto cbdcv; else goto cbdcu;
       cbdcv: // global
           I64[Sp + 24] = _sbc4j::I64;
           P64[Sp + 32] = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call _sbc2n() args: 0, res: 0, upd: 0;
       cbdcu: // global
           P64[Sp + 24] = R1;
           I64[Sp + 32] = _sbc4j::I64 + 1;
           Sp = Sp + 8;
           call _cbdcc() args: 0, res: 0, upd: 0;
     }
 },
 _sbc2n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbc2n: // global
           I64[Sp - 8] = block_cbd6M_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdd8; else goto cbd6N;
       ubdd8: // global
           call _cbd6M(R1) args: 0, res: 0, upd: 0;
       cbd6N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbd6M() //  [R1]
         { info_tbl: [(cbd6M,
                       label: block_cbd6M_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd6M: // global
           _sbc22::I64 = I64[Sp + 80];
           _sbc2q::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto cbdbv; else goto cbdbR;
       cbdbv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdby; else goto cbdbx;
       cbdby: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdbx: // global
           if (_sbc22::I64 == _sbc2q::I64) goto cbdbK; else goto cbdbJ;
       cbdbK: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbc2q::I64;
           P64[Sp + 80] = GHC.Types.[]_closure+1;
           P64[Sp] = Hp - 7;
           call _sbc2r() args: 0, res: 0, upd: 0;
       cbdbJ: // global
           Hp = Hp - 16;
           I64[Sp - 8] = _sbc2q::I64 - 1;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call _cbd7y() args: 0, res: 0, upd: 0;
       cbdbR: // global
           I64[Sp] = block_cbdbN_info;
           R6 = GHC.Types.[]_closure+1;
           R5 = _sbc2q::I64;
           R4 = _sbc22::I64;
           R3 = P64[Sp + 56];
           R2 = I64[Sp + 48];
           call $wunpack_nl_rb6WF_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbd7y() //  []
         { info_tbl: [(cbd7y,
                       label: block_cbd7y_info
                       rep:StackRep [True, False, False, False, True, False, False, True,
                                     False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd7y: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbdbE; else goto cbdbD;
       cbdbE: // global
           HpAlloc = 40;
           I64[Sp] = block_cbd7y_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbdbD: // global
           _sbc3U::P64 = P64[Sp + 16];
           _sbc3V::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_sbc3V::I64,
                            I64[Sp + 96])) goto cbdbG; else goto cbdbH;
       cbdbG: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 64] + (_sbc3V::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _sbc3U::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 8] = _sbc3V::I64 - 1;
           call _cbd7y() args: 0, res: 0, upd: 0;
       cbdbH: // global
           Hp = Hp - 40;
           P64[Sp + 96] = _sbc3U::P64;
           Sp = Sp + 24;
           call _cbd7s() args: 0, res: 0, upd: 0;
     }
 },
 _cbd7s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd7s: // global
           Hp = Hp + 16;
           _sbc3Q::P64 = P64[Sp + 72];
           if (Hp > HpLim) (likely: False) goto cbdbB; else goto cbdbA;
       cbdbB: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cbd7r_info;
           R1 = _sbc3Q::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdbA: // global
           _sbc2q::I64 = I64[Sp + 16];
           call MO_Touch(P64[Sp + 48]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbc2q::I64;
           P64[Sp + 72] = _sbc3Q::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 8;
           call _sbc2r() args: 0, res: 0, upd: 0;
     }
 },
 _cbd7r() //  [R1]
         { info_tbl: [(cbd7r,
                       label: block_cbd7r_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd7r: // global
           P64[Sp + 80] = R1;
           Sp = Sp + 8;
           call _cbd7s() args: 0, res: 0, upd: 0;
     }
 },
 _cbdbN() //  [R1]
         { info_tbl: [(cbdbN,
                       label: block_cbdbN_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdbN: // global
           I64[Sp] = block_cbdbP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubdd2; else goto cbdbT;
       ubdd2: // global
           call _cbdbP(R1) args: 0, res: 0, upd: 0;
       cbdbT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdbP() //  [R1]
         { info_tbl: [(cbdbP,
                       label: block_cbdbP_info
                       rep:StackRep [False, False, True, False, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdbP: // global
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 80] = P64[R1 + 7];
           call _sbc2r() args: 0, res: 0, upd: 0;
     }
 },
 _sbc2r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbc2r: // global
           I64[Sp - 8] = block_cbd6Z_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdd9; else goto cbd70;
       ubdd9: // global
           call _cbd6Z(R1) args: 0, res: 0, upd: 0;
       cbd70: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbd6Z() //  [R1]
         { info_tbl: [(cbd6Z,
                       label: block_cbd6Z_info
                       rep:StackRep [False, False, False, True, True, False, True, False,
                                     False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd6Z: // global
           _sbc1Y::I64 = I64[Sp + 56];
           _sbc1Z::P64 = P64[Sp + 64];
           _sbc20::P64 = P64[Sp + 72];
           _sbc21::I64 = I64[Sp + 80];
           _sbc23::I64 = I64[Sp + 96];
           if (R1 & 7 == 1) goto cbdaU; else goto cbdbq;
       cbdaU: // global
           Hp = Hp + 96;
           _sbc2v::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbdbt; else goto cbdaW;
       cbdaW: // global
           I64[Hp - 88] = buf1_sbc2w_info;
           P64[Hp - 72] = _sbc1Z::P64;
           P64[Hp - 64] = _sbc20::P64;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = _sbc1Y::I64;
           I64[Hp - 40] = _sbc21::I64;
           I64[Hp - 32] = _sbc23::I64;
           I64[Hp - 24] = sat_sbc33_info;
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 24];
           _cbd74::P64 = Hp - 88;
           P64[Hp] = _cbd74::P64;
           I64[Sp + 8] = block_cbd78_info;
           R2 = GHC.IO.Handle.Text.hGetChar3_closure+2;
           R1 = Hp - 23;
           P64[Sp + 96] = _cbd74::P64;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       cbdbq: // global
           Hp = Hp + 96;
           _sbc2v::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbdbt; else goto cbdbs;
       cbdbt: // global
           HpAlloc = 96;
           R1 = _sbc2v::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdbs: // global
           I64[Hp - 88] = sat_sbc3H_info;
           P64[Hp - 72] = _sbc1Z::P64;
           P64[Hp - 64] = _sbc20::P64;
           I64[Hp - 56] = _sbc1Y::I64;
           I64[Hp - 48] = _sbc21::I64;
           I64[Hp - 40] = _sbc23::I64;
           I64[Hp - 32] = I64[Sp + 32];
           _sbc24::P64 = P64[Sp + 104];
           _sbc2f::P64 = P64[Sp + 16];
           _sbc2t::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sbc2f::P64 + 8] = Hp - 88;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc2f::P64);
           I64[Hp - 24] = sat_sbc3L_info;
           P64[Hp - 8] = _sbc24::P64;
           P64[Hp] = _sbc2t::P64;
           R1 = Hp - 24;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbd78() //  [R1]
         { info_tbl: [(cbd78,
                       label: block_cbd78_info
                       rep:StackRep [False, True, True, True, False, True, True, True,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd78: // global
           I64[Sp] = block_cbd7a_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubdcU; else goto cbd7b;
       ubdcU: // global
           call _cbd7a(R1) args: 0, res: 0, upd: 0;
       cbd7b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbd7a() //  [R1]
         { info_tbl: [(cbd7a,
                       label: block_cbd7a_info
                       rep:StackRep [False, True, True, True, False, True, True, True,
                                     True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd7a: // global
           if (R1 & 7 == 1) goto cbdb2; else goto cbdbm;
       cbdb2: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbdb5; else goto cbdb4;
       cbdb5: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdb4: // global
           I64[Hp - 88] = sat_sbc3f_info;
           _cbd74::P64 = P64[Sp + 88];
           P64[Hp - 72] = _cbd74::P64;
           _sbc24::P64 = P64[Sp + 96];
           _sbc2f::P64 = P64[Sp + 8];
           _sbc2t::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sbc2f::P64 + 8] = Hp - 88;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc2f::P64);
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sbc2t::P64;
           P64[Hp - 48] = _sbc24::P64;
           I64[Hp - 40] = sat_sbc3p_info;
           P64[Hp - 24] = _cbd74::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           I64[Sp + 96] = block_cbdb0_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp + 96;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
       cbdbm: // global
           I64[Sp + 32] = block_cbd7g_info;
           R1 = P64[R1 + 6];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto ubdcV; else goto cbd7h;
       ubdcV: // global
           call _cbd7g(R1) args: 0, res: 0, upd: 0;
       cbd7h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdb0() //  [R1]
         { info_tbl: [(cbdb0,
                       label: block_cbdb0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdb0: // global
           I64[Sp] = block_cbdb9_info;
           R2 = R1;
           call go1_rb6WQ_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbdb9() //  [R1]
         { info_tbl: [(cbdb9,
                       label: block_cbdb9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdb9: // global
           if (R1 & 7 == 1) goto cbdbg; else goto cbdbk;
       cbdbg: // global
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.ioe_EOF1_entry() args: 8, res: 0, upd: 8;
       cbdbk: // global
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbd7g() //  [R1]
         { info_tbl: [(cbd7g,
                       label: block_cbd7g_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd7g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbdbp; else goto cbdbo;
       cbdbp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdbo: // global
           _sbc3z::P64 = P64[R1 + 7];
           _sbc3A::P64 = P64[R1 + 15];
           _sbc3y::I64 = I64[R1 + 23];
           _sbc3B::I64 = I64[R1 + 31];
           _sbc3C::I64 = I64[R1 + 39];
           _sbc3D::I64 = I64[R1 + 47];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 64];
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = _sbc3y::I64;
           P64[Sp + 24] = _sbc3z::P64;
           P64[Sp + 32] = _sbc3A::P64;
           I64[Sp + 40] = _sbc3B::I64;
           I64[Sp + 48] = _sbc3C::I64;
           I64[Sp + 56] = _sbc3D::I64;
           P64[Sp + 64] = Hp - 14;
           Sp = Sp + 8;
           call _cbd6w() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.989367324 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine3_closure" {
     GHC.IO.Handle.Text.hGetLine3_closure:
         const GHC.IO.Handle.Text.hGetLine3_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbdhe,
                       label: GHC.IO.Handle.Text.hGetLine3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdhe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdhf; else goto cbdhg;
       cbdhf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetLine3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdhg: // global
           I64[Sp - 24] = block_cbdhb_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdhk; else goto cbdhc;
       ubdhk: // global
           call _cbdhb(R1) args: 0, res: 0, upd: 0;
       cbdhc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdhb() //  [R1]
         { info_tbl: [(cbdhb,
                       label: block_cbdhb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdhb: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.995372834 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetLine5_bytes" {
     GHC.IO.Handle.Text.hGetLine5_bytes:
         I8[] [104,71,101,116,76,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:10.997225122 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine4_closure" {
     GHC.IO.Handle.Text.hGetLine4_closure:
         const GHC.IO.Handle.Text.hGetLine4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine4_entry() //  [R1]
         { info_tbl: [(cbdhE,
                       label: GHC.IO.Handle.Text.hGetLine4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdhE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbdhF; else goto cbdhG;
       cbdhF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdhG: // global
           (_cbdhB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdhB::I64 == 0) goto cbdhD; else goto cbdhC;
       cbdhD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdhC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdhB::I64;
           R2 = GHC.IO.Handle.Text.hGetLine5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.001463506 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine2_closure" {
     GHC.IO.Handle.Text.hGetLine2_closure:
         const GHC.IO.Handle.Text.hGetLine2_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine2_entry() //  [R2]
         { info_tbl: [(cbdhW,
                       label: GHC.IO.Handle.Text.hGetLine2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdhW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdi0; else goto cbdi1;
       cbdi0: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetLine2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbdi1: // global
           I64[Sp - 8] = block_cbdhT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdi9; else goto cbdhU;
       ubdi9: // global
           call _cbdhT(R1) args: 0, res: 0, upd: 0;
       cbdhU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdhT() //  [R1]
         { info_tbl: [(cbdhT,
                       label: block_cbdhT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdhT: // global
           _sbc52::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 8] = block_cbdhZ_info;
           _sbc4J::P64 = R1;
           R1 = _sbc52::P64;
           P64[Sp] = _sbc4J::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdi8; else goto cbdi3;
       ubdi8: // global
           call _cbdhZ(R1) args: 0, res: 0, upd: 0;
       cbdi3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdhZ() //  [R1]
         { info_tbl: [(cbdhZ,
                       label: block_cbdhZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdhZ: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$whGetLineBufferedLoop_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.009597829 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine1_closure" {
     GHC.IO.Handle.Text.hGetLine1_closure:
         const GHC.IO.Handle.Text.hGetLine1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine1_entry() //  [R2]
         { info_tbl: [(cbdiy,
                       label: GHC.IO.Handle.Text.hGetLine1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdiy: // global
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.012839337 UTC

[section ""data" . GHC.IO.Handle.Text.hGetLine_closure" {
     GHC.IO.Handle.Text.hGetLine_closure:
         const GHC.IO.Handle.Text.hGetLine_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetLine_entry() //  [R2]
         { info_tbl: [(cbdiJ,
                       label: GHC.IO.Handle.Text.hGetLine_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdiJ: // global
           R2 = R2;
           call GHC.IO.Handle.Text.hGetLine1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.016349207 UTC

[section ""data" . lvl11_rb6WR_closure" {
     lvl11_rb6WR_closure:
         const lvl11_rb6WR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rb6WR_entry() //  [R1]
         { info_tbl: [(cbdj1,
                       label: lvl11_rb6WR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdj1: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbdj2; else goto cbdj3;
       cbdj2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdj3: // global
           (_cbdiT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdiT::I64 == 0) goto cbdiV; else goto cbdiU;
       cbdiV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdiU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdiT::I64;
           I64[Sp - 24] = block_cbdiW_info;
           R6 = 0;
           R5 = GHC.IO.FD.$tcFD1_closure;
           R4 = GHC.IO.FD.$trModule_closure;
           R3 = 15546290101957756376;
           R2 = 10838815552519039062;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cbdiW() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cbdiW,
                       label: block_cbdiW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdiW: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cbdiX() args: 0, res: 0, upd: 0;
     }
 },
 _cbdiX() //  []
         { info_tbl: [(cbdiX,
                       label: block_cbdiX_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdiX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbdj6; else goto cbdj5;
       cbdj6: // global
           HpAlloc = 48;
           I64[Sp] = block_cbdiX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cbdj5: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.028380267 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking2_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking2_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking2_info;
         const 0;
 },
 sat_sbc66_entry() //  [R1]
         { info_tbl: [(cbdks,
                       label: sat_sbc66_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdks: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbdkz; else goto cbdkA;
       cbdkz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdkA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbdkp_info;
           _sbc5N::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbc5N::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdkE; else goto cbdkq;
       ubdkE: // global
           call _cbdkp(R1) args: 0, res: 0, upd: 0;
       cbdkq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdkp() //  [R1]
         { info_tbl: [(cbdkp,
                       label: block_cbdkp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdkp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdkD; else goto cbdkC;
       cbdkD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdkC: // global
           _sbc65::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbc65::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc6a_entry() //  [R1]
         { info_tbl: [(cbdkN,
                       label: sat_sbc6a_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdkN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbdkU; else goto cbdkV;
       cbdkU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdkV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbdkK_info;
           _sbc5N::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbc5N::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdkZ; else goto cbdkL;
       ubdkZ: // global
           call _cbdkK(R1) args: 0, res: 0, upd: 0;
       cbdkL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdkK() //  [R1]
         { info_tbl: [(cbdkK,
                       label: block_cbdkK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdkK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdkY; else goto cbdkX;
       cbdkY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdkX: // global
           _sbc69::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbc69::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc6q_entry() //  [R1]
         { info_tbl: [(cbdlv,
                       label: sat_sbc6q_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdlv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbdlC; else goto cbdlD;
       cbdlC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdlD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbdls_info;
           _sbc5M::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbc5M::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdlH; else goto cbdlt;
       ubdlH: // global
           call _cbdls(R1) args: 0, res: 0, upd: 0;
       cbdlt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdls() //  [R1]
         { info_tbl: [(cbdls,
                       label: block_cbdls_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdls: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdlG; else goto cbdlF;
       cbdlG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdlF: // global
           _sbc6p::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbc6p::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking2_entry() //  [R2, R3, R4, R5,
                                                     R6]
         { info_tbl: [(cbdlI,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdlI: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbdlJ; else goto cbdlK;
       cbdlJ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufNonBlocking2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdlK: // global
           I64[Sp - 40] = block_cbdjD_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubdm8; else goto cbdjE;
       ubdm8: // global
           call _cbdjD(R1) args: 0, res: 0, upd: 0;
       cbdjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdjD() //  [R1]
         { info_tbl: [(cbdjD,
                       label: block_cbdjD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdjD: // global
           I64[Sp - 8] = block_cbdjI_info;
           _sbc5n::P64 = R1;
           _sbc5t::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbc5t::P64;
           P64[Sp + 8] = _sbc5n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdm4; else goto cbdjJ;
       ubdm4: // global
           call _cbdjI(R1) args: 0, res: 0, upd: 0;
       cbdjJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdjI() //  [R1]
         { info_tbl: [(cbdjI,
                       label: block_cbdjI_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdjI: // global
           I64[Sp - 40] = block_cbdjN_info;
           _sbc5G::P64 = P64[R1 + 7];
           _sbc5H::P64 = P64[R1 + 15];
           _sbc5F::I64 = I64[R1 + 23];
           _sbc5I::I64 = I64[R1 + 31];
           _sbc5J::I64 = I64[R1 + 39];
           _sbc5K::I64 = I64[R1 + 47];
           R1 = P64[Sp + 40];
           P64[Sp - 32] = _sbc5H::P64;
           I64[Sp - 24] = _sbc5I::I64;
           I64[Sp - 16] = _sbc5J::I64;
           I64[Sp - 8] = _sbc5K::I64;
           P64[Sp] = _sbc5G::P64;
           I64[Sp + 40] = _sbc5F::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubdm5; else goto cbdjO;
       ubdm5: // global
           call _cbdjN(R1) args: 0, res: 0, upd: 0;
       cbdjO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdjN() //  [R1]
         { info_tbl: [(cbdjN,
                       label: block_cbdjN_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdjN: // global
           _sbc5j::P64 = P64[Sp + 64];
           _sbc5M::I64 = I64[R1 + 7];
           _sbc5N::I64 = I64[Sp + 32] - I64[Sp + 24];
           if (%MO_S_Ge_W64(_sbc5M::I64,
                            _sbc5N::I64)) goto cbdlP; else goto cbdm0;
       cbdlP: // global
           I64[Sp] = block_cbdjY_info;
           R1 = _sbc5j::P64;
           I64[Sp + 32] = _sbc5N::I64;
           I64[Sp + 64] = _sbc5M::I64;
           if (R1 & 7 != 0) goto ubdm6; else goto cbdjZ;
       ubdm6: // global
           call _cbdjY(R1) args: 0, res: 0, upd: 0;
       cbdjZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbdm0: // global
           I64[Sp] = block_cbdl1_info;
           R1 = _sbc5j::P64;
           I64[Sp + 64] = _sbc5M::I64;
           if (R1 & 7 != 0) goto ubdm7; else goto cbdl2;
       ubdm7: // global
           call _cbdl1(R1) args: 0, res: 0, upd: 0;
       cbdl2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdjY() //  [R1]
         { info_tbl: [(cbdjY,
                       label: block_cbdjY_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdjY: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbdlS; else goto cbdlR;
       cbdlS: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdlR: // global
           _sbc5k::P64 = P64[Sp + 72];
           _sbc5n::P64 = P64[Sp + 56];
           _sbc5t::P64 = P64[Sp + 48];
           _sbc5F::I64 = I64[Sp + 80];
           _sbc5G::P64 = P64[Sp + 40];
           _sbc5H::P64 = P64[Sp + 8];
           _sbc5I::I64 = I64[Sp + 16];
           _sbc5M::I64 = I64[Sp + 64];
           _sbc5N::I64 = I64[Sp + 32];
           _sbc5Q::I64 = I64[R1 + 7];
           (_sbc5W::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sbc5Q::I64, _sbc5F::I64 + I64[Sp + 24], _sbc5N::I64);
           call MO_Touch(_sbc5G::P64);
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sbc5G::P64;
           P64[Hp - 80] = _sbc5H::P64;
           I64[Hp - 72] = _sbc5F::I64;
           I64[Hp - 64] = _sbc5I::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           call MO_WriteBarrier();
           P64[_sbc5t::P64 + 8] = Hp - 95;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc5t::P64);
           _sbc60::I64 = _sbc5M::I64 - _sbc5N::I64;
           if (_sbc60::I64 != 0) goto cbdlY; else goto cbdlZ;
       cbdlY: // global
           I64[Hp - 40] = sat_sbc66_info;
           P64[Hp - 24] = _sbc5k::P64;
           I64[Hp - 16] = _sbc5N::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbc5Q::I64 + _sbc5N::I64;
           R6 = _sbc60::I64;
           R5 = Hp - 40;
           R4 = Hp - 7;
           R3 = _sbc5I::I64;
           R2 = _sbc5n::P64;
           Sp = Sp + 88;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cbdlZ: // global
           I64[Hp - 40] = sat_sbc6a_info;
           P64[Hp - 24] = _sbc5k::P64;
           I64[Hp - 16] = _sbc5N::I64;
           _cbdkG::P64 = Hp - 40;
           Hp = Hp - 16;
           R1 = _cbdkG::P64;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbdl1() //  [R1]
         { info_tbl: [(cbdl1,
                       label: block_cbdl1_info
                       rep:StackRep [False, True, True, True, False, False, True, True,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdl1: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbdm3; else goto cbdm2;
       cbdm3: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdm2: // global
           _sbc5k::P64 = P64[Sp + 72];
           _sbc5t::P64 = P64[Sp + 48];
           _sbc5F::I64 = I64[Sp + 80];
           _sbc5G::P64 = P64[Sp + 40];
           _sbc5H::P64 = P64[Sp + 8];
           _sbc5I::I64 = I64[Sp + 16];
           _sbc5J::I64 = I64[Sp + 24];
           _sbc5K::I64 = I64[Sp + 32];
           _sbc5M::I64 = I64[Sp + 64];
           (_sbc6i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[R1 + 7], _sbc5F::I64 + _sbc5J::I64, _sbc5M::I64);
           call MO_Touch(_sbc5G::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _sbc5G::P64;
           P64[Hp - 64] = _sbc5H::P64;
           I64[Hp - 56] = _sbc5F::I64;
           I64[Hp - 48] = _sbc5I::I64;
           I64[Hp - 40] = _sbc5J::I64 + _sbc5M::I64;
           I64[Hp - 32] = _sbc5K::I64;
           call MO_WriteBarrier();
           P64[_sbc5t::P64 + 8] = Hp - 79;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc5t::P64);
           I64[Hp - 24] = sat_sbc6q_info;
           P64[Hp - 8] = _sbc5k::P64;
           I64[Hp] = _sbc5M::I64;
           R1 = Hp - 24;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Text.$wbufReadNBEmpty_closure" {
     GHC.IO.Handle.Text.$wbufReadNBEmpty_closure:
         const GHC.IO.Handle.Text.$wbufReadNBEmpty_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wbufReadNBEmpty_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdma: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2,
                                                          R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbc7o_entry() //  [R1]
         { info_tbl: [(cbdmW,
                       label: sat_sbc7o_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdmW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbdn3; else goto cbdn4;
       cbdn3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdn4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbdmT_info;
           _sbc7k::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbc7k::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdn8; else goto cbdmU;
       ubdn8: // global
           call _cbdmT(R1) args: 0, res: 0, upd: 0;
       cbdmU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdmT() //  [R1]
         { info_tbl: [(cbdmT,
                       label: block_cbdmT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdmT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdn7; else goto cbdn6;
       cbdn7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdn6: // global
           _sbc7n::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbc7n::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubdou_srtd" {
     ubdou_srtd:
         const SbcpG_srt+56;
         const 33;
         const 8321499137;
 },
 GHC.IO.Handle.Text.$wbufReadNBEmpty_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cbdn9,
                       label: GHC.IO.Handle.Text.$wbufReadNBEmpty_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, True, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdn9: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cbdna; else goto cbdnb;
       cbdna: // global
           R1 = GHC.IO.Handle.Text.$wbufReadNBEmpty_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cbdnb: // global
           I64[Sp - 40] = block_cbdme_info;
           R1 = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubdoq; else goto cbdmf;
       ubdoq: // global
           call _cbdme(R1) args: 0, res: 0, upd: 0;
       cbdmf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdov_srtd" {
     ubdov_srtd:
         const SbcpG_srt+56;
         const 33;
         const 8053063681;
 },
 _cbdme() //  [R1]
         { info_tbl: [(cbdme,
                       label: block_cbdme_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdme: // global
           I64[Sp - 32] = block_cbdmj_info;
           _sbc6x::P64 = R1;
           _sbc6z::P64 = P64[R1 + 15];
           _sbc6A::P64 = P64[R1 + 23];
           _sbc6D::P64 = P64[R1 + 47];
           R1 = P64[R1 + 31];
           P64[Sp - 24] = _sbc6z::P64;
           P64[Sp - 16] = _sbc6A::P64;
           P64[Sp - 8] = _sbc6D::P64;
           P64[Sp] = _sbc6x::P64;
           Sp = Sp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdow_srtd" {
     ubdow_srtd:
         const SbcpG_srt+56;
         const 33;
         const 8053063681;
 },
 _cbdmj() //  [R1]
         { info_tbl: [(cbdmj,
                       label: block_cbdmj_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdmj: // global
           if (%MO_S_Le_W64(I64[Sp + 64],
                            I64[Sp + 40])) goto ubdok; else goto cbdo3;
       ubdok: // global
           P64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _sbc6R() args: 0, res: 0, upd: 0;
       cbdo3: // global
           I64[Sp - 8] = block_cbdmt_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 15];
           I64[Sp + 16] = I64[R1 + 7];
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbdmt() //  [R1]
         { info_tbl: [(cbdmt,
                       label: block_cbdmt_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdmt: // global
           if (R1 & 7 == 1) goto ubdol; else goto cbdo9;
       ubdol: // global
           Sp = Sp + 16;
           call _sbc6R() args: 0, res: 0, upd: 0;
       cbdo9: // global
           I64[Sp] = block_cbdmy_info;
           R1 = P64[Sp + 56];
           if (R1 & 7 != 0) goto ubdon; else goto cbdmz;
       ubdon: // global
           call _cbdmy(R1) args: 0, res: 0, upd: 0;
       cbdmz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _sbc6R() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbc6R: // global
           _sbc6V::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp + 8] = block_cbdnh_info;
           R2 = P64[Sp];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 32];
           P64[Sp] = _sbc6V::P64;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.fillReadBuffer0_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbdnh() //  [R1]
         { info_tbl: [(cbdnh,
                       label: block_cbdnh_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdnh: // global
           I64[Sp] = block_cbdnj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubdor; else goto cbdnm;
       ubdor: // global
           call _cbdnj(R1) args: 0, res: 0, upd: 0;
       cbdnm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdnj() //  [R1]
         { info_tbl: [(cbdnj,
                       label: block_cbdnj_info
                       rep:StackRep [False, False, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdnj: // global
           I64[Sp] = block_cbdnq_info;
           _sbc71::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _sbc71::P64;
           if (R1 & 7 != 0) goto ubdos; else goto cbdns;
       ubdos: // global
           call _cbdnq(R1) args: 0, res: 0, upd: 0;
       cbdns: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdnq() //  [R1]
         { info_tbl: [(cbdnq,
                       label: block_cbdnq_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdnq: // global
           if (R1 & 7 == 1) goto cbdny; else goto cbdnD;
       cbdny: // global
           R1 = P64[Sp + 40];
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbdnD: // global
           I64[Sp] = block_cbdnB_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubdot; else goto cbdnE;
       ubdot: // global
           call _cbdnB(R1) args: 0, res: 0, upd: 0;
       cbdnE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdnB() //  [R1]
         { info_tbl: [(cbdnB,
                       label: block_cbdnB_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdnB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdnK; else goto cbdnJ;
       cbdnK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdnJ: // global
           _sbc6u::P64 = P64[Sp + 40];
           _sbc76::I64 = I64[R1 + 7];
           if (_sbc76::I64 == 0) goto cbdo0; else goto cbdnZ;
       cbdo0: // global
           Hp = Hp - 16;
           R1 = _sbc6u::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbdnZ: // global
           _sbc6t::P64 = P64[Sp + 32];
           _sbc6v::I64 = I64[Sp + 48];
           _sbc6x::P64 = P64[Sp + 16];
           _sbc6D::P64 = P64[Sp + 8];
           _sbc71::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sbc6D::P64 + 8] = _sbc71::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc6D::P64);
           if (%MO_S_Gt_W64(_sbc6v::I64,
                            _sbc76::I64)) goto cbdnT; else goto cbdnX;
       cbdnT: // global
           Hp = Hp - 16;
           R6 = R1;
           R5 = _sbc6u::P64;
           R4 = _sbc6t::P64;
           R3 = _sbc71::P64;
           R2 = _sbc6x::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cbdnX: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbc6v::I64;
           R6 = Hp - 7;
           R5 = _sbc6u::P64;
           R4 = _sbc6t::P64;
           R3 = _sbc71::P64;
           R2 = _sbc6x::P64;
           Sp = Sp + 56;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbdmy() //  [R1]
         { info_tbl: [(cbdmy,
                       label: block_cbdmy_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdmy: // global
           I64[Sp + 56] = block_cbdmG_info;
           R6 = 0;
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 8];
           R3 = I64[Sp + 24];
           R2 = GHC.IO.FD.$fBufferedIOFD8_closure;
           I64[Sp + 48] = I64[Sp + 72];
           Sp = Sp + 48;
           call GHC.IO.FD.$wreadRawBufferPtrNoBlock_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbdmG() //  [R1]
         { info_tbl: [(cbdmG,
                       label: block_cbdmG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdmG: // global
           I64[Sp] = block_cbdmI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubdop; else goto cbdmJ;
       ubdop: // global
           call _cbdmI(R1) args: 0, res: 0, upd: 0;
       cbdmJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdmI() //  [R1]
         { info_tbl: [(cbdmI,
                       label: block_cbdmI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdmI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbdoe; else goto cbdod;
       cbdoe: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdod: // global
           _sbc6u::P64 = P64[Sp + 8];
           _sbc7k::I64 = I64[R1 + 7];
           if (_sbc7k::I64 != (-1)) goto cbdog; else goto cbdoh;
       cbdog: // global
           I64[Hp - 24] = sat_sbc7o_info;
           P64[Hp - 8] = _sbc6u::P64;
           I64[Hp] = _sbc7k::I64;
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbdoh: // global
           Hp = Hp - 32;
           R1 = _sbc6u::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.090159701 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes" {
     GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes:
         I8[] [104,71,101,116,66,117,102,78,111,110,66,108,111,99,107,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.092118191 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking3_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking3_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking3_entry() //  [R1]
         { info_tbl: [(cbdrz,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdrz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbdrA; else goto cbdrB;
       cbdrA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdrB: // global
           (_cbdrw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdrw::I64 == 0) goto cbdry; else goto cbdrx;
       cbdry: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdrx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdrw::I64;
           R2 = GHC.IO.Handle.Text.hGetBufNonBlocking4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.09940387 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBufNonBlocking_closure" {
     GHC.IO.Handle.Text.$whGetBufNonBlocking_closure:
         const GHC.IO.Handle.Text.$whGetBufNonBlocking_info;
         const 0;
 },
 sat_sbc8u_entry() //  [R1]
         { info_tbl: [(cbdsv,
                       label: sat_sbc8u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdsv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdsz; else goto cbdsA;
       cbdsz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdsA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbdss_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdsE; else goto cbdst;
       ubdsE: // global
           call _cbdss(R1) args: 0, res: 0, upd: 0;
       cbdst: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdss() //  [R1]
         { info_tbl: [(cbdss,
                       label: block_cbdss_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdss: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdsD; else goto cbdsC;
       cbdsD: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdsC: // global
           _sbc8p::P64 = P64[R1 + 7];
           _sbc8q::P64 = P64[R1 + 15];
           _sbc8o::I64 = I64[R1 + 23];
           _sbc8r::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbc8p::P64;
           P64[Hp - 32] = _sbc8q::P64;
           I64[Hp - 24] = _sbc8o::I64;
           I64[Hp - 16] = _sbc8r::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc8N_entry() //  [R1]
         { info_tbl: [(cbdt1,
                       label: sat_sbc8N_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdt1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbdt8; else goto cbdt9;
       cbdt8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdt9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbdsY_info;
           _sbc8D::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbc8D::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdtd; else goto cbdsZ;
       ubdtd: // global
           call _cbdsY(R1) args: 0, res: 0, upd: 0;
       cbdsZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdsY() //  [R1]
         { info_tbl: [(cbdsY,
                       label: block_cbdsY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdsY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdtc; else goto cbdtb;
       cbdtc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdtb: // global
           _sbc8H::P64 = P64[R1 + 7];
           _sbc8I::P64 = P64[R1 + 15];
           _sbc8G::I64 = I64[R1 + 23];
           _sbc8J::I64 = I64[R1 + 31];
           _sbc8L::I64 = I64[R1 + 47];
           _sbc8M::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbc8H::P64;
           P64[Hp - 32] = _sbc8I::P64;
           I64[Hp - 24] = _sbc8G::I64;
           I64[Hp - 16] = _sbc8J::I64;
           I64[Hp - 8] = _sbc8M::I64;
           I64[Hp] = _sbc8L::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbc98_entry() //  [R1, R2]
         { info_tbl: [(cbdte,
                       label: sat_sbc98_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdte: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cbdtf; else goto cbdtg;
       cbdtf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbdtg: // global
           I64[Sp - 32] = block_cbdrZ_info;
           _sbc7q::P64 = P64[R1 + 6];
           _sbc7v::P64 = P64[R1 + 14];
           _sbc7t::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sbc7q::P64;
           I64[Sp - 16] = _sbc7t::I64;
           P64[Sp - 8] = _sbc7v::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubduK; else goto cbds0;
       ubduK: // global
           call _cbdrZ(R1) args: 0, res: 0, upd: 0;
       cbds0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdrZ() //  [R1]
         { info_tbl: [(cbdrZ,
                       label: block_cbdrZ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdrZ: // global
           I64[Sp - 40] = block_cbds4_info;
           _sbc7y::P64 = R1;
           _sbc7E::P64 = P64[R1 + 47];
           _sbc7G::P64 = P64[R1 + 63];
           _sbc7H::P64 = P64[R1 + 71];
           _sbc7K::P64 = P64[R1 + 95];
           R1 = P64[_sbc7H::P64 + 8];
           P64[Sp - 32] = _sbc7E::P64;
           P64[Sp - 24] = _sbc7G::P64;
           P64[Sp - 16] = _sbc7H::P64;
           P64[Sp - 8] = _sbc7K::P64;
           P64[Sp] = _sbc7y::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubduA; else goto cbds5;
       ubduA: // global
           call _cbds4(R1) args: 0, res: 0, upd: 0;
       cbds5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbds4() //  [R1]
         { info_tbl: [(cbds4,
                       label: block_cbds4_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbds4: // global
           I64[Sp - 16] = block_cbdsb_info;
           _sbc7X::I64 = I64[R1 + 39];
           _sbc7Y::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbc7Y::I64;
           I64[Sp] = _sbc7X::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubduB; else goto cbdsc;
       ubduB: // global
           call _cbdsb(R1) args: 0, res: 0, upd: 0;
       cbdsc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdsb() //  [R1]
         { info_tbl: [(cbdsb,
                       label: block_cbdsb_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdsb: // global
           if (R1 & 7 == 1) goto cbdue; else goto ubduv;
       cbdue: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubduw; else goto cbdtA;
       ubduw: // global
           Sp = Sp + 24;
           goto ubduE;
       cbdtA: // global
           _sbc8g::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cbdsj_info;
           R1 = _sbc8g::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubduC; else goto cbdsk;
       ubduC: // global
           call _cbdsj(R1) args: 0, res: 0, upd: 0;
       cbdsk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubduv: // global
           Sp = Sp + 24;
           goto ubduE;
       ubduE: // global
           call _sbc7Z() args: 0, res: 0, upd: 0;
     }
 },
 _cbdsj() //  [R1]
         { info_tbl: [(cbdsj,
                       label: block_cbdsj_info
                       rep:StackRep [False, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdsj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbdtD; else goto cbdtC;
       cbdtD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdtC: // global
           _sbc7H::P64 = P64[Sp + 24];
           _sbc8i::P64 = P64[R1 + 7];
           _sbc8j::P64 = P64[R1 + 15];
           _sbc8m::P64 = P64[_sbc7H::P64 + 8];
           I64[Hp - 16] = sat_sbc8u_info;
           P64[Hp] = _sbc8m::P64;
           call MO_WriteBarrier();
           P64[_sbc7H::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc7H::P64);
           I64[Sp] = block_cbdsI_info;
           R1 = _sbc8m::P64;
           P64[Sp + 16] = _sbc8j::P64;
           P64[Sp + 24] = _sbc8i::P64;
           if (R1 & 7 != 0) goto ubduF; else goto cbdsJ;
       ubduF: // global
           call _cbdsI(R1) args: 0, res: 0, upd: 0;
       cbdsJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdsI() //  [R1]
         { info_tbl: [(cbdsI,
                       label: block_cbdsI_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdsI: // global
           _sbc8D::I64 = I64[R1 + 39];
           if (_sbc8D::I64 != 0) goto cbdtG; else goto cbdub;
       cbdtG: // global
           I64[Sp - 24] = block_cbdsP_info;
           _sbc8y::P64 = P64[R1 + 7];
           _sbc8z::P64 = P64[R1 + 15];
           _sbc8x::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sbc8z::P64;
           I64[Sp - 8] = _sbc8D::I64;
           P64[Sp] = _sbc8y::P64;
           I64[Sp + 32] = _sbc8x::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubduG; else goto cbdsQ;
       ubduG: // global
           call _cbdsP(R1) args: 0, res: 0, upd: 0;
       cbdsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbdub: // global
           _sbc7E::P64 = P64[Sp + 8];
           _sbc8j::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbc7E::P64 + 8] = _sbc8j::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc7E::P64);
           Sp = Sp + 8;
           call _sbc7Z() args: 0, res: 0, upd: 0;
     }
 },
 _cbdsP() //  [R1]
         { info_tbl: [(cbdsP,
                       label: block_cbdsP_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdsP: // global
           if (R1 & 7 == 1) goto cbdtI; else goto cbdu0;
       cbdtI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbdtL; else goto cbdtK;
       cbdtL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdtK: // global
           I64[Hp - 24] = sat_sbc8N_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sbc7E::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbc7E::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc7E::P64);
           Sp = Sp + 32;
           call _sbc7Z() args: 0, res: 0, upd: 0;
       cbdu0: // global
           I64[Sp] = block_cbdtO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubduI; else goto cbdtP;
       ubduI: // global
           call _cbdtO(R1) args: 0, res: 0, upd: 0;
       cbdtP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdtO() //  [R1]
         { info_tbl: [(cbdtO,
                       label: block_cbdtO_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdtO: // global
           I64[Sp - 8] = block_cbdtT_info;
           R2 = P64[Sp + 48];
           _sbc8R::P64 = P64[R1 + 7];
           _sbc8S::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbc8S::P64;
           P64[Sp + 48] = _sbc8R::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdtT() //  [R1]
         { info_tbl: [(cbdtT,
                       label: block_cbdtT_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdtT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdu4; else goto cbdu3;
       cbdu4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdu3: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cbdtW_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbdtW() //  [R1]
         { info_tbl: [(cbdtW,
                       label: block_cbdtW_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdtW: // global
           I64[Sp] = block_cbdtY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubduL; else goto cbdu6;
       ubduL: // global
           call _cbdtY(R1) args: 0, res: 0, upd: 0;
       cbdu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdtY() //  [R1]
         { info_tbl: [(cbdtY,
                       label: block_cbdtY_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdtY: // global
           _sbc7E::P64 = P64[Sp + 8];
           _sbc94::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbc7E::P64 + 8] = _sbc94::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc7E::P64);
           Sp = Sp + 8;
           call _sbc7Z() args: 0, res: 0, upd: 0;
     }
 },
 _sbc7Z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbc7Z: // global
           _sbc83::P64 = P64[P64[Sp] + 8];
           I64[Sp + 24] = block_cbdtm_info;
           R1 = _sbc83::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubduN; else goto cbdto;
       ubduN: // global
           call _cbdtm(R1) args: 0, res: 0, upd: 0;
       cbdto: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdtm() //  [R1]
         { info_tbl: [(cbdtm,
                       label: block_cbdtm_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdtm: // global
           _sbc7q::P64 = P64[Sp + 16];
           _sbc7y::P64 = P64[Sp + 8];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbdtx; else goto cbdtw;
       cbdtx: // global
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sbc7q::P64;
           R3 = I64[R1 + 31];
           R2 = _sbc7y::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wbufReadNBEmpty_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cbdtw: // global
           R6 = P64[Sp + 32];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sbc7q::P64;
           R3 = R1;
           R2 = _sbc7y::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubduZ_srtd" {
     ubduZ_srtd:
         const SbcpG_srt+8;
         const 41;
         const 1700807051265;
 },
 GHC.IO.Handle.Text.$whGetBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cbduR,
                       label: GHC.IO.Handle.Text.$whGetBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbduR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbduV; else goto cbduU;
       cbduV: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBufNonBlocking_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbduU: // global
           if (R4 == 0) goto cbduQ; else goto cbduP;
       cbduQ: // global
           Hp = Hp - 48;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbduP: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cbduX; else goto cbduY;
       cbduX: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sbc98_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = R4;
           R4 = Hp - 22;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cbduY: // global
           Hp = Hp - 48;
           R4 = R4;
           R3 = GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.140107343 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking1_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking1_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbdwZ,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdwZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdx0; else goto cbdx1;
       cbdx0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufNonBlocking1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdx1: // global
           I64[Sp - 24] = block_cbdwW_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdx5; else goto cbdwX;
       ubdx5: // global
           call _cbdwW(R1) args: 0, res: 0, upd: 0;
       cbdwX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdwW() //  [R1]
         { info_tbl: [(cbdwW,
                       label: block_cbdwW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdwW: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBufNonBlocking_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.145737005 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufNonBlocking_closure" {
     GHC.IO.Handle.Text.hGetBufNonBlocking_closure:
         const GHC.IO.Handle.Text.hGetBufNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cbdxk,
                       label: GHC.IO.Handle.Text.hGetBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdxk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBufNonBlocking1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.148984639 UTC

[section ""cstring" . lvl12_rb6WS_bytes" {
     lvl12_rb6WS_bytes:
         I8[] [104,71,101,116,66,117,102,83,111,109,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.150896389 UTC

[section ""data" . lvl13_rb6WT_closure" {
     lvl13_rb6WT_closure:
         const lvl13_rb6WT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rb6WT_entry() //  [R1]
         { info_tbl: [(cbdxy,
                       label: lvl13_rb6WT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdxy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbdxz; else goto cbdxA;
       cbdxz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdxA: // global
           (_cbdxv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdxv::I64 == 0) goto cbdxx; else goto cbdxw;
       cbdxx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdxw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdxv::I64;
           R2 = lvl12_rb6WS_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.159250891 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBufSome_closure" {
     GHC.IO.Handle.Text.$whGetBufSome_closure:
         const GHC.IO.Handle.Text.$whGetBufSome_info;
         const 0;
 },
 sat_sbcaI_entry() //  [R1]
         { info_tbl: [(cbdyy,
                       label: sat_sbcaI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdyy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdyC; else goto cbdyD;
       cbdyC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdyD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbdyv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdyH; else goto cbdyw;
       ubdyH: // global
           call _cbdyv(R1) args: 0, res: 0, upd: 0;
       cbdyw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdyv() //  [R1]
         { info_tbl: [(cbdyv,
                       label: block_cbdyv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdyv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdyG; else goto cbdyF;
       cbdyG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdyF: // global
           _sbcaD::P64 = P64[R1 + 7];
           _sbcaE::P64 = P64[R1 + 15];
           _sbcaC::I64 = I64[R1 + 23];
           _sbcaF::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbcaD::P64;
           P64[Hp - 32] = _sbcaE::P64;
           I64[Hp - 24] = _sbcaC::I64;
           I64[Hp - 16] = _sbcaF::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbcb1_entry() //  [R1]
         { info_tbl: [(cbdz4,
                       label: sat_sbcb1_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdz4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbdzb; else goto cbdzc;
       cbdzb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdzc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbdz1_info;
           _sbcaR::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbcaR::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdzg; else goto cbdz2;
       ubdzg: // global
           call _cbdz1(R1) args: 0, res: 0, upd: 0;
       cbdz2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdz1() //  [R1]
         { info_tbl: [(cbdz1,
                       label: block_cbdz1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdz1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdzf; else goto cbdze;
       cbdzf: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdze: // global
           _sbcaV::P64 = P64[R1 + 7];
           _sbcaW::P64 = P64[R1 + 15];
           _sbcaU::I64 = I64[R1 + 23];
           _sbcaX::I64 = I64[R1 + 31];
           _sbcaZ::I64 = I64[R1 + 47];
           _sbcb0::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbcaV::P64;
           P64[Hp - 32] = _sbcaW::P64;
           I64[Hp - 24] = _sbcaU::I64;
           I64[Hp - 16] = _sbcaX::I64;
           I64[Hp - 8] = _sbcb0::I64;
           I64[Hp] = _sbcaZ::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubdCm_srtd" {
     ubdCm_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 sat_sbcbm_entry() //  [R1, R2]
         { info_tbl: [(cbdzh,
                       label: sat_sbcbm_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdzh: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cbdzi; else goto cbdzj;
       cbdzi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbdzj: // global
           I64[Sp - 32] = block_cbdxY_info;
           _sbc9g::P64 = P64[R1 + 6];
           _sbc9l::P64 = P64[R1 + 14];
           _sbc9j::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sbc9g::P64;
           I64[Sp - 16] = _sbc9j::I64;
           P64[Sp - 8] = _sbc9l::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdC2; else goto cbdxZ;
       ubdC2: // global
           call _cbdxY(R1) args: 0, res: 0, upd: 0;
       cbdxZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCn_srtd" {
     ubdCn_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdxY() //  [R1]
         { info_tbl: [(cbdxY,
                       label: block_cbdxY_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdxY: // global
           I64[Sp - 56] = block_cbdy3_info;
           _sbc9o::P64 = R1;
           _sbc9q::P64 = P64[R1 + 15];
           _sbc9r::P64 = P64[R1 + 23];
           _sbc9u::P64 = P64[R1 + 47];
           _sbc9w::P64 = P64[R1 + 63];
           _sbc9x::P64 = P64[R1 + 71];
           _sbc9A::P64 = P64[R1 + 95];
           R1 = P64[R1 + 31];
           P64[Sp - 48] = _sbc9q::P64;
           P64[Sp - 40] = _sbc9r::P64;
           P64[Sp - 32] = _sbc9u::P64;
           P64[Sp - 24] = _sbc9w::P64;
           P64[Sp - 16] = _sbc9x::P64;
           P64[Sp - 8] = _sbc9A::P64;
           P64[Sp] = _sbc9o::P64;
           Sp = Sp - 56;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCo_srtd" {
     ubdCo_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdy3() //  [R1]
         { info_tbl: [(cbdy3,
                       label: block_cbdy3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdy3: // global
           _sbc9K::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 24] = block_cbdy7_info;
           _sbc9F::P64 = R1;
           _sbc9G::I64 = I64[R1 + 7];
           _sbc9H::I64 = I64[R1 + 15];
           R1 = _sbc9K::P64;
           I64[Sp - 16] = _sbc9G::I64;
           I64[Sp - 8] = _sbc9H::I64;
           P64[Sp] = _sbc9F::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdBS; else goto cbdy8;
       ubdBS: // global
           call _cbdy7(R1) args: 0, res: 0, upd: 0;
       cbdy8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCp_srtd" {
     ubdCp_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdy7() //  [R1]
         { info_tbl: [(cbdy7,
                       label: block_cbdy7_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdy7: // global
           I64[Sp - 16] = block_cbdye_info;
           _sbc9Q::I64 = I64[R1 + 39];
           _sbc9R::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbc9R::I64;
           I64[Sp] = _sbc9Q::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubdBT; else goto cbdyf;
       ubdBT: // global
           call _cbdye(R1) args: 0, res: 0, upd: 0;
       cbdyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCq_srtd" {
     ubdCq_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdye() //  [R1]
         { info_tbl: [(cbdye,
                       label: block_cbdye_info
                       rep:StackRep [True, True, True, True, False, False, False, False,
                                     False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdye: // global
           if (R1 & 7 == 1) goto cbdBs; else goto ubdBL;
       cbdBs: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubdBM; else goto cbdAO;
       ubdBM: // global
           Sp = Sp + 24;
           goto ubdBW;
       cbdAO: // global
           _sbcau::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cbdym_info;
           R1 = _sbcau::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubdBU; else goto cbdyn;
       ubdBU: // global
           call _cbdym(R1) args: 0, res: 0, upd: 0;
       cbdyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubdBL: // global
           Sp = Sp + 24;
           goto ubdBW;
       ubdBW: // global
           call _sbc9S() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubdCr_srtd" {
     ubdCr_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdym() //  [R1]
         { info_tbl: [(cbdym,
                       label: block_cbdym_info
                       rep:StackRep [True, True, False, False, False, False, True, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdym: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbdAR; else goto cbdAQ;
       cbdAR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdAQ: // global
           _sbc9x::P64 = P64[Sp + 64];
           _sbcaw::P64 = P64[R1 + 7];
           _sbcax::P64 = P64[R1 + 15];
           _sbcaA::P64 = P64[_sbc9x::P64 + 8];
           I64[Hp - 16] = sat_sbcaI_info;
           P64[Hp] = _sbcaA::P64;
           call MO_WriteBarrier();
           P64[_sbc9x::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc9x::P64);
           I64[Sp] = block_cbdyL_info;
           R1 = _sbcaA::P64;
           P64[Sp + 56] = _sbcax::P64;
           P64[Sp + 64] = _sbcaw::P64;
           if (R1 & 7 != 0) goto ubdBX; else goto cbdyM;
       ubdBX: // global
           call _cbdyL(R1) args: 0, res: 0, upd: 0;
       cbdyM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCs_srtd" {
     ubdCs_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdyL() //  [R1]
         { info_tbl: [(cbdyL,
                       label: block_cbdyL_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdyL: // global
           _sbcaR::I64 = I64[R1 + 39];
           if (_sbcaR::I64 != 0) goto cbdAU; else goto cbdBp;
       cbdAU: // global
           I64[Sp - 24] = block_cbdyS_info;
           _sbcaM::P64 = P64[R1 + 7];
           _sbcaN::P64 = P64[R1 + 15];
           _sbcaL::I64 = I64[R1 + 23];
           R1 = P64[Sp + 72];
           P64[Sp - 16] = _sbcaN::P64;
           I64[Sp - 8] = _sbcaR::I64;
           P64[Sp] = _sbcaM::P64;
           I64[Sp + 72] = _sbcaL::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdBY; else goto cbdyT;
       ubdBY: // global
           call _cbdyS(R1) args: 0, res: 0, upd: 0;
       cbdyT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbdBp: // global
           _sbc9u::P64 = P64[Sp + 48];
           _sbcax::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sbc9u::P64 + 8] = _sbcax::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc9u::P64);
           Sp = Sp + 8;
           call _sbc9S() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubdCt_srtd" {
     ubdCt_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdyS() //  [R1]
         { info_tbl: [(cbdyS,
                       label: block_cbdyS_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdyS: // global
           if (R1 & 7 == 1) goto cbdAW; else goto cbdBe;
       cbdAW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbdAZ; else goto cbdAY;
       cbdAZ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdAY: // global
           I64[Hp - 24] = sat_sbcb1_info;
           P64[Hp - 8] = P64[Sp + 80];
           I64[Hp] = I64[Sp + 16];
           _sbc9u::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sbc9u::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc9u::P64);
           Sp = Sp + 32;
           call _sbc9S() args: 0, res: 0, upd: 0;
       cbdBe: // global
           I64[Sp] = block_cbdB2_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubdC0; else goto cbdB3;
       ubdC0: // global
           call _cbdB2(R1) args: 0, res: 0, upd: 0;
       cbdB3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCu_srtd" {
     ubdCu_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdB2() //  [R1]
         { info_tbl: [(cbdB2,
                       label: block_cbdB2_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdB2: // global
           I64[Sp - 8] = block_cbdB7_info;
           R2 = P64[Sp + 88];
           _sbcb5::P64 = P64[R1 + 7];
           _sbcb6::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbcb6::P64;
           P64[Sp + 88] = _sbcb5::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCv_srtd" {
     ubdCv_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdB7() //  [R1]
         { info_tbl: [(cbdB7,
                       label: block_cbdB7_info
                       rep:StackRep [False, False, True, False, True, True, False, False,
                                     False, False, False, False, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdB7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdBi; else goto cbdBh;
       cbdBi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdBh: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 104];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cbdBa_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 88];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 96];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCw_srtd" {
     ubdCw_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdBa() //  [R1]
         { info_tbl: [(cbdBa,
                       label: block_cbdBa_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdBa: // global
           I64[Sp] = block_cbdBc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubdC8; else goto cbdBk;
       ubdC8: // global
           call _cbdBc(R1) args: 0, res: 0, upd: 0;
       cbdBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCx_srtd" {
     ubdCx_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdBc() //  [R1]
         { info_tbl: [(cbdBc,
                       label: block_cbdBc_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdBc: // global
           _sbc9u::P64 = P64[Sp + 48];
           _sbcbi::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbc9u::P64 + 8] = _sbcbi::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc9u::P64);
           Sp = Sp + 8;
           call _sbc9S() args: 0, res: 0, upd: 0;
     }
 },
 _sbc9S() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbc9S: // global
           _sbc9W::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 8] = block_cbdzq_info;
           R1 = _sbc9W::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdCa; else goto cbdzs;
       ubdCa: // global
           call _cbdzq(R1) args: 0, res: 0, upd: 0;
       cbdzs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdCy_srtd" {
     ubdCy_srtd:
         const SbcpG_srt+56;
         const 38;
         const 210990268417;
 },
 _cbdzq() //  [R1]
         { info_tbl: [(cbdzq,
                       label: block_cbdzq_info
                       rep:StackRep [True, True, False, False, False, False, True, True,
                                     True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdzq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdzy; else goto cbdzx;
       cbdzy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdzx: // global
           _sbc9j::I64 = I64[Sp + 96];
           _sbca2::I64 = I64[R1 + 39];
           _sbca3::I64 = I64[R1 + 47];
           if (_sbca2::I64 == _sbca3::I64) goto cbdAL; else goto cbdzN;
       cbdAL: // global
           if (%MO_S_Le_W64(_sbc9j::I64,
                            I64[R1 + 31])) goto cbdAq; else goto cbdAu;
       cbdAq: // global
           Hp = Hp - 16;
           P64[Sp + 72] = R1;
           Sp = Sp + 24;
           call _sbca8() args: 0, res: 0, upd: 0;
       cbdAu: // global
           Hp = Hp - 16;
           I64[Sp] = block_cbdAt_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 40];
           P64[Sp + 72] = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
       cbdzN: // global
           _sbc9g::P64 = P64[Sp + 88];
           _sbc9o::P64 = P64[Sp + 80];
           _sbca5::I64 = _sbca3::I64 - _sbca2::I64;
           if (%MO_S_Gt_W64(_sbc9j::I64,
                            _sbca5::I64)) goto cbdzK; else goto cbdzL;
       cbdzK: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbca5::I64;
           R6 = Hp - 7;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sbc9g::P64;
           R3 = R1;
           R2 = _sbc9o::P64;
           Sp = Sp + 112;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cbdzL: // global
           Hp = Hp - 16;
           R6 = P64[Sp + 104];
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sbc9g::P64;
           R3 = R1;
           R2 = _sbc9o::P64;
           Sp = Sp + 112;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbdAt() //  [R1]
         { info_tbl: [(cbdAt,
                       label: block_cbdAt_info
                       rep:StackRep [True, True, False, False, True, False, True, True,
                                     False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdAt: // global
           if (R1 & 7 == 1) goto ubdBR; else goto cbdAF;
       ubdBR: // global
           Sp = Sp + 24;
           call _sbca8() args: 0, res: 0, upd: 0;
       cbdAF: // global
           I64[Sp] = block_cbdAD_info;
           R1 = P64[Sp + 88];
           if (R1 & 7 != 0) goto ubdC6; else goto cbdAG;
       ubdC6: // global
           call _cbdAD(R1) args: 0, res: 0, upd: 0;
       cbdAG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _sbca8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbca8: // global
           I64[Sp + 16] = block_cbdzU_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp + 8] = P64[Sp + 48];
           Sp = Sp - 8;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbdzU() //  [R1]
         { info_tbl: [(cbdzU,
                       label: block_cbdzU_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdzU: // global
           I64[Sp] = block_cbdzW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubdC4; else goto cbdzX;
       ubdC4: // global
           call _cbdzW(R1) args: 0, res: 0, upd: 0;
       cbdzX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdzW() //  [R1]
         { info_tbl: [(cbdzW,
                       label: block_cbdzW_info
                       rep:StackRep [False, True, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdzW: // global
           I64[Sp] = block_cbdA1_info;
           _sbcaf::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 32] = _sbcaf::P64;
           if (R1 & 7 != 0) goto ubdC5; else goto cbdA5;
       ubdC5: // global
           call _cbdA1(R1) args: 0, res: 0, upd: 0;
       cbdA5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdA1() //  [R1]
         { info_tbl: [(cbdA1,
                       label: block_cbdA1_info
                       rep:StackRep [False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdA1: // global
           _sbcai::I64 = I64[R1 + 7];
           if (_sbcai::I64 == 0) goto cbdAm; else goto cbdAl;
       cbdAm: // global
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbdAl: // global
           _sbc9g::P64 = P64[Sp + 48];
           _sbc9j::I64 = I64[Sp + 56];
           _sbc9l::P64 = P64[Sp + 64];
           _sbc9o::P64 = P64[Sp + 40];
           _sbc9u::P64 = P64[Sp + 8];
           _sbcaf::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbc9u::P64 + 8] = _sbcaf::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbc9u::P64);
           if (%MO_S_Gt_W64(_sbcai::I64,
                            _sbc9j::I64)) goto cbdAi; else goto cbdAj;
       cbdAi: // global
           R6 = _sbc9l::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sbc9g::P64;
           R3 = _sbcaf::P64;
           R2 = _sbc9o::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
       cbdAj: // global
           R6 = R1;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sbc9g::P64;
           R3 = _sbcaf::P64;
           R2 = _sbc9o::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBufNonBlocking2_entry(R6,
                                                             R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbdAD() //  [R1]
         { info_tbl: [(cbdAD,
                       label: block_cbdAD_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdAD: // global
           R6 = 0;
           R5 = I64[R1 + 7];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp + 104] = I64[Sp + 96];
           Sp = Sp + 104;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubdCz_srtd" {
     ubdCz_srtd:
         const SbcpG_srt+8;
         const 46;
         const 66279935313985;
 },
 GHC.IO.Handle.Text.$whGetBufSome_entry() //  [R2, R3, R4]
         { info_tbl: [(cbdCe,
                       label: GHC.IO.Handle.Text.$whGetBufSome_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdCe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbdCi; else goto cbdCh;
       cbdCi: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBufSome_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdCh: // global
           if (R4 == 0) goto cbdCd; else goto cbdCc;
       cbdCd: // global
           Hp = Hp - 48;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbdCc: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cbdCk; else goto cbdCl;
       cbdCk: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = R4;
           I64[Hp - 24] = sat_sbcbm_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = Hp - 39;
           I64[Hp] = R4;
           R4 = Hp - 22;
           R3 = R2;
           R2 = lvl13_rb6WT_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cbdCl: // global
           Hp = Hp - 48;
           R4 = R4;
           R3 = lvl13_rb6WT_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.223678168 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufSome1_closure" {
     GHC.IO.Handle.Text.hGetBufSome1_closure:
         const GHC.IO.Handle.Text.hGetBufSome1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufSome1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbdFo,
                       label: GHC.IO.Handle.Text.hGetBufSome1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdFo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdFp; else goto cbdFq;
       cbdFp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBufSome1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdFq: // global
           I64[Sp - 24] = block_cbdFl_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdFu; else goto cbdFm;
       ubdFu: // global
           call _cbdFl(R1) args: 0, res: 0, upd: 0;
       cbdFm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdFl() //  [R1]
         { info_tbl: [(cbdFl,
                       label: block_cbdFl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdFl: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBufSome_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.229438526 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBufSome_closure" {
     GHC.IO.Handle.Text.hGetBufSome_closure:
         const GHC.IO.Handle.Text.hGetBufSome_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBufSome_entry() //  [R2, R3, R4]
         { info_tbl: [(cbdFJ,
                       label: GHC.IO.Handle.Text.hGetBufSome_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdFJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBufSome1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.236989809 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf4_closure" {
     GHC.IO.Handle.Text.hGetBuf4_closure:
         const GHC.IO.Handle.Text.hGetBuf4_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbdFX,
                       label: GHC.IO.Handle.Text.hGetBuf4_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdFX: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbdGb; else goto cbdGc;
       cbdGb: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdGc: // global
           I64[Sp - 40] = block_cbdFU_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubdHH; else goto cbdFV;
       ubdHH: // global
           call _cbdFU(R1) args: 0, res: 0, upd: 0;
       cbdFV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdFU() //  [R1]
         { info_tbl: [(cbdFU,
                       label: block_cbdFU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdFU: // global
           I64[Sp - 8] = block_cbdG0_info;
           _sbcbz::P64 = R1;
           _sbcbF::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbcbF::P64;
           P64[Sp + 8] = _sbcbz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdHG; else goto cbdG1;
       ubdHG: // global
           call _cbdG0(R1) args: 0, res: 0, upd: 0;
       cbdG1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdG0() //  [R1]
         { info_tbl: [(cbdG0,
                       label: block_cbdG0_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdG0: // global
           I64[Sp - 40] = block_cbdG5_info;
           _sbcbS::P64 = P64[R1 + 7];
           _sbcbT::P64 = P64[R1 + 15];
           _sbcbR::I64 = I64[R1 + 23];
           _sbcbU::I64 = I64[R1 + 31];
           _sbcbV::I64 = I64[R1 + 39];
           _sbcbW::I64 = I64[R1 + 47];
           R1 = P64[Sp + 32];
           P64[Sp - 32] = _sbcbT::P64;
           I64[Sp - 24] = _sbcbU::I64;
           I64[Sp - 16] = _sbcbV::I64;
           I64[Sp - 8] = _sbcbW::I64;
           P64[Sp] = _sbcbS::P64;
           I64[Sp + 32] = _sbcbR::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubdHI; else goto cbdG6;
       ubdHI: // global
           call _cbdG5(R1) args: 0, res: 0, upd: 0;
       cbdG6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdG5() //  [R1]
         { info_tbl: [(cbdG5,
                       label: block_cbdG5_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdG5: // global
           I64[Sp] = block_cbdGa_info;
           _sbcbY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 80];
           I64[Sp + 80] = _sbcbY::I64;
           if (R1 & 7 != 0) goto ubdHJ; else goto cbdGg;
       ubdHJ: // global
           call _cbdGa(R1) args: 0, res: 0, upd: 0;
       cbdGg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdGa() //  [R1]
         { info_tbl: [(cbdGa,
                       label: block_cbdGa_info
                       rep:StackRep [False, True, True, True, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdGa: // global
           _sbcbv::P64 = P64[Sp + 64];
           _sbcc0::I64 = I64[R1 + 7];
           _sbcc1::I64 = I64[Sp + 32] - I64[Sp + 24];
           if (%MO_S_Ge_W64(_sbcc0::I64,
                            _sbcc1::I64)) goto cbdGt; else goto cbdHC;
       cbdGt: // global
           I64[Sp] = block_cbdGr_info;
           R1 = _sbcbv::P64;
           I64[Sp + 32] = _sbcc1::I64;
           I64[Sp + 64] = _sbcc0::I64;
           if (R1 & 7 != 0) goto ubdHK; else goto cbdGu;
       ubdHK: // global
           call _cbdGr(R1) args: 0, res: 0, upd: 0;
       cbdGu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbdHC: // global
           I64[Sp] = block_cbdHb_info;
           R1 = _sbcbv::P64;
           I64[Sp + 64] = _sbcc0::I64;
           if (R1 & 7 != 0) goto ubdHL; else goto cbdHc;
       ubdHL: // global
           call _cbdHb(R1) args: 0, res: 0, upd: 0;
       cbdHc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdGr() //  [R1]
         { info_tbl: [(cbdGr,
                       label: block_cbdGr_info
                       rep:StackRep [False, True, True, True, False, False, False, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdGr: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbdGA; else goto cbdGz;
       cbdGA: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdGz: // global
           _sbcbz::P64 = P64[Sp + 56];
           _sbcbF::P64 = P64[Sp + 48];
           _sbcbR::I64 = I64[Sp + 72];
           _sbcbS::P64 = P64[Sp + 40];
           _sbcbT::P64 = P64[Sp + 8];
           _sbcbU::I64 = I64[Sp + 16];
           _sbcbY::I64 = I64[Sp + 80];
           _sbcc0::I64 = I64[Sp + 64];
           _sbcc1::I64 = I64[Sp + 32];
           _sbcc4::I64 = I64[R1 + 7];
           (_sbcca::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sbcc4::I64, _sbcbR::I64 + I64[Sp + 24], _sbcc1::I64);
           call MO_Touch(_sbcbS::P64);
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = _sbcbS::P64;
           P64[Hp - 80] = _sbcbT::P64;
           I64[Hp - 72] = _sbcbR::I64;
           I64[Hp - 64] = _sbcbU::I64;
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           call MO_WriteBarrier();
           _cbdGM::P64 = Hp - 95;
           P64[_sbcbF::P64 + 8] = _cbdGM::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcbF::P64);
           _sbcce::I64 = _sbcc0::I64 - _sbcc1::I64;
           if (_sbcce::I64 != 0) goto cbdH3; else goto cbdH9;
       cbdH3: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sbcce::I64;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _sbcbY::I64 + _sbcc1::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbcc4::I64 + _sbcc1::I64;
           R6 = Hp - 39;
           R5 = Hp - 23;
           R4 = Hp - 7;
           R3 = _cbdGM::P64;
           R2 = _sbcbz::P64;
           Sp = Sp + 88;
           call GHC.IO.Handle.Text.hGetBuf2_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cbdH9: // global
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _sbcbY::I64 + _sbcc1::I64;
           _cbdH8::P64 = Hp - 39;
           Hp = Hp - 32;
           R1 = _cbdH8::P64;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbdHb() //  [R1]
         { info_tbl: [(cbdHb,
                       label: block_cbdHb_info
                       rep:StackRep [False, True, True, True, False, False, True, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdHb: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbdHF; else goto cbdHE;
       cbdHF: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdHE: // global
           _sbcbF::P64 = P64[Sp + 48];
           _sbcbR::I64 = I64[Sp + 72];
           _sbcbS::P64 = P64[Sp + 40];
           _sbcbT::P64 = P64[Sp + 8];
           _sbcbU::I64 = I64[Sp + 16];
           _sbcbV::I64 = I64[Sp + 24];
           _sbcbW::I64 = I64[Sp + 32];
           _sbcbY::I64 = I64[Sp + 80];
           _sbcc0::I64 = I64[Sp + 64];
           (_sbcct::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[R1 + 7], _sbcbR::I64 + _sbcbV::I64, _sbcc0::I64);
           call MO_Touch(_sbcbS::P64);
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = _sbcbS::P64;
           P64[Hp - 48] = _sbcbT::P64;
           I64[Hp - 40] = _sbcbR::I64;
           I64[Hp - 32] = _sbcbU::I64;
           I64[Hp - 24] = _sbcbV::I64 + _sbcc0::I64;
           I64[Hp - 16] = _sbcbW::I64;
           call MO_WriteBarrier();
           P64[_sbcbF::P64 + 8] = Hp - 63;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcbF::P64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbcbY::I64 + _sbcc0::I64;
           R1 = Hp - 7;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.IO.Handle.Text.hGetBuf2_closure" {
     GHC.IO.Handle.Text.hGetBuf2_closure:
         const GHC.IO.Handle.Text.hGetBuf2_info;
         const 0;
 },
 sat_sbcdq_entry() //  [R1]
         { info_tbl: [(cbdJd,
                       label: sat_sbcdq_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbdJk; else goto cbdJl;
       cbdJk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdJl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbdJa_info;
           _sbcdl::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbcdl::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdJp; else goto cbdJb;
       ubdJp: // global
           call _cbdJa(R1) args: 0, res: 0, upd: 0;
       cbdJb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdJa() //  [R1]
         { info_tbl: [(cbdJa,
                       label: block_cbdJa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdJo; else goto cbdJn;
       cbdJo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdJn: // global
           _sbcdp::I64 = I64[R1 + 7] + I64[Sp + 8];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbcdp::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbcdu_entry() //  [R1]
         { info_tbl: [(cbdJx,
                       label: sat_sbcdu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbdJy; else goto cbdJz;
       cbdJy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdJz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.$fNumInt_$c+_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubdL0_srtd" {
     ubdL0_srtd:
         const SbcpG_srt+56;
         const 43;
         const 6807523164161;
 },
 GHC.IO.Handle.Text.hGetBuf2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbdJA,
                       label: GHC.IO.Handle.Text.hGetBuf2_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJA: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cbdJB; else goto cbdJC;
       cbdJB: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf2_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdJC: // global
           I64[Sp - 40] = block_cbdHQ_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubdKX; else goto cbdHR;
       ubdKX: // global
           call _cbdHQ(R1) args: 0, res: 0, upd: 0;
       cbdHR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdL1_srtd" {
     ubdL1_srtd:
         const SbcpG_srt+56;
         const 43;
         const 4608499908609;
 },
 _cbdHQ() //  [R1]
         { info_tbl: [(cbdHQ,
                       label: block_cbdHQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdHQ: // global
           I64[Sp - 32] = block_cbdHV_info;
           _sbccG::P64 = R1;
           _sbccI::P64 = P64[R1 + 15];
           _sbccJ::P64 = P64[R1 + 23];
           _sbccK::P64 = P64[R1 + 31];
           _sbccM::P64 = P64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _sbccJ::P64;
           P64[Sp - 16] = _sbccK::P64;
           P64[Sp - 8] = _sbccM::P64;
           P64[Sp] = _sbccI::P64;
           P64[Sp + 8] = _sbccG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdKJ; else goto cbdHW;
       ubdKJ: // global
           call _cbdHV(R1) args: 0, res: 0, upd: 0;
       cbdHW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdL2_srtd" {
     ubdL2_srtd:
         const SbcpG_srt+56;
         const 43;
         const 4608499908609;
 },
 _cbdHV() //  [R1]
         { info_tbl: [(cbdHV,
                       label: block_cbdHV_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdHV: // global
           I64[Sp - 8] = block_cbdI0_info;
           _sbccX::P64 = R1;
           _sbcd1::I64 = I64[R1 + 31];
           R1 = P64[Sp + 64];
           I64[Sp] = _sbcd1::I64;
           P64[Sp + 64] = _sbccX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdKK; else goto cbdI1;
       ubdKK: // global
           call _cbdI0(R1) args: 0, res: 0, upd: 0;
       cbdI1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdL3_srtd" {
     ubdL3_srtd:
         const SbcpG_srt+56;
         const 43;
         const 4608499908609;
 },
 _cbdI0() //  [R1]
         { info_tbl: [(cbdI0,
                       label: block_cbdI0_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdI0: // global
           _sbcd5::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sbcd5::I64,
                            I64[Sp + 8])) goto ubdKB; else goto cbdK5;
       ubdKB: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _sbcd6() args: 0, res: 0, upd: 0;
       cbdK5: // global
           I64[Sp] = block_cbdIb_info;
           R3 = lvl11_rb6WR_closure;
           R2 = P64[Sp + 16];
           I64[Sp + 8] = _sbcd5::I64;
           P64[Sp + 16] = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbdIb() //  [R1]
         { info_tbl: [(cbdIb,
                       label: block_cbdIb_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdIb: // global
           if (R1 & 7 == 1) goto ubdKC; else goto cbdKv;
       ubdKC: // global
           Sp = Sp + 16;
           call _sbcd6() args: 0, res: 0, upd: 0;
       cbdKv: // global
           I64[Sp + 40] = I64[Sp + 8];
           P64[Sp + 48] = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           P64[Sp + 72] = P64[Sp + 24];
           Sp = Sp + 40;
           call _cbdIm() args: 0, res: 0, upd: 0;
     }
 },
 _sbcd6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbcd6: // global
           I64[Sp - 8] = block_cbdJJ_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 8];
           P64[Sp - 16] = P64[Sp + 56];
           Sp = Sp - 32;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbdJJ() //  [R1]
         { info_tbl: [(cbdJJ,
                       label: block_cbdJJ_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJJ: // global
           I64[Sp] = block_cbdJL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubdKY; else goto cbdJM;
       ubdKY: // global
           call _cbdJL(R1) args: 0, res: 0, upd: 0;
       cbdJM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdJL() //  [R1]
         { info_tbl: [(cbdJL,
                       label: block_cbdJL_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJL: // global
           I64[Sp] = block_cbdJQ_info;
           _sbcdd::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 64] = _sbcdd::P64;
           if (R1 & 7 != 0) goto ubdKZ; else goto cbdJU;
       ubdKZ: // global
           call _cbdJQ(R1) args: 0, res: 0, upd: 0;
       cbdJU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdJQ() //  [R1]
         { info_tbl: [(cbdJQ,
                       label: block_cbdJQ_info
                       rep:StackRep [False, True, False, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJQ: // global
           _sbccD::P64 = P64[Sp + 56];
           if (I64[R1 + 7] == 0) goto cbdK2; else goto cbdK1;
       cbdK2: // global
           R1 = _sbccD::P64;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbdK1: // global
           _sbccC::P64 = P64[Sp + 48];
           _sbccG::P64 = P64[Sp + 40];
           _sbccM::P64 = P64[Sp + 24];
           _sbcd4::P64 = P64[Sp + 8];
           _sbcdd::P64 = P64[Sp + 64];
           call MO_WriteBarrier();
           P64[_sbccM::P64 + 8] = _sbcdd::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbccM::P64);
           R6 = _sbcd4::P64;
           R5 = _sbccD::P64;
           R4 = _sbccC::P64;
           R3 = _sbcdd::P64;
           R2 = _sbccG::P64;
           Sp = Sp + 72;
           call GHC.IO.Handle.Text.hGetBuf4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbdIm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdIm: // global
           if (%MO_S_Gt_W64(I64[Sp], 0)) goto cbdKj; else goto cbdKu;
       cbdKj: // global
           I64[Sp - 8] = block_cbdIs_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdKO; else goto cbdIt;
       ubdKO: // global
           call _cbdIs(R1) args: 0, res: 0, upd: 0;
       cbdIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbdKu: // global
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 24;
           call _cbdJr() args: 0, res: 0, upd: 0;
     }
 },
 _cbdIs() //  [R1]
         { info_tbl: [(cbdIs,
                       label: block_cbdIs_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdIs: // global
           I64[Sp] = block_cbdIx_info;
           _sbcdC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sbcdC::I64;
           if (R1 & 7 != 0) goto ubdKQ; else goto cbdIy;
       ubdKQ: // global
           call _cbdIx(R1) args: 0, res: 0, upd: 0;
       cbdIy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdIx() //  [R1]
         { info_tbl: [(cbdIx,
                       label: block_cbdIx_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdIx: // global
           I64[Sp] = block_cbdIC_info;
           _sbcdE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sbcdE::I64;
           if (R1 & 7 != 0) goto ubdKR; else goto cbdID;
       ubdKR: // global
           call _cbdIC(R1) args: 0, res: 0, upd: 0;
       cbdID: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdIC() //  [R1]
         { info_tbl: [(cbdIC,
                       label: block_cbdIC_info
                       rep:StackRep [True, True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdIC: // global
           _sbcdI::I64 = I64[Sp + 16] + I64[Sp + 40];
           I64[Sp] = block_cbdIN_info;
           R6 = 0;
           R5 = _sbcdI::I64;
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = GHC.IO.FD.$fBufferedIOFD12_closure;
           I64[Sp - 8] = I64[Sp + 8];
           P64[Sp + 16] = R1;
           Sp = Sp - 8;
           call GHC.IO.FD.$wreadRawBufferPtr_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbdIN() //  [R1]
         { info_tbl: [(cbdIN,
                       label: block_cbdIN_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdIN: // global
           I64[Sp] = block_cbdIP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubdKS; else goto cbdIQ;
       ubdKS: // global
           call _cbdIP(R1) args: 0, res: 0, upd: 0;
       cbdIQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdIP() //  [R1]
         { info_tbl: [(cbdIP,
                       label: block_cbdIP_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdIP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdKq; else goto cbdKp;
       cbdKq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdKp: // global
           _sbcdE::I64 = I64[Sp + 40];
           _sbcdP::I64 = I64[R1 + 7];
           if (_sbcdP::I64 != 0) goto cbdKs; else goto cbdKt;
       cbdKs: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbcdE::I64 + _sbcdP::I64;
           P64[Sp + 40] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 7;
           I64[Sp + 8] = I64[Sp + 8] - _sbcdP::I64;
           Sp = Sp + 8;
           call _cbdIm() args: 0, res: 0, upd: 0;
       cbdKt: // global
           Hp = Hp - 16;
           I64[Sp + 40] = _sbcdE::I64;
           Sp = Sp + 32;
           call _cbdJ4() args: 0, res: 0, upd: 0;
     }
 },
 _cbdJ4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJ4: // global
           Hp = Hp + 32;
           _sbcdl::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cbdKd; else goto cbdKc;
       cbdKd: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cbdJ3_info;
           R1 = _sbcdl::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbdKc: // global
           I64[Hp - 24] = sat_sbcdq_info;
           P64[Hp - 8] = P64[Sp];
           I64[Hp] = _sbcdl::I64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbdJ3() //  [R1]
         { info_tbl: [(cbdJ3,
                       label: block_cbdJ3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJ3: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cbdJ4() args: 0, res: 0, upd: 0;
     }
 },
 _cbdJr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJr: // global
           Hp = Hp + 32;
           _sbcds::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cbdKg; else goto cbdKf;
       cbdKg: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_cbdJq_info;
           R1 = _sbcds::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdKf: // global
           I64[Hp - 24] = sat_sbcdu_info;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = _sbcds::P64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbdJq() //  [R1]
         { info_tbl: [(cbdJq,
                       label: block_cbdJq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdJq: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cbdJr() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.297814796 UTC

[section ""cstring" . GHC.IO.Handle.Text.hGetBuf6_bytes" {
     GHC.IO.Handle.Text.hGetBuf6_bytes:
         I8[] [104,71,101,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.299771353 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf5_closure" {
     GHC.IO.Handle.Text.hGetBuf5_closure:
         const GHC.IO.Handle.Text.hGetBuf5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf5_entry() //  [R1]
         { info_tbl: [(cbdOf,
                       label: GHC.IO.Handle.Text.hGetBuf5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdOf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbdOg; else goto cbdOh;
       cbdOg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdOh: // global
           (_cbdOc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdOc::I64 == 0) goto cbdOe; else goto cbdOd;
       cbdOe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdOd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdOc::I64;
           R2 = GHC.IO.Handle.Text.hGetBuf6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.307368422 UTC

[section ""data" . GHC.IO.Handle.Text.$whGetBuf_closure" {
     GHC.IO.Handle.Text.$whGetBuf_closure:
         const GHC.IO.Handle.Text.$whGetBuf_info;
         const 0;
 },
 sat_sbceY_entry() //  [R1]
         { info_tbl: [(cbdPb,
                       label: sat_sbceY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdPb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdPf; else goto cbdPg;
       cbdPf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdPg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbdP8_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdPk; else goto cbdP9;
       ubdPk: // global
           call _cbdP8(R1) args: 0, res: 0, upd: 0;
       cbdP9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdP8() //  [R1]
         { info_tbl: [(cbdP8,
                       label: block_cbdP8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdP8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdPj; else goto cbdPi;
       cbdPj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdPi: // global
           _sbceT::P64 = P64[R1 + 7];
           _sbceU::P64 = P64[R1 + 15];
           _sbceS::I64 = I64[R1 + 23];
           _sbceV::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbceT::P64;
           P64[Hp - 32] = _sbceU::P64;
           I64[Hp - 24] = _sbceS::I64;
           I64[Hp - 16] = _sbceV::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbcfh_entry() //  [R1]
         { info_tbl: [(cbdPH,
                       label: sat_sbcfh_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdPH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbdPO; else goto cbdPP;
       cbdPO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdPP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbdPE_info;
           _sbcf7::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbcf7::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubdPT; else goto cbdPF;
       ubdPT: // global
           call _cbdPE(R1) args: 0, res: 0, upd: 0;
       cbdPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbdPE() //  [R1]
         { info_tbl: [(cbdPE,
                       label: block_cbdPE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdPE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdPS; else goto cbdPR;
       cbdPS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbdPR: // global
           _sbcfb::P64 = P64[R1 + 7];
           _sbcfc::P64 = P64[R1 + 15];
           _sbcfa::I64 = I64[R1 + 23];
           _sbcfd::I64 = I64[R1 + 31];
           _sbcff::I64 = I64[R1 + 47];
           _sbcfg::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbcfb::P64;
           P64[Hp - 32] = _sbcfc::P64;
           I64[Hp - 24] = _sbcfa::I64;
           I64[Hp - 16] = _sbcfd::I64;
           I64[Hp - 8] = _sbcfg::I64;
           I64[Hp] = _sbcff::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbcfC_entry() //  [R1, R2]
         { info_tbl: [(cbdPU,
                       label: sat_sbcfC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdPU: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cbdPV; else goto cbdPW;
       cbdPV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbdPW: // global
           I64[Sp - 24] = block_cbdOF_info;
           _sbcdU::P64 = P64[R1 + 6];
           _sbcdZ::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbcdU::P64;
           P64[Sp - 8] = _sbcdZ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdRq; else goto cbdOG;
       ubdRq: // global
           call _cbdOF(R1) args: 0, res: 0, upd: 0;
       cbdOG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdOF() //  [R1]
         { info_tbl: [(cbdOF,
                       label: block_cbdOF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdOF: // global
           I64[Sp - 40] = block_cbdOK_info;
           _sbce2::P64 = R1;
           _sbce8::P64 = P64[R1 + 47];
           _sbcea::P64 = P64[R1 + 63];
           _sbceb::P64 = P64[R1 + 71];
           _sbcee::P64 = P64[R1 + 95];
           R1 = P64[_sbceb::P64 + 8];
           P64[Sp - 32] = _sbce8::P64;
           P64[Sp - 24] = _sbcea::P64;
           P64[Sp - 16] = _sbceb::P64;
           P64[Sp - 8] = _sbcee::P64;
           P64[Sp] = _sbce2::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubdRg; else goto cbdOL;
       ubdRg: // global
           call _cbdOK(R1) args: 0, res: 0, upd: 0;
       cbdOL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdOK() //  [R1]
         { info_tbl: [(cbdOK,
                       label: block_cbdOK_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdOK: // global
           I64[Sp - 16] = block_cbdOR_info;
           _sbcer::I64 = I64[R1 + 39];
           _sbces::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbces::I64;
           I64[Sp] = _sbcer::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubdRh; else goto cbdOS;
       ubdRh: // global
           call _cbdOR(R1) args: 0, res: 0, upd: 0;
       cbdOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdOR() //  [R1]
         { info_tbl: [(cbdOR,
                       label: block_cbdOR_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdOR: // global
           if (R1 & 7 == 1) goto cbdQU; else goto ubdRb;
       cbdQU: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubdRc; else goto cbdQg;
       ubdRc: // global
           Sp = Sp + 24;
           goto ubdRk;
       cbdQg: // global
           _sbceK::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cbdOZ_info;
           R1 = _sbceK::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubdRi; else goto cbdP0;
       ubdRi: // global
           call _cbdOZ(R1) args: 0, res: 0, upd: 0;
       cbdP0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubdRb: // global
           Sp = Sp + 24;
           goto ubdRk;
       ubdRk: // global
           call _sbcet() args: 0, res: 0, upd: 0;
     }
 },
 _cbdOZ() //  [R1]
         { info_tbl: [(cbdOZ,
                       label: block_cbdOZ_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdOZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbdQj; else goto cbdQi;
       cbdQj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdQi: // global
           _sbceb::P64 = P64[Sp + 24];
           _sbceM::P64 = P64[R1 + 7];
           _sbceN::P64 = P64[R1 + 15];
           _sbceQ::P64 = P64[_sbceb::P64 + 8];
           I64[Hp - 16] = sat_sbceY_info;
           P64[Hp] = _sbceQ::P64;
           call MO_WriteBarrier();
           P64[_sbceb::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbceb::P64);
           I64[Sp] = block_cbdPo_info;
           R1 = _sbceQ::P64;
           P64[Sp + 16] = _sbceN::P64;
           P64[Sp + 24] = _sbceM::P64;
           if (R1 & 7 != 0) goto ubdRl; else goto cbdPp;
       ubdRl: // global
           call _cbdPo(R1) args: 0, res: 0, upd: 0;
       cbdPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdPo() //  [R1]
         { info_tbl: [(cbdPo,
                       label: block_cbdPo_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdPo: // global
           _sbcf7::I64 = I64[R1 + 39];
           if (_sbcf7::I64 != 0) goto cbdQm; else goto cbdQR;
       cbdQm: // global
           I64[Sp - 24] = block_cbdPv_info;
           _sbcf2::P64 = P64[R1 + 7];
           _sbcf3::P64 = P64[R1 + 15];
           _sbcf1::I64 = I64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 16] = _sbcf3::P64;
           I64[Sp - 8] = _sbcf7::I64;
           P64[Sp] = _sbcf2::P64;
           I64[Sp + 32] = _sbcf1::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdRm; else goto cbdPw;
       ubdRm: // global
           call _cbdPv(R1) args: 0, res: 0, upd: 0;
       cbdPw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbdQR: // global
           _sbce8::P64 = P64[Sp + 8];
           _sbceN::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbce8::P64 + 8] = _sbceN::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbce8::P64);
           Sp = Sp + 8;
           call _sbcet() args: 0, res: 0, upd: 0;
     }
 },
 _cbdPv() //  [R1]
         { info_tbl: [(cbdPv,
                       label: block_cbdPv_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdPv: // global
           if (R1 & 7 == 1) goto cbdQo; else goto cbdQG;
       cbdQo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbdQr; else goto cbdQq;
       cbdQr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdQq: // global
           I64[Hp - 24] = sat_sbcfh_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 16];
           _sbce8::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbce8::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbce8::P64);
           Sp = Sp + 32;
           call _sbcet() args: 0, res: 0, upd: 0;
       cbdQG: // global
           I64[Sp] = block_cbdQu_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubdRo; else goto cbdQv;
       ubdRo: // global
           call _cbdQu(R1) args: 0, res: 0, upd: 0;
       cbdQv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdQu() //  [R1]
         { info_tbl: [(cbdQu,
                       label: block_cbdQu_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdQu: // global
           I64[Sp - 8] = block_cbdQz_info;
           R2 = P64[Sp + 48];
           _sbcfl::P64 = P64[R1 + 7];
           _sbcfm::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbcfm::P64;
           P64[Sp + 48] = _sbcfl::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdQz() //  [R1]
         { info_tbl: [(cbdQz,
                       label: block_cbdQz_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdQz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdQK; else goto cbdQJ;
       cbdQK: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdQJ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           I64[Sp + 32] = block_cbdQC_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbdQC() //  [R1]
         { info_tbl: [(cbdQC,
                       label: block_cbdQC_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdQC: // global
           I64[Sp] = block_cbdQE_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubdRr; else goto cbdQM;
       ubdRr: // global
           call _cbdQE(R1) args: 0, res: 0, upd: 0;
       cbdQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdQE() //  [R1]
         { info_tbl: [(cbdQE,
                       label: block_cbdQE_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdQE: // global
           _sbce8::P64 = P64[Sp + 8];
           _sbcfy::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbce8::P64 + 8] = _sbcfy::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbce8::P64);
           Sp = Sp + 8;
           call _sbcet() args: 0, res: 0, upd: 0;
     }
 },
 _sbcet() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbcet: // global
           _sbcex::P64 = P64[P64[Sp] + 8];
           I64[Sp + 24] = block_cbdQ2_info;
           R1 = _sbcex::P64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ubdRt; else goto cbdQ4;
       ubdRt: // global
           call _cbdQ2(R1) args: 0, res: 0, upd: 0;
       cbdQ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdQ2() //  [R1]
         { info_tbl: [(cbdQ2,
                       label: block_cbdQ2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdQ2: // global
           _sbcdU::P64 = P64[Sp + 16];
           _sbcdZ::P64 = P64[Sp + 24];
           _sbce2::P64 = P64[Sp + 8];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbdQd; else goto cbdQc;
       cbdQd: // global
           R6 = _sbcdZ::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sbcdU::P64;
           R3 = R1;
           R2 = _sbce2::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.hGetBuf2_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cbdQc: // global
           R6 = _sbcdZ::P64;
           R5 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           R4 = _sbcdU::P64;
           R3 = R1;
           R2 = _sbce2::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.hGetBuf4_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubdRF_srtd" {
     ubdRF_srtd:
         const SbcpG_srt+8;
         const 51;
         const 2111062325331969;
 },
 GHC.IO.Handle.Text.$whGetBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbdRx,
                       label: GHC.IO.Handle.Text.$whGetBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdRx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbdRB; else goto cbdRA;
       cbdRB: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.$whGetBuf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdRA: // global
           if (R4 == 0) goto cbdRw; else goto cbdRv;
       cbdRw: // global
           Hp = Hp - 40;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbdRv: // global
           if (%MO_S_Ge_W64(R4, 0)) goto cbdRD; else goto cbdRE;
       cbdRD: // global
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sbcfC_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 31;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hGetBuf5_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
       cbdRE: // global
           Hp = Hp - 40;
           R4 = R4;
           R3 = GHC.IO.Handle.Text.hGetBuf5_closure;
           R2 = R2;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.346560663 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf1_closure" {
     GHC.IO.Handle.Text.hGetBuf1_closure:
         const GHC.IO.Handle.Text.hGetBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbdTF,
                       label: GHC.IO.Handle.Text.hGetBuf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdTF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdTG; else goto cbdTH;
       cbdTG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hGetBuf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdTH: // global
           I64[Sp - 24] = block_cbdTC_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdTL; else goto cbdTD;
       ubdTL: // global
           call _cbdTC(R1) args: 0, res: 0, upd: 0;
       cbdTD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdTC() //  [R1]
         { info_tbl: [(cbdTC,
                       label: block_cbdTC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdTC: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whGetBuf_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.353044161 UTC

[section ""data" . GHC.IO.Handle.Text.hGetBuf_closure" {
     GHC.IO.Handle.Text.hGetBuf_closure:
         const GHC.IO.Handle.Text.hGetBuf_info;
         const 0;
 },
 GHC.IO.Handle.Text.hGetBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbdU0,
                       label: GHC.IO.Handle.Text.hGetBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdU0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hGetBuf1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.356283116 UTC

[section ""cstring" . lvl14_rb6WU_bytes" {
     lvl14_rb6WU_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.358483737 UTC

[section ""data" . lvl15_rb6WV_closure" {
     lvl15_rb6WV_closure:
         const lvl15_rb6WV_info;
         const 0;
         const 0;
         const 0;
 },
 lvl15_rb6WV_entry() //  [R1]
         { info_tbl: [(cbdUe,
                       label: lvl15_rb6WV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdUe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbdUf; else goto cbdUg;
       cbdUf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdUg: // global
           (_cbdUb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdUb::I64 == 0) goto cbdUd; else goto cbdUc;
       cbdUd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdUc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdUb::I64;
           R2 = lvl14_rb6WU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.362518179 UTC

[section ""data" . lvl16_rb6WW_closure" {
     lvl16_rb6WW_closure:
         const lvl16_rb6WW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_rb6WW_entry() //  [R1]
         { info_tbl: [(cbdUv,
                       label: lvl16_rb6WW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdUv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbdUw; else goto cbdUx;
       cbdUw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdUx: // global
           (_cbdUs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdUs::I64 == 0) goto cbdUu; else goto cbdUt;
       cbdUu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdUt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdUs::I64;
           R2 = GHC.IO.Handle.Text.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.366504172 UTC

[section ""data" . lvl17_rb6WX_closure" {
     lvl17_rb6WX_closure:
         const lvl17_rb6WX_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rb6WX_entry() //  [R1]
         { info_tbl: [(cbdUM,
                       label: lvl17_rb6WX_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdUM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbdUN; else goto cbdUO;
       cbdUN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdUO: // global
           (_cbdUJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdUJ::I64 == 0) goto cbdUL; else goto cbdUK;
       cbdUL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdUK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdUJ::I64;
           R2 = GHC.IO.Handle.Text.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.370609447 UTC

[section ""cstring" . lvl18_rb6WY_bytes" {
     lvl18_rb6WY_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,72,97,110,100,108,101,47,84,101,120,116,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.372506176 UTC

[section ""data" . lvl19_rb6WZ_closure" {
     lvl19_rb6WZ_closure:
         const lvl19_rb6WZ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rb6WZ_entry() //  [R1]
         { info_tbl: [(cbdV4,
                       label: lvl19_rb6WZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdV4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbdV5; else goto cbdV6;
       cbdV5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdV6: // global
           (_cbdV1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdV1::I64 == 0) goto cbdV3; else goto cbdV2;
       cbdV3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdV2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdV1::I64;
           R2 = lvl18_rb6WY_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.376220075 UTC

[section ""data" . lvl20_rb6X0_closure" {
     lvl20_rb6X0_closure:
         const GHC.Types.I#_con_info;
         const 785;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.377815272 UTC

[section ""data" . lvl21_rb6X1_closure" {
     lvl21_rb6X1_closure:
         const GHC.Types.I#_con_info;
         const 17;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.379445248 UTC

[section ""data" . lvl22_rb6X2_closure" {
     lvl22_rb6X2_closure:
         const GHC.Types.I#_con_info;
         const 38;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.382060999 UTC

[section ""data" . lvl23_rb6X3_closure" {
     lvl23_rb6X3_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl16_rb6WW_closure;
         const lvl17_rb6WX_closure;
         const lvl19_rb6WZ_closure;
         const lvl20_rb6X0_closure+1;
         const lvl21_rb6X1_closure+1;
         const lvl20_rb6X0_closure+1;
         const lvl22_rb6X2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.383887651 UTC

[section ""data" . lvl24_rb6X4_closure" {
     lvl24_rb6X4_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl15_rb6WV_closure;
         const lvl23_rb6X3_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.385634428 UTC

[section ""cstring" . lvl25_rb6X5_bytes" {
     lvl25_rb6X5_bytes:
         I8[] [84,111,100,111,58,32,104,80,117,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.387621995 UTC

[section ""data" . lvl26_rb6X6_closure" {
     lvl26_rb6X6_closure:
         const lvl26_rb6X6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_rb6X6_entry() //  [R1]
         { info_tbl: [(cbdVt,
                       label: lvl26_rb6X6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdVt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdVu; else goto cbdVv;
       cbdVu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdVv: // global
           (_cbdVo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdVo::I64 == 0) goto cbdVq; else goto cbdVp;
       cbdVq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdVp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdVo::I64;
           I64[Sp - 24] = block_cbdVr_info;
           R2 = lvl25_rb6X5_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbdVr() //  [R1]
         { info_tbl: [(cbdVr,
                       label: block_cbdVr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdVr: // global
           R3 = R1;
           R2 = lvl24_rb6X4_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.393077331 UTC

[section ""data" . lvl27_rb6X7_closure" {
     lvl27_rb6X7_closure:
         const GHC.Types.I#_con_info;
         const 790;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.395191842 UTC

[section ""data" . lvl28_rb6X8_closure" {
     lvl28_rb6X8_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl16_rb6WW_closure;
         const lvl17_rb6WX_closure;
         const lvl19_rb6WZ_closure;
         const lvl27_rb6X7_closure+1;
         const lvl21_rb6X1_closure+1;
         const lvl27_rb6X7_closure+1;
         const lvl22_rb6X2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.397036939 UTC

[section ""data" . lvl29_rb6X9_closure" {
     lvl29_rb6X9_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl15_rb6WV_closure;
         const lvl28_rb6X8_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.399079726 UTC

[section ""data" . lvl30_rb6Xa_closure" {
     lvl30_rb6Xa_closure:
         const lvl30_rb6Xa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_rb6Xa_entry() //  [R1]
         { info_tbl: [(cbdVW,
                       label: lvl30_rb6Xa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdVW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbdVX; else goto cbdVY;
       cbdVX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbdVY: // global
           (_cbdVR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbdVR::I64 == 0) goto cbdVT; else goto cbdVS;
       cbdVT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbdVS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbdVR::I64;
           I64[Sp - 24] = block_cbdVU_info;
           R2 = lvl25_rb6X5_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbdVU() //  [R1]
         { info_tbl: [(cbdVU,
                       label: block_cbdVU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdVU: // global
           R3 = R1;
           R2 = lvl29_rb6X9_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.407429253 UTC

[section ""data" . GHC.IO.Handle.Text.$wbufWrite_closure" {
     GHC.IO.Handle.Text.$wbufWrite_closure:
         const GHC.IO.Handle.Text.$wbufWrite_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wbufWrite_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdWf: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wbufWrite_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubdZg_srtd" {
     ubdZg_srtd:
         const SbcpG_srt+56;
         const 54;
         const 17451452851027969;
 },
 GHC.IO.Handle.Text.$wbufWrite_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbdWm,
                       label: GHC.IO.Handle.Text.$wbufWrite_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdWm: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cbdWu; else goto ubdZ2;
       cbdWu: // global
           R1 = GHC.IO.Handle.Text.$wbufWrite_closure;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ubdZ2: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _cbdWg() args: 0, res: 0, upd: 0;
     }
 },
 _cbdWg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdWg: // global
           _sbcfL::P64 = P64[Sp];
           I64[Sp] = block_cbdWj_info;
           R1 = _sbcfL::P64;
           if (R1 & 7 != 0) goto ubdZ6; else goto cbdWk;
       ubdZ6: // global
           call _cbdWj(R1) args: 0, res: 0, upd: 0;
       cbdWk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdZh_srtd" {
     ubdZh_srtd:
         const SbcpG_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbdWj() //  [R1]
         { info_tbl: [(cbdWj,
                       label: block_cbdWj_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdWj: // global
           I64[Sp - 32] = block_cbdWp_info;
           _sbcfQ::P64 = R1;
           _sbcfS::P64 = P64[R1 + 15];
           _sbcfT::P64 = P64[R1 + 23];
           _sbcfW::P64 = P64[R1 + 47];
           R1 = P64[R1 + 31];
           P64[Sp - 24] = _sbcfS::P64;
           P64[Sp - 16] = _sbcfT::P64;
           P64[Sp - 8] = _sbcfW::P64;
           P64[Sp] = _sbcfQ::P64;
           Sp = Sp - 32;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdZi_srtd" {
     ubdZi_srtd:
         const SbcpG_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbdWp() //  [R1]
         { info_tbl: [(cbdWp,
                       label: block_cbdWp_info
                       rep:StackRep [False, False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdWp: // global
           _sbcgc::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 24] = block_cbdWt_info;
           _sbcg7::P64 = R1;
           _sbcg8::I64 = I64[R1 + 7];
           _sbcg9::I64 = I64[R1 + 15];
           R1 = _sbcgc::P64;
           I64[Sp - 16] = _sbcg8::I64;
           I64[Sp - 8] = _sbcg9::I64;
           P64[Sp] = _sbcg7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubdZ8; else goto cbdWy;
       ubdZ8: // global
           call _cbdWt(R1) args: 0, res: 0, upd: 0;
       cbdWy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdZj_srtd" {
     ubdZj_srtd:
         const SbcpG_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbdWt() //  [R1]
         { info_tbl: [(cbdWt,
                       label: block_cbdWt_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdWt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbdWE; else goto cbdWD;
       cbdWE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdWD: // global
           _sbcgf::P64 = P64[R1 + 7];
           _sbcgg::P64 = P64[R1 + 15];
           _sbcge::I64 = I64[R1 + 23];
           _sbcgh::I64 = I64[R1 + 31];
           _sbcgi::I64 = I64[R1 + 39];
           _sbcgj::I64 = I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _sbcfN::I64 = I64[Sp + 72];
           I64[Hp] = _sbcfN::I64;
           _sbcfS::P64 = P64[Sp + 32];
           _sbcg7::P64 = P64[Sp + 24];
           _sbcgd::P64 = R1;
           _cbdWF::P64 = Hp - 7;
           if (%MO_S_Ge_W64(_sbcfN::I64,
                            _sbcgh::I64)) goto sbcgl; else goto cbdYL;
       cbdYL: // global
           if (%MO_S_Gt_W64(_sbcfN::I64,
                            _sbcgh::I64 - _sbcgj::I64)) goto sbcgl; else goto cbdYb;
       sbcgl: // global
           if (%MO_S_Le_W64(_sbcgj::I64, 0)) goto ubdZ3; else goto cbdXS;
       ubdZ3: // global
           I64[Sp + 32] = _sbcgh::I64;
           P64[Sp + 48] = _cbdWF::P64;
           Sp = Sp + 8;
           call _sbcgm() args: 0, res: 0, upd: 0;
       cbdXS: // global
           I64[Sp] = block_cbdXR_info;
           R2 = _sbcfS::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sbcg7::P64;
           P64[Sp - 8] = _sbcgd::P64;
           I64[Sp + 24] = _sbcgh::I64;
           P64[Sp + 32] = _cbdWF::P64;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cbdYb: // global
           I64[Sp - 8] = block_cbdYa_info;
           R1 = P64[Sp + 64];
           I64[Sp] = _sbcgj::I64;
           I64[Sp + 8] = _sbcgi::I64;
           I64[Sp + 16] = _sbcgh::I64;
           P64[Sp + 40] = _sbcgg::P64;
           P64[Sp + 56] = _sbcgf::P64;
           I64[Sp + 64] = _sbcge::I64;
           P64[Sp + 80] = _cbdWF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdZ9; else goto cbdYc;
       ubdZ9: // global
           call _cbdYa(R1) args: 0, res: 0, upd: 0;
       cbdYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubdZk_srtd" {
     ubdZk_srtd:
         const SbcpG_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbdXR() //  [R1]
         { info_tbl: [(cbdXR,
                       label: block_cbdXR_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdXR: // global
           _cbdWF::P64 = P64[Sp + 32];
           _sbcfW::P64 = P64[Sp + 48];
           _sbcgh::I64 = I64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sbcfW::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcfW::P64);
           P64[Sp + 48] = _cbdWF::P64;
           I64[Sp + 32] = _sbcgh::I64;
           Sp = Sp + 8;
           call _sbcgm() args: 0, res: 0, upd: 0;
     }
 },
 _sbcgm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbcgm: // global
           _sbcfN::I64 = I64[Sp + 64];
           _sbcfO::P64 = P64[Sp + 72];
           if (%MO_S_Ge_W64(_sbcfN::I64,
                            I64[Sp + 24])) goto cbdWX; else goto cbdXK;
       cbdWX: // global
           I64[Sp - 8] = block_cbdWV_info;
           R1 = _sbcfO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubdZe; else goto cbdWY;
       ubdZe: // global
           call _cbdWV(R1) args: 0, res: 0, upd: 0;
       cbdWY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbdXK: // global
           P64[Sp + 48] = P64[Sp + 48];
           P64[Sp + 56] = P64[Sp + 56];
           I64[Sp + 64] = _sbcfN::I64;
           P64[Sp + 72] = _sbcfO::P64;
           Sp = Sp + 48;
           call _cbdWg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubdZl_srtd" {
     ubdZl_srtd:
         const SbcpG_srt+56;
         const 54;
         const 15199653037342721;
 },
 _cbdWV() //  [R1]
         { info_tbl: [(cbdWV,
                       label: block_cbdWV_info
                       rep:StackRep [True, True, True, True, False, False, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdWV: // global
           _sbcfT::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbdX5; else goto cbdXq;
       cbdX5: // global
           I64[Sp] = block_cbdX2_info;
           R3 = lvl11_rb6WR_closure;
           R2 = _sbcfT::P64;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
       cbdXq: // global
           I64[Sp] = block_cbdXo_info;
           R3 = lvl11_rb6WR_closure;
           R2 = _sbcfT::P64;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbdX2() //  [R1]
         { info_tbl: [(cbdX2,
                       label: block_cbdX2_info
                       rep:StackRep [True, True, True, True, True, True, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdX2: // global
           if (R1 & 7 == 1) goto cbdXb; else goto cbdXg;
       cbdXb: // global
           R1 = lvl30_rb6Xa_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbdXg: // global
           I64[Sp] = block_cbdXe_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto ubdZb; else goto cbdXh;
       ubdZb: // global
           call _cbdXe(R1) args: 0, res: 0, upd: 0;
       cbdXh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdXe() //  [R1]
         { info_tbl: [(cbdXe,
                       label: block_cbdXe_info
                       rep:StackRep [True, True, True, True, True, True, True, True, True,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdXe: // global
           R5 = I64[Sp + 72];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 88;
           call GHC.IO.FD.$w$cwriteNonBlocking_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbdXo() //  [R1]
         { info_tbl: [(cbdXo,
                       label: block_cbdXo_info
                       rep:StackRep [True, True, True, True, True, False, True, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdXo: // global
           if (R1 & 7 == 1) goto cbdXw; else goto cbdXG;
       cbdXw: // global
           R1 = lvl26_rb6X6_closure;
           Sp = Sp + 88;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbdXG: // global
           I64[Sp] = block_cbdXz_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto ubdZc; else goto cbdXA;
       ubdZc: // global
           call _cbdXz(R1) args: 0, res: 0, upd: 0;
       cbdXA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbdXz() //  [R1]
         { info_tbl: [(cbdXz,
                       label: block_cbdXz_info
                       rep:StackRep [True, True, True, True, True, False, True, True,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdXz: // global
           I64[Sp + 40] = block_cbdXE_info;
           R5 = I64[Sp + 72];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 40;
           call GHC.IO.FD.$wfdWrite_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbdXE() //  []
         { info_tbl: [(cbdXE,
                       label: block_cbdXE_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdXE: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbdYa() //  [R1]
         { info_tbl: [(cbdYa,
                       label: block_cbdYa_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdYa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbdYi; else goto cbdYh;
       cbdYi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbdYh: // global
           _cbdWF::P64 = P64[Sp + 88];
           _sbcfN::I64 = I64[Sp + 80];
           _sbcfS::P64 = P64[Sp + 40];
           _sbcfW::P64 = P64[Sp + 56];
           _sbcge::I64 = I64[Sp + 72];
           _sbcgf::P64 = P64[Sp + 64];
           _sbcgg::P64 = P64[Sp + 48];
           _sbcgh::I64 = I64[Sp + 24];
           _sbcgi::I64 = I64[Sp + 16];
           _sbcgj::I64 = I64[Sp + 8];
           (_sbcgQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(_sbcge::I64 + _sbcgj::I64, I64[R1 + 7], _sbcfN::I64);
           call MO_Touch(_sbcgf::P64);
           if (_sbcfN::I64 == _sbcgh::I64 - _sbcgj::I64) goto cbdYI; else goto cbdYA;
       cbdYI: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbcgf::P64;
           P64[Hp - 32] = _sbcgg::P64;
           I64[Hp - 24] = _sbcge::I64;
           I64[Hp - 16] = _sbcgh::I64;
           I64[Hp - 8] = _sbcgi::I64;
           I64[Hp] = _sbcgj::I64 + _sbcfN::I64;
           I64[Sp + 48] = block_cbdYH_info;
           R2 = _sbcfS::P64;
           I64[Sp + 24] = stg_ap_ppv_info;
           P64[Sp + 40] = Hp - 47;
           Sp = Sp + 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
       cbdYA: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbcgf::P64;
           P64[Hp - 32] = _sbcgg::P64;
           I64[Hp - 24] = _sbcge::I64;
           I64[Hp - 16] = _sbcgh::I64;
           I64[Hp - 8] = _sbcgi::I64;
           I64[Hp] = _sbcgj::I64 + _sbcfN::I64;
           call MO_WriteBarrier();
           P64[_sbcfW::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcfW::P64);
           R1 = _cbdWF::P64;
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbdYH() //  [R1]
         { info_tbl: [(cbdYH,
                       label: block_cbdYH_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdYH: // global
           _cbdWF::P64 = P64[Sp + 40];
           _sbcfW::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbcfW::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcfW::P64);
           R1 = _cbdWF::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.444273692 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutBuf4_bytes" {
     GHC.IO.Handle.Text.hPutBuf4_bytes:
         I8[] [104,80,117,116,66,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.44621614 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf3_closure" {
     GHC.IO.Handle.Text.hPutBuf3_closure:
         const GHC.IO.Handle.Text.hPutBuf3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf3_entry() //  [R1]
         { info_tbl: [(cbe19,
                       label: GHC.IO.Handle.Text.hPutBuf3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe19: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbe1a; else goto cbe1b;
       cbe1a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbe1b: // global
           (_cbe16::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbe16::I64 == 0) goto cbe18; else goto cbe17;
       cbe18: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbe17: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbe16::I64;
           R2 = GHC.IO.Handle.Text.hPutBuf4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.451619471 UTC

[section ""data" . GHC.IO.Handle.Text.$whPutBuf'_closure" {
     GHC.IO.Handle.Text.$whPutBuf'_closure:
         const GHC.IO.Handle.Text.$whPutBuf'_info;
         const 0;
 },
 GHC.IO.Handle.Text.$whPutBuf'_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe1l: // global
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 8, res: 0, upd: 8;
     }
 },
 act_sbcha_entry() //  [R1, R2]
         { info_tbl: [(cbe1C,
                       label: act_sbcha_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe1C: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbe1D; else goto cbe1E;
       cbe1D: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbe1E: // global
           I64[Sp - 32] = block_cbe1z_info;
           _sbch4::P64 = P64[R1 + 6];
           _sbch6::P64 = P64[R1 + 14];
           _sbch8::I64 = I64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sbch4::P64;
           P64[Sp - 16] = _sbch6::P64;
           I64[Sp - 8] = _sbch8::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ube2C; else goto cbe1A;
       ube2C: // global
           call _cbe1z(R1) args: 0, res: 0, upd: 0;
       cbe1A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe1z() //  [R1]
         { info_tbl: [(cbe1z,
                       label: block_cbe1z_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe1z: // global
           I64[Sp - 8] = block_cbe1H_info;
           R5 = P64[Sp + 16];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = R1;
           P64[Sp] = P64[R1 + 55];
           P64[Sp + 8] = P64[R1 + 47];
           P64[Sp + 16] = P64[R1 + 31];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$wbufWrite_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbe1H() //  [R1]
         { info_tbl: [(cbe1H,
                       label: block_cbe1H_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe1H: // global
           I64[Sp] = block_cbe1J_info;
           _sbchw::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbchw::P64;
           if (R1 & 7 != 0) goto ube2D; else goto cbe1M;
       ube2D: // global
           call _cbe1J(R1) args: 0, res: 0, upd: 0;
       cbe1M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe1J() //  [R1]
         { info_tbl: [(cbe1J,
                       label: block_cbe1J_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe1J: // global
           if (R1 & 7 == 3) goto ube2z; else goto cbe1T;
       ube2z: // global
           Sp = Sp + 8;
           call _cbe2t() args: 0, res: 0, upd: 0;
       cbe1T: // global
           _sbchA::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbe1Q_info;
           R1 = _sbchA::P64;
           if (R1 & 7 != 0) goto ube2E; else goto cbe1U;
       ube2E: // global
           call _cbe1Q(R1) args: 0, res: 0, upd: 0;
       cbe1U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe1Q() //  [R1]
         { info_tbl: [(cbe1Q,
                       label: block_cbe1Q_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe1Q: // global
           I64[Sp] = block_cbe1Y_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ube2G; else goto cbe20;
       ube2G: // global
           call _cbe1Y(R1) args: 0, res: 0, upd: 0;
       cbe20: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe1Y() //  [R1]
         { info_tbl: [(cbe1Y,
                       label: block_cbe1Y_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe1Y: // global
           if (R1 & 7 == 1) goto ube2A; else goto cbe2b;
       ube2A: // global
           Sp = Sp + 8;
           call _cbe2t() args: 0, res: 0, upd: 0;
       cbe2b: // global
           _sbchL::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbe29_info;
           R1 = _sbchL::P64;
           if (R1 & 7 != 0) goto ube2H; else goto cbe2c;
       ube2H: // global
           call _cbe29(R1) args: 0, res: 0, upd: 0;
       cbe2c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe29() //  [R1]
         { info_tbl: [(cbe29,
                       label: block_cbe29_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe29: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ube2B; else goto cbe2m;
       ube2B: // global
           Sp = Sp + 8;
           call _cbe2t() args: 0, res: 0, upd: 0;
       cbe2m: // global
           I64[Sp] = block_cbe2k_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbe2t() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe2t: // global
           R1 = P64[Sp];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbe2k() //  [R1]
         { info_tbl: [(cbe2k,
                       label: block_cbe2k_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe2k: // global
           _sbchj::P64 = P64[Sp + 16];
           _sbchw::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbchj::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbchj::P64);
           R1 = _sbchw::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ube39_srtd" {
     ube39_srtd:
         const SbcpG_srt+8;
         const 62;
         const 3602879701896396803;
 },
 GHC.IO.Handle.Text.$whPutBuf'_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbe2N,
                       label: GHC.IO.Handle.Text.$whPutBuf'_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe2N: // global
           _sbch6::P64 = R5;
           _sbch5::I64 = R4;
           _sbch4::P64 = R3;
           _sbch3::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbe2O; else goto cbe2P;
       cbe2P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbe2R; else goto cbe2Q;
       cbe2R: // global
           HpAlloc = 32;
           goto cbe2O;
       cbe2O: // global
           R1 = GHC.IO.Handle.Text.$whPutBuf'_closure;
           P64[Sp - 32] = _sbch3::P64;
           P64[Sp - 24] = _sbch4::P64;
           I64[Sp - 16] = _sbch5::I64;
           P64[Sp - 8] = _sbch6::P64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cbe2Q: // global
           if (_sbch5::I64 == 0) goto cbe2M; else goto cbe2L;
       cbe2M: // global
           Hp = Hp - 32;
           R1 = GHC.IO.Handle.Text.hGetBuf3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbe2L: // global
           if (%MO_S_Ge_W64(_sbch5::I64, 0)) goto cbe2U; else goto cbe36;
       cbe2U: // global
           I64[Hp - 24] = act_sbcha_info;
           P64[Hp - 16] = _sbch4::P64;
           P64[Hp - 8] = _sbch6::P64;
           I64[Hp] = _sbch5::I64;
           I64[Sp - 16] = block_cbe2S_info;
           R1 = _sbch3::P64;
           P64[Sp - 8] = Hp - 22;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ube38; else goto cbe2V;
       ube38: // global
           call _cbe2S(R1) args: 0, res: 0, upd: 0;
       cbe2V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbe36: // global
           Hp = Hp - 32;
           R4 = _sbch5::I64;
           R3 = GHC.IO.Handle.Text.hPutBuf3_closure;
           R2 = _sbch3::P64;
           call GHC.IO.Handle.Text.$willegalBufferSize_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ube3a_srtd" {
     ube3a_srtd:
         const SbcpG_srt+16;
         const 61;
         const 1152921504606846977;
 },
 _cbe2S() //  [R1]
         { info_tbl: [(cbe2S,
                       label: block_cbe2S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe2S: // global
           _cbe1u::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbe31; else goto cbe35;
       cbe31: // global
           R5 = _cbe1u::P64;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutBuf3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
       cbe35: // global
           R5 = _cbe1u::P64;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutBuf3_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.477673751 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf2_closure" {
     GHC.IO.Handle.Text.hPutBuf2_closure:
         const GHC.IO.Handle.Text.hPutBuf2_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbe4u,
                       label: GHC.IO.Handle.Text.hPutBuf2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe4u: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbe4v; else goto cbe4w;
       cbe4v: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBuf2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbe4w: // global
           I64[Sp - 32] = block_cbe4r_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ube4A; else goto cbe4s;
       ube4A: // global
           call _cbe4r(R1) args: 0, res: 0, upd: 0;
       cbe4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe4r() //  [R1]
         { info_tbl: [(cbe4r,
                       label: block_cbe4r_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe4r: // global
           R5 = P64[Sp + 24];
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.483311348 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBufNonBlocking1_closure" {
     GHC.IO.Handle.Text.hPutBufNonBlocking1_closure:
         const GHC.IO.Handle.Text.hPutBufNonBlocking1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBufNonBlocking1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbe4S,
                       label: GHC.IO.Handle.Text.hPutBufNonBlocking1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe4S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbe4T; else goto cbe4U;
       cbe4T: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBufNonBlocking1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbe4U: // global
           I64[Sp - 24] = block_cbe4P_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ube4Y; else goto cbe4Q;
       ube4Y: // global
           call _cbe4P(R1) args: 0, res: 0, upd: 0;
       cbe4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe4P() //  [R1]
         { info_tbl: [(cbe4P,
                       label: block_cbe4P_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe4P: // global
           R5 = GHC.Types.False_closure+1;
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.489058179 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBufNonBlocking_closure" {
     GHC.IO.Handle.Text.hPutBufNonBlocking_closure:
         const GHC.IO.Handle.Text.hPutBufNonBlocking_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBufNonBlocking_entry() //  [R2, R3, R4]
         { info_tbl: [(cbe5e,
                       label: GHC.IO.Handle.Text.hPutBufNonBlocking_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe5e: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutBufNonBlocking1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.492517798 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf1_closure" {
     GHC.IO.Handle.Text.hPutBuf1_closure:
         const GHC.IO.Handle.Text.hPutBuf1_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbe5s,
                       label: GHC.IO.Handle.Text.hPutBuf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe5s: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbe5w; else goto cbe5x;
       cbe5w: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutBuf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbe5x: // global
           I64[Sp - 24] = block_cbe5p_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ube5B; else goto cbe5q;
       ube5B: // global
           call _cbe5p(R1) args: 0, res: 0, upd: 0;
       cbe5q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe5p() //  [R1]
         { info_tbl: [(cbe5p,
                       label: block_cbe5p_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe5p: // global
           _sbcij::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbe5v_info;
           R5 = GHC.Types.True_closure+2;
           R4 = I64[R1 + 7];
           R3 = _sbcij::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.$whPutBuf'_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbe5v() //  []
         { info_tbl: [(cbe5v,
                       label: block_cbe5v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe5v: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.500412559 UTC

[section ""data" . GHC.IO.Handle.Text.hPutBuf_closure" {
     GHC.IO.Handle.Text.hPutBuf_closure:
         const GHC.IO.Handle.Text.hPutBuf_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbe5X,
                       label: GHC.IO.Handle.Text.hPutBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe5X: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutBuf1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.503612189 UTC

[section ""cstring" . lvl31_rb6Xb_bytes" {
     lvl31_rb6Xb_bytes:
         I8[] [10]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.505849997 UTC

[section ""data" . lvl32_rb6Xc_closure" {
     lvl32_rb6Xc_closure:
         const lvl32_rb6Xc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl32_rb6Xc_entry() //  [R1]
         { info_tbl: [(cbe6b,
                       label: lvl32_rb6Xc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe6b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbe6c; else goto cbe6d;
       cbe6c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbe6d: // global
           (_cbe68::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbe68::I64 == 0) goto cbe6a; else goto cbe69;
       cbe6a: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbe69: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbe68::I64;
           R2 = lvl31_rb6Xb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.51350126 UTC

[section ""data" . GHC.IO.Handle.Text.$wwriteBlocks_closure" {
     GHC.IO.Handle.Text.$wwriteBlocks_closure:
         const GHC.IO.Handle.Text.$wwriteBlocks_info;
         const 0;
 },
 GHC.IO.Handle.Text.$wwriteBlocks_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe6n: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sbckU_entry() //  [R1]
         { info_tbl: [(cbe6C,
                       label: sat_sbckU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe6C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbe6D; else goto cbe6E;
       cbe6D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbe6E: // global
           I64[Sp - 8] = block_cbe6v_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ube6L; else goto cbe6w;
       ube6L: // global
           call _cbe6v(R1) args: 0, res: 0, upd: 0;
       cbe6w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe6v() //  [R1]
         { info_tbl: [(cbe6v,
                       label: block_cbe6v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe6v: // global
           if (R1 & 7 == 1) goto cbe6z; else goto cbe6A;
       cbe6z: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbe6A: // global
           R1 = lvl32_rb6Xc_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbcjg_entry() //  [R1, R2]
         { info_tbl: [(cbe70,
                       label: sat_sbcjg_info
                       rep:HeapRep 2 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe70: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbe76; else goto cbe77;
       cbe76: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbe77: // global
           I64[Sp - 48] = block_cbe6X_info;
           _sbciw::P64 = P64[R1 + 6];
           _sbciD::P64 = P64[R1 + 14];
           _sbciv::I64 = I64[R1 + 22];
           _sbcix::I64 = I64[R1 + 30];
           _sbciB::I64 = I64[R1 + 38];
           R1 = R2;
           I64[Sp - 40] = _sbciv::I64;
           P64[Sp - 32] = _sbciw::P64;
           I64[Sp - 24] = _sbcix::I64;
           I64[Sp - 16] = _sbciB::I64;
           P64[Sp - 8] = _sbciD::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ube7s; else goto cbe6Y;
       ube7s: // global
           call _cbe6X(R1) args: 0, res: 0, upd: 0;
       cbe6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe6X() //  [R1]
         { info_tbl: [(cbe6X,
                       label: block_cbe6X_info
                       rep:StackRep [True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe6X: // global
           _sbciv::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cbe73_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = _sbciv::I64;
           R2 = R1;
           I64[Sp - 8] = 0;
           I64[Sp] = I64[Sp + 32];
           P64[Sp + 16] = P64[R1 + 79];
           P64[Sp + 32] = P64[R1 + 71];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbe73() //  []
         { info_tbl: [(cbe73,
                       label: block_cbe73_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe73: // global
           _sbcj2::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbe75_info;
           R1 = _sbcj2::P64;
           if (R1 & 7 != 0) goto ube7t; else goto cbe7a;
       ube7t: // global
           call _cbe75(R1) args: 0, res: 0, upd: 0;
       cbe7a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe75() //  [R1]
         { info_tbl: [(cbe75,
                       label: block_cbe75_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe75: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbe7g; else goto cbe7f;
       cbe7g: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbe7f: // global
           if (I64[Sp + 16] == I64[R1 + 31]) goto cbe7l; else goto cbe7k;
       cbe7l: // global
           _sbciQ::P64 = P64[Sp + 8];
           _sbcjd::P64 = P64[_sbciQ::P64 + 8];
           I64[Hp - 16] = GHC.IO.Handle.Types.BufferListCons_con_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sbcjd::P64;
           call MO_WriteBarrier();
           P64[_sbciQ::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbciQ::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbe7k: // global
           Hp = Hp - 24;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbckf_entry() //  [R1, R2]
         { info_tbl: [(cbe8c,
                       label: sat_sbckf_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe8c: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbe8i; else goto cbe8j;
       cbe8i: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbe8j: // global
           I64[Sp - 40] = block_cbe89_info;
           _sbciw::P64 = P64[R1 + 6];
           _sbciv::I64 = I64[R1 + 14];
           _sbcix::I64 = I64[R1 + 22];
           _sbcjC::I64 = I64[R1 + 30];
           R1 = R2;
           I64[Sp - 32] = _sbciv::I64;
           P64[Sp - 24] = _sbciw::P64;
           I64[Sp - 16] = _sbcix::I64;
           I64[Sp - 8] = _sbcjC::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ube8D; else goto cbe8a;
       ube8D: // global
           call _cbe89(R1) args: 0, res: 0, upd: 0;
       cbe8a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe89() //  [R1]
         { info_tbl: [(cbe89,
                       label: block_cbe89_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe89: // global
           _sbciv::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cbe8f_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = _sbciv::I64;
           R2 = R1;
           I64[Sp - 8] = 0;
           I64[Sp] = I64[Sp + 32];
           P64[Sp + 16] = P64[R1 + 47];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbe8f() //  []
         { info_tbl: [(cbe8f,
                       label: block_cbe8f_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe8f: // global
           _sbck2::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_cbe8h_info;
           R1 = _sbck2::P64;
           if (R1 & 7 != 0) goto ube8E; else goto cbe8m;
       ube8E: // global
           call _cbe8h(R1) args: 0, res: 0, upd: 0;
       cbe8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe8h() //  [R1]
         { info_tbl: [(cbe8h,
                       label: block_cbe8h_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe8h: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbe8z; else goto cbe8w;
       cbe8z: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbe8w: // global
           I64[Sp] = block_cbe8u_info;
           R2 = P64[Sp + 24];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbe8u() //  [R1]
         { info_tbl: [(cbe8u,
                       label: block_cbe8u_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe8u: // global
           _sbcjM::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbcjM::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcjM::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbckP_entry() //  [R1, R2]
         { info_tbl: [(cbe8O,
                       label: sat_sbckP_info
                       rep:HeapRep 1 ptrs 3 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe8O: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbe8S; else goto cbe8T;
       cbe8S: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbe8T: // global
           I64[Sp - 40] = block_cbe8L_info;
           _sbciw::P64 = P64[R1 + 6];
           _sbciv::I64 = I64[R1 + 14];
           _sbcix::I64 = I64[R1 + 22];
           _sbcji::I64 = I64[R1 + 30];
           R1 = R2;
           I64[Sp - 32] = _sbciv::I64;
           P64[Sp - 24] = _sbciw::P64;
           I64[Sp - 16] = _sbcix::I64;
           I64[Sp - 8] = _sbcji::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ube8X; else goto cbe8M;
       ube8X: // global
           call _cbe8L(R1) args: 0, res: 0, upd: 0;
       cbe8M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe8L() //  [R1]
         { info_tbl: [(cbe8L,
                       label: block_cbe8L_info
                       rep:StackRep [True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe8L: // global
           _sbcji::I64 = I64[Sp + 32];
           I64[Sp + 32] = block_cbe8R_info;
           R6 = I64[Sp + 24];
           R5 = GHC.IO.Buffer.WriteBuffer_closure+2;
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = R1;
           I64[Sp + 16] = 0;
           I64[Sp + 24] = _sbcji::I64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wwriteCharBuffer_entry(R6,
                                                                R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbe8R() //  []
         { info_tbl: [(cbe8R,
                       label: block_cbe8R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe8R: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.Text.$wwriteBlocks_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbe8Y,
                       label: GHC.IO.Handle.Text.$wwriteBlocks_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, True, False, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe8Y: // global
           _sbciv::I64 = R6;
           _sbciu::P64 = R5;
           _sbcit::P64 = R4;
           _sbcis::P64 = R3;
           _sbcir::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cbe8Z; else goto cbe90;
       cbe90: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbe92; else goto cbe91;
       cbe92: // global
           HpAlloc = 24;
           goto cbe8Z;
       cbe8Z: // global
           R1 = GHC.IO.Handle.Text.$wwriteBlocks_closure;
           P64[Sp - 40] = _sbcir::P64;
           P64[Sp - 32] = _sbcis::P64;
           P64[Sp - 24] = _sbcit::P64;
           P64[Sp - 16] = _sbciu::P64;
           I64[Sp - 8] = _sbciv::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cbe91: // global
           I64[Hp - 16] = sat_sbckU_info;
           P64[Hp] = _sbcit::P64;
           P64[Sp - 48] = _sbcis::P64;
           P64[Sp - 40] = _sbciu::P64;
           I64[Sp - 32] = _sbciv::I64;
           I64[Sp - 24] = 0;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = Hp - 16;
           P64[Sp + 16] = _sbcir::P64;
           Sp = Sp - 48;
           call _cbe7w() args: 0, res: 0, upd: 0;
     }
 },
 _cbe7w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe7w: // global
           I64[Sp - 8] = block_cbe7z_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubeam; else goto cbe7A;
       ubeam: // global
           call _cbe7z(R1) args: 0, res: 0, upd: 0;
       cbe7A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe7z() //  [R1]
         { info_tbl: [(cbe7z,
                       label: block_cbe7z_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe7z: // global
           if (R1 & 7 == 1) goto cbe9b; else goto cbe9n;
       cbe9b: // global
           I64[Sp] = block_cbe98_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ubean; else goto cbe9c;
       ubean: // global
           call _cbe98(R1) args: 0, res: 0, upd: 0;
       cbe9c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbe9n: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbe9q; else goto cbe9p;
       cbe9q: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbe9p: // global
           _sbcix::I64 = I64[Sp + 64];
           _sbcji::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(_sbcji::I64 + 1,
                            _sbcix::I64)) goto cbe9s; else goto cbe9W;
       cbe9s: // global
           _sbcjq::P64 = P64[R1 + 6];
           _sbcjr::P64 = P64[R1 + 14];
           Hp = Hp - 40;
           I64[Sp] = block_cbe7L_info;
           R1 = _sbcjq::P64;
           P64[Sp + 40] = _sbcjr::P64;
           if (R1 & 7 != 0) goto ubeao; else goto cbe7M;
       ubeao: // global
           call _cbe7L(R1) args: 0, res: 0, upd: 0;
       cbe7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbe9W: // global
           I64[Hp - 32] = sat_sbckP_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = _sbcix::I64;
           I64[Hp] = _sbcji::I64;
           I64[Sp] = block_cbe9V_info;
           R4 = Hp - 30;
           R3 = P64[Sp + 72];
           R2 = lvl2_rb6WE_closure;
           P64[Sp + 40] = R1;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbe98() //  [R1]
         { info_tbl: [(cbe98,
                       label: block_cbe98_info
                       rep:StackRep [False, False, True, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe98: // global
           _sbcji::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cbe9i; else goto cbe9m;
       cbe9i: // global
           I64[Sp + 48] = _sbcji::I64;
           Sp = Sp + 24;
           call _cbe6P() args: 0, res: 0, upd: 0;
       cbe9m: // global
           I64[Sp + 32] = _sbcji::I64;
           P64[Sp + 40] = R1;
           P64[Sp + 48] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _cbe7w() args: 0, res: 0, upd: 0;
     }
 },
 _cbe6P() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe6P: // global
           Hp = Hp + 72;
           _sbciB::I64 = I64[Sp + 24];
           if (Hp > HpLim) (likely: False) goto cbe95; else goto cbe94;
       cbe95: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_cbe6O_info;
           R1 = _sbciB::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbe94: // global
           I64[Hp - 64] = GHC.ForeignPtr.ForeignPtr_con_info;
           _sbciw::P64 = P64[Sp + 32];
           P64[Hp - 56] = _sbciw::P64;
           _sbciv::I64 = I64[Sp];
           I64[Hp - 48] = _sbciv::I64;
           I64[Hp - 40] = sat_sbcjg_info;
           P64[Hp - 32] = _sbciw::P64;
           P64[Hp - 24] = Hp - 63;
           I64[Hp - 16] = _sbciv::I64;
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _sbciB::I64;
           R4 = Hp - 38;
           R3 = P64[Sp + 48];
           R2 = lvl2_rb6WE_closure;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbe6O() //  [R1]
         { info_tbl: [(cbe6O,
                       label: block_cbe6O_info
                       rep:StackRep [True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe6O: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cbe6P() args: 0, res: 0, upd: 0;
     }
 },
 _cbe7L() //  [R1]
         { info_tbl: [(cbe7L,
                       label: block_cbe7L_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe7L: // global
           _sbcjw::I64 = I64[R1 + 7];
           if (_sbcjw::I64 != 10) goto cbe9v; else goto cbe9J;
       cbe9v: // global
           _sbciw::P64 = P64[Sp + 56];
           _sbcji::I64 = I64[Sp + 32];
           _sbcjk::P64 = P64[Sp + 48];
           _sbcjr::P64 = P64[Sp + 40];
           I32[I64[Sp + 24] + (_sbcji::I64 << 2)] = %MO_UU_Conv_W64_W32(_sbcjw::I64);
           call MO_Touch(_sbciw::P64);
           I64[Sp + 32] = _sbcji::I64 + 1;
           P64[Sp + 40] = _sbcjr::P64;
           P64[Sp + 48] = _sbcjk::P64;
           Sp = Sp + 8;
           call _cbe7w() args: 0, res: 0, upd: 0;
       cbe9J: // global
           I64[Sp] = block_cbe9w_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubeap; else goto cbe9K;
       ubeap: // global
           call _cbe9w(R1) args: 0, res: 0, upd: 0;
       cbe9K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe9w() //  [R1]
         { info_tbl: [(cbe9w,
                       label: block_cbe9w_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe9w: // global
           _sbcis::P64 = P64[Sp + 8];
           _sbciv::I64 = I64[Sp + 24];
           _sbciw::P64 = P64[Sp + 56];
           _sbcji::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cbe9Q; else goto cbe9U;
       cbe9Q: // global
           I32[_sbciv::I64 + (_sbcji::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sbciw::P64);
           _sbcjC::I64 = _sbcji::I64 + 1;
           goto sbcjA;
       cbe9U: // global
           I32[_sbciv::I64 + (_sbcji::I64 << 2)] = 13 :: W32;
           call MO_Touch(_sbciw::P64);
           _sbckp::I64 = _sbcji::I64 + 1;
           I32[_sbciv::I64 + (_sbckp::I64 << 2)] = 10 :: W32;
           call MO_Touch(_sbciw::P64);
           _sbcjC::I64 = _sbckp::I64 + 1;
           goto sbcjA;
       sbcjA: // global
           I64[Sp] = block_cbe7Y_info;
           R1 = _sbcis::P64;
           I64[Sp + 32] = _sbcjC::I64;
           if (R1 & 7 != 0) goto ubeav; else goto cbe7Z;
       ubeav: // global
           call _cbe7Y(R1) args: 0, res: 0, upd: 0;
       cbe7Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbe7Y() //  [R1]
         { info_tbl: [(cbe7Y,
                       label: block_cbe7Y_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe7Y: // global
           _sbcjC::I64 = I64[Sp + 32];
           if (R1 & 7 == 1) goto cbe9B; else goto cbe9D;
       cbe9B: // global
           I64[Sp + 32] = _sbcjC::I64;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cbe7w() args: 0, res: 0, upd: 0;
       cbe9D: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbe9G; else goto cbe9F;
       cbe9G: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbe9F: // global
           I64[Hp - 32] = sat_sbckf_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = I64[Sp + 64];
           I64[Hp] = _sbcjC::I64;
           I64[Sp] = block_cbe9C_info;
           R4 = Hp - 30;
           R3 = P64[Sp + 72];
           R2 = lvl2_rb6WE_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbe9C() //  []
         { info_tbl: [(cbe9C,
                       label: block_cbe9C_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe9C: // global
           I64[Sp + 32] = 0;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cbe7w() args: 0, res: 0, upd: 0;
     }
 },
 _cbe9V() //  []
         { info_tbl: [(cbe9V,
                       label: block_cbe9V_info
                       rep:StackRep [False, False, True, True, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe9V: // global
           I64[Sp + 32] = 0;
           P64[Sp + 40] = P64[Sp + 40];
           P64[Sp + 48] = P64[Sp + 48];
           Sp = Sp + 8;
           call _cbe7w() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.566414047 UTC

[section ""cstring" . lvl33_rb6Xd_bytes" {
     lvl33_rb6Xd_bytes:
         I8[] [110,111,32,98,117,102,102,101,114,33]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.568437659 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr4_closure" {
     GHC.IO.Handle.Text.hPutStr4_closure:
         const GHC.IO.Handle.Text.hPutStr4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr4_entry() //  [R1]
         { info_tbl: [(cbedA,
                       label: GHC.IO.Handle.Text.hPutStr4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbedA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbedB; else goto cbedC;
       cbedB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbedC: // global
           (_cbedv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbedv::I64 == 0) goto cbedx; else goto cbedw;
       cbedx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbedw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbedv::I64;
           I64[Sp - 24] = block_cbedy_info;
           R2 = lvl33_rb6Xd_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbedy() //  [R1]
         { info_tbl: [(cbedy,
                       label: block_cbedy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbedy: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.574390651 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr3_closure" {
     GHC.IO.Handle.Text.hPutStr3_closure:
         const (,)_con_info;
         const GHC.IO.Handle.Types.NoBuffering_closure+1;
         const GHC.IO.Handle.Text.hPutStr4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.578432014 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr2_closure" {
     GHC.IO.Handle.Text.hPutStr2_closure:
         const GHC.IO.Handle.Text.hPutStr2_info;
         const 0;
 },
 sat_sbclV_entry() //  [R1]
         { info_tbl: [(cbeen,
                       label: sat_sbclV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeen: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbeew; else goto cbeex;
       cbeew: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbeex: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbeek_info;
           _sbcll::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbcll::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubeeD; else goto cbeel;
       ubeeD: // global
           call _cbeek(R1) args: 0, res: 0, upd: 0;
       cbeel: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbeek() //  [R1]
         { info_tbl: [(cbeek,
                       label: block_cbeek_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeek: // global
           I64[Sp - 8] = block_cbeeq_info;
           _sbclN::P64 = P64[R1 + 7];
           _sbclM::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbclN::P64;
           I64[Sp + 8] = _sbclM::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubeeC; else goto cbeer;
       ubeeC: // global
           call _cbeeq(R1) args: 0, res: 0, upd: 0;
       cbeer: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbeeq() //  [R1]
         { info_tbl: [(cbeeq,
                       label: block_cbeeq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeeq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbeeB; else goto cbeeA;
       cbeeB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbeeA: // global
           _sbclS::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = _sbclS::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.Text.hPutStr2_entry() //  [R2]
         { info_tbl: [(cbeeE,
                       label: GHC.IO.Handle.Text.hPutStr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeeE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbeeF; else goto cbeeG;
       cbeeF: // global
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbeeG: // global
           I64[Sp - 8] = block_cbedX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubefB; else goto cbedY;
       ubefB: // global
           call _cbedX(R1) args: 0, res: 0, upd: 0;
       cbedY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbedX() //  [R1]
         { info_tbl: [(cbedX,
                       label: block_cbedX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbedX: // global
           I64[Sp - 24] = block_cbee2_info;
           _sbcl7::P64 = P64[R1 + 71];
           _sbcl8::P64 = P64[R1 + 79];
           _sbcld::P64 = P64[R1 + 119];
           R1 = P64[R1 + 55];
           P64[Sp - 16] = _sbcl8::P64;
           P64[Sp - 8] = _sbcld::P64;
           P64[Sp] = _sbcl7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubefy; else goto cbee3;
       ubefy: // global
           call _cbee2(R1) args: 0, res: 0, upd: 0;
       cbee3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbee2() //  [R1]
         { info_tbl: [(cbee2,
                       label: block_cbee2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbee2: // global
           if (R1 & 7 == 1) goto cbefs; else goto cbeeK;
       cbefs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbefv; else goto cbefu;
       cbefv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbefu: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Text.hPutStr3_closure+1;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbeeK: // global
           _sbcli::P64 = P64[P64[Sp + 8] + 8];
           _sbcll::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp - 8] = block_cbee7_info;
           _sbclf::P64 = R1;
           R1 = _sbcli::P64;
           P64[Sp] = _sbcll::P64;
           P64[Sp + 24] = _sbclf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubefz; else goto cbee8;
       ubefz: // global
           call _cbee7(R1) args: 0, res: 0, upd: 0;
       cbee8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbee7() //  [R1]
         { info_tbl: [(cbee7,
                       label: block_cbee7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbee7: // global
           _sbcll::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbeeP; else goto cbefl;
       cbeeP: // global
           I64[Sp + 16] = block_cbeeM_info;
           R1 = _sbcll::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubefA; else goto cbeeQ;
       ubefA: // global
           call _cbeeM(R1) args: 0, res: 0, upd: 0;
       cbeeQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbefl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbefo; else goto cbefn;
       cbefo: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbefn: // global
           _sbcl8::P64 = P64[Sp + 16];
           _sbcld::P64 = P64[Sp + 24];
           _sbclf::P64 = P64[Sp + 32];
           _sbclI::P64 = P64[R1 + 6];
           _sbclJ::P64 = P64[R1 + 14];
           call MO_WriteBarrier();
           P64[_sbcl8::P64 + 8] = _sbclJ::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcl8::P64);
           I64[Hp - 72] = sat_sbclV_info;
           P64[Hp - 56] = _sbcll::P64;
           P64[Hp - 48] = _sbclI::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = _sbclf::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = _sbcld::P64;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbeeM() //  [R1]
         { info_tbl: [(cbeeM,
                       label: block_cbeeM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeeM: // global
           _sbclr::I64 = I64[R1 + 31];
           _sbclu::I64 = _sbclr::I64 << 2;
           if (%MO_S_Ge_W64(_sbclu::I64, 0)) goto cbefd; else goto cbefi;
       cbefd: // global
           I64[Sp - 16] = block_cbef1_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _sbclu::I64;
           I64[Sp] = _sbclr::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbefi: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbef1() //  [R1]
         { info_tbl: [(cbef1,
                       label: block_cbef1_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbef1: // global
           I64[Sp] = block_cbef3_info;
           _sbcly::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _sbcly::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbef3() //  [R1]
         { info_tbl: [(cbef3,
                       label: block_cbef3_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbef3: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cbefh; else goto cbefg;
       cbefh: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbefg: // global
           I64[Hp - 120] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 112] = R1;
           P64[Hp - 104] = P64[Sp + 8];
           I64[Hp - 96] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 88] = Hp - 118;
           P64[Hp - 80] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 72] = R1 + 16;
           I64[Hp - 64] = I64[Sp + 16];
           I64[Hp - 56] = 0;
           I64[Hp - 48] = 0;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = Hp - 95;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.601314638 UTC

[section ""cstring" . GHC.IO.Handle.Text.hPutStr6_bytes" {
     GHC.IO.Handle.Text.hPutStr6_bytes:
         I8[] [104,80,117,116,83,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.603300069 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr5_closure" {
     GHC.IO.Handle.Text.hPutStr5_closure:
         const GHC.IO.Handle.Text.hPutStr5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr5_entry() //  [R1]
         { info_tbl: [(cbeh8,
                       label: GHC.IO.Handle.Text.hPutStr5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeh8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbeh9; else goto cbeha;
       cbeh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbeha: // global
           (_cbeh5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbeh5::I64 == 0) goto cbeh7; else goto cbeh6;
       cbeh7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbeh6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbeh5::I64;
           R2 = GHC.IO.Handle.Text.hPutStr6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.608600775 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr1_closure" {
     GHC.IO.Handle.Text.hPutStr1_closure:
         const GHC.IO.Handle.Text.hPutStr1_info;
         const 0;
 },
 section ""relreadonly" . ubeja_srtd" {
     ubeja_srtd:
         const SbcpG_srt+16;
         const 74;
         const 19;
         const 836;
 },
 GHC.IO.Handle.Text.hPutStr1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbehw,
                       label: GHC.IO.Handle.Text.hPutStr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbehw: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbehx; else goto cbehy;
       cbehx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hPutStr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbehy: // global
           I64[Sp - 32] = block_cbehp_info;
           R1 = R2;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubeiZ; else goto cbehq;
       ubeiZ: // global
           call _cbehp(R1) args: 0, res: 0, upd: 0;
       cbehq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubejb_srtd" {
     ubejb_srtd:
         const SbcpG_srt+16;
         const 74;
         const 19;
         const 580;
 },
 _cbehp() //  [R1]
         { info_tbl: [(cbehp,
                       label: block_cbehp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbehp: // global
           if (R1 & 7 == 1) goto cbeht; else goto cbehu;
       cbeht: // global
           I64[Sp] = block_cbeim_info;
           R5 = GHC.IO.Handle.Text.hPutStr2_closure+2;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutStr5_closure;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 8, upd: 8;
       cbehu: // global
           I64[Sp] = block_cbeiE_info;
           R5 = GHC.IO.Handle.Text.hPutStr2_closure+2;
           R4 = P64[R1 + 22];
           R3 = R1;
           R2 = GHC.IO.Handle.Text.hPutStr5_closure;
           call GHC.IO.Handle.Internals.$wwantWritableHandle'_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubejc_srtd" {
     ubejc_srtd:
         const SbcpG_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbeim() //  [R1]
         { info_tbl: [(cbeim,
                       label: block_cbeim_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeim: // global
           I64[Sp] = block_cbeio_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubej3; else goto cbeip;
       ubej3: // global
           call _cbeio(R1) args: 0, res: 0, upd: 0;
       cbeip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubejd_srtd" {
     ubejd_srtd:
         const SbcpG_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbeio() //  [R1]
         { info_tbl: [(cbeio,
                       label: block_cbeio_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeio: // global
           I64[Sp - 8] = block_cbeit_info;
           _sbcmA::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sbcmA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubej4; else goto cbeix;
       ubej4: // global
           call _cbeit(R1) args: 0, res: 0, upd: 0;
       cbeix: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubeje_srtd" {
     ubeje_srtd:
         const SbcpG_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbeit() //  [R1]
         { info_tbl: [(cbeit,
                       label: block_cbeit_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeit: // global
           _sbcm7::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           P64[Sp - 8] = _sbcm7::P64;
           Sp = Sp - 8;
           call _sbcm3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubejf_srtd" {
     ubejf_srtd:
         const SbcpG_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbeiE() //  [R1]
         { info_tbl: [(cbeiE,
                       label: block_cbeiE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeiE: // global
           I64[Sp] = block_cbeiG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubej6; else goto cbeiH;
       ubej6: // global
           call _cbeiG(R1) args: 0, res: 0, upd: 0;
       cbeiH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubejg_srtd" {
     ubejg_srtd:
         const SbcpG_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbeiG() //  [R1]
         { info_tbl: [(cbeiG,
                       label: block_cbeiG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeiG: // global
           I64[Sp - 8] = block_cbeiL_info;
           _sbcmM::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sbcmM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubej7; else goto cbeiP;
       ubej7: // global
           call _cbeiL(R1) args: 0, res: 0, upd: 0;
       cbeiP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubejh_srtd" {
     ubejh_srtd:
         const SbcpG_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbeiL() //  [R1]
         { info_tbl: [(cbeiL,
                       label: block_cbeiL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeiL: // global
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 8] = P64[R1 + 7];
           Sp = Sp - 8;
           call _sbcm3() args: 0, res: 0, upd: 0;
     }
 },
 _sbcm3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbcm3: // global
           I64[Sp - 8] = block_cbehC_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubej9; else goto cbehE;
       ubej9: // global
           call _cbehC(R1) args: 0, res: 0, upd: 0;
       cbehE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubeji_srtd" {
     ubeji_srtd:
         const SbcpG_srt+24;
         const 66;
         const 9;
         const 2;
 },
 _cbehC() //  [R1]
         { info_tbl: [(cbehC,
                       label: block_cbehC_info
                       rep:StackRep [False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbehC: // global
           _sbcm6::P64 = P64[Sp + 16];
           _cbeiU::P64 = R1 & 7;
           if (_cbeiU::P64 < 3) goto ubeiW; else goto cbeie;
       ubeiW: // global
           if (_cbeiU::P64 < 2) goto cbehN; else goto cbei4;
       cbehN: // global
           I64[Sp + 24] = block_cbehI_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           Sp = Sp + 24;
           call GHC.IO.Handle.Text.hPutStr7_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cbei4: // global
           I64[Sp] = block_cbei2_info;
           R1 = _sbcm6::P64;
           if (R1 & 7 != 0) goto ubej0; else goto cbei5;
       ubej0: // global
           call _cbei2(R1) args: 0, res: 0, upd: 0;
       cbei5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbeie: // global
           I64[Sp] = block_cbeic_info;
           R1 = _sbcm6::P64;
           if (R1 & 7 != 0) goto ubej1; else goto cbeif;
       ubej1: // global
           call _cbeic(R1) args: 0, res: 0, upd: 0;
       cbeif: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbehI() //  []
         { info_tbl: [(cbehI,
                       label: block_cbehI_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbehI: // global
           I64[Sp] = block_cbehK_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto ubej2; else goto cbehP;
       ubej2: // global
           call _cbehK(R1) args: 0, res: 0, upd: 0;
       cbehP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbehK() //  [R1]
         { info_tbl: [(cbehK,
                       label: block_cbehK_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbehK: // global
           if (R1 & 7 == 1) goto cbehV; else goto cbehZ;
       cbehV: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbehZ: // global
           R3 = 10;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$whPutChar_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbei2() //  [R1]
         { info_tbl: [(cbei2,
                       label: block_cbei2_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbei2: // global
           R6 = I64[R1 + 23];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = GHC.Types.True_closure+2;
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           _sbcm0::P64 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 31];
           P64[Sp + 48] = _sbcm0::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 _cbeic() //  [R1]
         { info_tbl: [(cbeic,
                       label: block_cbeic_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeic: // global
           R6 = I64[R1 + 23];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = GHC.Types.False_closure+1;
           R2 = P64[Sp + 32];
           P64[Sp + 32] = P64[R1 + 7];
           _sbcm0::P64 = P64[Sp + 40];
           I64[Sp + 40] = I64[R1 + 31];
           P64[Sp + 48] = _sbcm0::P64;
           Sp = Sp + 32;
           call GHC.IO.Handle.Text.$wwriteBlocks_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.642049753 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr'_closure" {
     GHC.IO.Handle.Text.hPutStr'_closure:
         const GHC.IO.Handle.Text.hPutStr'_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr'_entry() //  [R2, R3, R4]
         { info_tbl: [(cbekQ,
                       label: GHC.IO.Handle.Text.hPutStr'_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbekQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.645763194 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStr_closure" {
     GHC.IO.Handle.Text.hPutStr_closure:
         const GHC.IO.Handle.Text.hPutStr_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStr_entry() //  [R2, R3]
         { info_tbl: [(cbel1,
                       label: GHC.IO.Handle.Text.hPutStr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbel1: // global
           R4 = GHC.Types.False_closure+1;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.649262404 UTC

[section ""data" . GHC.IO.Handle.Text.hPutStrLn_closure" {
     GHC.IO.Handle.Text.hPutStrLn_closure:
         const GHC.IO.Handle.Text.hPutStrLn_info;
         const 0;
 },
 GHC.IO.Handle.Text.hPutStrLn_entry() //  [R2, R3]
         { info_tbl: [(cbeld,
                       label: GHC.IO.Handle.Text.hPutStrLn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeld: // global
           R4 = GHC.Types.True_closure+2;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.652459057 UTC

[section ""cstring" . GHC.IO.Handle.Text.hWaitForInput3_bytes" {
     GHC.IO.Handle.Text.hWaitForInput3_bytes:
         I8[] [104,87,97,105,116,70,111,114,73,110,112,117,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.654923857 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput2_closure" {
     GHC.IO.Handle.Text.hWaitForInput2_closure:
         const GHC.IO.Handle.Text.hWaitForInput2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.Text.hWaitForInput2_entry() //  [R1]
         { info_tbl: [(cbels,
                       label: GHC.IO.Handle.Text.hWaitForInput2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbels: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbelt; else goto cbelu;
       cbelt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbelu: // global
           (_cbelp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbelp::I64 == 0) goto cbelr; else goto cbelq;
       cbelr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbelq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbelp::I64;
           R2 = GHC.IO.Handle.Text.hWaitForInput3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.66237577 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput1_closure" {
     GHC.IO.Handle.Text.hWaitForInput1_closure:
         const GHC.IO.Handle.Text.hWaitForInput1_info;
         const 0;
 },
 lvl34_sbcmX_entry() //  [R1]
         { info_tbl: [(cbelO,
                       label: lvl34_sbcmX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbelO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbelP; else goto cbelQ;
       cbelP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbelQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbelL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubelV; else goto cbelM;
       ubelV: // global
           call _cbelL(R1) args: 0, res: 0, upd: 0;
       cbelM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbelL() //  [R1]
         { info_tbl: [(cbelL,
                       label: block_cbelL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbelL: // global
           R1 = I64[(%MO_S_Lt_W64(I64[R1 + 7],
                                  0) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbcoY_entry() //  [R1, R2]
         { info_tbl: [(cbem4,
                       label: sat_sbcoY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbem4: // global
           if ((Sp + -96) < SpLim) (likely: False) goto cbem8; else goto cbem9;
       cbem8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbem9: // global
           I64[Sp - 24] = block_cbem1_info;
           _sbcmV::P64 = P64[R1 + 6];
           _sbcmX::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbcmV::P64;
           P64[Sp - 8] = _sbcmX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubeoQ; else goto cbem2;
       ubeoQ: // global
           call _cbem1(R1) args: 0, res: 0, upd: 0;
       cbem2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbem1() //  [R1]
         { info_tbl: [(cbem1,
                       label: block_cbem1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbem1: // global
           I64[Sp - 56] = block_cbem7_info;
           _sbcn3::P64 = R1;
           _sbcn4::P64 = P64[R1 + 7];
           _sbcn7::P64 = P64[R1 + 31];
           _sbcn9::P64 = P64[R1 + 47];
           _sbcnb::P64 = P64[R1 + 63];
           _sbcnc::P64 = P64[R1 + 71];
           _sbcnf::P64 = P64[R1 + 95];
           R1 = P64[_sbcnc::P64 + 8];
           P64[Sp - 48] = _sbcn4::P64;
           P64[Sp - 40] = _sbcn7::P64;
           P64[Sp - 32] = _sbcn9::P64;
           P64[Sp - 24] = _sbcnb::P64;
           P64[Sp - 16] = _sbcnc::P64;
           P64[Sp - 8] = _sbcnf::P64;
           P64[Sp] = _sbcn3::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ubeoP; else goto cbemb;
       ubeoP: // global
           call _cbem7(R1) args: 0, res: 0, upd: 0;
       cbemb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbem7() //  [R1]
         { info_tbl: [(cbem7,
                       label: block_cbem7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbem7: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbemn; else goto ubeoL;
       cbemn: // global
           I64[Sp] = block_cbemm_info;
           _sbcnn::P64 = R1;
           R1 = P64[Sp + 72];
           P64[Sp + 72] = _sbcnn::P64;
           if (R1 & 7 != 0) goto ubeoR; else goto cbemo;
       ubeoR: // global
           call _cbemm(R1) args: 0, res: 0, upd: 0;
       cbemo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubeoL: // global
           Sp = Sp + 80;
           call _cbemJ() args: 0, res: 0, upd: 0;
     }
 },
 _cbemm() //  [R1]
         { info_tbl: [(cbemm,
                       label: block_cbemm_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbemm: // global
           if (R1 & 7 == 1) goto cbenj; else goto cbeou;
       cbenj: // global
           _sbcny::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbemu_info;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _sbcny::P64;
           if (R1 & 7 != 0) goto ubeoT; else goto cbenk;
       ubeoT: // global
           call _cbemu(R1) args: 0, res: 0, upd: 0;
       cbenk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbeou: // global
           I64[Sp + 32] = block_cbeos_info;
           R3 = P64[Sp + 72];
           R2 = P64[Sp + 56];
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbemu() //  [R1]
         { info_tbl: [(cbemu,
                       label: block_cbemu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbemu: // global
           if (R1 & 7 == 1) goto cbenE; else goto cbeoe;
       cbenE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbenH; else goto cbenG;
       cbenH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbenG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.IO.Handle.Internals.decodeByteBuf2_closure;
           _sbcny::P64 = P64[Sp + 48];
           P64[Hp] = _sbcny::P64;
           _sbcnb::P64 = P64[Sp + 32];
           _sbcnn::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sbcnb::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcnb::P64);
           I64[Sp] = block_cbens_info;
           R3 = _sbcnn::P64;
           R2 = _sbcny::P64;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       cbeoe: // global
           I64[Sp] = block_cbenR_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubeoU; else goto cbenS;
       ubeoU: // global
           call _cbenR(R1) args: 0, res: 0, upd: 0;
       cbenS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbens() //  [R1]
         { info_tbl: [(cbens,
                       label: block_cbens_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbens: // global
           I64[Sp] = block_cbenu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubeoY; else goto cbenv;
       ubeoY: // global
           call _cbenu(R1) args: 0, res: 0, upd: 0;
       cbenv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbenu() //  [R1]
         { info_tbl: [(cbenu,
                       label: block_cbenu_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbenu: // global
           _sbcn9::P64 = P64[Sp + 24];
           _sbcok::P64 = P64[R1 + 15];
           _sbcol::P64 = P64[R1 + 23];
           call MO_WriteBarrier();
           P64[_sbcn9::P64 + 8] = _sbcok::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcn9::P64);
           I64[Sp] = block_cbenC_info;
           R1 = _sbcol::P64;
           if (R1 & 7 != 0) goto ubeoZ; else goto cbenK;
       ubeoZ: // global
           call _cbenC(R1) args: 0, res: 0, upd: 0;
       cbenK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbenC() //  [R1]
         { info_tbl: [(cbenC,
                       label: block_cbenC_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbenC: // global
           I64[Sp + 72] = I64[R1 + 23];
           P64[Sp + 48] = P64[R1 + 7];
           P64[Sp + 32] = P64[R1 + 15];
           I64[Sp + 24] = I64[R1 + 31];
           I64[Sp] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           Sp = Sp - 16;
           call _cbemw() args: 0, res: 0, upd: 0;
     }
 },
 _cbenR() //  [R1]
         { info_tbl: [(cbenR,
                       label: block_cbenR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbenR: // global
           I64[Sp - 16] = block_cbenW_info;
           _sbcow::P64 = P64[R1 + 7];
           _sbcox::P64 = P64[R1 + 15];
           R1 = P64[R1 + 31];
           P64[Sp - 8] = _sbcox::P64;
           P64[Sp] = _sbcow::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbenW() //  [R1]
         { info_tbl: [(cbenW,
                       label: block_cbenW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbenW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbeoi; else goto cbeoh;
       cbeoi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbeoh: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           _sbcny::P64 = P64[Sp + 64];
           P64[Hp] = _sbcny::P64;
           _sbcnb::P64 = P64[Sp + 48];
           _sbcnn::P64 = P64[Sp + 88];
           _sbcow::P64 = P64[Sp + 16];
           _sbcox::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbcnb::P64 + 8] = Hp - 15;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcnb::P64);
           I64[Sp + 16] = block_cbeo2_info;
           R5 = _sbcnn::P64;
           R4 = _sbcny::P64;
           R3 = _sbcox::P64;
           R2 = _sbcow::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbeo2() //  [R1]
         { info_tbl: [(cbeo2,
                       label: block_cbeo2_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeo2: // global
           I64[Sp] = block_cbeo4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubep1; else goto cbeo5;
       ubep1: // global
           call _cbeo4(R1) args: 0, res: 0, upd: 0;
       cbeo5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbeo4() //  [R1]
         { info_tbl: [(cbeo4,
                       label: block_cbeo4_info
                       rep:StackRep [False, False, False, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeo4: // global
           _sbcn9::P64 = P64[Sp + 24];
           _sbcoK::P64 = P64[R1 + 7];
           _sbcoL::P64 = P64[R1 + 15];
           call MO_WriteBarrier();
           P64[_sbcn9::P64 + 8] = _sbcoK::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcn9::P64);
           I64[Sp] = block_cbeoc_info;
           R1 = _sbcoL::P64;
           if (R1 & 7 != 0) goto ubep2; else goto cbeol;
       ubep2: // global
           call _cbeoc(R1) args: 0, res: 0, upd: 0;
       cbeol: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbeoc() //  [R1]
         { info_tbl: [(cbeoc,
                       label: block_cbeoc_info
                       rep:StackRep [False, False, True, True, False, True, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeoc: // global
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 24] = I64[R1 + 31];
           P64[Sp + 32] = P64[R1 + 15];
           P64[Sp + 48] = P64[R1 + 7];
           I64[Sp + 72] = I64[R1 + 23];
           Sp = Sp - 16;
           call _cbemw() args: 0, res: 0, upd: 0;
     }
 },
 _cbemw() //  []
         { info_tbl: [(cbemw,
                       label: block_cbemw_info
                       rep:StackRep [True, True, False, False, True, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbemw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbemB; else goto cbemA;
       cbemB: // global
           HpAlloc = 56;
           I64[Sp] = block_cbemw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbemA: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 48];
           I64[Hp - 24] = I64[Sp + 88];
           I64[Hp - 16] = I64[Sp + 40];
           _sbcnF::I64 = I64[Sp + 16];
           I64[Hp - 8] = _sbcnF::I64;
           _sbcnG::I64 = I64[Sp + 8];
           I64[Hp] = _sbcnG::I64;
           _sbcmV::P64 = P64[Sp + 80];
           _sbcn4::P64 = P64[Sp + 24];
           _sbcn7::P64 = P64[Sp + 32];
           _sbcnc::P64 = P64[Sp + 56];
           call MO_WriteBarrier();
           P64[_sbcnc::P64 + 8] = Hp - 47;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcnc::P64);
           if (_sbcnF::I64 == _sbcnG::I64) goto cbemP; else goto ubeoO;
       cbemP: // global
           I64[Sp + 48] = block_cbemM_info;
           R2 = _sbcn4::P64;
           I64[Sp + 16] = stg_ap_pppv_info;
           P64[Sp + 24] = _sbcn7::P64;
           P64[Sp + 32] = GHC.Types.False_closure+1;
           P64[Sp + 40] = _sbcmV::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.ready_entry(R2) args: 40, res: 8, upd: 8;
       ubeoO: // global
           Sp = Sp + 96;
           call _cbemJ() args: 0, res: 0, upd: 0;
     }
 },
 _cbemM() //  [R1]
         { info_tbl: [(cbemM,
                       label: block_cbemM_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbemM: // global
           I64[Sp] = block_cbemO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubeoW; else goto cbemR;
       ubeoW: // global
           call _cbemO(R1) args: 0, res: 0, upd: 0;
       cbemR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbemO() //  [R1]
         { info_tbl: [(cbemO,
                       label: block_cbemO_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbemO: // global
           if (R1 & 7 == 1) goto cbemX; else goto cben2;
       cbemX: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cben2: // global
           _sbcnQ::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_cben0_info;
           R1 = _sbcnQ::P64;
           if (R1 & 7 != 0) goto ubeoX; else goto cben3;
       ubeoX: // global
           call _cben0(R1) args: 0, res: 0, upd: 0;
       cben3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cben0() //  [R1]
         { info_tbl: [(cben0,
                       label: block_cben0_info
                       rep:StackRep [False, True, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cben0: // global
           _sbcnT::P64 = P64[R1 + 7];
           _sbcnS::I64 = I64[R1 + 23];
           _sbcnW::I64 = I64[R1 + 39];
           if (_sbcnW::I64 == I64[R1 + 47]) goto cbenf; else goto cbenb;
       cbenf: // global
           I64[Sp] = block_cbene_info;
           R3 = R1;
           R2 = P64[Sp + 24];
           I64[Sp + 24] = _sbcnW::I64;
           P64[Sp + 32] = _sbcnT::P64;
           I64[Sp + 40] = _sbcnS::I64;
           call GHC.IO.Handle.Internals.hLookAhead_2_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
       cbenb: // global
           _sbcnc::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbcnc::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcnc::P64);
           call MO_Touch(_sbcnT::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbene() //  [R1]
         { info_tbl: [(cbene,
                       label: block_cbene_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbene: // global
           _sbcnc::P64 = P64[Sp + 8];
           _sbcnS::I64 = I64[Sp + 40];
           _sbcnT::P64 = P64[Sp + 32];
           _sbcnW::I64 = I64[Sp + 24];
           call MO_WriteBarrier();
           P64[_sbcnc::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcnc::P64);
           call MO_Touch(_sbcnT::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbeos() //  [R1]
         { info_tbl: [(cbeos,
                       label: block_cbeos_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeos: // global
           _sbcnc::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbcnc::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbcnc::P64);
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbemJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbemJ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubep9_srtd" {
     ubep9_srtd:
         const SbcpG_srt+96;
         const 70;
         const 1;
         const 60;
 },
 GHC.IO.Handle.Text.hWaitForInput1_entry() //  [R2, R3]
         { info_tbl: [(cbep4,
                       label: GHC.IO.Handle.Text.hWaitForInput1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbep4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbep8; else goto cbep7;
       cbep8: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.Text.hWaitForInput1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbep7: // global
           I64[Hp - 40] = lvl34_sbcmX_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbcoY_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.Text.hWaitForInput2_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.71022933 UTC

[section ""data" . GHC.IO.Handle.Text.hWaitForInput_closure" {
     GHC.IO.Handle.Text.hWaitForInput_closure:
         const GHC.IO.Handle.Text.hWaitForInput_info;
         const 0;
 },
 GHC.IO.Handle.Text.hWaitForInput_entry() //  [R2, R3]
         { info_tbl: [(cberS,
                       label: GHC.IO.Handle.Text.hWaitForInput_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cberS: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.Text.hWaitForInput1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:11.71403891 UTC

[section ""relreadonly" . SbcpG_srt" {
     SbcpG_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.Text.$willegalBufferSize_closure;
         const GHC.IO.Handle.Internals.$wwantWritableHandle'_closure;
         const GHC.IO.Handle.Text.$whPutChar_closure;
         const GHC.IO.Handle.Text.hPutChar2_closure;
         const GHC.IO.Handle.Text.hPutChar1_closure;
         const GHC.IO.Handle.Text.hPutStr7_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.Text.hGetChar3_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Text.hGetChar2_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.hGetChar6_closure;
         const GHC.IO.Handle.Text.hGetChar1_closure;
         const GHC.IO.Exception.$fExceptionIOException_closure;
         const GHC.IO.Handle.Text.hGetContents3_closure;
         const $wlvl_rb6WI_closure;
         const lvl6_rb6WK_closure;
         const lvl7_rb6WL_closure;
         const lvl9_rb6WN_closure;
         const lvl10_rb6WO_closure;
         const lvl4_rb6WH_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Text.hGetContents2_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle1_closure;
         const GHC.IO.Handle.Text.hGetContents1_closure;
         const GHC.IO.Handle.Internals.ioe_EOF1_closure;
         const GHC.IO.Handle.Text.$whGetLineBufferedLoop_closure;
         const GHC.IO.Handle.Text.hGetLine3_closure;
         const GHC.IO.Handle.Text.hGetLine2_closure;
         const GHC.IO.Handle.Text.hGetLine4_closure;
         const GHC.IO.Handle.Text.hGetLine1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.Text.$wbufReadNBEmpty_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking2_closure;
         const GHC.IO.FD.$fBufferedIOFD8_closure;
         const GHC.IO.FD.$wreadRawBufferPtrNoBlock_closure;
         const lvl11_rb6WR_closure;
         const GHC.IO.Handle.Text.$whGetBufNonBlocking_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking3_closure;
         const GHC.IO.Handle.Text.hGetBufNonBlocking1_closure;
         const GHC.IO.FD.$fBufferedIOFD12_closure;
         const GHC.IO.FD.$wreadRawBufferPtr_closure;
         const GHC.IO.Handle.Text.$whGetBufSome_closure;
         const lvl13_rb6WT_closure;
         const GHC.IO.Handle.Text.hGetBufSome1_closure;
         const GHC.IO.Handle.Text.hGetBuf2_closure;
         const GHC.IO.Handle.Text.hGetBuf4_closure;
         const GHC.IO.Handle.Text.$whGetBuf_closure;
         const GHC.IO.Handle.Text.hGetBuf5_closure;
         const GHC.IO.Handle.Text.hGetBuf1_closure;
         const GHC.Err.error_closure;
         const lvl24_rb6X4_closure;
         const lvl29_rb6X9_closure;
         const GHC.IO.FD.$w$cwriteNonBlocking_closure;
         const GHC.IO.FD.$wfdWrite_closure;
         const GHC.IO.Handle.Text.$wbufWrite_closure;
         const lvl26_rb6X6_closure;
         const lvl30_rb6Xa_closure;
         const GHC.IO.Handle.Text.$whPutBuf'_closure;
         const GHC.IO.Handle.Text.hPutBuf3_closure;
         const GHC.IO.Handle.Text.hPutBuf2_closure;
         const GHC.IO.Handle.Text.hPutBufNonBlocking1_closure;
         const GHC.IO.Handle.Text.hPutBuf1_closure;
         const lvl32_rb6Xc_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.Text.$wwriteBlocks_closure;
         const lvl2_rb6WE_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const GHC.IO.Handle.Text.hPutStr2_closure;
         const GHC.IO.Handle.Text.hPutStr3_closure;
         const GHC.IO.Handle.Text.hPutStr1_closure;
         const GHC.IO.Handle.Text.hPutStr5_closure;
         const GHC.IO.Handle.Text.$whPutChar_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.Internals.decodeByteBuf2_closure;
         const GHC.IO.Handle.Internals.hLookAhead_2_closure;
         const GHC.IO.Handle.Text.hWaitForInput1_closure;
         const GHC.IO.Handle.Text.hWaitForInput2_closure;
 }]

