
==================== Output Cmm ====================
2018-03-16 16:03:43.437233135 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:43.437883249 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule4_bytes" {
     GHC.IO.Encoding.UTF32.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.438501143 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule3_closure" {
     GHC.IO.Encoding.UTF32.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.439124662 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule2_bytes" {
     GHC.IO.Encoding.UTF32.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.439727152 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule1_closure" {
     GHC.IO.Encoding.UTF32.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.440378977 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule_closure" {
     GHC.IO.Encoding.UTF32.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF32.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF32.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.446366155 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le1_info;
 },
 sat_s8AWR_entry() //  [R1]
         { info_tbl: [(c8B9V,
                       label: sat_s8AWR_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8B9V: // global
           _s8AWR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8B9W; else goto c8B9X;
       c8B9X: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8B9Z; else goto c8B9Y;
       c8B9Z: // global
           HpAlloc = 56;
           goto c8B9W;
       c8B9W: // global
           R1 = _s8AWR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8B9Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AWR::P64;
           _s8AWD::I64 = I64[_s8AWR::P64 + 56];
           _s8AWN::I64 = I64[_s8AWR::P64 + 64];
           if (_s8AWN::I64 == _s8AWD::I64) goto c8B9U; else goto c8B9T;
       c8B9U: // global
           _s8AWL::P64 = P64[_s8AWR::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8B9T: // global
           _s8AWz::P64 = P64[_s8AWR::P64 + 16];
           _s8AWA::P64 = P64[_s8AWR::P64 + 24];
           _s8AWy::I64 = I64[_s8AWR::P64 + 40];
           _s8AWB::I64 = I64[_s8AWR::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AWN::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AWZ_entry() //  [R1]
         { info_tbl: [(c8Bah,
                       label: sat_s8AWZ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bah: // global
           _s8AWZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Bai; else goto c8Baj;
       c8Baj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bal; else goto c8Bak;
       c8Bal: // global
           HpAlloc = 56;
           goto c8Bai;
       c8Bai: // global
           R1 = _s8AWZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bak: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AWZ::P64;
           _s8AWD::I64 = I64[_s8AWZ::P64 + 56];
           _s8AWV::I64 = I64[_s8AWZ::P64 + 64];
           if (_s8AWV::I64 == _s8AWD::I64) goto c8Bag; else goto c8Baf;
       c8Bag: // global
           _s8AWL::P64 = P64[_s8AWZ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Baf: // global
           _s8AWz::P64 = P64[_s8AWZ::P64 + 16];
           _s8AWA::P64 = P64[_s8AWZ::P64 + 24];
           _s8AWy::I64 = I64[_s8AWZ::P64 + 40];
           _s8AWB::I64 = I64[_s8AWZ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AWV::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AX7_entry() //  [R1]
         { info_tbl: [(c8BaD,
                       label: sat_s8AX7_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BaD: // global
           _s8AX7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BaE; else goto c8BaF;
       c8BaF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BaH; else goto c8BaG;
       c8BaH: // global
           HpAlloc = 56;
           goto c8BaE;
       c8BaE: // global
           R1 = _s8AX7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BaG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AX7::P64;
           _s8AWD::I64 = I64[_s8AX7::P64 + 56];
           _s8AX3::I64 = I64[_s8AX7::P64 + 64];
           if (_s8AX3::I64 == _s8AWD::I64) goto c8BaC; else goto c8BaB;
       c8BaC: // global
           _s8AWL::P64 = P64[_s8AX7::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BaB: // global
           _s8AWz::P64 = P64[_s8AX7::P64 + 16];
           _s8AWA::P64 = P64[_s8AX7::P64 + 24];
           _s8AWy::I64 = I64[_s8AX7::P64 + 40];
           _s8AWB::I64 = I64[_s8AX7::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AX3::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AXf_entry() //  [R1]
         { info_tbl: [(c8BaZ,
                       label: sat_s8AXf_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BaZ: // global
           _s8AXf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Bb0; else goto c8Bb1;
       c8Bb1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bb3; else goto c8Bb2;
       c8Bb3: // global
           HpAlloc = 56;
           goto c8Bb0;
       c8Bb0: // global
           R1 = _s8AXf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bb2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AXf::P64;
           _s8AWD::I64 = I64[_s8AXf::P64 + 56];
           _s8AXb::I64 = I64[_s8AXf::P64 + 64];
           if (_s8AXb::I64 == _s8AWD::I64) goto c8BaY; else goto c8BaX;
       c8BaY: // global
           _s8AWL::P64 = P64[_s8AXf::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BaX: // global
           _s8AWz::P64 = P64[_s8AXf::P64 + 16];
           _s8AWA::P64 = P64[_s8AXf::P64 + 24];
           _s8AWy::I64 = I64[_s8AXf::P64 + 40];
           _s8AWB::I64 = I64[_s8AXf::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AXb::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AXn_entry() //  [R1]
         { info_tbl: [(c8Bbl,
                       label: sat_s8AXn_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bbl: // global
           _s8AXn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Bbm; else goto c8Bbn;
       c8Bbn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bbp; else goto c8Bbo;
       c8Bbp: // global
           HpAlloc = 56;
           goto c8Bbm;
       c8Bbm: // global
           R1 = _s8AXn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bbo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AXn::P64;
           _s8AWD::I64 = I64[_s8AXn::P64 + 56];
           _s8AXj::I64 = I64[_s8AXn::P64 + 64];
           if (_s8AXj::I64 == _s8AWD::I64) goto c8Bbk; else goto c8Bbj;
       c8Bbk: // global
           _s8AWL::P64 = P64[_s8AXn::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Bbj: // global
           _s8AWz::P64 = P64[_s8AXn::P64 + 16];
           _s8AWA::P64 = P64[_s8AXn::P64 + 24];
           _s8AWy::I64 = I64[_s8AXn::P64 + 40];
           _s8AWB::I64 = I64[_s8AXn::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AXj::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32le1_entry() //  [R2, R3]
         { info_tbl: [(c8Bbs,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bbs: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Bbt; else goto c8Bbu;
       c8Bbt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Bbu: // global
           I64[Sp - 16] = block_c8B9v_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Bh6; else goto c8B9w;
       u8Bh6: // global
           call _c8B9v(R1) args: 0, res: 0, upd: 0;
       c8B9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8B9v() //  [R1]
         { info_tbl: [(c8B9v,
                       label: block_c8B9v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8B9v: // global
           I64[Sp - 40] = block_c8B9A_info;
           _s8AWz::P64 = P64[R1 + 7];
           _s8AWA::P64 = P64[R1 + 15];
           _s8AWy::I64 = I64[R1 + 23];
           _s8AWB::I64 = I64[R1 + 31];
           _s8AWC::I64 = I64[R1 + 39];
           _s8AWD::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8AWA::P64;
           I64[Sp - 24] = _s8AWB::I64;
           I64[Sp - 16] = _s8AWC::I64;
           I64[Sp - 8] = _s8AWD::I64;
           P64[Sp] = _s8AWz::P64;
           I64[Sp + 8] = _s8AWy::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Bh0; else goto c8B9B;
       u8Bh0: // global
           call _c8B9A(R1) args: 0, res: 0, upd: 0;
       c8B9B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8B9A() //  [R1]
         { info_tbl: [(c8B9A,
                       label: block_c8B9A_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8B9A: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bby; else goto c8Bbx;
       c8Bby: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Bbx: // global
           _s8AWG::P64 = P64[R1 + 7];
           _s8AWH::P64 = P64[R1 + 15];
           _s8AWF::I64 = I64[R1 + 23];
           _s8AWI::I64 = I64[R1 + 31];
           _s8AWJ::I64 = I64[R1 + 39];
           _s8AWK::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8AWz::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8AWy::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8AWD::I64 = I64[Sp + 32];
           _c8B9F::P64 = Hp - 47;
           _s8AXs::I64 = _s8AWK::I64;
           _s8AXr::I64 = I64[Sp + 24];
           goto c8BbV;
       c8BbV: // global
           if (%MO_S_Lt_W64(_s8AXr::I64,
                            _s8AWD::I64)) goto c8BcR; else goto c8BcS;
       c8BcR: // global
           if (%MO_S_Ge_W64(_s8AWI::I64 - _s8AXs::I64,
                            4)) goto c8BcO; else goto c8BcP;
       c8BcO: // global
           _s8AXz::I64 = %MO_UU_Conv_W32_W64(I32[_s8AWy::I64 + (_s8AXr::I64 << 2)]);
           call MO_Touch(_s8AWz::P64);
           if (%MO_S_Gt_W64(55296, _s8AXz::I64)) goto c8Bcs; else goto c8BcM;
       c8Bcs: // global
           if (%MO_S_Gt_W64(56320, _s8AXz::I64)) goto c8Bci; else goto c8Bcq;
       c8Bci: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8BbV;
       c8Bcq: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 57343)) goto c8Bco; else goto c8Bcp;
       c8Bco: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8BbV;
       c8Bcp: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8B9F::P64;
           Sp = Sp - 56;
           call _c8B9I() args: 0, res: 0, upd: 0;
       c8BcM: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 56319)) goto c8BcK; else goto c8BcL;
       c8BcK: // global
           if (%MO_S_Gt_W64(56320, _s8AXz::I64)) goto c8BcA; else goto c8BcI;
       c8BcA: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8BbV;
       c8BcI: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 57343)) goto c8BcG; else goto c8BcH;
       c8BcG: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8BbV;
       c8BcH: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8B9F::P64;
           Sp = Sp - 56;
           call _c8Ba4() args: 0, res: 0, upd: 0;
       c8BcL: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8B9F::P64;
           Sp = Sp - 56;
           call _c8Baq() args: 0, res: 0, upd: 0;
       c8BcP: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8B9F::P64;
           Sp = Sp - 56;
           call _c8BaM() args: 0, res: 0, upd: 0;
       c8BcS: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8B9F::P64;
           Sp = Sp - 56;
           call _c8Bb8() args: 0, res: 0, upd: 0;
     }
 },
 _c8B9I() //  []
         { info_tbl: [(c8B9I,
                       label: block_c8B9I_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8B9I: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BbC; else goto c8BbB;
       c8BbC: // global
           HpAlloc = 160;
           I64[Sp] = block_c8B9I_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BbB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AWR_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ba4() //  []
         { info_tbl: [(c8Ba4,
                       label: block_c8Ba4_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ba4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BbG; else goto c8BbF;
       c8BbG: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ba4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BbF: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AWZ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Baq() //  []
         { info_tbl: [(c8Baq,
                       label: block_c8Baq_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Baq: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BbK; else goto c8BbJ;
       c8BbK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Baq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BbJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AX7_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BaM() //  []
         { info_tbl: [(c8BaM,
                       label: block_c8BaM_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BaM: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BbO; else goto c8BbN;
       c8BbO: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BaM_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BbN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AXf_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Bb8() //  []
         { info_tbl: [(c8Bb8,
                       label: block_c8Bb8_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bb8: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BbS; else goto c8BbR;
       c8BbS: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Bb8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BbR: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AXn_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.456450708 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_encode_entry() //  [R2, R3]
         { info_tbl: [(c8Bhb,
                       label: GHC.IO.Encoding.UTF32.utf32le_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bhb: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF32le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.462115154 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF1_info;
 },
 sat_s8AZT_entry() //  [R1]
         { info_tbl: [(c8BhI,
                       label: sat_s8AZT_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BhI: // global
           _s8AZT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BhJ; else goto c8BhK;
       c8BhK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BhM; else goto c8BhL;
       c8BhM: // global
           HpAlloc = 56;
           goto c8BhJ;
       c8BhJ: // global
           R1 = _s8AZT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BhL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AZT::P64;
           _s8AZF::I64 = I64[_s8AZT::P64 + 56];
           _s8AZP::I64 = I64[_s8AZT::P64 + 64];
           if (_s8AZP::I64 == _s8AZF::I64) goto c8BhH; else goto c8BhG;
       c8BhH: // global
           _s8AZN::P64 = P64[_s8AZT::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BhG: // global
           _s8AZB::P64 = P64[_s8AZT::P64 + 16];
           _s8AZC::P64 = P64[_s8AZT::P64 + 24];
           _s8AZA::I64 = I64[_s8AZT::P64 + 40];
           _s8AZD::I64 = I64[_s8AZT::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8AZP::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B01_entry() //  [R1]
         { info_tbl: [(c8Bi4,
                       label: sat_s8B01_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bi4: // global
           _s8B01::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Bi5; else goto c8Bi6;
       c8Bi6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bi8; else goto c8Bi7;
       c8Bi8: // global
           HpAlloc = 56;
           goto c8Bi5;
       c8Bi5: // global
           R1 = _s8B01::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bi7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B01::P64;
           _s8AZF::I64 = I64[_s8B01::P64 + 56];
           _s8AZX::I64 = I64[_s8B01::P64 + 64];
           if (_s8AZX::I64 == _s8AZF::I64) goto c8Bi3; else goto c8Bi2;
       c8Bi3: // global
           _s8AZN::P64 = P64[_s8B01::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Bi2: // global
           _s8AZB::P64 = P64[_s8B01::P64 + 16];
           _s8AZC::P64 = P64[_s8B01::P64 + 24];
           _s8AZA::I64 = I64[_s8B01::P64 + 40];
           _s8AZD::I64 = I64[_s8B01::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8AZX::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B09_entry() //  [R1]
         { info_tbl: [(c8Biq,
                       label: sat_s8B09_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Biq: // global
           _s8B09::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Bir; else goto c8Bis;
       c8Bis: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Biu; else goto c8Bit;
       c8Biu: // global
           HpAlloc = 56;
           goto c8Bir;
       c8Bir: // global
           R1 = _s8B09::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bit: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B09::P64;
           _s8AZF::I64 = I64[_s8B09::P64 + 56];
           _s8B05::I64 = I64[_s8B09::P64 + 64];
           if (_s8B05::I64 == _s8AZF::I64) goto c8Bip; else goto c8Bio;
       c8Bip: // global
           _s8AZN::P64 = P64[_s8B09::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Bio: // global
           _s8AZB::P64 = P64[_s8B09::P64 + 16];
           _s8AZC::P64 = P64[_s8B09::P64 + 24];
           _s8AZA::I64 = I64[_s8B09::P64 + 40];
           _s8AZD::I64 = I64[_s8B09::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B05::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B0h_entry() //  [R1]
         { info_tbl: [(c8BiM,
                       label: sat_s8B0h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BiM: // global
           _s8B0h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BiN; else goto c8BiO;
       c8BiO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BiQ; else goto c8BiP;
       c8BiQ: // global
           HpAlloc = 56;
           goto c8BiN;
       c8BiN: // global
           R1 = _s8B0h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BiP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B0h::P64;
           _s8AZF::I64 = I64[_s8B0h::P64 + 56];
           _s8B0d::I64 = I64[_s8B0h::P64 + 64];
           if (_s8B0d::I64 == _s8AZF::I64) goto c8BiL; else goto c8BiK;
       c8BiL: // global
           _s8AZN::P64 = P64[_s8B0h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BiK: // global
           _s8AZB::P64 = P64[_s8B0h::P64 + 16];
           _s8AZC::P64 = P64[_s8B0h::P64 + 24];
           _s8AZA::I64 = I64[_s8B0h::P64 + 40];
           _s8AZD::I64 = I64[_s8B0h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B0d::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B0p_entry() //  [R1]
         { info_tbl: [(c8Bj8,
                       label: sat_s8B0p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bj8: // global
           _s8B0p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Bj9; else goto c8Bja;
       c8Bja: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bjc; else goto c8Bjb;
       c8Bjc: // global
           HpAlloc = 56;
           goto c8Bj9;
       c8Bj9: // global
           R1 = _s8B0p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bjb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B0p::P64;
           _s8AZF::I64 = I64[_s8B0p::P64 + 56];
           _s8B0l::I64 = I64[_s8B0p::P64 + 64];
           if (_s8B0l::I64 == _s8AZF::I64) goto c8Bj7; else goto c8Bj6;
       c8Bj7: // global
           _s8AZN::P64 = P64[_s8B0p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Bj6: // global
           _s8AZB::P64 = P64[_s8B0p::P64 + 16];
           _s8AZC::P64 = P64[_s8B0p::P64 + 24];
           _s8AZA::I64 = I64[_s8B0p::P64 + 40];
           _s8AZD::I64 = I64[_s8B0p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B0l::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8Bjf,
                       label: GHC.IO.Encoding.UTF32.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bjf: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Bjg; else goto c8Bjh;
       c8Bjg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Bjh: // global
           I64[Sp - 16] = block_c8Bhi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8BoT; else goto c8Bhj;
       u8BoT: // global
           call _c8Bhi(R1) args: 0, res: 0, upd: 0;
       c8Bhj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Bhi() //  [R1]
         { info_tbl: [(c8Bhi,
                       label: block_c8Bhi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bhi: // global
           I64[Sp - 40] = block_c8Bhn_info;
           _s8AZB::P64 = P64[R1 + 7];
           _s8AZC::P64 = P64[R1 + 15];
           _s8AZA::I64 = I64[R1 + 23];
           _s8AZD::I64 = I64[R1 + 31];
           _s8AZE::I64 = I64[R1 + 39];
           _s8AZF::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8AZC::P64;
           I64[Sp - 24] = _s8AZD::I64;
           I64[Sp - 16] = _s8AZE::I64;
           I64[Sp - 8] = _s8AZF::I64;
           P64[Sp] = _s8AZB::P64;
           I64[Sp + 8] = _s8AZA::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8BoN; else goto c8Bho;
       u8BoN: // global
           call _c8Bhn(R1) args: 0, res: 0, upd: 0;
       c8Bho: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Bhn() //  [R1]
         { info_tbl: [(c8Bhn,
                       label: block_c8Bhn_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bhn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bjl; else goto c8Bjk;
       c8Bjl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Bjk: // global
           _s8AZI::P64 = P64[R1 + 7];
           _s8AZJ::P64 = P64[R1 + 15];
           _s8AZH::I64 = I64[R1 + 23];
           _s8AZK::I64 = I64[R1 + 31];
           _s8AZL::I64 = I64[R1 + 39];
           _s8AZM::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8AZB::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8AZA::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8AZF::I64 = I64[Sp + 32];
           _c8Bhs::P64 = Hp - 47;
           _s8B0u::I64 = _s8AZM::I64;
           _s8B0t::I64 = I64[Sp + 24];
           goto c8BjI;
       c8BjI: // global
           if (%MO_S_Lt_W64(_s8B0t::I64,
                            _s8AZF::I64)) goto c8BkE; else goto c8BkF;
       c8BkE: // global
           if (%MO_S_Ge_W64(_s8AZK::I64 - _s8B0u::I64,
                            4)) goto c8BkB; else goto c8BkC;
       c8BkB: // global
           _s8B0B::I64 = %MO_UU_Conv_W32_W64(I32[_s8AZA::I64 + (_s8B0t::I64 << 2)]);
           call MO_Touch(_s8AZB::P64);
           if (%MO_S_Gt_W64(55296, _s8B0B::I64)) goto c8Bkf; else goto c8Bkz;
       c8Bkf: // global
           if (%MO_S_Gt_W64(56320, _s8B0B::I64)) goto c8Bk5; else goto c8Bkd;
       c8Bk5: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8BjI;
       c8Bkd: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 57343)) goto c8Bkb; else goto c8Bkc;
       c8Bkb: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8BjI;
       c8Bkc: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Bhs::P64;
           Sp = Sp - 56;
           call _c8Bhv() args: 0, res: 0, upd: 0;
       c8Bkz: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 56319)) goto c8Bkx; else goto c8Bky;
       c8Bkx: // global
           if (%MO_S_Gt_W64(56320, _s8B0B::I64)) goto c8Bkn; else goto c8Bkv;
       c8Bkn: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8BjI;
       c8Bkv: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 57343)) goto c8Bkt; else goto c8Bku;
       c8Bkt: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8BjI;
       c8Bku: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Bhs::P64;
           Sp = Sp - 56;
           call _c8BhR() args: 0, res: 0, upd: 0;
       c8Bky: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Bhs::P64;
           Sp = Sp - 56;
           call _c8Bid() args: 0, res: 0, upd: 0;
       c8BkC: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Bhs::P64;
           Sp = Sp - 56;
           call _c8Biz() args: 0, res: 0, upd: 0;
       c8BkF: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Bhs::P64;
           Sp = Sp - 56;
           call _c8BiV() args: 0, res: 0, upd: 0;
     }
 },
 _c8Bhv() //  []
         { info_tbl: [(c8Bhv,
                       label: block_c8Bhv_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bhv: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Bjp; else goto c8Bjo;
       c8Bjp: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Bhv_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Bjo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AZT_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BhR() //  []
         { info_tbl: [(c8BhR,
                       label: block_c8BhR_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BhR: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Bjt; else goto c8Bjs;
       c8Bjt: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BhR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Bjs: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B01_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Bid() //  []
         { info_tbl: [(c8Bid,
                       label: block_c8Bid_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bid: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Bjx; else goto c8Bjw;
       c8Bjx: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Bid_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Bjw: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B09_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Biz() //  []
         { info_tbl: [(c8Biz,
                       label: block_c8Biz_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Biz: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BjB; else goto c8BjA;
       c8BjB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Biz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BjA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B0h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BiV() //  []
         { info_tbl: [(c8BiV,
                       label: block_c8BiV_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BiV: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BjF; else goto c8BjE;
       c8BjF: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BiV_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BjE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B0p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.47082043 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_encode_entry() //  [R2, R3]
         { info_tbl: [(c8BoY,
                       label: GHC.IO.Encoding.UTF32.utf32be_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BoY: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.474890964 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF3_closure" {
     GHC.IO.Encoding.UTF32.mkUTF3_closure:
         const GHC.IO.Encoding.UTF32.mkUTF3_info;
 },
 sat_s8B2V_entry() //  [R1]
         { info_tbl: [(c8Bpv,
                       label: sat_s8B2V_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bpv: // global
           _s8B2V::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Bpw; else goto c8Bpx;
       c8Bpx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bpz; else goto c8Bpy;
       c8Bpz: // global
           HpAlloc = 56;
           goto c8Bpw;
       c8Bpw: // global
           R1 = _s8B2V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bpy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B2V::P64;
           _s8B2H::I64 = I64[_s8B2V::P64 + 56];
           _s8B2R::I64 = I64[_s8B2V::P64 + 64];
           if (_s8B2R::I64 == _s8B2H::I64) goto c8Bpu; else goto c8Bpt;
       c8Bpu: // global
           _s8B2P::P64 = P64[_s8B2V::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Bpt: // global
           _s8B2D::P64 = P64[_s8B2V::P64 + 16];
           _s8B2E::P64 = P64[_s8B2V::P64 + 24];
           _s8B2C::I64 = I64[_s8B2V::P64 + 40];
           _s8B2F::I64 = I64[_s8B2V::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B2R::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B33_entry() //  [R1]
         { info_tbl: [(c8BpR,
                       label: sat_s8B33_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BpR: // global
           _s8B33::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BpS; else goto c8BpT;
       c8BpT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BpV; else goto c8BpU;
       c8BpV: // global
           HpAlloc = 56;
           goto c8BpS;
       c8BpS: // global
           R1 = _s8B33::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BpU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B33::P64;
           _s8B2H::I64 = I64[_s8B33::P64 + 56];
           _s8B2Z::I64 = I64[_s8B33::P64 + 64];
           if (_s8B2Z::I64 == _s8B2H::I64) goto c8BpQ; else goto c8BpP;
       c8BpQ: // global
           _s8B2P::P64 = P64[_s8B33::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BpP: // global
           _s8B2D::P64 = P64[_s8B33::P64 + 16];
           _s8B2E::P64 = P64[_s8B33::P64 + 24];
           _s8B2C::I64 = I64[_s8B33::P64 + 40];
           _s8B2F::I64 = I64[_s8B33::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B2Z::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B3U_entry() //  [R1]
         { info_tbl: [(c8Brv,
                       label: sat_s8B3U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Brv: // global
           _s8B3U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Brw; else goto c8Brx;
       c8Brx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Brz; else goto c8Bry;
       c8Brz: // global
           HpAlloc = 56;
           goto c8Brw;
       c8Brw: // global
           R1 = _s8B3U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bry: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B3U::P64;
           _s8B2H::I64 = I64[_s8B3U::P64 + 56];
           _s8B37::I64 = I64[_s8B3U::P64 + 64];
           if (_s8B37::I64 == _s8B2H::I64) goto c8Bru; else goto c8Brt;
       c8Bru: // global
           _s8B2P::P64 = P64[_s8B3U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Brt: // global
           _s8B2D::P64 = P64[_s8B3U::P64 + 16];
           _s8B2E::P64 = P64[_s8B3U::P64 + 24];
           _s8B2C::I64 = I64[_s8B3U::P64 + 40];
           _s8B2F::I64 = I64[_s8B3U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B37::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B3Z_entry() //  [R1]
         { info_tbl: [(c8BrQ,
                       label: sat_s8B3Z_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BrQ: // global
           _s8B3Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BrR; else goto c8BrS;
       c8BrS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BrU; else goto c8BrT;
       c8BrU: // global
           HpAlloc = 56;
           goto c8BrR;
       c8BrR: // global
           R1 = _s8B3Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BrT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B3Z::P64;
           _s8B2H::I64 = I64[_s8B3Z::P64 + 56];
           _s8B37::I64 = I64[_s8B3Z::P64 + 64];
           if (_s8B37::I64 == _s8B2H::I64) goto c8BrP; else goto c8BrO;
       c8BrP: // global
           _s8B2P::P64 = P64[_s8B3Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BrO: // global
           _s8B2D::P64 = P64[_s8B3Z::P64 + 16];
           _s8B2E::P64 = P64[_s8B3Z::P64 + 24];
           _s8B2C::I64 = I64[_s8B3Z::P64 + 40];
           _s8B2F::I64 = I64[_s8B3Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B37::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF3_entry() //  [R2, R3]
         { info_tbl: [(c8BrX,
                       label: GHC.IO.Encoding.UTF32.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BrX: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8BrY; else goto c8BrZ;
       c8BrY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8BrZ: // global
           I64[Sp - 16] = block_c8Bp5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Bt5; else goto c8Bp6;
       u8Bt5: // global
           call _c8Bp5(R1) args: 0, res: 0, upd: 0;
       c8Bp6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Bp5() //  [R1]
         { info_tbl: [(c8Bp5,
                       label: block_c8Bp5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bp5: // global
           I64[Sp - 40] = block_c8Bpa_info;
           _s8B2D::P64 = P64[R1 + 7];
           _s8B2E::P64 = P64[R1 + 15];
           _s8B2C::I64 = I64[R1 + 23];
           _s8B2F::I64 = I64[R1 + 31];
           _s8B2G::I64 = I64[R1 + 39];
           _s8B2H::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8B2E::P64;
           I64[Sp - 24] = _s8B2F::I64;
           I64[Sp - 16] = _s8B2G::I64;
           I64[Sp - 8] = _s8B2H::I64;
           P64[Sp] = _s8B2D::P64;
           I64[Sp + 8] = _s8B2C::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8BsX; else goto c8Bpb;
       u8BsX: // global
           call _c8Bpa(R1) args: 0, res: 0, upd: 0;
       c8Bpb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Bpa() //  [R1]
         { info_tbl: [(c8Bpa,
                       label: block_c8Bpa_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bpa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bs3; else goto c8Bs2;
       c8Bs3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Bs2: // global
           _s8B2K::P64 = P64[R1 + 7];
           _s8B2L::P64 = P64[R1 + 15];
           _s8B2J::I64 = I64[R1 + 23];
           _s8B2M::I64 = I64[R1 + 31];
           _s8B2N::I64 = I64[R1 + 39];
           _s8B2O::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8B2K::P64;
           P64[Sp - 40] = _s8B2L::P64;
           I64[Sp - 32] = _s8B2M::I64;
           I64[Sp - 24] = _s8B2N::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8B2O::I64;
           I64[Sp] = _s8B2J::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8Bq0() args: 0, res: 0, upd: 0;
     }
 },
 _c8Bq0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bq0: // global
           _s8B37::I64 = I64[Sp + 32];
           _s8B38::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8B38::I64,
                            I64[Sp + 16])) goto c8BsI; else goto c8BsJ;
       c8BsI: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8B37::I64,
                            4)) goto c8BsF; else goto c8BsG;
       c8BsF: // global
           _s8B2C::I64 = I64[Sp + 96];
           _s8B2D::P64 = P64[Sp + 88];
           _s8B3g::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + _s8B37::I64]);
           call MO_Touch(_s8B2D::P64);
           _s8B3m::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 1)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3s::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 2)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3y::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 3)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3A::I64 = (_s8B3y::I64 << 24) + ((_s8B3s::I64 << 16) + ((_s8B3m::I64 << 8) + _s8B3g::I64));
           if (%MO_S_Lt_W64(_s8B3A::I64, 0)) goto u8BsQ; else goto c8BsD;
       u8BsQ: // global
           I64[Sp - 16] = _s8B3A::I64;
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 24;
           goto u8Bt1;
       c8BsD: // global
           if (%MO_S_Ge_W64(_s8B3A::I64, 55296)) goto u8BsS; else goto u8BsR;
       u8BsS: // global
           I64[Sp - 16] = _s8B3A::I64;
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 24;
           goto u8Bt1;
       u8Bt1: // global
           call _c8Brg() args: 0, res: 0, upd: 0;
       u8BsR: // global
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 8;
           call _s8B3M() args: 0, res: 0, upd: 0;
       c8BsG: // global
           I64[Sp + 32] = _s8B38::I64;
           I64[Sp + 40] = _s8B37::I64;
           Sp = Sp - 8;
           call _c8Bpi() args: 0, res: 0, upd: 0;
       c8BsJ: // global
           I64[Sp + 32] = _s8B38::I64;
           I64[Sp + 40] = _s8B37::I64;
           Sp = Sp - 8;
           call _c8BpE() args: 0, res: 0, upd: 0;
     }
 },
 _c8Brg() //  []
         { info_tbl: [(c8Brg,
                       label: block_c8Brg_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Brg: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Bsj; else goto c8Bsi;
       c8Bsj: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Brg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Bsi: // global
           _c8Bpf::P64 = P64[Sp + 96];
           _s8B2C::I64 = I64[Sp + 120];
           _s8B2D::P64 = P64[Sp + 112];
           _s8B2E::P64 = P64[Sp + 80];
           _s8B2F::I64 = I64[Sp + 88];
           _s8B2H::I64 = I64[Sp + 104];
           _s8B2J::I64 = I64[Sp + 72];
           _s8B2K::P64 = P64[Sp + 24];
           _s8B2L::P64 = P64[Sp + 32];
           _s8B2M::I64 = I64[Sp + 40];
           _s8B2N::I64 = I64[Sp + 48];
           _s8B37::I64 = I64[Sp + 56];
           _s8B38::I64 = I64[Sp + 64];
           _s8B3L::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8B3L::I64, 57343)) goto c8Bsm; else goto c8Bsr;
       c8Bsm: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B2K::P64;
           P64[Hp - 136] = _s8B2L::P64;
           I64[Hp - 128] = _s8B2J::I64;
           I64[Hp - 120] = _s8B2M::I64;
           I64[Hp - 112] = _s8B2N::I64;
           I64[Hp - 104] = _s8B38::I64;
           I64[Hp - 96] = sat_s8B3U_info;
           P64[Hp - 80] = _s8B2D::P64;
           P64[Hp - 72] = _s8B2E::P64;
           P64[Hp - 64] = _c8Bpf::P64;
           I64[Hp - 56] = _s8B2C::I64;
           I64[Hp - 48] = _s8B2F::I64;
           I64[Hp - 40] = _s8B2H::I64;
           I64[Hp - 32] = _s8B37::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Bsr: // global
           if (%MO_S_Gt_W64(_s8B3L::I64,
                            1114111)) goto c8Bsp; else goto c8Bsq;
       c8Bsp: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B2K::P64;
           P64[Hp - 136] = _s8B2L::P64;
           I64[Hp - 128] = _s8B2J::I64;
           I64[Hp - 120] = _s8B2M::I64;
           I64[Hp - 112] = _s8B2N::I64;
           I64[Hp - 104] = _s8B38::I64;
           I64[Hp - 96] = sat_s8B3Z_info;
           P64[Hp - 80] = _s8B2D::P64;
           P64[Hp - 72] = _s8B2E::P64;
           P64[Hp - 64] = _c8Bpf::P64;
           I64[Hp - 56] = _s8B2C::I64;
           I64[Hp - 48] = _s8B2F::I64;
           I64[Hp - 40] = _s8B2H::I64;
           I64[Hp - 32] = _s8B37::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Bsq: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8B3M() args: 0, res: 0, upd: 0;
     }
 },
 _s8B3M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8B3M: // global
           _s8B2K::P64 = P64[Sp + 8];
           _s8B37::I64 = I64[Sp + 40];
           _s8B38::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8B38::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8B2K::P64);
           I64[Sp + 40] = _s8B37::I64 + 4;
           I64[Sp + 48] = _s8B38::I64 + 1;
           Sp = Sp + 8;
           call _c8Bq0() args: 0, res: 0, upd: 0;
     }
 },
 _c8Bpi() //  []
         { info_tbl: [(c8Bpi,
                       label: block_c8Bpi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bpi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Bs7; else goto c8Bs6;
       c8Bs7: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Bpi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Bs6: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B2V_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BpE() //  []
         { info_tbl: [(c8BpE,
                       label: block_c8BpE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BpE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Bsb; else goto c8Bsa;
       c8Bsb: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BpE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Bsa: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B33_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.481508178 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_decode_entry() //  [R2, R3]
         { info_tbl: [(c8Btb,
                       label: GHC.IO.Encoding.UTF32.utf32le_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Btb: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.482221537 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32le3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32le3_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.483035729 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le2_entry() //  [R1]
         { info_tbl: [(c8Btk,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Btk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Btl; else goto c8Btm;
       c8Btl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Btm: // global
           (_c8Bth::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Bth::I64 == 0) goto c8Btj; else goto c8Bti;
       c8Btj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Bti: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Bth::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.48405123 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF2_entry() //  []
         { info_tbl: [(c8Btr,
                       label: GHC.IO.Encoding.UTF32.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Btr: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.484887792 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be1_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be1_entry() //  []
         { info_tbl: [(c8Bty,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bty: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.486392481 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le_info;
         const 0;
 },
 sat_s8B4d_entry() //  [R1, R2, R3]
         { info_tbl: [(c8BtP,
                       label: sat_s8B4d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BtP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B4f_entry() //  [R1]
         { info_tbl: [(c8BtT,
                       label: sat_s8B4f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BtT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8BtX; else goto c8BtW;
       c8BtX: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8BtW: // global
           _s8B47::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B4d_info;
           P64[Hp - 48] = _s8B47::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B49_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Bu8,
                       label: sat_s8B49_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bu8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B4b_entry() //  [R1]
         { info_tbl: [(c8Buc,
                       label: sat_s8B4b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Buc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Bug; else goto c8Buf;
       c8Bug: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Buf: // global
           _s8B47::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B49_info;
           P64[Hp - 48] = _s8B47::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32le_entry() //  [R2]
         { info_tbl: [(c8Bui,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bui: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Bum; else goto c8Bul;
       c8Bum: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Bul: // global
           I64[Hp - 56] = sat_s8B4f_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B4b_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.4885799 UTC

[section ""data" . lvl_r8AWo_closure" {
     lvl_r8AWo_closure:
         const lvl_r8AWo_info;
         const 0;
 },
 lvl_r8AWo_entry() //  [R2, R3]
         { info_tbl: [(c8Buv,
                       label: lvl_r8AWo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Buv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Buz; else goto c8BuA;
       c8Buz: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8AWo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8BuA: // global
           I64[Sp - 16] = block_c8Bus_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8BuI; else goto c8But;
       u8BuI: // global
           call _c8Bus() args: 0, res: 0, upd: 0;
       c8But: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Bus() //  []
         { info_tbl: [(c8Bus,
                       label: block_c8Bus_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bus: // global
           _s8B4h::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Buy_info;
           R1 = _s8B4h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8BuH; else goto c8BuC;
       u8BuH: // global
           call _c8Buy() args: 0, res: 0, upd: 0;
       c8BuC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Buy() //  []
         { info_tbl: [(c8Buy,
                       label: block_c8Buy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Buy: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.48981896 UTC

[section ""data" . lvl1_r8AWp_closure" {
     lvl1_r8AWp_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.490484036 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le2_closure" {
     GHC.IO.Encoding.UTF32.utf32le2_closure:
         const GHC.IO.Encoding.UTF32.utf32le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le2_entry() //  []
         { info_tbl: [(c8BuN,
                       label: GHC.IO.Encoding.UTF32.utf32le2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BuN: // global
           R1 = lvl1_r8AWp_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.49158919 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be2_closure" {
     GHC.IO.Encoding.UTF32.utf32be2_closure:
         const GHC.IO.Encoding.UTF32.utf32be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be2_entry() //  [R2, R3]
         { info_tbl: [(c8BuX,
                       label: GHC.IO.Encoding.UTF32.utf32be2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BuX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Bv1; else goto c8Bv2;
       c8Bv1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Bv2: // global
           I64[Sp - 16] = block_c8BuU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Bvb; else goto c8BuV;
       u8Bvb: // global
           call _c8BuU(R1) args: 0, res: 0, upd: 0;
       c8BuV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BuU() //  [R1]
         { info_tbl: [(c8BuU,
                       label: block_c8BuU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BuU: // global
           I64[Sp - 16] = block_c8Bv0_info;
           _s8B4D::P64 = P64[R1 + 7];
           _s8B4C::I64 = I64[R1 + 23];
           _s8B4G::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8B4G::I64;
           P64[Sp] = _s8B4D::P64;
           I64[Sp + 8] = _s8B4C::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Bva; else goto c8Bv4;
       u8Bva: // global
           call _c8Bv0() args: 0, res: 0, upd: 0;
       c8Bv4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Bv0() //  []
         { info_tbl: [(c8Bv0,
                       label: block_c8Bv0_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bv0: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.492865407 UTC

[section ""data" . lvl2_r8AWq_closure" {
     lvl2_r8AWq_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.493613978 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le1_closure" {
     GHC.IO.Encoding.UTF32.utf32le1_closure:
         const GHC.IO.Encoding.UTF32.utf32le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le1_entry() //  []
         { info_tbl: [(c8Bvg,
                       label: GHC.IO.Encoding.UTF32.utf32le1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bvg: // global
           R1 = lvl2_r8AWq_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.494375122 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_closure" {
     GHC.IO.Encoding.UTF32.utf32le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.UTF32.utf32le2_closure+1;
         const GHC.IO.Encoding.UTF32.utf32le1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.498277201 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF5_closure" {
     GHC.IO.Encoding.UTF32.mkUTF5_closure:
         const GHC.IO.Encoding.UTF32.mkUTF5_info;
 },
 sat_s8B5h_entry() //  [R1]
         { info_tbl: [(c8BvN,
                       label: sat_s8B5h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BvN: // global
           _s8B5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BvO; else goto c8BvP;
       c8BvP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BvR; else goto c8BvQ;
       c8BvR: // global
           HpAlloc = 56;
           goto c8BvO;
       c8BvO: // global
           R1 = _s8B5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BvQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B5h::P64;
           _s8B53::I64 = I64[_s8B5h::P64 + 56];
           _s8B5d::I64 = I64[_s8B5h::P64 + 64];
           if (_s8B5d::I64 == _s8B53::I64) goto c8BvM; else goto c8BvL;
       c8BvM: // global
           _s8B5b::P64 = P64[_s8B5h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BvL: // global
           _s8B4Z::P64 = P64[_s8B5h::P64 + 16];
           _s8B50::P64 = P64[_s8B5h::P64 + 24];
           _s8B4Y::I64 = I64[_s8B5h::P64 + 40];
           _s8B51::I64 = I64[_s8B5h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5d::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B5p_entry() //  [R1]
         { info_tbl: [(c8Bw9,
                       label: sat_s8B5p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bw9: // global
           _s8B5p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Bwa; else goto c8Bwb;
       c8Bwb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Bwd; else goto c8Bwc;
       c8Bwd: // global
           HpAlloc = 56;
           goto c8Bwa;
       c8Bwa: // global
           R1 = _s8B5p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bwc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B5p::P64;
           _s8B53::I64 = I64[_s8B5p::P64 + 56];
           _s8B5l::I64 = I64[_s8B5p::P64 + 64];
           if (_s8B5l::I64 == _s8B53::I64) goto c8Bw8; else goto c8Bw7;
       c8Bw8: // global
           _s8B5b::P64 = P64[_s8B5p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Bw7: // global
           _s8B4Z::P64 = P64[_s8B5p::P64 + 16];
           _s8B50::P64 = P64[_s8B5p::P64 + 24];
           _s8B4Y::I64 = I64[_s8B5p::P64 + 40];
           _s8B51::I64 = I64[_s8B5p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5l::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B6g_entry() //  [R1]
         { info_tbl: [(c8BxN,
                       label: sat_s8B6g_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BxN: // global
           _s8B6g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BxO; else goto c8BxP;
       c8BxP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BxR; else goto c8BxQ;
       c8BxR: // global
           HpAlloc = 56;
           goto c8BxO;
       c8BxO: // global
           R1 = _s8B6g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BxQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B6g::P64;
           _s8B53::I64 = I64[_s8B6g::P64 + 56];
           _s8B5t::I64 = I64[_s8B6g::P64 + 64];
           if (_s8B5t::I64 == _s8B53::I64) goto c8BxM; else goto c8BxL;
       c8BxM: // global
           _s8B5b::P64 = P64[_s8B6g::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BxL: // global
           _s8B4Z::P64 = P64[_s8B6g::P64 + 16];
           _s8B50::P64 = P64[_s8B6g::P64 + 24];
           _s8B4Y::I64 = I64[_s8B6g::P64 + 40];
           _s8B51::I64 = I64[_s8B6g::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5t::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B6l_entry() //  [R1]
         { info_tbl: [(c8By8,
                       label: sat_s8B6l_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8By8: // global
           _s8B6l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8By9; else goto c8Bya;
       c8Bya: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Byc; else goto c8Byb;
       c8Byc: // global
           HpAlloc = 56;
           goto c8By9;
       c8By9: // global
           R1 = _s8B6l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Byb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B6l::P64;
           _s8B53::I64 = I64[_s8B6l::P64 + 56];
           _s8B5t::I64 = I64[_s8B6l::P64 + 64];
           if (_s8B5t::I64 == _s8B53::I64) goto c8By7; else goto c8By6;
       c8By7: // global
           _s8B5b::P64 = P64[_s8B6l::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8By6: // global
           _s8B4Z::P64 = P64[_s8B6l::P64 + 16];
           _s8B50::P64 = P64[_s8B6l::P64 + 24];
           _s8B4Y::I64 = I64[_s8B6l::P64 + 40];
           _s8B51::I64 = I64[_s8B6l::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5t::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF5_entry() //  [R2, R3]
         { info_tbl: [(c8Byf,
                       label: GHC.IO.Encoding.UTF32.mkUTF5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Byf: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8Byg; else goto c8Byh;
       c8Byg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Byh: // global
           I64[Sp - 16] = block_c8Bvn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Bzn; else goto c8Bvo;
       u8Bzn: // global
           call _c8Bvn(R1) args: 0, res: 0, upd: 0;
       c8Bvo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Bvn() //  [R1]
         { info_tbl: [(c8Bvn,
                       label: block_c8Bvn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bvn: // global
           I64[Sp - 40] = block_c8Bvs_info;
           _s8B4Z::P64 = P64[R1 + 7];
           _s8B50::P64 = P64[R1 + 15];
           _s8B4Y::I64 = I64[R1 + 23];
           _s8B51::I64 = I64[R1 + 31];
           _s8B52::I64 = I64[R1 + 39];
           _s8B53::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8B50::P64;
           I64[Sp - 24] = _s8B51::I64;
           I64[Sp - 16] = _s8B52::I64;
           I64[Sp - 8] = _s8B53::I64;
           P64[Sp] = _s8B4Z::P64;
           I64[Sp + 8] = _s8B4Y::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Bzf; else goto c8Bvt;
       u8Bzf: // global
           call _c8Bvs(R1) args: 0, res: 0, upd: 0;
       c8Bvt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Bvs() //  [R1]
         { info_tbl: [(c8Bvs,
                       label: block_c8Bvs_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bvs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Byl; else goto c8Byk;
       c8Byl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Byk: // global
           _s8B56::P64 = P64[R1 + 7];
           _s8B57::P64 = P64[R1 + 15];
           _s8B55::I64 = I64[R1 + 23];
           _s8B58::I64 = I64[R1 + 31];
           _s8B59::I64 = I64[R1 + 39];
           _s8B5a::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8B56::P64;
           P64[Sp - 40] = _s8B57::P64;
           I64[Sp - 32] = _s8B58::I64;
           I64[Sp - 24] = _s8B59::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8B5a::I64;
           I64[Sp] = _s8B55::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8Bwi() args: 0, res: 0, upd: 0;
     }
 },
 _c8Bwi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bwi: // global
           _s8B5t::I64 = I64[Sp + 32];
           _s8B5u::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8B5u::I64,
                            I64[Sp + 16])) goto c8Bz0; else goto c8Bz1;
       c8Bz0: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8B5t::I64,
                            4)) goto c8ByX; else goto c8ByY;
       c8ByX: // global
           _s8B4Y::I64 = I64[Sp + 96];
           _s8B4Z::P64 = P64[Sp + 88];
           _s8B5C::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + _s8B5t::I64]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5I::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 1)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5O::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 2)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5U::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 3)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5W::I64 = (_s8B5C::I64 << 24) + ((_s8B5I::I64 << 16) + ((_s8B5O::I64 << 8) + _s8B5U::I64));
           if (%MO_S_Lt_W64(_s8B5W::I64, 0)) goto u8Bz8; else goto c8ByV;
       u8Bz8: // global
           I64[Sp - 16] = _s8B5W::I64;
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 24;
           goto u8Bzj;
       c8ByV: // global
           if (%MO_S_Ge_W64(_s8B5W::I64, 55296)) goto u8Bza; else goto u8Bz9;
       u8Bza: // global
           I64[Sp - 16] = _s8B5W::I64;
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 24;
           goto u8Bzj;
       u8Bzj: // global
           call _c8Bxy() args: 0, res: 0, upd: 0;
       u8Bz9: // global
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 8;
           call _s8B68() args: 0, res: 0, upd: 0;
       c8ByY: // global
           I64[Sp + 32] = _s8B5u::I64;
           I64[Sp + 40] = _s8B5t::I64;
           Sp = Sp - 8;
           call _c8BvA() args: 0, res: 0, upd: 0;
       c8Bz1: // global
           I64[Sp + 32] = _s8B5u::I64;
           I64[Sp + 40] = _s8B5t::I64;
           Sp = Sp - 8;
           call _c8BvW() args: 0, res: 0, upd: 0;
     }
 },
 _c8Bxy() //  []
         { info_tbl: [(c8Bxy,
                       label: block_c8Bxy_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bxy: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ByB; else goto c8ByA;
       c8ByB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Bxy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ByA: // global
           _c8Bvx::P64 = P64[Sp + 96];
           _s8B4Y::I64 = I64[Sp + 120];
           _s8B4Z::P64 = P64[Sp + 112];
           _s8B50::P64 = P64[Sp + 80];
           _s8B51::I64 = I64[Sp + 88];
           _s8B53::I64 = I64[Sp + 104];
           _s8B55::I64 = I64[Sp + 72];
           _s8B56::P64 = P64[Sp + 24];
           _s8B57::P64 = P64[Sp + 32];
           _s8B58::I64 = I64[Sp + 40];
           _s8B59::I64 = I64[Sp + 48];
           _s8B5t::I64 = I64[Sp + 56];
           _s8B5u::I64 = I64[Sp + 64];
           _s8B67::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8B67::I64, 57343)) goto c8ByE; else goto c8ByJ;
       c8ByE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B56::P64;
           P64[Hp - 136] = _s8B57::P64;
           I64[Hp - 128] = _s8B55::I64;
           I64[Hp - 120] = _s8B58::I64;
           I64[Hp - 112] = _s8B59::I64;
           I64[Hp - 104] = _s8B5u::I64;
           I64[Hp - 96] = sat_s8B6g_info;
           P64[Hp - 80] = _s8B4Z::P64;
           P64[Hp - 72] = _s8B50::P64;
           P64[Hp - 64] = _c8Bvx::P64;
           I64[Hp - 56] = _s8B4Y::I64;
           I64[Hp - 48] = _s8B51::I64;
           I64[Hp - 40] = _s8B53::I64;
           I64[Hp - 32] = _s8B5t::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ByJ: // global
           if (%MO_S_Gt_W64(_s8B67::I64,
                            1114111)) goto c8ByH; else goto c8ByI;
       c8ByH: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B56::P64;
           P64[Hp - 136] = _s8B57::P64;
           I64[Hp - 128] = _s8B55::I64;
           I64[Hp - 120] = _s8B58::I64;
           I64[Hp - 112] = _s8B59::I64;
           I64[Hp - 104] = _s8B5u::I64;
           I64[Hp - 96] = sat_s8B6l_info;
           P64[Hp - 80] = _s8B4Z::P64;
           P64[Hp - 72] = _s8B50::P64;
           P64[Hp - 64] = _c8Bvx::P64;
           I64[Hp - 56] = _s8B4Y::I64;
           I64[Hp - 48] = _s8B51::I64;
           I64[Hp - 40] = _s8B53::I64;
           I64[Hp - 32] = _s8B5t::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ByI: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8B68() args: 0, res: 0, upd: 0;
     }
 },
 _s8B68() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8B68: // global
           _s8B56::P64 = P64[Sp + 8];
           _s8B5t::I64 = I64[Sp + 40];
           _s8B5u::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8B5u::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8B56::P64);
           I64[Sp + 40] = _s8B5t::I64 + 4;
           I64[Sp + 48] = _s8B5u::I64 + 1;
           Sp = Sp + 8;
           call _c8Bwi() args: 0, res: 0, upd: 0;
     }
 },
 _c8BvA() //  []
         { info_tbl: [(c8BvA,
                       label: block_c8BvA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BvA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Byp; else goto c8Byo;
       c8Byp: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BvA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Byo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B5h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BvW() //  []
         { info_tbl: [(c8BvW,
                       label: block_c8BvW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BvW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Byt; else goto c8Bys;
       c8Byt: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BvW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Bys: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B5p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.505124912 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_decode_entry() //  [R2, R3]
         { info_tbl: [(c8Bzt,
                       label: GHC.IO.Encoding.UTF32.utf32be_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bzt: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.505948695 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32be3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32be3_bytes:
         I8[] [85,84,70,45,51,50,66,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.506749013 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be2_entry() //  [R1]
         { info_tbl: [(c8BzC,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BzC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8BzD; else goto c8BzE;
       c8BzD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BzE: // global
           (_c8Bzz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Bzz::I64 == 0) goto c8BzB; else goto c8BzA;
       c8BzB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8BzA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Bzz::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.508489554 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be_info;
         const 0;
 },
 sat_s8B6w_entry() //  [R1, R2, R3]
         { info_tbl: [(c8BzT,
                       label: sat_s8B6w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BzT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B6y_entry() //  [R1]
         { info_tbl: [(c8BzX,
                       label: sat_s8B6y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BzX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8BA1; else goto c8BA0;
       c8BA1: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8BA0: // global
           _s8B6q::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B6w_info;
           P64[Hp - 48] = _s8B6q::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B6s_entry() //  [R1, R2, R3]
         { info_tbl: [(c8BAc,
                       label: sat_s8B6s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BAc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B6u_entry() //  [R1]
         { info_tbl: [(c8BAg,
                       label: sat_s8B6u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BAg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8BAk; else goto c8BAj;
       c8BAk: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8BAj: // global
           _s8B6q::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B6s_info;
           P64[Hp - 48] = _s8B6q::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32be_entry() //  [R2]
         { info_tbl: [(c8BAm,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BAm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8BAq; else goto c8BAp;
       c8BAq: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8BAp: // global
           I64[Hp - 56] = sat_s8B6y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B6u_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.512507405 UTC

[section ""data" . lvl3_r8AWr_closure" {
     lvl3_r8AWr_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.513268331 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be3_closure" {
     GHC.IO.Encoding.UTF32.utf32be3_closure:
         const GHC.IO.Encoding.UTF32.utf32be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be3_entry() //  []
         { info_tbl: [(c8BAv,
                       label: GHC.IO.Encoding.UTF32.utf32be3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BAv: // global
           R1 = lvl3_r8AWr_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.514012471 UTC

[section ""data" . lvl4_r8AWs_closure" {
     lvl4_r8AWs_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.514728794 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be1_closure" {
     GHC.IO.Encoding.UTF32.utf32be1_closure:
         const GHC.IO.Encoding.UTF32.utf32be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be1_entry() //  []
         { info_tbl: [(c8BAC,
                       label: GHC.IO.Encoding.UTF32.utf32be1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BAC: // global
           R1 = lvl4_r8AWs_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.515440669 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_closure" {
     GHC.IO.Encoding.UTF32.utf32be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const GHC.IO.Encoding.UTF32.utf32be3_closure+1;
         const GHC.IO.Encoding.UTF32.utf32be1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.516013308 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF6_closure" {
     GHC.IO.Encoding.UTF32.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.516595534 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF4_closure" {
     GHC.IO.Encoding.UTF32.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.519073514 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_decode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_decode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BAG: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8BAR,
                       label: GHC.IO.Encoding.UTF32.$wutf32_decode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BAR: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8BAS; else goto c8BAT;
       c8BAS: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8BAT: // global
           I64[Sp - 48] = block_c8BAK_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8BD6; else goto c8BAL;
       u8BD6: // global
           call _c8BAK(R1) args: 0, res: 0, upd: 0;
       c8BAL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BAK() //  [R1]
         { info_tbl: [(c8BAK,
                       label: block_c8BAK_info
                       rep:StackRep [False, True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BAK: // global
           _s8B6C::I64 = I64[Sp + 16];
           _s8B6D::P64 = P64[Sp + 24];
           _s8B6E::P64 = P64[Sp + 32];
           _s8B6F::I64 = I64[Sp + 40];
           _s8B6G::I64 = I64[Sp + 48];
           _s8B6H::I64 = I64[Sp + 56];
           _s8B6I::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8BAO; else goto c8BAP;
       c8BAO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8BAY; else goto c8BAX;
       c8BAY: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8BAX: // global
           if (%MO_S_Ge_W64(_s8B6H::I64 - _s8B6G::I64,
                            4)) goto c8BCT; else goto c8BCX;
       c8BCT: // global
           _s8B6B::P64 = P64[Sp + 8];
           _s8B6T::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + _s8B6G::I64]);
           call MO_Touch(_s8B6D::P64);
           _s8B6Z::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 1)]);
           call MO_Touch(_s8B6D::P64);
           _s8B75::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 2)]);
           call MO_Touch(_s8B6D::P64);
           _s8B7b::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 3)]);
           call MO_Touch(_s8B6D::P64);
           if (_s8B6T::I64 != 0) goto c8BCE; else goto c8BCR;
       c8BCR: // global
           if (_s8B6Z::I64 != 0) goto c8BCE; else goto c8BCQ;
       c8BCQ: // global
           if (_s8B75::I64 != 254) goto c8BCE; else goto c8BCP;
       c8BCP: // global
           if (_s8B7b::I64 != 255) goto c8BCE; else goto c8BCO;
       c8BCE: // global
           Hp = Hp - 88;
           I64[Sp - 24] = _s8B6Z::I64;
           I64[Sp - 16] = _s8B75::I64;
           I64[Sp - 8] = _s8B7b::I64;
           I64[Sp] = _s8B6T::I64;
           Sp = Sp - 32;
           call _c8BBx() args: 0, res: 0, upd: 0;
       c8BCO: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B6D::P64;
           P64[Hp - 64] = _s8B6E::P64;
           I64[Hp - 56] = _s8B6C::I64;
           I64[Hp - 48] = _s8B6F::I64;
           I64[Hp - 40] = _s8B6G::I64 + 4;
           I64[Hp - 32] = _s8B6H::I64;
           _c8BCN::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8B6I::P64;
           R2 = _c8BCN::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8BCX: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B6D::P64;
           P64[Hp - 64] = _s8B6E::P64;
           I64[Hp - 56] = _s8B6C::I64;
           I64[Hp - 48] = _s8B6F::I64;
           I64[Hp - 40] = _s8B6G::I64;
           I64[Hp - 32] = _s8B6H::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8B6I::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8BAP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BD3; else goto c8BD2;
       c8BD3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8BD2: // global
           _s8B7C::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           R1 = _s8B7C::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BBx() //  []
         { info_tbl: [(c8BBx,
                       label: block_c8BBx_info
                       rep:StackRep [True, True, True, True, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BBx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BBB; else goto c8BBA;
       c8BBB: // global
           HpAlloc = 56;
           I64[Sp] = block_c8BBx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BBA: // global
           _s8B6B::P64 = P64[Sp + 40];
           _s8B6C::I64 = I64[Sp + 48];
           _s8B6D::P64 = P64[Sp + 56];
           _s8B6E::P64 = P64[Sp + 64];
           _s8B6F::I64 = I64[Sp + 72];
           _s8B6G::I64 = I64[Sp + 80];
           _s8B6H::I64 = I64[Sp + 88];
           _s8B6I::P64 = P64[Sp + 96];
           if (I64[Sp + 32] == 255) goto c8BCm; else goto c8BBJ;
       c8BCm: // global
           if (I64[Sp + 8] == 254) goto c8BCl; else goto c8BBS;
       c8BCl: // global
           if (I64[Sp + 16] == 0) goto c8BCk; else goto c8BC1;
       c8BCk: // global
           if (I64[Sp + 24] == 0) goto c8BCj; else goto c8BCa;
       c8BCj: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64 + 4;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8BCa: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8BC1: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8BBS: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8BBJ: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.523368925 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8BDe,
                       label: GHC.IO.Encoding.UTF32.utf32_decode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BDe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8BDi; else goto c8BDj;
       c8BDi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8BDj: // global
           I64[Sp - 24] = block_c8BDb_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8BDr; else goto c8BDc;
       u8BDr: // global
           call _c8BDb(R1) args: 0, res: 0, upd: 0;
       c8BDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BDb() //  [R1]
         { info_tbl: [(c8BDb,
                       label: block_c8BDb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BDb: // global
           I64[Sp] = block_c8BDh_info;
           _s8B7J::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8B7J::P64;
           if (R1 & 7 != 0) goto u8BDq; else goto c8BDl;
       u8BDq: // global
           call _c8BDh(R1) args: 0, res: 0, upd: 0;
       c8BDl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BDh() //  [R1]
         { info_tbl: [(c8BDh,
                       label: block_c8BDh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BDh: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.524733047 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8BDw,
                       label: GHC.IO.Encoding.UTF32.utf32_decode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BDw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.526405314 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_encode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_encode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BDA: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8BDL,
                       label: GHC.IO.Encoding.UTF32.$wutf32_encode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BDL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8BDM; else goto c8BDN;
       c8BDM: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8BDN: // global
           I64[Sp - 48] = block_c8BDE_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8BEH; else goto c8BDF;
       u8BEH: // global
           call _c8BDE(R1) args: 0, res: 0, upd: 0;
       c8BDF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BDE() //  [R1]
         { info_tbl: [(c8BDE,
                       label: block_c8BDE_info
                       rep:StackRep [False, False, True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BDE: // global
           _s8B7S::P64 = P64[Sp + 16];
           _s8B7T::I64 = I64[Sp + 24];
           _s8B7U::P64 = P64[Sp + 32];
           _s8B7V::P64 = P64[Sp + 40];
           _s8B7W::I64 = I64[Sp + 48];
           _s8B7X::I64 = I64[Sp + 56];
           _s8B7Y::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8BDI; else goto c8BDJ;
       c8BDI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8BDS; else goto c8BDR;
       c8BDS: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8BDR: // global
           if (%MO_S_Ge_W64(_s8B7W::I64 - _s8B7Y::I64,
                            4)) goto c8BEw; else goto c8BEA;
       c8BEw: // global
           _s8B7R::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8B7R::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B7R::P64);
           I8[_s8B7T::I64 + _s8B7Y::I64] = 0 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 1)] = 0 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 2)] = 254 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 3)] = 255 :: W8;
           call MO_Touch(_s8B7U::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B7U::P64;
           P64[Hp - 64] = _s8B7V::P64;
           I64[Hp - 56] = _s8B7T::I64;
           I64[Hp - 48] = _s8B7W::I64;
           I64[Hp - 40] = _s8B7X::I64;
           I64[Hp - 32] = _s8B7Y::I64 + 4;
           _c8BEu::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8BEu::P64;
           R2 = _s8B7S::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8BEA: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B7U::P64;
           P64[Hp - 64] = _s8B7V::P64;
           I64[Hp - 56] = _s8B7T::I64;
           I64[Hp - 48] = _s8B7W::I64;
           I64[Hp - 40] = _s8B7X::I64;
           I64[Hp - 32] = _s8B7Y::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8B7S::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8BDJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BEG; else goto c8BEF;
       c8BEG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8BEF: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B7U::P64;
           P64[Hp - 32] = _s8B7V::P64;
           I64[Hp - 24] = _s8B7T::I64;
           I64[Hp - 16] = _s8B7W::I64;
           I64[Hp - 8] = _s8B7X::I64;
           I64[Hp] = _s8B7Y::I64;
           R3 = Hp - 47;
           R2 = _s8B7S::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.528925932 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8BEP,
                       label: GHC.IO.Encoding.UTF32.utf32_encode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BEP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8BET; else goto c8BEU;
       c8BET: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8BEU: // global
           I64[Sp - 24] = block_c8BEM_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8BF2; else goto c8BEN;
       u8BF2: // global
           call _c8BEM(R1) args: 0, res: 0, upd: 0;
       c8BEN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BEM() //  [R1]
         { info_tbl: [(c8BEM,
                       label: block_c8BEM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BEM: // global
           I64[Sp] = block_c8BES_info;
           _s8B8w::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8B8w::P64;
           if (R1 & 7 != 0) goto u8BF1; else goto c8BEW;
       u8BF1: // global
           call _c8BES(R1) args: 0, res: 0, upd: 0;
       c8BEW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BES() //  [R1]
         { info_tbl: [(c8BES,
                       label: block_c8BES_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BES: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.530394052 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8BF7,
                       label: GHC.IO.Encoding.UTF32.utf32_encode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BF7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.531158159 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF8_bytes:
         I8[] [85,84,70,45,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.531886301 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF7_closure" {
     GHC.IO.Encoding.UTF32.mkUTF7_closure:
         const GHC.IO.Encoding.UTF32.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF7_entry() //  [R1]
         { info_tbl: [(c8BFg,
                       label: GHC.IO.Encoding.UTF32.mkUTF7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BFg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8BFh; else goto c8BFi;
       c8BFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BFi: // global
           (_c8BFd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8BFd::I64 == 0) goto c8BFf; else goto c8BFe;
       c8BFf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8BFe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8BFd::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.534996573 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32_info;
         const 0;
 },
 sat_s8B9o_entry() //  [R1, R2]
         { info_tbl: [(c8BFC,
                       label: sat_s8B9o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BFC: // global
           _s8B96::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8B96::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B96::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B9k_entry() //  [R1]
         { info_tbl: [(c8BFL,
                       label: sat_s8B9k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BFL: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B9i_entry() //  [R1, R2, R3]
         { info_tbl: [(c8BFT,
                       label: sat_s8B9i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BFT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B9h_entry() //  [R1, R2, R3]
         { info_tbl: [(c8BG4,
                       label: sat_s8B9h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BG4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8BG5; else goto c8BG6;
       c8BG5: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8BG6: // global
           I64[Sp - 24] = block_c8BG1_info;
           _s8B96::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8B96::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8BGa; else goto c8BG2;
       u8BGa: // global
           call _c8BG1(R1) args: 0, res: 0, upd: 0;
       c8BG2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BG1() //  [R1]
         { info_tbl: [(c8BG1,
                       label: block_c8BG1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BG1: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8B9q_entry() //  [R1]
         { info_tbl: [(c8BGc,
                       label: sat_s8B9q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BGc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8BGd; else goto c8BGe;
       c8BGd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8BGe: // global
           I64[Sp - 16] = block_c8BFs_info;
           _s8B8E::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8B8E::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BFs() //  [R1]
         { info_tbl: [(c8BFs,
                       label: block_c8BFs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BFs: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8BGh; else goto c8BGg;
       c8BGh: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8BGg: // global
           I64[Hp - 104] = sat_s8B9o_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8B9k_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8B9i_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8B9h_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B90_entry() //  [R1, R2]
         { info_tbl: [(c8BGx,
                       label: sat_s8B90_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BGx: // global
           _s8B8I::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8B8I::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B8I::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B8W_entry() //  [R1]
         { info_tbl: [(c8BGG,
                       label: sat_s8B8W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BGG: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B8U_entry() //  [R1, R2, R3]
         { info_tbl: [(c8BGO,
                       label: sat_s8B8U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BGO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B8T_entry() //  [R1, R2, R3]
         { info_tbl: [(c8BGZ,
                       label: sat_s8B8T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BGZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8BH0; else goto c8BH1;
       c8BH0: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8BH1: // global
           I64[Sp - 24] = block_c8BGW_info;
           _s8B8I::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8B8I::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8BH5; else goto c8BGX;
       u8BH5: // global
           call _c8BGW(R1) args: 0, res: 0, upd: 0;
       c8BGX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BGW() //  [R1]
         { info_tbl: [(c8BGW,
                       label: block_c8BGW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BGW: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8B92_entry() //  [R1]
         { info_tbl: [(c8BH7,
                       label: sat_s8B92_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BH7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8BH8; else goto c8BH9;
       c8BH8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8BH9: // global
           I64[Sp - 16] = block_c8BGn_info;
           _s8B8E::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8B8E::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BGn() //  [R1]
         { info_tbl: [(c8BGn,
                       label: block_c8BGn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BGn: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8BHc; else goto c8BHb;
       c8BHc: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8BHb: // global
           I64[Hp - 104] = sat_s8B90_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8B8W_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8B8U_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8B8T_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32_entry() //  [R2]
         { info_tbl: [(c8BHe,
                       label: GHC.IO.Encoding.UTF32.mkUTF32_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BHe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8BHi; else goto c8BHh;
       c8BHi: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8BHh: // global
           I64[Hp - 56] = sat_s8B9q_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B92_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.539272789 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_closure" {
     GHC.IO.Encoding.UTF32.utf32_closure:
         const GHC.IO.Encoding.UTF32.utf32_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32_entry() //  [R1]
         { info_tbl: [(c8BHp,
                       label: GHC.IO.Encoding.UTF32.utf32_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BHp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8BHq; else goto c8BHr;
       c8BHq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BHr: // global
           (_c8BHm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8BHm::I64 == 0) goto c8BHo; else goto c8BHn;
       c8BHo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8BHn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8BHm::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF32.mkUTF32_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.540195942 UTC

[section ""relreadonly" . S8Bun_srt" {
     S8Bun_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8AWo_closure;
         const lvl1_r8AWp_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF32.utf32be2_closure;
         const lvl2_r8AWq_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const lvl3_r8AWr_closure;
         const lvl4_r8AWs_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32_closure;
         const GHC.IO.Encoding.UTF32.mkUTF7_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.540897136 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:43.541464223 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule4_bytes" {
     GHC.IO.Encoding.UTF32.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.542060839 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule3_closure" {
     GHC.IO.Encoding.UTF32.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.542675145 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule2_bytes" {
     GHC.IO.Encoding.UTF32.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.543238367 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule1_closure" {
     GHC.IO.Encoding.UTF32.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.543857915 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule_closure" {
     GHC.IO.Encoding.UTF32.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF32.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF32.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.549652023 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le1_info;
 },
 sat_s8AWR_entry() //  [R1]
         { info_tbl: [(c8BHW,
                       label: sat_s8AWR_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BHW: // global
           _s8AWR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BHX; else goto c8BHY;
       c8BHY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BI0; else goto c8BHZ;
       c8BI0: // global
           HpAlloc = 56;
           goto c8BHX;
       c8BHX: // global
           R1 = _s8AWR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BHZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AWR::P64;
           _s8AWD::I64 = I64[_s8AWR::P64 + 56];
           _s8AWN::I64 = I64[_s8AWR::P64 + 64];
           if (_s8AWN::I64 == _s8AWD::I64) goto c8BHV; else goto c8BHU;
       c8BHV: // global
           _s8AWL::P64 = P64[_s8AWR::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BHU: // global
           _s8AWz::P64 = P64[_s8AWR::P64 + 16];
           _s8AWA::P64 = P64[_s8AWR::P64 + 24];
           _s8AWy::I64 = I64[_s8AWR::P64 + 40];
           _s8AWB::I64 = I64[_s8AWR::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AWN::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AWZ_entry() //  [R1]
         { info_tbl: [(c8BIi,
                       label: sat_s8AWZ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BIi: // global
           _s8AWZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BIj; else goto c8BIk;
       c8BIk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BIm; else goto c8BIl;
       c8BIm: // global
           HpAlloc = 56;
           goto c8BIj;
       c8BIj: // global
           R1 = _s8AWZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BIl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AWZ::P64;
           _s8AWD::I64 = I64[_s8AWZ::P64 + 56];
           _s8AWV::I64 = I64[_s8AWZ::P64 + 64];
           if (_s8AWV::I64 == _s8AWD::I64) goto c8BIh; else goto c8BIg;
       c8BIh: // global
           _s8AWL::P64 = P64[_s8AWZ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BIg: // global
           _s8AWz::P64 = P64[_s8AWZ::P64 + 16];
           _s8AWA::P64 = P64[_s8AWZ::P64 + 24];
           _s8AWy::I64 = I64[_s8AWZ::P64 + 40];
           _s8AWB::I64 = I64[_s8AWZ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AWV::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AX7_entry() //  [R1]
         { info_tbl: [(c8BIE,
                       label: sat_s8AX7_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BIE: // global
           _s8AX7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BIF; else goto c8BIG;
       c8BIG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BII; else goto c8BIH;
       c8BII: // global
           HpAlloc = 56;
           goto c8BIF;
       c8BIF: // global
           R1 = _s8AX7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BIH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AX7::P64;
           _s8AWD::I64 = I64[_s8AX7::P64 + 56];
           _s8AX3::I64 = I64[_s8AX7::P64 + 64];
           if (_s8AX3::I64 == _s8AWD::I64) goto c8BID; else goto c8BIC;
       c8BID: // global
           _s8AWL::P64 = P64[_s8AX7::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BIC: // global
           _s8AWz::P64 = P64[_s8AX7::P64 + 16];
           _s8AWA::P64 = P64[_s8AX7::P64 + 24];
           _s8AWy::I64 = I64[_s8AX7::P64 + 40];
           _s8AWB::I64 = I64[_s8AX7::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AX3::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AXf_entry() //  [R1]
         { info_tbl: [(c8BJ0,
                       label: sat_s8AXf_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BJ0: // global
           _s8AXf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BJ1; else goto c8BJ2;
       c8BJ2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BJ4; else goto c8BJ3;
       c8BJ4: // global
           HpAlloc = 56;
           goto c8BJ1;
       c8BJ1: // global
           R1 = _s8AXf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BJ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AXf::P64;
           _s8AWD::I64 = I64[_s8AXf::P64 + 56];
           _s8AXb::I64 = I64[_s8AXf::P64 + 64];
           if (_s8AXb::I64 == _s8AWD::I64) goto c8BIZ; else goto c8BIY;
       c8BIZ: // global
           _s8AWL::P64 = P64[_s8AXf::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BIY: // global
           _s8AWz::P64 = P64[_s8AXf::P64 + 16];
           _s8AWA::P64 = P64[_s8AXf::P64 + 24];
           _s8AWy::I64 = I64[_s8AXf::P64 + 40];
           _s8AWB::I64 = I64[_s8AXf::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AXb::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AXn_entry() //  [R1]
         { info_tbl: [(c8BJm,
                       label: sat_s8AXn_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BJm: // global
           _s8AXn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BJn; else goto c8BJo;
       c8BJo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BJq; else goto c8BJp;
       c8BJq: // global
           HpAlloc = 56;
           goto c8BJn;
       c8BJn: // global
           R1 = _s8AXn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BJp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AXn::P64;
           _s8AWD::I64 = I64[_s8AXn::P64 + 56];
           _s8AXj::I64 = I64[_s8AXn::P64 + 64];
           if (_s8AXj::I64 == _s8AWD::I64) goto c8BJl; else goto c8BJk;
       c8BJl: // global
           _s8AWL::P64 = P64[_s8AXn::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BJk: // global
           _s8AWz::P64 = P64[_s8AXn::P64 + 16];
           _s8AWA::P64 = P64[_s8AXn::P64 + 24];
           _s8AWy::I64 = I64[_s8AXn::P64 + 40];
           _s8AWB::I64 = I64[_s8AXn::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AXj::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32le1_entry() //  [R2, R3]
         { info_tbl: [(c8BJt,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BJt: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8BJu; else goto c8BJv;
       c8BJu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8BJv: // global
           I64[Sp - 16] = block_c8BHw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8BP7; else goto c8BHx;
       u8BP7: // global
           call _c8BHw(R1) args: 0, res: 0, upd: 0;
       c8BHx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BHw() //  [R1]
         { info_tbl: [(c8BHw,
                       label: block_c8BHw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BHw: // global
           I64[Sp - 40] = block_c8BHB_info;
           _s8AWz::P64 = P64[R1 + 7];
           _s8AWA::P64 = P64[R1 + 15];
           _s8AWy::I64 = I64[R1 + 23];
           _s8AWB::I64 = I64[R1 + 31];
           _s8AWC::I64 = I64[R1 + 39];
           _s8AWD::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8AWA::P64;
           I64[Sp - 24] = _s8AWB::I64;
           I64[Sp - 16] = _s8AWC::I64;
           I64[Sp - 8] = _s8AWD::I64;
           P64[Sp] = _s8AWz::P64;
           I64[Sp + 8] = _s8AWy::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8BP1; else goto c8BHC;
       u8BP1: // global
           call _c8BHB(R1) args: 0, res: 0, upd: 0;
       c8BHC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BHB() //  [R1]
         { info_tbl: [(c8BHB,
                       label: block_c8BHB_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BHB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BJz; else goto c8BJy;
       c8BJz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8BJy: // global
           _s8AWG::P64 = P64[R1 + 7];
           _s8AWH::P64 = P64[R1 + 15];
           _s8AWF::I64 = I64[R1 + 23];
           _s8AWI::I64 = I64[R1 + 31];
           _s8AWJ::I64 = I64[R1 + 39];
           _s8AWK::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8AWz::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8AWy::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8AWD::I64 = I64[Sp + 32];
           _c8BHG::P64 = Hp - 47;
           _s8AXs::I64 = _s8AWK::I64;
           _s8AXr::I64 = I64[Sp + 24];
           goto c8BJW;
       c8BJW: // global
           if (%MO_S_Lt_W64(_s8AXr::I64,
                            _s8AWD::I64)) goto c8BKS; else goto c8BKT;
       c8BKS: // global
           if (%MO_S_Ge_W64(_s8AWI::I64 - _s8AXs::I64,
                            4)) goto c8BKP; else goto c8BKQ;
       c8BKP: // global
           _s8AXz::I64 = %MO_UU_Conv_W32_W64(I32[_s8AWy::I64 + (_s8AXr::I64 << 2)]);
           call MO_Touch(_s8AWz::P64);
           if (%MO_S_Gt_W64(55296, _s8AXz::I64)) goto c8BKt; else goto c8BKN;
       c8BKt: // global
           if (%MO_S_Gt_W64(56320, _s8AXz::I64)) goto c8BKj; else goto c8BKr;
       c8BKj: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8BJW;
       c8BKr: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 57343)) goto c8BKp; else goto c8BKq;
       c8BKp: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8BJW;
       c8BKq: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8BHG::P64;
           Sp = Sp - 56;
           call _c8BHJ() args: 0, res: 0, upd: 0;
       c8BKN: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 56319)) goto c8BKL; else goto c8BKM;
       c8BKL: // global
           if (%MO_S_Gt_W64(56320, _s8AXz::I64)) goto c8BKB; else goto c8BKJ;
       c8BKB: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8BJW;
       c8BKJ: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 57343)) goto c8BKH; else goto c8BKI;
       c8BKH: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8BJW;
       c8BKI: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8BHG::P64;
           Sp = Sp - 56;
           call _c8BI5() args: 0, res: 0, upd: 0;
       c8BKM: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8BHG::P64;
           Sp = Sp - 56;
           call _c8BIr() args: 0, res: 0, upd: 0;
       c8BKQ: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8BHG::P64;
           Sp = Sp - 56;
           call _c8BIN() args: 0, res: 0, upd: 0;
       c8BKT: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8BHG::P64;
           Sp = Sp - 56;
           call _c8BJ9() args: 0, res: 0, upd: 0;
     }
 },
 _c8BHJ() //  []
         { info_tbl: [(c8BHJ,
                       label: block_c8BHJ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BHJ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BJD; else goto c8BJC;
       c8BJD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BHJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BJC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AWR_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BI5() //  []
         { info_tbl: [(c8BI5,
                       label: block_c8BI5_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BI5: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BJH; else goto c8BJG;
       c8BJH: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BI5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BJG: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AWZ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BIr() //  []
         { info_tbl: [(c8BIr,
                       label: block_c8BIr_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BIr: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BJL; else goto c8BJK;
       c8BJL: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BIr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BJK: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AX7_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BIN() //  []
         { info_tbl: [(c8BIN,
                       label: block_c8BIN_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BIN: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BJP; else goto c8BJO;
       c8BJP: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BIN_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BJO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AXf_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BJ9() //  []
         { info_tbl: [(c8BJ9,
                       label: block_c8BJ9_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BJ9: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BJT; else goto c8BJS;
       c8BJT: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BJ9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BJS: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AXn_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.558517067 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_encode_entry() //  [R2, R3]
         { info_tbl: [(c8BPc,
                       label: GHC.IO.Encoding.UTF32.utf32le_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BPc: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF32le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.564365021 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF1_info;
 },
 sat_s8AZT_entry() //  [R1]
         { info_tbl: [(c8BPJ,
                       label: sat_s8AZT_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BPJ: // global
           _s8AZT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BPK; else goto c8BPL;
       c8BPL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BPN; else goto c8BPM;
       c8BPN: // global
           HpAlloc = 56;
           goto c8BPK;
       c8BPK: // global
           R1 = _s8AZT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BPM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AZT::P64;
           _s8AZF::I64 = I64[_s8AZT::P64 + 56];
           _s8AZP::I64 = I64[_s8AZT::P64 + 64];
           if (_s8AZP::I64 == _s8AZF::I64) goto c8BPI; else goto c8BPH;
       c8BPI: // global
           _s8AZN::P64 = P64[_s8AZT::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BPH: // global
           _s8AZB::P64 = P64[_s8AZT::P64 + 16];
           _s8AZC::P64 = P64[_s8AZT::P64 + 24];
           _s8AZA::I64 = I64[_s8AZT::P64 + 40];
           _s8AZD::I64 = I64[_s8AZT::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8AZP::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B01_entry() //  [R1]
         { info_tbl: [(c8BQ5,
                       label: sat_s8B01_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BQ5: // global
           _s8B01::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BQ6; else goto c8BQ7;
       c8BQ7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BQ9; else goto c8BQ8;
       c8BQ9: // global
           HpAlloc = 56;
           goto c8BQ6;
       c8BQ6: // global
           R1 = _s8B01::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BQ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B01::P64;
           _s8AZF::I64 = I64[_s8B01::P64 + 56];
           _s8AZX::I64 = I64[_s8B01::P64 + 64];
           if (_s8AZX::I64 == _s8AZF::I64) goto c8BQ4; else goto c8BQ3;
       c8BQ4: // global
           _s8AZN::P64 = P64[_s8B01::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BQ3: // global
           _s8AZB::P64 = P64[_s8B01::P64 + 16];
           _s8AZC::P64 = P64[_s8B01::P64 + 24];
           _s8AZA::I64 = I64[_s8B01::P64 + 40];
           _s8AZD::I64 = I64[_s8B01::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8AZX::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B09_entry() //  [R1]
         { info_tbl: [(c8BQr,
                       label: sat_s8B09_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BQr: // global
           _s8B09::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BQs; else goto c8BQt;
       c8BQt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BQv; else goto c8BQu;
       c8BQv: // global
           HpAlloc = 56;
           goto c8BQs;
       c8BQs: // global
           R1 = _s8B09::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BQu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B09::P64;
           _s8AZF::I64 = I64[_s8B09::P64 + 56];
           _s8B05::I64 = I64[_s8B09::P64 + 64];
           if (_s8B05::I64 == _s8AZF::I64) goto c8BQq; else goto c8BQp;
       c8BQq: // global
           _s8AZN::P64 = P64[_s8B09::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BQp: // global
           _s8AZB::P64 = P64[_s8B09::P64 + 16];
           _s8AZC::P64 = P64[_s8B09::P64 + 24];
           _s8AZA::I64 = I64[_s8B09::P64 + 40];
           _s8AZD::I64 = I64[_s8B09::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B05::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B0h_entry() //  [R1]
         { info_tbl: [(c8BQN,
                       label: sat_s8B0h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BQN: // global
           _s8B0h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BQO; else goto c8BQP;
       c8BQP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BQR; else goto c8BQQ;
       c8BQR: // global
           HpAlloc = 56;
           goto c8BQO;
       c8BQO: // global
           R1 = _s8B0h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BQQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B0h::P64;
           _s8AZF::I64 = I64[_s8B0h::P64 + 56];
           _s8B0d::I64 = I64[_s8B0h::P64 + 64];
           if (_s8B0d::I64 == _s8AZF::I64) goto c8BQM; else goto c8BQL;
       c8BQM: // global
           _s8AZN::P64 = P64[_s8B0h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BQL: // global
           _s8AZB::P64 = P64[_s8B0h::P64 + 16];
           _s8AZC::P64 = P64[_s8B0h::P64 + 24];
           _s8AZA::I64 = I64[_s8B0h::P64 + 40];
           _s8AZD::I64 = I64[_s8B0h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B0d::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B0p_entry() //  [R1]
         { info_tbl: [(c8BR9,
                       label: sat_s8B0p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BR9: // global
           _s8B0p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BRa; else goto c8BRb;
       c8BRb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BRd; else goto c8BRc;
       c8BRd: // global
           HpAlloc = 56;
           goto c8BRa;
       c8BRa: // global
           R1 = _s8B0p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BRc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B0p::P64;
           _s8AZF::I64 = I64[_s8B0p::P64 + 56];
           _s8B0l::I64 = I64[_s8B0p::P64 + 64];
           if (_s8B0l::I64 == _s8AZF::I64) goto c8BR8; else goto c8BR7;
       c8BR8: // global
           _s8AZN::P64 = P64[_s8B0p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BR7: // global
           _s8AZB::P64 = P64[_s8B0p::P64 + 16];
           _s8AZC::P64 = P64[_s8B0p::P64 + 24];
           _s8AZA::I64 = I64[_s8B0p::P64 + 40];
           _s8AZD::I64 = I64[_s8B0p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B0l::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8BRg,
                       label: GHC.IO.Encoding.UTF32.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BRg: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8BRh; else goto c8BRi;
       c8BRh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8BRi: // global
           I64[Sp - 16] = block_c8BPj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8BWU; else goto c8BPk;
       u8BWU: // global
           call _c8BPj(R1) args: 0, res: 0, upd: 0;
       c8BPk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BPj() //  [R1]
         { info_tbl: [(c8BPj,
                       label: block_c8BPj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BPj: // global
           I64[Sp - 40] = block_c8BPo_info;
           _s8AZB::P64 = P64[R1 + 7];
           _s8AZC::P64 = P64[R1 + 15];
           _s8AZA::I64 = I64[R1 + 23];
           _s8AZD::I64 = I64[R1 + 31];
           _s8AZE::I64 = I64[R1 + 39];
           _s8AZF::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8AZC::P64;
           I64[Sp - 24] = _s8AZD::I64;
           I64[Sp - 16] = _s8AZE::I64;
           I64[Sp - 8] = _s8AZF::I64;
           P64[Sp] = _s8AZB::P64;
           I64[Sp + 8] = _s8AZA::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8BWO; else goto c8BPp;
       u8BWO: // global
           call _c8BPo(R1) args: 0, res: 0, upd: 0;
       c8BPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BPo() //  [R1]
         { info_tbl: [(c8BPo,
                       label: block_c8BPo_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BPo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BRm; else goto c8BRl;
       c8BRm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8BRl: // global
           _s8AZI::P64 = P64[R1 + 7];
           _s8AZJ::P64 = P64[R1 + 15];
           _s8AZH::I64 = I64[R1 + 23];
           _s8AZK::I64 = I64[R1 + 31];
           _s8AZL::I64 = I64[R1 + 39];
           _s8AZM::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8AZB::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8AZA::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8AZF::I64 = I64[Sp + 32];
           _c8BPt::P64 = Hp - 47;
           _s8B0u::I64 = _s8AZM::I64;
           _s8B0t::I64 = I64[Sp + 24];
           goto c8BRJ;
       c8BRJ: // global
           if (%MO_S_Lt_W64(_s8B0t::I64,
                            _s8AZF::I64)) goto c8BSF; else goto c8BSG;
       c8BSF: // global
           if (%MO_S_Ge_W64(_s8AZK::I64 - _s8B0u::I64,
                            4)) goto c8BSC; else goto c8BSD;
       c8BSC: // global
           _s8B0B::I64 = %MO_UU_Conv_W32_W64(I32[_s8AZA::I64 + (_s8B0t::I64 << 2)]);
           call MO_Touch(_s8AZB::P64);
           if (%MO_S_Gt_W64(55296, _s8B0B::I64)) goto c8BSg; else goto c8BSA;
       c8BSg: // global
           if (%MO_S_Gt_W64(56320, _s8B0B::I64)) goto c8BS6; else goto c8BSe;
       c8BS6: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8BRJ;
       c8BSe: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 57343)) goto c8BSc; else goto c8BSd;
       c8BSc: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8BRJ;
       c8BSd: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8BPt::P64;
           Sp = Sp - 56;
           call _c8BPw() args: 0, res: 0, upd: 0;
       c8BSA: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 56319)) goto c8BSy; else goto c8BSz;
       c8BSy: // global
           if (%MO_S_Gt_W64(56320, _s8B0B::I64)) goto c8BSo; else goto c8BSw;
       c8BSo: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8BRJ;
       c8BSw: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 57343)) goto c8BSu; else goto c8BSv;
       c8BSu: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8BRJ;
       c8BSv: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8BPt::P64;
           Sp = Sp - 56;
           call _c8BPS() args: 0, res: 0, upd: 0;
       c8BSz: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8BPt::P64;
           Sp = Sp - 56;
           call _c8BQe() args: 0, res: 0, upd: 0;
       c8BSD: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8BPt::P64;
           Sp = Sp - 56;
           call _c8BQA() args: 0, res: 0, upd: 0;
       c8BSG: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8BPt::P64;
           Sp = Sp - 56;
           call _c8BQW() args: 0, res: 0, upd: 0;
     }
 },
 _c8BPw() //  []
         { info_tbl: [(c8BPw,
                       label: block_c8BPw_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BPw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BRq; else goto c8BRp;
       c8BRq: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BPw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BRp: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AZT_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BPS() //  []
         { info_tbl: [(c8BPS,
                       label: block_c8BPS_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BPS: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BRu; else goto c8BRt;
       c8BRu: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BPS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BRt: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B01_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BQe() //  []
         { info_tbl: [(c8BQe,
                       label: block_c8BQe_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BQe: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BRy; else goto c8BRx;
       c8BRy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BQe_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BRx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B09_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BQA() //  []
         { info_tbl: [(c8BQA,
                       label: block_c8BQA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BQA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BRC; else goto c8BRB;
       c8BRC: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BQA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BRB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B0h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BQW() //  []
         { info_tbl: [(c8BQW,
                       label: block_c8BQW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BQW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8BRG; else goto c8BRF;
       c8BRG: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BQW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8BRF: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B0p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.575344198 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_encode_entry() //  [R2, R3]
         { info_tbl: [(c8BWZ,
                       label: GHC.IO.Encoding.UTF32.utf32be_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BWZ: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.579346038 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF3_closure" {
     GHC.IO.Encoding.UTF32.mkUTF3_closure:
         const GHC.IO.Encoding.UTF32.mkUTF3_info;
 },
 sat_s8B2V_entry() //  [R1]
         { info_tbl: [(c8BXw,
                       label: sat_s8B2V_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BXw: // global
           _s8B2V::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BXx; else goto c8BXy;
       c8BXy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BXA; else goto c8BXz;
       c8BXA: // global
           HpAlloc = 56;
           goto c8BXx;
       c8BXx: // global
           R1 = _s8B2V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BXz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B2V::P64;
           _s8B2H::I64 = I64[_s8B2V::P64 + 56];
           _s8B2R::I64 = I64[_s8B2V::P64 + 64];
           if (_s8B2R::I64 == _s8B2H::I64) goto c8BXv; else goto c8BXu;
       c8BXv: // global
           _s8B2P::P64 = P64[_s8B2V::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BXu: // global
           _s8B2D::P64 = P64[_s8B2V::P64 + 16];
           _s8B2E::P64 = P64[_s8B2V::P64 + 24];
           _s8B2C::I64 = I64[_s8B2V::P64 + 40];
           _s8B2F::I64 = I64[_s8B2V::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B2R::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B33_entry() //  [R1]
         { info_tbl: [(c8BXS,
                       label: sat_s8B33_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BXS: // global
           _s8B33::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BXT; else goto c8BXU;
       c8BXU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BXW; else goto c8BXV;
       c8BXW: // global
           HpAlloc = 56;
           goto c8BXT;
       c8BXT: // global
           R1 = _s8B33::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BXV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B33::P64;
           _s8B2H::I64 = I64[_s8B33::P64 + 56];
           _s8B2Z::I64 = I64[_s8B33::P64 + 64];
           if (_s8B2Z::I64 == _s8B2H::I64) goto c8BXR; else goto c8BXQ;
       c8BXR: // global
           _s8B2P::P64 = P64[_s8B33::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BXQ: // global
           _s8B2D::P64 = P64[_s8B33::P64 + 16];
           _s8B2E::P64 = P64[_s8B33::P64 + 24];
           _s8B2C::I64 = I64[_s8B33::P64 + 40];
           _s8B2F::I64 = I64[_s8B33::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B2Z::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B3U_entry() //  [R1]
         { info_tbl: [(c8BZw,
                       label: sat_s8B3U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BZw: // global
           _s8B3U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BZx; else goto c8BZy;
       c8BZy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BZA; else goto c8BZz;
       c8BZA: // global
           HpAlloc = 56;
           goto c8BZx;
       c8BZx: // global
           R1 = _s8B3U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BZz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B3U::P64;
           _s8B2H::I64 = I64[_s8B3U::P64 + 56];
           _s8B37::I64 = I64[_s8B3U::P64 + 64];
           if (_s8B37::I64 == _s8B2H::I64) goto c8BZv; else goto c8BZu;
       c8BZv: // global
           _s8B2P::P64 = P64[_s8B3U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BZu: // global
           _s8B2D::P64 = P64[_s8B3U::P64 + 16];
           _s8B2E::P64 = P64[_s8B3U::P64 + 24];
           _s8B2C::I64 = I64[_s8B3U::P64 + 40];
           _s8B2F::I64 = I64[_s8B3U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B37::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B3Z_entry() //  [R1]
         { info_tbl: [(c8BZR,
                       label: sat_s8B3Z_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BZR: // global
           _s8B3Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8BZS; else goto c8BZT;
       c8BZT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8BZV; else goto c8BZU;
       c8BZV: // global
           HpAlloc = 56;
           goto c8BZS;
       c8BZS: // global
           R1 = _s8B3Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8BZU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B3Z::P64;
           _s8B2H::I64 = I64[_s8B3Z::P64 + 56];
           _s8B37::I64 = I64[_s8B3Z::P64 + 64];
           if (_s8B37::I64 == _s8B2H::I64) goto c8BZQ; else goto c8BZP;
       c8BZQ: // global
           _s8B2P::P64 = P64[_s8B3Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BZP: // global
           _s8B2D::P64 = P64[_s8B3Z::P64 + 16];
           _s8B2E::P64 = P64[_s8B3Z::P64 + 24];
           _s8B2C::I64 = I64[_s8B3Z::P64 + 40];
           _s8B2F::I64 = I64[_s8B3Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B37::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF3_entry() //  [R2, R3]
         { info_tbl: [(c8BZY,
                       label: GHC.IO.Encoding.UTF32.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BZY: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8BZZ; else goto c8C00;
       c8BZZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8C00: // global
           I64[Sp - 16] = block_c8BX6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8C16; else goto c8BX7;
       u8C16: // global
           call _c8BX6(R1) args: 0, res: 0, upd: 0;
       c8BX7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BX6() //  [R1]
         { info_tbl: [(c8BX6,
                       label: block_c8BX6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BX6: // global
           I64[Sp - 40] = block_c8BXb_info;
           _s8B2D::P64 = P64[R1 + 7];
           _s8B2E::P64 = P64[R1 + 15];
           _s8B2C::I64 = I64[R1 + 23];
           _s8B2F::I64 = I64[R1 + 31];
           _s8B2G::I64 = I64[R1 + 39];
           _s8B2H::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8B2E::P64;
           I64[Sp - 24] = _s8B2F::I64;
           I64[Sp - 16] = _s8B2G::I64;
           I64[Sp - 8] = _s8B2H::I64;
           P64[Sp] = _s8B2D::P64;
           I64[Sp + 8] = _s8B2C::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8C0Y; else goto c8BXc;
       u8C0Y: // global
           call _c8BXb(R1) args: 0, res: 0, upd: 0;
       c8BXc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BXb() //  [R1]
         { info_tbl: [(c8BXb,
                       label: block_c8BXb_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BXb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8C04; else goto c8C03;
       c8C04: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8C03: // global
           _s8B2K::P64 = P64[R1 + 7];
           _s8B2L::P64 = P64[R1 + 15];
           _s8B2J::I64 = I64[R1 + 23];
           _s8B2M::I64 = I64[R1 + 31];
           _s8B2N::I64 = I64[R1 + 39];
           _s8B2O::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8B2K::P64;
           P64[Sp - 40] = _s8B2L::P64;
           I64[Sp - 32] = _s8B2M::I64;
           I64[Sp - 24] = _s8B2N::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8B2O::I64;
           I64[Sp] = _s8B2J::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8BY1() args: 0, res: 0, upd: 0;
     }
 },
 _c8BY1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BY1: // global
           _s8B37::I64 = I64[Sp + 32];
           _s8B38::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8B38::I64,
                            I64[Sp + 16])) goto c8C0J; else goto c8C0K;
       c8C0J: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8B37::I64,
                            4)) goto c8C0G; else goto c8C0H;
       c8C0G: // global
           _s8B2C::I64 = I64[Sp + 96];
           _s8B2D::P64 = P64[Sp + 88];
           _s8B3g::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + _s8B37::I64]);
           call MO_Touch(_s8B2D::P64);
           _s8B3m::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 1)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3s::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 2)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3y::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 3)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3A::I64 = (_s8B3y::I64 << 24) + ((_s8B3s::I64 << 16) + ((_s8B3m::I64 << 8) + _s8B3g::I64));
           if (%MO_S_Lt_W64(_s8B3A::I64, 0)) goto u8C0R; else goto c8C0E;
       u8C0R: // global
           I64[Sp - 16] = _s8B3A::I64;
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 24;
           goto u8C12;
       c8C0E: // global
           if (%MO_S_Ge_W64(_s8B3A::I64, 55296)) goto u8C0T; else goto u8C0S;
       u8C0T: // global
           I64[Sp - 16] = _s8B3A::I64;
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 24;
           goto u8C12;
       u8C12: // global
           call _c8BZh() args: 0, res: 0, upd: 0;
       u8C0S: // global
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 8;
           call _s8B3M() args: 0, res: 0, upd: 0;
       c8C0H: // global
           I64[Sp + 32] = _s8B38::I64;
           I64[Sp + 40] = _s8B37::I64;
           Sp = Sp - 8;
           call _c8BXj() args: 0, res: 0, upd: 0;
       c8C0K: // global
           I64[Sp + 32] = _s8B38::I64;
           I64[Sp + 40] = _s8B37::I64;
           Sp = Sp - 8;
           call _c8BXF() args: 0, res: 0, upd: 0;
     }
 },
 _c8BZh() //  []
         { info_tbl: [(c8BZh,
                       label: block_c8BZh_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BZh: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8C0k; else goto c8C0j;
       c8C0k: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BZh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8C0j: // global
           _c8BXg::P64 = P64[Sp + 96];
           _s8B2C::I64 = I64[Sp + 120];
           _s8B2D::P64 = P64[Sp + 112];
           _s8B2E::P64 = P64[Sp + 80];
           _s8B2F::I64 = I64[Sp + 88];
           _s8B2H::I64 = I64[Sp + 104];
           _s8B2J::I64 = I64[Sp + 72];
           _s8B2K::P64 = P64[Sp + 24];
           _s8B2L::P64 = P64[Sp + 32];
           _s8B2M::I64 = I64[Sp + 40];
           _s8B2N::I64 = I64[Sp + 48];
           _s8B37::I64 = I64[Sp + 56];
           _s8B38::I64 = I64[Sp + 64];
           _s8B3L::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8B3L::I64, 57343)) goto c8C0n; else goto c8C0s;
       c8C0n: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B2K::P64;
           P64[Hp - 136] = _s8B2L::P64;
           I64[Hp - 128] = _s8B2J::I64;
           I64[Hp - 120] = _s8B2M::I64;
           I64[Hp - 112] = _s8B2N::I64;
           I64[Hp - 104] = _s8B38::I64;
           I64[Hp - 96] = sat_s8B3U_info;
           P64[Hp - 80] = _s8B2D::P64;
           P64[Hp - 72] = _s8B2E::P64;
           P64[Hp - 64] = _c8BXg::P64;
           I64[Hp - 56] = _s8B2C::I64;
           I64[Hp - 48] = _s8B2F::I64;
           I64[Hp - 40] = _s8B2H::I64;
           I64[Hp - 32] = _s8B37::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8C0s: // global
           if (%MO_S_Gt_W64(_s8B3L::I64,
                            1114111)) goto c8C0q; else goto c8C0r;
       c8C0q: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B2K::P64;
           P64[Hp - 136] = _s8B2L::P64;
           I64[Hp - 128] = _s8B2J::I64;
           I64[Hp - 120] = _s8B2M::I64;
           I64[Hp - 112] = _s8B2N::I64;
           I64[Hp - 104] = _s8B38::I64;
           I64[Hp - 96] = sat_s8B3Z_info;
           P64[Hp - 80] = _s8B2D::P64;
           P64[Hp - 72] = _s8B2E::P64;
           P64[Hp - 64] = _c8BXg::P64;
           I64[Hp - 56] = _s8B2C::I64;
           I64[Hp - 48] = _s8B2F::I64;
           I64[Hp - 40] = _s8B2H::I64;
           I64[Hp - 32] = _s8B37::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8C0r: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8B3M() args: 0, res: 0, upd: 0;
     }
 },
 _s8B3M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8B3M: // global
           _s8B2K::P64 = P64[Sp + 8];
           _s8B37::I64 = I64[Sp + 40];
           _s8B38::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8B38::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8B2K::P64);
           I64[Sp + 40] = _s8B37::I64 + 4;
           I64[Sp + 48] = _s8B38::I64 + 1;
           Sp = Sp + 8;
           call _c8BY1() args: 0, res: 0, upd: 0;
     }
 },
 _c8BXj() //  []
         { info_tbl: [(c8BXj,
                       label: block_c8BXj_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BXj: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8C08; else goto c8C07;
       c8C08: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BXj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8C07: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B2V_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8BXF() //  []
         { info_tbl: [(c8BXF,
                       label: block_c8BXF_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BXF: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8C0c; else goto c8C0b;
       c8C0c: // global
           HpAlloc = 160;
           I64[Sp] = block_c8BXF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8C0b: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B33_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.585889088 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_decode_entry() //  [R2, R3]
         { info_tbl: [(c8C1c,
                       label: GHC.IO.Encoding.UTF32.utf32le_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C1c: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.586564297 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32le3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32le3_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.587365748 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le2_entry() //  [R1]
         { info_tbl: [(c8C1l,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C1l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8C1m; else goto c8C1n;
       c8C1m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8C1n: // global
           (_c8C1i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8C1i::I64 == 0) goto c8C1k; else goto c8C1j;
       c8C1k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8C1j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8C1i::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.5883652 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF2_entry() //  []
         { info_tbl: [(c8C1s,
                       label: GHC.IO.Encoding.UTF32.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C1s: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.589150838 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be1_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be1_entry() //  []
         { info_tbl: [(c8C1z,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C1z: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.590674298 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le_info;
         const 0;
 },
 sat_s8B4d_entry() //  [R1, R2, R3]
         { info_tbl: [(c8C1Q,
                       label: sat_s8B4d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C1Q: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B4f_entry() //  [R1]
         { info_tbl: [(c8C1U,
                       label: sat_s8B4f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C1U: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8C1Y; else goto c8C1X;
       c8C1Y: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8C1X: // global
           _s8B47::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B4d_info;
           P64[Hp - 48] = _s8B47::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B49_entry() //  [R1, R2, R3]
         { info_tbl: [(c8C29,
                       label: sat_s8B49_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C29: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B4b_entry() //  [R1]
         { info_tbl: [(c8C2d,
                       label: sat_s8B4b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C2d: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8C2h; else goto c8C2g;
       c8C2h: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8C2g: // global
           _s8B47::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B49_info;
           P64[Hp - 48] = _s8B47::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32le_entry() //  [R2]
         { info_tbl: [(c8C2j,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C2j: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8C2n; else goto c8C2m;
       c8C2n: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8C2m: // global
           I64[Hp - 56] = sat_s8B4f_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B4b_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.592813225 UTC

[section ""data" . lvl_r8AWo_closure" {
     lvl_r8AWo_closure:
         const lvl_r8AWo_info;
         const 0;
 },
 lvl_r8AWo_entry() //  [R2, R3]
         { info_tbl: [(c8C2v,
                       label: lvl_r8AWo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C2v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8C2z; else goto c8C2A;
       c8C2z: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8AWo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8C2A: // global
           I64[Sp - 16] = block_c8C2s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8C2I; else goto c8C2t;
       u8C2I: // global
           call _c8C2s() args: 0, res: 0, upd: 0;
       c8C2t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8C2s() //  []
         { info_tbl: [(c8C2s,
                       label: block_c8C2s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C2s: // global
           _s8B4h::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8C2y_info;
           R1 = _s8B4h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8C2H; else goto c8C2C;
       u8C2H: // global
           call _c8C2y() args: 0, res: 0, upd: 0;
       c8C2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8C2y() //  []
         { info_tbl: [(c8C2y,
                       label: block_c8C2y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C2y: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.593997429 UTC

[section ""data" . lvl1_r8AWp_closure" {
     lvl1_r8AWp_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.594708565 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le2_closure" {
     GHC.IO.Encoding.UTF32.utf32le2_closure:
         const GHC.IO.Encoding.UTF32.utf32le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le2_entry() //  []
         { info_tbl: [(c8C2N,
                       label: GHC.IO.Encoding.UTF32.utf32le2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C2N: // global
           R1 = lvl1_r8AWp_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.595795352 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be2_closure" {
     GHC.IO.Encoding.UTF32.utf32be2_closure:
         const GHC.IO.Encoding.UTF32.utf32be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be2_entry() //  [R2, R3]
         { info_tbl: [(c8C2X,
                       label: GHC.IO.Encoding.UTF32.utf32be2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C2X: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8C31; else goto c8C32;
       c8C31: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8C32: // global
           I64[Sp - 16] = block_c8C2U_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8C3b; else goto c8C2V;
       u8C3b: // global
           call _c8C2U(R1) args: 0, res: 0, upd: 0;
       c8C2V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8C2U() //  [R1]
         { info_tbl: [(c8C2U,
                       label: block_c8C2U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C2U: // global
           I64[Sp - 16] = block_c8C30_info;
           _s8B4D::P64 = P64[R1 + 7];
           _s8B4C::I64 = I64[R1 + 23];
           _s8B4G::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8B4G::I64;
           P64[Sp] = _s8B4D::P64;
           I64[Sp + 8] = _s8B4C::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8C3a; else goto c8C34;
       u8C3a: // global
           call _c8C30() args: 0, res: 0, upd: 0;
       c8C34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8C30() //  []
         { info_tbl: [(c8C30,
                       label: block_c8C30_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C30: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.597074791 UTC

[section ""data" . lvl2_r8AWq_closure" {
     lvl2_r8AWq_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.597814576 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le1_closure" {
     GHC.IO.Encoding.UTF32.utf32le1_closure:
         const GHC.IO.Encoding.UTF32.utf32le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le1_entry() //  []
         { info_tbl: [(c8C3g,
                       label: GHC.IO.Encoding.UTF32.utf32le1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C3g: // global
           R1 = lvl2_r8AWq_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.598520513 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_closure" {
     GHC.IO.Encoding.UTF32.utf32le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.UTF32.utf32le2_closure+1;
         const GHC.IO.Encoding.UTF32.utf32le1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.602480677 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF5_closure" {
     GHC.IO.Encoding.UTF32.mkUTF5_closure:
         const GHC.IO.Encoding.UTF32.mkUTF5_info;
 },
 sat_s8B5h_entry() //  [R1]
         { info_tbl: [(c8C3N,
                       label: sat_s8B5h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C3N: // global
           _s8B5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8C3O; else goto c8C3P;
       c8C3P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8C3R; else goto c8C3Q;
       c8C3R: // global
           HpAlloc = 56;
           goto c8C3O;
       c8C3O: // global
           R1 = _s8B5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8C3Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B5h::P64;
           _s8B53::I64 = I64[_s8B5h::P64 + 56];
           _s8B5d::I64 = I64[_s8B5h::P64 + 64];
           if (_s8B5d::I64 == _s8B53::I64) goto c8C3M; else goto c8C3L;
       c8C3M: // global
           _s8B5b::P64 = P64[_s8B5h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8C3L: // global
           _s8B4Z::P64 = P64[_s8B5h::P64 + 16];
           _s8B50::P64 = P64[_s8B5h::P64 + 24];
           _s8B4Y::I64 = I64[_s8B5h::P64 + 40];
           _s8B51::I64 = I64[_s8B5h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5d::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B5p_entry() //  [R1]
         { info_tbl: [(c8C49,
                       label: sat_s8B5p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C49: // global
           _s8B5p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8C4a; else goto c8C4b;
       c8C4b: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8C4d; else goto c8C4c;
       c8C4d: // global
           HpAlloc = 56;
           goto c8C4a;
       c8C4a: // global
           R1 = _s8B5p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8C4c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B5p::P64;
           _s8B53::I64 = I64[_s8B5p::P64 + 56];
           _s8B5l::I64 = I64[_s8B5p::P64 + 64];
           if (_s8B5l::I64 == _s8B53::I64) goto c8C48; else goto c8C47;
       c8C48: // global
           _s8B5b::P64 = P64[_s8B5p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8C47: // global
           _s8B4Z::P64 = P64[_s8B5p::P64 + 16];
           _s8B50::P64 = P64[_s8B5p::P64 + 24];
           _s8B4Y::I64 = I64[_s8B5p::P64 + 40];
           _s8B51::I64 = I64[_s8B5p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5l::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B6g_entry() //  [R1]
         { info_tbl: [(c8C5N,
                       label: sat_s8B6g_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C5N: // global
           _s8B6g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8C5O; else goto c8C5P;
       c8C5P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8C5R; else goto c8C5Q;
       c8C5R: // global
           HpAlloc = 56;
           goto c8C5O;
       c8C5O: // global
           R1 = _s8B6g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8C5Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B6g::P64;
           _s8B53::I64 = I64[_s8B6g::P64 + 56];
           _s8B5t::I64 = I64[_s8B6g::P64 + 64];
           if (_s8B5t::I64 == _s8B53::I64) goto c8C5M; else goto c8C5L;
       c8C5M: // global
           _s8B5b::P64 = P64[_s8B6g::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8C5L: // global
           _s8B4Z::P64 = P64[_s8B6g::P64 + 16];
           _s8B50::P64 = P64[_s8B6g::P64 + 24];
           _s8B4Y::I64 = I64[_s8B6g::P64 + 40];
           _s8B51::I64 = I64[_s8B6g::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5t::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B6l_entry() //  [R1]
         { info_tbl: [(c8C68,
                       label: sat_s8B6l_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C68: // global
           _s8B6l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8C69; else goto c8C6a;
       c8C6a: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8C6c; else goto c8C6b;
       c8C6c: // global
           HpAlloc = 56;
           goto c8C69;
       c8C69: // global
           R1 = _s8B6l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8C6b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B6l::P64;
           _s8B53::I64 = I64[_s8B6l::P64 + 56];
           _s8B5t::I64 = I64[_s8B6l::P64 + 64];
           if (_s8B5t::I64 == _s8B53::I64) goto c8C67; else goto c8C66;
       c8C67: // global
           _s8B5b::P64 = P64[_s8B6l::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8C66: // global
           _s8B4Z::P64 = P64[_s8B6l::P64 + 16];
           _s8B50::P64 = P64[_s8B6l::P64 + 24];
           _s8B4Y::I64 = I64[_s8B6l::P64 + 40];
           _s8B51::I64 = I64[_s8B6l::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5t::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF5_entry() //  [R2, R3]
         { info_tbl: [(c8C6f,
                       label: GHC.IO.Encoding.UTF32.mkUTF5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C6f: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8C6g; else goto c8C6h;
       c8C6g: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8C6h: // global
           I64[Sp - 16] = block_c8C3n_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8C7n; else goto c8C3o;
       u8C7n: // global
           call _c8C3n(R1) args: 0, res: 0, upd: 0;
       c8C3o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8C3n() //  [R1]
         { info_tbl: [(c8C3n,
                       label: block_c8C3n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C3n: // global
           I64[Sp - 40] = block_c8C3s_info;
           _s8B4Z::P64 = P64[R1 + 7];
           _s8B50::P64 = P64[R1 + 15];
           _s8B4Y::I64 = I64[R1 + 23];
           _s8B51::I64 = I64[R1 + 31];
           _s8B52::I64 = I64[R1 + 39];
           _s8B53::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8B50::P64;
           I64[Sp - 24] = _s8B51::I64;
           I64[Sp - 16] = _s8B52::I64;
           I64[Sp - 8] = _s8B53::I64;
           P64[Sp] = _s8B4Z::P64;
           I64[Sp + 8] = _s8B4Y::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8C7f; else goto c8C3t;
       u8C7f: // global
           call _c8C3s(R1) args: 0, res: 0, upd: 0;
       c8C3t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8C3s() //  [R1]
         { info_tbl: [(c8C3s,
                       label: block_c8C3s_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C3s: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8C6l; else goto c8C6k;
       c8C6l: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8C6k: // global
           _s8B56::P64 = P64[R1 + 7];
           _s8B57::P64 = P64[R1 + 15];
           _s8B55::I64 = I64[R1 + 23];
           _s8B58::I64 = I64[R1 + 31];
           _s8B59::I64 = I64[R1 + 39];
           _s8B5a::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8B56::P64;
           P64[Sp - 40] = _s8B57::P64;
           I64[Sp - 32] = _s8B58::I64;
           I64[Sp - 24] = _s8B59::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8B5a::I64;
           I64[Sp] = _s8B55::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8C4i() args: 0, res: 0, upd: 0;
     }
 },
 _c8C4i() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C4i: // global
           _s8B5t::I64 = I64[Sp + 32];
           _s8B5u::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8B5u::I64,
                            I64[Sp + 16])) goto c8C70; else goto c8C71;
       c8C70: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8B5t::I64,
                            4)) goto c8C6X; else goto c8C6Y;
       c8C6X: // global
           _s8B4Y::I64 = I64[Sp + 96];
           _s8B4Z::P64 = P64[Sp + 88];
           _s8B5C::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + _s8B5t::I64]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5I::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 1)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5O::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 2)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5U::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 3)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5W::I64 = (_s8B5C::I64 << 24) + ((_s8B5I::I64 << 16) + ((_s8B5O::I64 << 8) + _s8B5U::I64));
           if (%MO_S_Lt_W64(_s8B5W::I64, 0)) goto u8C78; else goto c8C6V;
       u8C78: // global
           I64[Sp - 16] = _s8B5W::I64;
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 24;
           goto u8C7j;
       c8C6V: // global
           if (%MO_S_Ge_W64(_s8B5W::I64, 55296)) goto u8C7a; else goto u8C79;
       u8C7a: // global
           I64[Sp - 16] = _s8B5W::I64;
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 24;
           goto u8C7j;
       u8C7j: // global
           call _c8C5y() args: 0, res: 0, upd: 0;
       u8C79: // global
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 8;
           call _s8B68() args: 0, res: 0, upd: 0;
       c8C6Y: // global
           I64[Sp + 32] = _s8B5u::I64;
           I64[Sp + 40] = _s8B5t::I64;
           Sp = Sp - 8;
           call _c8C3A() args: 0, res: 0, upd: 0;
       c8C71: // global
           I64[Sp + 32] = _s8B5u::I64;
           I64[Sp + 40] = _s8B5t::I64;
           Sp = Sp - 8;
           call _c8C3W() args: 0, res: 0, upd: 0;
     }
 },
 _c8C5y() //  []
         { info_tbl: [(c8C5y,
                       label: block_c8C5y_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C5y: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8C6B; else goto c8C6A;
       c8C6B: // global
           HpAlloc = 160;
           I64[Sp] = block_c8C5y_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8C6A: // global
           _c8C3x::P64 = P64[Sp + 96];
           _s8B4Y::I64 = I64[Sp + 120];
           _s8B4Z::P64 = P64[Sp + 112];
           _s8B50::P64 = P64[Sp + 80];
           _s8B51::I64 = I64[Sp + 88];
           _s8B53::I64 = I64[Sp + 104];
           _s8B55::I64 = I64[Sp + 72];
           _s8B56::P64 = P64[Sp + 24];
           _s8B57::P64 = P64[Sp + 32];
           _s8B58::I64 = I64[Sp + 40];
           _s8B59::I64 = I64[Sp + 48];
           _s8B5t::I64 = I64[Sp + 56];
           _s8B5u::I64 = I64[Sp + 64];
           _s8B67::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8B67::I64, 57343)) goto c8C6E; else goto c8C6J;
       c8C6E: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B56::P64;
           P64[Hp - 136] = _s8B57::P64;
           I64[Hp - 128] = _s8B55::I64;
           I64[Hp - 120] = _s8B58::I64;
           I64[Hp - 112] = _s8B59::I64;
           I64[Hp - 104] = _s8B5u::I64;
           I64[Hp - 96] = sat_s8B6g_info;
           P64[Hp - 80] = _s8B4Z::P64;
           P64[Hp - 72] = _s8B50::P64;
           P64[Hp - 64] = _c8C3x::P64;
           I64[Hp - 56] = _s8B4Y::I64;
           I64[Hp - 48] = _s8B51::I64;
           I64[Hp - 40] = _s8B53::I64;
           I64[Hp - 32] = _s8B5t::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8C6J: // global
           if (%MO_S_Gt_W64(_s8B67::I64,
                            1114111)) goto c8C6H; else goto c8C6I;
       c8C6H: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B56::P64;
           P64[Hp - 136] = _s8B57::P64;
           I64[Hp - 128] = _s8B55::I64;
           I64[Hp - 120] = _s8B58::I64;
           I64[Hp - 112] = _s8B59::I64;
           I64[Hp - 104] = _s8B5u::I64;
           I64[Hp - 96] = sat_s8B6l_info;
           P64[Hp - 80] = _s8B4Z::P64;
           P64[Hp - 72] = _s8B50::P64;
           P64[Hp - 64] = _c8C3x::P64;
           I64[Hp - 56] = _s8B4Y::I64;
           I64[Hp - 48] = _s8B51::I64;
           I64[Hp - 40] = _s8B53::I64;
           I64[Hp - 32] = _s8B5t::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8C6I: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8B68() args: 0, res: 0, upd: 0;
     }
 },
 _s8B68() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8B68: // global
           _s8B56::P64 = P64[Sp + 8];
           _s8B5t::I64 = I64[Sp + 40];
           _s8B5u::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8B5u::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8B56::P64);
           I64[Sp + 40] = _s8B5t::I64 + 4;
           I64[Sp + 48] = _s8B5u::I64 + 1;
           Sp = Sp + 8;
           call _c8C4i() args: 0, res: 0, upd: 0;
     }
 },
 _c8C3A() //  []
         { info_tbl: [(c8C3A,
                       label: block_c8C3A_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C3A: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8C6p; else goto c8C6o;
       c8C6p: // global
           HpAlloc = 160;
           I64[Sp] = block_c8C3A_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8C6o: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B5h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8C3W() //  []
         { info_tbl: [(c8C3W,
                       label: block_c8C3W_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C3W: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8C6t; else goto c8C6s;
       c8C6t: // global
           HpAlloc = 160;
           I64[Sp] = block_c8C3W_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8C6s: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B5p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.609102618 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_decode_entry() //  [R2, R3]
         { info_tbl: [(c8C7t,
                       label: GHC.IO.Encoding.UTF32.utf32be_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C7t: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.609886757 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32be3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32be3_bytes:
         I8[] [85,84,70,45,51,50,66,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.610652983 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be2_entry() //  [R1]
         { info_tbl: [(c8C7C,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C7C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8C7D; else goto c8C7E;
       c8C7D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8C7E: // global
           (_c8C7z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8C7z::I64 == 0) goto c8C7B; else goto c8C7A;
       c8C7B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8C7A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8C7z::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.612366586 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be_info;
         const 0;
 },
 sat_s8B6w_entry() //  [R1, R2, R3]
         { info_tbl: [(c8C7T,
                       label: sat_s8B6w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C7T: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B6y_entry() //  [R1]
         { info_tbl: [(c8C7X,
                       label: sat_s8B6y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C7X: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8C81; else goto c8C80;
       c8C81: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8C80: // global
           _s8B6q::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B6w_info;
           P64[Hp - 48] = _s8B6q::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B6s_entry() //  [R1, R2, R3]
         { info_tbl: [(c8C8c,
                       label: sat_s8B6s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C8c: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B6u_entry() //  [R1]
         { info_tbl: [(c8C8g,
                       label: sat_s8B6u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C8g: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8C8k; else goto c8C8j;
       c8C8k: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8C8j: // global
           _s8B6q::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B6s_info;
           P64[Hp - 48] = _s8B6q::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32be_entry() //  [R2]
         { info_tbl: [(c8C8m,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C8m: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8C8q; else goto c8C8p;
       c8C8q: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8C8p: // global
           I64[Hp - 56] = sat_s8B6y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B6u_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.61456341 UTC

[section ""data" . lvl3_r8AWr_closure" {
     lvl3_r8AWr_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.615281053 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be3_closure" {
     GHC.IO.Encoding.UTF32.utf32be3_closure:
         const GHC.IO.Encoding.UTF32.utf32be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be3_entry() //  []
         { info_tbl: [(c8C8v,
                       label: GHC.IO.Encoding.UTF32.utf32be3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C8v: // global
           R1 = lvl3_r8AWr_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.616070603 UTC

[section ""data" . lvl4_r8AWs_closure" {
     lvl4_r8AWs_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.616782485 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be1_closure" {
     GHC.IO.Encoding.UTF32.utf32be1_closure:
         const GHC.IO.Encoding.UTF32.utf32be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be1_entry() //  []
         { info_tbl: [(c8C8C,
                       label: GHC.IO.Encoding.UTF32.utf32be1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C8C: // global
           R1 = lvl4_r8AWs_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.617550678 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_closure" {
     GHC.IO.Encoding.UTF32.utf32be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const GHC.IO.Encoding.UTF32.utf32be3_closure+1;
         const GHC.IO.Encoding.UTF32.utf32be1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.618163834 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF6_closure" {
     GHC.IO.Encoding.UTF32.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.618824497 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF4_closure" {
     GHC.IO.Encoding.UTF32.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.621368935 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_decode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_decode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C8G: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8C8R,
                       label: GHC.IO.Encoding.UTF32.$wutf32_decode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C8R: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8C8S; else goto c8C8T;
       c8C8S: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8C8T: // global
           I64[Sp - 48] = block_c8C8K_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8Cb6; else goto c8C8L;
       u8Cb6: // global
           call _c8C8K(R1) args: 0, res: 0, upd: 0;
       c8C8L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8C8K() //  [R1]
         { info_tbl: [(c8C8K,
                       label: block_c8C8K_info
                       rep:StackRep [False, True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C8K: // global
           _s8B6C::I64 = I64[Sp + 16];
           _s8B6D::P64 = P64[Sp + 24];
           _s8B6E::P64 = P64[Sp + 32];
           _s8B6F::I64 = I64[Sp + 40];
           _s8B6G::I64 = I64[Sp + 48];
           _s8B6H::I64 = I64[Sp + 56];
           _s8B6I::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8C8O; else goto c8C8P;
       c8C8O: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8C8Y; else goto c8C8X;
       c8C8Y: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8C8X: // global
           if (%MO_S_Ge_W64(_s8B6H::I64 - _s8B6G::I64,
                            4)) goto c8CaT; else goto c8CaX;
       c8CaT: // global
           _s8B6B::P64 = P64[Sp + 8];
           _s8B6T::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + _s8B6G::I64]);
           call MO_Touch(_s8B6D::P64);
           _s8B6Z::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 1)]);
           call MO_Touch(_s8B6D::P64);
           _s8B75::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 2)]);
           call MO_Touch(_s8B6D::P64);
           _s8B7b::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 3)]);
           call MO_Touch(_s8B6D::P64);
           if (_s8B6T::I64 != 0) goto c8CaE; else goto c8CaR;
       c8CaR: // global
           if (_s8B6Z::I64 != 0) goto c8CaE; else goto c8CaQ;
       c8CaQ: // global
           if (_s8B75::I64 != 254) goto c8CaE; else goto c8CaP;
       c8CaP: // global
           if (_s8B7b::I64 != 255) goto c8CaE; else goto c8CaO;
       c8CaE: // global
           Hp = Hp - 88;
           I64[Sp - 24] = _s8B6Z::I64;
           I64[Sp - 16] = _s8B75::I64;
           I64[Sp - 8] = _s8B7b::I64;
           I64[Sp] = _s8B6T::I64;
           Sp = Sp - 32;
           call _c8C9x() args: 0, res: 0, upd: 0;
       c8CaO: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B6D::P64;
           P64[Hp - 64] = _s8B6E::P64;
           I64[Hp - 56] = _s8B6C::I64;
           I64[Hp - 48] = _s8B6F::I64;
           I64[Hp - 40] = _s8B6G::I64 + 4;
           I64[Hp - 32] = _s8B6H::I64;
           _c8CaN::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8B6I::P64;
           R2 = _c8CaN::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CaX: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B6D::P64;
           P64[Hp - 64] = _s8B6E::P64;
           I64[Hp - 56] = _s8B6C::I64;
           I64[Hp - 48] = _s8B6F::I64;
           I64[Hp - 40] = _s8B6G::I64;
           I64[Hp - 32] = _s8B6H::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8B6I::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8C8P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Cb3; else goto c8Cb2;
       c8Cb3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Cb2: // global
           _s8B7C::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           R1 = _s8B7C::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8C9x() //  []
         { info_tbl: [(c8C9x,
                       label: block_c8C9x_info
                       rep:StackRep [True, True, True, True, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C9x: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8C9B; else goto c8C9A;
       c8C9B: // global
           HpAlloc = 56;
           I64[Sp] = block_c8C9x_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8C9A: // global
           _s8B6B::P64 = P64[Sp + 40];
           _s8B6C::I64 = I64[Sp + 48];
           _s8B6D::P64 = P64[Sp + 56];
           _s8B6E::P64 = P64[Sp + 64];
           _s8B6F::I64 = I64[Sp + 72];
           _s8B6G::I64 = I64[Sp + 80];
           _s8B6H::I64 = I64[Sp + 88];
           _s8B6I::P64 = P64[Sp + 96];
           if (I64[Sp + 32] == 255) goto c8Cam; else goto c8C9J;
       c8Cam: // global
           if (I64[Sp + 8] == 254) goto c8Cal; else goto c8C9S;
       c8Cal: // global
           if (I64[Sp + 16] == 0) goto c8Cak; else goto c8Ca1;
       c8Cak: // global
           if (I64[Sp + 24] == 0) goto c8Caj; else goto c8Caa;
       c8Caj: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64 + 4;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8Caa: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8Ca1: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8C9S: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8C9J: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.625769647 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Cbe,
                       label: GHC.IO.Encoding.UTF32.utf32_decode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cbe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Cbi; else goto c8Cbj;
       c8Cbi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Cbj: // global
           I64[Sp - 24] = block_c8Cbb_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Cbr; else goto c8Cbc;
       u8Cbr: // global
           call _c8Cbb(R1) args: 0, res: 0, upd: 0;
       c8Cbc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Cbb() //  [R1]
         { info_tbl: [(c8Cbb,
                       label: block_c8Cbb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cbb: // global
           I64[Sp] = block_c8Cbh_info;
           _s8B7J::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8B7J::P64;
           if (R1 & 7 != 0) goto u8Cbq; else goto c8Cbl;
       u8Cbq: // global
           call _c8Cbh(R1) args: 0, res: 0, upd: 0;
       c8Cbl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Cbh() //  [R1]
         { info_tbl: [(c8Cbh,
                       label: block_c8Cbh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cbh: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.627236763 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Cbw,
                       label: GHC.IO.Encoding.UTF32.utf32_decode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cbw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.628942426 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_encode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_encode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CbA: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8CbL,
                       label: GHC.IO.Encoding.UTF32.$wutf32_encode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CbL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8CbM; else goto c8CbN;
       c8CbM: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8CbN: // global
           I64[Sp - 48] = block_c8CbE_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8CcH; else goto c8CbF;
       u8CcH: // global
           call _c8CbE(R1) args: 0, res: 0, upd: 0;
       c8CbF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CbE() //  [R1]
         { info_tbl: [(c8CbE,
                       label: block_c8CbE_info
                       rep:StackRep [False, False, True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CbE: // global
           _s8B7S::P64 = P64[Sp + 16];
           _s8B7T::I64 = I64[Sp + 24];
           _s8B7U::P64 = P64[Sp + 32];
           _s8B7V::P64 = P64[Sp + 40];
           _s8B7W::I64 = I64[Sp + 48];
           _s8B7X::I64 = I64[Sp + 56];
           _s8B7Y::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8CbI; else goto c8CbJ;
       c8CbI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8CbS; else goto c8CbR;
       c8CbS: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CbR: // global
           if (%MO_S_Ge_W64(_s8B7W::I64 - _s8B7Y::I64,
                            4)) goto c8Ccw; else goto c8CcA;
       c8Ccw: // global
           _s8B7R::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8B7R::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B7R::P64);
           I8[_s8B7T::I64 + _s8B7Y::I64] = 0 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 1)] = 0 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 2)] = 254 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 3)] = 255 :: W8;
           call MO_Touch(_s8B7U::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B7U::P64;
           P64[Hp - 64] = _s8B7V::P64;
           I64[Hp - 56] = _s8B7T::I64;
           I64[Hp - 48] = _s8B7W::I64;
           I64[Hp - 40] = _s8B7X::I64;
           I64[Hp - 32] = _s8B7Y::I64 + 4;
           _c8Ccu::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8Ccu::P64;
           R2 = _s8B7S::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CcA: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B7U::P64;
           P64[Hp - 64] = _s8B7V::P64;
           I64[Hp - 56] = _s8B7T::I64;
           I64[Hp - 48] = _s8B7W::I64;
           I64[Hp - 40] = _s8B7X::I64;
           I64[Hp - 32] = _s8B7Y::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8B7S::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CbJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CcG; else goto c8CcF;
       c8CcG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CcF: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B7U::P64;
           P64[Hp - 32] = _s8B7V::P64;
           I64[Hp - 24] = _s8B7T::I64;
           I64[Hp - 16] = _s8B7W::I64;
           I64[Hp - 8] = _s8B7X::I64;
           I64[Hp] = _s8B7Y::I64;
           R3 = Hp - 47;
           R2 = _s8B7S::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.631752355 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8CcP,
                       label: GHC.IO.Encoding.UTF32.utf32_encode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CcP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8CcT; else goto c8CcU;
       c8CcT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CcU: // global
           I64[Sp - 24] = block_c8CcM_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Cd2; else goto c8CcN;
       u8Cd2: // global
           call _c8CcM(R1) args: 0, res: 0, upd: 0;
       c8CcN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CcM() //  [R1]
         { info_tbl: [(c8CcM,
                       label: block_c8CcM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CcM: // global
           I64[Sp] = block_c8CcS_info;
           _s8B8w::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8B8w::P64;
           if (R1 & 7 != 0) goto u8Cd1; else goto c8CcW;
       u8Cd1: // global
           call _c8CcS(R1) args: 0, res: 0, upd: 0;
       c8CcW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CcS() //  [R1]
         { info_tbl: [(c8CcS,
                       label: block_c8CcS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CcS: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.633318616 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Cd7,
                       label: GHC.IO.Encoding.UTF32.utf32_encode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cd7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.636086025 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF8_bytes:
         I8[] [85,84,70,45,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.636810801 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF7_closure" {
     GHC.IO.Encoding.UTF32.mkUTF7_closure:
         const GHC.IO.Encoding.UTF32.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF7_entry() //  [R1]
         { info_tbl: [(c8Cdg,
                       label: GHC.IO.Encoding.UTF32.mkUTF7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cdg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cdh; else goto c8Cdi;
       c8Cdh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cdi: // global
           (_c8Cdd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Cdd::I64 == 0) goto c8Cdf; else goto c8Cde;
       c8Cdf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Cde: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Cdd::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.640129102 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32_info;
         const 0;
 },
 sat_s8B9o_entry() //  [R1, R2]
         { info_tbl: [(c8CdC,
                       label: sat_s8B9o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CdC: // global
           _s8B96::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8B96::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B96::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B9k_entry() //  [R1]
         { info_tbl: [(c8CdL,
                       label: sat_s8B9k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CdL: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B9i_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CdT,
                       label: sat_s8B9i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CdT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B9h_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Ce4,
                       label: sat_s8B9h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ce4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ce5; else goto c8Ce6;
       c8Ce5: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ce6: // global
           I64[Sp - 24] = block_c8Ce1_info;
           _s8B96::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8B96::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Cea; else goto c8Ce2;
       u8Cea: // global
           call _c8Ce1(R1) args: 0, res: 0, upd: 0;
       c8Ce2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ce1() //  [R1]
         { info_tbl: [(c8Ce1,
                       label: block_c8Ce1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ce1: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8B9q_entry() //  [R1]
         { info_tbl: [(c8Cec,
                       label: sat_s8B9q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cec: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ced; else goto c8Cee;
       c8Ced: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Cee: // global
           I64[Sp - 16] = block_c8Cds_info;
           _s8B8E::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8B8E::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Cds() //  [R1]
         { info_tbl: [(c8Cds,
                       label: block_c8Cds_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cds: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8Ceh; else goto c8Ceg;
       c8Ceh: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ceg: // global
           I64[Hp - 104] = sat_s8B9o_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8B9k_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8B9i_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8B9h_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B90_entry() //  [R1, R2]
         { info_tbl: [(c8Cex,
                       label: sat_s8B90_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cex: // global
           _s8B8I::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8B8I::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B8I::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B8W_entry() //  [R1]
         { info_tbl: [(c8CeG,
                       label: sat_s8B8W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CeG: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B8U_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CeO,
                       label: sat_s8B8U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CeO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B8T_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CeZ,
                       label: sat_s8B8T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CeZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Cf0; else goto c8Cf1;
       c8Cf0: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Cf1: // global
           I64[Sp - 24] = block_c8CeW_info;
           _s8B8I::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8B8I::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Cf5; else goto c8CeX;
       u8Cf5: // global
           call _c8CeW(R1) args: 0, res: 0, upd: 0;
       c8CeX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CeW() //  [R1]
         { info_tbl: [(c8CeW,
                       label: block_c8CeW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CeW: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8B92_entry() //  [R1]
         { info_tbl: [(c8Cf7,
                       label: sat_s8B92_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cf7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cf8; else goto c8Cf9;
       c8Cf8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Cf9: // global
           I64[Sp - 16] = block_c8Cen_info;
           _s8B8E::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8B8E::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Cen() //  [R1]
         { info_tbl: [(c8Cen,
                       label: block_c8Cen_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cen: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8Cfc; else goto c8Cfb;
       c8Cfc: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Cfb: // global
           I64[Hp - 104] = sat_s8B90_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8B8W_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8B8U_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8B8T_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32_entry() //  [R2]
         { info_tbl: [(c8Cfe,
                       label: GHC.IO.Encoding.UTF32.mkUTF32_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cfe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Cfi; else goto c8Cfh;
       c8Cfi: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Cfh: // global
           I64[Hp - 56] = sat_s8B9q_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B92_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.644543035 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_closure" {
     GHC.IO.Encoding.UTF32.utf32_closure:
         const GHC.IO.Encoding.UTF32.utf32_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32_entry() //  [R1]
         { info_tbl: [(c8Cfp,
                       label: GHC.IO.Encoding.UTF32.utf32_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cfp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cfq; else goto c8Cfr;
       c8Cfq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cfr: // global
           (_c8Cfm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Cfm::I64 == 0) goto c8Cfo; else goto c8Cfn;
       c8Cfo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Cfn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Cfm::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF32.mkUTF32_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.645456738 UTC

[section ""relreadonly" . S8Bun_srt" {
     S8Bun_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8AWo_closure;
         const lvl1_r8AWp_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF32.utf32be2_closure;
         const lvl2_r8AWq_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const lvl3_r8AWr_closure;
         const lvl4_r8AWs_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32_closure;
         const GHC.IO.Encoding.UTF32.mkUTF7_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.646371411 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:43.647562845 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule4_bytes" {
     GHC.IO.Encoding.UTF32.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.64944692 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule3_closure" {
     GHC.IO.Encoding.UTF32.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.65114721 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule2_bytes" {
     GHC.IO.Encoding.UTF32.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.652832825 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule1_closure" {
     GHC.IO.Encoding.UTF32.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.6546817 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule_closure" {
     GHC.IO.Encoding.UTF32.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF32.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF32.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.661489744 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le1_info;
 },
 sat_s8AWR_entry() //  [R1]
         { info_tbl: [(c8Cg1,
                       label: sat_s8AWR_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cg1: // global
           _s8AWR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cg2; else goto c8Cg3;
       c8Cg3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Cg5; else goto c8Cg4;
       c8Cg5: // global
           HpAlloc = 56;
           goto c8Cg2;
       c8Cg2: // global
           R1 = _s8AWR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cg4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AWR::P64;
           _s8AWD::I64 = I64[_s8AWR::P64 + 56];
           _s8AWN::I64 = I64[_s8AWR::P64 + 64];
           if (_s8AWN::I64 == _s8AWD::I64) goto c8Cg0; else goto c8CfZ;
       c8Cg0: // global
           _s8AWL::P64 = P64[_s8AWR::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CfZ: // global
           _s8AWz::P64 = P64[_s8AWR::P64 + 16];
           _s8AWA::P64 = P64[_s8AWR::P64 + 24];
           _s8AWy::I64 = I64[_s8AWR::P64 + 40];
           _s8AWB::I64 = I64[_s8AWR::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AWN::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AWZ_entry() //  [R1]
         { info_tbl: [(c8Cgn,
                       label: sat_s8AWZ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cgn: // global
           _s8AWZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cgo; else goto c8Cgp;
       c8Cgp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Cgr; else goto c8Cgq;
       c8Cgr: // global
           HpAlloc = 56;
           goto c8Cgo;
       c8Cgo: // global
           R1 = _s8AWZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cgq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AWZ::P64;
           _s8AWD::I64 = I64[_s8AWZ::P64 + 56];
           _s8AWV::I64 = I64[_s8AWZ::P64 + 64];
           if (_s8AWV::I64 == _s8AWD::I64) goto c8Cgm; else goto c8Cgl;
       c8Cgm: // global
           _s8AWL::P64 = P64[_s8AWZ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Cgl: // global
           _s8AWz::P64 = P64[_s8AWZ::P64 + 16];
           _s8AWA::P64 = P64[_s8AWZ::P64 + 24];
           _s8AWy::I64 = I64[_s8AWZ::P64 + 40];
           _s8AWB::I64 = I64[_s8AWZ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AWV::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AX7_entry() //  [R1]
         { info_tbl: [(c8CgJ,
                       label: sat_s8AX7_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CgJ: // global
           _s8AX7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CgK; else goto c8CgL;
       c8CgL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CgN; else goto c8CgM;
       c8CgN: // global
           HpAlloc = 56;
           goto c8CgK;
       c8CgK: // global
           R1 = _s8AX7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CgM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AX7::P64;
           _s8AWD::I64 = I64[_s8AX7::P64 + 56];
           _s8AX3::I64 = I64[_s8AX7::P64 + 64];
           if (_s8AX3::I64 == _s8AWD::I64) goto c8CgI; else goto c8CgH;
       c8CgI: // global
           _s8AWL::P64 = P64[_s8AX7::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CgH: // global
           _s8AWz::P64 = P64[_s8AX7::P64 + 16];
           _s8AWA::P64 = P64[_s8AX7::P64 + 24];
           _s8AWy::I64 = I64[_s8AX7::P64 + 40];
           _s8AWB::I64 = I64[_s8AX7::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AX3::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AXf_entry() //  [R1]
         { info_tbl: [(c8Ch5,
                       label: sat_s8AXf_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ch5: // global
           _s8AXf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ch6; else goto c8Ch7;
       c8Ch7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Ch9; else goto c8Ch8;
       c8Ch9: // global
           HpAlloc = 56;
           goto c8Ch6;
       c8Ch6: // global
           R1 = _s8AXf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ch8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AXf::P64;
           _s8AWD::I64 = I64[_s8AXf::P64 + 56];
           _s8AXb::I64 = I64[_s8AXf::P64 + 64];
           if (_s8AXb::I64 == _s8AWD::I64) goto c8Ch4; else goto c8Ch3;
       c8Ch4: // global
           _s8AWL::P64 = P64[_s8AXf::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Ch3: // global
           _s8AWz::P64 = P64[_s8AXf::P64 + 16];
           _s8AWA::P64 = P64[_s8AXf::P64 + 24];
           _s8AWy::I64 = I64[_s8AXf::P64 + 40];
           _s8AWB::I64 = I64[_s8AXf::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AXb::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8AXn_entry() //  [R1]
         { info_tbl: [(c8Chr,
                       label: sat_s8AXn_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Chr: // global
           _s8AXn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Chs; else goto c8Cht;
       c8Cht: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Chv; else goto c8Chu;
       c8Chv: // global
           HpAlloc = 56;
           goto c8Chs;
       c8Chs: // global
           R1 = _s8AXn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Chu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AXn::P64;
           _s8AWD::I64 = I64[_s8AXn::P64 + 56];
           _s8AXj::I64 = I64[_s8AXn::P64 + 64];
           if (_s8AXj::I64 == _s8AWD::I64) goto c8Chq; else goto c8Chp;
       c8Chq: // global
           _s8AWL::P64 = P64[_s8AXn::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AWL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Chp: // global
           _s8AWz::P64 = P64[_s8AXn::P64 + 16];
           _s8AWA::P64 = P64[_s8AXn::P64 + 24];
           _s8AWy::I64 = I64[_s8AXn::P64 + 40];
           _s8AWB::I64 = I64[_s8AXn::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = _s8AWA::P64;
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = _s8AWB::I64;
           I64[Hp - 8] = _s8AXj::I64;
           I64[Hp] = _s8AWD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32le1_entry() //  [R2, R3]
         { info_tbl: [(c8Chy,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Chy: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Chz; else goto c8ChA;
       c8Chz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ChA: // global
           I64[Sp - 16] = block_c8CfB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Cnc; else goto c8CfC;
       u8Cnc: // global
           call _c8CfB(R1) args: 0, res: 0, upd: 0;
       c8CfC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CfB() //  [R1]
         { info_tbl: [(c8CfB,
                       label: block_c8CfB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CfB: // global
           I64[Sp - 40] = block_c8CfG_info;
           _s8AWz::P64 = P64[R1 + 7];
           _s8AWA::P64 = P64[R1 + 15];
           _s8AWy::I64 = I64[R1 + 23];
           _s8AWB::I64 = I64[R1 + 31];
           _s8AWC::I64 = I64[R1 + 39];
           _s8AWD::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8AWA::P64;
           I64[Sp - 24] = _s8AWB::I64;
           I64[Sp - 16] = _s8AWC::I64;
           I64[Sp - 8] = _s8AWD::I64;
           P64[Sp] = _s8AWz::P64;
           I64[Sp + 8] = _s8AWy::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Cn6; else goto c8CfH;
       u8Cn6: // global
           call _c8CfG(R1) args: 0, res: 0, upd: 0;
       c8CfH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CfG() //  [R1]
         { info_tbl: [(c8CfG,
                       label: block_c8CfG_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CfG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ChE; else goto c8ChD;
       c8ChE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ChD: // global
           _s8AWG::P64 = P64[R1 + 7];
           _s8AWH::P64 = P64[R1 + 15];
           _s8AWF::I64 = I64[R1 + 23];
           _s8AWI::I64 = I64[R1 + 31];
           _s8AWJ::I64 = I64[R1 + 39];
           _s8AWK::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8AWz::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8AWz::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8AWy::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8AWy::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8AWD::I64 = I64[Sp + 32];
           _c8CfL::P64 = Hp - 47;
           _s8AXs::I64 = _s8AWK::I64;
           _s8AXr::I64 = I64[Sp + 24];
           goto c8Ci1;
       c8Ci1: // global
           if (%MO_S_Lt_W64(_s8AXr::I64,
                            _s8AWD::I64)) goto c8CiX; else goto c8CiY;
       c8CiX: // global
           if (%MO_S_Ge_W64(_s8AWI::I64 - _s8AXs::I64,
                            4)) goto c8CiU; else goto c8CiV;
       c8CiU: // global
           _s8AXz::I64 = %MO_UU_Conv_W32_W64(I32[_s8AWy::I64 + (_s8AXr::I64 << 2)]);
           call MO_Touch(_s8AWz::P64);
           if (%MO_S_Gt_W64(55296, _s8AXz::I64)) goto c8Ciy; else goto c8CiS;
       c8Ciy: // global
           if (%MO_S_Gt_W64(56320, _s8AXz::I64)) goto c8Cio; else goto c8Ciw;
       c8Cio: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8Ci1;
       c8Ciw: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 57343)) goto c8Ciu; else goto c8Civ;
       c8Ciu: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8Ci1;
       c8Civ: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8CfO() args: 0, res: 0, upd: 0;
       c8CiS: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 56319)) goto c8CiQ; else goto c8CiR;
       c8CiQ: // global
           if (%MO_S_Gt_W64(56320, _s8AXz::I64)) goto c8CiG; else goto c8CiO;
       c8CiG: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8Ci1;
       c8CiO: // global
           if (%MO_S_Gt_W64(_s8AXz::I64, 57343)) goto c8CiM; else goto c8CiN;
       c8CiM: // global
           I8[_s8AWF::I64 + _s8AXs::I64] = %MO_UU_Conv_W64_W8(_s8AXz::I64);
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  8));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  16));
           call MO_Touch(_s8AWG::P64);
           I8[_s8AWF::I64 + (_s8AXs::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8AXz::I64,
                                                                                  24));
           call MO_Touch(_s8AWG::P64);
           _s8AXs::I64 = _s8AXs::I64 + 4;
           _s8AXr::I64 = _s8AXr::I64 + 1;
           goto c8Ci1;
       c8CiN: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8Cga() args: 0, res: 0, upd: 0;
       c8CiR: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8Cgw() args: 0, res: 0, upd: 0;
       c8CiV: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8CgS() args: 0, res: 0, upd: 0;
       c8CiY: // global
           P64[Sp - 48] = _s8AWG::P64;
           P64[Sp - 40] = _s8AWH::P64;
           I64[Sp - 32] = _s8AWI::I64;
           I64[Sp - 24] = _s8AWJ::I64;
           I64[Sp - 16] = _s8AXr::I64;
           I64[Sp - 8] = _s8AXs::I64;
           I64[Sp] = _s8AWF::I64;
           P64[Sp + 24] = _c8CfL::P64;
           Sp = Sp - 56;
           call _c8Che() args: 0, res: 0, upd: 0;
     }
 },
 _c8CfO() //  []
         { info_tbl: [(c8CfO,
                       label: block_c8CfO_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CfO: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChI; else goto c8ChH;
       c8ChI: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CfO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChH: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AWR_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Cga() //  []
         { info_tbl: [(c8Cga,
                       label: block_c8Cga_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cga: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChM; else goto c8ChL;
       c8ChM: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Cga_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChL: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AWZ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Cgw() //  []
         { info_tbl: [(c8Cgw,
                       label: block_c8Cgw_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cgw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChQ; else goto c8ChP;
       c8ChQ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Cgw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChP: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AX7_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8CgS() //  []
         { info_tbl: [(c8CgS,
                       label: block_c8CgS_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CgS: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChU; else goto c8ChT;
       c8ChU: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CgS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChT: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AXf_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Che() //  []
         { info_tbl: [(c8Che,
                       label: block_c8Che_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Che: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ChY; else goto c8ChX;
       c8ChY: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Che_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ChX: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AXn_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.70461112 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_encode_entry() //  [R2, R3]
         { info_tbl: [(c8Cq5,
                       label: GHC.IO.Encoding.UTF32.utf32le_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cq5: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF32le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.713263067 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF1_info;
 },
 sat_s8AZT_entry() //  [R1]
         { info_tbl: [(c8CqG,
                       label: sat_s8AZT_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CqG: // global
           _s8AZT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CqH; else goto c8CqI;
       c8CqI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CqK; else goto c8CqJ;
       c8CqK: // global
           HpAlloc = 56;
           goto c8CqH;
       c8CqH: // global
           R1 = _s8AZT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CqJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8AZT::P64;
           _s8AZF::I64 = I64[_s8AZT::P64 + 56];
           _s8AZP::I64 = I64[_s8AZT::P64 + 64];
           if (_s8AZP::I64 == _s8AZF::I64) goto c8CqF; else goto c8CqE;
       c8CqF: // global
           _s8AZN::P64 = P64[_s8AZT::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CqE: // global
           _s8AZB::P64 = P64[_s8AZT::P64 + 16];
           _s8AZC::P64 = P64[_s8AZT::P64 + 24];
           _s8AZA::I64 = I64[_s8AZT::P64 + 40];
           _s8AZD::I64 = I64[_s8AZT::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8AZP::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B01_entry() //  [R1]
         { info_tbl: [(c8Cr2,
                       label: sat_s8B01_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cr2: // global
           _s8B01::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cr3; else goto c8Cr4;
       c8Cr4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Cr6; else goto c8Cr5;
       c8Cr6: // global
           HpAlloc = 56;
           goto c8Cr3;
       c8Cr3: // global
           R1 = _s8B01::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cr5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B01::P64;
           _s8AZF::I64 = I64[_s8B01::P64 + 56];
           _s8AZX::I64 = I64[_s8B01::P64 + 64];
           if (_s8AZX::I64 == _s8AZF::I64) goto c8Cr1; else goto c8Cr0;
       c8Cr1: // global
           _s8AZN::P64 = P64[_s8B01::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Cr0: // global
           _s8AZB::P64 = P64[_s8B01::P64 + 16];
           _s8AZC::P64 = P64[_s8B01::P64 + 24];
           _s8AZA::I64 = I64[_s8B01::P64 + 40];
           _s8AZD::I64 = I64[_s8B01::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8AZX::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B09_entry() //  [R1]
         { info_tbl: [(c8Cro,
                       label: sat_s8B09_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cro: // global
           _s8B09::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Crp; else goto c8Crq;
       c8Crq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Crs; else goto c8Crr;
       c8Crs: // global
           HpAlloc = 56;
           goto c8Crp;
       c8Crp: // global
           R1 = _s8B09::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Crr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B09::P64;
           _s8AZF::I64 = I64[_s8B09::P64 + 56];
           _s8B05::I64 = I64[_s8B09::P64 + 64];
           if (_s8B05::I64 == _s8AZF::I64) goto c8Crn; else goto c8Crm;
       c8Crn: // global
           _s8AZN::P64 = P64[_s8B09::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Crm: // global
           _s8AZB::P64 = P64[_s8B09::P64 + 16];
           _s8AZC::P64 = P64[_s8B09::P64 + 24];
           _s8AZA::I64 = I64[_s8B09::P64 + 40];
           _s8AZD::I64 = I64[_s8B09::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B05::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B0h_entry() //  [R1]
         { info_tbl: [(c8CrK,
                       label: sat_s8B0h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CrK: // global
           _s8B0h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CrL; else goto c8CrM;
       c8CrM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CrO; else goto c8CrN;
       c8CrO: // global
           HpAlloc = 56;
           goto c8CrL;
       c8CrL: // global
           R1 = _s8B0h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CrN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B0h::P64;
           _s8AZF::I64 = I64[_s8B0h::P64 + 56];
           _s8B0d::I64 = I64[_s8B0h::P64 + 64];
           if (_s8B0d::I64 == _s8AZF::I64) goto c8CrJ; else goto c8CrI;
       c8CrJ: // global
           _s8AZN::P64 = P64[_s8B0h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CrI: // global
           _s8AZB::P64 = P64[_s8B0h::P64 + 16];
           _s8AZC::P64 = P64[_s8B0h::P64 + 24];
           _s8AZA::I64 = I64[_s8B0h::P64 + 40];
           _s8AZD::I64 = I64[_s8B0h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B0d::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B0p_entry() //  [R1]
         { info_tbl: [(c8Cs6,
                       label: sat_s8B0p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cs6: // global
           _s8B0p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Cs7; else goto c8Cs8;
       c8Cs8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Csa; else goto c8Cs9;
       c8Csa: // global
           HpAlloc = 56;
           goto c8Cs7;
       c8Cs7: // global
           R1 = _s8B0p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Cs9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B0p::P64;
           _s8AZF::I64 = I64[_s8B0p::P64 + 56];
           _s8B0l::I64 = I64[_s8B0p::P64 + 64];
           if (_s8B0l::I64 == _s8AZF::I64) goto c8Cs5; else goto c8Cs4;
       c8Cs5: // global
           _s8AZN::P64 = P64[_s8B0p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8AZN::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Cs4: // global
           _s8AZB::P64 = P64[_s8B0p::P64 + 16];
           _s8AZC::P64 = P64[_s8B0p::P64 + 24];
           _s8AZA::I64 = I64[_s8B0p::P64 + 40];
           _s8AZD::I64 = I64[_s8B0p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = _s8AZC::P64;
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = _s8AZD::I64;
           I64[Hp - 8] = _s8B0l::I64;
           I64[Hp] = _s8AZF::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8Csd,
                       label: GHC.IO.Encoding.UTF32.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Csd: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Cse; else goto c8Csf;
       c8Cse: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Csf: // global
           I64[Sp - 16] = block_c8Cqg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CxR; else goto c8Cqh;
       u8CxR: // global
           call _c8Cqg(R1) args: 0, res: 0, upd: 0;
       c8Cqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Cqg() //  [R1]
         { info_tbl: [(c8Cqg,
                       label: block_c8Cqg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cqg: // global
           I64[Sp - 40] = block_c8Cql_info;
           _s8AZB::P64 = P64[R1 + 7];
           _s8AZC::P64 = P64[R1 + 15];
           _s8AZA::I64 = I64[R1 + 23];
           _s8AZD::I64 = I64[R1 + 31];
           _s8AZE::I64 = I64[R1 + 39];
           _s8AZF::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8AZC::P64;
           I64[Sp - 24] = _s8AZD::I64;
           I64[Sp - 16] = _s8AZE::I64;
           I64[Sp - 8] = _s8AZF::I64;
           P64[Sp] = _s8AZB::P64;
           I64[Sp + 8] = _s8AZA::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8CxL; else goto c8Cqm;
       u8CxL: // global
           call _c8Cql(R1) args: 0, res: 0, upd: 0;
       c8Cqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Cql() //  [R1]
         { info_tbl: [(c8Cql,
                       label: block_c8Cql_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cql: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Csj; else goto c8Csi;
       c8Csj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Csi: // global
           _s8AZI::P64 = P64[R1 + 7];
           _s8AZJ::P64 = P64[R1 + 15];
           _s8AZH::I64 = I64[R1 + 23];
           _s8AZK::I64 = I64[R1 + 31];
           _s8AZL::I64 = I64[R1 + 39];
           _s8AZM::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8AZB::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8AZB::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8AZA::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8AZA::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8AZF::I64 = I64[Sp + 32];
           _c8Cqq::P64 = Hp - 47;
           _s8B0u::I64 = _s8AZM::I64;
           _s8B0t::I64 = I64[Sp + 24];
           goto c8CsG;
       c8CsG: // global
           if (%MO_S_Lt_W64(_s8B0t::I64,
                            _s8AZF::I64)) goto c8CtC; else goto c8CtD;
       c8CtC: // global
           if (%MO_S_Ge_W64(_s8AZK::I64 - _s8B0u::I64,
                            4)) goto c8Ctz; else goto c8CtA;
       c8Ctz: // global
           _s8B0B::I64 = %MO_UU_Conv_W32_W64(I32[_s8AZA::I64 + (_s8B0t::I64 << 2)]);
           call MO_Touch(_s8AZB::P64);
           if (%MO_S_Gt_W64(55296, _s8B0B::I64)) goto c8Ctd; else goto c8Ctx;
       c8Ctd: // global
           if (%MO_S_Gt_W64(56320, _s8B0B::I64)) goto c8Ct3; else goto c8Ctb;
       c8Ct3: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8CsG;
       c8Ctb: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 57343)) goto c8Ct9; else goto c8Cta;
       c8Ct9: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8CsG;
       c8Cta: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8Cqt() args: 0, res: 0, upd: 0;
       c8Ctx: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 56319)) goto c8Ctv; else goto c8Ctw;
       c8Ctv: // global
           if (%MO_S_Gt_W64(56320, _s8B0B::I64)) goto c8Ctl; else goto c8Ctt;
       c8Ctl: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8CsG;
       c8Ctt: // global
           if (%MO_S_Gt_W64(_s8B0B::I64, 57343)) goto c8Ctr; else goto c8Cts;
       c8Ctr: // global
           I8[_s8AZH::I64 + _s8B0u::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                            24));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  16));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8B0B::I64,
                                                                                  8));
           call MO_Touch(_s8AZI::P64);
           I8[_s8AZH::I64 + (_s8B0u::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8B0B::I64);
           call MO_Touch(_s8AZI::P64);
           _s8B0u::I64 = _s8B0u::I64 + 4;
           _s8B0t::I64 = _s8B0t::I64 + 1;
           goto c8CsG;
       c8Cts: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8CqP() args: 0, res: 0, upd: 0;
       c8Ctw: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8Crb() args: 0, res: 0, upd: 0;
       c8CtA: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8Crx() args: 0, res: 0, upd: 0;
       c8CtD: // global
           P64[Sp - 48] = _s8AZI::P64;
           P64[Sp - 40] = _s8AZJ::P64;
           I64[Sp - 32] = _s8AZK::I64;
           I64[Sp - 24] = _s8AZL::I64;
           I64[Sp - 16] = _s8B0t::I64;
           I64[Sp - 8] = _s8B0u::I64;
           I64[Sp] = _s8AZH::I64;
           P64[Sp + 24] = _c8Cqq::P64;
           Sp = Sp - 56;
           call _c8CrT() args: 0, res: 0, upd: 0;
     }
 },
 _c8Cqt() //  []
         { info_tbl: [(c8Cqt,
                       label: block_c8Cqt_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cqt: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Csn; else goto c8Csm;
       c8Csn: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Cqt_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Csm: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8AZT_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8CqP() //  []
         { info_tbl: [(c8CqP,
                       label: block_c8CqP_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CqP: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Csr; else goto c8Csq;
       c8Csr: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CqP_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Csq: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B01_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Crb() //  []
         { info_tbl: [(c8Crb,
                       label: block_c8Crb_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Crb: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Csv; else goto c8Csu;
       c8Csv: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Crb_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Csu: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B09_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Crx() //  []
         { info_tbl: [(c8Crx,
                       label: block_c8Crx_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Crx: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Csz; else goto c8Csy;
       c8Csz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Crx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Csy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B0h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8CrT() //  []
         { info_tbl: [(c8CrT,
                       label: block_c8CrT_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CrT: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CsD; else goto c8CsC;
       c8CsD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CrT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CsC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8B0p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.755608905 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_encode_entry() //  [R2, R3]
         { info_tbl: [(c8CAK,
                       label: GHC.IO.Encoding.UTF32.utf32be_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CAK: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.762165532 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF3_closure" {
     GHC.IO.Encoding.UTF32.mkUTF3_closure:
         const GHC.IO.Encoding.UTF32.mkUTF3_info;
 },
 sat_s8B2V_entry() //  [R1]
         { info_tbl: [(c8CBl,
                       label: sat_s8B2V_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CBl: // global
           _s8B2V::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CBm; else goto c8CBn;
       c8CBn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CBp; else goto c8CBo;
       c8CBp: // global
           HpAlloc = 56;
           goto c8CBm;
       c8CBm: // global
           R1 = _s8B2V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CBo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B2V::P64;
           _s8B2H::I64 = I64[_s8B2V::P64 + 56];
           _s8B2R::I64 = I64[_s8B2V::P64 + 64];
           if (_s8B2R::I64 == _s8B2H::I64) goto c8CBk; else goto c8CBj;
       c8CBk: // global
           _s8B2P::P64 = P64[_s8B2V::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CBj: // global
           _s8B2D::P64 = P64[_s8B2V::P64 + 16];
           _s8B2E::P64 = P64[_s8B2V::P64 + 24];
           _s8B2C::I64 = I64[_s8B2V::P64 + 40];
           _s8B2F::I64 = I64[_s8B2V::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B2R::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B33_entry() //  [R1]
         { info_tbl: [(c8CBH,
                       label: sat_s8B33_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CBH: // global
           _s8B33::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CBI; else goto c8CBJ;
       c8CBJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CBL; else goto c8CBK;
       c8CBL: // global
           HpAlloc = 56;
           goto c8CBI;
       c8CBI: // global
           R1 = _s8B33::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CBK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B33::P64;
           _s8B2H::I64 = I64[_s8B33::P64 + 56];
           _s8B2Z::I64 = I64[_s8B33::P64 + 64];
           if (_s8B2Z::I64 == _s8B2H::I64) goto c8CBG; else goto c8CBF;
       c8CBG: // global
           _s8B2P::P64 = P64[_s8B33::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CBF: // global
           _s8B2D::P64 = P64[_s8B33::P64 + 16];
           _s8B2E::P64 = P64[_s8B33::P64 + 24];
           _s8B2C::I64 = I64[_s8B33::P64 + 40];
           _s8B2F::I64 = I64[_s8B33::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B2Z::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B3U_entry() //  [R1]
         { info_tbl: [(c8CDl,
                       label: sat_s8B3U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CDl: // global
           _s8B3U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CDm; else goto c8CDn;
       c8CDn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CDp; else goto c8CDo;
       c8CDp: // global
           HpAlloc = 56;
           goto c8CDm;
       c8CDm: // global
           R1 = _s8B3U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CDo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B3U::P64;
           _s8B2H::I64 = I64[_s8B3U::P64 + 56];
           _s8B37::I64 = I64[_s8B3U::P64 + 64];
           if (_s8B37::I64 == _s8B2H::I64) goto c8CDk; else goto c8CDj;
       c8CDk: // global
           _s8B2P::P64 = P64[_s8B3U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CDj: // global
           _s8B2D::P64 = P64[_s8B3U::P64 + 16];
           _s8B2E::P64 = P64[_s8B3U::P64 + 24];
           _s8B2C::I64 = I64[_s8B3U::P64 + 40];
           _s8B2F::I64 = I64[_s8B3U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B37::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B3Z_entry() //  [R1]
         { info_tbl: [(c8CDG,
                       label: sat_s8B3Z_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CDG: // global
           _s8B3Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CDH; else goto c8CDI;
       c8CDI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CDK; else goto c8CDJ;
       c8CDK: // global
           HpAlloc = 56;
           goto c8CDH;
       c8CDH: // global
           R1 = _s8B3Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CDJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B3Z::P64;
           _s8B2H::I64 = I64[_s8B3Z::P64 + 56];
           _s8B37::I64 = I64[_s8B3Z::P64 + 64];
           if (_s8B37::I64 == _s8B2H::I64) goto c8CDF; else goto c8CDE;
       c8CDF: // global
           _s8B2P::P64 = P64[_s8B3Z::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B2P::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CDE: // global
           _s8B2D::P64 = P64[_s8B3Z::P64 + 16];
           _s8B2E::P64 = P64[_s8B3Z::P64 + 24];
           _s8B2C::I64 = I64[_s8B3Z::P64 + 40];
           _s8B2F::I64 = I64[_s8B3Z::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B2D::P64;
           P64[Hp - 32] = _s8B2E::P64;
           I64[Hp - 24] = _s8B2C::I64;
           I64[Hp - 16] = _s8B2F::I64;
           I64[Hp - 8] = _s8B37::I64;
           I64[Hp] = _s8B2H::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF3_entry() //  [R2, R3]
         { info_tbl: [(c8CDN,
                       label: GHC.IO.Encoding.UTF32.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CDN: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8CDO; else goto c8CDP;
       c8CDO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CDP: // global
           I64[Sp - 16] = block_c8CAV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CEV; else goto c8CAW;
       u8CEV: // global
           call _c8CAV(R1) args: 0, res: 0, upd: 0;
       c8CAW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CAV() //  [R1]
         { info_tbl: [(c8CAV,
                       label: block_c8CAV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CAV: // global
           I64[Sp - 40] = block_c8CB0_info;
           _s8B2D::P64 = P64[R1 + 7];
           _s8B2E::P64 = P64[R1 + 15];
           _s8B2C::I64 = I64[R1 + 23];
           _s8B2F::I64 = I64[R1 + 31];
           _s8B2G::I64 = I64[R1 + 39];
           _s8B2H::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8B2E::P64;
           I64[Sp - 24] = _s8B2F::I64;
           I64[Sp - 16] = _s8B2G::I64;
           I64[Sp - 8] = _s8B2H::I64;
           P64[Sp] = _s8B2D::P64;
           I64[Sp + 8] = _s8B2C::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8CEN; else goto c8CB1;
       u8CEN: // global
           call _c8CB0(R1) args: 0, res: 0, upd: 0;
       c8CB1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CB0() //  [R1]
         { info_tbl: [(c8CB0,
                       label: block_c8CB0_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CB0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CDT; else goto c8CDS;
       c8CDT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CDS: // global
           _s8B2K::P64 = P64[R1 + 7];
           _s8B2L::P64 = P64[R1 + 15];
           _s8B2J::I64 = I64[R1 + 23];
           _s8B2M::I64 = I64[R1 + 31];
           _s8B2N::I64 = I64[R1 + 39];
           _s8B2O::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8B2K::P64;
           P64[Sp - 40] = _s8B2L::P64;
           I64[Sp - 32] = _s8B2M::I64;
           I64[Sp - 24] = _s8B2N::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8B2O::I64;
           I64[Sp] = _s8B2J::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8CBQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8CBQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CBQ: // global
           _s8B37::I64 = I64[Sp + 32];
           _s8B38::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8B38::I64,
                            I64[Sp + 16])) goto c8CEy; else goto c8CEz;
       c8CEy: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8B37::I64,
                            4)) goto c8CEv; else goto c8CEw;
       c8CEv: // global
           _s8B2C::I64 = I64[Sp + 96];
           _s8B2D::P64 = P64[Sp + 88];
           _s8B3g::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + _s8B37::I64]);
           call MO_Touch(_s8B2D::P64);
           _s8B3m::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 1)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3s::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 2)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3y::I64 = %MO_UU_Conv_W8_W64(I8[_s8B2C::I64 + (_s8B37::I64 + 3)]);
           call MO_Touch(_s8B2D::P64);
           _s8B3A::I64 = (_s8B3y::I64 << 24) + ((_s8B3s::I64 << 16) + ((_s8B3m::I64 << 8) + _s8B3g::I64));
           if (%MO_S_Lt_W64(_s8B3A::I64, 0)) goto u8CEG; else goto c8CEt;
       u8CEG: // global
           I64[Sp - 16] = _s8B3A::I64;
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 24;
           goto u8CER;
       c8CEt: // global
           if (%MO_S_Ge_W64(_s8B3A::I64, 55296)) goto u8CEI; else goto u8CEH;
       u8CEI: // global
           I64[Sp - 16] = _s8B3A::I64;
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 24;
           goto u8CER;
       u8CER: // global
           call _c8CD6() args: 0, res: 0, upd: 0;
       u8CEH: // global
           I64[Sp - 8] = _s8B3A::I64;
           Sp = Sp - 8;
           call _s8B3M() args: 0, res: 0, upd: 0;
       c8CEw: // global
           I64[Sp + 32] = _s8B38::I64;
           I64[Sp + 40] = _s8B37::I64;
           Sp = Sp - 8;
           call _c8CB8() args: 0, res: 0, upd: 0;
       c8CEz: // global
           I64[Sp + 32] = _s8B38::I64;
           I64[Sp + 40] = _s8B37::I64;
           Sp = Sp - 8;
           call _c8CBu() args: 0, res: 0, upd: 0;
     }
 },
 _c8CD6() //  []
         { info_tbl: [(c8CD6,
                       label: block_c8CD6_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CD6: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CE9; else goto c8CE8;
       c8CE9: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CD6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CE8: // global
           _c8CB5::P64 = P64[Sp + 96];
           _s8B2C::I64 = I64[Sp + 120];
           _s8B2D::P64 = P64[Sp + 112];
           _s8B2E::P64 = P64[Sp + 80];
           _s8B2F::I64 = I64[Sp + 88];
           _s8B2H::I64 = I64[Sp + 104];
           _s8B2J::I64 = I64[Sp + 72];
           _s8B2K::P64 = P64[Sp + 24];
           _s8B2L::P64 = P64[Sp + 32];
           _s8B2M::I64 = I64[Sp + 40];
           _s8B2N::I64 = I64[Sp + 48];
           _s8B37::I64 = I64[Sp + 56];
           _s8B38::I64 = I64[Sp + 64];
           _s8B3L::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8B3L::I64, 57343)) goto c8CEc; else goto c8CEh;
       c8CEc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B2K::P64;
           P64[Hp - 136] = _s8B2L::P64;
           I64[Hp - 128] = _s8B2J::I64;
           I64[Hp - 120] = _s8B2M::I64;
           I64[Hp - 112] = _s8B2N::I64;
           I64[Hp - 104] = _s8B38::I64;
           I64[Hp - 96] = sat_s8B3U_info;
           P64[Hp - 80] = _s8B2D::P64;
           P64[Hp - 72] = _s8B2E::P64;
           P64[Hp - 64] = _c8CB5::P64;
           I64[Hp - 56] = _s8B2C::I64;
           I64[Hp - 48] = _s8B2F::I64;
           I64[Hp - 40] = _s8B2H::I64;
           I64[Hp - 32] = _s8B37::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CEh: // global
           if (%MO_S_Gt_W64(_s8B3L::I64,
                            1114111)) goto c8CEf; else goto c8CEg;
       c8CEf: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B2K::P64;
           P64[Hp - 136] = _s8B2L::P64;
           I64[Hp - 128] = _s8B2J::I64;
           I64[Hp - 120] = _s8B2M::I64;
           I64[Hp - 112] = _s8B2N::I64;
           I64[Hp - 104] = _s8B38::I64;
           I64[Hp - 96] = sat_s8B3Z_info;
           P64[Hp - 80] = _s8B2D::P64;
           P64[Hp - 72] = _s8B2E::P64;
           P64[Hp - 64] = _c8CB5::P64;
           I64[Hp - 56] = _s8B2C::I64;
           I64[Hp - 48] = _s8B2F::I64;
           I64[Hp - 40] = _s8B2H::I64;
           I64[Hp - 32] = _s8B37::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CEg: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8B3M() args: 0, res: 0, upd: 0;
     }
 },
 _s8B3M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8B3M: // global
           _s8B2K::P64 = P64[Sp + 8];
           _s8B37::I64 = I64[Sp + 40];
           _s8B38::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8B38::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8B2K::P64);
           I64[Sp + 40] = _s8B37::I64 + 4;
           I64[Sp + 48] = _s8B38::I64 + 1;
           Sp = Sp + 8;
           call _c8CBQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8CB8() //  []
         { info_tbl: [(c8CB8,
                       label: block_c8CB8_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CB8: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CDX; else goto c8CDW;
       c8CDX: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CB8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CDW: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B2V_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8CBu() //  []
         { info_tbl: [(c8CBu,
                       label: block_c8CBu_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CBu: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CE1; else goto c8CE0;
       c8CE1: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CBu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CE0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B33_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.797621714 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_decode_entry() //  [R2, R3]
         { info_tbl: [(c8CGM,
                       label: GHC.IO.Encoding.UTF32.utf32le_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CGM: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.801639517 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32le3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32le3_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.803890235 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le2_entry() //  [R1]
         { info_tbl: [(c8CH0,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CH0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CH1; else goto c8CH2;
       c8CH1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CH2: // global
           (_c8CGX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8CGX::I64 == 0) goto c8CGZ; else goto c8CGY;
       c8CGZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8CGY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8CGX::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.809073386 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF2_entry() //  []
         { info_tbl: [(c8CHe,
                       label: GHC.IO.Encoding.UTF32.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CHe: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.812895062 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be1_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be1_entry() //  []
         { info_tbl: [(c8CHq,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CHq: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.817898884 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le_info;
         const 0;
 },
 sat_s8B4d_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CHM,
                       label: sat_s8B4d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CHM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B4f_entry() //  [R1]
         { info_tbl: [(c8CHQ,
                       label: sat_s8B4f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CHQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CHU; else goto c8CHT;
       c8CHU: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CHT: // global
           _s8B47::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B4d_info;
           P64[Hp - 48] = _s8B47::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B49_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CI5,
                       label: sat_s8B49_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CI5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B4b_entry() //  [R1]
         { info_tbl: [(c8CI9,
                       label: sat_s8B4b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CI9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CId; else goto c8CIc;
       c8CId: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CIc: // global
           _s8B47::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B49_info;
           P64[Hp - 48] = _s8B47::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32le_entry() //  [R2]
         { info_tbl: [(c8CIf,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CIf: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CIj; else goto c8CIi;
       c8CIj: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8CIi: // global
           I64[Hp - 56] = sat_s8B4f_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B4b_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.830952172 UTC

[section ""data" . lvl_r8AWo_closure" {
     lvl_r8AWo_closure:
         const lvl_r8AWo_info;
         const 0;
 },
 lvl_r8AWo_entry() //  [R2, R3]
         { info_tbl: [(c8CIO,
                       label: lvl_r8AWo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CIO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CIS; else goto c8CIT;
       c8CIS: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8AWo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CIT: // global
           I64[Sp - 16] = block_c8CIL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CJ1; else goto c8CIM;
       u8CJ1: // global
           call _c8CIL() args: 0, res: 0, upd: 0;
       c8CIM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CIL() //  []
         { info_tbl: [(c8CIL,
                       label: block_c8CIL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CIL: // global
           _s8B4h::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8CIR_info;
           R1 = _s8B4h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8CJ0; else goto c8CIV;
       u8CJ0: // global
           call _c8CIR() args: 0, res: 0, upd: 0;
       c8CIV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CIR() //  []
         { info_tbl: [(c8CIR,
                       label: block_c8CIR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CIR: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.839085887 UTC

[section ""data" . lvl1_r8AWp_closure" {
     lvl1_r8AWp_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.841048864 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le2_closure" {
     GHC.IO.Encoding.UTF32.utf32le2_closure:
         const GHC.IO.Encoding.UTF32.utf32le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le2_entry() //  []
         { info_tbl: [(c8CJk,
                       label: GHC.IO.Encoding.UTF32.utf32le2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CJk: // global
           R1 = lvl1_r8AWp_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.845326201 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be2_closure" {
     GHC.IO.Encoding.UTF32.utf32be2_closure:
         const GHC.IO.Encoding.UTF32.utf32be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be2_entry() //  [R2, R3]
         { info_tbl: [(c8CJz,
                       label: GHC.IO.Encoding.UTF32.utf32be2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CJz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8CJD; else goto c8CJE;
       c8CJD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CJE: // global
           I64[Sp - 16] = block_c8CJw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CJN; else goto c8CJx;
       u8CJN: // global
           call _c8CJw(R1) args: 0, res: 0, upd: 0;
       c8CJx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CJw() //  [R1]
         { info_tbl: [(c8CJw,
                       label: block_c8CJw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CJw: // global
           I64[Sp - 16] = block_c8CJC_info;
           _s8B4D::P64 = P64[R1 + 7];
           _s8B4C::I64 = I64[R1 + 23];
           _s8B4G::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8B4G::I64;
           P64[Sp] = _s8B4D::P64;
           I64[Sp + 8] = _s8B4C::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8CJM; else goto c8CJG;
       u8CJM: // global
           call _c8CJC() args: 0, res: 0, upd: 0;
       c8CJG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CJC() //  []
         { info_tbl: [(c8CJC,
                       label: block_c8CJC_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CJC: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.852881855 UTC

[section ""data" . lvl2_r8AWq_closure" {
     lvl2_r8AWq_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.85487136 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le1_closure" {
     GHC.IO.Encoding.UTF32.utf32le1_closure:
         const GHC.IO.Encoding.UTF32.utf32le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le1_entry() //  []
         { info_tbl: [(c8CK6,
                       label: GHC.IO.Encoding.UTF32.utf32le1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CK6: // global
           R1 = lvl2_r8AWq_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.858193077 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_closure" {
     GHC.IO.Encoding.UTF32.utf32le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.UTF32.utf32le2_closure+1;
         const GHC.IO.Encoding.UTF32.utf32le1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.863325344 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF5_closure" {
     GHC.IO.Encoding.UTF32.mkUTF5_closure:
         const GHC.IO.Encoding.UTF32.mkUTF5_info;
 },
 sat_s8B5h_entry() //  [R1]
         { info_tbl: [(c8CKJ,
                       label: sat_s8B5h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CKJ: // global
           _s8B5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CKK; else goto c8CKL;
       c8CKL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CKN; else goto c8CKM;
       c8CKN: // global
           HpAlloc = 56;
           goto c8CKK;
       c8CKK: // global
           R1 = _s8B5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CKM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B5h::P64;
           _s8B53::I64 = I64[_s8B5h::P64 + 56];
           _s8B5d::I64 = I64[_s8B5h::P64 + 64];
           if (_s8B5d::I64 == _s8B53::I64) goto c8CKI; else goto c8CKH;
       c8CKI: // global
           _s8B5b::P64 = P64[_s8B5h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CKH: // global
           _s8B4Z::P64 = P64[_s8B5h::P64 + 16];
           _s8B50::P64 = P64[_s8B5h::P64 + 24];
           _s8B4Y::I64 = I64[_s8B5h::P64 + 40];
           _s8B51::I64 = I64[_s8B5h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5d::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B5p_entry() //  [R1]
         { info_tbl: [(c8CL5,
                       label: sat_s8B5p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CL5: // global
           _s8B5p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CL6; else goto c8CL7;
       c8CL7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CL9; else goto c8CL8;
       c8CL9: // global
           HpAlloc = 56;
           goto c8CL6;
       c8CL6: // global
           R1 = _s8B5p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CL8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B5p::P64;
           _s8B53::I64 = I64[_s8B5p::P64 + 56];
           _s8B5l::I64 = I64[_s8B5p::P64 + 64];
           if (_s8B5l::I64 == _s8B53::I64) goto c8CL4; else goto c8CL3;
       c8CL4: // global
           _s8B5b::P64 = P64[_s8B5p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CL3: // global
           _s8B4Z::P64 = P64[_s8B5p::P64 + 16];
           _s8B50::P64 = P64[_s8B5p::P64 + 24];
           _s8B4Y::I64 = I64[_s8B5p::P64 + 40];
           _s8B51::I64 = I64[_s8B5p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5l::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B6g_entry() //  [R1]
         { info_tbl: [(c8CMJ,
                       label: sat_s8B6g_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CMJ: // global
           _s8B6g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CMK; else goto c8CML;
       c8CML: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CMN; else goto c8CMM;
       c8CMN: // global
           HpAlloc = 56;
           goto c8CMK;
       c8CMK: // global
           R1 = _s8B6g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CMM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B6g::P64;
           _s8B53::I64 = I64[_s8B6g::P64 + 56];
           _s8B5t::I64 = I64[_s8B6g::P64 + 64];
           if (_s8B5t::I64 == _s8B53::I64) goto c8CMI; else goto c8CMH;
       c8CMI: // global
           _s8B5b::P64 = P64[_s8B6g::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CMH: // global
           _s8B4Z::P64 = P64[_s8B6g::P64 + 16];
           _s8B50::P64 = P64[_s8B6g::P64 + 24];
           _s8B4Y::I64 = I64[_s8B6g::P64 + 40];
           _s8B51::I64 = I64[_s8B6g::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5t::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8B6l_entry() //  [R1]
         { info_tbl: [(c8CN4,
                       label: sat_s8B6l_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CN4: // global
           _s8B6l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8CN5; else goto c8CN6;
       c8CN6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CN8; else goto c8CN7;
       c8CN8: // global
           HpAlloc = 56;
           goto c8CN5;
       c8CN5: // global
           R1 = _s8B6l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CN7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8B6l::P64;
           _s8B53::I64 = I64[_s8B6l::P64 + 56];
           _s8B5t::I64 = I64[_s8B6l::P64 + 64];
           if (_s8B5t::I64 == _s8B53::I64) goto c8CN3; else goto c8CN2;
       c8CN3: // global
           _s8B5b::P64 = P64[_s8B6l::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8B5b::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8CN2: // global
           _s8B4Z::P64 = P64[_s8B6l::P64 + 16];
           _s8B50::P64 = P64[_s8B6l::P64 + 24];
           _s8B4Y::I64 = I64[_s8B6l::P64 + 40];
           _s8B51::I64 = I64[_s8B6l::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B4Z::P64;
           P64[Hp - 32] = _s8B50::P64;
           I64[Hp - 24] = _s8B4Y::I64;
           I64[Hp - 16] = _s8B51::I64;
           I64[Hp - 8] = _s8B5t::I64;
           I64[Hp] = _s8B53::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF5_entry() //  [R2, R3]
         { info_tbl: [(c8CNb,
                       label: GHC.IO.Encoding.UTF32.mkUTF5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CNb: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8CNc; else goto c8CNd;
       c8CNc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CNd: // global
           I64[Sp - 16] = block_c8CKj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8COj; else goto c8CKk;
       u8COj: // global
           call _c8CKj(R1) args: 0, res: 0, upd: 0;
       c8CKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CKj() //  [R1]
         { info_tbl: [(c8CKj,
                       label: block_c8CKj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CKj: // global
           I64[Sp - 40] = block_c8CKo_info;
           _s8B4Z::P64 = P64[R1 + 7];
           _s8B50::P64 = P64[R1 + 15];
           _s8B4Y::I64 = I64[R1 + 23];
           _s8B51::I64 = I64[R1 + 31];
           _s8B52::I64 = I64[R1 + 39];
           _s8B53::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8B50::P64;
           I64[Sp - 24] = _s8B51::I64;
           I64[Sp - 16] = _s8B52::I64;
           I64[Sp - 8] = _s8B53::I64;
           P64[Sp] = _s8B4Z::P64;
           I64[Sp + 8] = _s8B4Y::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8COb; else goto c8CKp;
       u8COb: // global
           call _c8CKo(R1) args: 0, res: 0, upd: 0;
       c8CKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CKo() //  [R1]
         { info_tbl: [(c8CKo,
                       label: block_c8CKo_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CKo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CNh; else goto c8CNg;
       c8CNh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CNg: // global
           _s8B56::P64 = P64[R1 + 7];
           _s8B57::P64 = P64[R1 + 15];
           _s8B55::I64 = I64[R1 + 23];
           _s8B58::I64 = I64[R1 + 31];
           _s8B59::I64 = I64[R1 + 39];
           _s8B5a::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8B56::P64;
           P64[Sp - 40] = _s8B57::P64;
           I64[Sp - 32] = _s8B58::I64;
           I64[Sp - 24] = _s8B59::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8B5a::I64;
           I64[Sp] = _s8B55::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8CLe() args: 0, res: 0, upd: 0;
     }
 },
 _c8CLe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CLe: // global
           _s8B5t::I64 = I64[Sp + 32];
           _s8B5u::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8B5u::I64,
                            I64[Sp + 16])) goto c8CNW; else goto c8CNX;
       c8CNW: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8B5t::I64,
                            4)) goto c8CNT; else goto c8CNU;
       c8CNT: // global
           _s8B4Y::I64 = I64[Sp + 96];
           _s8B4Z::P64 = P64[Sp + 88];
           _s8B5C::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + _s8B5t::I64]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5I::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 1)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5O::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 2)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5U::I64 = %MO_UU_Conv_W8_W64(I8[_s8B4Y::I64 + (_s8B5t::I64 + 3)]);
           call MO_Touch(_s8B4Z::P64);
           _s8B5W::I64 = (_s8B5C::I64 << 24) + ((_s8B5I::I64 << 16) + ((_s8B5O::I64 << 8) + _s8B5U::I64));
           if (%MO_S_Lt_W64(_s8B5W::I64, 0)) goto u8CO4; else goto c8CNR;
       u8CO4: // global
           I64[Sp - 16] = _s8B5W::I64;
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 24;
           goto u8COf;
       c8CNR: // global
           if (%MO_S_Ge_W64(_s8B5W::I64, 55296)) goto u8CO6; else goto u8CO5;
       u8CO6: // global
           I64[Sp - 16] = _s8B5W::I64;
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 24;
           goto u8COf;
       u8COf: // global
           call _c8CMu() args: 0, res: 0, upd: 0;
       u8CO5: // global
           I64[Sp - 8] = _s8B5W::I64;
           Sp = Sp - 8;
           call _s8B68() args: 0, res: 0, upd: 0;
       c8CNU: // global
           I64[Sp + 32] = _s8B5u::I64;
           I64[Sp + 40] = _s8B5t::I64;
           Sp = Sp - 8;
           call _c8CKw() args: 0, res: 0, upd: 0;
       c8CNX: // global
           I64[Sp + 32] = _s8B5u::I64;
           I64[Sp + 40] = _s8B5t::I64;
           Sp = Sp - 8;
           call _c8CKS() args: 0, res: 0, upd: 0;
     }
 },
 _c8CMu() //  []
         { info_tbl: [(c8CMu,
                       label: block_c8CMu_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CMu: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CNx; else goto c8CNw;
       c8CNx: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CMu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CNw: // global
           _c8CKt::P64 = P64[Sp + 96];
           _s8B4Y::I64 = I64[Sp + 120];
           _s8B4Z::P64 = P64[Sp + 112];
           _s8B50::P64 = P64[Sp + 80];
           _s8B51::I64 = I64[Sp + 88];
           _s8B53::I64 = I64[Sp + 104];
           _s8B55::I64 = I64[Sp + 72];
           _s8B56::P64 = P64[Sp + 24];
           _s8B57::P64 = P64[Sp + 32];
           _s8B58::I64 = I64[Sp + 40];
           _s8B59::I64 = I64[Sp + 48];
           _s8B5t::I64 = I64[Sp + 56];
           _s8B5u::I64 = I64[Sp + 64];
           _s8B67::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8B67::I64, 57343)) goto c8CNA; else goto c8CNF;
       c8CNA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B56::P64;
           P64[Hp - 136] = _s8B57::P64;
           I64[Hp - 128] = _s8B55::I64;
           I64[Hp - 120] = _s8B58::I64;
           I64[Hp - 112] = _s8B59::I64;
           I64[Hp - 104] = _s8B5u::I64;
           I64[Hp - 96] = sat_s8B6g_info;
           P64[Hp - 80] = _s8B4Z::P64;
           P64[Hp - 72] = _s8B50::P64;
           P64[Hp - 64] = _c8CKt::P64;
           I64[Hp - 56] = _s8B4Y::I64;
           I64[Hp - 48] = _s8B51::I64;
           I64[Hp - 40] = _s8B53::I64;
           I64[Hp - 32] = _s8B5t::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CNF: // global
           if (%MO_S_Gt_W64(_s8B67::I64,
                            1114111)) goto c8CND; else goto c8CNE;
       c8CND: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8B56::P64;
           P64[Hp - 136] = _s8B57::P64;
           I64[Hp - 128] = _s8B55::I64;
           I64[Hp - 120] = _s8B58::I64;
           I64[Hp - 112] = _s8B59::I64;
           I64[Hp - 104] = _s8B5u::I64;
           I64[Hp - 96] = sat_s8B6l_info;
           P64[Hp - 80] = _s8B4Z::P64;
           P64[Hp - 72] = _s8B50::P64;
           P64[Hp - 64] = _c8CKt::P64;
           I64[Hp - 56] = _s8B4Y::I64;
           I64[Hp - 48] = _s8B51::I64;
           I64[Hp - 40] = _s8B53::I64;
           I64[Hp - 32] = _s8B5t::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CNE: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8B68() args: 0, res: 0, upd: 0;
     }
 },
 _s8B68() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8B68: // global
           _s8B56::P64 = P64[Sp + 8];
           _s8B5t::I64 = I64[Sp + 40];
           _s8B5u::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8B5u::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8B56::P64);
           I64[Sp + 40] = _s8B5t::I64 + 4;
           I64[Sp + 48] = _s8B5u::I64 + 1;
           Sp = Sp + 8;
           call _c8CLe() args: 0, res: 0, upd: 0;
     }
 },
 _c8CKw() //  []
         { info_tbl: [(c8CKw,
                       label: block_c8CKw_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CKw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CNl; else goto c8CNk;
       c8CNl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CKw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CNk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B5h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8CKS() //  []
         { info_tbl: [(c8CKS,
                       label: block_c8CKS_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CKS: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8CNp; else goto c8CNo;
       c8CNp: // global
           HpAlloc = 160;
           I64[Sp] = block_c8CKS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CNo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8B5p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.89735552 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_decode_entry() //  [R2, R3]
         { info_tbl: [(c8CQa,
                       label: GHC.IO.Encoding.UTF32.utf32be_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CQa: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.900723121 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32be3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32be3_bytes:
         I8[] [85,84,70,45,51,50,66,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.902650721 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be2_entry() //  [R1]
         { info_tbl: [(c8CQo,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CQo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CQp; else goto c8CQq;
       c8CQp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CQq: // global
           (_c8CQl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8CQl::I64 == 0) goto c8CQn; else goto c8CQm;
       c8CQn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8CQm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8CQl::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.907337265 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be_info;
         const 0;
 },
 sat_s8B6w_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CQM,
                       label: sat_s8B6w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CQM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B6y_entry() //  [R1]
         { info_tbl: [(c8CQQ,
                       label: sat_s8B6y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CQQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CQU; else goto c8CQT;
       c8CQU: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CQT: // global
           _s8B6q::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B6w_info;
           P64[Hp - 48] = _s8B6q::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B6s_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CR5,
                       label: sat_s8B6s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CR5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B6u_entry() //  [R1]
         { info_tbl: [(c8CR9,
                       label: sat_s8B6u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CR9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CRd; else goto c8CRc;
       c8CRd: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CRc: // global
           _s8B6q::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8B6s_info;
           P64[Hp - 48] = _s8B6q::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32be_entry() //  [R2]
         { info_tbl: [(c8CRf,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CRf: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8CRj; else goto c8CRi;
       c8CRj: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8CRi: // global
           I64[Hp - 56] = sat_s8B6y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B6u_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.919001784 UTC

[section ""data" . lvl3_r8AWr_closure" {
     lvl3_r8AWr_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.920931337 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be3_closure" {
     GHC.IO.Encoding.UTF32.utf32be3_closure:
         const GHC.IO.Encoding.UTF32.utf32be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be3_entry() //  []
         { info_tbl: [(c8CRM,
                       label: GHC.IO.Encoding.UTF32.utf32be3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CRM: // global
           R1 = lvl3_r8AWr_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.924337142 UTC

[section ""data" . lvl4_r8AWs_closure" {
     lvl4_r8AWs_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.926354219 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be1_closure" {
     GHC.IO.Encoding.UTF32.utf32be1_closure:
         const GHC.IO.Encoding.UTF32.utf32be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be1_entry() //  []
         { info_tbl: [(c8CRZ,
                       label: GHC.IO.Encoding.UTF32.utf32be1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CRZ: // global
           R1 = lvl4_r8AWs_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.930251031 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_closure" {
     GHC.IO.Encoding.UTF32.utf32be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const GHC.IO.Encoding.UTF32.utf32be3_closure+1;
         const GHC.IO.Encoding.UTF32.utf32be1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.932119075 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF6_closure" {
     GHC.IO.Encoding.UTF32.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.933909418 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF4_closure" {
     GHC.IO.Encoding.UTF32.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.938581546 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_decode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_decode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CSb: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8CSm,
                       label: GHC.IO.Encoding.UTF32.$wutf32_decode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CSm: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8CSn; else goto c8CSo;
       c8CSn: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8CSo: // global
           I64[Sp - 48] = block_c8CSf_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8CUB; else goto c8CSg;
       u8CUB: // global
           call _c8CSf(R1) args: 0, res: 0, upd: 0;
       c8CSg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CSf() //  [R1]
         { info_tbl: [(c8CSf,
                       label: block_c8CSf_info
                       rep:StackRep [False, True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CSf: // global
           _s8B6C::I64 = I64[Sp + 16];
           _s8B6D::P64 = P64[Sp + 24];
           _s8B6E::P64 = P64[Sp + 32];
           _s8B6F::I64 = I64[Sp + 40];
           _s8B6G::I64 = I64[Sp + 48];
           _s8B6H::I64 = I64[Sp + 56];
           _s8B6I::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8CSj; else goto c8CSk;
       c8CSj: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8CSt; else goto c8CSs;
       c8CSt: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CSs: // global
           if (%MO_S_Ge_W64(_s8B6H::I64 - _s8B6G::I64,
                            4)) goto c8CUo; else goto c8CUs;
       c8CUo: // global
           _s8B6B::P64 = P64[Sp + 8];
           _s8B6T::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + _s8B6G::I64]);
           call MO_Touch(_s8B6D::P64);
           _s8B6Z::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 1)]);
           call MO_Touch(_s8B6D::P64);
           _s8B75::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 2)]);
           call MO_Touch(_s8B6D::P64);
           _s8B7b::I64 = %MO_UU_Conv_W8_W64(I8[_s8B6C::I64 + (_s8B6G::I64 + 3)]);
           call MO_Touch(_s8B6D::P64);
           if (_s8B6T::I64 != 0) goto c8CU9; else goto c8CUm;
       c8CUm: // global
           if (_s8B6Z::I64 != 0) goto c8CU9; else goto c8CUl;
       c8CUl: // global
           if (_s8B75::I64 != 254) goto c8CU9; else goto c8CUk;
       c8CUk: // global
           if (_s8B7b::I64 != 255) goto c8CU9; else goto c8CUj;
       c8CU9: // global
           Hp = Hp - 88;
           I64[Sp - 24] = _s8B6Z::I64;
           I64[Sp - 16] = _s8B75::I64;
           I64[Sp - 8] = _s8B7b::I64;
           I64[Sp] = _s8B6T::I64;
           Sp = Sp - 32;
           call _c8CT2() args: 0, res: 0, upd: 0;
       c8CUj: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B6D::P64;
           P64[Hp - 64] = _s8B6E::P64;
           I64[Hp - 56] = _s8B6C::I64;
           I64[Hp - 48] = _s8B6F::I64;
           I64[Hp - 40] = _s8B6G::I64 + 4;
           I64[Hp - 32] = _s8B6H::I64;
           _c8CUi::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8B6I::P64;
           R2 = _c8CUi::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CUs: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B6D::P64;
           P64[Hp - 64] = _s8B6E::P64;
           I64[Hp - 56] = _s8B6C::I64;
           I64[Hp - 48] = _s8B6F::I64;
           I64[Hp - 40] = _s8B6G::I64;
           I64[Hp - 32] = _s8B6H::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8B6I::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CSk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CUy; else goto c8CUx;
       c8CUy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CUx: // global
           _s8B7C::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           R1 = _s8B7C::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8CT2() //  []
         { info_tbl: [(c8CT2,
                       label: block_c8CT2_info
                       rep:StackRep [True, True, True, True, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CT2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CT6; else goto c8CT5;
       c8CT6: // global
           HpAlloc = 56;
           I64[Sp] = block_c8CT2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8CT5: // global
           _s8B6B::P64 = P64[Sp + 40];
           _s8B6C::I64 = I64[Sp + 48];
           _s8B6D::P64 = P64[Sp + 56];
           _s8B6E::P64 = P64[Sp + 64];
           _s8B6F::I64 = I64[Sp + 72];
           _s8B6G::I64 = I64[Sp + 80];
           _s8B6H::I64 = I64[Sp + 88];
           _s8B6I::P64 = P64[Sp + 96];
           if (I64[Sp + 32] == 255) goto c8CTR; else goto c8CTe;
       c8CTR: // global
           if (I64[Sp + 8] == 254) goto c8CTQ; else goto c8CTn;
       c8CTQ: // global
           if (I64[Sp + 16] == 0) goto c8CTP; else goto c8CTw;
       c8CTP: // global
           if (I64[Sp + 24] == 0) goto c8CTO; else goto c8CTF;
       c8CTO: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64 + 4;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CTF: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CTw: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CTn: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CTe: // global
           call MO_WriteBarrier();
           P64[_s8B6B::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B6B::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B6D::P64;
           P64[Hp - 32] = _s8B6E::P64;
           I64[Hp - 24] = _s8B6C::I64;
           I64[Hp - 16] = _s8B6F::I64;
           I64[Hp - 8] = _s8B6G::I64;
           I64[Hp] = _s8B6H::I64;
           R3 = _s8B6I::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.955477735 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8CVe,
                       label: GHC.IO.Encoding.UTF32.utf32_decode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CVe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8CVi; else goto c8CVj;
       c8CVi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CVj: // global
           I64[Sp - 24] = block_c8CVb_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8CVr; else goto c8CVc;
       u8CVr: // global
           call _c8CVb(R1) args: 0, res: 0, upd: 0;
       c8CVc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CVb() //  [R1]
         { info_tbl: [(c8CVb,
                       label: block_c8CVb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CVb: // global
           I64[Sp] = block_c8CVh_info;
           _s8B7J::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8B7J::P64;
           if (R1 & 7 != 0) goto u8CVq; else goto c8CVl;
       u8CVq: // global
           call _c8CVh(R1) args: 0, res: 0, upd: 0;
       c8CVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CVh() //  [R1]
         { info_tbl: [(c8CVh,
                       label: block_c8CVh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CVh: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.96290708 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8CVL,
                       label: GHC.IO.Encoding.UTF32.utf32_decode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CVL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.967125639 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_encode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_encode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CVT: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8CW4,
                       label: GHC.IO.Encoding.UTF32.$wutf32_encode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CW4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8CW5; else goto c8CW6;
       c8CW5: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8CW6: // global
           I64[Sp - 48] = block_c8CVX_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8CX0; else goto c8CVY;
       u8CX0: // global
           call _c8CVX(R1) args: 0, res: 0, upd: 0;
       c8CVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CVX() //  [R1]
         { info_tbl: [(c8CVX,
                       label: block_c8CVX_info
                       rep:StackRep [False, False, True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CVX: // global
           _s8B7S::P64 = P64[Sp + 16];
           _s8B7T::I64 = I64[Sp + 24];
           _s8B7U::P64 = P64[Sp + 32];
           _s8B7V::P64 = P64[Sp + 40];
           _s8B7W::I64 = I64[Sp + 48];
           _s8B7X::I64 = I64[Sp + 56];
           _s8B7Y::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8CW1; else goto c8CW2;
       c8CW1: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8CWb; else goto c8CWa;
       c8CWb: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CWa: // global
           if (%MO_S_Ge_W64(_s8B7W::I64 - _s8B7Y::I64,
                            4)) goto c8CWP; else goto c8CWT;
       c8CWP: // global
           _s8B7R::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8B7R::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B7R::P64);
           I8[_s8B7T::I64 + _s8B7Y::I64] = 0 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 1)] = 0 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 2)] = 254 :: W8;
           call MO_Touch(_s8B7U::P64);
           I8[_s8B7T::I64 + (_s8B7Y::I64 + 3)] = 255 :: W8;
           call MO_Touch(_s8B7U::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B7U::P64;
           P64[Hp - 64] = _s8B7V::P64;
           I64[Hp - 56] = _s8B7T::I64;
           I64[Hp - 48] = _s8B7W::I64;
           I64[Hp - 40] = _s8B7X::I64;
           I64[Hp - 32] = _s8B7Y::I64 + 4;
           _c8CWN::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8CWN::P64;
           R2 = _s8B7S::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8CWT: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8B7U::P64;
           P64[Hp - 64] = _s8B7V::P64;
           I64[Hp - 56] = _s8B7T::I64;
           I64[Hp - 48] = _s8B7W::I64;
           I64[Hp - 40] = _s8B7X::I64;
           I64[Hp - 32] = _s8B7Y::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8B7S::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8CW2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8CWZ; else goto c8CWY;
       c8CWZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CWY: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8B7U::P64;
           P64[Hp - 32] = _s8B7V::P64;
           I64[Hp - 24] = _s8B7T::I64;
           I64[Hp - 16] = _s8B7W::I64;
           I64[Hp - 8] = _s8B7X::I64;
           I64[Hp] = _s8B7Y::I64;
           R3 = Hp - 47;
           R2 = _s8B7S::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.978045194 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8CXu,
                       label: GHC.IO.Encoding.UTF32.utf32_encode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CXu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8CXy; else goto c8CXz;
       c8CXy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CXz: // global
           I64[Sp - 24] = block_c8CXr_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8CXH; else goto c8CXs;
       u8CXH: // global
           call _c8CXr(R1) args: 0, res: 0, upd: 0;
       c8CXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CXr() //  [R1]
         { info_tbl: [(c8CXr,
                       label: block_c8CXr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CXr: // global
           I64[Sp] = block_c8CXx_info;
           _s8B8w::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8B8w::P64;
           if (R1 & 7 != 0) goto u8CXG; else goto c8CXB;
       u8CXG: // global
           call _c8CXx(R1) args: 0, res: 0, upd: 0;
       c8CXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CXx() //  [R1]
         { info_tbl: [(c8CXx,
                       label: block_c8CXx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CXx: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.985585953 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8CY2,
                       label: GHC.IO.Encoding.UTF32.utf32_encode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CY2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.98887895 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF8_bytes:
         I8[] [85,84,70,45,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.991617444 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF7_closure" {
     GHC.IO.Encoding.UTF32.mkUTF7_closure:
         const GHC.IO.Encoding.UTF32.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF7_entry() //  [R1]
         { info_tbl: [(c8CYg,
                       label: GHC.IO.Encoding.UTF32.mkUTF7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CYh; else goto c8CYi;
       c8CYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8CYi: // global
           (_c8CYd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8CYd::I64 == 0) goto c8CYf; else goto c8CYe;
       c8CYf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8CYe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8CYd::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:43.997686753 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32_info;
         const 0;
 },
 sat_s8B9o_entry() //  [R1, R2]
         { info_tbl: [(c8CYJ,
                       label: sat_s8B9o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CYJ: // global
           _s8B96::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8B96::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B96::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B9k_entry() //  [R1]
         { info_tbl: [(c8CYS,
                       label: sat_s8B9k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CYS: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B9i_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CZ0,
                       label: sat_s8B9i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CZ0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B9h_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CZb,
                       label: sat_s8B9h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CZb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8CZc; else goto c8CZd;
       c8CZc: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8CZd: // global
           I64[Sp - 24] = block_c8CZ8_info;
           _s8B96::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8B96::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8CZh; else goto c8CZ9;
       u8CZh: // global
           call _c8CZ8(R1) args: 0, res: 0, upd: 0;
       c8CZ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CZ8() //  [R1]
         { info_tbl: [(c8CZ8,
                       label: block_c8CZ8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CZ8: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8B9q_entry() //  [R1]
         { info_tbl: [(c8CZj,
                       label: sat_s8B9q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8CZk; else goto c8CZl;
       c8CZk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8CZl: // global
           I64[Sp - 16] = block_c8CYz_info;
           _s8B8E::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8B8E::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CYz() //  [R1]
         { info_tbl: [(c8CYz,
                       label: block_c8CYz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CYz: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8CZo; else goto c8CZn;
       c8CZo: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8CZn: // global
           I64[Hp - 104] = sat_s8B9o_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8B9k_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8B9i_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8B9h_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B90_entry() //  [R1, R2]
         { info_tbl: [(c8CZE,
                       label: sat_s8B90_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CZE: // global
           _s8B8I::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8B8I::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8B8I::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B8W_entry() //  [R1]
         { info_tbl: [(c8CZN,
                       label: sat_s8B8W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CZN: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B8U_entry() //  [R1, R2, R3]
         { info_tbl: [(c8CZV,
                       label: sat_s8B8U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CZV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8B8T_entry() //  [R1, R2, R3]
         { info_tbl: [(c8D06,
                       label: sat_s8B8T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8D06: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8D07; else goto c8D08;
       c8D07: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8D08: // global
           I64[Sp - 24] = block_c8D03_info;
           _s8B8I::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8B8I::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8D0c; else goto c8D04;
       u8D0c: // global
           call _c8D03(R1) args: 0, res: 0, upd: 0;
       c8D04: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8D03() //  [R1]
         { info_tbl: [(c8D03,
                       label: block_c8D03_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8D03: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8B92_entry() //  [R1]
         { info_tbl: [(c8D0e,
                       label: sat_s8B92_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8D0e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8D0f; else goto c8D0g;
       c8D0f: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8D0g: // global
           I64[Sp - 16] = block_c8CZu_info;
           _s8B8E::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8B8E::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CZu() //  [R1]
         { info_tbl: [(c8CZu,
                       label: block_c8CZu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CZu: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8D0j; else goto c8D0i;
       c8D0j: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8D0i: // global
           I64[Hp - 104] = sat_s8B90_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8B8W_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8B8U_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8B8T_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32_entry() //  [R2]
         { info_tbl: [(c8D0l,
                       label: GHC.IO.Encoding.UTF32.mkUTF32_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8D0l: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8D0p; else goto c8D0o;
       c8D0p: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8D0o: // global
           I64[Hp - 56] = sat_s8B9q_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8B92_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:44.028194354 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_closure" {
     GHC.IO.Encoding.UTF32.utf32_closure:
         const GHC.IO.Encoding.UTF32.utf32_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32_entry() //  [R1]
         { info_tbl: [(c8D1O,
                       label: GHC.IO.Encoding.UTF32.utf32_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8D1O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8D1P; else goto c8D1Q;
       c8D1P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8D1Q: // global
           (_c8D1L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8D1L::I64 == 0) goto c8D1N; else goto c8D1M;
       c8D1N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8D1M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8D1L::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF32.mkUTF32_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:44.032521971 UTC

[section ""relreadonly" . S8Bun_srt" {
     S8Bun_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8AWo_closure;
         const lvl1_r8AWp_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF32.utf32be2_closure;
         const lvl2_r8AWq_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const lvl3_r8AWr_closure;
         const lvl4_r8AWs_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32_closure;
         const GHC.IO.Encoding.UTF32.mkUTF7_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.599506977 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:47.600630092 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule4_bytes" {
     GHC.IO.Encoding.UTF32.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.602417264 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule3_closure" {
     GHC.IO.Encoding.UTF32.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.604160779 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.$trModule2_bytes" {
     GHC.IO.Encoding.UTF32.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.605879974 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule1_closure" {
     GHC.IO.Encoding.UTF32.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF32.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.607634864 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$trModule_closure" {
     GHC.IO.Encoding.UTF32.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF32.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF32.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.614673831 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le1_info;
 },
 sat_s8D2m_entry() //  [R1]
         { info_tbl: [(c8Dfv,
                       label: sat_s8D2m_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dfv: // global
           _s8D2m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Dfw; else goto c8Dfx;
       c8Dfx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dfz; else goto c8Dfy;
       c8Dfz: // global
           HpAlloc = 56;
           goto c8Dfw;
       c8Dfw: // global
           R1 = _s8D2m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Dfy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2m::P64;
           _s8D28::I64 = I64[_s8D2m::P64 + 56];
           _s8D2i::I64 = I64[_s8D2m::P64 + 64];
           if (_s8D2i::I64 == _s8D28::I64) goto c8Dfu; else goto c8Dft;
       c8Dfu: // global
           _s8D2g::P64 = P64[_s8D2m::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Dft: // global
           _s8D24::P64 = P64[_s8D2m::P64 + 16];
           _s8D25::P64 = P64[_s8D2m::P64 + 24];
           _s8D23::I64 = I64[_s8D2m::P64 + 40];
           _s8D26::I64 = I64[_s8D2m::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2i::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D2u_entry() //  [R1]
         { info_tbl: [(c8DfR,
                       label: sat_s8D2u_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DfR: // global
           _s8D2u::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DfS; else goto c8DfT;
       c8DfT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DfV; else goto c8DfU;
       c8DfV: // global
           HpAlloc = 56;
           goto c8DfS;
       c8DfS: // global
           R1 = _s8D2u::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DfU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2u::P64;
           _s8D28::I64 = I64[_s8D2u::P64 + 56];
           _s8D2q::I64 = I64[_s8D2u::P64 + 64];
           if (_s8D2q::I64 == _s8D28::I64) goto c8DfQ; else goto c8DfP;
       c8DfQ: // global
           _s8D2g::P64 = P64[_s8D2u::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DfP: // global
           _s8D24::P64 = P64[_s8D2u::P64 + 16];
           _s8D25::P64 = P64[_s8D2u::P64 + 24];
           _s8D23::I64 = I64[_s8D2u::P64 + 40];
           _s8D26::I64 = I64[_s8D2u::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2q::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D2C_entry() //  [R1]
         { info_tbl: [(c8Dgd,
                       label: sat_s8D2C_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dgd: // global
           _s8D2C::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Dge; else goto c8Dgf;
       c8Dgf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dgh; else goto c8Dgg;
       c8Dgh: // global
           HpAlloc = 56;
           goto c8Dge;
       c8Dge: // global
           R1 = _s8D2C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Dgg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2C::P64;
           _s8D28::I64 = I64[_s8D2C::P64 + 56];
           _s8D2y::I64 = I64[_s8D2C::P64 + 64];
           if (_s8D2y::I64 == _s8D28::I64) goto c8Dgc; else goto c8Dgb;
       c8Dgc: // global
           _s8D2g::P64 = P64[_s8D2C::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Dgb: // global
           _s8D24::P64 = P64[_s8D2C::P64 + 16];
           _s8D25::P64 = P64[_s8D2C::P64 + 24];
           _s8D23::I64 = I64[_s8D2C::P64 + 40];
           _s8D26::I64 = I64[_s8D2C::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2y::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D2K_entry() //  [R1]
         { info_tbl: [(c8Dgz,
                       label: sat_s8D2K_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dgz: // global
           _s8D2K::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DgA; else goto c8DgB;
       c8DgB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DgD; else goto c8DgC;
       c8DgD: // global
           HpAlloc = 56;
           goto c8DgA;
       c8DgA: // global
           R1 = _s8D2K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DgC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2K::P64;
           _s8D28::I64 = I64[_s8D2K::P64 + 56];
           _s8D2G::I64 = I64[_s8D2K::P64 + 64];
           if (_s8D2G::I64 == _s8D28::I64) goto c8Dgy; else goto c8Dgx;
       c8Dgy: // global
           _s8D2g::P64 = P64[_s8D2K::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Dgx: // global
           _s8D24::P64 = P64[_s8D2K::P64 + 16];
           _s8D25::P64 = P64[_s8D2K::P64 + 24];
           _s8D23::I64 = I64[_s8D2K::P64 + 40];
           _s8D26::I64 = I64[_s8D2K::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2G::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D2S_entry() //  [R1]
         { info_tbl: [(c8DgV,
                       label: sat_s8D2S_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DgV: // global
           _s8D2S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DgW; else goto c8DgX;
       c8DgX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DgZ; else goto c8DgY;
       c8DgZ: // global
           HpAlloc = 56;
           goto c8DgW;
       c8DgW: // global
           R1 = _s8D2S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DgY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D2S::P64;
           _s8D28::I64 = I64[_s8D2S::P64 + 56];
           _s8D2O::I64 = I64[_s8D2S::P64 + 64];
           if (_s8D2O::I64 == _s8D28::I64) goto c8DgU; else goto c8DgT;
       c8DgU: // global
           _s8D2g::P64 = P64[_s8D2S::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D2g::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DgT: // global
           _s8D24::P64 = P64[_s8D2S::P64 + 16];
           _s8D25::P64 = P64[_s8D2S::P64 + 24];
           _s8D23::I64 = I64[_s8D2S::P64 + 40];
           _s8D26::I64 = I64[_s8D2S::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = _s8D25::P64;
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = _s8D26::I64;
           I64[Hp - 8] = _s8D2O::I64;
           I64[Hp] = _s8D28::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32le1_entry() //  [R2, R3]
         { info_tbl: [(c8Dh2,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dh2: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Dh3; else goto c8Dh4;
       c8Dh3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Dh4: // global
           I64[Sp - 16] = block_c8Df5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DmG; else goto c8Df6;
       u8DmG: // global
           call _c8Df5(R1) args: 0, res: 0, upd: 0;
       c8Df6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Df5() //  [R1]
         { info_tbl: [(c8Df5,
                       label: block_c8Df5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Df5: // global
           I64[Sp - 40] = block_c8Dfa_info;
           _s8D24::P64 = P64[R1 + 7];
           _s8D25::P64 = P64[R1 + 15];
           _s8D23::I64 = I64[R1 + 23];
           _s8D26::I64 = I64[R1 + 31];
           _s8D27::I64 = I64[R1 + 39];
           _s8D28::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8D25::P64;
           I64[Sp - 24] = _s8D26::I64;
           I64[Sp - 16] = _s8D27::I64;
           I64[Sp - 8] = _s8D28::I64;
           P64[Sp] = _s8D24::P64;
           I64[Sp + 8] = _s8D23::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8DmA; else goto c8Dfb;
       u8DmA: // global
           call _c8Dfa(R1) args: 0, res: 0, upd: 0;
       c8Dfb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Dfa() //  [R1]
         { info_tbl: [(c8Dfa,
                       label: block_c8Dfa_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dfa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dh8; else goto c8Dh7;
       c8Dh8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Dh7: // global
           _s8D2b::P64 = P64[R1 + 7];
           _s8D2c::P64 = P64[R1 + 15];
           _s8D2a::I64 = I64[R1 + 23];
           _s8D2d::I64 = I64[R1 + 31];
           _s8D2e::I64 = I64[R1 + 39];
           _s8D2f::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8D24::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8D24::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8D23::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8D23::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8D28::I64 = I64[Sp + 32];
           _c8Dff::P64 = Hp - 47;
           _s8D2X::I64 = _s8D2f::I64;
           _s8D2W::I64 = I64[Sp + 24];
           goto c8Dhv;
       c8Dhv: // global
           if (%MO_S_Lt_W64(_s8D2W::I64,
                            _s8D28::I64)) goto c8Dir; else goto c8Dis;
       c8Dir: // global
           if (%MO_S_Ge_W64(_s8D2d::I64 - _s8D2X::I64,
                            4)) goto c8Dio; else goto c8Dip;
       c8Dio: // global
           _s8D34::I64 = %MO_UU_Conv_W32_W64(I32[_s8D23::I64 + (_s8D2W::I64 << 2)]);
           call MO_Touch(_s8D24::P64);
           if (%MO_S_Gt_W64(55296, _s8D34::I64)) goto c8Di2; else goto c8Dim;
       c8Di2: // global
           if (%MO_S_Gt_W64(56320, _s8D34::I64)) goto c8DhS; else goto c8Di0;
       c8DhS: // global
           I8[_s8D2a::I64 + _s8D2X::I64] = %MO_UU_Conv_W64_W8(_s8D34::I64);
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  8));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  16));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  24));
           call MO_Touch(_s8D2b::P64);
           _s8D2X::I64 = _s8D2X::I64 + 4;
           _s8D2W::I64 = _s8D2W::I64 + 1;
           goto c8Dhv;
       c8Di0: // global
           if (%MO_S_Gt_W64(_s8D34::I64, 57343)) goto c8DhY; else goto c8DhZ;
       c8DhY: // global
           I8[_s8D2a::I64 + _s8D2X::I64] = %MO_UU_Conv_W64_W8(_s8D34::I64);
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  8));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  16));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  24));
           call MO_Touch(_s8D2b::P64);
           _s8D2X::I64 = _s8D2X::I64 + 4;
           _s8D2W::I64 = _s8D2W::I64 + 1;
           goto c8Dhv;
       c8DhZ: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8Dfi() args: 0, res: 0, upd: 0;
       c8Dim: // global
           if (%MO_S_Gt_W64(_s8D34::I64, 56319)) goto c8Dik; else goto c8Dil;
       c8Dik: // global
           if (%MO_S_Gt_W64(56320, _s8D34::I64)) goto c8Dia; else goto c8Dii;
       c8Dia: // global
           I8[_s8D2a::I64 + _s8D2X::I64] = %MO_UU_Conv_W64_W8(_s8D34::I64);
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  8));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  16));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  24));
           call MO_Touch(_s8D2b::P64);
           _s8D2X::I64 = _s8D2X::I64 + 4;
           _s8D2W::I64 = _s8D2W::I64 + 1;
           goto c8Dhv;
       c8Dii: // global
           if (%MO_S_Gt_W64(_s8D34::I64, 57343)) goto c8Dig; else goto c8Dih;
       c8Dig: // global
           I8[_s8D2a::I64 + _s8D2X::I64] = %MO_UU_Conv_W64_W8(_s8D34::I64);
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  8));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  16));
           call MO_Touch(_s8D2b::P64);
           I8[_s8D2a::I64 + (_s8D2X::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D34::I64,
                                                                                  24));
           call MO_Touch(_s8D2b::P64);
           _s8D2X::I64 = _s8D2X::I64 + 4;
           _s8D2W::I64 = _s8D2W::I64 + 1;
           goto c8Dhv;
       c8Dih: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8DfE() args: 0, res: 0, upd: 0;
       c8Dil: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8Dg0() args: 0, res: 0, upd: 0;
       c8Dip: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8Dgm() args: 0, res: 0, upd: 0;
       c8Dis: // global
           P64[Sp - 48] = _s8D2b::P64;
           P64[Sp - 40] = _s8D2c::P64;
           I64[Sp - 32] = _s8D2d::I64;
           I64[Sp - 24] = _s8D2e::I64;
           I64[Sp - 16] = _s8D2W::I64;
           I64[Sp - 8] = _s8D2X::I64;
           I64[Sp] = _s8D2a::I64;
           P64[Sp + 24] = _c8Dff::P64;
           Sp = Sp - 56;
           call _c8DgI() args: 0, res: 0, upd: 0;
     }
 },
 _c8Dfi() //  []
         { info_tbl: [(c8Dfi,
                       label: block_c8Dfi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dfi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dhc; else goto c8Dhb;
       c8Dhc: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Dfi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhb: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2m_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8DfE() //  []
         { info_tbl: [(c8DfE,
                       label: block_c8DfE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DfE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dhg; else goto c8Dhf;
       c8Dhg: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DfE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhf: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2u_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Dg0() //  []
         { info_tbl: [(c8Dg0,
                       label: block_c8Dg0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dg0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dhk; else goto c8Dhj;
       c8Dhk: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Dg0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhj: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2C_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Dgm() //  []
         { info_tbl: [(c8Dgm,
                       label: block_c8Dgm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dgm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dho; else goto c8Dhn;
       c8Dho: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Dgm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhn: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2K_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8DgI() //  []
         { info_tbl: [(c8DgI,
                       label: block_c8DgI_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DgI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dhs; else goto c8Dhr;
       c8Dhs: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DgI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dhr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D2S_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.674036107 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_encode_entry() //  [R2, R3]
         { info_tbl: [(c8Dqg,
                       label: GHC.IO.Encoding.UTF32.utf32le_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dqg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF32le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.682688665 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF1_info;
 },
 sat_s8D5o_entry() //  [R1]
         { info_tbl: [(c8DqR,
                       label: sat_s8D5o_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DqR: // global
           _s8D5o::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DqS; else goto c8DqT;
       c8DqT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DqV; else goto c8DqU;
       c8DqV: // global
           HpAlloc = 56;
           goto c8DqS;
       c8DqS: // global
           R1 = _s8D5o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DqU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5o::P64;
           _s8D5a::I64 = I64[_s8D5o::P64 + 56];
           _s8D5k::I64 = I64[_s8D5o::P64 + 64];
           if (_s8D5k::I64 == _s8D5a::I64) goto c8DqQ; else goto c8DqP;
       c8DqQ: // global
           _s8D5i::P64 = P64[_s8D5o::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DqP: // global
           _s8D56::P64 = P64[_s8D5o::P64 + 16];
           _s8D57::P64 = P64[_s8D5o::P64 + 24];
           _s8D55::I64 = I64[_s8D5o::P64 + 40];
           _s8D58::I64 = I64[_s8D5o::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5k::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D5w_entry() //  [R1]
         { info_tbl: [(c8Drd,
                       label: sat_s8D5w_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Drd: // global
           _s8D5w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Dre; else goto c8Drf;
       c8Drf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Drh; else goto c8Drg;
       c8Drh: // global
           HpAlloc = 56;
           goto c8Dre;
       c8Dre: // global
           R1 = _s8D5w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Drg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5w::P64;
           _s8D5a::I64 = I64[_s8D5w::P64 + 56];
           _s8D5s::I64 = I64[_s8D5w::P64 + 64];
           if (_s8D5s::I64 == _s8D5a::I64) goto c8Drc; else goto c8Drb;
       c8Drc: // global
           _s8D5i::P64 = P64[_s8D5w::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Drb: // global
           _s8D56::P64 = P64[_s8D5w::P64 + 16];
           _s8D57::P64 = P64[_s8D5w::P64 + 24];
           _s8D55::I64 = I64[_s8D5w::P64 + 40];
           _s8D58::I64 = I64[_s8D5w::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5s::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D5E_entry() //  [R1]
         { info_tbl: [(c8Drz,
                       label: sat_s8D5E_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Drz: // global
           _s8D5E::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DrA; else goto c8DrB;
       c8DrB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DrD; else goto c8DrC;
       c8DrD: // global
           HpAlloc = 56;
           goto c8DrA;
       c8DrA: // global
           R1 = _s8D5E::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DrC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5E::P64;
           _s8D5a::I64 = I64[_s8D5E::P64 + 56];
           _s8D5A::I64 = I64[_s8D5E::P64 + 64];
           if (_s8D5A::I64 == _s8D5a::I64) goto c8Dry; else goto c8Drx;
       c8Dry: // global
           _s8D5i::P64 = P64[_s8D5E::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Drx: // global
           _s8D56::P64 = P64[_s8D5E::P64 + 16];
           _s8D57::P64 = P64[_s8D5E::P64 + 24];
           _s8D55::I64 = I64[_s8D5E::P64 + 40];
           _s8D58::I64 = I64[_s8D5E::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5A::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D5M_entry() //  [R1]
         { info_tbl: [(c8DrV,
                       label: sat_s8D5M_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DrV: // global
           _s8D5M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DrW; else goto c8DrX;
       c8DrX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DrZ; else goto c8DrY;
       c8DrZ: // global
           HpAlloc = 56;
           goto c8DrW;
       c8DrW: // global
           R1 = _s8D5M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DrY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5M::P64;
           _s8D5a::I64 = I64[_s8D5M::P64 + 56];
           _s8D5I::I64 = I64[_s8D5M::P64 + 64];
           if (_s8D5I::I64 == _s8D5a::I64) goto c8DrU; else goto c8DrT;
       c8DrU: // global
           _s8D5i::P64 = P64[_s8D5M::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DrT: // global
           _s8D56::P64 = P64[_s8D5M::P64 + 16];
           _s8D57::P64 = P64[_s8D5M::P64 + 24];
           _s8D55::I64 = I64[_s8D5M::P64 + 40];
           _s8D58::I64 = I64[_s8D5M::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5I::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D5U_entry() //  [R1]
         { info_tbl: [(c8Dsh,
                       label: sat_s8D5U_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dsh: // global
           _s8D5U::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Dsi; else goto c8Dsj;
       c8Dsj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dsl; else goto c8Dsk;
       c8Dsl: // global
           HpAlloc = 56;
           goto c8Dsi;
       c8Dsi: // global
           R1 = _s8D5U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Dsk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D5U::P64;
           _s8D5a::I64 = I64[_s8D5U::P64 + 56];
           _s8D5Q::I64 = I64[_s8D5U::P64 + 64];
           if (_s8D5Q::I64 == _s8D5a::I64) goto c8Dsg; else goto c8Dsf;
       c8Dsg: // global
           _s8D5i::P64 = P64[_s8D5U::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D5i::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Dsf: // global
           _s8D56::P64 = P64[_s8D5U::P64 + 16];
           _s8D57::P64 = P64[_s8D5U::P64 + 24];
           _s8D55::I64 = I64[_s8D5U::P64 + 40];
           _s8D58::I64 = I64[_s8D5U::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = _s8D57::P64;
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = _s8D58::I64;
           I64[Hp - 8] = _s8D5Q::I64;
           I64[Hp] = _s8D5a::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8Dso,
                       label: GHC.IO.Encoding.UTF32.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dso: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Dsp; else goto c8Dsq;
       c8Dsp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Dsq: // global
           I64[Sp - 16] = block_c8Dqr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Dy2; else goto c8Dqs;
       u8Dy2: // global
           call _c8Dqr(R1) args: 0, res: 0, upd: 0;
       c8Dqs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Dqr() //  [R1]
         { info_tbl: [(c8Dqr,
                       label: block_c8Dqr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dqr: // global
           I64[Sp - 40] = block_c8Dqw_info;
           _s8D56::P64 = P64[R1 + 7];
           _s8D57::P64 = P64[R1 + 15];
           _s8D55::I64 = I64[R1 + 23];
           _s8D58::I64 = I64[R1 + 31];
           _s8D59::I64 = I64[R1 + 39];
           _s8D5a::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8D57::P64;
           I64[Sp - 24] = _s8D58::I64;
           I64[Sp - 16] = _s8D59::I64;
           I64[Sp - 8] = _s8D5a::I64;
           P64[Sp] = _s8D56::P64;
           I64[Sp + 8] = _s8D55::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8DxW; else goto c8Dqx;
       u8DxW: // global
           call _c8Dqw(R1) args: 0, res: 0, upd: 0;
       c8Dqx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Dqw() //  [R1]
         { info_tbl: [(c8Dqw,
                       label: block_c8Dqw_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dqw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Dsu; else goto c8Dst;
       c8Dsu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Dst: // global
           _s8D5d::P64 = P64[R1 + 7];
           _s8D5e::P64 = P64[R1 + 15];
           _s8D5c::I64 = I64[R1 + 23];
           _s8D5f::I64 = I64[R1 + 31];
           _s8D5g::I64 = I64[R1 + 39];
           _s8D5h::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8D56::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8D56::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8D55::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8D55::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8D5a::I64 = I64[Sp + 32];
           _c8DqB::P64 = Hp - 47;
           _s8D5Z::I64 = _s8D5h::I64;
           _s8D5Y::I64 = I64[Sp + 24];
           goto c8DsR;
       c8DsR: // global
           if (%MO_S_Lt_W64(_s8D5Y::I64,
                            _s8D5a::I64)) goto c8DtN; else goto c8DtO;
       c8DtN: // global
           if (%MO_S_Ge_W64(_s8D5f::I64 - _s8D5Z::I64,
                            4)) goto c8DtK; else goto c8DtL;
       c8DtK: // global
           _s8D66::I64 = %MO_UU_Conv_W32_W64(I32[_s8D55::I64 + (_s8D5Y::I64 << 2)]);
           call MO_Touch(_s8D56::P64);
           if (%MO_S_Gt_W64(55296, _s8D66::I64)) goto c8Dto; else goto c8DtI;
       c8Dto: // global
           if (%MO_S_Gt_W64(56320, _s8D66::I64)) goto c8Dte; else goto c8Dtm;
       c8Dte: // global
           I8[_s8D5c::I64 + _s8D5Z::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                            24));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  16));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  8));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8D66::I64);
           call MO_Touch(_s8D5d::P64);
           _s8D5Z::I64 = _s8D5Z::I64 + 4;
           _s8D5Y::I64 = _s8D5Y::I64 + 1;
           goto c8DsR;
       c8Dtm: // global
           if (%MO_S_Gt_W64(_s8D66::I64, 57343)) goto c8Dtk; else goto c8Dtl;
       c8Dtk: // global
           I8[_s8D5c::I64 + _s8D5Z::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                            24));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  16));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  8));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8D66::I64);
           call MO_Touch(_s8D5d::P64);
           _s8D5Z::I64 = _s8D5Z::I64 + 4;
           _s8D5Y::I64 = _s8D5Y::I64 + 1;
           goto c8DsR;
       c8Dtl: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8DqE() args: 0, res: 0, upd: 0;
       c8DtI: // global
           if (%MO_S_Gt_W64(_s8D66::I64, 56319)) goto c8DtG; else goto c8DtH;
       c8DtG: // global
           if (%MO_S_Gt_W64(56320, _s8D66::I64)) goto c8Dtw; else goto c8DtE;
       c8Dtw: // global
           I8[_s8D5c::I64 + _s8D5Z::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                            24));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  16));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  8));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8D66::I64);
           call MO_Touch(_s8D5d::P64);
           _s8D5Z::I64 = _s8D5Z::I64 + 4;
           _s8D5Y::I64 = _s8D5Y::I64 + 1;
           goto c8DsR;
       c8DtE: // global
           if (%MO_S_Gt_W64(_s8D66::I64, 57343)) goto c8DtC; else goto c8DtD;
       c8DtC: // global
           I8[_s8D5c::I64 + _s8D5Z::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                            24));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  16));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8D66::I64,
                                                                                  8));
           call MO_Touch(_s8D5d::P64);
           I8[_s8D5c::I64 + (_s8D5Z::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8D66::I64);
           call MO_Touch(_s8D5d::P64);
           _s8D5Z::I64 = _s8D5Z::I64 + 4;
           _s8D5Y::I64 = _s8D5Y::I64 + 1;
           goto c8DsR;
       c8DtD: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8Dr0() args: 0, res: 0, upd: 0;
       c8DtH: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8Drm() args: 0, res: 0, upd: 0;
       c8DtL: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8DrI() args: 0, res: 0, upd: 0;
       c8DtO: // global
           P64[Sp - 48] = _s8D5d::P64;
           P64[Sp - 40] = _s8D5e::P64;
           I64[Sp - 32] = _s8D5f::I64;
           I64[Sp - 24] = _s8D5g::I64;
           I64[Sp - 16] = _s8D5Y::I64;
           I64[Sp - 8] = _s8D5Z::I64;
           I64[Sp] = _s8D5c::I64;
           P64[Sp + 24] = _c8DqB::P64;
           Sp = Sp - 56;
           call _c8Ds4() args: 0, res: 0, upd: 0;
     }
 },
 _c8DqE() //  []
         { info_tbl: [(c8DqE,
                       label: block_c8DqE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DqE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Dsy; else goto c8Dsx;
       c8Dsy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DqE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Dsx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5o_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Dr0() //  []
         { info_tbl: [(c8Dr0,
                       label: block_c8Dr0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dr0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DsC; else goto c8DsB;
       c8DsC: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Dr0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DsB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5w_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Drm() //  []
         { info_tbl: [(c8Drm,
                       label: block_c8Drm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Drm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DsG; else goto c8DsF;
       c8DsG: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Drm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DsF: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5E_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8DrI() //  []
         { info_tbl: [(c8DrI,
                       label: block_c8DrI_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DrI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DsK; else goto c8DsJ;
       c8DsK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DrI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DsJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5M_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ds4() //  []
         { info_tbl: [(c8Ds4,
                       label: block_c8Ds4_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ds4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DsO; else goto c8DsN;
       c8DsO: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ds4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DsN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8D5U_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.724914104 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_encode_entry() //  [R2, R3]
         { info_tbl: [(c8DBC,
                       label: GHC.IO.Encoding.UTF32.utf32be_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DBC: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.732548483 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF3_closure" {
     GHC.IO.Encoding.UTF32.mkUTF3_closure:
         const GHC.IO.Encoding.UTF32.mkUTF3_info;
 },
 sat_s8D8q_entry() //  [R1]
         { info_tbl: [(c8DCd,
                       label: sat_s8D8q_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DCd: // global
           _s8D8q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DCe; else goto c8DCf;
       c8DCf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DCh; else goto c8DCg;
       c8DCh: // global
           HpAlloc = 56;
           goto c8DCe;
       c8DCe: // global
           R1 = _s8D8q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DCg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D8q::P64;
           _s8D8c::I64 = I64[_s8D8q::P64 + 56];
           _s8D8m::I64 = I64[_s8D8q::P64 + 64];
           if (_s8D8m::I64 == _s8D8c::I64) goto c8DCc; else goto c8DCb;
       c8DCc: // global
           _s8D8k::P64 = P64[_s8D8q::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D8k::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DCb: // global
           _s8D88::P64 = P64[_s8D8q::P64 + 16];
           _s8D89::P64 = P64[_s8D8q::P64 + 24];
           _s8D87::I64 = I64[_s8D8q::P64 + 40];
           _s8D8a::I64 = I64[_s8D8q::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D88::P64;
           P64[Hp - 32] = _s8D89::P64;
           I64[Hp - 24] = _s8D87::I64;
           I64[Hp - 16] = _s8D8a::I64;
           I64[Hp - 8] = _s8D8m::I64;
           I64[Hp] = _s8D8c::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D8y_entry() //  [R1]
         { info_tbl: [(c8DCz,
                       label: sat_s8D8y_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DCz: // global
           _s8D8y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DCA; else goto c8DCB;
       c8DCB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DCD; else goto c8DCC;
       c8DCD: // global
           HpAlloc = 56;
           goto c8DCA;
       c8DCA: // global
           R1 = _s8D8y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DCC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D8y::P64;
           _s8D8c::I64 = I64[_s8D8y::P64 + 56];
           _s8D8u::I64 = I64[_s8D8y::P64 + 64];
           if (_s8D8u::I64 == _s8D8c::I64) goto c8DCy; else goto c8DCx;
       c8DCy: // global
           _s8D8k::P64 = P64[_s8D8y::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D8k::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DCx: // global
           _s8D88::P64 = P64[_s8D8y::P64 + 16];
           _s8D89::P64 = P64[_s8D8y::P64 + 24];
           _s8D87::I64 = I64[_s8D8y::P64 + 40];
           _s8D8a::I64 = I64[_s8D8y::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D88::P64;
           P64[Hp - 32] = _s8D89::P64;
           I64[Hp - 24] = _s8D87::I64;
           I64[Hp - 16] = _s8D8a::I64;
           I64[Hp - 8] = _s8D8u::I64;
           I64[Hp] = _s8D8c::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D9p_entry() //  [R1]
         { info_tbl: [(c8DEd,
                       label: sat_s8D9p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DEd: // global
           _s8D9p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DEe; else goto c8DEf;
       c8DEf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DEh; else goto c8DEg;
       c8DEh: // global
           HpAlloc = 56;
           goto c8DEe;
       c8DEe: // global
           R1 = _s8D9p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DEg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D9p::P64;
           _s8D8c::I64 = I64[_s8D9p::P64 + 56];
           _s8D8C::I64 = I64[_s8D9p::P64 + 64];
           if (_s8D8C::I64 == _s8D8c::I64) goto c8DEc; else goto c8DEb;
       c8DEc: // global
           _s8D8k::P64 = P64[_s8D9p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D8k::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DEb: // global
           _s8D88::P64 = P64[_s8D9p::P64 + 16];
           _s8D89::P64 = P64[_s8D9p::P64 + 24];
           _s8D87::I64 = I64[_s8D9p::P64 + 40];
           _s8D8a::I64 = I64[_s8D9p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D88::P64;
           P64[Hp - 32] = _s8D89::P64;
           I64[Hp - 24] = _s8D87::I64;
           I64[Hp - 16] = _s8D8a::I64;
           I64[Hp - 8] = _s8D8C::I64;
           I64[Hp] = _s8D8c::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8D9u_entry() //  [R1]
         { info_tbl: [(c8DEy,
                       label: sat_s8D9u_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DEy: // global
           _s8D9u::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DEz; else goto c8DEA;
       c8DEA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DEC; else goto c8DEB;
       c8DEC: // global
           HpAlloc = 56;
           goto c8DEz;
       c8DEz: // global
           R1 = _s8D9u::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DEB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8D9u::P64;
           _s8D8c::I64 = I64[_s8D9u::P64 + 56];
           _s8D8C::I64 = I64[_s8D9u::P64 + 64];
           if (_s8D8C::I64 == _s8D8c::I64) goto c8DEx; else goto c8DEw;
       c8DEx: // global
           _s8D8k::P64 = P64[_s8D9u::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8D8k::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DEw: // global
           _s8D88::P64 = P64[_s8D9u::P64 + 16];
           _s8D89::P64 = P64[_s8D9u::P64 + 24];
           _s8D87::I64 = I64[_s8D9u::P64 + 40];
           _s8D8a::I64 = I64[_s8D9u::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8D88::P64;
           P64[Hp - 32] = _s8D89::P64;
           I64[Hp - 24] = _s8D87::I64;
           I64[Hp - 16] = _s8D8a::I64;
           I64[Hp - 8] = _s8D8C::I64;
           I64[Hp] = _s8D8c::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF3_entry() //  [R2, R3]
         { info_tbl: [(c8DEF,
                       label: GHC.IO.Encoding.UTF32.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DEF: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8DEG; else goto c8DEH;
       c8DEG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DEH: // global
           I64[Sp - 16] = block_c8DBN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DFN; else goto c8DBO;
       u8DFN: // global
           call _c8DBN(R1) args: 0, res: 0, upd: 0;
       c8DBO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DBN() //  [R1]
         { info_tbl: [(c8DBN,
                       label: block_c8DBN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DBN: // global
           I64[Sp - 40] = block_c8DBS_info;
           _s8D88::P64 = P64[R1 + 7];
           _s8D89::P64 = P64[R1 + 15];
           _s8D87::I64 = I64[R1 + 23];
           _s8D8a::I64 = I64[R1 + 31];
           _s8D8b::I64 = I64[R1 + 39];
           _s8D8c::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8D89::P64;
           I64[Sp - 24] = _s8D8a::I64;
           I64[Sp - 16] = _s8D8b::I64;
           I64[Sp - 8] = _s8D8c::I64;
           P64[Sp] = _s8D88::P64;
           I64[Sp + 8] = _s8D87::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8DFF; else goto c8DBT;
       u8DFF: // global
           call _c8DBS(R1) args: 0, res: 0, upd: 0;
       c8DBT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DBS() //  [R1]
         { info_tbl: [(c8DBS,
                       label: block_c8DBS_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DBS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DEL; else goto c8DEK;
       c8DEL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DEK: // global
           _s8D8f::P64 = P64[R1 + 7];
           _s8D8g::P64 = P64[R1 + 15];
           _s8D8e::I64 = I64[R1 + 23];
           _s8D8h::I64 = I64[R1 + 31];
           _s8D8i::I64 = I64[R1 + 39];
           _s8D8j::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8D8f::P64;
           P64[Sp - 40] = _s8D8g::P64;
           I64[Sp - 32] = _s8D8h::I64;
           I64[Sp - 24] = _s8D8i::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8D8j::I64;
           I64[Sp] = _s8D8e::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8DCI() args: 0, res: 0, upd: 0;
     }
 },
 _c8DCI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DCI: // global
           _s8D8C::I64 = I64[Sp + 32];
           _s8D8D::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8D8D::I64,
                            I64[Sp + 16])) goto c8DFq; else goto c8DFr;
       c8DFq: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8D8C::I64,
                            4)) goto c8DFn; else goto c8DFo;
       c8DFn: // global
           _s8D87::I64 = I64[Sp + 96];
           _s8D88::P64 = P64[Sp + 88];
           _s8D8L::I64 = %MO_UU_Conv_W8_W64(I8[_s8D87::I64 + _s8D8C::I64]);
           call MO_Touch(_s8D88::P64);
           _s8D8R::I64 = %MO_UU_Conv_W8_W64(I8[_s8D87::I64 + (_s8D8C::I64 + 1)]);
           call MO_Touch(_s8D88::P64);
           _s8D8X::I64 = %MO_UU_Conv_W8_W64(I8[_s8D87::I64 + (_s8D8C::I64 + 2)]);
           call MO_Touch(_s8D88::P64);
           _s8D93::I64 = %MO_UU_Conv_W8_W64(I8[_s8D87::I64 + (_s8D8C::I64 + 3)]);
           call MO_Touch(_s8D88::P64);
           _s8D95::I64 = (_s8D93::I64 << 24) + ((_s8D8X::I64 << 16) + ((_s8D8R::I64 << 8) + _s8D8L::I64));
           if (%MO_S_Lt_W64(_s8D95::I64, 0)) goto u8DFy; else goto c8DFl;
       u8DFy: // global
           I64[Sp - 16] = _s8D95::I64;
           I64[Sp - 8] = _s8D95::I64;
           Sp = Sp - 24;
           goto u8DFJ;
       c8DFl: // global
           if (%MO_S_Ge_W64(_s8D95::I64, 55296)) goto u8DFA; else goto u8DFz;
       u8DFA: // global
           I64[Sp - 16] = _s8D95::I64;
           I64[Sp - 8] = _s8D95::I64;
           Sp = Sp - 24;
           goto u8DFJ;
       u8DFJ: // global
           call _c8DDY() args: 0, res: 0, upd: 0;
       u8DFz: // global
           I64[Sp - 8] = _s8D95::I64;
           Sp = Sp - 8;
           call _s8D9h() args: 0, res: 0, upd: 0;
       c8DFo: // global
           I64[Sp + 32] = _s8D8D::I64;
           I64[Sp + 40] = _s8D8C::I64;
           Sp = Sp - 8;
           call _c8DC0() args: 0, res: 0, upd: 0;
       c8DFr: // global
           I64[Sp + 32] = _s8D8D::I64;
           I64[Sp + 40] = _s8D8C::I64;
           Sp = Sp - 8;
           call _c8DCm() args: 0, res: 0, upd: 0;
     }
 },
 _c8DDY() //  []
         { info_tbl: [(c8DDY,
                       label: block_c8DDY_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DDY: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DF1; else goto c8DF0;
       c8DF1: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DDY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DF0: // global
           _c8DBX::P64 = P64[Sp + 96];
           _s8D87::I64 = I64[Sp + 120];
           _s8D88::P64 = P64[Sp + 112];
           _s8D89::P64 = P64[Sp + 80];
           _s8D8a::I64 = I64[Sp + 88];
           _s8D8c::I64 = I64[Sp + 104];
           _s8D8e::I64 = I64[Sp + 72];
           _s8D8f::P64 = P64[Sp + 24];
           _s8D8g::P64 = P64[Sp + 32];
           _s8D8h::I64 = I64[Sp + 40];
           _s8D8i::I64 = I64[Sp + 48];
           _s8D8C::I64 = I64[Sp + 56];
           _s8D8D::I64 = I64[Sp + 64];
           _s8D9g::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8D9g::I64, 57343)) goto c8DF4; else goto c8DF9;
       c8DF4: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8D8f::P64;
           P64[Hp - 136] = _s8D8g::P64;
           I64[Hp - 128] = _s8D8e::I64;
           I64[Hp - 120] = _s8D8h::I64;
           I64[Hp - 112] = _s8D8i::I64;
           I64[Hp - 104] = _s8D8D::I64;
           I64[Hp - 96] = sat_s8D9p_info;
           P64[Hp - 80] = _s8D88::P64;
           P64[Hp - 72] = _s8D89::P64;
           P64[Hp - 64] = _c8DBX::P64;
           I64[Hp - 56] = _s8D87::I64;
           I64[Hp - 48] = _s8D8a::I64;
           I64[Hp - 40] = _s8D8c::I64;
           I64[Hp - 32] = _s8D8C::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DF9: // global
           if (%MO_S_Gt_W64(_s8D9g::I64,
                            1114111)) goto c8DF7; else goto c8DF8;
       c8DF7: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8D8f::P64;
           P64[Hp - 136] = _s8D8g::P64;
           I64[Hp - 128] = _s8D8e::I64;
           I64[Hp - 120] = _s8D8h::I64;
           I64[Hp - 112] = _s8D8i::I64;
           I64[Hp - 104] = _s8D8D::I64;
           I64[Hp - 96] = sat_s8D9u_info;
           P64[Hp - 80] = _s8D88::P64;
           P64[Hp - 72] = _s8D89::P64;
           P64[Hp - 64] = _c8DBX::P64;
           I64[Hp - 56] = _s8D87::I64;
           I64[Hp - 48] = _s8D8a::I64;
           I64[Hp - 40] = _s8D8c::I64;
           I64[Hp - 32] = _s8D8C::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DF8: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8D9h() args: 0, res: 0, upd: 0;
     }
 },
 _s8D9h() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8D9h: // global
           _s8D8f::P64 = P64[Sp + 8];
           _s8D8C::I64 = I64[Sp + 40];
           _s8D8D::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8D8D::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8D8f::P64);
           I64[Sp + 40] = _s8D8C::I64 + 4;
           I64[Sp + 48] = _s8D8D::I64 + 1;
           Sp = Sp + 8;
           call _c8DCI() args: 0, res: 0, upd: 0;
     }
 },
 _c8DC0() //  []
         { info_tbl: [(c8DC0,
                       label: block_c8DC0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DC0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DEP; else goto c8DEO;
       c8DEP: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DC0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DEO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8D8q_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8DCm() //  []
         { info_tbl: [(c8DCm,
                       label: block_c8DCm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DCm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DET; else goto c8DES;
       c8DET: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DCm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DES: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8D8y_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.76669296 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32le_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32le_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32le_decode_entry() //  [R2, R3]
         { info_tbl: [(c8DIc,
                       label: GHC.IO.Encoding.UTF32.utf32le_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DIc: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.76988508 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32le3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32le3_bytes:
         I8[] [85,84,70,45,51,50,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.771826419 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32le2_entry() //  [R1]
         { info_tbl: [(c8DIq,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DIq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8DIr; else goto c8DIs;
       c8DIr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DIs: // global
           (_c8DIn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8DIn::I64 == 0) goto c8DIp; else goto c8DIo;
       c8DIp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8DIo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8DIn::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.775911192 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF2_entry() //  []
         { info_tbl: [(c8DIF,
                       label: GHC.IO.Encoding.UTF32.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DIF: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.779580709 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be1_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be1_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be1_info;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be1_entry() //  []
         { info_tbl: [(c8DIS,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DIS: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.783679089 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32le_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32le_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32le_info;
         const 0;
 },
 sat_s8D9I_entry() //  [R1, R2, R3]
         { info_tbl: [(c8DJf,
                       label: sat_s8D9I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DJf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8D9K_entry() //  [R1]
         { info_tbl: [(c8DJj,
                       label: sat_s8D9K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DJj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DJn; else goto c8DJm;
       c8DJn: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8DJm: // global
           _s8D9C::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8D9I_info;
           P64[Hp - 48] = _s8D9C::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8D9E_entry() //  [R1, R2, R3]
         { info_tbl: [(c8DJy,
                       label: sat_s8D9E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DJy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8D9G_entry() //  [R1]
         { info_tbl: [(c8DJC,
                       label: sat_s8D9G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DJC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DJG; else goto c8DJF;
       c8DJG: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8DJF: // global
           _s8D9C::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8D9E_info;
           P64[Hp - 48] = _s8D9C::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32le_entry() //  [R2]
         { info_tbl: [(c8DJI,
                       label: GHC.IO.Encoding.UTF32.mkUTF32le_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DJI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DJM; else goto c8DJL;
       c8DJM: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8DJL: // global
           I64[Hp - 56] = sat_s8D9K_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8D9G_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.796657088 UTC

[section ""data" . lvl_r8AWo_closure" {
     lvl_r8AWo_closure:
         const lvl_r8AWo_info;
         const 0;
 },
 lvl_r8AWo_entry() //  [R2, R3]
         { info_tbl: [(c8DKy,
                       label: lvl_r8AWo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DKy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8DKC; else goto c8DKD;
       c8DKC: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8AWo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DKD: // global
           I64[Sp - 16] = block_c8DKv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DKL; else goto c8DKw;
       u8DKL: // global
           call _c8DKv() args: 0, res: 0, upd: 0;
       c8DKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DKv() //  []
         { info_tbl: [(c8DKv,
                       label: block_c8DKv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DKv: // global
           _s8D9M::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8DKB_info;
           R1 = _s8D9M::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8DKK; else goto c8DKF;
       u8DKK: // global
           call _c8DKB() args: 0, res: 0, upd: 0;
       c8DKF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DKB() //  []
         { info_tbl: [(c8DKB,
                       label: block_c8DKB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DKB: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.803678658 UTC

[section ""data" . lvl1_r8AWp_closure" {
     lvl1_r8AWp_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.805551969 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le2_closure" {
     GHC.IO.Encoding.UTF32.utf32le2_closure:
         const GHC.IO.Encoding.UTF32.utf32le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le2_entry() //  []
         { info_tbl: [(c8DL6,
                       label: GHC.IO.Encoding.UTF32.utf32le2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DL6: // global
           R1 = lvl1_r8AWp_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.809207912 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be2_closure" {
     GHC.IO.Encoding.UTF32.utf32be2_closure:
         const GHC.IO.Encoding.UTF32.utf32be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be2_entry() //  [R2, R3]
         { info_tbl: [(c8DLl,
                       label: GHC.IO.Encoding.UTF32.utf32be2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DLl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8DLp; else goto c8DLq;
       c8DLp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DLq: // global
           I64[Sp - 16] = block_c8DLi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DLz; else goto c8DLj;
       u8DLz: // global
           call _c8DLi(R1) args: 0, res: 0, upd: 0;
       c8DLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DLi() //  [R1]
         { info_tbl: [(c8DLi,
                       label: block_c8DLi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DLi: // global
           I64[Sp - 16] = block_c8DLo_info;
           _s8Da8::P64 = P64[R1 + 7];
           _s8Da7::I64 = I64[R1 + 23];
           _s8Dab::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8Dab::I64;
           P64[Sp] = _s8Da8::P64;
           I64[Sp + 8] = _s8Da7::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DLy; else goto c8DLs;
       u8DLy: // global
           call _c8DLo() args: 0, res: 0, upd: 0;
       c8DLs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DLo() //  []
         { info_tbl: [(c8DLo,
                       label: block_c8DLo_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DLo: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.816763541 UTC

[section ""data" . lvl2_r8AWq_closure" {
     lvl2_r8AWq_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.818672838 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le1_closure" {
     GHC.IO.Encoding.UTF32.utf32le1_closure:
         const GHC.IO.Encoding.UTF32.utf32le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32le1_entry() //  []
         { info_tbl: [(c8DLU,
                       label: GHC.IO.Encoding.UTF32.utf32le1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DLU: // global
           R1 = lvl2_r8AWq_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.821970345 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32le_closure" {
     GHC.IO.Encoding.UTF32.utf32le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.UTF32.utf32le2_closure+1;
         const GHC.IO.Encoding.UTF32.utf32le1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.827488253 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF5_closure" {
     GHC.IO.Encoding.UTF32.mkUTF5_closure:
         const GHC.IO.Encoding.UTF32.mkUTF5_info;
 },
 sat_s8DaM_entry() //  [R1]
         { info_tbl: [(c8DMx,
                       label: sat_s8DaM_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DMx: // global
           _s8DaM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DMy; else goto c8DMz;
       c8DMz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DMB; else goto c8DMA;
       c8DMB: // global
           HpAlloc = 56;
           goto c8DMy;
       c8DMy: // global
           R1 = _s8DaM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DMA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8DaM::P64;
           _s8Day::I64 = I64[_s8DaM::P64 + 56];
           _s8DaI::I64 = I64[_s8DaM::P64 + 64];
           if (_s8DaI::I64 == _s8Day::I64) goto c8DMw; else goto c8DMv;
       c8DMw: // global
           _s8DaG::P64 = P64[_s8DaM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8DaG::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DMv: // global
           _s8Dau::P64 = P64[_s8DaM::P64 + 16];
           _s8Dav::P64 = P64[_s8DaM::P64 + 24];
           _s8Dat::I64 = I64[_s8DaM::P64 + 40];
           _s8Daw::I64 = I64[_s8DaM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dau::P64;
           P64[Hp - 32] = _s8Dav::P64;
           I64[Hp - 24] = _s8Dat::I64;
           I64[Hp - 16] = _s8Daw::I64;
           I64[Hp - 8] = _s8DaI::I64;
           I64[Hp] = _s8Day::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8DaU_entry() //  [R1]
         { info_tbl: [(c8DMT,
                       label: sat_s8DaU_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DMT: // global
           _s8DaU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DMU; else goto c8DMV;
       c8DMV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DMX; else goto c8DMW;
       c8DMX: // global
           HpAlloc = 56;
           goto c8DMU;
       c8DMU: // global
           R1 = _s8DaU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DMW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8DaU::P64;
           _s8Day::I64 = I64[_s8DaU::P64 + 56];
           _s8DaQ::I64 = I64[_s8DaU::P64 + 64];
           if (_s8DaQ::I64 == _s8Day::I64) goto c8DMS; else goto c8DMR;
       c8DMS: // global
           _s8DaG::P64 = P64[_s8DaU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8DaG::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DMR: // global
           _s8Dau::P64 = P64[_s8DaU::P64 + 16];
           _s8Dav::P64 = P64[_s8DaU::P64 + 24];
           _s8Dat::I64 = I64[_s8DaU::P64 + 40];
           _s8Daw::I64 = I64[_s8DaU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dau::P64;
           P64[Hp - 32] = _s8Dav::P64;
           I64[Hp - 24] = _s8Dat::I64;
           I64[Hp - 16] = _s8Daw::I64;
           I64[Hp - 8] = _s8DaQ::I64;
           I64[Hp] = _s8Day::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8DbL_entry() //  [R1]
         { info_tbl: [(c8DOx,
                       label: sat_s8DbL_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DOx: // global
           _s8DbL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DOy; else goto c8DOz;
       c8DOz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DOB; else goto c8DOA;
       c8DOB: // global
           HpAlloc = 56;
           goto c8DOy;
       c8DOy: // global
           R1 = _s8DbL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DOA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8DbL::P64;
           _s8Day::I64 = I64[_s8DbL::P64 + 56];
           _s8DaY::I64 = I64[_s8DbL::P64 + 64];
           if (_s8DaY::I64 == _s8Day::I64) goto c8DOw; else goto c8DOv;
       c8DOw: // global
           _s8DaG::P64 = P64[_s8DbL::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8DaG::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DOv: // global
           _s8Dau::P64 = P64[_s8DbL::P64 + 16];
           _s8Dav::P64 = P64[_s8DbL::P64 + 24];
           _s8Dat::I64 = I64[_s8DbL::P64 + 40];
           _s8Daw::I64 = I64[_s8DbL::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dau::P64;
           P64[Hp - 32] = _s8Dav::P64;
           I64[Hp - 24] = _s8Dat::I64;
           I64[Hp - 16] = _s8Daw::I64;
           I64[Hp - 8] = _s8DaY::I64;
           I64[Hp] = _s8Day::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8DbQ_entry() //  [R1]
         { info_tbl: [(c8DOS,
                       label: sat_s8DbQ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DOS: // global
           _s8DbQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8DOT; else goto c8DOU;
       c8DOU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DOW; else goto c8DOV;
       c8DOW: // global
           HpAlloc = 56;
           goto c8DOT;
       c8DOT: // global
           R1 = _s8DbQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DOV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8DbQ::P64;
           _s8Day::I64 = I64[_s8DbQ::P64 + 56];
           _s8DaY::I64 = I64[_s8DbQ::P64 + 64];
           if (_s8DaY::I64 == _s8Day::I64) goto c8DOR; else goto c8DOQ;
       c8DOR: // global
           _s8DaG::P64 = P64[_s8DbQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8DaG::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8DOQ: // global
           _s8Dau::P64 = P64[_s8DbQ::P64 + 16];
           _s8Dav::P64 = P64[_s8DbQ::P64 + 24];
           _s8Dat::I64 = I64[_s8DbQ::P64 + 40];
           _s8Daw::I64 = I64[_s8DbQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dau::P64;
           P64[Hp - 32] = _s8Dav::P64;
           I64[Hp - 24] = _s8Dat::I64;
           I64[Hp - 16] = _s8Daw::I64;
           I64[Hp - 8] = _s8DaY::I64;
           I64[Hp] = _s8Day::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF5_entry() //  [R2, R3]
         { info_tbl: [(c8DOZ,
                       label: GHC.IO.Encoding.UTF32.mkUTF5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DOZ: // global
           if ((Sp + -128) < SpLim) (likely: False) goto c8DP0; else goto c8DP1;
       c8DP0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DP1: // global
           I64[Sp - 16] = block_c8DM7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8DQ7; else goto c8DM8;
       u8DQ7: // global
           call _c8DM7(R1) args: 0, res: 0, upd: 0;
       c8DM8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DM7() //  [R1]
         { info_tbl: [(c8DM7,
                       label: block_c8DM7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DM7: // global
           I64[Sp - 40] = block_c8DMc_info;
           _s8Dau::P64 = P64[R1 + 7];
           _s8Dav::P64 = P64[R1 + 15];
           _s8Dat::I64 = I64[R1 + 23];
           _s8Daw::I64 = I64[R1 + 31];
           _s8Dax::I64 = I64[R1 + 39];
           _s8Day::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Dav::P64;
           I64[Sp - 24] = _s8Daw::I64;
           I64[Sp - 16] = _s8Dax::I64;
           I64[Sp - 8] = _s8Day::I64;
           P64[Sp] = _s8Dau::P64;
           I64[Sp + 8] = _s8Dat::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8DPZ; else goto c8DMd;
       u8DPZ: // global
           call _c8DMc(R1) args: 0, res: 0, upd: 0;
       c8DMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DMc() //  [R1]
         { info_tbl: [(c8DMc,
                       label: block_c8DMc_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DMc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DP5; else goto c8DP4;
       c8DP5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DP4: // global
           _s8DaB::P64 = P64[R1 + 7];
           _s8DaC::P64 = P64[R1 + 15];
           _s8DaA::I64 = I64[R1 + 23];
           _s8DaD::I64 = I64[R1 + 31];
           _s8DaE::I64 = I64[R1 + 39];
           _s8DaF::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp - 48] = _s8DaB::P64;
           P64[Sp - 40] = _s8DaC::P64;
           I64[Sp - 32] = _s8DaD::I64;
           I64[Sp - 24] = _s8DaE::I64;
           I64[Sp - 16] = I64[Sp + 24];
           I64[Sp - 8] = _s8DaF::I64;
           I64[Sp] = _s8DaA::I64;
           P64[Sp + 24] = Hp - 47;
           Sp = Sp - 48;
           call _c8DN2() args: 0, res: 0, upd: 0;
     }
 },
 _c8DN2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DN2: // global
           _s8DaY::I64 = I64[Sp + 32];
           _s8DaZ::I64 = I64[Sp + 40];
           if (%MO_S_Lt_W64(_s8DaZ::I64,
                            I64[Sp + 16])) goto c8DPK; else goto c8DPL;
       c8DPK: // global
           if (%MO_S_Ge_W64(I64[Sp + 80] - _s8DaY::I64,
                            4)) goto c8DPH; else goto c8DPI;
       c8DPH: // global
           _s8Dat::I64 = I64[Sp + 96];
           _s8Dau::P64 = P64[Sp + 88];
           _s8Db7::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dat::I64 + _s8DaY::I64]);
           call MO_Touch(_s8Dau::P64);
           _s8Dbd::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dat::I64 + (_s8DaY::I64 + 1)]);
           call MO_Touch(_s8Dau::P64);
           _s8Dbj::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dat::I64 + (_s8DaY::I64 + 2)]);
           call MO_Touch(_s8Dau::P64);
           _s8Dbp::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dat::I64 + (_s8DaY::I64 + 3)]);
           call MO_Touch(_s8Dau::P64);
           _s8Dbr::I64 = (_s8Db7::I64 << 24) + ((_s8Dbd::I64 << 16) + ((_s8Dbj::I64 << 8) + _s8Dbp::I64));
           if (%MO_S_Lt_W64(_s8Dbr::I64, 0)) goto u8DPS; else goto c8DPF;
       u8DPS: // global
           I64[Sp - 16] = _s8Dbr::I64;
           I64[Sp - 8] = _s8Dbr::I64;
           Sp = Sp - 24;
           goto u8DQ3;
       c8DPF: // global
           if (%MO_S_Ge_W64(_s8Dbr::I64, 55296)) goto u8DPU; else goto u8DPT;
       u8DPU: // global
           I64[Sp - 16] = _s8Dbr::I64;
           I64[Sp - 8] = _s8Dbr::I64;
           Sp = Sp - 24;
           goto u8DQ3;
       u8DQ3: // global
           call _c8DOi() args: 0, res: 0, upd: 0;
       u8DPT: // global
           I64[Sp - 8] = _s8Dbr::I64;
           Sp = Sp - 8;
           call _s8DbD() args: 0, res: 0, upd: 0;
       c8DPI: // global
           I64[Sp + 32] = _s8DaZ::I64;
           I64[Sp + 40] = _s8DaY::I64;
           Sp = Sp - 8;
           call _c8DMk() args: 0, res: 0, upd: 0;
       c8DPL: // global
           I64[Sp + 32] = _s8DaZ::I64;
           I64[Sp + 40] = _s8DaY::I64;
           Sp = Sp - 8;
           call _c8DMG() args: 0, res: 0, upd: 0;
     }
 },
 _c8DOi() //  []
         { info_tbl: [(c8DOi,
                       label: block_c8DOi_info
                       rep:StackRep [True, True, False, False, True, True, True, True,
                                     True, False, True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DOi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DPl; else goto c8DPk;
       c8DPl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DOi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DPk: // global
           _c8DMh::P64 = P64[Sp + 96];
           _s8Dat::I64 = I64[Sp + 120];
           _s8Dau::P64 = P64[Sp + 112];
           _s8Dav::P64 = P64[Sp + 80];
           _s8Daw::I64 = I64[Sp + 88];
           _s8Day::I64 = I64[Sp + 104];
           _s8DaA::I64 = I64[Sp + 72];
           _s8DaB::P64 = P64[Sp + 24];
           _s8DaC::P64 = P64[Sp + 32];
           _s8DaD::I64 = I64[Sp + 40];
           _s8DaE::I64 = I64[Sp + 48];
           _s8DaY::I64 = I64[Sp + 56];
           _s8DaZ::I64 = I64[Sp + 64];
           _s8DbC::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s8DbC::I64, 57343)) goto c8DPo; else goto c8DPt;
       c8DPo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8DaB::P64;
           P64[Hp - 136] = _s8DaC::P64;
           I64[Hp - 128] = _s8DaA::I64;
           I64[Hp - 120] = _s8DaD::I64;
           I64[Hp - 112] = _s8DaE::I64;
           I64[Hp - 104] = _s8DaZ::I64;
           I64[Hp - 96] = sat_s8DbL_info;
           P64[Hp - 80] = _s8Dau::P64;
           P64[Hp - 72] = _s8Dav::P64;
           P64[Hp - 64] = _c8DMh::P64;
           I64[Hp - 56] = _s8Dat::I64;
           I64[Hp - 48] = _s8Daw::I64;
           I64[Hp - 40] = _s8Day::I64;
           I64[Hp - 32] = _s8DaY::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DPt: // global
           if (%MO_S_Gt_W64(_s8DbC::I64,
                            1114111)) goto c8DPr; else goto c8DPs;
       c8DPr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = _s8DaB::P64;
           P64[Hp - 136] = _s8DaC::P64;
           I64[Hp - 128] = _s8DaA::I64;
           I64[Hp - 120] = _s8DaD::I64;
           I64[Hp - 112] = _s8DaE::I64;
           I64[Hp - 104] = _s8DaZ::I64;
           I64[Hp - 96] = sat_s8DbQ_info;
           P64[Hp - 80] = _s8Dau::P64;
           P64[Hp - 72] = _s8Dav::P64;
           P64[Hp - 64] = _c8DMh::P64;
           I64[Hp - 56] = _s8Dat::I64;
           I64[Hp - 48] = _s8Daw::I64;
           I64[Hp - 40] = _s8Day::I64;
           I64[Hp - 32] = _s8DaY::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DPs: // global
           Hp = Hp - 160;
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _s8DbD() args: 0, res: 0, upd: 0;
     }
 },
 _s8DbD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8DbD: // global
           _s8DaB::P64 = P64[Sp + 8];
           _s8DaY::I64 = I64[Sp + 40];
           _s8DaZ::I64 = I64[Sp + 48];
           I32[I64[Sp + 56] + (_s8DaZ::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[Sp]);
           call MO_Touch(_s8DaB::P64);
           I64[Sp + 40] = _s8DaY::I64 + 4;
           I64[Sp + 48] = _s8DaZ::I64 + 1;
           Sp = Sp + 8;
           call _c8DN2() args: 0, res: 0, upd: 0;
     }
 },
 _c8DMk() //  []
         { info_tbl: [(c8DMk,
                       label: block_c8DMk_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DMk: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DP9; else goto c8DP8;
       c8DP9: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DMk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DP8: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8DaM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8DMG() //  []
         { info_tbl: [(c8DMG,
                       label: block_c8DMG_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DMG: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8DPd; else goto c8DPc;
       c8DPd: // global
           HpAlloc = 160;
           I64[Sp] = block_c8DMG_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DPc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 40];
           I64[Hp - 96] = sat_s8DaU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 48];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.861482783 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32be_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32be_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32be_decode_entry() //  [R2, R3]
         { info_tbl: [(c8DSw,
                       label: GHC.IO.Encoding.UTF32.utf32be_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DSw: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.864796229 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF32be3_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF32be3_bytes:
         I8[] [85,84,70,45,51,50,66,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.867117866 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be2_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be2_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF32be2_entry() //  [R1]
         { info_tbl: [(c8DSK,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DSK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8DSL; else goto c8DSM;
       c8DSL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8DSM: // global
           (_c8DSH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8DSH::I64 == 0) goto c8DSJ; else goto c8DSI;
       c8DSJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8DSI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8DSH::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF32be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.872009618 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32be_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32be_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32be_info;
         const 0;
 },
 sat_s8Dc1_entry() //  [R1, R2, R3]
         { info_tbl: [(c8DT9,
                       label: sat_s8Dc1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DT9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Dc3_entry() //  [R1]
         { info_tbl: [(c8DTd,
                       label: sat_s8Dc3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DTd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DTh; else goto c8DTg;
       c8DTh: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8DTg: // global
           _s8DbV::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Dc1_info;
           P64[Hp - 48] = _s8DbV::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8DbX_entry() //  [R1, R2, R3]
         { info_tbl: [(c8DTs,
                       label: sat_s8DbX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DTs: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8DbZ_entry() //  [R1]
         { info_tbl: [(c8DTw,
                       label: sat_s8DbZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DTw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DTA; else goto c8DTz;
       c8DTA: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8DTz: // global
           _s8DbV::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8DbX_info;
           P64[Hp - 48] = _s8DbV::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32be_entry() //  [R2]
         { info_tbl: [(c8DTC,
                       label: GHC.IO.Encoding.UTF32.mkUTF32be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DTC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8DTG; else goto c8DTF;
       c8DTG: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8DTF: // global
           I64[Hp - 56] = sat_s8Dc3_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8DbZ_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.884427716 UTC

[section ""data" . lvl3_r8AWr_closure" {
     lvl3_r8AWr_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const lvl_r8AWo_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.886427975 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be3_closure" {
     GHC.IO.Encoding.UTF32.utf32be3_closure:
         const GHC.IO.Encoding.UTF32.utf32be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be3_entry() //  []
         { info_tbl: [(c8DUp,
                       label: GHC.IO.Encoding.UTF32.utf32be3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DUp: // global
           R1 = lvl3_r8AWr_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.889730511 UTC

[section ""data" . lvl4_r8AWs_closure" {
     lvl4_r8AWs_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF32.utf32be2_closure+3;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF32.mkUTF32be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.891645617 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be1_closure" {
     GHC.IO.Encoding.UTF32.utf32be1_closure:
         const GHC.IO.Encoding.UTF32.utf32be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32be1_entry() //  []
         { info_tbl: [(c8DUC,
                       label: GHC.IO.Encoding.UTF32.utf32be1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DUC: // global
           R1 = lvl4_r8AWs_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.895176931 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32be_closure" {
     GHC.IO.Encoding.UTF32.utf32be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const GHC.IO.Encoding.UTF32.utf32be3_closure+1;
         const GHC.IO.Encoding.UTF32.utf32be1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.896971904 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF6_closure" {
     GHC.IO.Encoding.UTF32.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.898728409 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF4_closure" {
     GHC.IO.Encoding.UTF32.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF32.mkUTF3_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.90243048 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_decode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_decode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DUO: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8DUZ,
                       label: GHC.IO.Encoding.UTF32.$wutf32_decode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DUZ: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8DV0; else goto c8DV1;
       c8DV0: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8DV1: // global
           I64[Sp - 48] = block_c8DUS_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8DXe; else goto c8DUT;
       u8DXe: // global
           call _c8DUS(R1) args: 0, res: 0, upd: 0;
       c8DUT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DUS() //  [R1]
         { info_tbl: [(c8DUS,
                       label: block_c8DUS_info
                       rep:StackRep [False, True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DUS: // global
           _s8Dc7::I64 = I64[Sp + 16];
           _s8Dc8::P64 = P64[Sp + 24];
           _s8Dc9::P64 = P64[Sp + 32];
           _s8Dca::I64 = I64[Sp + 40];
           _s8Dcb::I64 = I64[Sp + 48];
           _s8Dcc::I64 = I64[Sp + 56];
           _s8Dcd::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8DUW; else goto c8DUX;
       c8DUW: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8DV6; else goto c8DV5;
       c8DV6: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DV5: // global
           if (%MO_S_Ge_W64(_s8Dcc::I64 - _s8Dcb::I64,
                            4)) goto c8DX1; else goto c8DX5;
       c8DX1: // global
           _s8Dc6::P64 = P64[Sp + 8];
           _s8Dco::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dc7::I64 + _s8Dcb::I64]);
           call MO_Touch(_s8Dc8::P64);
           _s8Dcu::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dc7::I64 + (_s8Dcb::I64 + 1)]);
           call MO_Touch(_s8Dc8::P64);
           _s8DcA::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dc7::I64 + (_s8Dcb::I64 + 2)]);
           call MO_Touch(_s8Dc8::P64);
           _s8DcG::I64 = %MO_UU_Conv_W8_W64(I8[_s8Dc7::I64 + (_s8Dcb::I64 + 3)]);
           call MO_Touch(_s8Dc8::P64);
           if (_s8Dco::I64 != 0) goto c8DWM; else goto c8DWZ;
       c8DWZ: // global
           if (_s8Dcu::I64 != 0) goto c8DWM; else goto c8DWY;
       c8DWY: // global
           if (_s8DcA::I64 != 254) goto c8DWM; else goto c8DWX;
       c8DWX: // global
           if (_s8DcG::I64 != 255) goto c8DWM; else goto c8DWW;
       c8DWM: // global
           Hp = Hp - 88;
           I64[Sp - 24] = _s8Dcu::I64;
           I64[Sp - 16] = _s8DcA::I64;
           I64[Sp - 8] = _s8DcG::I64;
           I64[Sp] = _s8Dco::I64;
           Sp = Sp - 32;
           call _c8DVF() args: 0, res: 0, upd: 0;
       c8DWW: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Dc8::P64;
           P64[Hp - 64] = _s8Dc9::P64;
           I64[Hp - 56] = _s8Dc7::I64;
           I64[Hp - 48] = _s8Dca::I64;
           I64[Hp - 40] = _s8Dcb::I64 + 4;
           I64[Hp - 32] = _s8Dcc::I64;
           _c8DWV::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8Dcd::P64;
           R2 = _c8DWV::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DX5: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Dc8::P64;
           P64[Hp - 64] = _s8Dc9::P64;
           I64[Hp - 56] = _s8Dc7::I64;
           I64[Hp - 48] = _s8Dca::I64;
           I64[Hp - 40] = _s8Dcb::I64;
           I64[Hp - 32] = _s8Dcc::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8Dcd::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DUX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DXb; else goto c8DXa;
       c8DXb: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DXa: // global
           _s8Dd7::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           R1 = _s8Dd7::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8DVF() //  []
         { info_tbl: [(c8DVF,
                       label: block_c8DVF_info
                       rep:StackRep [True, True, True, True, False, True, False, False,
                                     True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DVF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DVJ; else goto c8DVI;
       c8DVJ: // global
           HpAlloc = 56;
           I64[Sp] = block_c8DVF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8DVI: // global
           _s8Dc6::P64 = P64[Sp + 40];
           _s8Dc7::I64 = I64[Sp + 48];
           _s8Dc8::P64 = P64[Sp + 56];
           _s8Dc9::P64 = P64[Sp + 64];
           _s8Dca::I64 = I64[Sp + 72];
           _s8Dcb::I64 = I64[Sp + 80];
           _s8Dcc::I64 = I64[Sp + 88];
           _s8Dcd::P64 = P64[Sp + 96];
           if (I64[Sp + 32] == 255) goto c8DWu; else goto c8DVR;
       c8DWu: // global
           if (I64[Sp + 8] == 254) goto c8DWt; else goto c8DW0;
       c8DWt: // global
           if (I64[Sp + 16] == 0) goto c8DWs; else goto c8DW9;
       c8DWs: // global
           if (I64[Sp + 24] == 0) goto c8DWr; else goto c8DWi;
       c8DWr: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64 + 4;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DWi: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DW9: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DW0: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DVR: // global
           call MO_WriteBarrier();
           P64[_s8Dc6::P64 + 8] = GHC.IO.Encoding.UTF32.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Dc6::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Dc8::P64;
           P64[Hp - 32] = _s8Dc9::P64;
           I64[Hp - 24] = _s8Dc7::I64;
           I64[Hp - 16] = _s8Dca::I64;
           I64[Hp - 8] = _s8Dcb::I64;
           I64[Hp] = _s8Dcc::I64;
           R3 = _s8Dcd::P64;
           R2 = Hp - 47;
           Sp = Sp + 104;
           call GHC.IO.Encoding.UTF32.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.920091393 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8DYa,
                       label: GHC.IO.Encoding.UTF32.utf32_decode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DYa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8DYe; else goto c8DYf;
       c8DYe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8DYf: // global
           I64[Sp - 24] = block_c8DY7_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8DYn; else goto c8DY8;
       u8DYn: // global
           call _c8DY7(R1) args: 0, res: 0, upd: 0;
       c8DY8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DY7() //  [R1]
         { info_tbl: [(c8DY7,
                       label: block_c8DY7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DY7: // global
           I64[Sp] = block_c8DYd_info;
           _s8Dde::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8Dde::P64;
           if (R1 & 7 != 0) goto u8DYm; else goto c8DYh;
       u8DYm: // global
           call _c8DYd(R1) args: 0, res: 0, upd: 0;
       c8DYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DYd() //  [R1]
         { info_tbl: [(c8DYd,
                       label: block_c8DYd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DYd: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.928458162 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_decode_closure" {
     GHC.IO.Encoding.UTF32.utf32_decode_closure:
         const GHC.IO.Encoding.UTF32.utf32_decode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_decode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8DYJ,
                       label: GHC.IO.Encoding.UTF32.utf32_decode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DYJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.932778823 UTC

[section ""data" . GHC.IO.Encoding.UTF32.$wutf32_encode_closure" {
     GHC.IO.Encoding.UTF32.$wutf32_encode_closure:
         const GHC.IO.Encoding.UTF32.$wutf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DYR: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.$wutf32_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8DZ2,
                       label: GHC.IO.Encoding.UTF32.$wutf32_encode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DZ2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8DZ3; else goto c8DZ4;
       c8DZ3: // global
           R1 = GHC.IO.Encoding.UTF32.$wutf32_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8DZ4: // global
           I64[Sp - 48] = block_c8DYV_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8DZY; else goto c8DYW;
       u8DZY: // global
           call _c8DYV(R1) args: 0, res: 0, upd: 0;
       c8DYW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8DYV() //  [R1]
         { info_tbl: [(c8DYV,
                       label: block_c8DYV_info
                       rep:StackRep [False, False, True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DYV: // global
           _s8Ddn::P64 = P64[Sp + 16];
           _s8Ddo::I64 = I64[Sp + 24];
           _s8Ddp::P64 = P64[Sp + 32];
           _s8Ddq::P64 = P64[Sp + 40];
           _s8Ddr::I64 = I64[Sp + 48];
           _s8Dds::I64 = I64[Sp + 56];
           _s8Ddt::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8DYZ; else goto c8DZ0;
       c8DYZ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8DZ9; else goto c8DZ8;
       c8DZ9: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DZ8: // global
           if (%MO_S_Ge_W64(_s8Ddr::I64 - _s8Ddt::I64,
                            4)) goto c8DZN; else goto c8DZR;
       c8DZN: // global
           _s8Ddm::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8Ddm::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Ddm::P64);
           I8[_s8Ddo::I64 + _s8Ddt::I64] = 0 :: W8;
           call MO_Touch(_s8Ddp::P64);
           I8[_s8Ddo::I64 + (_s8Ddt::I64 + 1)] = 0 :: W8;
           call MO_Touch(_s8Ddp::P64);
           I8[_s8Ddo::I64 + (_s8Ddt::I64 + 2)] = 254 :: W8;
           call MO_Touch(_s8Ddp::P64);
           I8[_s8Ddo::I64 + (_s8Ddt::I64 + 3)] = 255 :: W8;
           call MO_Touch(_s8Ddp::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Ddp::P64;
           P64[Hp - 64] = _s8Ddq::P64;
           I64[Hp - 56] = _s8Ddo::I64;
           I64[Hp - 48] = _s8Ddr::I64;
           I64[Hp - 40] = _s8Dds::I64;
           I64[Hp - 32] = _s8Ddt::I64 + 4;
           _c8DZL::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8DZL::P64;
           R2 = _s8Ddn::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8DZR: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Ddp::P64;
           P64[Hp - 64] = _s8Ddq::P64;
           I64[Hp - 56] = _s8Ddo::I64;
           I64[Hp - 48] = _s8Ddr::I64;
           I64[Hp - 40] = _s8Dds::I64;
           I64[Hp - 32] = _s8Ddt::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8Ddn::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8DZ0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8DZX; else goto c8DZW;
       c8DZX: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DZW: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Ddp::P64;
           P64[Hp - 32] = _s8Ddq::P64;
           I64[Hp - 24] = _s8Ddo::I64;
           I64[Hp - 16] = _s8Ddr::I64;
           I64[Hp - 8] = _s8Dds::I64;
           I64[Hp] = _s8Ddt::I64;
           R3 = Hp - 47;
           R2 = _s8Ddn::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF32.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.943221948 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode1_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode1_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode1_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8E0B,
                       label: GHC.IO.Encoding.UTF32.utf32_encode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E0B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8E0F; else goto c8E0G;
       c8E0F: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.utf32_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8E0G: // global
           I64[Sp - 24] = block_c8E0y_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8E0O; else goto c8E0z;
       u8E0O: // global
           call _c8E0y(R1) args: 0, res: 0, upd: 0;
       c8E0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8E0y() //  [R1]
         { info_tbl: [(c8E0y,
                       label: block_c8E0y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E0y: // global
           I64[Sp] = block_c8E0E_info;
           _s8De1::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8De1::P64;
           if (R1 & 7 != 0) goto u8E0N; else goto c8E0I;
       u8E0N: // global
           call _c8E0E(R1) args: 0, res: 0, upd: 0;
       c8E0I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8E0E() //  [R1]
         { info_tbl: [(c8E0E,
                       label: block_c8E0E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E0E: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.950644446 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_encode_closure" {
     GHC.IO.Encoding.UTF32.utf32_encode_closure:
         const GHC.IO.Encoding.UTF32.utf32_encode_info;
 },
 GHC.IO.Encoding.UTF32.utf32_encode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8E1b,
                       label: GHC.IO.Encoding.UTF32.utf32_encode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E1b: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF32.utf32_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.953840355 UTC

[section ""cstring" . GHC.IO.Encoding.UTF32.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF32.mkUTF8_bytes:
         I8[] [85,84,70,45,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.955765928 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF7_closure" {
     GHC.IO.Encoding.UTF32.mkUTF7_closure:
         const GHC.IO.Encoding.UTF32.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.mkUTF7_entry() //  [R1]
         { info_tbl: [(c8E1p,
                       label: GHC.IO.Encoding.UTF32.mkUTF7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E1p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8E1q; else goto c8E1r;
       c8E1q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8E1r: // global
           (_c8E1m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8E1m::I64 == 0) goto c8E1o; else goto c8E1n;
       c8E1o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8E1n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8E1m::I64;
           R2 = GHC.IO.Encoding.UTF32.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.96177591 UTC

[section ""data" . GHC.IO.Encoding.UTF32.mkUTF32_closure" {
     GHC.IO.Encoding.UTF32.mkUTF32_closure:
         const GHC.IO.Encoding.UTF32.mkUTF32_info;
         const 0;
 },
 sat_s8DeT_entry() //  [R1, R2]
         { info_tbl: [(c8E1T,
                       label: sat_s8DeT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E1T: // global
           _s8DeB::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8DeB::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8DeB::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8DeP_entry() //  [R1]
         { info_tbl: [(c8E22,
                       label: sat_s8DeP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E22: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8DeN_entry() //  [R1, R2, R3]
         { info_tbl: [(c8E2a,
                       label: sat_s8DeN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E2a: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8DeM_entry() //  [R1, R2, R3]
         { info_tbl: [(c8E2l,
                       label: sat_s8DeM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E2l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8E2m; else goto c8E2n;
       c8E2m: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8E2n: // global
           I64[Sp - 24] = block_c8E2i_info;
           _s8DeB::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8DeB::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8E2r; else goto c8E2j;
       u8E2r: // global
           call _c8E2i(R1) args: 0, res: 0, upd: 0;
       c8E2j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8E2i() //  [R1]
         { info_tbl: [(c8E2i,
                       label: block_c8E2i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E2i: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8DeV_entry() //  [R1]
         { info_tbl: [(c8E2t,
                       label: sat_s8DeV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E2t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8E2u; else goto c8E2v;
       c8E2u: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8E2v: // global
           I64[Sp - 16] = block_c8E1J_info;
           _s8De9::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8De9::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8E1J() //  [R1]
         { info_tbl: [(c8E1J,
                       label: block_c8E1J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E1J: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8E2y; else goto c8E2x;
       c8E2y: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8E2x: // global
           I64[Hp - 104] = sat_s8DeT_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8DeP_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8DeN_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8DeM_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Dev_entry() //  [R1, R2]
         { info_tbl: [(c8E2O,
                       label: sat_s8Dev_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E2O: // global
           _s8Ded::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8Ded::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Ded::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Der_entry() //  [R1]
         { info_tbl: [(c8E2X,
                       label: sat_s8Der_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E2X: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Dep_entry() //  [R1, R2, R3]
         { info_tbl: [(c8E35,
                       label: sat_s8Dep_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E35: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Deo_entry() //  [R1, R2, R3]
         { info_tbl: [(c8E3g,
                       label: sat_s8Deo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E3g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8E3h; else goto c8E3i;
       c8E3h: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8E3i: // global
           I64[Sp - 24] = block_c8E3d_info;
           _s8Ded::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8Ded::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8E3m; else goto c8E3e;
       u8E3m: // global
           call _c8E3d(R1) args: 0, res: 0, upd: 0;
       c8E3e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8E3d() //  [R1]
         { info_tbl: [(c8E3d,
                       label: block_c8E3d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E3d: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF32.$wutf32_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8Dex_entry() //  [R1]
         { info_tbl: [(c8E3o,
                       label: sat_s8Dex_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E3o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8E3p; else goto c8E3q;
       c8E3p: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8E3q: // global
           I64[Sp - 16] = block_c8E2E_info;
           _s8De9::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8De9::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8E2E() //  [R1]
         { info_tbl: [(c8E2E,
                       label: block_c8E2E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E2E: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8E3t; else goto c8E3s;
       c8E3t: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8E3s: // global
           I64[Hp - 104] = sat_s8Dev_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Der_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Dep_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Deo_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF32.mkUTF32_entry() //  [R2]
         { info_tbl: [(c8E3v,
                       label: GHC.IO.Encoding.UTF32.mkUTF32_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E3v: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8E3z; else goto c8E3y;
       c8E3z: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF32.mkUTF32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8E3y: // global
           I64[Hp - 56] = sat_s8DeV_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Dex_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF32.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.992829569 UTC

[section ""data" . GHC.IO.Encoding.UTF32.utf32_closure" {
     GHC.IO.Encoding.UTF32.utf32_closure:
         const GHC.IO.Encoding.UTF32.utf32_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF32.utf32_entry() //  [R1]
         { info_tbl: [(c8E5m,
                       label: GHC.IO.Encoding.UTF32.utf32_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E5m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8E5n; else goto c8E5o;
       c8E5n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8E5o: // global
           (_c8E5j::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8E5j::I64 == 0) goto c8E5l; else goto c8E5k;
       c8E5l: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8E5k: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8E5j::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF32.mkUTF32_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:47.996815846 UTC

[section ""relreadonly" . S8DJN_srt" {
     S8DJN_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8AWo_closure;
         const lvl1_r8AWp_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF32.utf32be2_closure;
         const lvl2_r8AWq_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32be2_closure;
         const lvl3_r8AWr_closure;
         const lvl4_r8AWs_closure;
         const GHC.IO.Encoding.UTF32.mkUTF32_closure;
         const GHC.IO.Encoding.UTF32.mkUTF7_closure;
 }]

