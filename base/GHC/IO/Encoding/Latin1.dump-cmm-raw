
==================== Raw Cmm ====================
2018-03-16 16:03:54.484624325 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:03:54.491091391 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin5_closure" {
     GHC.IO.Encoding.Latin1.latin5_closure:
         const GHC.IO.Encoding.Latin1.latin5_info;
 },
 sat_s8Kv1_entry() //  [R1]
         { []
         }
     {offset
       c8L6h: // global
           _s8Kv1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8L6i; else goto c8L6j;
       c8L6j: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L6l; else goto c8L6k;
       c8L6l: // global
           HpAlloc = 56;
           goto c8L6i;
       c8L6i: // global
           R1 = _s8Kv1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L6k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kv1::P64;
           _s8KuN::I64 = I64[_s8Kv1::P64 + 56];
           _s8KuX::I64 = I64[_s8Kv1::P64 + 64];
           if (_s8KuX::I64 == _s8KuN::I64) goto c8L6g; else goto c8L6f;
       c8L6g: // global
           _s8KuV::P64 = P64[_s8Kv1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KuV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8L6f: // global
           _s8KuJ::P64 = P64[_s8Kv1::P64 + 16];
           _s8KuK::P64 = P64[_s8Kv1::P64 + 24];
           _s8KuI::I64 = I64[_s8Kv1::P64 + 40];
           _s8KuL::I64 = I64[_s8Kv1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = _s8KuK::P64;
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = _s8KuL::I64;
           I64[Hp - 8] = _s8KuX::I64;
           I64[Hp] = _s8KuN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Kv1_info" {
     sat_s8Kv1_info:
         const sat_s8Kv1_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Kv9_entry() //  [R1]
         { []
         }
     {offset
       c8L6D: // global
           _s8Kv9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8L6E; else goto c8L6F;
       c8L6F: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L6H; else goto c8L6G;
       c8L6H: // global
           HpAlloc = 56;
           goto c8L6E;
       c8L6E: // global
           R1 = _s8Kv9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L6G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kv9::P64;
           _s8KuN::I64 = I64[_s8Kv9::P64 + 56];
           _s8Kv5::I64 = I64[_s8Kv9::P64 + 64];
           if (_s8Kv5::I64 == _s8KuN::I64) goto c8L6C; else goto c8L6B;
       c8L6C: // global
           _s8KuV::P64 = P64[_s8Kv9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KuV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8L6B: // global
           _s8KuJ::P64 = P64[_s8Kv9::P64 + 16];
           _s8KuK::P64 = P64[_s8Kv9::P64 + 24];
           _s8KuI::I64 = I64[_s8Kv9::P64 + 40];
           _s8KuL::I64 = I64[_s8Kv9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = _s8KuK::P64;
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = _s8KuL::I64;
           I64[Hp - 8] = _s8Kv5::I64;
           I64[Hp] = _s8KuN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Kv9_info" {
     sat_s8Kv9_info:
         const sat_s8Kv9_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.latin5_entry() //  [R2, R3]
         { []
         }
     {offset
       c8L6K: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8L6L; else goto c8L6M;
       c8L6L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8L6M: // global
           I64[Sp - 16] = block_c8L5R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8L7B; else goto c8L5S;
       u8L7B: // global
           call _c8L5R(R1) args: 0, res: 0, upd: 0;
       c8L5S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin5_info" {
     GHC.IO.Encoding.Latin1.latin5_info:
         const GHC.IO.Encoding.Latin1.latin5_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8L5R() //  [R1]
         { []
         }
     {offset
       c8L5R: // global
           I64[Sp - 40] = block_c8L5W_info;
           _s8KuJ::P64 = P64[R1 + 7];
           _s8KuK::P64 = P64[R1 + 15];
           _s8KuI::I64 = I64[R1 + 23];
           _s8KuL::I64 = I64[R1 + 31];
           _s8KuM::I64 = I64[R1 + 39];
           _s8KuN::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8KuK::P64;
           I64[Sp - 24] = _s8KuL::I64;
           I64[Sp - 16] = _s8KuM::I64;
           I64[Sp - 8] = _s8KuN::I64;
           P64[Sp] = _s8KuJ::P64;
           I64[Sp + 8] = _s8KuI::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8L7y; else goto c8L5X;
       u8L7y: // global
           call _c8L5W(R1) args: 0, res: 0, upd: 0;
       c8L5X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8L5R_info" {
     block_c8L5R_info:
         const _c8L5R;
         const 1;
         const 30;
 },
 _c8L5W() //  [R1]
         { []
         }
     {offset
       c8L5W: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L6Q; else goto c8L6P;
       c8L6Q: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8L6P: // global
           _s8KuQ::P64 = P64[R1 + 7];
           _s8KuR::P64 = P64[R1 + 15];
           _s8KuP::I64 = I64[R1 + 23];
           _s8KuS::I64 = I64[R1 + 31];
           _s8KuT::I64 = I64[R1 + 39];
           _s8KuU::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8KuJ::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8KuI::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KuN::I64 = I64[Sp + 32];
           _c8L61::P64 = Hp - 47;
           _s8Kve::I64 = _s8KuU::I64;
           _s8Kvd::I64 = I64[Sp + 24];
           goto c8L71;
       c8L71: // global
           if (%MO_S_Lt_W64(_s8Kve::I64,
                            _s8KuS::I64)) goto c8L7e; else goto c8L7f;
       c8L7e: // global
           if (%MO_S_Lt_W64(_s8Kvd::I64,
                            _s8KuN::I64)) goto c8L7b; else goto c8L7c;
       c8L7b: // global
           _s8Kvl::I64 = %MO_UU_Conv_W8_W64(I8[_s8KuI::I64 + _s8Kvd::I64]);
           call MO_Touch(_s8KuJ::P64);
           I32[_s8KuP::I64 + (_s8Kve::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Kvl::I64);
           call MO_Touch(_s8KuQ::P64);
           _s8Kve::I64 = _s8Kve::I64 + 1;
           _s8Kvd::I64 = _s8Kvd::I64 + 1;
           goto c8L71;
       c8L7c: // global
           P64[Sp - 48] = _s8KuQ::P64;
           P64[Sp - 40] = _s8KuR::P64;
           I64[Sp - 32] = _s8KuS::I64;
           I64[Sp - 24] = _s8KuT::I64;
           I64[Sp - 16] = _s8Kvd::I64;
           I64[Sp - 8] = _s8Kve::I64;
           I64[Sp] = _s8KuP::I64;
           P64[Sp + 24] = _c8L61::P64;
           Sp = Sp - 56;
           call _c8L64() args: 0, res: 0, upd: 0;
       c8L7f: // global
           P64[Sp - 48] = _s8KuQ::P64;
           P64[Sp - 40] = _s8KuR::P64;
           I64[Sp - 32] = _s8KuS::I64;
           I64[Sp - 24] = _s8KuT::I64;
           I64[Sp - 16] = _s8Kvd::I64;
           I64[Sp - 8] = _s8Kve::I64;
           I64[Sp] = _s8KuP::I64;
           P64[Sp + 24] = _c8L61::P64;
           Sp = Sp - 56;
           call _c8L6q() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8L5W_info" {
     block_c8L5W_info:
         const _c8L5W;
         const 2950;
         const 30;
 },
 _c8L64() //  []
         { []
         }
     {offset
       c8L64: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8L6U; else goto c8L6T;
       c8L6U: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L64_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8L6T: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kv1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8L64_info" {
     block_c8L64_info:
         const _c8L64;
         const 352013;
         const 30;
 },
 _c8L6q() //  []
         { []
         }
     {offset
       c8L6q: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8L6Y; else goto c8L6X;
       c8L6Y: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L6q_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8L6X: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kv9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8L6q_info" {
     block_c8L6q_info:
         const _c8L6q;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.509927386 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_decode_closure" {
     GHC.IO.Encoding.Latin1.latin1_decode_closure:
         const GHC.IO.Encoding.Latin1.latin1_decode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8L8J: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_decode_info" {
     GHC.IO.Encoding.Latin1.latin1_decode_info:
         const GHC.IO.Encoding.Latin1.latin1_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.520007781 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii5_closure" {
     GHC.IO.Encoding.Latin1.ascii5_closure:
         const GHC.IO.Encoding.Latin1.ascii5_info;
 },
 sat_s8KvQ_entry() //  [R1]
         { []
         }
     {offset
       c8L9k: // global
           _s8KvQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8L9l; else goto c8L9m;
       c8L9m: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L9o; else goto c8L9n;
       c8L9o: // global
           HpAlloc = 56;
           goto c8L9l;
       c8L9l: // global
           R1 = _s8KvQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L9n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KvQ::P64;
           _s8KvC::I64 = I64[_s8KvQ::P64 + 56];
           _s8KvM::I64 = I64[_s8KvQ::P64 + 64];
           if (_s8KvM::I64 == _s8KvC::I64) goto c8L9j; else goto c8L9i;
       c8L9j: // global
           _s8KvK::P64 = P64[_s8KvQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8L9i: // global
           _s8Kvy::P64 = P64[_s8KvQ::P64 + 16];
           _s8Kvz::P64 = P64[_s8KvQ::P64 + 24];
           _s8Kvx::I64 = I64[_s8KvQ::P64 + 40];
           _s8KvA::I64 = I64[_s8KvQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8KvM::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KvQ_info" {
     sat_s8KvQ_info:
         const sat_s8KvQ_entry;
         const 17179869187;
         const 15;
 },
 sat_s8KvY_entry() //  [R1]
         { []
         }
     {offset
       c8L9G: // global
           _s8KvY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8L9H; else goto c8L9I;
       c8L9I: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L9K; else goto c8L9J;
       c8L9K: // global
           HpAlloc = 56;
           goto c8L9H;
       c8L9H: // global
           R1 = _s8KvY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L9J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KvY::P64;
           _s8KvC::I64 = I64[_s8KvY::P64 + 56];
           _s8KvU::I64 = I64[_s8KvY::P64 + 64];
           if (_s8KvU::I64 == _s8KvC::I64) goto c8L9F; else goto c8L9E;
       c8L9F: // global
           _s8KvK::P64 = P64[_s8KvY::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8L9E: // global
           _s8Kvy::P64 = P64[_s8KvY::P64 + 16];
           _s8Kvz::P64 = P64[_s8KvY::P64 + 24];
           _s8Kvx::I64 = I64[_s8KvY::P64 + 40];
           _s8KvA::I64 = I64[_s8KvY::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8KvU::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KvY_info" {
     sat_s8KvY_info:
         const sat_s8KvY_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Kw6_entry() //  [R1]
         { []
         }
     {offset
       c8La2: // global
           _s8Kw6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8La3; else goto c8La4;
       c8La4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8La6; else goto c8La5;
       c8La6: // global
           HpAlloc = 56;
           goto c8La3;
       c8La3: // global
           R1 = _s8Kw6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8La5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kw6::P64;
           _s8KvC::I64 = I64[_s8Kw6::P64 + 56];
           _s8Kw2::I64 = I64[_s8Kw6::P64 + 64];
           if (_s8Kw2::I64 == _s8KvC::I64) goto c8La1; else goto c8La0;
       c8La1: // global
           _s8KvK::P64 = P64[_s8Kw6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8La0: // global
           _s8Kvy::P64 = P64[_s8Kw6::P64 + 16];
           _s8Kvz::P64 = P64[_s8Kw6::P64 + 24];
           _s8Kvx::I64 = I64[_s8Kw6::P64 + 40];
           _s8KvA::I64 = I64[_s8Kw6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8Kw2::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Kw6_info" {
     sat_s8Kw6_info:
         const sat_s8Kw6_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.ascii5_entry() //  [R2, R3]
         { []
         }
     {offset
       c8La9: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Laa; else goto c8Lab;
       c8Laa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Lab: // global
           I64[Sp - 16] = block_c8L8U_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lbc; else goto c8L8V;
       u8Lbc: // global
           call _c8L8U(R1) args: 0, res: 0, upd: 0;
       c8L8V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii5_info" {
     GHC.IO.Encoding.Latin1.ascii5_info:
         const GHC.IO.Encoding.Latin1.ascii5_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8L8U() //  [R1]
         { []
         }
     {offset
       c8L8U: // global
           I64[Sp - 40] = block_c8L8Z_info;
           _s8Kvy::P64 = P64[R1 + 7];
           _s8Kvz::P64 = P64[R1 + 15];
           _s8Kvx::I64 = I64[R1 + 23];
           _s8KvA::I64 = I64[R1 + 31];
           _s8KvB::I64 = I64[R1 + 39];
           _s8KvC::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kvz::P64;
           I64[Sp - 24] = _s8KvA::I64;
           I64[Sp - 16] = _s8KvB::I64;
           I64[Sp - 8] = _s8KvC::I64;
           P64[Sp] = _s8Kvy::P64;
           I64[Sp + 8] = _s8Kvx::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Lb8; else goto c8L90;
       u8Lb8: // global
           call _c8L8Z(R1) args: 0, res: 0, upd: 0;
       c8L90: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8L8U_info" {
     block_c8L8U_info:
         const _c8L8U;
         const 1;
         const 30;
 },
 _c8L8Z() //  [R1]
         { []
         }
     {offset
       c8L8Z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Laf; else goto c8Lae;
       c8Laf: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Lae: // global
           _s8KvF::P64 = P64[R1 + 7];
           _s8KvG::P64 = P64[R1 + 15];
           _s8KvE::I64 = I64[R1 + 23];
           _s8KvH::I64 = I64[R1 + 31];
           _s8KvI::I64 = I64[R1 + 39];
           _s8KvJ::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kvy::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kvx::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KvC::I64 = I64[Sp + 32];
           _c8L94::P64 = Hp - 47;
           _s8Kwb::I64 = _s8KvJ::I64;
           _s8Kwa::I64 = I64[Sp + 24];
           goto c8Lau;
       c8Lau: // global
           if (%MO_S_Lt_W64(_s8Kwb::I64,
                            _s8KvH::I64)) goto c8LaR; else goto c8LaS;
       c8LaR: // global
           if (%MO_S_Lt_W64(_s8Kwa::I64,
                            _s8KvC::I64)) goto c8LaO; else goto c8LaP;
       c8LaO: // global
           _s8Kwi::I64 = %MO_UU_Conv_W8_W64(I8[_s8Kvx::I64 + _s8Kwa::I64]);
           call MO_Touch(_s8Kvy::P64);
           if (_s8Kwi::I64 <= 127) goto c8LaL; else goto c8LaM;
       c8LaL: // global
           I32[_s8KvE::I64 + (_s8Kwb::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Kwi::I64);
           call MO_Touch(_s8KvF::P64);
           _s8Kwb::I64 = _s8Kwb::I64 + 1;
           _s8Kwa::I64 = _s8Kwa::I64 + 1;
           goto c8Lau;
       c8LaM: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8L94::P64;
           Sp = Sp - 56;
           call _c8L97() args: 0, res: 0, upd: 0;
       c8LaP: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8L94::P64;
           Sp = Sp - 56;
           call _c8L9t() args: 0, res: 0, upd: 0;
       c8LaS: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8L94::P64;
           Sp = Sp - 56;
           call _c8L9P() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8L8Z_info" {
     block_c8L8Z_info:
         const _c8L8Z;
         const 2950;
         const 30;
 },
 _c8L97() //  []
         { []
         }
     {offset
       c8L97: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Laj; else goto c8Lai;
       c8Laj: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L97_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lai: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KvQ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8L97_info" {
     block_c8L97_info:
         const _c8L97;
         const 352013;
         const 30;
 },
 _c8L9t() //  []
         { []
         }
     {offset
       c8L9t: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lan; else goto c8Lam;
       c8Lan: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L9t_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lam: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KvY_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8L9t_info" {
     block_c8L9t_info:
         const _c8L9t;
         const 352013;
         const 30;
 },
 _c8L9P() //  []
         { []
         }
     {offset
       c8L9P: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lar; else goto c8Laq;
       c8Lar: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L9P_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Laq: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kw6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8L9P_info" {
     block_c8L9P_info:
         const _c8L9P;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.541351445 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_decode_closure" {
     GHC.IO.Encoding.Latin1.ascii_decode_closure:
         const GHC.IO.Encoding.Latin1.ascii_decode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LcJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii_decode_info" {
     GHC.IO.Encoding.Latin1.ascii_decode_info:
         const GHC.IO.Encoding.Latin1.ascii_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.550006345 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin3_closure" {
     GHC.IO.Encoding.Latin1.latin3_closure:
         const GHC.IO.Encoding.Latin1.latin3_info;
 },
 sat_s8KwO_entry() //  [R1]
         { []
         }
     {offset
       c8Ldk: // global
           _s8KwO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ldl; else goto c8Ldm;
       c8Ldm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Ldo; else goto c8Ldn;
       c8Ldo: // global
           HpAlloc = 56;
           goto c8Ldl;
       c8Ldl: // global
           R1 = _s8KwO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ldn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KwO::P64;
           _s8KwA::I64 = I64[_s8KwO::P64 + 56];
           _s8KwK::I64 = I64[_s8KwO::P64 + 64];
           if (_s8KwK::I64 == _s8KwA::I64) goto c8Ldj; else goto c8Ldi;
       c8Ldj: // global
           _s8KwI::P64 = P64[_s8KwO::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KwI::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Ldi: // global
           _s8Kww::P64 = P64[_s8KwO::P64 + 16];
           _s8Kwx::P64 = P64[_s8KwO::P64 + 24];
           _s8Kwv::I64 = I64[_s8KwO::P64 + 40];
           _s8Kwy::I64 = I64[_s8KwO::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = _s8Kwx::P64;
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = _s8Kwy::I64;
           I64[Hp - 8] = _s8KwK::I64;
           I64[Hp] = _s8KwA::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KwO_info" {
     sat_s8KwO_info:
         const sat_s8KwO_entry;
         const 17179869187;
         const 15;
 },
 sat_s8KwW_entry() //  [R1]
         { []
         }
     {offset
       c8LdG: // global
           _s8KwW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LdH; else goto c8LdI;
       c8LdI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LdK; else goto c8LdJ;
       c8LdK: // global
           HpAlloc = 56;
           goto c8LdH;
       c8LdH: // global
           R1 = _s8KwW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LdJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KwW::P64;
           _s8KwA::I64 = I64[_s8KwW::P64 + 56];
           _s8KwS::I64 = I64[_s8KwW::P64 + 64];
           if (_s8KwS::I64 == _s8KwA::I64) goto c8LdF; else goto c8LdE;
       c8LdF: // global
           _s8KwI::P64 = P64[_s8KwW::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KwI::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LdE: // global
           _s8Kww::P64 = P64[_s8KwW::P64 + 16];
           _s8Kwx::P64 = P64[_s8KwW::P64 + 24];
           _s8Kwv::I64 = I64[_s8KwW::P64 + 40];
           _s8Kwy::I64 = I64[_s8KwW::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = _s8Kwx::P64;
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = _s8Kwy::I64;
           I64[Hp - 8] = _s8KwS::I64;
           I64[Hp] = _s8KwA::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KwW_info" {
     sat_s8KwW_info:
         const sat_s8KwW_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.latin3_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LdN: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LdO; else goto c8LdP;
       c8LdO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LdP: // global
           I64[Sp - 16] = block_c8LcU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LeH; else goto c8LcV;
       u8LeH: // global
           call _c8LcU(R1) args: 0, res: 0, upd: 0;
       c8LcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin3_info" {
     GHC.IO.Encoding.Latin1.latin3_info:
         const GHC.IO.Encoding.Latin1.latin3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8LcU() //  [R1]
         { []
         }
     {offset
       c8LcU: // global
           I64[Sp - 40] = block_c8LcZ_info;
           _s8Kww::P64 = P64[R1 + 7];
           _s8Kwx::P64 = P64[R1 + 15];
           _s8Kwv::I64 = I64[R1 + 23];
           _s8Kwy::I64 = I64[R1 + 31];
           _s8Kwz::I64 = I64[R1 + 39];
           _s8KwA::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kwx::P64;
           I64[Sp - 24] = _s8Kwy::I64;
           I64[Sp - 16] = _s8Kwz::I64;
           I64[Sp - 8] = _s8KwA::I64;
           P64[Sp] = _s8Kww::P64;
           I64[Sp + 8] = _s8Kwv::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LeE; else goto c8Ld0;
       u8LeE: // global
           call _c8LcZ(R1) args: 0, res: 0, upd: 0;
       c8Ld0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LcU_info" {
     block_c8LcU_info:
         const _c8LcU;
         const 1;
         const 30;
 },
 _c8LcZ() //  [R1]
         { []
         }
     {offset
       c8LcZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LdT; else goto c8LdS;
       c8LdT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LdS: // global
           _s8KwD::P64 = P64[R1 + 7];
           _s8KwE::P64 = P64[R1 + 15];
           _s8KwC::I64 = I64[R1 + 23];
           _s8KwF::I64 = I64[R1 + 31];
           _s8KwG::I64 = I64[R1 + 39];
           _s8KwH::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kww::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kwv::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KwA::I64 = I64[Sp + 32];
           _c8Ld4::P64 = Hp - 47;
           _s8Kx1::I64 = _s8KwH::I64;
           _s8Kx0::I64 = I64[Sp + 24];
           goto c8Le4;
       c8Le4: // global
           if (%MO_S_Lt_W64(_s8Kx1::I64,
                            _s8KwF::I64)) goto c8Leh; else goto c8Lei;
       c8Leh: // global
           if (%MO_S_Lt_W64(_s8Kx0::I64,
                            _s8KwA::I64)) goto c8Lee; else goto c8Lef;
       c8Lee: // global
           _s8Kx7::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kwv::I64 + (_s8Kx0::I64 << 2)]);
           call MO_Touch(_s8Kww::P64);
           I8[_s8KwC::I64 + _s8Kx1::I64] = %MO_UU_Conv_W64_W8(_s8Kx7::I64);
           call MO_Touch(_s8KwD::P64);
           _s8Kx1::I64 = _s8Kx1::I64 + 1;
           _s8Kx0::I64 = _s8Kx0::I64 + 1;
           goto c8Le4;
       c8Lef: // global
           P64[Sp - 48] = _s8KwD::P64;
           P64[Sp - 40] = _s8KwE::P64;
           I64[Sp - 32] = _s8KwF::I64;
           I64[Sp - 24] = _s8KwG::I64;
           I64[Sp - 16] = _s8Kx0::I64;
           I64[Sp - 8] = _s8Kx1::I64;
           I64[Sp] = _s8KwC::I64;
           P64[Sp + 24] = _c8Ld4::P64;
           Sp = Sp - 56;
           call _c8Ld7() args: 0, res: 0, upd: 0;
       c8Lei: // global
           P64[Sp - 48] = _s8KwD::P64;
           P64[Sp - 40] = _s8KwE::P64;
           I64[Sp - 32] = _s8KwF::I64;
           I64[Sp - 24] = _s8KwG::I64;
           I64[Sp - 16] = _s8Kx0::I64;
           I64[Sp - 8] = _s8Kx1::I64;
           I64[Sp] = _s8KwC::I64;
           P64[Sp + 24] = _c8Ld4::P64;
           Sp = Sp - 56;
           call _c8Ldt() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8LcZ_info" {
     block_c8LcZ_info:
         const _c8LcZ;
         const 2950;
         const 30;
 },
 _c8Ld7() //  []
         { []
         }
     {offset
       c8Ld7: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LdX; else goto c8LdW;
       c8LdX: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ld7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LdW: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KwO_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ld7_info" {
     block_c8Ld7_info:
         const _c8Ld7;
         const 352013;
         const 30;
 },
 _c8Ldt() //  []
         { []
         }
     {offset
       c8Ldt: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Le1; else goto c8Le0;
       c8Le1: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ldt_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Le0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KwW_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ldt_info" {
     block_c8Ldt_info:
         const _c8Ldt;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.567908382 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LfQ: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_encode_info" {
     GHC.IO.Encoding.Latin1.latin1_encode_info:
         const GHC.IO.Encoding.Latin1.latin1_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.578266991 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii3_closure" {
     GHC.IO.Encoding.Latin1.ascii3_closure:
         const GHC.IO.Encoding.Latin1.ascii3_info;
 },
 sat_s8KxE_entry() //  [R1]
         { []
         }
     {offset
       c8Lgr: // global
           _s8KxE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Lgs; else goto c8Lgt;
       c8Lgt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Lgv; else goto c8Lgu;
       c8Lgv: // global
           HpAlloc = 56;
           goto c8Lgs;
       c8Lgs: // global
           R1 = _s8KxE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Lgu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxE::P64;
           _s8Kxq::I64 = I64[_s8KxE::P64 + 56];
           _s8KxA::I64 = I64[_s8KxE::P64 + 64];
           if (_s8KxA::I64 == _s8Kxq::I64) goto c8Lgq; else goto c8Lgp;
       c8Lgq: // global
           _s8Kxy::P64 = P64[_s8KxE::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Lgp: // global
           _s8Kxm::P64 = P64[_s8KxE::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxE::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxE::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxE::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxA::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KxE_info" {
     sat_s8KxE_info:
         const sat_s8KxE_entry;
         const 17179869187;
         const 15;
 },
 sat_s8KxM_entry() //  [R1]
         { []
         }
     {offset
       c8LgN: // global
           _s8KxM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LgO; else goto c8LgP;
       c8LgP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LgR; else goto c8LgQ;
       c8LgR: // global
           HpAlloc = 56;
           goto c8LgO;
       c8LgO: // global
           R1 = _s8KxM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LgQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxM::P64;
           _s8Kxq::I64 = I64[_s8KxM::P64 + 56];
           _s8KxI::I64 = I64[_s8KxM::P64 + 64];
           if (_s8KxI::I64 == _s8Kxq::I64) goto c8LgM; else goto c8LgL;
       c8LgM: // global
           _s8Kxy::P64 = P64[_s8KxM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LgL: // global
           _s8Kxm::P64 = P64[_s8KxM::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxM::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxM::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxI::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KxM_info" {
     sat_s8KxM_info:
         const sat_s8KxM_entry;
         const 17179869187;
         const 15;
 },
 sat_s8KxU_entry() //  [R1]
         { []
         }
     {offset
       c8Lh9: // global
           _s8KxU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Lha; else goto c8Lhb;
       c8Lhb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Lhd; else goto c8Lhc;
       c8Lhd: // global
           HpAlloc = 56;
           goto c8Lha;
       c8Lha: // global
           R1 = _s8KxU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Lhc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxU::P64;
           _s8Kxq::I64 = I64[_s8KxU::P64 + 56];
           _s8KxQ::I64 = I64[_s8KxU::P64 + 64];
           if (_s8KxQ::I64 == _s8Kxq::I64) goto c8Lh8; else goto c8Lh7;
       c8Lh8: // global
           _s8Kxy::P64 = P64[_s8KxU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Lh7: // global
           _s8Kxm::P64 = P64[_s8KxU::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxU::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxU::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxQ::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KxU_info" {
     sat_s8KxU_info:
         const sat_s8KxU_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.ascii3_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Lhg: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Lhh; else goto c8Lhi;
       c8Lhh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Lhi: // global
           I64[Sp - 16] = block_c8Lg1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lip; else goto c8Lg2;
       u8Lip: // global
           call _c8Lg1(R1) args: 0, res: 0, upd: 0;
       c8Lg2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii3_info" {
     GHC.IO.Encoding.Latin1.ascii3_info:
         const GHC.IO.Encoding.Latin1.ascii3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8Lg1() //  [R1]
         { []
         }
     {offset
       c8Lg1: // global
           I64[Sp - 40] = block_c8Lg6_info;
           _s8Kxm::P64 = P64[R1 + 7];
           _s8Kxn::P64 = P64[R1 + 15];
           _s8Kxl::I64 = I64[R1 + 23];
           _s8Kxo::I64 = I64[R1 + 31];
           _s8Kxp::I64 = I64[R1 + 39];
           _s8Kxq::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kxn::P64;
           I64[Sp - 24] = _s8Kxo::I64;
           I64[Sp - 16] = _s8Kxp::I64;
           I64[Sp - 8] = _s8Kxq::I64;
           P64[Sp] = _s8Kxm::P64;
           I64[Sp + 8] = _s8Kxl::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Lil; else goto c8Lg7;
       u8Lil: // global
           call _c8Lg6(R1) args: 0, res: 0, upd: 0;
       c8Lg7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Lg1_info" {
     block_c8Lg1_info:
         const _c8Lg1;
         const 1;
         const 30;
 },
 _c8Lg6() //  [R1]
         { []
         }
     {offset
       c8Lg6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Lhm; else goto c8Lhl;
       c8Lhm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Lhl: // global
           _s8Kxt::P64 = P64[R1 + 7];
           _s8Kxu::P64 = P64[R1 + 15];
           _s8Kxs::I64 = I64[R1 + 23];
           _s8Kxv::I64 = I64[R1 + 31];
           _s8Kxw::I64 = I64[R1 + 39];
           _s8Kxx::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kxm::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kxl::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Kxq::I64 = I64[Sp + 32];
           _c8Lgb::P64 = Hp - 47;
           _s8KxZ::I64 = _s8Kxx::I64;
           _s8KxY::I64 = I64[Sp + 24];
           goto c8LhB;
       c8LhB: // global
           if (%MO_S_Lt_W64(_s8KxZ::I64,
                            _s8Kxv::I64)) goto c8LhY; else goto c8LhZ;
       c8LhY: // global
           if (%MO_S_Lt_W64(_s8KxY::I64,
                            _s8Kxq::I64)) goto c8LhV; else goto c8LhW;
       c8LhV: // global
           _s8Ky5::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kxl::I64 + (_s8KxY::I64 << 2)]);
           call MO_Touch(_s8Kxm::P64);
           if (%MO_S_Le_W64(_s8Ky5::I64, 127)) goto c8LhS; else goto c8LhT;
       c8LhS: // global
           I8[_s8Kxs::I64 + _s8KxZ::I64] = %MO_UU_Conv_W64_W8(_s8Ky5::I64);
           call MO_Touch(_s8Kxt::P64);
           _s8KxZ::I64 = _s8KxZ::I64 + 1;
           _s8KxY::I64 = _s8KxY::I64 + 1;
           goto c8LhB;
       c8LhT: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8Lgb::P64;
           Sp = Sp - 56;
           call _c8Lge() args: 0, res: 0, upd: 0;
       c8LhW: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8Lgb::P64;
           Sp = Sp - 56;
           call _c8LgA() args: 0, res: 0, upd: 0;
       c8LhZ: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8Lgb::P64;
           Sp = Sp - 56;
           call _c8LgW() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Lg6_info" {
     block_c8Lg6_info:
         const _c8Lg6;
         const 2950;
         const 30;
 },
 _c8Lge() //  []
         { []
         }
     {offset
       c8Lge: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lhq; else goto c8Lhp;
       c8Lhq: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Lge_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lhp: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxE_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Lge_info" {
     block_c8Lge_info:
         const _c8Lge;
         const 352013;
         const 30;
 },
 _c8LgA() //  []
         { []
         }
     {offset
       c8LgA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lhu; else goto c8Lht;
       c8Lhu: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LgA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lht: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LgA_info" {
     block_c8LgA_info:
         const _c8LgA;
         const 352013;
         const 30;
 },
 _c8LgW() //  []
         { []
         }
     {offset
       c8LgW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lhy; else goto c8Lhx;
       c8Lhy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LgW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lhx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LgW_info" {
     block_c8LgW_info:
         const _c8LgW;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.599879134 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_encode_closure" {
     GHC.IO.Encoding.Latin1.ascii_encode_closure:
         const GHC.IO.Encoding.Latin1.ascii_encode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LjX: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii_encode_info" {
     GHC.IO.Encoding.Latin1.ascii_encode_info:
         const GHC.IO.Encoding.Latin1.ascii_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.611480665 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked2_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked2_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked2_info;
 },
 sat_s8KyE_entry() //  [R1]
         { []
         }
     {offset
       c8Lky: // global
           _s8KyE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Lkz; else goto c8LkA;
       c8LkA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LkC; else goto c8LkB;
       c8LkC: // global
           HpAlloc = 56;
           goto c8Lkz;
       c8Lkz: // global
           R1 = _s8KyE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LkB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyE::P64;
           _s8Kyq::I64 = I64[_s8KyE::P64 + 56];
           _s8KyA::I64 = I64[_s8KyE::P64 + 64];
           if (_s8KyA::I64 == _s8Kyq::I64) goto c8Lkx; else goto c8Lkw;
       c8Lkx: // global
           _s8Kyy::P64 = P64[_s8KyE::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Lkw: // global
           _s8Kym::P64 = P64[_s8KyE::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyE::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyE::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyE::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyA::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KyE_info" {
     sat_s8KyE_info:
         const sat_s8KyE_entry;
         const 17179869187;
         const 15;
 },
 sat_s8KyM_entry() //  [R1]
         { []
         }
     {offset
       c8LkU: // global
           _s8KyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LkV; else goto c8LkW;
       c8LkW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LkY; else goto c8LkX;
       c8LkY: // global
           HpAlloc = 56;
           goto c8LkV;
       c8LkV: // global
           R1 = _s8KyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LkX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyM::P64;
           _s8Kyq::I64 = I64[_s8KyM::P64 + 56];
           _s8KyI::I64 = I64[_s8KyM::P64 + 64];
           if (_s8KyI::I64 == _s8Kyq::I64) goto c8LkT; else goto c8LkS;
       c8LkT: // global
           _s8Kyy::P64 = P64[_s8KyM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LkS: // global
           _s8Kym::P64 = P64[_s8KyM::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyM::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyM::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyI::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KyM_info" {
     sat_s8KyM_info:
         const sat_s8KyM_entry;
         const 17179869187;
         const 15;
 },
 sat_s8KyU_entry() //  [R1]
         { []
         }
     {offset
       c8Llg: // global
           _s8KyU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Llh; else goto c8Lli;
       c8Lli: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Llk; else goto c8Llj;
       c8Llk: // global
           HpAlloc = 56;
           goto c8Llh;
       c8Llh: // global
           R1 = _s8KyU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Llj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyU::P64;
           _s8Kyq::I64 = I64[_s8KyU::P64 + 56];
           _s8KyQ::I64 = I64[_s8KyU::P64 + 64];
           if (_s8KyQ::I64 == _s8Kyq::I64) goto c8Llf; else goto c8Lle;
       c8Llf: // global
           _s8Kyy::P64 = P64[_s8KyU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Lle: // global
           _s8Kym::P64 = P64[_s8KyU::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyU::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyU::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyQ::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8KyU_info" {
     sat_s8KyU_info:
         const sat_s8KyU_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.latin1_checked2_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Lln: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Llo; else goto c8Llp;
       c8Llo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin1_checked2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Llp: // global
           I64[Sp - 16] = block_c8Lk8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lmw; else goto c8Lk9;
       u8Lmw: // global
           call _c8Lk8(R1) args: 0, res: 0, upd: 0;
       c8Lk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_checked2_info" {
     GHC.IO.Encoding.Latin1.latin1_checked2_info:
         const GHC.IO.Encoding.Latin1.latin1_checked2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8Lk8() //  [R1]
         { []
         }
     {offset
       c8Lk8: // global
           I64[Sp - 40] = block_c8Lkd_info;
           _s8Kym::P64 = P64[R1 + 7];
           _s8Kyn::P64 = P64[R1 + 15];
           _s8Kyl::I64 = I64[R1 + 23];
           _s8Kyo::I64 = I64[R1 + 31];
           _s8Kyp::I64 = I64[R1 + 39];
           _s8Kyq::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kyn::P64;
           I64[Sp - 24] = _s8Kyo::I64;
           I64[Sp - 16] = _s8Kyp::I64;
           I64[Sp - 8] = _s8Kyq::I64;
           P64[Sp] = _s8Kym::P64;
           I64[Sp + 8] = _s8Kyl::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Lms; else goto c8Lke;
       u8Lms: // global
           call _c8Lkd(R1) args: 0, res: 0, upd: 0;
       c8Lke: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Lk8_info" {
     block_c8Lk8_info:
         const _c8Lk8;
         const 1;
         const 30;
 },
 _c8Lkd() //  [R1]
         { []
         }
     {offset
       c8Lkd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Llt; else goto c8Lls;
       c8Llt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Lls: // global
           _s8Kyt::P64 = P64[R1 + 7];
           _s8Kyu::P64 = P64[R1 + 15];
           _s8Kys::I64 = I64[R1 + 23];
           _s8Kyv::I64 = I64[R1 + 31];
           _s8Kyw::I64 = I64[R1 + 39];
           _s8Kyx::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kym::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kyl::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Kyq::I64 = I64[Sp + 32];
           _c8Lki::P64 = Hp - 47;
           _s8KyZ::I64 = _s8Kyx::I64;
           _s8KyY::I64 = I64[Sp + 24];
           goto c8LlI;
       c8LlI: // global
           if (%MO_S_Lt_W64(_s8KyZ::I64,
                            _s8Kyv::I64)) goto c8Lm5; else goto c8Lm6;
       c8Lm5: // global
           if (%MO_S_Lt_W64(_s8KyY::I64,
                            _s8Kyq::I64)) goto c8Lm2; else goto c8Lm3;
       c8Lm2: // global
           _s8Kz5::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kyl::I64 + (_s8KyY::I64 << 2)]);
           call MO_Touch(_s8Kym::P64);
           if (%MO_S_Le_W64(_s8Kz5::I64, 255)) goto c8LlZ; else goto c8Lm0;
       c8LlZ: // global
           I8[_s8Kys::I64 + _s8KyZ::I64] = %MO_UU_Conv_W64_W8(_s8Kz5::I64);
           call MO_Touch(_s8Kyt::P64);
           _s8KyZ::I64 = _s8KyZ::I64 + 1;
           _s8KyY::I64 = _s8KyY::I64 + 1;
           goto c8LlI;
       c8Lm0: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8Lki::P64;
           Sp = Sp - 56;
           call _c8Lkl() args: 0, res: 0, upd: 0;
       c8Lm3: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8Lki::P64;
           Sp = Sp - 56;
           call _c8LkH() args: 0, res: 0, upd: 0;
       c8Lm6: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8Lki::P64;
           Sp = Sp - 56;
           call _c8Ll3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8Lkd_info" {
     block_c8Lkd_info:
         const _c8Lkd;
         const 2950;
         const 30;
 },
 _c8Lkl() //  []
         { []
         }
     {offset
       c8Lkl: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Llx; else goto c8Llw;
       c8Llx: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Lkl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Llw: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyE_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Lkl_info" {
     block_c8Lkl_info:
         const _c8Lkl;
         const 352013;
         const 30;
 },
 _c8LkH() //  []
         { []
         }
     {offset
       c8LkH: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LlB; else goto c8LlA;
       c8LlB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LkH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LlA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LkH_info" {
     block_c8LkH_info:
         const _c8LkH;
         const 352013;
         const 30;
 },
 _c8Ll3() //  []
         { []
         }
     {offset
       c8Ll3: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LlF; else goto c8LlE;
       c8LlF: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ll3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LlE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Ll3_info" {
     block_c8Ll3_info:
         const _c8Ll3;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.63397419 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_checked_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Lo4: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin1_checked2_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_checked_encode_info" {
     GHC.IO.Encoding.Latin1.latin1_checked_encode_info:
         const GHC.IO.Encoding.Latin1.latin1_checked_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.637098889 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule4_bytes" {
     GHC.IO.Encoding.Latin1.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.63891117 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule3_closure" {
     GHC.IO.Encoding.Latin1.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.640635118 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule2_bytes" {
     GHC.IO.Encoding.Latin1.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,76,97,116,105,110,49]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.642498346 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule1_closure" {
     GHC.IO.Encoding.Latin1.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.644260326 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule_closure" {
     GHC.IO.Encoding.Latin1.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Latin1.$trModule3_closure+1;
         const GHC.IO.Encoding.Latin1.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.646680418 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.ascii7_bytes" {
     GHC.IO.Encoding.Latin1.ascii7_bytes:
         I8[] [65,83,67,73,73]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.649155765 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii6_closure" {
     GHC.IO.Encoding.Latin1.ascii6_closure:
         const GHC.IO.Encoding.Latin1.ascii6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii6_entry() //  [R1]
         { []
         }
     {offset
       c8Lon: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Loo; else goto c8Lop;
       c8Loo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Lop: // global
           (_c8Lok::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Lok::I64 == 0) goto c8Lom; else goto c8Lol;
       c8Lom: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Lol: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Lok::I64;
           R2 = GHC.IO.Encoding.Latin1.ascii7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii6_info" {
     GHC.IO.Encoding.Latin1.ascii6_info:
         const GHC.IO.Encoding.Latin1.ascii6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.654523232 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii2_closure" {
     GHC.IO.Encoding.Latin1.mkAscii2_closure:
         const GHC.IO.Encoding.Latin1.mkAscii2_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii2_entry() //  []
         { []
         }
     {offset
       c8LoB: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkAscii2_info" {
     GHC.IO.Encoding.Latin1.mkAscii2_info:
         const GHC.IO.Encoding.Latin1.mkAscii2_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.65893182 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii1_closure" {
     GHC.IO.Encoding.Latin1.mkAscii1_closure:
         const GHC.IO.Encoding.Latin1.mkAscii1_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii1_entry() //  []
         { []
         }
     {offset
       c8LoN: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkAscii1_info" {
     GHC.IO.Encoding.Latin1.mkAscii1_info:
         const GHC.IO.Encoding.Latin1.mkAscii1_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.664866881 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii_closure" {
     GHC.IO.Encoding.Latin1.mkAscii_closure:
         const GHC.IO.Encoding.Latin1.mkAscii_info;
         const 0;
 },
 sat_s8Kzq_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8Lp9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Kzq_info" {
     sat_s8Kzq_info:
         const sat_s8Kzq_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8KNa_srt;
 },
 sat_s8Kzs_entry() //  [R1]
         { []
         }
     {offset
       c8Lpd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lph; else goto c8Lpg;
       c8Lph: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lpg: // global
           _s8Kzk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Kzq_info;
           P64[Hp - 48] = _s8Kzk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Kzs_info" {
     sat_s8Kzs_info:
         const sat_s8Kzs_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8KNa_srt;
 },
 sat_s8Kzm_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8Lps: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Kzm_info" {
     sat_s8Kzm_info:
         const sat_s8Kzm_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8KNa_srt+8;
 },
 sat_s8Kzo_entry() //  [R1]
         { []
         }
     {offset
       c8Lpw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LpA; else goto c8Lpz;
       c8LpA: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lpz: // global
           _s8Kzk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Kzm_info;
           P64[Hp - 48] = _s8Kzk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Kzo_info" {
     sat_s8Kzo_info:
         const sat_s8Kzo_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8KNa_srt+8;
 },
 GHC.IO.Encoding.Latin1.mkAscii_entry() //  [R2]
         { []
         }
     {offset
       c8LpC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LpG; else goto c8LpF;
       c8LpG: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkAscii_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8LpF: // global
           I64[Hp - 56] = sat_s8Kzs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Kzo_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.ascii6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkAscii_info" {
     GHC.IO.Encoding.Latin1.mkAscii_info:
         const GHC.IO.Encoding.Latin1.mkAscii_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S8KNa_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.675688138 UTC

[section ""data" . lvl_r8Kux_closure" {
     lvl_r8Kux_closure:
         const lvl_r8Kux_info;
         const 0;
 },
 lvl_r8Kux_entry() //  [R2, R3]
         { []
         }
     {offset
       c8Lqb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Lqf; else goto c8Lqg;
       c8Lqf: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8Kux_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Lqg: // global
           I64[Sp - 16] = block_c8Lq8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lqo; else goto c8Lq9;
       u8Lqo: // global
           call _c8Lq8() args: 0, res: 0, upd: 0;
       c8Lq9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl_r8Kux_info" {
     lvl_r8Kux_info:
         const lvl_r8Kux_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8KNa_srt+32;
 },
 _c8Lq8() //  []
         { []
         }
     {offset
       c8Lq8: // global
           _s8Kzu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Lqe_info;
           R1 = _s8Kzu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Lqn; else goto c8Lqi;
       u8Lqn: // global
           call _c8Lqe() args: 0, res: 0, upd: 0;
       c8Lqi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Lq8_info" {
     block_c8Lq8_info:
         const _c8Lq8;
         const 1;
         const 4294967326;
         const S8KNa_srt+32;
 },
 _c8Lqe() //  []
         { []
         }
     {offset
       c8Lqe: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8Lqe_info" {
     block_c8Lqe_info:
         const _c8Lqe;
         const 0;
         const 4294967326;
         const S8KNa_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.682360613 UTC

[section ""data" . lvl1_r8Kuy_closure" {
     lvl1_r8Kuy_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.684870943 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii4_closure" {
     GHC.IO.Encoding.Latin1.ascii4_closure:
         const GHC.IO.Encoding.Latin1.ascii4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii4_entry() //  []
         { []
         }
     {offset
       c8LqH: // global
           R1 = lvl1_r8Kuy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii4_info" {
     GHC.IO.Encoding.Latin1.ascii4_info:
         const GHC.IO.Encoding.Latin1.ascii4_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8KNa_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.689485376 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii2_closure" {
     GHC.IO.Encoding.Latin1.ascii2_closure:
         const GHC.IO.Encoding.Latin1.ascii2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii2_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LqW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Lr0; else goto c8Lr1;
       c8Lr0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Lr1: // global
           I64[Sp - 16] = block_c8LqT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lra; else goto c8LqU;
       u8Lra: // global
           call _c8LqT(R1) args: 0, res: 0, upd: 0;
       c8LqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii2_info" {
     GHC.IO.Encoding.Latin1.ascii2_info:
         const GHC.IO.Encoding.Latin1.ascii2_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8KNa_srt+56;
 },
 _c8LqT() //  [R1]
         { []
         }
     {offset
       c8LqT: // global
           I64[Sp - 16] = block_c8LqZ_info;
           _s8KzQ::P64 = P64[R1 + 7];
           _s8KzP::I64 = I64[R1 + 23];
           _s8KzT::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8KzT::I64;
           P64[Sp] = _s8KzQ::P64;
           I64[Sp + 8] = _s8KzP::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lr9; else goto c8Lr3;
       u8Lr9: // global
           call _c8LqZ() args: 0, res: 0, upd: 0;
       c8Lr3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LqT_info" {
     block_c8LqT_info:
         const _c8LqT;
         const 1;
         const 4294967326;
         const S8KNa_srt+56;
 },
 _c8LqZ() //  []
         { []
         }
     {offset
       c8LqZ: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LqZ_info" {
     block_c8LqZ_info:
         const _c8LqZ;
         const 323;
         const 4294967326;
         const S8KNa_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.69585655 UTC

[section ""data" . lvl2_r8Kuz_closure" {
     lvl2_r8Kuz_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.698227125 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii1_closure" {
     GHC.IO.Encoding.Latin1.ascii1_closure:
         const GHC.IO.Encoding.Latin1.ascii1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii1_entry() //  []
         { []
         }
     {offset
       c8Lrt: // global
           R1 = lvl2_r8Kuz_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii1_info" {
     GHC.IO.Encoding.Latin1.ascii1_info:
         const GHC.IO.Encoding.Latin1.ascii1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8KNa_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.70126651 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_closure" {
     GHC.IO.Encoding.Latin1.ascii_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Latin1.ascii4_closure+1;
         const GHC.IO.Encoding.Latin1.ascii1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.703021673 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.latin7_bytes" {
     GHC.IO.Encoding.Latin1.latin7_bytes:
         I8[] [73,83,79,45,56,56,53,57,45,49]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.70534678 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin6_closure" {
     GHC.IO.Encoding.Latin1.latin6_closure:
         const GHC.IO.Encoding.Latin1.latin6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin6_entry() //  [R1]
         { []
         }
     {offset
       c8LrJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8LrK; else goto c8LrL;
       c8LrK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LrL: // global
           (_c8LrG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8LrG::I64 == 0) goto c8LrI; else goto c8LrH;
       c8LrI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8LrH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8LrG::I64;
           R2 = GHC.IO.Encoding.Latin1.latin7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin6_info" {
     GHC.IO.Encoding.Latin1.latin6_info:
         const GHC.IO.Encoding.Latin1.latin6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.711342591 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_checked_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_checked_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_info;
         const 0;
 },
 sat_s8KAd_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8Ls7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8KAd_info" {
     sat_s8KAd_info:
         const sat_s8KAd_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8KNa_srt;
 },
 sat_s8KAf_entry() //  [R1]
         { []
         }
     {offset
       c8Lsb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lsf; else goto c8Lse;
       c8Lsf: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lse: // global
           _s8KA7::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAd_info;
           P64[Hp - 48] = _s8KA7::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8KAf_info" {
     sat_s8KAf_info:
         const sat_s8KAf_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8KNa_srt;
 },
 sat_s8KA9_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8Lsq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8KA9_info" {
     sat_s8KA9_info:
         const sat_s8KA9_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8KNa_srt+8;
 },
 sat_s8KAb_entry() //  [R1]
         { []
         }
     {offset
       c8Lsu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lsy; else goto c8Lsx;
       c8Lsy: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lsx: // global
           _s8KA7::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KA9_info;
           P64[Hp - 48] = _s8KA7::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8KAb_info" {
     sat_s8KAb_info:
         const sat_s8KAb_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8KNa_srt+8;
 },
 GHC.IO.Encoding.Latin1.mkLatin1_checked_entry() //  [R2]
         { []
         }
     {offset
       c8LsA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LsE; else goto c8LsD;
       c8LsE: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8LsD: // global
           I64[Hp - 56] = sat_s8KAf_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8KAb_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkLatin1_checked_info" {
     GHC.IO.Encoding.Latin1.mkLatin1_checked_info:
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_entry;
         const 0;
         const 13207024435214;
         const 4294967301;
         const S8KNa_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.722263502 UTC

[section ""data" . lvl3_r8KuA_closure" {
     lvl3_r8KuA_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.724412681 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin4_closure" {
     GHC.IO.Encoding.Latin1.latin4_closure:
         const GHC.IO.Encoding.Latin1.latin4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin4_entry() //  []
         { []
         }
     {offset
       c8Lt7: // global
           R1 = lvl3_r8KuA_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin4_info" {
     GHC.IO.Encoding.Latin1.latin4_info:
         const GHC.IO.Encoding.Latin1.latin4_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8KNa_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.727630444 UTC

[section ""data" . lvl4_r8KuB_closure" {
     lvl4_r8KuB_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.730033978 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked1_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked1_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin1_checked1_entry() //  []
         { []
         }
     {offset
       c8Ltk: // global
           R1 = lvl4_r8KuB_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_checked1_info" {
     GHC.IO.Encoding.Latin1.latin1_checked1_info:
         const GHC.IO.Encoding.Latin1.latin1_checked1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8KNa_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.733271187 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin1_checked1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.737148024 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_info;
         const 0;
 },
 sat_s8KAo_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8LtH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8KAo_info" {
     sat_s8KAo_info:
         const sat_s8KAo_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8KNa_srt;
 },
 sat_s8KAq_entry() //  [R1]
         { []
         }
     {offset
       c8LtL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LtP; else goto c8LtO;
       c8LtP: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LtO: // global
           _s8KAi::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAo_info;
           P64[Hp - 48] = _s8KAi::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8KAq_info" {
     sat_s8KAq_info:
         const sat_s8KAq_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8KNa_srt;
 },
 sat_s8KAk_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8Lu0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8KAk_info" {
     sat_s8KAk_info:
         const sat_s8KAk_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8KNa_srt+8;
 },
 sat_s8KAm_entry() //  [R1]
         { []
         }
     {offset
       c8Lu4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lu8; else goto c8Lu7;
       c8Lu8: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lu7: // global
           _s8KAi::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAk_info;
           P64[Hp - 48] = _s8KAi::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8KAm_info" {
     sat_s8KAm_info:
         const sat_s8KAm_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8KNa_srt+8;
 },
 GHC.IO.Encoding.Latin1.mkLatin1_entry() //  [R2]
         { []
         }
     {offset
       c8Lua: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lue; else goto c8Lud;
       c8Lue: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Lud: // global
           I64[Hp - 56] = sat_s8KAq_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8KAm_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkLatin1_info" {
     GHC.IO.Encoding.Latin1.mkLatin1_info:
         const GHC.IO.Encoding.Latin1.mkLatin1_entry;
         const 0;
         const 79177722101774;
         const 4294967301;
         const S8KNa_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.747373923 UTC

[section ""data" . lvl5_r8KuC_closure" {
     lvl5_r8KuC_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.749608441 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin2_closure" {
     GHC.IO.Encoding.Latin1.latin2_closure:
         const GHC.IO.Encoding.Latin1.latin2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin2_entry() //  []
         { []
         }
     {offset
       c8LuH: // global
           R1 = lvl5_r8KuC_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin2_info" {
     GHC.IO.Encoding.Latin1.latin2_info:
         const GHC.IO.Encoding.Latin1.latin2_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8KNa_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.753162805 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_closure" {
     GHC.IO.Encoding.Latin1.latin1_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin2_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:54.754921371 UTC

[section ""relreadonly" . S8KNa_srt" {
     S8KNa_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Latin1.mkAscii_closure;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8Kux_closure;
         const lvl1_r8Kuy_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.Latin1.ascii2_closure;
         const lvl2_r8Kuz_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const lvl3_r8KuA_closure;
         const lvl4_r8KuB_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_closure;
         const lvl5_r8KuC_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.737736741 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:03:55.745227386 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin5_closure" {
     GHC.IO.Encoding.Latin1.latin5_closure:
         const GHC.IO.Encoding.Latin1.latin5_info;
 },
 sat_s8Lve_entry() //  [R1]
         { []
         }
     {offset
       c8LB9: // global
           _s8Lve::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LBa; else goto c8LBb;
       c8LBb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LBd; else goto c8LBc;
       c8LBd: // global
           HpAlloc = 56;
           goto c8LBa;
       c8LBa: // global
           R1 = _s8Lve::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LBc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lve::P64;
           _s8Lv0::I64 = I64[_s8Lve::P64 + 56];
           _s8Lva::I64 = I64[_s8Lve::P64 + 64];
           if (_s8Lva::I64 == _s8Lv0::I64) goto c8LB8; else goto c8LB7;
       c8LB8: // global
           _s8Lv8::P64 = P64[_s8Lve::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Lv8::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LB7: // global
           _s8LuW::P64 = P64[_s8Lve::P64 + 16];
           _s8LuX::P64 = P64[_s8Lve::P64 + 24];
           _s8LuV::I64 = I64[_s8Lve::P64 + 40];
           _s8LuY::I64 = I64[_s8Lve::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LuW::P64;
           P64[Hp - 32] = _s8LuX::P64;
           I64[Hp - 24] = _s8LuV::I64;
           I64[Hp - 16] = _s8LuY::I64;
           I64[Hp - 8] = _s8Lva::I64;
           I64[Hp] = _s8Lv0::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Lve_info" {
     sat_s8Lve_info:
         const sat_s8Lve_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Lvm_entry() //  [R1]
         { []
         }
     {offset
       c8LBv: // global
           _s8Lvm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LBw; else goto c8LBx;
       c8LBx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LBz; else goto c8LBy;
       c8LBz: // global
           HpAlloc = 56;
           goto c8LBw;
       c8LBw: // global
           R1 = _s8Lvm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LBy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lvm::P64;
           _s8Lv0::I64 = I64[_s8Lvm::P64 + 56];
           _s8Lvi::I64 = I64[_s8Lvm::P64 + 64];
           if (_s8Lvi::I64 == _s8Lv0::I64) goto c8LBu; else goto c8LBt;
       c8LBu: // global
           _s8Lv8::P64 = P64[_s8Lvm::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Lv8::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LBt: // global
           _s8LuW::P64 = P64[_s8Lvm::P64 + 16];
           _s8LuX::P64 = P64[_s8Lvm::P64 + 24];
           _s8LuV::I64 = I64[_s8Lvm::P64 + 40];
           _s8LuY::I64 = I64[_s8Lvm::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LuW::P64;
           P64[Hp - 32] = _s8LuX::P64;
           I64[Hp - 24] = _s8LuV::I64;
           I64[Hp - 16] = _s8LuY::I64;
           I64[Hp - 8] = _s8Lvi::I64;
           I64[Hp] = _s8Lv0::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Lvm_info" {
     sat_s8Lvm_info:
         const sat_s8Lvm_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.latin5_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LBC: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LBD; else goto c8LBE;
       c8LBD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LBE: // global
           I64[Sp - 16] = block_c8LAJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LCt; else goto c8LAK;
       u8LCt: // global
           call _c8LAJ(R1) args: 0, res: 0, upd: 0;
       c8LAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin5_info" {
     GHC.IO.Encoding.Latin1.latin5_info:
         const GHC.IO.Encoding.Latin1.latin5_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8LAJ() //  [R1]
         { []
         }
     {offset
       c8LAJ: // global
           I64[Sp - 40] = block_c8LAO_info;
           _s8LuW::P64 = P64[R1 + 7];
           _s8LuX::P64 = P64[R1 + 15];
           _s8LuV::I64 = I64[R1 + 23];
           _s8LuY::I64 = I64[R1 + 31];
           _s8LuZ::I64 = I64[R1 + 39];
           _s8Lv0::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LuX::P64;
           I64[Sp - 24] = _s8LuY::I64;
           I64[Sp - 16] = _s8LuZ::I64;
           I64[Sp - 8] = _s8Lv0::I64;
           P64[Sp] = _s8LuW::P64;
           I64[Sp + 8] = _s8LuV::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LCq; else goto c8LAP;
       u8LCq: // global
           call _c8LAO(R1) args: 0, res: 0, upd: 0;
       c8LAP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LAJ_info" {
     block_c8LAJ_info:
         const _c8LAJ;
         const 1;
         const 30;
 },
 _c8LAO() //  [R1]
         { []
         }
     {offset
       c8LAO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LBI; else goto c8LBH;
       c8LBI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LBH: // global
           _s8Lv3::P64 = P64[R1 + 7];
           _s8Lv4::P64 = P64[R1 + 15];
           _s8Lv2::I64 = I64[R1 + 23];
           _s8Lv5::I64 = I64[R1 + 31];
           _s8Lv6::I64 = I64[R1 + 39];
           _s8Lv7::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8LuW::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8LuW::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8LuV::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8LuV::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Lv0::I64 = I64[Sp + 32];
           _c8LAT::P64 = Hp - 47;
           _s8Lvr::I64 = _s8Lv7::I64;
           _s8Lvq::I64 = I64[Sp + 24];
           goto c8LBT;
       c8LBT: // global
           if (%MO_S_Lt_W64(_s8Lvr::I64,
                            _s8Lv5::I64)) goto c8LC6; else goto c8LC7;
       c8LC6: // global
           if (%MO_S_Lt_W64(_s8Lvq::I64,
                            _s8Lv0::I64)) goto c8LC3; else goto c8LC4;
       c8LC3: // global
           _s8Lvy::I64 = %MO_UU_Conv_W8_W64(I8[_s8LuV::I64 + _s8Lvq::I64]);
           call MO_Touch(_s8LuW::P64);
           I32[_s8Lv2::I64 + (_s8Lvr::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Lvy::I64);
           call MO_Touch(_s8Lv3::P64);
           _s8Lvr::I64 = _s8Lvr::I64 + 1;
           _s8Lvq::I64 = _s8Lvq::I64 + 1;
           goto c8LBT;
       c8LC4: // global
           P64[Sp - 48] = _s8Lv3::P64;
           P64[Sp - 40] = _s8Lv4::P64;
           I64[Sp - 32] = _s8Lv5::I64;
           I64[Sp - 24] = _s8Lv6::I64;
           I64[Sp - 16] = _s8Lvq::I64;
           I64[Sp - 8] = _s8Lvr::I64;
           I64[Sp] = _s8Lv2::I64;
           P64[Sp + 24] = _c8LAT::P64;
           Sp = Sp - 56;
           call _c8LAW() args: 0, res: 0, upd: 0;
       c8LC7: // global
           P64[Sp - 48] = _s8Lv3::P64;
           P64[Sp - 40] = _s8Lv4::P64;
           I64[Sp - 32] = _s8Lv5::I64;
           I64[Sp - 24] = _s8Lv6::I64;
           I64[Sp - 16] = _s8Lvq::I64;
           I64[Sp - 8] = _s8Lvr::I64;
           I64[Sp] = _s8Lv2::I64;
           P64[Sp + 24] = _c8LAT::P64;
           Sp = Sp - 56;
           call _c8LBi() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8LAO_info" {
     block_c8LAO_info:
         const _c8LAO;
         const 2950;
         const 30;
 },
 _c8LAW() //  []
         { []
         }
     {offset
       c8LAW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LBM; else goto c8LBL;
       c8LBM: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LAW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LBL: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lve_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LAW_info" {
     block_c8LAW_info:
         const _c8LAW;
         const 352013;
         const 30;
 },
 _c8LBi() //  []
         { []
         }
     {offset
       c8LBi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LBQ; else goto c8LBP;
       c8LBQ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LBi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LBP: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lvm_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LBi_info" {
     block_c8LBi_info:
         const _c8LBi;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.764813917 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_decode_closure" {
     GHC.IO.Encoding.Latin1.latin1_decode_closure:
         const GHC.IO.Encoding.Latin1.latin1_decode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LDU: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_decode_info" {
     GHC.IO.Encoding.Latin1.latin1_decode_info:
         const GHC.IO.Encoding.Latin1.latin1_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.776985836 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii5_closure" {
     GHC.IO.Encoding.Latin1.ascii5_closure:
         const GHC.IO.Encoding.Latin1.ascii5_info;
 },
 sat_s8Lw3_entry() //  [R1]
         { []
         }
     {offset
       c8LEv: // global
           _s8Lw3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LEw; else goto c8LEx;
       c8LEx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LEz; else goto c8LEy;
       c8LEz: // global
           HpAlloc = 56;
           goto c8LEw;
       c8LEw: // global
           R1 = _s8Lw3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LEy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lw3::P64;
           _s8LvP::I64 = I64[_s8Lw3::P64 + 56];
           _s8LvZ::I64 = I64[_s8Lw3::P64 + 64];
           if (_s8LvZ::I64 == _s8LvP::I64) goto c8LEu; else goto c8LEt;
       c8LEu: // global
           _s8LvX::P64 = P64[_s8Lw3::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LvX::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LEt: // global
           _s8LvL::P64 = P64[_s8Lw3::P64 + 16];
           _s8LvM::P64 = P64[_s8Lw3::P64 + 24];
           _s8LvK::I64 = I64[_s8Lw3::P64 + 40];
           _s8LvN::I64 = I64[_s8Lw3::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LvL::P64;
           P64[Hp - 32] = _s8LvM::P64;
           I64[Hp - 24] = _s8LvK::I64;
           I64[Hp - 16] = _s8LvN::I64;
           I64[Hp - 8] = _s8LvZ::I64;
           I64[Hp] = _s8LvP::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Lw3_info" {
     sat_s8Lw3_info:
         const sat_s8Lw3_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Lwb_entry() //  [R1]
         { []
         }
     {offset
       c8LER: // global
           _s8Lwb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LES; else goto c8LET;
       c8LET: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LEV; else goto c8LEU;
       c8LEV: // global
           HpAlloc = 56;
           goto c8LES;
       c8LES: // global
           R1 = _s8Lwb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LEU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lwb::P64;
           _s8LvP::I64 = I64[_s8Lwb::P64 + 56];
           _s8Lw7::I64 = I64[_s8Lwb::P64 + 64];
           if (_s8Lw7::I64 == _s8LvP::I64) goto c8LEQ; else goto c8LEP;
       c8LEQ: // global
           _s8LvX::P64 = P64[_s8Lwb::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LvX::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LEP: // global
           _s8LvL::P64 = P64[_s8Lwb::P64 + 16];
           _s8LvM::P64 = P64[_s8Lwb::P64 + 24];
           _s8LvK::I64 = I64[_s8Lwb::P64 + 40];
           _s8LvN::I64 = I64[_s8Lwb::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LvL::P64;
           P64[Hp - 32] = _s8LvM::P64;
           I64[Hp - 24] = _s8LvK::I64;
           I64[Hp - 16] = _s8LvN::I64;
           I64[Hp - 8] = _s8Lw7::I64;
           I64[Hp] = _s8LvP::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Lwb_info" {
     sat_s8Lwb_info:
         const sat_s8Lwb_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Lwj_entry() //  [R1]
         { []
         }
     {offset
       c8LFd: // global
           _s8Lwj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LFe; else goto c8LFf;
       c8LFf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LFh; else goto c8LFg;
       c8LFh: // global
           HpAlloc = 56;
           goto c8LFe;
       c8LFe: // global
           R1 = _s8Lwj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lwj::P64;
           _s8LvP::I64 = I64[_s8Lwj::P64 + 56];
           _s8Lwf::I64 = I64[_s8Lwj::P64 + 64];
           if (_s8Lwf::I64 == _s8LvP::I64) goto c8LFc; else goto c8LFb;
       c8LFc: // global
           _s8LvX::P64 = P64[_s8Lwj::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LvX::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LFb: // global
           _s8LvL::P64 = P64[_s8Lwj::P64 + 16];
           _s8LvM::P64 = P64[_s8Lwj::P64 + 24];
           _s8LvK::I64 = I64[_s8Lwj::P64 + 40];
           _s8LvN::I64 = I64[_s8Lwj::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LvL::P64;
           P64[Hp - 32] = _s8LvM::P64;
           I64[Hp - 24] = _s8LvK::I64;
           I64[Hp - 16] = _s8LvN::I64;
           I64[Hp - 8] = _s8Lwf::I64;
           I64[Hp] = _s8LvP::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Lwj_info" {
     sat_s8Lwj_info:
         const sat_s8Lwj_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.ascii5_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LFk: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LFl; else goto c8LFm;
       c8LFl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LFm: // global
           I64[Sp - 16] = block_c8LE5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LGn; else goto c8LE6;
       u8LGn: // global
           call _c8LE5(R1) args: 0, res: 0, upd: 0;
       c8LE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii5_info" {
     GHC.IO.Encoding.Latin1.ascii5_info:
         const GHC.IO.Encoding.Latin1.ascii5_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8LE5() //  [R1]
         { []
         }
     {offset
       c8LE5: // global
           I64[Sp - 40] = block_c8LEa_info;
           _s8LvL::P64 = P64[R1 + 7];
           _s8LvM::P64 = P64[R1 + 15];
           _s8LvK::I64 = I64[R1 + 23];
           _s8LvN::I64 = I64[R1 + 31];
           _s8LvO::I64 = I64[R1 + 39];
           _s8LvP::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LvM::P64;
           I64[Sp - 24] = _s8LvN::I64;
           I64[Sp - 16] = _s8LvO::I64;
           I64[Sp - 8] = _s8LvP::I64;
           P64[Sp] = _s8LvL::P64;
           I64[Sp + 8] = _s8LvK::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LGj; else goto c8LEb;
       u8LGj: // global
           call _c8LEa(R1) args: 0, res: 0, upd: 0;
       c8LEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LE5_info" {
     block_c8LE5_info:
         const _c8LE5;
         const 1;
         const 30;
 },
 _c8LEa() //  [R1]
         { []
         }
     {offset
       c8LEa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LFq; else goto c8LFp;
       c8LFq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LFp: // global
           _s8LvS::P64 = P64[R1 + 7];
           _s8LvT::P64 = P64[R1 + 15];
           _s8LvR::I64 = I64[R1 + 23];
           _s8LvU::I64 = I64[R1 + 31];
           _s8LvV::I64 = I64[R1 + 39];
           _s8LvW::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8LvL::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8LvL::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8LvK::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8LvK::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8LvP::I64 = I64[Sp + 32];
           _c8LEf::P64 = Hp - 47;
           _s8Lwo::I64 = _s8LvW::I64;
           _s8Lwn::I64 = I64[Sp + 24];
           goto c8LFF;
       c8LFF: // global
           if (%MO_S_Lt_W64(_s8Lwo::I64,
                            _s8LvU::I64)) goto c8LG2; else goto c8LG3;
       c8LG2: // global
           if (%MO_S_Lt_W64(_s8Lwn::I64,
                            _s8LvP::I64)) goto c8LFZ; else goto c8LG0;
       c8LFZ: // global
           _s8Lwv::I64 = %MO_UU_Conv_W8_W64(I8[_s8LvK::I64 + _s8Lwn::I64]);
           call MO_Touch(_s8LvL::P64);
           if (_s8Lwv::I64 <= 127) goto c8LFW; else goto c8LFX;
       c8LFW: // global
           I32[_s8LvR::I64 + (_s8Lwo::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Lwv::I64);
           call MO_Touch(_s8LvS::P64);
           _s8Lwo::I64 = _s8Lwo::I64 + 1;
           _s8Lwn::I64 = _s8Lwn::I64 + 1;
           goto c8LFF;
       c8LFX: // global
           P64[Sp - 48] = _s8LvS::P64;
           P64[Sp - 40] = _s8LvT::P64;
           I64[Sp - 32] = _s8LvU::I64;
           I64[Sp - 24] = _s8LvV::I64;
           I64[Sp - 16] = _s8Lwn::I64;
           I64[Sp - 8] = _s8Lwo::I64;
           I64[Sp] = _s8LvR::I64;
           P64[Sp + 24] = _c8LEf::P64;
           Sp = Sp - 56;
           call _c8LEi() args: 0, res: 0, upd: 0;
       c8LG0: // global
           P64[Sp - 48] = _s8LvS::P64;
           P64[Sp - 40] = _s8LvT::P64;
           I64[Sp - 32] = _s8LvU::I64;
           I64[Sp - 24] = _s8LvV::I64;
           I64[Sp - 16] = _s8Lwn::I64;
           I64[Sp - 8] = _s8Lwo::I64;
           I64[Sp] = _s8LvR::I64;
           P64[Sp + 24] = _c8LEf::P64;
           Sp = Sp - 56;
           call _c8LEE() args: 0, res: 0, upd: 0;
       c8LG3: // global
           P64[Sp - 48] = _s8LvS::P64;
           P64[Sp - 40] = _s8LvT::P64;
           I64[Sp - 32] = _s8LvU::I64;
           I64[Sp - 24] = _s8LvV::I64;
           I64[Sp - 16] = _s8Lwn::I64;
           I64[Sp - 8] = _s8Lwo::I64;
           I64[Sp] = _s8LvR::I64;
           P64[Sp + 24] = _c8LEf::P64;
           Sp = Sp - 56;
           call _c8LF0() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8LEa_info" {
     block_c8LEa_info:
         const _c8LEa;
         const 2950;
         const 30;
 },
 _c8LEi() //  []
         { []
         }
     {offset
       c8LEi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LFu; else goto c8LFt;
       c8LFu: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LEi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LFt: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lw3_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LEi_info" {
     block_c8LEi_info:
         const _c8LEi;
         const 352013;
         const 30;
 },
 _c8LEE() //  []
         { []
         }
     {offset
       c8LEE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LFy; else goto c8LFx;
       c8LFy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LEE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LFx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lwb_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LEE_info" {
     block_c8LEE_info:
         const _c8LEE;
         const 352013;
         const 30;
 },
 _c8LF0() //  []
         { []
         }
     {offset
       c8LF0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LFC; else goto c8LFB;
       c8LFC: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LF0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LFB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lwj_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LF0_info" {
     block_c8LF0_info:
         const _c8LF0;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.800938296 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_decode_closure" {
     GHC.IO.Encoding.Latin1.ascii_decode_closure:
         const GHC.IO.Encoding.Latin1.ascii_decode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_decode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LIl: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii_decode_info" {
     GHC.IO.Encoding.Latin1.ascii_decode_info:
         const GHC.IO.Encoding.Latin1.ascii_decode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.810649948 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin3_closure" {
     GHC.IO.Encoding.Latin1.latin3_closure:
         const GHC.IO.Encoding.Latin1.latin3_info;
 },
 sat_s8Lx1_entry() //  [R1]
         { []
         }
     {offset
       c8LIW: // global
           _s8Lx1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LIX; else goto c8LIY;
       c8LIY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LJ0; else goto c8LIZ;
       c8LJ0: // global
           HpAlloc = 56;
           goto c8LIX;
       c8LIX: // global
           R1 = _s8Lx1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LIZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lx1::P64;
           _s8LwN::I64 = I64[_s8Lx1::P64 + 56];
           _s8LwX::I64 = I64[_s8Lx1::P64 + 64];
           if (_s8LwX::I64 == _s8LwN::I64) goto c8LIV; else goto c8LIU;
       c8LIV: // global
           _s8LwV::P64 = P64[_s8Lx1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LwV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LIU: // global
           _s8LwJ::P64 = P64[_s8Lx1::P64 + 16];
           _s8LwK::P64 = P64[_s8Lx1::P64 + 24];
           _s8LwI::I64 = I64[_s8Lx1::P64 + 40];
           _s8LwL::I64 = I64[_s8Lx1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LwJ::P64;
           P64[Hp - 32] = _s8LwK::P64;
           I64[Hp - 24] = _s8LwI::I64;
           I64[Hp - 16] = _s8LwL::I64;
           I64[Hp - 8] = _s8LwX::I64;
           I64[Hp] = _s8LwN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Lx1_info" {
     sat_s8Lx1_info:
         const sat_s8Lx1_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Lx9_entry() //  [R1]
         { []
         }
     {offset
       c8LJi: // global
           _s8Lx9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LJj; else goto c8LJk;
       c8LJk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LJm; else goto c8LJl;
       c8LJm: // global
           HpAlloc = 56;
           goto c8LJj;
       c8LJj: // global
           R1 = _s8Lx9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LJl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lx9::P64;
           _s8LwN::I64 = I64[_s8Lx9::P64 + 56];
           _s8Lx5::I64 = I64[_s8Lx9::P64 + 64];
           if (_s8Lx5::I64 == _s8LwN::I64) goto c8LJh; else goto c8LJg;
       c8LJh: // global
           _s8LwV::P64 = P64[_s8Lx9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LwV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LJg: // global
           _s8LwJ::P64 = P64[_s8Lx9::P64 + 16];
           _s8LwK::P64 = P64[_s8Lx9::P64 + 24];
           _s8LwI::I64 = I64[_s8Lx9::P64 + 40];
           _s8LwL::I64 = I64[_s8Lx9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LwJ::P64;
           P64[Hp - 32] = _s8LwK::P64;
           I64[Hp - 24] = _s8LwI::I64;
           I64[Hp - 16] = _s8LwL::I64;
           I64[Hp - 8] = _s8Lx5::I64;
           I64[Hp] = _s8LwN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Lx9_info" {
     sat_s8Lx9_info:
         const sat_s8Lx9_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.latin3_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LJp: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LJq; else goto c8LJr;
       c8LJq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LJr: // global
           I64[Sp - 16] = block_c8LIw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LKj; else goto c8LIx;
       u8LKj: // global
           call _c8LIw(R1) args: 0, res: 0, upd: 0;
       c8LIx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin3_info" {
     GHC.IO.Encoding.Latin1.latin3_info:
         const GHC.IO.Encoding.Latin1.latin3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8LIw() //  [R1]
         { []
         }
     {offset
       c8LIw: // global
           I64[Sp - 40] = block_c8LIB_info;
           _s8LwJ::P64 = P64[R1 + 7];
           _s8LwK::P64 = P64[R1 + 15];
           _s8LwI::I64 = I64[R1 + 23];
           _s8LwL::I64 = I64[R1 + 31];
           _s8LwM::I64 = I64[R1 + 39];
           _s8LwN::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LwK::P64;
           I64[Sp - 24] = _s8LwL::I64;
           I64[Sp - 16] = _s8LwM::I64;
           I64[Sp - 8] = _s8LwN::I64;
           P64[Sp] = _s8LwJ::P64;
           I64[Sp + 8] = _s8LwI::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LKg; else goto c8LIC;
       u8LKg: // global
           call _c8LIB(R1) args: 0, res: 0, upd: 0;
       c8LIC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LIw_info" {
     block_c8LIw_info:
         const _c8LIw;
         const 1;
         const 30;
 },
 _c8LIB() //  [R1]
         { []
         }
     {offset
       c8LIB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LJv; else goto c8LJu;
       c8LJv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LJu: // global
           _s8LwQ::P64 = P64[R1 + 7];
           _s8LwR::P64 = P64[R1 + 15];
           _s8LwP::I64 = I64[R1 + 23];
           _s8LwS::I64 = I64[R1 + 31];
           _s8LwT::I64 = I64[R1 + 39];
           _s8LwU::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8LwJ::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8LwJ::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8LwI::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8LwI::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8LwN::I64 = I64[Sp + 32];
           _c8LIG::P64 = Hp - 47;
           _s8Lxe::I64 = _s8LwU::I64;
           _s8Lxd::I64 = I64[Sp + 24];
           goto c8LJG;
       c8LJG: // global
           if (%MO_S_Lt_W64(_s8Lxe::I64,
                            _s8LwS::I64)) goto c8LJT; else goto c8LJU;
       c8LJT: // global
           if (%MO_S_Lt_W64(_s8Lxd::I64,
                            _s8LwN::I64)) goto c8LJQ; else goto c8LJR;
       c8LJQ: // global
           _s8Lxk::I64 = %MO_UU_Conv_W32_W64(I32[_s8LwI::I64 + (_s8Lxd::I64 << 2)]);
           call MO_Touch(_s8LwJ::P64);
           I8[_s8LwP::I64 + _s8Lxe::I64] = %MO_UU_Conv_W64_W8(_s8Lxk::I64);
           call MO_Touch(_s8LwQ::P64);
           _s8Lxe::I64 = _s8Lxe::I64 + 1;
           _s8Lxd::I64 = _s8Lxd::I64 + 1;
           goto c8LJG;
       c8LJR: // global
           P64[Sp - 48] = _s8LwQ::P64;
           P64[Sp - 40] = _s8LwR::P64;
           I64[Sp - 32] = _s8LwS::I64;
           I64[Sp - 24] = _s8LwT::I64;
           I64[Sp - 16] = _s8Lxd::I64;
           I64[Sp - 8] = _s8Lxe::I64;
           I64[Sp] = _s8LwP::I64;
           P64[Sp + 24] = _c8LIG::P64;
           Sp = Sp - 56;
           call _c8LIJ() args: 0, res: 0, upd: 0;
       c8LJU: // global
           P64[Sp - 48] = _s8LwQ::P64;
           P64[Sp - 40] = _s8LwR::P64;
           I64[Sp - 32] = _s8LwS::I64;
           I64[Sp - 24] = _s8LwT::I64;
           I64[Sp - 16] = _s8Lxd::I64;
           I64[Sp - 8] = _s8Lxe::I64;
           I64[Sp] = _s8LwP::I64;
           P64[Sp + 24] = _c8LIG::P64;
           Sp = Sp - 56;
           call _c8LJ5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8LIB_info" {
     block_c8LIB_info:
         const _c8LIB;
         const 2950;
         const 30;
 },
 _c8LIJ() //  []
         { []
         }
     {offset
       c8LIJ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LJz; else goto c8LJy;
       c8LJz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LIJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LJy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lx1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LIJ_info" {
     block_c8LIJ_info:
         const _c8LIJ;
         const 352013;
         const 30;
 },
 _c8LJ5() //  []
         { []
         }
     {offset
       c8LJ5: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LJD; else goto c8LJC;
       c8LJD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LJ5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LJC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lx9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LJ5_info" {
     block_c8LJ5_info:
         const _c8LJ5;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.830776408 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LLL: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_encode_info" {
     GHC.IO.Encoding.Latin1.latin1_encode_info:
         const GHC.IO.Encoding.Latin1.latin1_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.840949074 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii3_closure" {
     GHC.IO.Encoding.Latin1.ascii3_closure:
         const GHC.IO.Encoding.Latin1.ascii3_info;
 },
 sat_s8LxR_entry() //  [R1]
         { []
         }
     {offset
       c8LMm: // global
           _s8LxR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LMn; else goto c8LMo;
       c8LMo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LMq; else goto c8LMp;
       c8LMq: // global
           HpAlloc = 56;
           goto c8LMn;
       c8LMn: // global
           R1 = _s8LxR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LMp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8LxR::P64;
           _s8LxD::I64 = I64[_s8LxR::P64 + 56];
           _s8LxN::I64 = I64[_s8LxR::P64 + 64];
           if (_s8LxN::I64 == _s8LxD::I64) goto c8LMl; else goto c8LMk;
       c8LMl: // global
           _s8LxL::P64 = P64[_s8LxR::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LxL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LMk: // global
           _s8Lxz::P64 = P64[_s8LxR::P64 + 16];
           _s8LxA::P64 = P64[_s8LxR::P64 + 24];
           _s8Lxy::I64 = I64[_s8LxR::P64 + 40];
           _s8LxB::I64 = I64[_s8LxR::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lxz::P64;
           P64[Hp - 32] = _s8LxA::P64;
           I64[Hp - 24] = _s8Lxy::I64;
           I64[Hp - 16] = _s8LxB::I64;
           I64[Hp - 8] = _s8LxN::I64;
           I64[Hp] = _s8LxD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8LxR_info" {
     sat_s8LxR_info:
         const sat_s8LxR_entry;
         const 17179869187;
         const 15;
 },
 sat_s8LxZ_entry() //  [R1]
         { []
         }
     {offset
       c8LMI: // global
           _s8LxZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LMJ; else goto c8LMK;
       c8LMK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LMM; else goto c8LML;
       c8LMM: // global
           HpAlloc = 56;
           goto c8LMJ;
       c8LMJ: // global
           R1 = _s8LxZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LML: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8LxZ::P64;
           _s8LxD::I64 = I64[_s8LxZ::P64 + 56];
           _s8LxV::I64 = I64[_s8LxZ::P64 + 64];
           if (_s8LxV::I64 == _s8LxD::I64) goto c8LMH; else goto c8LMG;
       c8LMH: // global
           _s8LxL::P64 = P64[_s8LxZ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LxL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LMG: // global
           _s8Lxz::P64 = P64[_s8LxZ::P64 + 16];
           _s8LxA::P64 = P64[_s8LxZ::P64 + 24];
           _s8Lxy::I64 = I64[_s8LxZ::P64 + 40];
           _s8LxB::I64 = I64[_s8LxZ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lxz::P64;
           P64[Hp - 32] = _s8LxA::P64;
           I64[Hp - 24] = _s8Lxy::I64;
           I64[Hp - 16] = _s8LxB::I64;
           I64[Hp - 8] = _s8LxV::I64;
           I64[Hp] = _s8LxD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8LxZ_info" {
     sat_s8LxZ_info:
         const sat_s8LxZ_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Ly7_entry() //  [R1]
         { []
         }
     {offset
       c8LN4: // global
           _s8Ly7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LN5; else goto c8LN6;
       c8LN6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LN8; else goto c8LN7;
       c8LN8: // global
           HpAlloc = 56;
           goto c8LN5;
       c8LN5: // global
           R1 = _s8Ly7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LN7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Ly7::P64;
           _s8LxD::I64 = I64[_s8Ly7::P64 + 56];
           _s8Ly3::I64 = I64[_s8Ly7::P64 + 64];
           if (_s8Ly3::I64 == _s8LxD::I64) goto c8LN3; else goto c8LN2;
       c8LN3: // global
           _s8LxL::P64 = P64[_s8Ly7::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LxL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LN2: // global
           _s8Lxz::P64 = P64[_s8Ly7::P64 + 16];
           _s8LxA::P64 = P64[_s8Ly7::P64 + 24];
           _s8Lxy::I64 = I64[_s8Ly7::P64 + 40];
           _s8LxB::I64 = I64[_s8Ly7::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lxz::P64;
           P64[Hp - 32] = _s8LxA::P64;
           I64[Hp - 24] = _s8Lxy::I64;
           I64[Hp - 16] = _s8LxB::I64;
           I64[Hp - 8] = _s8Ly3::I64;
           I64[Hp] = _s8LxD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Ly7_info" {
     sat_s8Ly7_info:
         const sat_s8Ly7_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.ascii3_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LNb: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LNc; else goto c8LNd;
       c8LNc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LNd: // global
           I64[Sp - 16] = block_c8LLW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LOk; else goto c8LLX;
       u8LOk: // global
           call _c8LLW(R1) args: 0, res: 0, upd: 0;
       c8LLX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii3_info" {
     GHC.IO.Encoding.Latin1.ascii3_info:
         const GHC.IO.Encoding.Latin1.ascii3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8LLW() //  [R1]
         { []
         }
     {offset
       c8LLW: // global
           I64[Sp - 40] = block_c8LM1_info;
           _s8Lxz::P64 = P64[R1 + 7];
           _s8LxA::P64 = P64[R1 + 15];
           _s8Lxy::I64 = I64[R1 + 23];
           _s8LxB::I64 = I64[R1 + 31];
           _s8LxC::I64 = I64[R1 + 39];
           _s8LxD::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LxA::P64;
           I64[Sp - 24] = _s8LxB::I64;
           I64[Sp - 16] = _s8LxC::I64;
           I64[Sp - 8] = _s8LxD::I64;
           P64[Sp] = _s8Lxz::P64;
           I64[Sp + 8] = _s8Lxy::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LOg; else goto c8LM2;
       u8LOg: // global
           call _c8LM1(R1) args: 0, res: 0, upd: 0;
       c8LM2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LLW_info" {
     block_c8LLW_info:
         const _c8LLW;
         const 1;
         const 30;
 },
 _c8LM1() //  [R1]
         { []
         }
     {offset
       c8LM1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LNh; else goto c8LNg;
       c8LNh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LNg: // global
           _s8LxG::P64 = P64[R1 + 7];
           _s8LxH::P64 = P64[R1 + 15];
           _s8LxF::I64 = I64[R1 + 23];
           _s8LxI::I64 = I64[R1 + 31];
           _s8LxJ::I64 = I64[R1 + 39];
           _s8LxK::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Lxz::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Lxz::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Lxy::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Lxy::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8LxD::I64 = I64[Sp + 32];
           _c8LM6::P64 = Hp - 47;
           _s8Lyc::I64 = _s8LxK::I64;
           _s8Lyb::I64 = I64[Sp + 24];
           goto c8LNw;
       c8LNw: // global
           if (%MO_S_Lt_W64(_s8Lyc::I64,
                            _s8LxI::I64)) goto c8LNT; else goto c8LNU;
       c8LNT: // global
           if (%MO_S_Lt_W64(_s8Lyb::I64,
                            _s8LxD::I64)) goto c8LNQ; else goto c8LNR;
       c8LNQ: // global
           _s8Lyi::I64 = %MO_UU_Conv_W32_W64(I32[_s8Lxy::I64 + (_s8Lyb::I64 << 2)]);
           call MO_Touch(_s8Lxz::P64);
           if (%MO_S_Le_W64(_s8Lyi::I64, 127)) goto c8LNN; else goto c8LNO;
       c8LNN: // global
           I8[_s8LxF::I64 + _s8Lyc::I64] = %MO_UU_Conv_W64_W8(_s8Lyi::I64);
           call MO_Touch(_s8LxG::P64);
           _s8Lyc::I64 = _s8Lyc::I64 + 1;
           _s8Lyb::I64 = _s8Lyb::I64 + 1;
           goto c8LNw;
       c8LNO: // global
           P64[Sp - 48] = _s8LxG::P64;
           P64[Sp - 40] = _s8LxH::P64;
           I64[Sp - 32] = _s8LxI::I64;
           I64[Sp - 24] = _s8LxJ::I64;
           I64[Sp - 16] = _s8Lyb::I64;
           I64[Sp - 8] = _s8Lyc::I64;
           I64[Sp] = _s8LxF::I64;
           P64[Sp + 24] = _c8LM6::P64;
           Sp = Sp - 56;
           call _c8LM9() args: 0, res: 0, upd: 0;
       c8LNR: // global
           P64[Sp - 48] = _s8LxG::P64;
           P64[Sp - 40] = _s8LxH::P64;
           I64[Sp - 32] = _s8LxI::I64;
           I64[Sp - 24] = _s8LxJ::I64;
           I64[Sp - 16] = _s8Lyb::I64;
           I64[Sp - 8] = _s8Lyc::I64;
           I64[Sp] = _s8LxF::I64;
           P64[Sp + 24] = _c8LM6::P64;
           Sp = Sp - 56;
           call _c8LMv() args: 0, res: 0, upd: 0;
       c8LNU: // global
           P64[Sp - 48] = _s8LxG::P64;
           P64[Sp - 40] = _s8LxH::P64;
           I64[Sp - 32] = _s8LxI::I64;
           I64[Sp - 24] = _s8LxJ::I64;
           I64[Sp - 16] = _s8Lyb::I64;
           I64[Sp - 8] = _s8Lyc::I64;
           I64[Sp] = _s8LxF::I64;
           P64[Sp + 24] = _c8LM6::P64;
           Sp = Sp - 56;
           call _c8LMR() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8LM1_info" {
     block_c8LM1_info:
         const _c8LM1;
         const 2950;
         const 30;
 },
 _c8LM9() //  []
         { []
         }
     {offset
       c8LM9: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LNl; else goto c8LNk;
       c8LNl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LM9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LNk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8LxR_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LM9_info" {
     block_c8LM9_info:
         const _c8LM9;
         const 352013;
         const 30;
 },
 _c8LMv() //  []
         { []
         }
     {offset
       c8LMv: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LNp; else goto c8LNo;
       c8LNp: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LMv_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LNo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8LxZ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LMv_info" {
     block_c8LMv_info:
         const _c8LMv;
         const 352013;
         const 30;
 },
 _c8LMR() //  []
         { []
         }
     {offset
       c8LMR: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LNt; else goto c8LNs;
       c8LNt: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LMR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LNs: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Ly7_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LMR_info" {
     block_c8LMR_info:
         const _c8LMR;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.863517258 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_encode_closure" {
     GHC.IO.Encoding.Latin1.ascii_encode_closure:
         const GHC.IO.Encoding.Latin1.ascii_encode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LQj: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii_encode_info" {
     GHC.IO.Encoding.Latin1.ascii_encode_info:
         const GHC.IO.Encoding.Latin1.ascii_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.875056605 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked2_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked2_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked2_info;
 },
 sat_s8LyR_entry() //  [R1]
         { []
         }
     {offset
       c8LQU: // global
           _s8LyR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LQV; else goto c8LQW;
       c8LQW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LQY; else goto c8LQX;
       c8LQY: // global
           HpAlloc = 56;
           goto c8LQV;
       c8LQV: // global
           R1 = _s8LyR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LQX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8LyR::P64;
           _s8LyD::I64 = I64[_s8LyR::P64 + 56];
           _s8LyN::I64 = I64[_s8LyR::P64 + 64];
           if (_s8LyN::I64 == _s8LyD::I64) goto c8LQT; else goto c8LQS;
       c8LQT: // global
           _s8LyL::P64 = P64[_s8LyR::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LyL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LQS: // global
           _s8Lyz::P64 = P64[_s8LyR::P64 + 16];
           _s8LyA::P64 = P64[_s8LyR::P64 + 24];
           _s8Lyy::I64 = I64[_s8LyR::P64 + 40];
           _s8LyB::I64 = I64[_s8LyR::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lyz::P64;
           P64[Hp - 32] = _s8LyA::P64;
           I64[Hp - 24] = _s8Lyy::I64;
           I64[Hp - 16] = _s8LyB::I64;
           I64[Hp - 8] = _s8LyN::I64;
           I64[Hp] = _s8LyD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8LyR_info" {
     sat_s8LyR_info:
         const sat_s8LyR_entry;
         const 17179869187;
         const 15;
 },
 sat_s8LyZ_entry() //  [R1]
         { []
         }
     {offset
       c8LRg: // global
           _s8LyZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LRh; else goto c8LRi;
       c8LRi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LRk; else goto c8LRj;
       c8LRk: // global
           HpAlloc = 56;
           goto c8LRh;
       c8LRh: // global
           R1 = _s8LyZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LRj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8LyZ::P64;
           _s8LyD::I64 = I64[_s8LyZ::P64 + 56];
           _s8LyV::I64 = I64[_s8LyZ::P64 + 64];
           if (_s8LyV::I64 == _s8LyD::I64) goto c8LRf; else goto c8LRe;
       c8LRf: // global
           _s8LyL::P64 = P64[_s8LyZ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LyL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LRe: // global
           _s8Lyz::P64 = P64[_s8LyZ::P64 + 16];
           _s8LyA::P64 = P64[_s8LyZ::P64 + 24];
           _s8Lyy::I64 = I64[_s8LyZ::P64 + 40];
           _s8LyB::I64 = I64[_s8LyZ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lyz::P64;
           P64[Hp - 32] = _s8LyA::P64;
           I64[Hp - 24] = _s8Lyy::I64;
           I64[Hp - 16] = _s8LyB::I64;
           I64[Hp - 8] = _s8LyV::I64;
           I64[Hp] = _s8LyD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8LyZ_info" {
     sat_s8LyZ_info:
         const sat_s8LyZ_entry;
         const 17179869187;
         const 15;
 },
 sat_s8Lz7_entry() //  [R1]
         { []
         }
     {offset
       c8LRC: // global
           _s8Lz7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LRD; else goto c8LRE;
       c8LRE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LRG; else goto c8LRF;
       c8LRG: // global
           HpAlloc = 56;
           goto c8LRD;
       c8LRD: // global
           R1 = _s8Lz7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LRF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lz7::P64;
           _s8LyD::I64 = I64[_s8Lz7::P64 + 56];
           _s8Lz3::I64 = I64[_s8Lz7::P64 + 64];
           if (_s8Lz3::I64 == _s8LyD::I64) goto c8LRB; else goto c8LRA;
       c8LRB: // global
           _s8LyL::P64 = P64[_s8Lz7::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LyL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LRA: // global
           _s8Lyz::P64 = P64[_s8Lz7::P64 + 16];
           _s8LyA::P64 = P64[_s8Lz7::P64 + 24];
           _s8Lyy::I64 = I64[_s8Lz7::P64 + 40];
           _s8LyB::I64 = I64[_s8Lz7::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lyz::P64;
           P64[Hp - 32] = _s8LyA::P64;
           I64[Hp - 24] = _s8Lyy::I64;
           I64[Hp - 16] = _s8LyB::I64;
           I64[Hp - 8] = _s8Lz3::I64;
           I64[Hp] = _s8LyD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8Lz7_info" {
     sat_s8Lz7_info:
         const sat_s8Lz7_entry;
         const 17179869187;
         const 15;
 },
 GHC.IO.Encoding.Latin1.latin1_checked2_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LRJ: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LRK; else goto c8LRL;
       c8LRK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin1_checked2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LRL: // global
           I64[Sp - 16] = block_c8LQu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LSS; else goto c8LQv;
       u8LSS: // global
           call _c8LQu(R1) args: 0, res: 0, upd: 0;
       c8LQv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_checked2_info" {
     GHC.IO.Encoding.Latin1.latin1_checked2_info:
         const GHC.IO.Encoding.Latin1.latin1_checked2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _c8LQu() //  [R1]
         { []
         }
     {offset
       c8LQu: // global
           I64[Sp - 40] = block_c8LQz_info;
           _s8Lyz::P64 = P64[R1 + 7];
           _s8LyA::P64 = P64[R1 + 15];
           _s8Lyy::I64 = I64[R1 + 23];
           _s8LyB::I64 = I64[R1 + 31];
           _s8LyC::I64 = I64[R1 + 39];
           _s8LyD::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LyA::P64;
           I64[Sp - 24] = _s8LyB::I64;
           I64[Sp - 16] = _s8LyC::I64;
           I64[Sp - 8] = _s8LyD::I64;
           P64[Sp] = _s8Lyz::P64;
           I64[Sp + 8] = _s8Lyy::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LSO; else goto c8LQA;
       u8LSO: // global
           call _c8LQz(R1) args: 0, res: 0, upd: 0;
       c8LQA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LQu_info" {
     block_c8LQu_info:
         const _c8LQu;
         const 1;
         const 30;
 },
 _c8LQz() //  [R1]
         { []
         }
     {offset
       c8LQz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LRP; else goto c8LRO;
       c8LRP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LRO: // global
           _s8LyG::P64 = P64[R1 + 7];
           _s8LyH::P64 = P64[R1 + 15];
           _s8LyF::I64 = I64[R1 + 23];
           _s8LyI::I64 = I64[R1 + 31];
           _s8LyJ::I64 = I64[R1 + 39];
           _s8LyK::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Lyz::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Lyz::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Lyy::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Lyy::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8LyD::I64 = I64[Sp + 32];
           _c8LQE::P64 = Hp - 47;
           _s8Lzc::I64 = _s8LyK::I64;
           _s8Lzb::I64 = I64[Sp + 24];
           goto c8LS4;
       c8LS4: // global
           if (%MO_S_Lt_W64(_s8Lzc::I64,
                            _s8LyI::I64)) goto c8LSr; else goto c8LSs;
       c8LSr: // global
           if (%MO_S_Lt_W64(_s8Lzb::I64,
                            _s8LyD::I64)) goto c8LSo; else goto c8LSp;
       c8LSo: // global
           _s8Lzi::I64 = %MO_UU_Conv_W32_W64(I32[_s8Lyy::I64 + (_s8Lzb::I64 << 2)]);
           call MO_Touch(_s8Lyz::P64);
           if (%MO_S_Le_W64(_s8Lzi::I64, 255)) goto c8LSl; else goto c8LSm;
       c8LSl: // global
           I8[_s8LyF::I64 + _s8Lzc::I64] = %MO_UU_Conv_W64_W8(_s8Lzi::I64);
           call MO_Touch(_s8LyG::P64);
           _s8Lzc::I64 = _s8Lzc::I64 + 1;
           _s8Lzb::I64 = _s8Lzb::I64 + 1;
           goto c8LS4;
       c8LSm: // global
           P64[Sp - 48] = _s8LyG::P64;
           P64[Sp - 40] = _s8LyH::P64;
           I64[Sp - 32] = _s8LyI::I64;
           I64[Sp - 24] = _s8LyJ::I64;
           I64[Sp - 16] = _s8Lzb::I64;
           I64[Sp - 8] = _s8Lzc::I64;
           I64[Sp] = _s8LyF::I64;
           P64[Sp + 24] = _c8LQE::P64;
           Sp = Sp - 56;
           call _c8LQH() args: 0, res: 0, upd: 0;
       c8LSp: // global
           P64[Sp - 48] = _s8LyG::P64;
           P64[Sp - 40] = _s8LyH::P64;
           I64[Sp - 32] = _s8LyI::I64;
           I64[Sp - 24] = _s8LyJ::I64;
           I64[Sp - 16] = _s8Lzb::I64;
           I64[Sp - 8] = _s8Lzc::I64;
           I64[Sp] = _s8LyF::I64;
           P64[Sp + 24] = _c8LQE::P64;
           Sp = Sp - 56;
           call _c8LR3() args: 0, res: 0, upd: 0;
       c8LSs: // global
           P64[Sp - 48] = _s8LyG::P64;
           P64[Sp - 40] = _s8LyH::P64;
           I64[Sp - 32] = _s8LyI::I64;
           I64[Sp - 24] = _s8LyJ::I64;
           I64[Sp - 16] = _s8Lzb::I64;
           I64[Sp - 8] = _s8Lzc::I64;
           I64[Sp] = _s8LyF::I64;
           P64[Sp + 24] = _c8LQE::P64;
           Sp = Sp - 56;
           call _c8LRp() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c8LQz_info" {
     block_c8LQz_info:
         const _c8LQz;
         const 2950;
         const 30;
 },
 _c8LQH() //  []
         { []
         }
     {offset
       c8LQH: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LRT; else goto c8LRS;
       c8LRT: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LQH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LRS: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8LyR_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LQH_info" {
     block_c8LQH_info:
         const _c8LQH;
         const 352013;
         const 30;
 },
 _c8LR3() //  []
         { []
         }
     {offset
       c8LR3: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LRX; else goto c8LRW;
       c8LRX: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LR3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LRW: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8LyZ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LR3_info" {
     block_c8LR3_info:
         const _c8LR3;
         const 352013;
         const 30;
 },
 _c8LRp() //  []
         { []
         }
     {offset
       c8LRp: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LS1; else goto c8LS0;
       c8LS1: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LRp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LS0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lz7_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LRp_info" {
     block_c8LRp_info:
         const _c8LRp;
         const 352013;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.899098907 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_checked_encode_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LUR: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin1_checked2_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_checked_encode_info" {
     GHC.IO.Encoding.Latin1.latin1_checked_encode_info:
         const GHC.IO.Encoding.Latin1.latin1_checked_encode_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.902496812 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule4_bytes" {
     GHC.IO.Encoding.Latin1.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.904442068 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule3_closure" {
     GHC.IO.Encoding.Latin1.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.906566946 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule2_bytes" {
     GHC.IO.Encoding.Latin1.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,76,97,116,105,110,49]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.908473329 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule1_closure" {
     GHC.IO.Encoding.Latin1.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.910406233 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule_closure" {
     GHC.IO.Encoding.Latin1.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Latin1.$trModule3_closure+1;
         const GHC.IO.Encoding.Latin1.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.912286129 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.ascii7_bytes" {
     GHC.IO.Encoding.Latin1.ascii7_bytes:
         I8[] [65,83,67,73,73]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.915464661 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii6_closure" {
     GHC.IO.Encoding.Latin1.ascii6_closure:
         const GHC.IO.Encoding.Latin1.ascii6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii6_entry() //  [R1]
         { []
         }
     {offset
       c8LVa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8LVb; else goto c8LVc;
       c8LVb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LVc: // global
           (_c8LV7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8LV7::I64 == 0) goto c8LV9; else goto c8LV8;
       c8LV9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8LV8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8LV7::I64;
           R2 = GHC.IO.Encoding.Latin1.ascii7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii6_info" {
     GHC.IO.Encoding.Latin1.ascii6_info:
         const GHC.IO.Encoding.Latin1.ascii6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.92011137 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii2_closure" {
     GHC.IO.Encoding.Latin1.mkAscii2_closure:
         const GHC.IO.Encoding.Latin1.mkAscii2_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii2_entry() //  []
         { []
         }
     {offset
       c8LVp: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkAscii2_info" {
     GHC.IO.Encoding.Latin1.mkAscii2_info:
         const GHC.IO.Encoding.Latin1.mkAscii2_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.923737166 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii1_closure" {
     GHC.IO.Encoding.Latin1.mkAscii1_closure:
         const GHC.IO.Encoding.Latin1.mkAscii1_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii1_entry() //  []
         { []
         }
     {offset
       c8LVC: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkAscii1_info" {
     GHC.IO.Encoding.Latin1.mkAscii1_info:
         const GHC.IO.Encoding.Latin1.mkAscii1_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.929789602 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii_closure" {
     GHC.IO.Encoding.Latin1.mkAscii_closure:
         const GHC.IO.Encoding.Latin1.mkAscii_info;
         const 0;
 },
 sat_s8LzD_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8LVZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LzD_info" {
     sat_s8LzD_info:
         const sat_s8LzD_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8LWx_srt;
 },
 sat_s8LzF_entry() //  [R1]
         { []
         }
     {offset
       c8LW3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LW7; else goto c8LW6;
       c8LW7: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LW6: // global
           _s8Lzx::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LzD_info;
           P64[Hp - 48] = _s8Lzx::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LzF_info" {
     sat_s8LzF_info:
         const sat_s8LzF_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8LWx_srt;
 },
 sat_s8Lzz_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8LWi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8Lzz_info" {
     sat_s8Lzz_info:
         const sat_s8Lzz_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8LWx_srt+8;
 },
 sat_s8LzB_entry() //  [R1]
         { []
         }
     {offset
       c8LWm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LWq; else goto c8LWp;
       c8LWq: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LWp: // global
           _s8Lzx::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Lzz_info;
           P64[Hp - 48] = _s8Lzx::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LzB_info" {
     sat_s8LzB_info:
         const sat_s8LzB_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8LWx_srt+8;
 },
 GHC.IO.Encoding.Latin1.mkAscii_entry() //  [R2]
         { []
         }
     {offset
       c8LWs: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LWw; else goto c8LWv;
       c8LWw: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkAscii_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8LWv: // global
           I64[Hp - 56] = sat_s8LzF_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8LzB_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.ascii6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkAscii_info" {
     GHC.IO.Encoding.Latin1.mkAscii_info:
         const GHC.IO.Encoding.Latin1.mkAscii_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S8LWx_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.942385847 UTC

[section ""data" . lvl_r8Kux_closure" {
     lvl_r8Kux_closure:
         const lvl_r8Kux_info;
         const 0;
 },
 lvl_r8Kux_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LXi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8LXm; else goto c8LXn;
       c8LXm: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8Kux_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LXn: // global
           I64[Sp - 16] = block_c8LXf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LXv; else goto c8LXg;
       u8LXv: // global
           call _c8LXf() args: 0, res: 0, upd: 0;
       c8LXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl_r8Kux_info" {
     lvl_r8Kux_info:
         const lvl_r8Kux_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8LWx_srt+32;
 },
 _c8LXf() //  []
         { []
         }
     {offset
       c8LXf: // global
           _s8LzH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8LXl_info;
           R1 = _s8LzH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8LXu; else goto c8LXp;
       u8LXu: // global
           call _c8LXl() args: 0, res: 0, upd: 0;
       c8LXp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LXf_info" {
     block_c8LXf_info:
         const _c8LXf;
         const 1;
         const 4294967326;
         const S8LWx_srt+32;
 },
 _c8LXl() //  []
         { []
         }
     {offset
       c8LXl: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LXl_info" {
     block_c8LXl_info:
         const _c8LXl;
         const 0;
         const 4294967326;
         const S8LWx_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.949292085 UTC

[section ""data" . lvl1_r8Kuy_closure" {
     lvl1_r8Kuy_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.951579329 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii4_closure" {
     GHC.IO.Encoding.Latin1.ascii4_closure:
         const GHC.IO.Encoding.Latin1.ascii4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii4_entry() //  []
         { []
         }
     {offset
       c8LXQ: // global
           R1 = lvl1_r8Kuy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii4_info" {
     GHC.IO.Encoding.Latin1.ascii4_info:
         const GHC.IO.Encoding.Latin1.ascii4_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8LWx_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.957329107 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii2_closure" {
     GHC.IO.Encoding.Latin1.ascii2_closure:
         const GHC.IO.Encoding.Latin1.ascii2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii2_entry() //  [R2, R3]
         { []
         }
     {offset
       c8LY5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8LY9; else goto c8LYa;
       c8LY9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LYa: // global
           I64[Sp - 16] = block_c8LY2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LYj; else goto c8LY3;
       u8LYj: // global
           call _c8LY2(R1) args: 0, res: 0, upd: 0;
       c8LY3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii2_info" {
     GHC.IO.Encoding.Latin1.ascii2_info:
         const GHC.IO.Encoding.Latin1.ascii2_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const S8LWx_srt+56;
 },
 _c8LY2() //  [R1]
         { []
         }
     {offset
       c8LY2: // global
           I64[Sp - 16] = block_c8LY8_info;
           _s8LA3::P64 = P64[R1 + 7];
           _s8LA2::I64 = I64[R1 + 23];
           _s8LA6::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8LA6::I64;
           P64[Sp] = _s8LA3::P64;
           I64[Sp + 8] = _s8LA2::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LYi; else goto c8LYc;
       u8LYi: // global
           call _c8LY8() args: 0, res: 0, upd: 0;
       c8LYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LY2_info" {
     block_c8LY2_info:
         const _c8LY2;
         const 1;
         const 4294967326;
         const S8LWx_srt+56;
 },
 _c8LY8() //  []
         { []
         }
     {offset
       c8LY8: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c8LY8_info" {
     block_c8LY8_info:
         const _c8LY8;
         const 323;
         const 4294967326;
         const S8LWx_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.964711109 UTC

[section ""data" . lvl2_r8Kuz_closure" {
     lvl2_r8Kuz_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.966996086 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii1_closure" {
     GHC.IO.Encoding.Latin1.ascii1_closure:
         const GHC.IO.Encoding.Latin1.ascii1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii1_entry() //  []
         { []
         }
     {offset
       c8LYE: // global
           R1 = lvl2_r8Kuz_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.ascii1_info" {
     GHC.IO.Encoding.Latin1.ascii1_info:
         const GHC.IO.Encoding.Latin1.ascii1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8LWx_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.970358137 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_closure" {
     GHC.IO.Encoding.Latin1.ascii_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Latin1.ascii4_closure+1;
         const GHC.IO.Encoding.Latin1.ascii1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.972179189 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.latin7_bytes" {
     GHC.IO.Encoding.Latin1.latin7_bytes:
         I8[] [73,83,79,45,56,56,53,57,45,49]
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.974691587 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin6_closure" {
     GHC.IO.Encoding.Latin1.latin6_closure:
         const GHC.IO.Encoding.Latin1.latin6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin6_entry() //  [R1]
         { []
         }
     {offset
       c8LYU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8LYV; else goto c8LYW;
       c8LYV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LYW: // global
           (_c8LYR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8LYR::I64 == 0) goto c8LYT; else goto c8LYS;
       c8LYT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8LYS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8LYR::I64;
           R2 = GHC.IO.Encoding.Latin1.latin7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin6_info" {
     GHC.IO.Encoding.Latin1.latin6_info:
         const GHC.IO.Encoding.Latin1.latin6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.980941722 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_checked_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_checked_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_info;
         const 0;
 },
 sat_s8LAq_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8LZj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LAq_info" {
     sat_s8LAq_info:
         const sat_s8LAq_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8LWx_srt;
 },
 sat_s8LAs_entry() //  [R1]
         { []
         }
     {offset
       c8LZn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LZr; else goto c8LZq;
       c8LZr: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LZq: // global
           _s8LAk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LAq_info;
           P64[Hp - 48] = _s8LAk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LAs_info" {
     sat_s8LAs_info:
         const sat_s8LAs_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8LWx_srt;
 },
 sat_s8LAm_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8LZC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LAm_info" {
     sat_s8LAm_info:
         const sat_s8LAm_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8LWx_srt+8;
 },
 sat_s8LAo_entry() //  [R1]
         { []
         }
     {offset
       c8LZG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LZK; else goto c8LZJ;
       c8LZK: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LZJ: // global
           _s8LAk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LAm_info;
           P64[Hp - 48] = _s8LAk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LAo_info" {
     sat_s8LAo_info:
         const sat_s8LAo_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8LWx_srt+8;
 },
 GHC.IO.Encoding.Latin1.mkLatin1_checked_entry() //  [R2]
         { []
         }
     {offset
       c8LZM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LZQ; else goto c8LZP;
       c8LZQ: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8LZP: // global
           I64[Hp - 56] = sat_s8LAs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8LAo_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkLatin1_checked_info" {
     GHC.IO.Encoding.Latin1.mkLatin1_checked_info:
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_entry;
         const 0;
         const 13207024435214;
         const 4294967301;
         const S8LWx_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.993091963 UTC

[section ""data" . lvl3_r8KuA_closure" {
     lvl3_r8KuA_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.995719676 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin4_closure" {
     GHC.IO.Encoding.Latin1.latin4_closure:
         const GHC.IO.Encoding.Latin1.latin4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin4_entry() //  []
         { []
         }
     {offset
       c8M0z: // global
           R1 = lvl3_r8KuA_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin4_info" {
     GHC.IO.Encoding.Latin1.latin4_info:
         const GHC.IO.Encoding.Latin1.latin4_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8LWx_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:55.999051752 UTC

[section ""data" . lvl4_r8KuB_closure" {
     lvl4_r8KuB_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:56.00115254 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked1_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked1_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin1_checked1_entry() //  []
         { []
         }
     {offset
       c8M0M: // global
           R1 = lvl4_r8KuB_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin1_checked1_info" {
     GHC.IO.Encoding.Latin1.latin1_checked1_info:
         const GHC.IO.Encoding.Latin1.latin1_checked1_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8LWx_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:56.00479446 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin1_checked1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:56.008902032 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_info;
         const 0;
 },
 sat_s8LAB_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8M19: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LAB_info" {
     sat_s8LAB_info:
         const sat_s8LAB_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8LWx_srt;
 },
 sat_s8LAD_entry() //  [R1]
         { []
         }
     {offset
       c8M1d: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8M1h; else goto c8M1g;
       c8M1h: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8M1g: // global
           _s8LAv::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LAB_info;
           P64[Hp - 48] = _s8LAv::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LAD_info" {
     sat_s8LAD_info:
         const sat_s8LAD_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8LWx_srt;
 },
 sat_s8LAx_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       c8M1s: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LAx_info" {
     sat_s8LAx_info:
         const sat_s8LAx_entry;
         const 1;
         const 4294967305;
         const 12884901903;
         const S8LWx_srt+8;
 },
 sat_s8LAz_entry() //  [R1]
         { []
         }
     {offset
       c8M1w: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8M1A; else goto c8M1z;
       c8M1A: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8M1z: // global
           _s8LAv::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LAx_info;
           P64[Hp - 48] = _s8LAv::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8LAz_info" {
     sat_s8LAz_info:
         const sat_s8LAz_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8LWx_srt+8;
 },
 GHC.IO.Encoding.Latin1.mkLatin1_entry() //  [R2]
         { []
         }
     {offset
       c8M1C: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8M1G; else goto c8M1F;
       c8M1G: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8M1F: // global
           I64[Hp - 56] = sat_s8LAD_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8LAz_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.mkLatin1_info" {
     GHC.IO.Encoding.Latin1.mkLatin1_info:
         const GHC.IO.Encoding.Latin1.mkLatin1_entry;
         const 0;
         const 79177722101774;
         const 4294967301;
         const S8LWx_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:56.019816197 UTC

[section ""data" . lvl5_r8KuC_closure" {
     lvl5_r8KuC_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:56.022082032 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin2_closure" {
     GHC.IO.Encoding.Latin1.latin2_closure:
         const GHC.IO.Encoding.Latin1.latin2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin2_entry() //  []
         { []
         }
     {offset
       c8M2p: // global
           R1 = lvl5_r8KuC_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.IO.Encoding.Latin1.latin2_info" {
     GHC.IO.Encoding.Latin1.latin2_info:
         const GHC.IO.Encoding.Latin1.latin2_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const S8LWx_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:56.02628318 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_closure" {
     GHC.IO.Encoding.Latin1.latin1_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin2_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:03:56.028196224 UTC

[section ""relreadonly" . S8LWx_srt" {
     S8LWx_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Latin1.mkAscii_closure;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8Kux_closure;
         const lvl1_r8Kuy_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.Latin1.ascii2_closure;
         const lvl2_r8Kuz_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const lvl3_r8KuA_closure;
         const lvl4_r8KuB_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_closure;
         const lvl5_r8KuC_closure;
 }]

