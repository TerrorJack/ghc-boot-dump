
==================== Output Cmm ====================
2018-03-16 16:03:54.34228306 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:54.345140744 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin5_closure" {
     GHC.IO.Encoding.Latin1.latin5_closure:
         const GHC.IO.Encoding.Latin1.latin5_info;
 },
 sat_s8Kv1_entry() //  [R1]
         { info_tbl: [(c8KAW,
                       label: sat_s8Kv1_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KAW: // global
           _s8Kv1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KAX; else goto c8KAY;
       c8KAY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KB0; else goto c8KAZ;
       c8KB0: // global
           HpAlloc = 56;
           goto c8KAX;
       c8KAX: // global
           R1 = _s8Kv1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KAZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kv1::P64;
           _s8KuN::I64 = I64[_s8Kv1::P64 + 56];
           _s8KuX::I64 = I64[_s8Kv1::P64 + 64];
           if (_s8KuX::I64 == _s8KuN::I64) goto c8KAV; else goto c8KAU;
       c8KAV: // global
           _s8KuV::P64 = P64[_s8Kv1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KuV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KAU: // global
           _s8KuJ::P64 = P64[_s8Kv1::P64 + 16];
           _s8KuK::P64 = P64[_s8Kv1::P64 + 24];
           _s8KuI::I64 = I64[_s8Kv1::P64 + 40];
           _s8KuL::I64 = I64[_s8Kv1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = _s8KuK::P64;
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = _s8KuL::I64;
           I64[Hp - 8] = _s8KuX::I64;
           I64[Hp] = _s8KuN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Kv9_entry() //  [R1]
         { info_tbl: [(c8KBi,
                       label: sat_s8Kv9_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KBi: // global
           _s8Kv9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KBj; else goto c8KBk;
       c8KBk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KBm; else goto c8KBl;
       c8KBm: // global
           HpAlloc = 56;
           goto c8KBj;
       c8KBj: // global
           R1 = _s8Kv9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KBl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kv9::P64;
           _s8KuN::I64 = I64[_s8Kv9::P64 + 56];
           _s8Kv5::I64 = I64[_s8Kv9::P64 + 64];
           if (_s8Kv5::I64 == _s8KuN::I64) goto c8KBh; else goto c8KBg;
       c8KBh: // global
           _s8KuV::P64 = P64[_s8Kv9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KuV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KBg: // global
           _s8KuJ::P64 = P64[_s8Kv9::P64 + 16];
           _s8KuK::P64 = P64[_s8Kv9::P64 + 24];
           _s8KuI::I64 = I64[_s8Kv9::P64 + 40];
           _s8KuL::I64 = I64[_s8Kv9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = _s8KuK::P64;
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = _s8KuL::I64;
           I64[Hp - 8] = _s8Kv5::I64;
           I64[Hp] = _s8KuN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin5_entry() //  [R2, R3]
         { info_tbl: [(c8KBp,
                       label: GHC.IO.Encoding.Latin1.latin5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KBp: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8KBq; else goto c8KBr;
       c8KBq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KBr: // global
           I64[Sp - 16] = block_c8KAw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KCg; else goto c8KAx;
       u8KCg: // global
           call _c8KAw(R1) args: 0, res: 0, upd: 0;
       c8KAx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KAw() //  [R1]
         { info_tbl: [(c8KAw,
                       label: block_c8KAw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KAw: // global
           I64[Sp - 40] = block_c8KAB_info;
           _s8KuJ::P64 = P64[R1 + 7];
           _s8KuK::P64 = P64[R1 + 15];
           _s8KuI::I64 = I64[R1 + 23];
           _s8KuL::I64 = I64[R1 + 31];
           _s8KuM::I64 = I64[R1 + 39];
           _s8KuN::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8KuK::P64;
           I64[Sp - 24] = _s8KuL::I64;
           I64[Sp - 16] = _s8KuM::I64;
           I64[Sp - 8] = _s8KuN::I64;
           P64[Sp] = _s8KuJ::P64;
           I64[Sp + 8] = _s8KuI::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8KCd; else goto c8KAC;
       u8KCd: // global
           call _c8KAB(R1) args: 0, res: 0, upd: 0;
       c8KAC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KAB() //  [R1]
         { info_tbl: [(c8KAB,
                       label: block_c8KAB_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KAB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KBv; else goto c8KBu;
       c8KBv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KBu: // global
           _s8KuQ::P64 = P64[R1 + 7];
           _s8KuR::P64 = P64[R1 + 15];
           _s8KuP::I64 = I64[R1 + 23];
           _s8KuS::I64 = I64[R1 + 31];
           _s8KuT::I64 = I64[R1 + 39];
           _s8KuU::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8KuJ::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8KuI::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KuN::I64 = I64[Sp + 32];
           _c8KAG::P64 = Hp - 47;
           _s8Kve::I64 = _s8KuU::I64;
           _s8Kvd::I64 = I64[Sp + 24];
           goto c8KBG;
       c8KBG: // global
           if (%MO_S_Lt_W64(_s8Kve::I64,
                            _s8KuS::I64)) goto c8KBT; else goto c8KBU;
       c8KBT: // global
           if (%MO_S_Lt_W64(_s8Kvd::I64,
                            _s8KuN::I64)) goto c8KBQ; else goto c8KBR;
       c8KBQ: // global
           _s8Kvl::I64 = %MO_UU_Conv_W8_W64(I8[_s8KuI::I64 + _s8Kvd::I64]);
           call MO_Touch(_s8KuJ::P64);
           I32[_s8KuP::I64 + (_s8Kve::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Kvl::I64);
           call MO_Touch(_s8KuQ::P64);
           _s8Kve::I64 = _s8Kve::I64 + 1;
           _s8Kvd::I64 = _s8Kvd::I64 + 1;
           goto c8KBG;
       c8KBR: // global
           P64[Sp - 48] = _s8KuQ::P64;
           P64[Sp - 40] = _s8KuR::P64;
           I64[Sp - 32] = _s8KuS::I64;
           I64[Sp - 24] = _s8KuT::I64;
           I64[Sp - 16] = _s8Kvd::I64;
           I64[Sp - 8] = _s8Kve::I64;
           I64[Sp] = _s8KuP::I64;
           P64[Sp + 24] = _c8KAG::P64;
           Sp = Sp - 56;
           call _c8KAJ() args: 0, res: 0, upd: 0;
       c8KBU: // global
           P64[Sp - 48] = _s8KuQ::P64;
           P64[Sp - 40] = _s8KuR::P64;
           I64[Sp - 32] = _s8KuS::I64;
           I64[Sp - 24] = _s8KuT::I64;
           I64[Sp - 16] = _s8Kvd::I64;
           I64[Sp - 8] = _s8Kve::I64;
           I64[Sp] = _s8KuP::I64;
           P64[Sp + 24] = _c8KAG::P64;
           Sp = Sp - 56;
           call _c8KB5() args: 0, res: 0, upd: 0;
     }
 },
 _c8KAJ() //  []
         { info_tbl: [(c8KAJ,
                       label: block_c8KAJ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KAJ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KBz; else goto c8KBy;
       c8KBz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KAJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KBy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kv1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KB5() //  []
         { info_tbl: [(c8KB5,
                       label: block_c8KB5_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KB5: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KBD; else goto c8KBC;
       c8KBD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KB5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KBC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kv9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.349458634 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_decode_closure" {
     GHC.IO.Encoding.Latin1.latin1_decode_closure:
         const GHC.IO.Encoding.Latin1.latin1_decode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_decode_entry() //  [R2, R3]
         { info_tbl: [(c8KCl,
                       label: GHC.IO.Encoding.Latin1.latin1_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KCl: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.352634212 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii5_closure" {
     GHC.IO.Encoding.Latin1.ascii5_closure:
         const GHC.IO.Encoding.Latin1.ascii5_info;
 },
 sat_s8KvQ_entry() //  [R1]
         { info_tbl: [(c8KCS,
                       label: sat_s8KvQ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KCS: // global
           _s8KvQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KCT; else goto c8KCU;
       c8KCU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KCW; else goto c8KCV;
       c8KCW: // global
           HpAlloc = 56;
           goto c8KCT;
       c8KCT: // global
           R1 = _s8KvQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KCV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KvQ::P64;
           _s8KvC::I64 = I64[_s8KvQ::P64 + 56];
           _s8KvM::I64 = I64[_s8KvQ::P64 + 64];
           if (_s8KvM::I64 == _s8KvC::I64) goto c8KCR; else goto c8KCQ;
       c8KCR: // global
           _s8KvK::P64 = P64[_s8KvQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KCQ: // global
           _s8Kvy::P64 = P64[_s8KvQ::P64 + 16];
           _s8Kvz::P64 = P64[_s8KvQ::P64 + 24];
           _s8Kvx::I64 = I64[_s8KvQ::P64 + 40];
           _s8KvA::I64 = I64[_s8KvQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8KvM::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KvY_entry() //  [R1]
         { info_tbl: [(c8KDe,
                       label: sat_s8KvY_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KDe: // global
           _s8KvY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KDf; else goto c8KDg;
       c8KDg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KDi; else goto c8KDh;
       c8KDi: // global
           HpAlloc = 56;
           goto c8KDf;
       c8KDf: // global
           R1 = _s8KvY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KDh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KvY::P64;
           _s8KvC::I64 = I64[_s8KvY::P64 + 56];
           _s8KvU::I64 = I64[_s8KvY::P64 + 64];
           if (_s8KvU::I64 == _s8KvC::I64) goto c8KDd; else goto c8KDc;
       c8KDd: // global
           _s8KvK::P64 = P64[_s8KvY::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KDc: // global
           _s8Kvy::P64 = P64[_s8KvY::P64 + 16];
           _s8Kvz::P64 = P64[_s8KvY::P64 + 24];
           _s8Kvx::I64 = I64[_s8KvY::P64 + 40];
           _s8KvA::I64 = I64[_s8KvY::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8KvU::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Kw6_entry() //  [R1]
         { info_tbl: [(c8KDA,
                       label: sat_s8Kw6_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KDA: // global
           _s8Kw6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KDB; else goto c8KDC;
       c8KDC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KDE; else goto c8KDD;
       c8KDE: // global
           HpAlloc = 56;
           goto c8KDB;
       c8KDB: // global
           R1 = _s8Kw6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KDD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kw6::P64;
           _s8KvC::I64 = I64[_s8Kw6::P64 + 56];
           _s8Kw2::I64 = I64[_s8Kw6::P64 + 64];
           if (_s8Kw2::I64 == _s8KvC::I64) goto c8KDz; else goto c8KDy;
       c8KDz: // global
           _s8KvK::P64 = P64[_s8Kw6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KDy: // global
           _s8Kvy::P64 = P64[_s8Kw6::P64 + 16];
           _s8Kvz::P64 = P64[_s8Kw6::P64 + 24];
           _s8Kvx::I64 = I64[_s8Kw6::P64 + 40];
           _s8KvA::I64 = I64[_s8Kw6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8Kw2::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.ascii5_entry() //  [R2, R3]
         { info_tbl: [(c8KDH,
                       label: GHC.IO.Encoding.Latin1.ascii5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KDH: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8KDI; else goto c8KDJ;
       c8KDI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KDJ: // global
           I64[Sp - 16] = block_c8KCs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KEK; else goto c8KCt;
       u8KEK: // global
           call _c8KCs(R1) args: 0, res: 0, upd: 0;
       c8KCt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KCs() //  [R1]
         { info_tbl: [(c8KCs,
                       label: block_c8KCs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KCs: // global
           I64[Sp - 40] = block_c8KCx_info;
           _s8Kvy::P64 = P64[R1 + 7];
           _s8Kvz::P64 = P64[R1 + 15];
           _s8Kvx::I64 = I64[R1 + 23];
           _s8KvA::I64 = I64[R1 + 31];
           _s8KvB::I64 = I64[R1 + 39];
           _s8KvC::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kvz::P64;
           I64[Sp - 24] = _s8KvA::I64;
           I64[Sp - 16] = _s8KvB::I64;
           I64[Sp - 8] = _s8KvC::I64;
           P64[Sp] = _s8Kvy::P64;
           I64[Sp + 8] = _s8Kvx::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8KEG; else goto c8KCy;
       u8KEG: // global
           call _c8KCx(R1) args: 0, res: 0, upd: 0;
       c8KCy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KCx() //  [R1]
         { info_tbl: [(c8KCx,
                       label: block_c8KCx_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KCx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KDN; else goto c8KDM;
       c8KDN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KDM: // global
           _s8KvF::P64 = P64[R1 + 7];
           _s8KvG::P64 = P64[R1 + 15];
           _s8KvE::I64 = I64[R1 + 23];
           _s8KvH::I64 = I64[R1 + 31];
           _s8KvI::I64 = I64[R1 + 39];
           _s8KvJ::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kvy::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kvx::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KvC::I64 = I64[Sp + 32];
           _c8KCC::P64 = Hp - 47;
           _s8Kwb::I64 = _s8KvJ::I64;
           _s8Kwa::I64 = I64[Sp + 24];
           goto c8KE2;
       c8KE2: // global
           if (%MO_S_Lt_W64(_s8Kwb::I64,
                            _s8KvH::I64)) goto c8KEp; else goto c8KEq;
       c8KEp: // global
           if (%MO_S_Lt_W64(_s8Kwa::I64,
                            _s8KvC::I64)) goto c8KEm; else goto c8KEn;
       c8KEm: // global
           _s8Kwi::I64 = %MO_UU_Conv_W8_W64(I8[_s8Kvx::I64 + _s8Kwa::I64]);
           call MO_Touch(_s8Kvy::P64);
           if (_s8Kwi::I64 <= 127) goto c8KEj; else goto c8KEk;
       c8KEj: // global
           I32[_s8KvE::I64 + (_s8Kwb::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Kwi::I64);
           call MO_Touch(_s8KvF::P64);
           _s8Kwb::I64 = _s8Kwb::I64 + 1;
           _s8Kwa::I64 = _s8Kwa::I64 + 1;
           goto c8KE2;
       c8KEk: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8KCC::P64;
           Sp = Sp - 56;
           call _c8KCF() args: 0, res: 0, upd: 0;
       c8KEn: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8KCC::P64;
           Sp = Sp - 56;
           call _c8KD1() args: 0, res: 0, upd: 0;
       c8KEq: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8KCC::P64;
           Sp = Sp - 56;
           call _c8KDn() args: 0, res: 0, upd: 0;
     }
 },
 _c8KCF() //  []
         { info_tbl: [(c8KCF,
                       label: block_c8KCF_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KCF: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KDR; else goto c8KDQ;
       c8KDR: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KCF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KDQ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KvQ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KD1() //  []
         { info_tbl: [(c8KD1,
                       label: block_c8KD1_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KD1: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KDV; else goto c8KDU;
       c8KDV: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KD1_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KDU: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KvY_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KDn() //  []
         { info_tbl: [(c8KDn,
                       label: block_c8KDn_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KDn: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KDZ; else goto c8KDY;
       c8KDZ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KDn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KDY: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kw6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.357974979 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_decode_closure" {
     GHC.IO.Encoding.Latin1.ascii_decode_closure:
         const GHC.IO.Encoding.Latin1.ascii_decode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_decode_entry() //  [R2, R3]
         { info_tbl: [(c8KEP,
                       label: GHC.IO.Encoding.Latin1.ascii_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KEP: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.360634523 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin3_closure" {
     GHC.IO.Encoding.Latin1.latin3_closure:
         const GHC.IO.Encoding.Latin1.latin3_info;
 },
 sat_s8KwO_entry() //  [R1]
         { info_tbl: [(c8KFm,
                       label: sat_s8KwO_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KFm: // global
           _s8KwO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KFn; else goto c8KFo;
       c8KFo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KFq; else goto c8KFp;
       c8KFq: // global
           HpAlloc = 56;
           goto c8KFn;
       c8KFn: // global
           R1 = _s8KwO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KFp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KwO::P64;
           _s8KwA::I64 = I64[_s8KwO::P64 + 56];
           _s8KwK::I64 = I64[_s8KwO::P64 + 64];
           if (_s8KwK::I64 == _s8KwA::I64) goto c8KFl; else goto c8KFk;
       c8KFl: // global
           _s8KwI::P64 = P64[_s8KwO::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KwI::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KFk: // global
           _s8Kww::P64 = P64[_s8KwO::P64 + 16];
           _s8Kwx::P64 = P64[_s8KwO::P64 + 24];
           _s8Kwv::I64 = I64[_s8KwO::P64 + 40];
           _s8Kwy::I64 = I64[_s8KwO::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = _s8Kwx::P64;
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = _s8Kwy::I64;
           I64[Hp - 8] = _s8KwK::I64;
           I64[Hp] = _s8KwA::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KwW_entry() //  [R1]
         { info_tbl: [(c8KFI,
                       label: sat_s8KwW_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KFI: // global
           _s8KwW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KFJ; else goto c8KFK;
       c8KFK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KFM; else goto c8KFL;
       c8KFM: // global
           HpAlloc = 56;
           goto c8KFJ;
       c8KFJ: // global
           R1 = _s8KwW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KFL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KwW::P64;
           _s8KwA::I64 = I64[_s8KwW::P64 + 56];
           _s8KwS::I64 = I64[_s8KwW::P64 + 64];
           if (_s8KwS::I64 == _s8KwA::I64) goto c8KFH; else goto c8KFG;
       c8KFH: // global
           _s8KwI::P64 = P64[_s8KwW::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KwI::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KFG: // global
           _s8Kww::P64 = P64[_s8KwW::P64 + 16];
           _s8Kwx::P64 = P64[_s8KwW::P64 + 24];
           _s8Kwv::I64 = I64[_s8KwW::P64 + 40];
           _s8Kwy::I64 = I64[_s8KwW::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = _s8Kwx::P64;
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = _s8Kwy::I64;
           I64[Hp - 8] = _s8KwS::I64;
           I64[Hp] = _s8KwA::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin3_entry() //  [R2, R3]
         { info_tbl: [(c8KFP,
                       label: GHC.IO.Encoding.Latin1.latin3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KFP: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8KFQ; else goto c8KFR;
       c8KFQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KFR: // global
           I64[Sp - 16] = block_c8KEW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KGJ; else goto c8KEX;
       u8KGJ: // global
           call _c8KEW(R1) args: 0, res: 0, upd: 0;
       c8KEX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KEW() //  [R1]
         { info_tbl: [(c8KEW,
                       label: block_c8KEW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KEW: // global
           I64[Sp - 40] = block_c8KF1_info;
           _s8Kww::P64 = P64[R1 + 7];
           _s8Kwx::P64 = P64[R1 + 15];
           _s8Kwv::I64 = I64[R1 + 23];
           _s8Kwy::I64 = I64[R1 + 31];
           _s8Kwz::I64 = I64[R1 + 39];
           _s8KwA::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kwx::P64;
           I64[Sp - 24] = _s8Kwy::I64;
           I64[Sp - 16] = _s8Kwz::I64;
           I64[Sp - 8] = _s8KwA::I64;
           P64[Sp] = _s8Kww::P64;
           I64[Sp + 8] = _s8Kwv::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8KGG; else goto c8KF2;
       u8KGG: // global
           call _c8KF1(R1) args: 0, res: 0, upd: 0;
       c8KF2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KF1() //  [R1]
         { info_tbl: [(c8KF1,
                       label: block_c8KF1_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KF1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KFV; else goto c8KFU;
       c8KFV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KFU: // global
           _s8KwD::P64 = P64[R1 + 7];
           _s8KwE::P64 = P64[R1 + 15];
           _s8KwC::I64 = I64[R1 + 23];
           _s8KwF::I64 = I64[R1 + 31];
           _s8KwG::I64 = I64[R1 + 39];
           _s8KwH::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kww::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kwv::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KwA::I64 = I64[Sp + 32];
           _c8KF6::P64 = Hp - 47;
           _s8Kx1::I64 = _s8KwH::I64;
           _s8Kx0::I64 = I64[Sp + 24];
           goto c8KG6;
       c8KG6: // global
           if (%MO_S_Lt_W64(_s8Kx1::I64,
                            _s8KwF::I64)) goto c8KGj; else goto c8KGk;
       c8KGj: // global
           if (%MO_S_Lt_W64(_s8Kx0::I64,
                            _s8KwA::I64)) goto c8KGg; else goto c8KGh;
       c8KGg: // global
           _s8Kx7::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kwv::I64 + (_s8Kx0::I64 << 2)]);
           call MO_Touch(_s8Kww::P64);
           I8[_s8KwC::I64 + _s8Kx1::I64] = %MO_UU_Conv_W64_W8(_s8Kx7::I64);
           call MO_Touch(_s8KwD::P64);
           _s8Kx1::I64 = _s8Kx1::I64 + 1;
           _s8Kx0::I64 = _s8Kx0::I64 + 1;
           goto c8KG6;
       c8KGh: // global
           P64[Sp - 48] = _s8KwD::P64;
           P64[Sp - 40] = _s8KwE::P64;
           I64[Sp - 32] = _s8KwF::I64;
           I64[Sp - 24] = _s8KwG::I64;
           I64[Sp - 16] = _s8Kx0::I64;
           I64[Sp - 8] = _s8Kx1::I64;
           I64[Sp] = _s8KwC::I64;
           P64[Sp + 24] = _c8KF6::P64;
           Sp = Sp - 56;
           call _c8KF9() args: 0, res: 0, upd: 0;
       c8KGk: // global
           P64[Sp - 48] = _s8KwD::P64;
           P64[Sp - 40] = _s8KwE::P64;
           I64[Sp - 32] = _s8KwF::I64;
           I64[Sp - 24] = _s8KwG::I64;
           I64[Sp - 16] = _s8Kx0::I64;
           I64[Sp - 8] = _s8Kx1::I64;
           I64[Sp] = _s8KwC::I64;
           P64[Sp + 24] = _c8KF6::P64;
           Sp = Sp - 56;
           call _c8KFv() args: 0, res: 0, upd: 0;
     }
 },
 _c8KF9() //  []
         { info_tbl: [(c8KF9,
                       label: block_c8KF9_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KF9: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KFZ; else goto c8KFY;
       c8KFZ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KF9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KFY: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KwO_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KFv() //  []
         { info_tbl: [(c8KFv,
                       label: block_c8KFv_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KFv: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KG3; else goto c8KG2;
       c8KG3: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KFv_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KG2: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KwW_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.364867957 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_encode_entry() //  [R2, R3]
         { info_tbl: [(c8KGO,
                       label: GHC.IO.Encoding.Latin1.latin1_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KGO: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.368082414 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii3_closure" {
     GHC.IO.Encoding.Latin1.ascii3_closure:
         const GHC.IO.Encoding.Latin1.ascii3_info;
 },
 sat_s8KxE_entry() //  [R1]
         { info_tbl: [(c8KHl,
                       label: sat_s8KxE_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KHl: // global
           _s8KxE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KHm; else goto c8KHn;
       c8KHn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KHp; else goto c8KHo;
       c8KHp: // global
           HpAlloc = 56;
           goto c8KHm;
       c8KHm: // global
           R1 = _s8KxE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KHo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxE::P64;
           _s8Kxq::I64 = I64[_s8KxE::P64 + 56];
           _s8KxA::I64 = I64[_s8KxE::P64 + 64];
           if (_s8KxA::I64 == _s8Kxq::I64) goto c8KHk; else goto c8KHj;
       c8KHk: // global
           _s8Kxy::P64 = P64[_s8KxE::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KHj: // global
           _s8Kxm::P64 = P64[_s8KxE::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxE::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxE::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxE::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxA::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KxM_entry() //  [R1]
         { info_tbl: [(c8KHH,
                       label: sat_s8KxM_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KHH: // global
           _s8KxM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KHI; else goto c8KHJ;
       c8KHJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KHL; else goto c8KHK;
       c8KHL: // global
           HpAlloc = 56;
           goto c8KHI;
       c8KHI: // global
           R1 = _s8KxM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KHK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxM::P64;
           _s8Kxq::I64 = I64[_s8KxM::P64 + 56];
           _s8KxI::I64 = I64[_s8KxM::P64 + 64];
           if (_s8KxI::I64 == _s8Kxq::I64) goto c8KHG; else goto c8KHF;
       c8KHG: // global
           _s8Kxy::P64 = P64[_s8KxM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KHF: // global
           _s8Kxm::P64 = P64[_s8KxM::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxM::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxM::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxI::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KxU_entry() //  [R1]
         { info_tbl: [(c8KI3,
                       label: sat_s8KxU_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KI3: // global
           _s8KxU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KI4; else goto c8KI5;
       c8KI5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KI7; else goto c8KI6;
       c8KI7: // global
           HpAlloc = 56;
           goto c8KI4;
       c8KI4: // global
           R1 = _s8KxU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KI6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxU::P64;
           _s8Kxq::I64 = I64[_s8KxU::P64 + 56];
           _s8KxQ::I64 = I64[_s8KxU::P64 + 64];
           if (_s8KxQ::I64 == _s8Kxq::I64) goto c8KI2; else goto c8KI1;
       c8KI2: // global
           _s8Kxy::P64 = P64[_s8KxU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KI1: // global
           _s8Kxm::P64 = P64[_s8KxU::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxU::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxU::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxQ::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.ascii3_entry() //  [R2, R3]
         { info_tbl: [(c8KIa,
                       label: GHC.IO.Encoding.Latin1.ascii3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KIa: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8KIb; else goto c8KIc;
       c8KIb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KIc: // global
           I64[Sp - 16] = block_c8KGV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KJj; else goto c8KGW;
       u8KJj: // global
           call _c8KGV(R1) args: 0, res: 0, upd: 0;
       c8KGW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KGV() //  [R1]
         { info_tbl: [(c8KGV,
                       label: block_c8KGV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KGV: // global
           I64[Sp - 40] = block_c8KH0_info;
           _s8Kxm::P64 = P64[R1 + 7];
           _s8Kxn::P64 = P64[R1 + 15];
           _s8Kxl::I64 = I64[R1 + 23];
           _s8Kxo::I64 = I64[R1 + 31];
           _s8Kxp::I64 = I64[R1 + 39];
           _s8Kxq::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kxn::P64;
           I64[Sp - 24] = _s8Kxo::I64;
           I64[Sp - 16] = _s8Kxp::I64;
           I64[Sp - 8] = _s8Kxq::I64;
           P64[Sp] = _s8Kxm::P64;
           I64[Sp + 8] = _s8Kxl::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8KJf; else goto c8KH1;
       u8KJf: // global
           call _c8KH0(R1) args: 0, res: 0, upd: 0;
       c8KH1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KH0() //  [R1]
         { info_tbl: [(c8KH0,
                       label: block_c8KH0_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KH0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KIg; else goto c8KIf;
       c8KIg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KIf: // global
           _s8Kxt::P64 = P64[R1 + 7];
           _s8Kxu::P64 = P64[R1 + 15];
           _s8Kxs::I64 = I64[R1 + 23];
           _s8Kxv::I64 = I64[R1 + 31];
           _s8Kxw::I64 = I64[R1 + 39];
           _s8Kxx::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kxm::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kxl::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Kxq::I64 = I64[Sp + 32];
           _c8KH5::P64 = Hp - 47;
           _s8KxZ::I64 = _s8Kxx::I64;
           _s8KxY::I64 = I64[Sp + 24];
           goto c8KIv;
       c8KIv: // global
           if (%MO_S_Lt_W64(_s8KxZ::I64,
                            _s8Kxv::I64)) goto c8KIS; else goto c8KIT;
       c8KIS: // global
           if (%MO_S_Lt_W64(_s8KxY::I64,
                            _s8Kxq::I64)) goto c8KIP; else goto c8KIQ;
       c8KIP: // global
           _s8Ky5::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kxl::I64 + (_s8KxY::I64 << 2)]);
           call MO_Touch(_s8Kxm::P64);
           if (%MO_S_Le_W64(_s8Ky5::I64, 127)) goto c8KIM; else goto c8KIN;
       c8KIM: // global
           I8[_s8Kxs::I64 + _s8KxZ::I64] = %MO_UU_Conv_W64_W8(_s8Ky5::I64);
           call MO_Touch(_s8Kxt::P64);
           _s8KxZ::I64 = _s8KxZ::I64 + 1;
           _s8KxY::I64 = _s8KxY::I64 + 1;
           goto c8KIv;
       c8KIN: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8KH5::P64;
           Sp = Sp - 56;
           call _c8KH8() args: 0, res: 0, upd: 0;
       c8KIQ: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8KH5::P64;
           Sp = Sp - 56;
           call _c8KHu() args: 0, res: 0, upd: 0;
       c8KIT: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8KH5::P64;
           Sp = Sp - 56;
           call _c8KHQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8KH8() //  []
         { info_tbl: [(c8KH8,
                       label: block_c8KH8_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KH8: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KIk; else goto c8KIj;
       c8KIk: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KH8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KIj: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxE_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KHu() //  []
         { info_tbl: [(c8KHu,
                       label: block_c8KHu_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KHu: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KIo; else goto c8KIn;
       c8KIo: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KHu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KIn: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KHQ() //  []
         { info_tbl: [(c8KHQ,
                       label: block_c8KHQ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KHQ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KIs; else goto c8KIr;
       c8KIs: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KHQ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KIr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.375425289 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_encode_closure" {
     GHC.IO.Encoding.Latin1.ascii_encode_closure:
         const GHC.IO.Encoding.Latin1.ascii_encode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_encode_entry() //  [R2, R3]
         { info_tbl: [(c8KJo,
                       label: GHC.IO.Encoding.Latin1.ascii_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KJo: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.37853797 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked2_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked2_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked2_info;
 },
 sat_s8KyE_entry() //  [R1]
         { info_tbl: [(c8KJV,
                       label: sat_s8KyE_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KJV: // global
           _s8KyE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KJW; else goto c8KJX;
       c8KJX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KJZ; else goto c8KJY;
       c8KJZ: // global
           HpAlloc = 56;
           goto c8KJW;
       c8KJW: // global
           R1 = _s8KyE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KJY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyE::P64;
           _s8Kyq::I64 = I64[_s8KyE::P64 + 56];
           _s8KyA::I64 = I64[_s8KyE::P64 + 64];
           if (_s8KyA::I64 == _s8Kyq::I64) goto c8KJU; else goto c8KJT;
       c8KJU: // global
           _s8Kyy::P64 = P64[_s8KyE::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KJT: // global
           _s8Kym::P64 = P64[_s8KyE::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyE::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyE::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyE::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyA::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KyM_entry() //  [R1]
         { info_tbl: [(c8KKh,
                       label: sat_s8KyM_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KKh: // global
           _s8KyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KKi; else goto c8KKj;
       c8KKj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KKl; else goto c8KKk;
       c8KKl: // global
           HpAlloc = 56;
           goto c8KKi;
       c8KKi: // global
           R1 = _s8KyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KKk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyM::P64;
           _s8Kyq::I64 = I64[_s8KyM::P64 + 56];
           _s8KyI::I64 = I64[_s8KyM::P64 + 64];
           if (_s8KyI::I64 == _s8Kyq::I64) goto c8KKg; else goto c8KKf;
       c8KKg: // global
           _s8Kyy::P64 = P64[_s8KyM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KKf: // global
           _s8Kym::P64 = P64[_s8KyM::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyM::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyM::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyI::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KyU_entry() //  [R1]
         { info_tbl: [(c8KKD,
                       label: sat_s8KyU_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KKD: // global
           _s8KyU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KKE; else goto c8KKF;
       c8KKF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KKH; else goto c8KKG;
       c8KKH: // global
           HpAlloc = 56;
           goto c8KKE;
       c8KKE: // global
           R1 = _s8KyU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KKG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyU::P64;
           _s8Kyq::I64 = I64[_s8KyU::P64 + 56];
           _s8KyQ::I64 = I64[_s8KyU::P64 + 64];
           if (_s8KyQ::I64 == _s8Kyq::I64) goto c8KKC; else goto c8KKB;
       c8KKC: // global
           _s8Kyy::P64 = P64[_s8KyU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KKB: // global
           _s8Kym::P64 = P64[_s8KyU::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyU::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyU::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyQ::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin1_checked2_entry() //  [R2, R3]
         { info_tbl: [(c8KKK,
                       label: GHC.IO.Encoding.Latin1.latin1_checked2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KKK: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8KKL; else goto c8KKM;
       c8KKL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin1_checked2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KKM: // global
           I64[Sp - 16] = block_c8KJv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KLT; else goto c8KJw;
       u8KLT: // global
           call _c8KJv(R1) args: 0, res: 0, upd: 0;
       c8KJw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KJv() //  [R1]
         { info_tbl: [(c8KJv,
                       label: block_c8KJv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KJv: // global
           I64[Sp - 40] = block_c8KJA_info;
           _s8Kym::P64 = P64[R1 + 7];
           _s8Kyn::P64 = P64[R1 + 15];
           _s8Kyl::I64 = I64[R1 + 23];
           _s8Kyo::I64 = I64[R1 + 31];
           _s8Kyp::I64 = I64[R1 + 39];
           _s8Kyq::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kyn::P64;
           I64[Sp - 24] = _s8Kyo::I64;
           I64[Sp - 16] = _s8Kyp::I64;
           I64[Sp - 8] = _s8Kyq::I64;
           P64[Sp] = _s8Kym::P64;
           I64[Sp + 8] = _s8Kyl::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8KLP; else goto c8KJB;
       u8KLP: // global
           call _c8KJA(R1) args: 0, res: 0, upd: 0;
       c8KJB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KJA() //  [R1]
         { info_tbl: [(c8KJA,
                       label: block_c8KJA_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KJA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KKQ; else goto c8KKP;
       c8KKQ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KKP: // global
           _s8Kyt::P64 = P64[R1 + 7];
           _s8Kyu::P64 = P64[R1 + 15];
           _s8Kys::I64 = I64[R1 + 23];
           _s8Kyv::I64 = I64[R1 + 31];
           _s8Kyw::I64 = I64[R1 + 39];
           _s8Kyx::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kym::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kyl::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Kyq::I64 = I64[Sp + 32];
           _c8KJF::P64 = Hp - 47;
           _s8KyZ::I64 = _s8Kyx::I64;
           _s8KyY::I64 = I64[Sp + 24];
           goto c8KL5;
       c8KL5: // global
           if (%MO_S_Lt_W64(_s8KyZ::I64,
                            _s8Kyv::I64)) goto c8KLs; else goto c8KLt;
       c8KLs: // global
           if (%MO_S_Lt_W64(_s8KyY::I64,
                            _s8Kyq::I64)) goto c8KLp; else goto c8KLq;
       c8KLp: // global
           _s8Kz5::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kyl::I64 + (_s8KyY::I64 << 2)]);
           call MO_Touch(_s8Kym::P64);
           if (%MO_S_Le_W64(_s8Kz5::I64, 255)) goto c8KLm; else goto c8KLn;
       c8KLm: // global
           I8[_s8Kys::I64 + _s8KyZ::I64] = %MO_UU_Conv_W64_W8(_s8Kz5::I64);
           call MO_Touch(_s8Kyt::P64);
           _s8KyZ::I64 = _s8KyZ::I64 + 1;
           _s8KyY::I64 = _s8KyY::I64 + 1;
           goto c8KL5;
       c8KLn: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8KJF::P64;
           Sp = Sp - 56;
           call _c8KJI() args: 0, res: 0, upd: 0;
       c8KLq: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8KJF::P64;
           Sp = Sp - 56;
           call _c8KK4() args: 0, res: 0, upd: 0;
       c8KLt: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8KJF::P64;
           Sp = Sp - 56;
           call _c8KKq() args: 0, res: 0, upd: 0;
     }
 },
 _c8KJI() //  []
         { info_tbl: [(c8KJI,
                       label: block_c8KJI_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KJI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KKU; else goto c8KKT;
       c8KKU: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KJI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KKT: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyE_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KK4() //  []
         { info_tbl: [(c8KK4,
                       label: block_c8KK4_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KK4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KKY; else goto c8KKX;
       c8KKY: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KK4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KKX: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KKq() //  []
         { info_tbl: [(c8KKq,
                       label: block_c8KKq_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KKq: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KL2; else goto c8KL1;
       c8KL2: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KKq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KL1: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.383675572 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_checked_encode_entry() //  [R2, R3]
         { info_tbl: [(c8KLY,
                       label: GHC.IO.Encoding.Latin1.latin1_checked_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KLY: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin1_checked2_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.384424537 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule4_bytes" {
     GHC.IO.Encoding.Latin1.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.385037074 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule3_closure" {
     GHC.IO.Encoding.Latin1.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.385691998 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule2_bytes" {
     GHC.IO.Encoding.Latin1.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,76,97,116,105,110,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.386232543 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule1_closure" {
     GHC.IO.Encoding.Latin1.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.386808195 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule_closure" {
     GHC.IO.Encoding.Latin1.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Latin1.$trModule3_closure+1;
         const GHC.IO.Encoding.Latin1.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.38737608 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.ascii7_bytes" {
     GHC.IO.Encoding.Latin1.ascii7_bytes:
         I8[] [65,83,67,73,73]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.388123639 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii6_closure" {
     GHC.IO.Encoding.Latin1.ascii6_closure:
         const GHC.IO.Encoding.Latin1.ascii6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii6_entry() //  [R1]
         { info_tbl: [(c8KM7,
                       label: GHC.IO.Encoding.Latin1.ascii6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KM7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8KM8; else goto c8KM9;
       c8KM8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KM9: // global
           (_c8KM4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8KM4::I64 == 0) goto c8KM6; else goto c8KM5;
       c8KM6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8KM5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8KM4::I64;
           R2 = GHC.IO.Encoding.Latin1.ascii7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.389149226 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii2_closure" {
     GHC.IO.Encoding.Latin1.mkAscii2_closure:
         const GHC.IO.Encoding.Latin1.mkAscii2_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii2_entry() //  []
         { info_tbl: [(c8KMe,
                       label: GHC.IO.Encoding.Latin1.mkAscii2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KMe: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.390034568 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii1_closure" {
     GHC.IO.Encoding.Latin1.mkAscii1_closure:
         const GHC.IO.Encoding.Latin1.mkAscii1_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii1_entry() //  []
         { info_tbl: [(c8KMl,
                       label: GHC.IO.Encoding.Latin1.mkAscii1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KMl: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.391490197 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii_closure" {
     GHC.IO.Encoding.Latin1.mkAscii_closure:
         const GHC.IO.Encoding.Latin1.mkAscii_info;
         const 0;
 },
 sat_s8Kzq_entry() //  [R1, R2, R3]
         { info_tbl: [(c8KMC,
                       label: sat_s8Kzq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KMC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Kzs_entry() //  [R1]
         { info_tbl: [(c8KMG,
                       label: sat_s8Kzs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KMG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8KMK; else goto c8KMJ;
       c8KMK: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8KMJ: // global
           _s8Kzk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Kzq_info;
           P64[Hp - 48] = _s8Kzk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Kzm_entry() //  [R1, R2, R3]
         { info_tbl: [(c8KMV,
                       label: sat_s8Kzm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KMV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Kzo_entry() //  [R1]
         { info_tbl: [(c8KMZ,
                       label: sat_s8Kzo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KMZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8KN3; else goto c8KN2;
       c8KN3: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8KN2: // global
           _s8Kzk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Kzm_info;
           P64[Hp - 48] = _s8Kzk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkAscii_entry() //  [R2]
         { info_tbl: [(c8KN5,
                       label: GHC.IO.Encoding.Latin1.mkAscii_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KN5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8KN9; else goto c8KN8;
       c8KN9: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkAscii_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8KN8: // global
           I64[Hp - 56] = sat_s8Kzs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Kzo_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.ascii6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.393707308 UTC

[section ""data" . lvl_r8Kux_closure" {
     lvl_r8Kux_closure:
         const lvl_r8Kux_info;
         const 0;
 },
 lvl_r8Kux_entry() //  [R2, R3]
         { info_tbl: [(c8KNi,
                       label: lvl_r8Kux_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KNi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8KNm; else goto c8KNn;
       c8KNm: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8Kux_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KNn: // global
           I64[Sp - 16] = block_c8KNf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KNv; else goto c8KNg;
       u8KNv: // global
           call _c8KNf() args: 0, res: 0, upd: 0;
       c8KNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KNf() //  []
         { info_tbl: [(c8KNf,
                       label: block_c8KNf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KNf: // global
           _s8Kzu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8KNl_info;
           R1 = _s8Kzu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8KNu; else goto c8KNp;
       u8KNu: // global
           call _c8KNl() args: 0, res: 0, upd: 0;
       c8KNp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KNl() //  []
         { info_tbl: [(c8KNl,
                       label: block_c8KNl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KNl: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.394897676 UTC

[section ""data" . lvl1_r8Kuy_closure" {
     lvl1_r8Kuy_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.395623479 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii4_closure" {
     GHC.IO.Encoding.Latin1.ascii4_closure:
         const GHC.IO.Encoding.Latin1.ascii4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii4_entry() //  []
         { info_tbl: [(c8KNA,
                       label: GHC.IO.Encoding.Latin1.ascii4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KNA: // global
           R1 = lvl1_r8Kuy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.396677799 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii2_closure" {
     GHC.IO.Encoding.Latin1.ascii2_closure:
         const GHC.IO.Encoding.Latin1.ascii2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii2_entry() //  [R2, R3]
         { info_tbl: [(c8KNK,
                       label: GHC.IO.Encoding.Latin1.ascii2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KNK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8KNO; else goto c8KNP;
       c8KNO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KNP: // global
           I64[Sp - 16] = block_c8KNH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KNY; else goto c8KNI;
       u8KNY: // global
           call _c8KNH(R1) args: 0, res: 0, upd: 0;
       c8KNI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KNH() //  [R1]
         { info_tbl: [(c8KNH,
                       label: block_c8KNH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KNH: // global
           I64[Sp - 16] = block_c8KNN_info;
           _s8KzQ::P64 = P64[R1 + 7];
           _s8KzP::I64 = I64[R1 + 23];
           _s8KzT::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8KzT::I64;
           P64[Sp] = _s8KzQ::P64;
           I64[Sp + 8] = _s8KzP::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KNX; else goto c8KNR;
       u8KNX: // global
           call _c8KNN() args: 0, res: 0, upd: 0;
       c8KNR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KNN() //  []
         { info_tbl: [(c8KNN,
                       label: block_c8KNN_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KNN: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.398062277 UTC

[section ""data" . lvl2_r8Kuz_closure" {
     lvl2_r8Kuz_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.398763703 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii1_closure" {
     GHC.IO.Encoding.Latin1.ascii1_closure:
         const GHC.IO.Encoding.Latin1.ascii1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii1_entry() //  []
         { info_tbl: [(c8KO3,
                       label: GHC.IO.Encoding.Latin1.ascii1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KO3: // global
           R1 = lvl2_r8Kuz_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.399477451 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_closure" {
     GHC.IO.Encoding.Latin1.ascii_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Latin1.ascii4_closure+1;
         const GHC.IO.Encoding.Latin1.ascii1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.400073267 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.latin7_bytes" {
     GHC.IO.Encoding.Latin1.latin7_bytes:
         I8[] [73,83,79,45,56,56,53,57,45,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.400774521 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin6_closure" {
     GHC.IO.Encoding.Latin1.latin6_closure:
         const GHC.IO.Encoding.Latin1.latin6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin6_entry() //  [R1]
         { info_tbl: [(c8KOc,
                       label: GHC.IO.Encoding.Latin1.latin6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KOc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8KOd; else goto c8KOe;
       c8KOd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KOe: // global
           (_c8KO9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8KO9::I64 == 0) goto c8KOb; else goto c8KOa;
       c8KOb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8KOa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8KO9::I64;
           R2 = GHC.IO.Encoding.Latin1.latin7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.402404377 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_checked_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_checked_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_info;
         const 0;
 },
 sat_s8KAd_entry() //  [R1, R2, R3]
         { info_tbl: [(c8KOt,
                       label: sat_s8KAd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KOt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAf_entry() //  [R1]
         { info_tbl: [(c8KOx,
                       label: sat_s8KAf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KOx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8KOB; else goto c8KOA;
       c8KOB: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8KOA: // global
           _s8KA7::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAd_info;
           P64[Hp - 48] = _s8KA7::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KA9_entry() //  [R1, R2, R3]
         { info_tbl: [(c8KOM,
                       label: sat_s8KA9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KOM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAb_entry() //  [R1]
         { info_tbl: [(c8KOQ,
                       label: sat_s8KAb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KOQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8KOU; else goto c8KOT;
       c8KOU: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8KOT: // global
           _s8KA7::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KA9_info;
           P64[Hp - 48] = _s8KA7::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkLatin1_checked_entry() //  [R2]
         { info_tbl: [(c8KOW,
                       label: GHC.IO.Encoding.Latin1.mkLatin1_checked_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KOW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8KP0; else goto c8KOZ;
       c8KP0: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8KOZ: // global
           I64[Hp - 56] = sat_s8KAf_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8KAb_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.404248701 UTC

[section ""data" . lvl3_r8KuA_closure" {
     lvl3_r8KuA_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.404936087 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin4_closure" {
     GHC.IO.Encoding.Latin1.latin4_closure:
         const GHC.IO.Encoding.Latin1.latin4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin4_entry() //  []
         { info_tbl: [(c8KP5,
                       label: GHC.IO.Encoding.Latin1.latin4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KP5: // global
           R1 = lvl3_r8KuA_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.406019341 UTC

[section ""data" . lvl4_r8KuB_closure" {
     lvl4_r8KuB_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.406724489 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked1_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked1_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin1_checked1_entry() //  []
         { info_tbl: [(c8KPc,
                       label: GHC.IO.Encoding.Latin1.latin1_checked1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KPc: // global
           R1 = lvl4_r8KuB_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.407442047 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin1_checked1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.408733763 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_info;
         const 0;
 },
 sat_s8KAo_entry() //  [R1, R2, R3]
         { info_tbl: [(c8KPt,
                       label: sat_s8KAo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KPt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAq_entry() //  [R1]
         { info_tbl: [(c8KPx,
                       label: sat_s8KAq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KPx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8KPB; else goto c8KPA;
       c8KPB: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8KPA: // global
           _s8KAi::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAo_info;
           P64[Hp - 48] = _s8KAi::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAk_entry() //  [R1, R2, R3]
         { info_tbl: [(c8KPM,
                       label: sat_s8KAk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KPM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAm_entry() //  [R1]
         { info_tbl: [(c8KPQ,
                       label: sat_s8KAm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KPQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8KPU; else goto c8KPT;
       c8KPU: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8KPT: // global
           _s8KAi::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAk_info;
           P64[Hp - 48] = _s8KAi::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkLatin1_entry() //  [R2]
         { info_tbl: [(c8KPW,
                       label: GHC.IO.Encoding.Latin1.mkLatin1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KPW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8KQ0; else goto c8KPZ;
       c8KQ0: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8KPZ: // global
           I64[Hp - 56] = sat_s8KAq_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8KAm_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.410659663 UTC

[section ""data" . lvl5_r8KuC_closure" {
     lvl5_r8KuC_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.411377597 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin2_closure" {
     GHC.IO.Encoding.Latin1.latin2_closure:
         const GHC.IO.Encoding.Latin1.latin2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin2_entry() //  []
         { info_tbl: [(c8KQ5,
                       label: GHC.IO.Encoding.Latin1.latin2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KQ5: // global
           R1 = lvl5_r8KuC_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.412114828 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_closure" {
     GHC.IO.Encoding.Latin1.latin1_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.412688257 UTC

[section ""relreadonly" . S8KNa_srt" {
     S8KNa_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Latin1.mkAscii_closure;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8Kux_closure;
         const lvl1_r8Kuy_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.Latin1.ascii2_closure;
         const lvl2_r8Kuz_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const lvl3_r8KuA_closure;
         const lvl4_r8KuB_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_closure;
         const lvl5_r8KuC_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.413563349 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:54.41593691 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin5_closure" {
     GHC.IO.Encoding.Latin1.latin5_closure:
         const GHC.IO.Encoding.Latin1.latin5_info;
 },
 sat_s8Kv1_entry() //  [R1]
         { info_tbl: [(c8KQC,
                       label: sat_s8Kv1_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KQC: // global
           _s8Kv1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KQD; else goto c8KQE;
       c8KQE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KQG; else goto c8KQF;
       c8KQG: // global
           HpAlloc = 56;
           goto c8KQD;
       c8KQD: // global
           R1 = _s8Kv1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KQF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kv1::P64;
           _s8KuN::I64 = I64[_s8Kv1::P64 + 56];
           _s8KuX::I64 = I64[_s8Kv1::P64 + 64];
           if (_s8KuX::I64 == _s8KuN::I64) goto c8KQB; else goto c8KQA;
       c8KQB: // global
           _s8KuV::P64 = P64[_s8Kv1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KuV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KQA: // global
           _s8KuJ::P64 = P64[_s8Kv1::P64 + 16];
           _s8KuK::P64 = P64[_s8Kv1::P64 + 24];
           _s8KuI::I64 = I64[_s8Kv1::P64 + 40];
           _s8KuL::I64 = I64[_s8Kv1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = _s8KuK::P64;
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = _s8KuL::I64;
           I64[Hp - 8] = _s8KuX::I64;
           I64[Hp] = _s8KuN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Kv9_entry() //  [R1]
         { info_tbl: [(c8KQY,
                       label: sat_s8Kv9_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KQY: // global
           _s8Kv9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KQZ; else goto c8KR0;
       c8KR0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KR2; else goto c8KR1;
       c8KR2: // global
           HpAlloc = 56;
           goto c8KQZ;
       c8KQZ: // global
           R1 = _s8Kv9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KR1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kv9::P64;
           _s8KuN::I64 = I64[_s8Kv9::P64 + 56];
           _s8Kv5::I64 = I64[_s8Kv9::P64 + 64];
           if (_s8Kv5::I64 == _s8KuN::I64) goto c8KQX; else goto c8KQW;
       c8KQX: // global
           _s8KuV::P64 = P64[_s8Kv9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KuV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KQW: // global
           _s8KuJ::P64 = P64[_s8Kv9::P64 + 16];
           _s8KuK::P64 = P64[_s8Kv9::P64 + 24];
           _s8KuI::I64 = I64[_s8Kv9::P64 + 40];
           _s8KuL::I64 = I64[_s8Kv9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = _s8KuK::P64;
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = _s8KuL::I64;
           I64[Hp - 8] = _s8Kv5::I64;
           I64[Hp] = _s8KuN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin5_entry() //  [R2, R3]
         { info_tbl: [(c8KR5,
                       label: GHC.IO.Encoding.Latin1.latin5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KR5: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8KR6; else goto c8KR7;
       c8KR6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KR7: // global
           I64[Sp - 16] = block_c8KQc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KRW; else goto c8KQd;
       u8KRW: // global
           call _c8KQc(R1) args: 0, res: 0, upd: 0;
       c8KQd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KQc() //  [R1]
         { info_tbl: [(c8KQc,
                       label: block_c8KQc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KQc: // global
           I64[Sp - 40] = block_c8KQh_info;
           _s8KuJ::P64 = P64[R1 + 7];
           _s8KuK::P64 = P64[R1 + 15];
           _s8KuI::I64 = I64[R1 + 23];
           _s8KuL::I64 = I64[R1 + 31];
           _s8KuM::I64 = I64[R1 + 39];
           _s8KuN::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8KuK::P64;
           I64[Sp - 24] = _s8KuL::I64;
           I64[Sp - 16] = _s8KuM::I64;
           I64[Sp - 8] = _s8KuN::I64;
           P64[Sp] = _s8KuJ::P64;
           I64[Sp + 8] = _s8KuI::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8KRT; else goto c8KQi;
       u8KRT: // global
           call _c8KQh(R1) args: 0, res: 0, upd: 0;
       c8KQi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KQh() //  [R1]
         { info_tbl: [(c8KQh,
                       label: block_c8KQh_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KQh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KRb; else goto c8KRa;
       c8KRb: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KRa: // global
           _s8KuQ::P64 = P64[R1 + 7];
           _s8KuR::P64 = P64[R1 + 15];
           _s8KuP::I64 = I64[R1 + 23];
           _s8KuS::I64 = I64[R1 + 31];
           _s8KuT::I64 = I64[R1 + 39];
           _s8KuU::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8KuJ::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8KuI::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KuN::I64 = I64[Sp + 32];
           _c8KQm::P64 = Hp - 47;
           _s8Kve::I64 = _s8KuU::I64;
           _s8Kvd::I64 = I64[Sp + 24];
           goto c8KRm;
       c8KRm: // global
           if (%MO_S_Lt_W64(_s8Kve::I64,
                            _s8KuS::I64)) goto c8KRz; else goto c8KRA;
       c8KRz: // global
           if (%MO_S_Lt_W64(_s8Kvd::I64,
                            _s8KuN::I64)) goto c8KRw; else goto c8KRx;
       c8KRw: // global
           _s8Kvl::I64 = %MO_UU_Conv_W8_W64(I8[_s8KuI::I64 + _s8Kvd::I64]);
           call MO_Touch(_s8KuJ::P64);
           I32[_s8KuP::I64 + (_s8Kve::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Kvl::I64);
           call MO_Touch(_s8KuQ::P64);
           _s8Kve::I64 = _s8Kve::I64 + 1;
           _s8Kvd::I64 = _s8Kvd::I64 + 1;
           goto c8KRm;
       c8KRx: // global
           P64[Sp - 48] = _s8KuQ::P64;
           P64[Sp - 40] = _s8KuR::P64;
           I64[Sp - 32] = _s8KuS::I64;
           I64[Sp - 24] = _s8KuT::I64;
           I64[Sp - 16] = _s8Kvd::I64;
           I64[Sp - 8] = _s8Kve::I64;
           I64[Sp] = _s8KuP::I64;
           P64[Sp + 24] = _c8KQm::P64;
           Sp = Sp - 56;
           call _c8KQp() args: 0, res: 0, upd: 0;
       c8KRA: // global
           P64[Sp - 48] = _s8KuQ::P64;
           P64[Sp - 40] = _s8KuR::P64;
           I64[Sp - 32] = _s8KuS::I64;
           I64[Sp - 24] = _s8KuT::I64;
           I64[Sp - 16] = _s8Kvd::I64;
           I64[Sp - 8] = _s8Kve::I64;
           I64[Sp] = _s8KuP::I64;
           P64[Sp + 24] = _c8KQm::P64;
           Sp = Sp - 56;
           call _c8KQL() args: 0, res: 0, upd: 0;
     }
 },
 _c8KQp() //  []
         { info_tbl: [(c8KQp,
                       label: block_c8KQp_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KQp: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KRf; else goto c8KRe;
       c8KRf: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KQp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KRe: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kv1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KQL() //  []
         { info_tbl: [(c8KQL,
                       label: block_c8KQL_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KQL: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KRj; else goto c8KRi;
       c8KRj: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KQL_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KRi: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kv9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.420053344 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_decode_closure" {
     GHC.IO.Encoding.Latin1.latin1_decode_closure:
         const GHC.IO.Encoding.Latin1.latin1_decode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_decode_entry() //  [R2, R3]
         { info_tbl: [(c8KS1,
                       label: GHC.IO.Encoding.Latin1.latin1_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KS1: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.423373006 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii5_closure" {
     GHC.IO.Encoding.Latin1.ascii5_closure:
         const GHC.IO.Encoding.Latin1.ascii5_info;
 },
 sat_s8KvQ_entry() //  [R1]
         { info_tbl: [(c8KSy,
                       label: sat_s8KvQ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KSy: // global
           _s8KvQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KSz; else goto c8KSA;
       c8KSA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KSC; else goto c8KSB;
       c8KSC: // global
           HpAlloc = 56;
           goto c8KSz;
       c8KSz: // global
           R1 = _s8KvQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KSB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KvQ::P64;
           _s8KvC::I64 = I64[_s8KvQ::P64 + 56];
           _s8KvM::I64 = I64[_s8KvQ::P64 + 64];
           if (_s8KvM::I64 == _s8KvC::I64) goto c8KSx; else goto c8KSw;
       c8KSx: // global
           _s8KvK::P64 = P64[_s8KvQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KSw: // global
           _s8Kvy::P64 = P64[_s8KvQ::P64 + 16];
           _s8Kvz::P64 = P64[_s8KvQ::P64 + 24];
           _s8Kvx::I64 = I64[_s8KvQ::P64 + 40];
           _s8KvA::I64 = I64[_s8KvQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8KvM::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KvY_entry() //  [R1]
         { info_tbl: [(c8KSU,
                       label: sat_s8KvY_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KSU: // global
           _s8KvY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KSV; else goto c8KSW;
       c8KSW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KSY; else goto c8KSX;
       c8KSY: // global
           HpAlloc = 56;
           goto c8KSV;
       c8KSV: // global
           R1 = _s8KvY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KSX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KvY::P64;
           _s8KvC::I64 = I64[_s8KvY::P64 + 56];
           _s8KvU::I64 = I64[_s8KvY::P64 + 64];
           if (_s8KvU::I64 == _s8KvC::I64) goto c8KST; else goto c8KSS;
       c8KST: // global
           _s8KvK::P64 = P64[_s8KvY::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KSS: // global
           _s8Kvy::P64 = P64[_s8KvY::P64 + 16];
           _s8Kvz::P64 = P64[_s8KvY::P64 + 24];
           _s8Kvx::I64 = I64[_s8KvY::P64 + 40];
           _s8KvA::I64 = I64[_s8KvY::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8KvU::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Kw6_entry() //  [R1]
         { info_tbl: [(c8KTg,
                       label: sat_s8Kw6_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KTg: // global
           _s8Kw6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KTh; else goto c8KTi;
       c8KTi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KTk; else goto c8KTj;
       c8KTk: // global
           HpAlloc = 56;
           goto c8KTh;
       c8KTh: // global
           R1 = _s8Kw6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KTj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kw6::P64;
           _s8KvC::I64 = I64[_s8Kw6::P64 + 56];
           _s8Kw2::I64 = I64[_s8Kw6::P64 + 64];
           if (_s8Kw2::I64 == _s8KvC::I64) goto c8KTf; else goto c8KTe;
       c8KTf: // global
           _s8KvK::P64 = P64[_s8Kw6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KTe: // global
           _s8Kvy::P64 = P64[_s8Kw6::P64 + 16];
           _s8Kvz::P64 = P64[_s8Kw6::P64 + 24];
           _s8Kvx::I64 = I64[_s8Kw6::P64 + 40];
           _s8KvA::I64 = I64[_s8Kw6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8Kw2::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.ascii5_entry() //  [R2, R3]
         { info_tbl: [(c8KTn,
                       label: GHC.IO.Encoding.Latin1.ascii5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KTn: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8KTo; else goto c8KTp;
       c8KTo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KTp: // global
           I64[Sp - 16] = block_c8KS8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KUq; else goto c8KS9;
       u8KUq: // global
           call _c8KS8(R1) args: 0, res: 0, upd: 0;
       c8KS9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KS8() //  [R1]
         { info_tbl: [(c8KS8,
                       label: block_c8KS8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KS8: // global
           I64[Sp - 40] = block_c8KSd_info;
           _s8Kvy::P64 = P64[R1 + 7];
           _s8Kvz::P64 = P64[R1 + 15];
           _s8Kvx::I64 = I64[R1 + 23];
           _s8KvA::I64 = I64[R1 + 31];
           _s8KvB::I64 = I64[R1 + 39];
           _s8KvC::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kvz::P64;
           I64[Sp - 24] = _s8KvA::I64;
           I64[Sp - 16] = _s8KvB::I64;
           I64[Sp - 8] = _s8KvC::I64;
           P64[Sp] = _s8Kvy::P64;
           I64[Sp + 8] = _s8Kvx::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8KUm; else goto c8KSe;
       u8KUm: // global
           call _c8KSd(R1) args: 0, res: 0, upd: 0;
       c8KSe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KSd() //  [R1]
         { info_tbl: [(c8KSd,
                       label: block_c8KSd_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KSd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KTt; else goto c8KTs;
       c8KTt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KTs: // global
           _s8KvF::P64 = P64[R1 + 7];
           _s8KvG::P64 = P64[R1 + 15];
           _s8KvE::I64 = I64[R1 + 23];
           _s8KvH::I64 = I64[R1 + 31];
           _s8KvI::I64 = I64[R1 + 39];
           _s8KvJ::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kvy::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kvx::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KvC::I64 = I64[Sp + 32];
           _c8KSi::P64 = Hp - 47;
           _s8Kwb::I64 = _s8KvJ::I64;
           _s8Kwa::I64 = I64[Sp + 24];
           goto c8KTI;
       c8KTI: // global
           if (%MO_S_Lt_W64(_s8Kwb::I64,
                            _s8KvH::I64)) goto c8KU5; else goto c8KU6;
       c8KU5: // global
           if (%MO_S_Lt_W64(_s8Kwa::I64,
                            _s8KvC::I64)) goto c8KU2; else goto c8KU3;
       c8KU2: // global
           _s8Kwi::I64 = %MO_UU_Conv_W8_W64(I8[_s8Kvx::I64 + _s8Kwa::I64]);
           call MO_Touch(_s8Kvy::P64);
           if (_s8Kwi::I64 <= 127) goto c8KTZ; else goto c8KU0;
       c8KTZ: // global
           I32[_s8KvE::I64 + (_s8Kwb::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Kwi::I64);
           call MO_Touch(_s8KvF::P64);
           _s8Kwb::I64 = _s8Kwb::I64 + 1;
           _s8Kwa::I64 = _s8Kwa::I64 + 1;
           goto c8KTI;
       c8KU0: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8KSi::P64;
           Sp = Sp - 56;
           call _c8KSl() args: 0, res: 0, upd: 0;
       c8KU3: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8KSi::P64;
           Sp = Sp - 56;
           call _c8KSH() args: 0, res: 0, upd: 0;
       c8KU6: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8KSi::P64;
           Sp = Sp - 56;
           call _c8KT3() args: 0, res: 0, upd: 0;
     }
 },
 _c8KSl() //  []
         { info_tbl: [(c8KSl,
                       label: block_c8KSl_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KSl: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KTx; else goto c8KTw;
       c8KTx: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KSl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KTw: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KvQ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KSH() //  []
         { info_tbl: [(c8KSH,
                       label: block_c8KSH_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KSH: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KTB; else goto c8KTA;
       c8KTB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KSH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KTA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KvY_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KT3() //  []
         { info_tbl: [(c8KT3,
                       label: block_c8KT3_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KT3: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KTF; else goto c8KTE;
       c8KTF: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KT3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KTE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kw6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.428615371 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_decode_closure" {
     GHC.IO.Encoding.Latin1.ascii_decode_closure:
         const GHC.IO.Encoding.Latin1.ascii_decode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_decode_entry() //  [R2, R3]
         { info_tbl: [(c8KUv,
                       label: GHC.IO.Encoding.Latin1.ascii_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KUv: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.431167466 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin3_closure" {
     GHC.IO.Encoding.Latin1.latin3_closure:
         const GHC.IO.Encoding.Latin1.latin3_info;
 },
 sat_s8KwO_entry() //  [R1]
         { info_tbl: [(c8KV2,
                       label: sat_s8KwO_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KV2: // global
           _s8KwO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KV3; else goto c8KV4;
       c8KV4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KV6; else goto c8KV5;
       c8KV6: // global
           HpAlloc = 56;
           goto c8KV3;
       c8KV3: // global
           R1 = _s8KwO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KV5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KwO::P64;
           _s8KwA::I64 = I64[_s8KwO::P64 + 56];
           _s8KwK::I64 = I64[_s8KwO::P64 + 64];
           if (_s8KwK::I64 == _s8KwA::I64) goto c8KV1; else goto c8KV0;
       c8KV1: // global
           _s8KwI::P64 = P64[_s8KwO::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KwI::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KV0: // global
           _s8Kww::P64 = P64[_s8KwO::P64 + 16];
           _s8Kwx::P64 = P64[_s8KwO::P64 + 24];
           _s8Kwv::I64 = I64[_s8KwO::P64 + 40];
           _s8Kwy::I64 = I64[_s8KwO::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = _s8Kwx::P64;
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = _s8Kwy::I64;
           I64[Hp - 8] = _s8KwK::I64;
           I64[Hp] = _s8KwA::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KwW_entry() //  [R1]
         { info_tbl: [(c8KVo,
                       label: sat_s8KwW_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KVo: // global
           _s8KwW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KVp; else goto c8KVq;
       c8KVq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KVs; else goto c8KVr;
       c8KVs: // global
           HpAlloc = 56;
           goto c8KVp;
       c8KVp: // global
           R1 = _s8KwW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KVr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KwW::P64;
           _s8KwA::I64 = I64[_s8KwW::P64 + 56];
           _s8KwS::I64 = I64[_s8KwW::P64 + 64];
           if (_s8KwS::I64 == _s8KwA::I64) goto c8KVn; else goto c8KVm;
       c8KVn: // global
           _s8KwI::P64 = P64[_s8KwW::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KwI::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KVm: // global
           _s8Kww::P64 = P64[_s8KwW::P64 + 16];
           _s8Kwx::P64 = P64[_s8KwW::P64 + 24];
           _s8Kwv::I64 = I64[_s8KwW::P64 + 40];
           _s8Kwy::I64 = I64[_s8KwW::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = _s8Kwx::P64;
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = _s8Kwy::I64;
           I64[Hp - 8] = _s8KwS::I64;
           I64[Hp] = _s8KwA::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin3_entry() //  [R2, R3]
         { info_tbl: [(c8KVv,
                       label: GHC.IO.Encoding.Latin1.latin3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KVv: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8KVw; else goto c8KVx;
       c8KVw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KVx: // global
           I64[Sp - 16] = block_c8KUC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KWp; else goto c8KUD;
       u8KWp: // global
           call _c8KUC(R1) args: 0, res: 0, upd: 0;
       c8KUD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KUC() //  [R1]
         { info_tbl: [(c8KUC,
                       label: block_c8KUC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KUC: // global
           I64[Sp - 40] = block_c8KUH_info;
           _s8Kww::P64 = P64[R1 + 7];
           _s8Kwx::P64 = P64[R1 + 15];
           _s8Kwv::I64 = I64[R1 + 23];
           _s8Kwy::I64 = I64[R1 + 31];
           _s8Kwz::I64 = I64[R1 + 39];
           _s8KwA::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kwx::P64;
           I64[Sp - 24] = _s8Kwy::I64;
           I64[Sp - 16] = _s8Kwz::I64;
           I64[Sp - 8] = _s8KwA::I64;
           P64[Sp] = _s8Kww::P64;
           I64[Sp + 8] = _s8Kwv::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8KWm; else goto c8KUI;
       u8KWm: // global
           call _c8KUH(R1) args: 0, res: 0, upd: 0;
       c8KUI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KUH() //  [R1]
         { info_tbl: [(c8KUH,
                       label: block_c8KUH_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KUH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KVB; else goto c8KVA;
       c8KVB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KVA: // global
           _s8KwD::P64 = P64[R1 + 7];
           _s8KwE::P64 = P64[R1 + 15];
           _s8KwC::I64 = I64[R1 + 23];
           _s8KwF::I64 = I64[R1 + 31];
           _s8KwG::I64 = I64[R1 + 39];
           _s8KwH::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kww::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kwv::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KwA::I64 = I64[Sp + 32];
           _c8KUM::P64 = Hp - 47;
           _s8Kx1::I64 = _s8KwH::I64;
           _s8Kx0::I64 = I64[Sp + 24];
           goto c8KVM;
       c8KVM: // global
           if (%MO_S_Lt_W64(_s8Kx1::I64,
                            _s8KwF::I64)) goto c8KVZ; else goto c8KW0;
       c8KVZ: // global
           if (%MO_S_Lt_W64(_s8Kx0::I64,
                            _s8KwA::I64)) goto c8KVW; else goto c8KVX;
       c8KVW: // global
           _s8Kx7::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kwv::I64 + (_s8Kx0::I64 << 2)]);
           call MO_Touch(_s8Kww::P64);
           I8[_s8KwC::I64 + _s8Kx1::I64] = %MO_UU_Conv_W64_W8(_s8Kx7::I64);
           call MO_Touch(_s8KwD::P64);
           _s8Kx1::I64 = _s8Kx1::I64 + 1;
           _s8Kx0::I64 = _s8Kx0::I64 + 1;
           goto c8KVM;
       c8KVX: // global
           P64[Sp - 48] = _s8KwD::P64;
           P64[Sp - 40] = _s8KwE::P64;
           I64[Sp - 32] = _s8KwF::I64;
           I64[Sp - 24] = _s8KwG::I64;
           I64[Sp - 16] = _s8Kx0::I64;
           I64[Sp - 8] = _s8Kx1::I64;
           I64[Sp] = _s8KwC::I64;
           P64[Sp + 24] = _c8KUM::P64;
           Sp = Sp - 56;
           call _c8KUP() args: 0, res: 0, upd: 0;
       c8KW0: // global
           P64[Sp - 48] = _s8KwD::P64;
           P64[Sp - 40] = _s8KwE::P64;
           I64[Sp - 32] = _s8KwF::I64;
           I64[Sp - 24] = _s8KwG::I64;
           I64[Sp - 16] = _s8Kx0::I64;
           I64[Sp - 8] = _s8Kx1::I64;
           I64[Sp] = _s8KwC::I64;
           P64[Sp + 24] = _c8KUM::P64;
           Sp = Sp - 56;
           call _c8KVb() args: 0, res: 0, upd: 0;
     }
 },
 _c8KUP() //  []
         { info_tbl: [(c8KUP,
                       label: block_c8KUP_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KUP: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KVF; else goto c8KVE;
       c8KVF: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KUP_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KVE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KwO_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KVb() //  []
         { info_tbl: [(c8KVb,
                       label: block_c8KVb_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KVb: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KVJ; else goto c8KVI;
       c8KVJ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KVb_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KVI: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KwW_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.43535259 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_encode_entry() //  [R2, R3]
         { info_tbl: [(c8KWu,
                       label: GHC.IO.Encoding.Latin1.latin1_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KWu: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.438447116 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii3_closure" {
     GHC.IO.Encoding.Latin1.ascii3_closure:
         const GHC.IO.Encoding.Latin1.ascii3_info;
 },
 sat_s8KxE_entry() //  [R1]
         { info_tbl: [(c8KX1,
                       label: sat_s8KxE_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KX1: // global
           _s8KxE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KX2; else goto c8KX3;
       c8KX3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KX5; else goto c8KX4;
       c8KX5: // global
           HpAlloc = 56;
           goto c8KX2;
       c8KX2: // global
           R1 = _s8KxE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KX4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxE::P64;
           _s8Kxq::I64 = I64[_s8KxE::P64 + 56];
           _s8KxA::I64 = I64[_s8KxE::P64 + 64];
           if (_s8KxA::I64 == _s8Kxq::I64) goto c8KX0; else goto c8KWZ;
       c8KX0: // global
           _s8Kxy::P64 = P64[_s8KxE::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KWZ: // global
           _s8Kxm::P64 = P64[_s8KxE::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxE::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxE::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxE::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxA::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KxM_entry() //  [R1]
         { info_tbl: [(c8KXn,
                       label: sat_s8KxM_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KXn: // global
           _s8KxM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KXo; else goto c8KXp;
       c8KXp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KXr; else goto c8KXq;
       c8KXr: // global
           HpAlloc = 56;
           goto c8KXo;
       c8KXo: // global
           R1 = _s8KxM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KXq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxM::P64;
           _s8Kxq::I64 = I64[_s8KxM::P64 + 56];
           _s8KxI::I64 = I64[_s8KxM::P64 + 64];
           if (_s8KxI::I64 == _s8Kxq::I64) goto c8KXm; else goto c8KXl;
       c8KXm: // global
           _s8Kxy::P64 = P64[_s8KxM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KXl: // global
           _s8Kxm::P64 = P64[_s8KxM::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxM::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxM::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxI::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KxU_entry() //  [R1]
         { info_tbl: [(c8KXJ,
                       label: sat_s8KxU_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KXJ: // global
           _s8KxU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KXK; else goto c8KXL;
       c8KXL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KXN; else goto c8KXM;
       c8KXN: // global
           HpAlloc = 56;
           goto c8KXK;
       c8KXK: // global
           R1 = _s8KxU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KXM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxU::P64;
           _s8Kxq::I64 = I64[_s8KxU::P64 + 56];
           _s8KxQ::I64 = I64[_s8KxU::P64 + 64];
           if (_s8KxQ::I64 == _s8Kxq::I64) goto c8KXI; else goto c8KXH;
       c8KXI: // global
           _s8Kxy::P64 = P64[_s8KxU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KXH: // global
           _s8Kxm::P64 = P64[_s8KxU::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxU::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxU::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxQ::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.ascii3_entry() //  [R2, R3]
         { info_tbl: [(c8KXQ,
                       label: GHC.IO.Encoding.Latin1.ascii3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KXQ: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8KXR; else goto c8KXS;
       c8KXR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KXS: // global
           I64[Sp - 16] = block_c8KWB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KYZ; else goto c8KWC;
       u8KYZ: // global
           call _c8KWB(R1) args: 0, res: 0, upd: 0;
       c8KWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KWB() //  [R1]
         { info_tbl: [(c8KWB,
                       label: block_c8KWB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KWB: // global
           I64[Sp - 40] = block_c8KWG_info;
           _s8Kxm::P64 = P64[R1 + 7];
           _s8Kxn::P64 = P64[R1 + 15];
           _s8Kxl::I64 = I64[R1 + 23];
           _s8Kxo::I64 = I64[R1 + 31];
           _s8Kxp::I64 = I64[R1 + 39];
           _s8Kxq::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kxn::P64;
           I64[Sp - 24] = _s8Kxo::I64;
           I64[Sp - 16] = _s8Kxp::I64;
           I64[Sp - 8] = _s8Kxq::I64;
           P64[Sp] = _s8Kxm::P64;
           I64[Sp + 8] = _s8Kxl::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8KYV; else goto c8KWH;
       u8KYV: // global
           call _c8KWG(R1) args: 0, res: 0, upd: 0;
       c8KWH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KWG() //  [R1]
         { info_tbl: [(c8KWG,
                       label: block_c8KWG_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KWG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KXW; else goto c8KXV;
       c8KXW: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KXV: // global
           _s8Kxt::P64 = P64[R1 + 7];
           _s8Kxu::P64 = P64[R1 + 15];
           _s8Kxs::I64 = I64[R1 + 23];
           _s8Kxv::I64 = I64[R1 + 31];
           _s8Kxw::I64 = I64[R1 + 39];
           _s8Kxx::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kxm::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kxl::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Kxq::I64 = I64[Sp + 32];
           _c8KWL::P64 = Hp - 47;
           _s8KxZ::I64 = _s8Kxx::I64;
           _s8KxY::I64 = I64[Sp + 24];
           goto c8KYb;
       c8KYb: // global
           if (%MO_S_Lt_W64(_s8KxZ::I64,
                            _s8Kxv::I64)) goto c8KYy; else goto c8KYz;
       c8KYy: // global
           if (%MO_S_Lt_W64(_s8KxY::I64,
                            _s8Kxq::I64)) goto c8KYv; else goto c8KYw;
       c8KYv: // global
           _s8Ky5::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kxl::I64 + (_s8KxY::I64 << 2)]);
           call MO_Touch(_s8Kxm::P64);
           if (%MO_S_Le_W64(_s8Ky5::I64, 127)) goto c8KYs; else goto c8KYt;
       c8KYs: // global
           I8[_s8Kxs::I64 + _s8KxZ::I64] = %MO_UU_Conv_W64_W8(_s8Ky5::I64);
           call MO_Touch(_s8Kxt::P64);
           _s8KxZ::I64 = _s8KxZ::I64 + 1;
           _s8KxY::I64 = _s8KxY::I64 + 1;
           goto c8KYb;
       c8KYt: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8KWL::P64;
           Sp = Sp - 56;
           call _c8KWO() args: 0, res: 0, upd: 0;
       c8KYw: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8KWL::P64;
           Sp = Sp - 56;
           call _c8KXa() args: 0, res: 0, upd: 0;
       c8KYz: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8KWL::P64;
           Sp = Sp - 56;
           call _c8KXw() args: 0, res: 0, upd: 0;
     }
 },
 _c8KWO() //  []
         { info_tbl: [(c8KWO,
                       label: block_c8KWO_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KWO: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KY0; else goto c8KXZ;
       c8KY0: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KWO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KXZ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxE_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KXa() //  []
         { info_tbl: [(c8KXa,
                       label: block_c8KXa_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KXa: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KY4; else goto c8KY3;
       c8KY4: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KXa_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KY3: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KXw() //  []
         { info_tbl: [(c8KXw,
                       label: block_c8KXw_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KXw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8KY8; else goto c8KY7;
       c8KY8: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KXw_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8KY7: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.443884154 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_encode_closure" {
     GHC.IO.Encoding.Latin1.ascii_encode_closure:
         const GHC.IO.Encoding.Latin1.ascii_encode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_encode_entry() //  [R2, R3]
         { info_tbl: [(c8KZ4,
                       label: GHC.IO.Encoding.Latin1.ascii_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KZ4: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.449677909 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked2_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked2_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked2_info;
 },
 sat_s8KyE_entry() //  [R1]
         { info_tbl: [(c8KZB,
                       label: sat_s8KyE_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KZB: // global
           _s8KyE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KZC; else goto c8KZD;
       c8KZD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8KZF; else goto c8KZE;
       c8KZF: // global
           HpAlloc = 56;
           goto c8KZC;
       c8KZC: // global
           R1 = _s8KyE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8KZE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyE::P64;
           _s8Kyq::I64 = I64[_s8KyE::P64 + 56];
           _s8KyA::I64 = I64[_s8KyE::P64 + 64];
           if (_s8KyA::I64 == _s8Kyq::I64) goto c8KZA; else goto c8KZz;
       c8KZA: // global
           _s8Kyy::P64 = P64[_s8KyE::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KZz: // global
           _s8Kym::P64 = P64[_s8KyE::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyE::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyE::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyE::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyA::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KyM_entry() //  [R1]
         { info_tbl: [(c8KZX,
                       label: sat_s8KyM_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KZX: // global
           _s8KyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8KZY; else goto c8KZZ;
       c8KZZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L01; else goto c8L00;
       c8L01: // global
           HpAlloc = 56;
           goto c8KZY;
       c8KZY: // global
           R1 = _s8KyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L00: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyM::P64;
           _s8Kyq::I64 = I64[_s8KyM::P64 + 56];
           _s8KyI::I64 = I64[_s8KyM::P64 + 64];
           if (_s8KyI::I64 == _s8Kyq::I64) goto c8KZW; else goto c8KZV;
       c8KZW: // global
           _s8Kyy::P64 = P64[_s8KyM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8KZV: // global
           _s8Kym::P64 = P64[_s8KyM::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyM::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyM::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyI::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KyU_entry() //  [R1]
         { info_tbl: [(c8L0j,
                       label: sat_s8KyU_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L0j: // global
           _s8KyU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8L0k; else goto c8L0l;
       c8L0l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L0n; else goto c8L0m;
       c8L0n: // global
           HpAlloc = 56;
           goto c8L0k;
       c8L0k: // global
           R1 = _s8KyU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L0m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyU::P64;
           _s8Kyq::I64 = I64[_s8KyU::P64 + 56];
           _s8KyQ::I64 = I64[_s8KyU::P64 + 64];
           if (_s8KyQ::I64 == _s8Kyq::I64) goto c8L0i; else goto c8L0h;
       c8L0i: // global
           _s8Kyy::P64 = P64[_s8KyU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8L0h: // global
           _s8Kym::P64 = P64[_s8KyU::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyU::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyU::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyQ::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin1_checked2_entry() //  [R2, R3]
         { info_tbl: [(c8L0q,
                       label: GHC.IO.Encoding.Latin1.latin1_checked2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L0q: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8L0r; else goto c8L0s;
       c8L0r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin1_checked2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8L0s: // global
           I64[Sp - 16] = block_c8KZb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8L1z; else goto c8KZc;
       u8L1z: // global
           call _c8KZb(R1) args: 0, res: 0, upd: 0;
       c8KZc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KZb() //  [R1]
         { info_tbl: [(c8KZb,
                       label: block_c8KZb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KZb: // global
           I64[Sp - 40] = block_c8KZg_info;
           _s8Kym::P64 = P64[R1 + 7];
           _s8Kyn::P64 = P64[R1 + 15];
           _s8Kyl::I64 = I64[R1 + 23];
           _s8Kyo::I64 = I64[R1 + 31];
           _s8Kyp::I64 = I64[R1 + 39];
           _s8Kyq::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kyn::P64;
           I64[Sp - 24] = _s8Kyo::I64;
           I64[Sp - 16] = _s8Kyp::I64;
           I64[Sp - 8] = _s8Kyq::I64;
           P64[Sp] = _s8Kym::P64;
           I64[Sp + 8] = _s8Kyl::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8L1v; else goto c8KZh;
       u8L1v: // global
           call _c8KZg(R1) args: 0, res: 0, upd: 0;
       c8KZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KZg() //  [R1]
         { info_tbl: [(c8KZg,
                       label: block_c8KZg_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KZg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L0w; else goto c8L0v;
       c8L0w: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8L0v: // global
           _s8Kyt::P64 = P64[R1 + 7];
           _s8Kyu::P64 = P64[R1 + 15];
           _s8Kys::I64 = I64[R1 + 23];
           _s8Kyv::I64 = I64[R1 + 31];
           _s8Kyw::I64 = I64[R1 + 39];
           _s8Kyx::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kym::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kyl::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Kyq::I64 = I64[Sp + 32];
           _c8KZl::P64 = Hp - 47;
           _s8KyZ::I64 = _s8Kyx::I64;
           _s8KyY::I64 = I64[Sp + 24];
           goto c8L0L;
       c8L0L: // global
           if (%MO_S_Lt_W64(_s8KyZ::I64,
                            _s8Kyv::I64)) goto c8L18; else goto c8L19;
       c8L18: // global
           if (%MO_S_Lt_W64(_s8KyY::I64,
                            _s8Kyq::I64)) goto c8L15; else goto c8L16;
       c8L15: // global
           _s8Kz5::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kyl::I64 + (_s8KyY::I64 << 2)]);
           call MO_Touch(_s8Kym::P64);
           if (%MO_S_Le_W64(_s8Kz5::I64, 255)) goto c8L12; else goto c8L13;
       c8L12: // global
           I8[_s8Kys::I64 + _s8KyZ::I64] = %MO_UU_Conv_W64_W8(_s8Kz5::I64);
           call MO_Touch(_s8Kyt::P64);
           _s8KyZ::I64 = _s8KyZ::I64 + 1;
           _s8KyY::I64 = _s8KyY::I64 + 1;
           goto c8L0L;
       c8L13: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8KZl::P64;
           Sp = Sp - 56;
           call _c8KZo() args: 0, res: 0, upd: 0;
       c8L16: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8KZl::P64;
           Sp = Sp - 56;
           call _c8KZK() args: 0, res: 0, upd: 0;
       c8L19: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8KZl::P64;
           Sp = Sp - 56;
           call _c8L06() args: 0, res: 0, upd: 0;
     }
 },
 _c8KZo() //  []
         { info_tbl: [(c8KZo,
                       label: block_c8KZo_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KZo: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8L0A; else goto c8L0z;
       c8L0A: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KZo_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8L0z: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyE_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8KZK() //  []
         { info_tbl: [(c8KZK,
                       label: block_c8KZK_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KZK: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8L0E; else goto c8L0D;
       c8L0E: // global
           HpAlloc = 160;
           I64[Sp] = block_c8KZK_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8L0D: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8L06() //  []
         { info_tbl: [(c8L06,
                       label: block_c8L06_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L06: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8L0I; else goto c8L0H;
       c8L0I: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L06_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8L0H: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.454786076 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_checked_encode_entry() //  [R2, R3]
         { info_tbl: [(c8L1E,
                       label: GHC.IO.Encoding.Latin1.latin1_checked_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L1E: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin1_checked2_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.455478069 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule4_bytes" {
     GHC.IO.Encoding.Latin1.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.456029193 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule3_closure" {
     GHC.IO.Encoding.Latin1.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.456611581 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule2_bytes" {
     GHC.IO.Encoding.Latin1.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,76,97,116,105,110,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.457168587 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule1_closure" {
     GHC.IO.Encoding.Latin1.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.457812564 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule_closure" {
     GHC.IO.Encoding.Latin1.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Latin1.$trModule3_closure+1;
         const GHC.IO.Encoding.Latin1.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.458332194 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.ascii7_bytes" {
     GHC.IO.Encoding.Latin1.ascii7_bytes:
         I8[] [65,83,67,73,73]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.459038884 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii6_closure" {
     GHC.IO.Encoding.Latin1.ascii6_closure:
         const GHC.IO.Encoding.Latin1.ascii6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii6_entry() //  [R1]
         { info_tbl: [(c8L1N,
                       label: GHC.IO.Encoding.Latin1.ascii6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L1N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8L1O; else goto c8L1P;
       c8L1O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L1P: // global
           (_c8L1K::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8L1K::I64 == 0) goto c8L1M; else goto c8L1L;
       c8L1M: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8L1L: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8L1K::I64;
           R2 = GHC.IO.Encoding.Latin1.ascii7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.460023782 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii2_closure" {
     GHC.IO.Encoding.Latin1.mkAscii2_closure:
         const GHC.IO.Encoding.Latin1.mkAscii2_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii2_entry() //  []
         { info_tbl: [(c8L1U,
                       label: GHC.IO.Encoding.Latin1.mkAscii2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L1U: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.460838241 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii1_closure" {
     GHC.IO.Encoding.Latin1.mkAscii1_closure:
         const GHC.IO.Encoding.Latin1.mkAscii1_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii1_entry() //  []
         { info_tbl: [(c8L21,
                       label: GHC.IO.Encoding.Latin1.mkAscii1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L21: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.462304982 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii_closure" {
     GHC.IO.Encoding.Latin1.mkAscii_closure:
         const GHC.IO.Encoding.Latin1.mkAscii_info;
         const 0;
 },
 sat_s8Kzq_entry() //  [R1, R2, R3]
         { info_tbl: [(c8L2i,
                       label: sat_s8Kzq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L2i: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Kzs_entry() //  [R1]
         { info_tbl: [(c8L2m,
                       label: sat_s8Kzs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L2m: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8L2q; else goto c8L2p;
       c8L2q: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8L2p: // global
           _s8Kzk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Kzq_info;
           P64[Hp - 48] = _s8Kzk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Kzm_entry() //  [R1, R2, R3]
         { info_tbl: [(c8L2B,
                       label: sat_s8Kzm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L2B: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Kzo_entry() //  [R1]
         { info_tbl: [(c8L2F,
                       label: sat_s8Kzo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L2F: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8L2J; else goto c8L2I;
       c8L2J: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8L2I: // global
           _s8Kzk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Kzm_info;
           P64[Hp - 48] = _s8Kzk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkAscii_entry() //  [R2]
         { info_tbl: [(c8L2L,
                       label: GHC.IO.Encoding.Latin1.mkAscii_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L2L: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8L2P; else goto c8L2O;
       c8L2P: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkAscii_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8L2O: // global
           I64[Hp - 56] = sat_s8Kzs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Kzo_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.ascii6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.464433389 UTC

[section ""data" . lvl_r8Kux_closure" {
     lvl_r8Kux_closure:
         const lvl_r8Kux_info;
         const 0;
 },
 lvl_r8Kux_entry() //  [R2, R3]
         { info_tbl: [(c8L2X,
                       label: lvl_r8Kux_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L2X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8L31; else goto c8L32;
       c8L31: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8Kux_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8L32: // global
           I64[Sp - 16] = block_c8L2U_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8L3a; else goto c8L2V;
       u8L3a: // global
           call _c8L2U() args: 0, res: 0, upd: 0;
       c8L2V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8L2U() //  []
         { info_tbl: [(c8L2U,
                       label: block_c8L2U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L2U: // global
           _s8Kzu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8L30_info;
           R1 = _s8Kzu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8L39; else goto c8L34;
       u8L39: // global
           call _c8L30() args: 0, res: 0, upd: 0;
       c8L34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8L30() //  []
         { info_tbl: [(c8L30,
                       label: block_c8L30_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L30: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.465764454 UTC

[section ""data" . lvl1_r8Kuy_closure" {
     lvl1_r8Kuy_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.466409757 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii4_closure" {
     GHC.IO.Encoding.Latin1.ascii4_closure:
         const GHC.IO.Encoding.Latin1.ascii4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii4_entry() //  []
         { info_tbl: [(c8L3f,
                       label: GHC.IO.Encoding.Latin1.ascii4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L3f: // global
           R1 = lvl1_r8Kuy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.467470482 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii2_closure" {
     GHC.IO.Encoding.Latin1.ascii2_closure:
         const GHC.IO.Encoding.Latin1.ascii2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii2_entry() //  [R2, R3]
         { info_tbl: [(c8L3p,
                       label: GHC.IO.Encoding.Latin1.ascii2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L3p: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8L3t; else goto c8L3u;
       c8L3t: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8L3u: // global
           I64[Sp - 16] = block_c8L3m_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8L3D; else goto c8L3n;
       u8L3D: // global
           call _c8L3m(R1) args: 0, res: 0, upd: 0;
       c8L3n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8L3m() //  [R1]
         { info_tbl: [(c8L3m,
                       label: block_c8L3m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L3m: // global
           I64[Sp - 16] = block_c8L3s_info;
           _s8KzQ::P64 = P64[R1 + 7];
           _s8KzP::I64 = I64[R1 + 23];
           _s8KzT::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8KzT::I64;
           P64[Sp] = _s8KzQ::P64;
           I64[Sp + 8] = _s8KzP::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8L3C; else goto c8L3w;
       u8L3C: // global
           call _c8L3s() args: 0, res: 0, upd: 0;
       c8L3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8L3s() //  []
         { info_tbl: [(c8L3s,
                       label: block_c8L3s_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L3s: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.468738065 UTC

[section ""data" . lvl2_r8Kuz_closure" {
     lvl2_r8Kuz_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.469476926 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii1_closure" {
     GHC.IO.Encoding.Latin1.ascii1_closure:
         const GHC.IO.Encoding.Latin1.ascii1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii1_entry() //  []
         { info_tbl: [(c8L3I,
                       label: GHC.IO.Encoding.Latin1.ascii1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L3I: // global
           R1 = lvl2_r8Kuz_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.470206832 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_closure" {
     GHC.IO.Encoding.Latin1.ascii_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Latin1.ascii4_closure+1;
         const GHC.IO.Encoding.Latin1.ascii1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.470789683 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.latin7_bytes" {
     GHC.IO.Encoding.Latin1.latin7_bytes:
         I8[] [73,83,79,45,56,56,53,57,45,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.471509186 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin6_closure" {
     GHC.IO.Encoding.Latin1.latin6_closure:
         const GHC.IO.Encoding.Latin1.latin6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin6_entry() //  [R1]
         { info_tbl: [(c8L3R,
                       label: GHC.IO.Encoding.Latin1.latin6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L3R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8L3S; else goto c8L3T;
       c8L3S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L3T: // global
           (_c8L3O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8L3O::I64 == 0) goto c8L3Q; else goto c8L3P;
       c8L3Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8L3P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8L3O::I64;
           R2 = GHC.IO.Encoding.Latin1.latin7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.473145074 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_checked_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_checked_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_info;
         const 0;
 },
 sat_s8KAd_entry() //  [R1, R2, R3]
         { info_tbl: [(c8L48,
                       label: sat_s8KAd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L48: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAf_entry() //  [R1]
         { info_tbl: [(c8L4c,
                       label: sat_s8KAf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L4c: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8L4g; else goto c8L4f;
       c8L4g: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8L4f: // global
           _s8KA7::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAd_info;
           P64[Hp - 48] = _s8KA7::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KA9_entry() //  [R1, R2, R3]
         { info_tbl: [(c8L4r,
                       label: sat_s8KA9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L4r: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAb_entry() //  [R1]
         { info_tbl: [(c8L4v,
                       label: sat_s8KAb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L4v: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8L4z; else goto c8L4y;
       c8L4z: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8L4y: // global
           _s8KA7::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KA9_info;
           P64[Hp - 48] = _s8KA7::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkLatin1_checked_entry() //  [R2]
         { info_tbl: [(c8L4B,
                       label: GHC.IO.Encoding.Latin1.mkLatin1_checked_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L4B: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8L4F; else goto c8L4E;
       c8L4F: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8L4E: // global
           I64[Hp - 56] = sat_s8KAf_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8KAb_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.475012329 UTC

[section ""data" . lvl3_r8KuA_closure" {
     lvl3_r8KuA_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.475715738 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin4_closure" {
     GHC.IO.Encoding.Latin1.latin4_closure:
         const GHC.IO.Encoding.Latin1.latin4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin4_entry() //  []
         { info_tbl: [(c8L4K,
                       label: GHC.IO.Encoding.Latin1.latin4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L4K: // global
           R1 = lvl3_r8KuA_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.476433577 UTC

[section ""data" . lvl4_r8KuB_closure" {
     lvl4_r8KuB_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.477129414 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked1_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked1_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin1_checked1_entry() //  []
         { info_tbl: [(c8L4R,
                       label: GHC.IO.Encoding.Latin1.latin1_checked1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L4R: // global
           R1 = lvl4_r8KuB_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.477854041 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin1_checked1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.479180401 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_info;
         const 0;
 },
 sat_s8KAo_entry() //  [R1, R2, R3]
         { info_tbl: [(c8L58,
                       label: sat_s8KAo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L58: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAq_entry() //  [R1]
         { info_tbl: [(c8L5c,
                       label: sat_s8KAq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L5c: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8L5g; else goto c8L5f;
       c8L5g: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8L5f: // global
           _s8KAi::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAo_info;
           P64[Hp - 48] = _s8KAi::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAk_entry() //  [R1, R2, R3]
         { info_tbl: [(c8L5r,
                       label: sat_s8KAk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L5r: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAm_entry() //  [R1]
         { info_tbl: [(c8L5v,
                       label: sat_s8KAm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L5v: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8L5z; else goto c8L5y;
       c8L5z: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8L5y: // global
           _s8KAi::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAk_info;
           P64[Hp - 48] = _s8KAi::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkLatin1_entry() //  [R2]
         { info_tbl: [(c8L5B,
                       label: GHC.IO.Encoding.Latin1.mkLatin1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L5B: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8L5F; else goto c8L5E;
       c8L5F: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8L5E: // global
           I64[Hp - 56] = sat_s8KAq_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8KAm_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.481047939 UTC

[section ""data" . lvl5_r8KuC_closure" {
     lvl5_r8KuC_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.481955712 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin2_closure" {
     GHC.IO.Encoding.Latin1.latin2_closure:
         const GHC.IO.Encoding.Latin1.latin2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin2_entry() //  []
         { info_tbl: [(c8L5K,
                       label: GHC.IO.Encoding.Latin1.latin2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L5K: // global
           R1 = lvl5_r8KuC_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.482646665 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_closure" {
     GHC.IO.Encoding.Latin1.latin1_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.483211584 UTC

[section ""relreadonly" . S8KNa_srt" {
     S8KNa_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Latin1.mkAscii_closure;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8Kux_closure;
         const lvl1_r8Kuy_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.Latin1.ascii2_closure;
         const lvl2_r8Kuz_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const lvl3_r8KuA_closure;
         const lvl4_r8KuB_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_closure;
         const lvl5_r8KuC_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.484063964 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:54.487092594 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin5_closure" {
     GHC.IO.Encoding.Latin1.latin5_closure:
         const GHC.IO.Encoding.Latin1.latin5_info;
 },
 sat_s8Kv1_entry() //  [R1]
         { info_tbl: [(c8L6h,
                       label: sat_s8Kv1_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L6h: // global
           _s8Kv1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8L6i; else goto c8L6j;
       c8L6j: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L6l; else goto c8L6k;
       c8L6l: // global
           HpAlloc = 56;
           goto c8L6i;
       c8L6i: // global
           R1 = _s8Kv1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L6k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kv1::P64;
           _s8KuN::I64 = I64[_s8Kv1::P64 + 56];
           _s8KuX::I64 = I64[_s8Kv1::P64 + 64];
           if (_s8KuX::I64 == _s8KuN::I64) goto c8L6g; else goto c8L6f;
       c8L6g: // global
           _s8KuV::P64 = P64[_s8Kv1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KuV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8L6f: // global
           _s8KuJ::P64 = P64[_s8Kv1::P64 + 16];
           _s8KuK::P64 = P64[_s8Kv1::P64 + 24];
           _s8KuI::I64 = I64[_s8Kv1::P64 + 40];
           _s8KuL::I64 = I64[_s8Kv1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = _s8KuK::P64;
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = _s8KuL::I64;
           I64[Hp - 8] = _s8KuX::I64;
           I64[Hp] = _s8KuN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Kv9_entry() //  [R1]
         { info_tbl: [(c8L6D,
                       label: sat_s8Kv9_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L6D: // global
           _s8Kv9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8L6E; else goto c8L6F;
       c8L6F: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L6H; else goto c8L6G;
       c8L6H: // global
           HpAlloc = 56;
           goto c8L6E;
       c8L6E: // global
           R1 = _s8Kv9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L6G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kv9::P64;
           _s8KuN::I64 = I64[_s8Kv9::P64 + 56];
           _s8Kv5::I64 = I64[_s8Kv9::P64 + 64];
           if (_s8Kv5::I64 == _s8KuN::I64) goto c8L6C; else goto c8L6B;
       c8L6C: // global
           _s8KuV::P64 = P64[_s8Kv9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KuV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8L6B: // global
           _s8KuJ::P64 = P64[_s8Kv9::P64 + 16];
           _s8KuK::P64 = P64[_s8Kv9::P64 + 24];
           _s8KuI::I64 = I64[_s8Kv9::P64 + 40];
           _s8KuL::I64 = I64[_s8Kv9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = _s8KuK::P64;
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = _s8KuL::I64;
           I64[Hp - 8] = _s8Kv5::I64;
           I64[Hp] = _s8KuN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin5_entry() //  [R2, R3]
         { info_tbl: [(c8L6K,
                       label: GHC.IO.Encoding.Latin1.latin5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L6K: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8L6L; else goto c8L6M;
       c8L6L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8L6M: // global
           I64[Sp - 16] = block_c8L5R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8L7B; else goto c8L5S;
       u8L7B: // global
           call _c8L5R(R1) args: 0, res: 0, upd: 0;
       c8L5S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8L5R() //  [R1]
         { info_tbl: [(c8L5R,
                       label: block_c8L5R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L5R: // global
           I64[Sp - 40] = block_c8L5W_info;
           _s8KuJ::P64 = P64[R1 + 7];
           _s8KuK::P64 = P64[R1 + 15];
           _s8KuI::I64 = I64[R1 + 23];
           _s8KuL::I64 = I64[R1 + 31];
           _s8KuM::I64 = I64[R1 + 39];
           _s8KuN::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8KuK::P64;
           I64[Sp - 24] = _s8KuL::I64;
           I64[Sp - 16] = _s8KuM::I64;
           I64[Sp - 8] = _s8KuN::I64;
           P64[Sp] = _s8KuJ::P64;
           I64[Sp + 8] = _s8KuI::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8L7y; else goto c8L5X;
       u8L7y: // global
           call _c8L5W(R1) args: 0, res: 0, upd: 0;
       c8L5X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8L5W() //  [R1]
         { info_tbl: [(c8L5W,
                       label: block_c8L5W_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L5W: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L6Q; else goto c8L6P;
       c8L6Q: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8L6P: // global
           _s8KuQ::P64 = P64[R1 + 7];
           _s8KuR::P64 = P64[R1 + 15];
           _s8KuP::I64 = I64[R1 + 23];
           _s8KuS::I64 = I64[R1 + 31];
           _s8KuT::I64 = I64[R1 + 39];
           _s8KuU::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8KuJ::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8KuJ::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8KuI::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8KuI::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KuN::I64 = I64[Sp + 32];
           _c8L61::P64 = Hp - 47;
           _s8Kve::I64 = _s8KuU::I64;
           _s8Kvd::I64 = I64[Sp + 24];
           goto c8L71;
       c8L71: // global
           if (%MO_S_Lt_W64(_s8Kve::I64,
                            _s8KuS::I64)) goto c8L7e; else goto c8L7f;
       c8L7e: // global
           if (%MO_S_Lt_W64(_s8Kvd::I64,
                            _s8KuN::I64)) goto c8L7b; else goto c8L7c;
       c8L7b: // global
           _s8Kvl::I64 = %MO_UU_Conv_W8_W64(I8[_s8KuI::I64 + _s8Kvd::I64]);
           call MO_Touch(_s8KuJ::P64);
           I32[_s8KuP::I64 + (_s8Kve::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Kvl::I64);
           call MO_Touch(_s8KuQ::P64);
           _s8Kve::I64 = _s8Kve::I64 + 1;
           _s8Kvd::I64 = _s8Kvd::I64 + 1;
           goto c8L71;
       c8L7c: // global
           P64[Sp - 48] = _s8KuQ::P64;
           P64[Sp - 40] = _s8KuR::P64;
           I64[Sp - 32] = _s8KuS::I64;
           I64[Sp - 24] = _s8KuT::I64;
           I64[Sp - 16] = _s8Kvd::I64;
           I64[Sp - 8] = _s8Kve::I64;
           I64[Sp] = _s8KuP::I64;
           P64[Sp + 24] = _c8L61::P64;
           Sp = Sp - 56;
           call _c8L64() args: 0, res: 0, upd: 0;
       c8L7f: // global
           P64[Sp - 48] = _s8KuQ::P64;
           P64[Sp - 40] = _s8KuR::P64;
           I64[Sp - 32] = _s8KuS::I64;
           I64[Sp - 24] = _s8KuT::I64;
           I64[Sp - 16] = _s8Kvd::I64;
           I64[Sp - 8] = _s8Kve::I64;
           I64[Sp] = _s8KuP::I64;
           P64[Sp + 24] = _c8L61::P64;
           Sp = Sp - 56;
           call _c8L6q() args: 0, res: 0, upd: 0;
     }
 },
 _c8L64() //  []
         { info_tbl: [(c8L64,
                       label: block_c8L64_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L64: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8L6U; else goto c8L6T;
       c8L6U: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L64_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8L6T: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kv1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8L6q() //  []
         { info_tbl: [(c8L6q,
                       label: block_c8L6q_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L6q: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8L6Y; else goto c8L6X;
       c8L6Y: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L6q_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8L6X: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kv9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.509146049 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_decode_closure" {
     GHC.IO.Encoding.Latin1.latin1_decode_closure:
         const GHC.IO.Encoding.Latin1.latin1_decode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_decode_entry() //  [R2, R3]
         { info_tbl: [(c8L8J,
                       label: GHC.IO.Encoding.Latin1.latin1_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L8J: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.515010954 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii5_closure" {
     GHC.IO.Encoding.Latin1.ascii5_closure:
         const GHC.IO.Encoding.Latin1.ascii5_info;
 },
 sat_s8KvQ_entry() //  [R1]
         { info_tbl: [(c8L9k,
                       label: sat_s8KvQ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L9k: // global
           _s8KvQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8L9l; else goto c8L9m;
       c8L9m: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L9o; else goto c8L9n;
       c8L9o: // global
           HpAlloc = 56;
           goto c8L9l;
       c8L9l: // global
           R1 = _s8KvQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L9n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KvQ::P64;
           _s8KvC::I64 = I64[_s8KvQ::P64 + 56];
           _s8KvM::I64 = I64[_s8KvQ::P64 + 64];
           if (_s8KvM::I64 == _s8KvC::I64) goto c8L9j; else goto c8L9i;
       c8L9j: // global
           _s8KvK::P64 = P64[_s8KvQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8L9i: // global
           _s8Kvy::P64 = P64[_s8KvQ::P64 + 16];
           _s8Kvz::P64 = P64[_s8KvQ::P64 + 24];
           _s8Kvx::I64 = I64[_s8KvQ::P64 + 40];
           _s8KvA::I64 = I64[_s8KvQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8KvM::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KvY_entry() //  [R1]
         { info_tbl: [(c8L9G,
                       label: sat_s8KvY_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L9G: // global
           _s8KvY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8L9H; else goto c8L9I;
       c8L9I: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8L9K; else goto c8L9J;
       c8L9K: // global
           HpAlloc = 56;
           goto c8L9H;
       c8L9H: // global
           R1 = _s8KvY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8L9J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KvY::P64;
           _s8KvC::I64 = I64[_s8KvY::P64 + 56];
           _s8KvU::I64 = I64[_s8KvY::P64 + 64];
           if (_s8KvU::I64 == _s8KvC::I64) goto c8L9F; else goto c8L9E;
       c8L9F: // global
           _s8KvK::P64 = P64[_s8KvY::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8L9E: // global
           _s8Kvy::P64 = P64[_s8KvY::P64 + 16];
           _s8Kvz::P64 = P64[_s8KvY::P64 + 24];
           _s8Kvx::I64 = I64[_s8KvY::P64 + 40];
           _s8KvA::I64 = I64[_s8KvY::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8KvU::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Kw6_entry() //  [R1]
         { info_tbl: [(c8La2,
                       label: sat_s8Kw6_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8La2: // global
           _s8Kw6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8La3; else goto c8La4;
       c8La4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8La6; else goto c8La5;
       c8La6: // global
           HpAlloc = 56;
           goto c8La3;
       c8La3: // global
           R1 = _s8Kw6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8La5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Kw6::P64;
           _s8KvC::I64 = I64[_s8Kw6::P64 + 56];
           _s8Kw2::I64 = I64[_s8Kw6::P64 + 64];
           if (_s8Kw2::I64 == _s8KvC::I64) goto c8La1; else goto c8La0;
       c8La1: // global
           _s8KvK::P64 = P64[_s8Kw6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KvK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8La0: // global
           _s8Kvy::P64 = P64[_s8Kw6::P64 + 16];
           _s8Kvz::P64 = P64[_s8Kw6::P64 + 24];
           _s8Kvx::I64 = I64[_s8Kw6::P64 + 40];
           _s8KvA::I64 = I64[_s8Kw6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = _s8Kvz::P64;
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = _s8KvA::I64;
           I64[Hp - 8] = _s8Kw2::I64;
           I64[Hp] = _s8KvC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.ascii5_entry() //  [R2, R3]
         { info_tbl: [(c8La9,
                       label: GHC.IO.Encoding.Latin1.ascii5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8La9: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Laa; else goto c8Lab;
       c8Laa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Lab: // global
           I64[Sp - 16] = block_c8L8U_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lbc; else goto c8L8V;
       u8Lbc: // global
           call _c8L8U(R1) args: 0, res: 0, upd: 0;
       c8L8V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8L8U() //  [R1]
         { info_tbl: [(c8L8U,
                       label: block_c8L8U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L8U: // global
           I64[Sp - 40] = block_c8L8Z_info;
           _s8Kvy::P64 = P64[R1 + 7];
           _s8Kvz::P64 = P64[R1 + 15];
           _s8Kvx::I64 = I64[R1 + 23];
           _s8KvA::I64 = I64[R1 + 31];
           _s8KvB::I64 = I64[R1 + 39];
           _s8KvC::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kvz::P64;
           I64[Sp - 24] = _s8KvA::I64;
           I64[Sp - 16] = _s8KvB::I64;
           I64[Sp - 8] = _s8KvC::I64;
           P64[Sp] = _s8Kvy::P64;
           I64[Sp + 8] = _s8Kvx::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Lb8; else goto c8L90;
       u8Lb8: // global
           call _c8L8Z(R1) args: 0, res: 0, upd: 0;
       c8L90: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8L8Z() //  [R1]
         { info_tbl: [(c8L8Z,
                       label: block_c8L8Z_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L8Z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Laf; else goto c8Lae;
       c8Laf: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Lae: // global
           _s8KvF::P64 = P64[R1 + 7];
           _s8KvG::P64 = P64[R1 + 15];
           _s8KvE::I64 = I64[R1 + 23];
           _s8KvH::I64 = I64[R1 + 31];
           _s8KvI::I64 = I64[R1 + 39];
           _s8KvJ::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kvy::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kvy::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kvx::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kvx::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KvC::I64 = I64[Sp + 32];
           _c8L94::P64 = Hp - 47;
           _s8Kwb::I64 = _s8KvJ::I64;
           _s8Kwa::I64 = I64[Sp + 24];
           goto c8Lau;
       c8Lau: // global
           if (%MO_S_Lt_W64(_s8Kwb::I64,
                            _s8KvH::I64)) goto c8LaR; else goto c8LaS;
       c8LaR: // global
           if (%MO_S_Lt_W64(_s8Kwa::I64,
                            _s8KvC::I64)) goto c8LaO; else goto c8LaP;
       c8LaO: // global
           _s8Kwi::I64 = %MO_UU_Conv_W8_W64(I8[_s8Kvx::I64 + _s8Kwa::I64]);
           call MO_Touch(_s8Kvy::P64);
           if (_s8Kwi::I64 <= 127) goto c8LaL; else goto c8LaM;
       c8LaL: // global
           I32[_s8KvE::I64 + (_s8Kwb::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Kwi::I64);
           call MO_Touch(_s8KvF::P64);
           _s8Kwb::I64 = _s8Kwb::I64 + 1;
           _s8Kwa::I64 = _s8Kwa::I64 + 1;
           goto c8Lau;
       c8LaM: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8L94::P64;
           Sp = Sp - 56;
           call _c8L97() args: 0, res: 0, upd: 0;
       c8LaP: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8L94::P64;
           Sp = Sp - 56;
           call _c8L9t() args: 0, res: 0, upd: 0;
       c8LaS: // global
           P64[Sp - 48] = _s8KvF::P64;
           P64[Sp - 40] = _s8KvG::P64;
           I64[Sp - 32] = _s8KvH::I64;
           I64[Sp - 24] = _s8KvI::I64;
           I64[Sp - 16] = _s8Kwa::I64;
           I64[Sp - 8] = _s8Kwb::I64;
           I64[Sp] = _s8KvE::I64;
           P64[Sp + 24] = _c8L94::P64;
           Sp = Sp - 56;
           call _c8L9P() args: 0, res: 0, upd: 0;
     }
 },
 _c8L97() //  []
         { info_tbl: [(c8L97,
                       label: block_c8L97_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L97: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Laj; else goto c8Lai;
       c8Laj: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L97_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lai: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KvQ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8L9t() //  []
         { info_tbl: [(c8L9t,
                       label: block_c8L9t_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L9t: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lan; else goto c8Lam;
       c8Lan: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L9t_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lam: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KvY_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8L9P() //  []
         { info_tbl: [(c8L9P,
                       label: block_c8L9P_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L9P: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lar; else goto c8Laq;
       c8Lar: // global
           HpAlloc = 160;
           I64[Sp] = block_c8L9P_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Laq: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Kw6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.540576453 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_decode_closure" {
     GHC.IO.Encoding.Latin1.ascii_decode_closure:
         const GHC.IO.Encoding.Latin1.ascii_decode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_decode_entry() //  [R2, R3]
         { info_tbl: [(c8LcJ,
                       label: GHC.IO.Encoding.Latin1.ascii_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LcJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.54606792 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin3_closure" {
     GHC.IO.Encoding.Latin1.latin3_closure:
         const GHC.IO.Encoding.Latin1.latin3_info;
 },
 sat_s8KwO_entry() //  [R1]
         { info_tbl: [(c8Ldk,
                       label: sat_s8KwO_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ldk: // global
           _s8KwO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ldl; else goto c8Ldm;
       c8Ldm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Ldo; else goto c8Ldn;
       c8Ldo: // global
           HpAlloc = 56;
           goto c8Ldl;
       c8Ldl: // global
           R1 = _s8KwO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ldn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KwO::P64;
           _s8KwA::I64 = I64[_s8KwO::P64 + 56];
           _s8KwK::I64 = I64[_s8KwO::P64 + 64];
           if (_s8KwK::I64 == _s8KwA::I64) goto c8Ldj; else goto c8Ldi;
       c8Ldj: // global
           _s8KwI::P64 = P64[_s8KwO::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KwI::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Ldi: // global
           _s8Kww::P64 = P64[_s8KwO::P64 + 16];
           _s8Kwx::P64 = P64[_s8KwO::P64 + 24];
           _s8Kwv::I64 = I64[_s8KwO::P64 + 40];
           _s8Kwy::I64 = I64[_s8KwO::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = _s8Kwx::P64;
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = _s8Kwy::I64;
           I64[Hp - 8] = _s8KwK::I64;
           I64[Hp] = _s8KwA::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KwW_entry() //  [R1]
         { info_tbl: [(c8LdG,
                       label: sat_s8KwW_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LdG: // global
           _s8KwW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LdH; else goto c8LdI;
       c8LdI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LdK; else goto c8LdJ;
       c8LdK: // global
           HpAlloc = 56;
           goto c8LdH;
       c8LdH: // global
           R1 = _s8KwW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LdJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KwW::P64;
           _s8KwA::I64 = I64[_s8KwW::P64 + 56];
           _s8KwS::I64 = I64[_s8KwW::P64 + 64];
           if (_s8KwS::I64 == _s8KwA::I64) goto c8LdF; else goto c8LdE;
       c8LdF: // global
           _s8KwI::P64 = P64[_s8KwW::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8KwI::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LdE: // global
           _s8Kww::P64 = P64[_s8KwW::P64 + 16];
           _s8Kwx::P64 = P64[_s8KwW::P64 + 24];
           _s8Kwv::I64 = I64[_s8KwW::P64 + 40];
           _s8Kwy::I64 = I64[_s8KwW::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = _s8Kwx::P64;
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = _s8Kwy::I64;
           I64[Hp - 8] = _s8KwS::I64;
           I64[Hp] = _s8KwA::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin3_entry() //  [R2, R3]
         { info_tbl: [(c8LdN,
                       label: GHC.IO.Encoding.Latin1.latin3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LdN: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LdO; else goto c8LdP;
       c8LdO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LdP: // global
           I64[Sp - 16] = block_c8LcU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LeH; else goto c8LcV;
       u8LeH: // global
           call _c8LcU(R1) args: 0, res: 0, upd: 0;
       c8LcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LcU() //  [R1]
         { info_tbl: [(c8LcU,
                       label: block_c8LcU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LcU: // global
           I64[Sp - 40] = block_c8LcZ_info;
           _s8Kww::P64 = P64[R1 + 7];
           _s8Kwx::P64 = P64[R1 + 15];
           _s8Kwv::I64 = I64[R1 + 23];
           _s8Kwy::I64 = I64[R1 + 31];
           _s8Kwz::I64 = I64[R1 + 39];
           _s8KwA::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kwx::P64;
           I64[Sp - 24] = _s8Kwy::I64;
           I64[Sp - 16] = _s8Kwz::I64;
           I64[Sp - 8] = _s8KwA::I64;
           P64[Sp] = _s8Kww::P64;
           I64[Sp + 8] = _s8Kwv::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LeE; else goto c8Ld0;
       u8LeE: // global
           call _c8LcZ(R1) args: 0, res: 0, upd: 0;
       c8Ld0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LcZ() //  [R1]
         { info_tbl: [(c8LcZ,
                       label: block_c8LcZ_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LcZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LdT; else goto c8LdS;
       c8LdT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LdS: // global
           _s8KwD::P64 = P64[R1 + 7];
           _s8KwE::P64 = P64[R1 + 15];
           _s8KwC::I64 = I64[R1 + 23];
           _s8KwF::I64 = I64[R1 + 31];
           _s8KwG::I64 = I64[R1 + 39];
           _s8KwH::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kww::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kww::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kwv::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kwv::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8KwA::I64 = I64[Sp + 32];
           _c8Ld4::P64 = Hp - 47;
           _s8Kx1::I64 = _s8KwH::I64;
           _s8Kx0::I64 = I64[Sp + 24];
           goto c8Le4;
       c8Le4: // global
           if (%MO_S_Lt_W64(_s8Kx1::I64,
                            _s8KwF::I64)) goto c8Leh; else goto c8Lei;
       c8Leh: // global
           if (%MO_S_Lt_W64(_s8Kx0::I64,
                            _s8KwA::I64)) goto c8Lee; else goto c8Lef;
       c8Lee: // global
           _s8Kx7::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kwv::I64 + (_s8Kx0::I64 << 2)]);
           call MO_Touch(_s8Kww::P64);
           I8[_s8KwC::I64 + _s8Kx1::I64] = %MO_UU_Conv_W64_W8(_s8Kx7::I64);
           call MO_Touch(_s8KwD::P64);
           _s8Kx1::I64 = _s8Kx1::I64 + 1;
           _s8Kx0::I64 = _s8Kx0::I64 + 1;
           goto c8Le4;
       c8Lef: // global
           P64[Sp - 48] = _s8KwD::P64;
           P64[Sp - 40] = _s8KwE::P64;
           I64[Sp - 32] = _s8KwF::I64;
           I64[Sp - 24] = _s8KwG::I64;
           I64[Sp - 16] = _s8Kx0::I64;
           I64[Sp - 8] = _s8Kx1::I64;
           I64[Sp] = _s8KwC::I64;
           P64[Sp + 24] = _c8Ld4::P64;
           Sp = Sp - 56;
           call _c8Ld7() args: 0, res: 0, upd: 0;
       c8Lei: // global
           P64[Sp - 48] = _s8KwD::P64;
           P64[Sp - 40] = _s8KwE::P64;
           I64[Sp - 32] = _s8KwF::I64;
           I64[Sp - 24] = _s8KwG::I64;
           I64[Sp - 16] = _s8Kx0::I64;
           I64[Sp - 8] = _s8Kx1::I64;
           I64[Sp] = _s8KwC::I64;
           P64[Sp + 24] = _c8Ld4::P64;
           Sp = Sp - 56;
           call _c8Ldt() args: 0, res: 0, upd: 0;
     }
 },
 _c8Ld7() //  []
         { info_tbl: [(c8Ld7,
                       label: block_c8Ld7_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ld7: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LdX; else goto c8LdW;
       c8LdX: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ld7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LdW: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KwO_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ldt() //  []
         { info_tbl: [(c8Ldt,
                       label: block_c8Ldt_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ldt: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Le1; else goto c8Le0;
       c8Le1: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ldt_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Le0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KwW_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.567184824 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_encode_entry() //  [R2, R3]
         { info_tbl: [(c8LfQ,
                       label: GHC.IO.Encoding.Latin1.latin1_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LfQ: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.572868693 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii3_closure" {
     GHC.IO.Encoding.Latin1.ascii3_closure:
         const GHC.IO.Encoding.Latin1.ascii3_info;
 },
 sat_s8KxE_entry() //  [R1]
         { info_tbl: [(c8Lgr,
                       label: sat_s8KxE_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lgr: // global
           _s8KxE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Lgs; else goto c8Lgt;
       c8Lgt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Lgv; else goto c8Lgu;
       c8Lgv: // global
           HpAlloc = 56;
           goto c8Lgs;
       c8Lgs: // global
           R1 = _s8KxE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Lgu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxE::P64;
           _s8Kxq::I64 = I64[_s8KxE::P64 + 56];
           _s8KxA::I64 = I64[_s8KxE::P64 + 64];
           if (_s8KxA::I64 == _s8Kxq::I64) goto c8Lgq; else goto c8Lgp;
       c8Lgq: // global
           _s8Kxy::P64 = P64[_s8KxE::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Lgp: // global
           _s8Kxm::P64 = P64[_s8KxE::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxE::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxE::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxE::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxA::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KxM_entry() //  [R1]
         { info_tbl: [(c8LgN,
                       label: sat_s8KxM_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LgN: // global
           _s8KxM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LgO; else goto c8LgP;
       c8LgP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LgR; else goto c8LgQ;
       c8LgR: // global
           HpAlloc = 56;
           goto c8LgO;
       c8LgO: // global
           R1 = _s8KxM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LgQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxM::P64;
           _s8Kxq::I64 = I64[_s8KxM::P64 + 56];
           _s8KxI::I64 = I64[_s8KxM::P64 + 64];
           if (_s8KxI::I64 == _s8Kxq::I64) goto c8LgM; else goto c8LgL;
       c8LgM: // global
           _s8Kxy::P64 = P64[_s8KxM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LgL: // global
           _s8Kxm::P64 = P64[_s8KxM::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxM::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxM::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxI::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KxU_entry() //  [R1]
         { info_tbl: [(c8Lh9,
                       label: sat_s8KxU_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lh9: // global
           _s8KxU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Lha; else goto c8Lhb;
       c8Lhb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Lhd; else goto c8Lhc;
       c8Lhd: // global
           HpAlloc = 56;
           goto c8Lha;
       c8Lha: // global
           R1 = _s8KxU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Lhc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KxU::P64;
           _s8Kxq::I64 = I64[_s8KxU::P64 + 56];
           _s8KxQ::I64 = I64[_s8KxU::P64 + 64];
           if (_s8KxQ::I64 == _s8Kxq::I64) goto c8Lh8; else goto c8Lh7;
       c8Lh8: // global
           _s8Kxy::P64 = P64[_s8KxU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kxy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Lh7: // global
           _s8Kxm::P64 = P64[_s8KxU::P64 + 16];
           _s8Kxn::P64 = P64[_s8KxU::P64 + 24];
           _s8Kxl::I64 = I64[_s8KxU::P64 + 40];
           _s8Kxo::I64 = I64[_s8KxU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = _s8Kxn::P64;
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = _s8Kxo::I64;
           I64[Hp - 8] = _s8KxQ::I64;
           I64[Hp] = _s8Kxq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.ascii3_entry() //  [R2, R3]
         { info_tbl: [(c8Lhg,
                       label: GHC.IO.Encoding.Latin1.ascii3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lhg: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Lhh; else goto c8Lhi;
       c8Lhh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Lhi: // global
           I64[Sp - 16] = block_c8Lg1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lip; else goto c8Lg2;
       u8Lip: // global
           call _c8Lg1(R1) args: 0, res: 0, upd: 0;
       c8Lg2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Lg1() //  [R1]
         { info_tbl: [(c8Lg1,
                       label: block_c8Lg1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lg1: // global
           I64[Sp - 40] = block_c8Lg6_info;
           _s8Kxm::P64 = P64[R1 + 7];
           _s8Kxn::P64 = P64[R1 + 15];
           _s8Kxl::I64 = I64[R1 + 23];
           _s8Kxo::I64 = I64[R1 + 31];
           _s8Kxp::I64 = I64[R1 + 39];
           _s8Kxq::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kxn::P64;
           I64[Sp - 24] = _s8Kxo::I64;
           I64[Sp - 16] = _s8Kxp::I64;
           I64[Sp - 8] = _s8Kxq::I64;
           P64[Sp] = _s8Kxm::P64;
           I64[Sp + 8] = _s8Kxl::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Lil; else goto c8Lg7;
       u8Lil: // global
           call _c8Lg6(R1) args: 0, res: 0, upd: 0;
       c8Lg7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Lg6() //  [R1]
         { info_tbl: [(c8Lg6,
                       label: block_c8Lg6_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lg6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Lhm; else goto c8Lhl;
       c8Lhm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Lhl: // global
           _s8Kxt::P64 = P64[R1 + 7];
           _s8Kxu::P64 = P64[R1 + 15];
           _s8Kxs::I64 = I64[R1 + 23];
           _s8Kxv::I64 = I64[R1 + 31];
           _s8Kxw::I64 = I64[R1 + 39];
           _s8Kxx::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kxm::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kxm::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kxl::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kxl::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Kxq::I64 = I64[Sp + 32];
           _c8Lgb::P64 = Hp - 47;
           _s8KxZ::I64 = _s8Kxx::I64;
           _s8KxY::I64 = I64[Sp + 24];
           goto c8LhB;
       c8LhB: // global
           if (%MO_S_Lt_W64(_s8KxZ::I64,
                            _s8Kxv::I64)) goto c8LhY; else goto c8LhZ;
       c8LhY: // global
           if (%MO_S_Lt_W64(_s8KxY::I64,
                            _s8Kxq::I64)) goto c8LhV; else goto c8LhW;
       c8LhV: // global
           _s8Ky5::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kxl::I64 + (_s8KxY::I64 << 2)]);
           call MO_Touch(_s8Kxm::P64);
           if (%MO_S_Le_W64(_s8Ky5::I64, 127)) goto c8LhS; else goto c8LhT;
       c8LhS: // global
           I8[_s8Kxs::I64 + _s8KxZ::I64] = %MO_UU_Conv_W64_W8(_s8Ky5::I64);
           call MO_Touch(_s8Kxt::P64);
           _s8KxZ::I64 = _s8KxZ::I64 + 1;
           _s8KxY::I64 = _s8KxY::I64 + 1;
           goto c8LhB;
       c8LhT: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8Lgb::P64;
           Sp = Sp - 56;
           call _c8Lge() args: 0, res: 0, upd: 0;
       c8LhW: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8Lgb::P64;
           Sp = Sp - 56;
           call _c8LgA() args: 0, res: 0, upd: 0;
       c8LhZ: // global
           P64[Sp - 48] = _s8Kxt::P64;
           P64[Sp - 40] = _s8Kxu::P64;
           I64[Sp - 32] = _s8Kxv::I64;
           I64[Sp - 24] = _s8Kxw::I64;
           I64[Sp - 16] = _s8KxY::I64;
           I64[Sp - 8] = _s8KxZ::I64;
           I64[Sp] = _s8Kxs::I64;
           P64[Sp + 24] = _c8Lgb::P64;
           Sp = Sp - 56;
           call _c8LgW() args: 0, res: 0, upd: 0;
     }
 },
 _c8Lge() //  []
         { info_tbl: [(c8Lge,
                       label: block_c8Lge_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lge: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lhq; else goto c8Lhp;
       c8Lhq: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Lge_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lhp: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxE_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LgA() //  []
         { info_tbl: [(c8LgA,
                       label: block_c8LgA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LgA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lhu; else goto c8Lht;
       c8Lhu: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LgA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lht: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LgW() //  []
         { info_tbl: [(c8LgW,
                       label: block_c8LgW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LgW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Lhy; else goto c8Lhx;
       c8Lhy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LgW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Lhx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KxU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.599061097 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_encode_closure" {
     GHC.IO.Encoding.Latin1.ascii_encode_closure:
         const GHC.IO.Encoding.Latin1.ascii_encode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_encode_entry() //  [R2, R3]
         { info_tbl: [(c8LjX,
                       label: GHC.IO.Encoding.Latin1.ascii_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LjX: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.606124462 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked2_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked2_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked2_info;
 },
 sat_s8KyE_entry() //  [R1]
         { info_tbl: [(c8Lky,
                       label: sat_s8KyE_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lky: // global
           _s8KyE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Lkz; else goto c8LkA;
       c8LkA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LkC; else goto c8LkB;
       c8LkC: // global
           HpAlloc = 56;
           goto c8Lkz;
       c8Lkz: // global
           R1 = _s8KyE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LkB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyE::P64;
           _s8Kyq::I64 = I64[_s8KyE::P64 + 56];
           _s8KyA::I64 = I64[_s8KyE::P64 + 64];
           if (_s8KyA::I64 == _s8Kyq::I64) goto c8Lkx; else goto c8Lkw;
       c8Lkx: // global
           _s8Kyy::P64 = P64[_s8KyE::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Lkw: // global
           _s8Kym::P64 = P64[_s8KyE::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyE::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyE::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyE::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyA::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KyM_entry() //  [R1]
         { info_tbl: [(c8LkU,
                       label: sat_s8KyM_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LkU: // global
           _s8KyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LkV; else goto c8LkW;
       c8LkW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LkY; else goto c8LkX;
       c8LkY: // global
           HpAlloc = 56;
           goto c8LkV;
       c8LkV: // global
           R1 = _s8KyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LkX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyM::P64;
           _s8Kyq::I64 = I64[_s8KyM::P64 + 56];
           _s8KyI::I64 = I64[_s8KyM::P64 + 64];
           if (_s8KyI::I64 == _s8Kyq::I64) goto c8LkT; else goto c8LkS;
       c8LkT: // global
           _s8Kyy::P64 = P64[_s8KyM::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LkS: // global
           _s8Kym::P64 = P64[_s8KyM::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyM::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyM::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyM::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyI::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8KyU_entry() //  [R1]
         { info_tbl: [(c8Llg,
                       label: sat_s8KyU_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Llg: // global
           _s8KyU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Llh; else goto c8Lli;
       c8Lli: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Llk; else goto c8Llj;
       c8Llk: // global
           HpAlloc = 56;
           goto c8Llh;
       c8Llh: // global
           R1 = _s8KyU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Llj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8KyU::P64;
           _s8Kyq::I64 = I64[_s8KyU::P64 + 56];
           _s8KyQ::I64 = I64[_s8KyU::P64 + 64];
           if (_s8KyQ::I64 == _s8Kyq::I64) goto c8Llf; else goto c8Lle;
       c8Llf: // global
           _s8Kyy::P64 = P64[_s8KyU::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Kyy::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Lle: // global
           _s8Kym::P64 = P64[_s8KyU::P64 + 16];
           _s8Kyn::P64 = P64[_s8KyU::P64 + 24];
           _s8Kyl::I64 = I64[_s8KyU::P64 + 40];
           _s8Kyo::I64 = I64[_s8KyU::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = _s8Kyn::P64;
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = _s8Kyo::I64;
           I64[Hp - 8] = _s8KyQ::I64;
           I64[Hp] = _s8Kyq::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin1_checked2_entry() //  [R2, R3]
         { info_tbl: [(c8Lln,
                       label: GHC.IO.Encoding.Latin1.latin1_checked2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lln: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Llo; else goto c8Llp;
       c8Llo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin1_checked2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Llp: // global
           I64[Sp - 16] = block_c8Lk8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lmw; else goto c8Lk9;
       u8Lmw: // global
           call _c8Lk8(R1) args: 0, res: 0, upd: 0;
       c8Lk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Lk8() //  [R1]
         { info_tbl: [(c8Lk8,
                       label: block_c8Lk8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lk8: // global
           I64[Sp - 40] = block_c8Lkd_info;
           _s8Kym::P64 = P64[R1 + 7];
           _s8Kyn::P64 = P64[R1 + 15];
           _s8Kyl::I64 = I64[R1 + 23];
           _s8Kyo::I64 = I64[R1 + 31];
           _s8Kyp::I64 = I64[R1 + 39];
           _s8Kyq::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Kyn::P64;
           I64[Sp - 24] = _s8Kyo::I64;
           I64[Sp - 16] = _s8Kyp::I64;
           I64[Sp - 8] = _s8Kyq::I64;
           P64[Sp] = _s8Kym::P64;
           I64[Sp + 8] = _s8Kyl::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Lms; else goto c8Lke;
       u8Lms: // global
           call _c8Lkd(R1) args: 0, res: 0, upd: 0;
       c8Lke: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Lkd() //  [R1]
         { info_tbl: [(c8Lkd,
                       label: block_c8Lkd_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lkd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Llt; else goto c8Lls;
       c8Llt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Lls: // global
           _s8Kyt::P64 = P64[R1 + 7];
           _s8Kyu::P64 = P64[R1 + 15];
           _s8Kys::I64 = I64[R1 + 23];
           _s8Kyv::I64 = I64[R1 + 31];
           _s8Kyw::I64 = I64[R1 + 39];
           _s8Kyx::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Kym::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Kym::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Kyl::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Kyl::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Kyq::I64 = I64[Sp + 32];
           _c8Lki::P64 = Hp - 47;
           _s8KyZ::I64 = _s8Kyx::I64;
           _s8KyY::I64 = I64[Sp + 24];
           goto c8LlI;
       c8LlI: // global
           if (%MO_S_Lt_W64(_s8KyZ::I64,
                            _s8Kyv::I64)) goto c8Lm5; else goto c8Lm6;
       c8Lm5: // global
           if (%MO_S_Lt_W64(_s8KyY::I64,
                            _s8Kyq::I64)) goto c8Lm2; else goto c8Lm3;
       c8Lm2: // global
           _s8Kz5::I64 = %MO_UU_Conv_W32_W64(I32[_s8Kyl::I64 + (_s8KyY::I64 << 2)]);
           call MO_Touch(_s8Kym::P64);
           if (%MO_S_Le_W64(_s8Kz5::I64, 255)) goto c8LlZ; else goto c8Lm0;
       c8LlZ: // global
           I8[_s8Kys::I64 + _s8KyZ::I64] = %MO_UU_Conv_W64_W8(_s8Kz5::I64);
           call MO_Touch(_s8Kyt::P64);
           _s8KyZ::I64 = _s8KyZ::I64 + 1;
           _s8KyY::I64 = _s8KyY::I64 + 1;
           goto c8LlI;
       c8Lm0: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8Lki::P64;
           Sp = Sp - 56;
           call _c8Lkl() args: 0, res: 0, upd: 0;
       c8Lm3: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8Lki::P64;
           Sp = Sp - 56;
           call _c8LkH() args: 0, res: 0, upd: 0;
       c8Lm6: // global
           P64[Sp - 48] = _s8Kyt::P64;
           P64[Sp - 40] = _s8Kyu::P64;
           I64[Sp - 32] = _s8Kyv::I64;
           I64[Sp - 24] = _s8Kyw::I64;
           I64[Sp - 16] = _s8KyY::I64;
           I64[Sp - 8] = _s8KyZ::I64;
           I64[Sp] = _s8Kys::I64;
           P64[Sp + 24] = _c8Lki::P64;
           Sp = Sp - 56;
           call _c8Ll3() args: 0, res: 0, upd: 0;
     }
 },
 _c8Lkl() //  []
         { info_tbl: [(c8Lkl,
                       label: block_c8Lkl_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lkl: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Llx; else goto c8Llw;
       c8Llx: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Lkl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Llw: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyE_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LkH() //  []
         { info_tbl: [(c8LkH,
                       label: block_c8LkH_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LkH: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LlB; else goto c8LlA;
       c8LlB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LkH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LlA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyM_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ll3() //  []
         { info_tbl: [(c8Ll3,
                       label: block_c8Ll3_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ll3: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LlF; else goto c8LlE;
       c8LlF: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ll3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LlE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8KyU_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.632656994 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_checked_encode_entry() //  [R2, R3]
         { info_tbl: [(c8Lo4,
                       label: GHC.IO.Encoding.Latin1.latin1_checked_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lo4: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin1_checked2_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.63657515 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule4_bytes" {
     GHC.IO.Encoding.Latin1.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.638318526 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule3_closure" {
     GHC.IO.Encoding.Latin1.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.640048533 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule2_bytes" {
     GHC.IO.Encoding.Latin1.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,76,97,116,105,110,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.641925538 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule1_closure" {
     GHC.IO.Encoding.Latin1.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.643690225 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule_closure" {
     GHC.IO.Encoding.Latin1.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Latin1.$trModule3_closure+1;
         const GHC.IO.Encoding.Latin1.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.646118998 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.ascii7_bytes" {
     GHC.IO.Encoding.Latin1.ascii7_bytes:
         I8[] [65,83,67,73,73]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.648199796 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii6_closure" {
     GHC.IO.Encoding.Latin1.ascii6_closure:
         const GHC.IO.Encoding.Latin1.ascii6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii6_entry() //  [R1]
         { info_tbl: [(c8Lon,
                       label: GHC.IO.Encoding.Latin1.ascii6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lon: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Loo; else goto c8Lop;
       c8Loo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Lop: // global
           (_c8Lok::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Lok::I64 == 0) goto c8Lom; else goto c8Lol;
       c8Lom: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Lol: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Lok::I64;
           R2 = GHC.IO.Encoding.Latin1.ascii7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.6536303 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii2_closure" {
     GHC.IO.Encoding.Latin1.mkAscii2_closure:
         const GHC.IO.Encoding.Latin1.mkAscii2_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii2_entry() //  []
         { info_tbl: [(c8LoB,
                       label: GHC.IO.Encoding.Latin1.mkAscii2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LoB: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.657984743 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii1_closure" {
     GHC.IO.Encoding.Latin1.mkAscii1_closure:
         const GHC.IO.Encoding.Latin1.mkAscii1_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii1_entry() //  []
         { info_tbl: [(c8LoN,
                       label: GHC.IO.Encoding.Latin1.mkAscii1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LoN: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.662898659 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii_closure" {
     GHC.IO.Encoding.Latin1.mkAscii_closure:
         const GHC.IO.Encoding.Latin1.mkAscii_info;
         const 0;
 },
 sat_s8Kzq_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Lp9,
                       label: sat_s8Kzq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lp9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Kzs_entry() //  [R1]
         { info_tbl: [(c8Lpd,
                       label: sat_s8Kzs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lpd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lph; else goto c8Lpg;
       c8Lph: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lpg: // global
           _s8Kzk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Kzq_info;
           P64[Hp - 48] = _s8Kzk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Kzm_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Lps,
                       label: sat_s8Kzm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lps: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Kzo_entry() //  [R1]
         { info_tbl: [(c8Lpw,
                       label: sat_s8Kzo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lpw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LpA; else goto c8Lpz;
       c8LpA: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lpz: // global
           _s8Kzk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Kzm_info;
           P64[Hp - 48] = _s8Kzk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkAscii_entry() //  [R2]
         { info_tbl: [(c8LpC,
                       label: GHC.IO.Encoding.Latin1.mkAscii_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LpC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LpG; else goto c8LpF;
       c8LpG: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkAscii_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8LpF: // global
           I64[Hp - 56] = sat_s8Kzs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Kzo_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.ascii6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.674489067 UTC

[section ""data" . lvl_r8Kux_closure" {
     lvl_r8Kux_closure:
         const lvl_r8Kux_info;
         const 0;
 },
 lvl_r8Kux_entry() //  [R2, R3]
         { info_tbl: [(c8Lqb,
                       label: lvl_r8Kux_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lqb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Lqf; else goto c8Lqg;
       c8Lqf: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8Kux_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Lqg: // global
           I64[Sp - 16] = block_c8Lq8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lqo; else goto c8Lq9;
       u8Lqo: // global
           call _c8Lq8() args: 0, res: 0, upd: 0;
       c8Lq9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Lq8() //  []
         { info_tbl: [(c8Lq8,
                       label: block_c8Lq8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lq8: // global
           _s8Kzu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Lqe_info;
           R1 = _s8Kzu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Lqn; else goto c8Lqi;
       u8Lqn: // global
           call _c8Lqe() args: 0, res: 0, upd: 0;
       c8Lqi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Lqe() //  []
         { info_tbl: [(c8Lqe,
                       label: block_c8Lqe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lqe: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.681723954 UTC

[section ""data" . lvl1_r8Kuy_closure" {
     lvl1_r8Kuy_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.684140831 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii4_closure" {
     GHC.IO.Encoding.Latin1.ascii4_closure:
         const GHC.IO.Encoding.Latin1.ascii4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii4_entry() //  []
         { info_tbl: [(c8LqH,
                       label: GHC.IO.Encoding.Latin1.ascii4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LqH: // global
           R1 = lvl1_r8Kuy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.688181213 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii2_closure" {
     GHC.IO.Encoding.Latin1.ascii2_closure:
         const GHC.IO.Encoding.Latin1.ascii2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii2_entry() //  [R2, R3]
         { info_tbl: [(c8LqW,
                       label: GHC.IO.Encoding.Latin1.ascii2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LqW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Lr0; else goto c8Lr1;
       c8Lr0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Lr1: // global
           I64[Sp - 16] = block_c8LqT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lra; else goto c8LqU;
       u8Lra: // global
           call _c8LqT(R1) args: 0, res: 0, upd: 0;
       c8LqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LqT() //  [R1]
         { info_tbl: [(c8LqT,
                       label: block_c8LqT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LqT: // global
           I64[Sp - 16] = block_c8LqZ_info;
           _s8KzQ::P64 = P64[R1 + 7];
           _s8KzP::I64 = I64[R1 + 23];
           _s8KzT::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8KzT::I64;
           P64[Sp] = _s8KzQ::P64;
           I64[Sp + 8] = _s8KzP::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Lr9; else goto c8Lr3;
       u8Lr9: // global
           call _c8LqZ() args: 0, res: 0, upd: 0;
       c8Lr3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LqZ() //  []
         { info_tbl: [(c8LqZ,
                       label: block_c8LqZ_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LqZ: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.695229092 UTC

[section ""data" . lvl2_r8Kuz_closure" {
     lvl2_r8Kuz_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.697174893 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii1_closure" {
     GHC.IO.Encoding.Latin1.ascii1_closure:
         const GHC.IO.Encoding.Latin1.ascii1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii1_entry() //  []
         { info_tbl: [(c8Lrt,
                       label: GHC.IO.Encoding.Latin1.ascii1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lrt: // global
           R1 = lvl2_r8Kuz_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.70065501 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_closure" {
     GHC.IO.Encoding.Latin1.ascii_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Latin1.ascii4_closure+1;
         const GHC.IO.Encoding.Latin1.ascii1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.702474134 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.latin7_bytes" {
     GHC.IO.Encoding.Latin1.latin7_bytes:
         I8[] [73,83,79,45,56,56,53,57,45,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.704390005 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin6_closure" {
     GHC.IO.Encoding.Latin1.latin6_closure:
         const GHC.IO.Encoding.Latin1.latin6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin6_entry() //  [R1]
         { info_tbl: [(c8LrJ,
                       label: GHC.IO.Encoding.Latin1.latin6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LrJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8LrK; else goto c8LrL;
       c8LrK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LrL: // global
           (_c8LrG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8LrG::I64 == 0) goto c8LrI; else goto c8LrH;
       c8LrI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8LrH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8LrG::I64;
           R2 = GHC.IO.Encoding.Latin1.latin7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.709045957 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_checked_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_checked_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_info;
         const 0;
 },
 sat_s8KAd_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Ls7,
                       label: sat_s8KAd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ls7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAf_entry() //  [R1]
         { info_tbl: [(c8Lsb,
                       label: sat_s8KAf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lsb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lsf; else goto c8Lse;
       c8Lsf: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lse: // global
           _s8KA7::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAd_info;
           P64[Hp - 48] = _s8KA7::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KA9_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Lsq,
                       label: sat_s8KA9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lsq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAb_entry() //  [R1]
         { info_tbl: [(c8Lsu,
                       label: sat_s8KAb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lsu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lsy; else goto c8Lsx;
       c8Lsy: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lsx: // global
           _s8KA7::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KA9_info;
           P64[Hp - 48] = _s8KA7::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkLatin1_checked_entry() //  [R2]
         { info_tbl: [(c8LsA,
                       label: GHC.IO.Encoding.Latin1.mkLatin1_checked_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LsA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LsE; else goto c8LsD;
       c8LsE: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8LsD: // global
           I64[Hp - 56] = sat_s8KAf_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8KAb_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.72122243 UTC

[section ""data" . lvl3_r8KuA_closure" {
     lvl3_r8KuA_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.723657262 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin4_closure" {
     GHC.IO.Encoding.Latin1.latin4_closure:
         const GHC.IO.Encoding.Latin1.latin4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin4_entry() //  []
         { info_tbl: [(c8Lt7,
                       label: GHC.IO.Encoding.Latin1.latin4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lt7: // global
           R1 = lvl3_r8KuA_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.726999196 UTC

[section ""data" . lvl4_r8KuB_closure" {
     lvl4_r8KuB_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.728959137 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked1_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked1_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin1_checked1_entry() //  []
         { info_tbl: [(c8Ltk,
                       label: GHC.IO.Encoding.Latin1.latin1_checked1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ltk: // global
           R1 = lvl4_r8KuB_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.732651583 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin1_checked1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.735263059 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_info;
         const 0;
 },
 sat_s8KAo_entry() //  [R1, R2, R3]
         { info_tbl: [(c8LtH,
                       label: sat_s8KAo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LtH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAq_entry() //  [R1]
         { info_tbl: [(c8LtL,
                       label: sat_s8KAq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LtL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LtP; else goto c8LtO;
       c8LtP: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LtO: // global
           _s8KAi::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAo_info;
           P64[Hp - 48] = _s8KAi::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAk_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Lu0,
                       label: sat_s8KAk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lu0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8KAm_entry() //  [R1]
         { info_tbl: [(c8Lu4,
                       label: sat_s8KAm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lu4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lu8; else goto c8Lu7;
       c8Lu8: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Lu7: // global
           _s8KAi::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8KAk_info;
           P64[Hp - 48] = _s8KAi::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkLatin1_entry() //  [R2]
         { info_tbl: [(c8Lua,
                       label: GHC.IO.Encoding.Latin1.mkLatin1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lua: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Lue; else goto c8Lud;
       c8Lue: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Lud: // global
           I64[Hp - 56] = sat_s8KAq_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8KAm_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.746764011 UTC

[section ""data" . lvl5_r8KuC_closure" {
     lvl5_r8KuC_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.748663064 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin2_closure" {
     GHC.IO.Encoding.Latin1.latin2_closure:
         const GHC.IO.Encoding.Latin1.latin2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin2_entry() //  []
         { info_tbl: [(c8LuH,
                       label: GHC.IO.Encoding.Latin1.latin2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LuH: // global
           R1 = lvl5_r8KuC_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.752575569 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_closure" {
     GHC.IO.Encoding.Latin1.latin1_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.754295182 UTC

[section ""relreadonly" . S8KNa_srt" {
     S8KNa_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Latin1.mkAscii_closure;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8Kux_closure;
         const lvl1_r8Kuy_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.Latin1.ascii2_closure;
         const lvl2_r8Kuz_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const lvl3_r8KuA_closure;
         const lvl4_r8KuB_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_closure;
         const lvl5_r8KuC_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.737087356 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:55.740694398 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin5_closure" {
     GHC.IO.Encoding.Latin1.latin5_closure:
         const GHC.IO.Encoding.Latin1.latin5_info;
 },
 sat_s8Lve_entry() //  [R1]
         { info_tbl: [(c8LB9,
                       label: sat_s8Lve_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LB9: // global
           _s8Lve::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LBa; else goto c8LBb;
       c8LBb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LBd; else goto c8LBc;
       c8LBd: // global
           HpAlloc = 56;
           goto c8LBa;
       c8LBa: // global
           R1 = _s8Lve::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LBc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lve::P64;
           _s8Lv0::I64 = I64[_s8Lve::P64 + 56];
           _s8Lva::I64 = I64[_s8Lve::P64 + 64];
           if (_s8Lva::I64 == _s8Lv0::I64) goto c8LB8; else goto c8LB7;
       c8LB8: // global
           _s8Lv8::P64 = P64[_s8Lve::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Lv8::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LB7: // global
           _s8LuW::P64 = P64[_s8Lve::P64 + 16];
           _s8LuX::P64 = P64[_s8Lve::P64 + 24];
           _s8LuV::I64 = I64[_s8Lve::P64 + 40];
           _s8LuY::I64 = I64[_s8Lve::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LuW::P64;
           P64[Hp - 32] = _s8LuX::P64;
           I64[Hp - 24] = _s8LuV::I64;
           I64[Hp - 16] = _s8LuY::I64;
           I64[Hp - 8] = _s8Lva::I64;
           I64[Hp] = _s8Lv0::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Lvm_entry() //  [R1]
         { info_tbl: [(c8LBv,
                       label: sat_s8Lvm_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LBv: // global
           _s8Lvm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LBw; else goto c8LBx;
       c8LBx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LBz; else goto c8LBy;
       c8LBz: // global
           HpAlloc = 56;
           goto c8LBw;
       c8LBw: // global
           R1 = _s8Lvm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LBy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lvm::P64;
           _s8Lv0::I64 = I64[_s8Lvm::P64 + 56];
           _s8Lvi::I64 = I64[_s8Lvm::P64 + 64];
           if (_s8Lvi::I64 == _s8Lv0::I64) goto c8LBu; else goto c8LBt;
       c8LBu: // global
           _s8Lv8::P64 = P64[_s8Lvm::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Lv8::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LBt: // global
           _s8LuW::P64 = P64[_s8Lvm::P64 + 16];
           _s8LuX::P64 = P64[_s8Lvm::P64 + 24];
           _s8LuV::I64 = I64[_s8Lvm::P64 + 40];
           _s8LuY::I64 = I64[_s8Lvm::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LuW::P64;
           P64[Hp - 32] = _s8LuX::P64;
           I64[Hp - 24] = _s8LuV::I64;
           I64[Hp - 16] = _s8LuY::I64;
           I64[Hp - 8] = _s8Lvi::I64;
           I64[Hp] = _s8Lv0::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin5_entry() //  [R2, R3]
         { info_tbl: [(c8LBC,
                       label: GHC.IO.Encoding.Latin1.latin5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LBC: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LBD; else goto c8LBE;
       c8LBD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LBE: // global
           I64[Sp - 16] = block_c8LAJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LCt; else goto c8LAK;
       u8LCt: // global
           call _c8LAJ(R1) args: 0, res: 0, upd: 0;
       c8LAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LAJ() //  [R1]
         { info_tbl: [(c8LAJ,
                       label: block_c8LAJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LAJ: // global
           I64[Sp - 40] = block_c8LAO_info;
           _s8LuW::P64 = P64[R1 + 7];
           _s8LuX::P64 = P64[R1 + 15];
           _s8LuV::I64 = I64[R1 + 23];
           _s8LuY::I64 = I64[R1 + 31];
           _s8LuZ::I64 = I64[R1 + 39];
           _s8Lv0::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LuX::P64;
           I64[Sp - 24] = _s8LuY::I64;
           I64[Sp - 16] = _s8LuZ::I64;
           I64[Sp - 8] = _s8Lv0::I64;
           P64[Sp] = _s8LuW::P64;
           I64[Sp + 8] = _s8LuV::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LCq; else goto c8LAP;
       u8LCq: // global
           call _c8LAO(R1) args: 0, res: 0, upd: 0;
       c8LAP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LAO() //  [R1]
         { info_tbl: [(c8LAO,
                       label: block_c8LAO_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LAO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LBI; else goto c8LBH;
       c8LBI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LBH: // global
           _s8Lv3::P64 = P64[R1 + 7];
           _s8Lv4::P64 = P64[R1 + 15];
           _s8Lv2::I64 = I64[R1 + 23];
           _s8Lv5::I64 = I64[R1 + 31];
           _s8Lv6::I64 = I64[R1 + 39];
           _s8Lv7::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8LuW::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8LuW::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8LuV::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8LuV::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Lv0::I64 = I64[Sp + 32];
           _c8LAT::P64 = Hp - 47;
           _s8Lvr::I64 = _s8Lv7::I64;
           _s8Lvq::I64 = I64[Sp + 24];
           goto c8LBT;
       c8LBT: // global
           if (%MO_S_Lt_W64(_s8Lvr::I64,
                            _s8Lv5::I64)) goto c8LC6; else goto c8LC7;
       c8LC6: // global
           if (%MO_S_Lt_W64(_s8Lvq::I64,
                            _s8Lv0::I64)) goto c8LC3; else goto c8LC4;
       c8LC3: // global
           _s8Lvy::I64 = %MO_UU_Conv_W8_W64(I8[_s8LuV::I64 + _s8Lvq::I64]);
           call MO_Touch(_s8LuW::P64);
           I32[_s8Lv2::I64 + (_s8Lvr::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Lvy::I64);
           call MO_Touch(_s8Lv3::P64);
           _s8Lvr::I64 = _s8Lvr::I64 + 1;
           _s8Lvq::I64 = _s8Lvq::I64 + 1;
           goto c8LBT;
       c8LC4: // global
           P64[Sp - 48] = _s8Lv3::P64;
           P64[Sp - 40] = _s8Lv4::P64;
           I64[Sp - 32] = _s8Lv5::I64;
           I64[Sp - 24] = _s8Lv6::I64;
           I64[Sp - 16] = _s8Lvq::I64;
           I64[Sp - 8] = _s8Lvr::I64;
           I64[Sp] = _s8Lv2::I64;
           P64[Sp + 24] = _c8LAT::P64;
           Sp = Sp - 56;
           call _c8LAW() args: 0, res: 0, upd: 0;
       c8LC7: // global
           P64[Sp - 48] = _s8Lv3::P64;
           P64[Sp - 40] = _s8Lv4::P64;
           I64[Sp - 32] = _s8Lv5::I64;
           I64[Sp - 24] = _s8Lv6::I64;
           I64[Sp - 16] = _s8Lvq::I64;
           I64[Sp - 8] = _s8Lvr::I64;
           I64[Sp] = _s8Lv2::I64;
           P64[Sp + 24] = _c8LAT::P64;
           Sp = Sp - 56;
           call _c8LBi() args: 0, res: 0, upd: 0;
     }
 },
 _c8LAW() //  []
         { info_tbl: [(c8LAW,
                       label: block_c8LAW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LAW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LBM; else goto c8LBL;
       c8LBM: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LAW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LBL: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lve_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LBi() //  []
         { info_tbl: [(c8LBi,
                       label: block_c8LBi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LBi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LBQ; else goto c8LBP;
       c8LBQ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LBi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LBP: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lvm_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.763857399 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_decode_closure" {
     GHC.IO.Encoding.Latin1.latin1_decode_closure:
         const GHC.IO.Encoding.Latin1.latin1_decode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_decode_entry() //  [R2, R3]
         { info_tbl: [(c8LDU,
                       label: GHC.IO.Encoding.Latin1.latin1_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LDU: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.7712496 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii5_closure" {
     GHC.IO.Encoding.Latin1.ascii5_closure:
         const GHC.IO.Encoding.Latin1.ascii5_info;
 },
 sat_s8Lw3_entry() //  [R1]
         { info_tbl: [(c8LEv,
                       label: sat_s8Lw3_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LEv: // global
           _s8Lw3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LEw; else goto c8LEx;
       c8LEx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LEz; else goto c8LEy;
       c8LEz: // global
           HpAlloc = 56;
           goto c8LEw;
       c8LEw: // global
           R1 = _s8Lw3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LEy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lw3::P64;
           _s8LvP::I64 = I64[_s8Lw3::P64 + 56];
           _s8LvZ::I64 = I64[_s8Lw3::P64 + 64];
           if (_s8LvZ::I64 == _s8LvP::I64) goto c8LEu; else goto c8LEt;
       c8LEu: // global
           _s8LvX::P64 = P64[_s8Lw3::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LvX::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LEt: // global
           _s8LvL::P64 = P64[_s8Lw3::P64 + 16];
           _s8LvM::P64 = P64[_s8Lw3::P64 + 24];
           _s8LvK::I64 = I64[_s8Lw3::P64 + 40];
           _s8LvN::I64 = I64[_s8Lw3::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LvL::P64;
           P64[Hp - 32] = _s8LvM::P64;
           I64[Hp - 24] = _s8LvK::I64;
           I64[Hp - 16] = _s8LvN::I64;
           I64[Hp - 8] = _s8LvZ::I64;
           I64[Hp] = _s8LvP::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Lwb_entry() //  [R1]
         { info_tbl: [(c8LER,
                       label: sat_s8Lwb_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LER: // global
           _s8Lwb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LES; else goto c8LET;
       c8LET: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LEV; else goto c8LEU;
       c8LEV: // global
           HpAlloc = 56;
           goto c8LES;
       c8LES: // global
           R1 = _s8Lwb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LEU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lwb::P64;
           _s8LvP::I64 = I64[_s8Lwb::P64 + 56];
           _s8Lw7::I64 = I64[_s8Lwb::P64 + 64];
           if (_s8Lw7::I64 == _s8LvP::I64) goto c8LEQ; else goto c8LEP;
       c8LEQ: // global
           _s8LvX::P64 = P64[_s8Lwb::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LvX::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LEP: // global
           _s8LvL::P64 = P64[_s8Lwb::P64 + 16];
           _s8LvM::P64 = P64[_s8Lwb::P64 + 24];
           _s8LvK::I64 = I64[_s8Lwb::P64 + 40];
           _s8LvN::I64 = I64[_s8Lwb::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LvL::P64;
           P64[Hp - 32] = _s8LvM::P64;
           I64[Hp - 24] = _s8LvK::I64;
           I64[Hp - 16] = _s8LvN::I64;
           I64[Hp - 8] = _s8Lw7::I64;
           I64[Hp] = _s8LvP::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Lwj_entry() //  [R1]
         { info_tbl: [(c8LFd,
                       label: sat_s8Lwj_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LFd: // global
           _s8Lwj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LFe; else goto c8LFf;
       c8LFf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LFh; else goto c8LFg;
       c8LFh: // global
           HpAlloc = 56;
           goto c8LFe;
       c8LFe: // global
           R1 = _s8Lwj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lwj::P64;
           _s8LvP::I64 = I64[_s8Lwj::P64 + 56];
           _s8Lwf::I64 = I64[_s8Lwj::P64 + 64];
           if (_s8Lwf::I64 == _s8LvP::I64) goto c8LFc; else goto c8LFb;
       c8LFc: // global
           _s8LvX::P64 = P64[_s8Lwj::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LvX::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LFb: // global
           _s8LvL::P64 = P64[_s8Lwj::P64 + 16];
           _s8LvM::P64 = P64[_s8Lwj::P64 + 24];
           _s8LvK::I64 = I64[_s8Lwj::P64 + 40];
           _s8LvN::I64 = I64[_s8Lwj::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LvL::P64;
           P64[Hp - 32] = _s8LvM::P64;
           I64[Hp - 24] = _s8LvK::I64;
           I64[Hp - 16] = _s8LvN::I64;
           I64[Hp - 8] = _s8Lwf::I64;
           I64[Hp] = _s8LvP::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.ascii5_entry() //  [R2, R3]
         { info_tbl: [(c8LFk,
                       label: GHC.IO.Encoding.Latin1.ascii5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LFk: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LFl; else goto c8LFm;
       c8LFl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LFm: // global
           I64[Sp - 16] = block_c8LE5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LGn; else goto c8LE6;
       u8LGn: // global
           call _c8LE5(R1) args: 0, res: 0, upd: 0;
       c8LE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LE5() //  [R1]
         { info_tbl: [(c8LE5,
                       label: block_c8LE5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LE5: // global
           I64[Sp - 40] = block_c8LEa_info;
           _s8LvL::P64 = P64[R1 + 7];
           _s8LvM::P64 = P64[R1 + 15];
           _s8LvK::I64 = I64[R1 + 23];
           _s8LvN::I64 = I64[R1 + 31];
           _s8LvO::I64 = I64[R1 + 39];
           _s8LvP::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LvM::P64;
           I64[Sp - 24] = _s8LvN::I64;
           I64[Sp - 16] = _s8LvO::I64;
           I64[Sp - 8] = _s8LvP::I64;
           P64[Sp] = _s8LvL::P64;
           I64[Sp + 8] = _s8LvK::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LGj; else goto c8LEb;
       u8LGj: // global
           call _c8LEa(R1) args: 0, res: 0, upd: 0;
       c8LEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LEa() //  [R1]
         { info_tbl: [(c8LEa,
                       label: block_c8LEa_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LEa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LFq; else goto c8LFp;
       c8LFq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LFp: // global
           _s8LvS::P64 = P64[R1 + 7];
           _s8LvT::P64 = P64[R1 + 15];
           _s8LvR::I64 = I64[R1 + 23];
           _s8LvU::I64 = I64[R1 + 31];
           _s8LvV::I64 = I64[R1 + 39];
           _s8LvW::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8LvL::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8LvL::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8LvK::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8LvK::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8LvP::I64 = I64[Sp + 32];
           _c8LEf::P64 = Hp - 47;
           _s8Lwo::I64 = _s8LvW::I64;
           _s8Lwn::I64 = I64[Sp + 24];
           goto c8LFF;
       c8LFF: // global
           if (%MO_S_Lt_W64(_s8Lwo::I64,
                            _s8LvU::I64)) goto c8LG2; else goto c8LG3;
       c8LG2: // global
           if (%MO_S_Lt_W64(_s8Lwn::I64,
                            _s8LvP::I64)) goto c8LFZ; else goto c8LG0;
       c8LFZ: // global
           _s8Lwv::I64 = %MO_UU_Conv_W8_W64(I8[_s8LvK::I64 + _s8Lwn::I64]);
           call MO_Touch(_s8LvL::P64);
           if (_s8Lwv::I64 <= 127) goto c8LFW; else goto c8LFX;
       c8LFW: // global
           I32[_s8LvR::I64 + (_s8Lwo::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8Lwv::I64);
           call MO_Touch(_s8LvS::P64);
           _s8Lwo::I64 = _s8Lwo::I64 + 1;
           _s8Lwn::I64 = _s8Lwn::I64 + 1;
           goto c8LFF;
       c8LFX: // global
           P64[Sp - 48] = _s8LvS::P64;
           P64[Sp - 40] = _s8LvT::P64;
           I64[Sp - 32] = _s8LvU::I64;
           I64[Sp - 24] = _s8LvV::I64;
           I64[Sp - 16] = _s8Lwn::I64;
           I64[Sp - 8] = _s8Lwo::I64;
           I64[Sp] = _s8LvR::I64;
           P64[Sp + 24] = _c8LEf::P64;
           Sp = Sp - 56;
           call _c8LEi() args: 0, res: 0, upd: 0;
       c8LG0: // global
           P64[Sp - 48] = _s8LvS::P64;
           P64[Sp - 40] = _s8LvT::P64;
           I64[Sp - 32] = _s8LvU::I64;
           I64[Sp - 24] = _s8LvV::I64;
           I64[Sp - 16] = _s8Lwn::I64;
           I64[Sp - 8] = _s8Lwo::I64;
           I64[Sp] = _s8LvR::I64;
           P64[Sp + 24] = _c8LEf::P64;
           Sp = Sp - 56;
           call _c8LEE() args: 0, res: 0, upd: 0;
       c8LG3: // global
           P64[Sp - 48] = _s8LvS::P64;
           P64[Sp - 40] = _s8LvT::P64;
           I64[Sp - 32] = _s8LvU::I64;
           I64[Sp - 24] = _s8LvV::I64;
           I64[Sp - 16] = _s8Lwn::I64;
           I64[Sp - 8] = _s8Lwo::I64;
           I64[Sp] = _s8LvR::I64;
           P64[Sp + 24] = _c8LEf::P64;
           Sp = Sp - 56;
           call _c8LF0() args: 0, res: 0, upd: 0;
     }
 },
 _c8LEi() //  []
         { info_tbl: [(c8LEi,
                       label: block_c8LEi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LEi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LFu; else goto c8LFt;
       c8LFu: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LEi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LFt: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lw3_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LEE() //  []
         { info_tbl: [(c8LEE,
                       label: block_c8LEE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LEE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LFy; else goto c8LFx;
       c8LFy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LEE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LFx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lwb_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LF0() //  []
         { info_tbl: [(c8LF0,
                       label: block_c8LF0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LF0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LFC; else goto c8LFB;
       c8LFC: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LF0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LFB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lwj_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.800129048 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_decode_closure" {
     GHC.IO.Encoding.Latin1.ascii_decode_closure:
         const GHC.IO.Encoding.Latin1.ascii_decode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_decode_entry() //  [R2, R3]
         { info_tbl: [(c8LIl,
                       label: GHC.IO.Encoding.Latin1.ascii_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LIl: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii5_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.805849488 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin3_closure" {
     GHC.IO.Encoding.Latin1.latin3_closure:
         const GHC.IO.Encoding.Latin1.latin3_info;
 },
 sat_s8Lx1_entry() //  [R1]
         { info_tbl: [(c8LIW,
                       label: sat_s8Lx1_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LIW: // global
           _s8Lx1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LIX; else goto c8LIY;
       c8LIY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LJ0; else goto c8LIZ;
       c8LJ0: // global
           HpAlloc = 56;
           goto c8LIX;
       c8LIX: // global
           R1 = _s8Lx1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LIZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lx1::P64;
           _s8LwN::I64 = I64[_s8Lx1::P64 + 56];
           _s8LwX::I64 = I64[_s8Lx1::P64 + 64];
           if (_s8LwX::I64 == _s8LwN::I64) goto c8LIV; else goto c8LIU;
       c8LIV: // global
           _s8LwV::P64 = P64[_s8Lx1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LwV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LIU: // global
           _s8LwJ::P64 = P64[_s8Lx1::P64 + 16];
           _s8LwK::P64 = P64[_s8Lx1::P64 + 24];
           _s8LwI::I64 = I64[_s8Lx1::P64 + 40];
           _s8LwL::I64 = I64[_s8Lx1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LwJ::P64;
           P64[Hp - 32] = _s8LwK::P64;
           I64[Hp - 24] = _s8LwI::I64;
           I64[Hp - 16] = _s8LwL::I64;
           I64[Hp - 8] = _s8LwX::I64;
           I64[Hp] = _s8LwN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Lx9_entry() //  [R1]
         { info_tbl: [(c8LJi,
                       label: sat_s8Lx9_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LJi: // global
           _s8Lx9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LJj; else goto c8LJk;
       c8LJk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LJm; else goto c8LJl;
       c8LJm: // global
           HpAlloc = 56;
           goto c8LJj;
       c8LJj: // global
           R1 = _s8Lx9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LJl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lx9::P64;
           _s8LwN::I64 = I64[_s8Lx9::P64 + 56];
           _s8Lx5::I64 = I64[_s8Lx9::P64 + 64];
           if (_s8Lx5::I64 == _s8LwN::I64) goto c8LJh; else goto c8LJg;
       c8LJh: // global
           _s8LwV::P64 = P64[_s8Lx9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LwV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LJg: // global
           _s8LwJ::P64 = P64[_s8Lx9::P64 + 16];
           _s8LwK::P64 = P64[_s8Lx9::P64 + 24];
           _s8LwI::I64 = I64[_s8Lx9::P64 + 40];
           _s8LwL::I64 = I64[_s8Lx9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8LwJ::P64;
           P64[Hp - 32] = _s8LwK::P64;
           I64[Hp - 24] = _s8LwI::I64;
           I64[Hp - 16] = _s8LwL::I64;
           I64[Hp - 8] = _s8Lx5::I64;
           I64[Hp] = _s8LwN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin3_entry() //  [R2, R3]
         { info_tbl: [(c8LJp,
                       label: GHC.IO.Encoding.Latin1.latin3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LJp: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LJq; else goto c8LJr;
       c8LJq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LJr: // global
           I64[Sp - 16] = block_c8LIw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LKj; else goto c8LIx;
       u8LKj: // global
           call _c8LIw(R1) args: 0, res: 0, upd: 0;
       c8LIx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LIw() //  [R1]
         { info_tbl: [(c8LIw,
                       label: block_c8LIw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LIw: // global
           I64[Sp - 40] = block_c8LIB_info;
           _s8LwJ::P64 = P64[R1 + 7];
           _s8LwK::P64 = P64[R1 + 15];
           _s8LwI::I64 = I64[R1 + 23];
           _s8LwL::I64 = I64[R1 + 31];
           _s8LwM::I64 = I64[R1 + 39];
           _s8LwN::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LwK::P64;
           I64[Sp - 24] = _s8LwL::I64;
           I64[Sp - 16] = _s8LwM::I64;
           I64[Sp - 8] = _s8LwN::I64;
           P64[Sp] = _s8LwJ::P64;
           I64[Sp + 8] = _s8LwI::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LKg; else goto c8LIC;
       u8LKg: // global
           call _c8LIB(R1) args: 0, res: 0, upd: 0;
       c8LIC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LIB() //  [R1]
         { info_tbl: [(c8LIB,
                       label: block_c8LIB_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LIB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LJv; else goto c8LJu;
       c8LJv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LJu: // global
           _s8LwQ::P64 = P64[R1 + 7];
           _s8LwR::P64 = P64[R1 + 15];
           _s8LwP::I64 = I64[R1 + 23];
           _s8LwS::I64 = I64[R1 + 31];
           _s8LwT::I64 = I64[R1 + 39];
           _s8LwU::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8LwJ::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8LwJ::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8LwI::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8LwI::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8LwN::I64 = I64[Sp + 32];
           _c8LIG::P64 = Hp - 47;
           _s8Lxe::I64 = _s8LwU::I64;
           _s8Lxd::I64 = I64[Sp + 24];
           goto c8LJG;
       c8LJG: // global
           if (%MO_S_Lt_W64(_s8Lxe::I64,
                            _s8LwS::I64)) goto c8LJT; else goto c8LJU;
       c8LJT: // global
           if (%MO_S_Lt_W64(_s8Lxd::I64,
                            _s8LwN::I64)) goto c8LJQ; else goto c8LJR;
       c8LJQ: // global
           _s8Lxk::I64 = %MO_UU_Conv_W32_W64(I32[_s8LwI::I64 + (_s8Lxd::I64 << 2)]);
           call MO_Touch(_s8LwJ::P64);
           I8[_s8LwP::I64 + _s8Lxe::I64] = %MO_UU_Conv_W64_W8(_s8Lxk::I64);
           call MO_Touch(_s8LwQ::P64);
           _s8Lxe::I64 = _s8Lxe::I64 + 1;
           _s8Lxd::I64 = _s8Lxd::I64 + 1;
           goto c8LJG;
       c8LJR: // global
           P64[Sp - 48] = _s8LwQ::P64;
           P64[Sp - 40] = _s8LwR::P64;
           I64[Sp - 32] = _s8LwS::I64;
           I64[Sp - 24] = _s8LwT::I64;
           I64[Sp - 16] = _s8Lxd::I64;
           I64[Sp - 8] = _s8Lxe::I64;
           I64[Sp] = _s8LwP::I64;
           P64[Sp + 24] = _c8LIG::P64;
           Sp = Sp - 56;
           call _c8LIJ() args: 0, res: 0, upd: 0;
       c8LJU: // global
           P64[Sp - 48] = _s8LwQ::P64;
           P64[Sp - 40] = _s8LwR::P64;
           I64[Sp - 32] = _s8LwS::I64;
           I64[Sp - 24] = _s8LwT::I64;
           I64[Sp - 16] = _s8Lxd::I64;
           I64[Sp - 8] = _s8Lxe::I64;
           I64[Sp] = _s8LwP::I64;
           P64[Sp + 24] = _c8LIG::P64;
           Sp = Sp - 56;
           call _c8LJ5() args: 0, res: 0, upd: 0;
     }
 },
 _c8LIJ() //  []
         { info_tbl: [(c8LIJ,
                       label: block_c8LIJ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LIJ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LJz; else goto c8LJy;
       c8LJz: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LIJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LJy: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lx1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LJ5() //  []
         { info_tbl: [(c8LJ5,
                       label: block_c8LJ5_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LJ5: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LJD; else goto c8LJC;
       c8LJD: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LJ5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LJC: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lx9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.829978189 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_encode_entry() //  [R2, R3]
         { info_tbl: [(c8LLL,
                       label: GHC.IO.Encoding.Latin1.latin1_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LLL: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.835857958 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii3_closure" {
     GHC.IO.Encoding.Latin1.ascii3_closure:
         const GHC.IO.Encoding.Latin1.ascii3_info;
 },
 sat_s8LxR_entry() //  [R1]
         { info_tbl: [(c8LMm,
                       label: sat_s8LxR_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LMm: // global
           _s8LxR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LMn; else goto c8LMo;
       c8LMo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LMq; else goto c8LMp;
       c8LMq: // global
           HpAlloc = 56;
           goto c8LMn;
       c8LMn: // global
           R1 = _s8LxR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LMp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8LxR::P64;
           _s8LxD::I64 = I64[_s8LxR::P64 + 56];
           _s8LxN::I64 = I64[_s8LxR::P64 + 64];
           if (_s8LxN::I64 == _s8LxD::I64) goto c8LMl; else goto c8LMk;
       c8LMl: // global
           _s8LxL::P64 = P64[_s8LxR::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LxL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LMk: // global
           _s8Lxz::P64 = P64[_s8LxR::P64 + 16];
           _s8LxA::P64 = P64[_s8LxR::P64 + 24];
           _s8Lxy::I64 = I64[_s8LxR::P64 + 40];
           _s8LxB::I64 = I64[_s8LxR::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lxz::P64;
           P64[Hp - 32] = _s8LxA::P64;
           I64[Hp - 24] = _s8Lxy::I64;
           I64[Hp - 16] = _s8LxB::I64;
           I64[Hp - 8] = _s8LxN::I64;
           I64[Hp] = _s8LxD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8LxZ_entry() //  [R1]
         { info_tbl: [(c8LMI,
                       label: sat_s8LxZ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LMI: // global
           _s8LxZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LMJ; else goto c8LMK;
       c8LMK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LMM; else goto c8LML;
       c8LMM: // global
           HpAlloc = 56;
           goto c8LMJ;
       c8LMJ: // global
           R1 = _s8LxZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LML: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8LxZ::P64;
           _s8LxD::I64 = I64[_s8LxZ::P64 + 56];
           _s8LxV::I64 = I64[_s8LxZ::P64 + 64];
           if (_s8LxV::I64 == _s8LxD::I64) goto c8LMH; else goto c8LMG;
       c8LMH: // global
           _s8LxL::P64 = P64[_s8LxZ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LxL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LMG: // global
           _s8Lxz::P64 = P64[_s8LxZ::P64 + 16];
           _s8LxA::P64 = P64[_s8LxZ::P64 + 24];
           _s8Lxy::I64 = I64[_s8LxZ::P64 + 40];
           _s8LxB::I64 = I64[_s8LxZ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lxz::P64;
           P64[Hp - 32] = _s8LxA::P64;
           I64[Hp - 24] = _s8Lxy::I64;
           I64[Hp - 16] = _s8LxB::I64;
           I64[Hp - 8] = _s8LxV::I64;
           I64[Hp] = _s8LxD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Ly7_entry() //  [R1]
         { info_tbl: [(c8LN4,
                       label: sat_s8Ly7_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LN4: // global
           _s8Ly7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LN5; else goto c8LN6;
       c8LN6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LN8; else goto c8LN7;
       c8LN8: // global
           HpAlloc = 56;
           goto c8LN5;
       c8LN5: // global
           R1 = _s8Ly7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LN7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Ly7::P64;
           _s8LxD::I64 = I64[_s8Ly7::P64 + 56];
           _s8Ly3::I64 = I64[_s8Ly7::P64 + 64];
           if (_s8Ly3::I64 == _s8LxD::I64) goto c8LN3; else goto c8LN2;
       c8LN3: // global
           _s8LxL::P64 = P64[_s8Ly7::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LxL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LN2: // global
           _s8Lxz::P64 = P64[_s8Ly7::P64 + 16];
           _s8LxA::P64 = P64[_s8Ly7::P64 + 24];
           _s8Lxy::I64 = I64[_s8Ly7::P64 + 40];
           _s8LxB::I64 = I64[_s8Ly7::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lxz::P64;
           P64[Hp - 32] = _s8LxA::P64;
           I64[Hp - 24] = _s8Lxy::I64;
           I64[Hp - 16] = _s8LxB::I64;
           I64[Hp - 8] = _s8Ly3::I64;
           I64[Hp] = _s8LxD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.ascii3_entry() //  [R2, R3]
         { info_tbl: [(c8LNb,
                       label: GHC.IO.Encoding.Latin1.ascii3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LNb: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LNc; else goto c8LNd;
       c8LNc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LNd: // global
           I64[Sp - 16] = block_c8LLW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LOk; else goto c8LLX;
       u8LOk: // global
           call _c8LLW(R1) args: 0, res: 0, upd: 0;
       c8LLX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LLW() //  [R1]
         { info_tbl: [(c8LLW,
                       label: block_c8LLW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LLW: // global
           I64[Sp - 40] = block_c8LM1_info;
           _s8Lxz::P64 = P64[R1 + 7];
           _s8LxA::P64 = P64[R1 + 15];
           _s8Lxy::I64 = I64[R1 + 23];
           _s8LxB::I64 = I64[R1 + 31];
           _s8LxC::I64 = I64[R1 + 39];
           _s8LxD::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LxA::P64;
           I64[Sp - 24] = _s8LxB::I64;
           I64[Sp - 16] = _s8LxC::I64;
           I64[Sp - 8] = _s8LxD::I64;
           P64[Sp] = _s8Lxz::P64;
           I64[Sp + 8] = _s8Lxy::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LOg; else goto c8LM2;
       u8LOg: // global
           call _c8LM1(R1) args: 0, res: 0, upd: 0;
       c8LM2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LM1() //  [R1]
         { info_tbl: [(c8LM1,
                       label: block_c8LM1_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LM1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LNh; else goto c8LNg;
       c8LNh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LNg: // global
           _s8LxG::P64 = P64[R1 + 7];
           _s8LxH::P64 = P64[R1 + 15];
           _s8LxF::I64 = I64[R1 + 23];
           _s8LxI::I64 = I64[R1 + 31];
           _s8LxJ::I64 = I64[R1 + 39];
           _s8LxK::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Lxz::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Lxz::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Lxy::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Lxy::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8LxD::I64 = I64[Sp + 32];
           _c8LM6::P64 = Hp - 47;
           _s8Lyc::I64 = _s8LxK::I64;
           _s8Lyb::I64 = I64[Sp + 24];
           goto c8LNw;
       c8LNw: // global
           if (%MO_S_Lt_W64(_s8Lyc::I64,
                            _s8LxI::I64)) goto c8LNT; else goto c8LNU;
       c8LNT: // global
           if (%MO_S_Lt_W64(_s8Lyb::I64,
                            _s8LxD::I64)) goto c8LNQ; else goto c8LNR;
       c8LNQ: // global
           _s8Lyi::I64 = %MO_UU_Conv_W32_W64(I32[_s8Lxy::I64 + (_s8Lyb::I64 << 2)]);
           call MO_Touch(_s8Lxz::P64);
           if (%MO_S_Le_W64(_s8Lyi::I64, 127)) goto c8LNN; else goto c8LNO;
       c8LNN: // global
           I8[_s8LxF::I64 + _s8Lyc::I64] = %MO_UU_Conv_W64_W8(_s8Lyi::I64);
           call MO_Touch(_s8LxG::P64);
           _s8Lyc::I64 = _s8Lyc::I64 + 1;
           _s8Lyb::I64 = _s8Lyb::I64 + 1;
           goto c8LNw;
       c8LNO: // global
           P64[Sp - 48] = _s8LxG::P64;
           P64[Sp - 40] = _s8LxH::P64;
           I64[Sp - 32] = _s8LxI::I64;
           I64[Sp - 24] = _s8LxJ::I64;
           I64[Sp - 16] = _s8Lyb::I64;
           I64[Sp - 8] = _s8Lyc::I64;
           I64[Sp] = _s8LxF::I64;
           P64[Sp + 24] = _c8LM6::P64;
           Sp = Sp - 56;
           call _c8LM9() args: 0, res: 0, upd: 0;
       c8LNR: // global
           P64[Sp - 48] = _s8LxG::P64;
           P64[Sp - 40] = _s8LxH::P64;
           I64[Sp - 32] = _s8LxI::I64;
           I64[Sp - 24] = _s8LxJ::I64;
           I64[Sp - 16] = _s8Lyb::I64;
           I64[Sp - 8] = _s8Lyc::I64;
           I64[Sp] = _s8LxF::I64;
           P64[Sp + 24] = _c8LM6::P64;
           Sp = Sp - 56;
           call _c8LMv() args: 0, res: 0, upd: 0;
       c8LNU: // global
           P64[Sp - 48] = _s8LxG::P64;
           P64[Sp - 40] = _s8LxH::P64;
           I64[Sp - 32] = _s8LxI::I64;
           I64[Sp - 24] = _s8LxJ::I64;
           I64[Sp - 16] = _s8Lyb::I64;
           I64[Sp - 8] = _s8Lyc::I64;
           I64[Sp] = _s8LxF::I64;
           P64[Sp + 24] = _c8LM6::P64;
           Sp = Sp - 56;
           call _c8LMR() args: 0, res: 0, upd: 0;
     }
 },
 _c8LM9() //  []
         { info_tbl: [(c8LM9,
                       label: block_c8LM9_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LM9: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LNl; else goto c8LNk;
       c8LNl: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LM9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LNk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8LxR_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LMv() //  []
         { info_tbl: [(c8LMv,
                       label: block_c8LMv_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LMv: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LNp; else goto c8LNo;
       c8LNp: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LMv_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LNo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8LxZ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LMR() //  []
         { info_tbl: [(c8LMR,
                       label: block_c8LMR_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LMR: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LNt; else goto c8LNs;
       c8LNt: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LMR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LNs: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Ly7_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.862729847 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_encode_closure" {
     GHC.IO.Encoding.Latin1.ascii_encode_closure:
         const GHC.IO.Encoding.Latin1.ascii_encode_info;
 },
 GHC.IO.Encoding.Latin1.ascii_encode_entry() //  [R2, R3]
         { info_tbl: [(c8LQj,
                       label: GHC.IO.Encoding.Latin1.ascii_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LQj: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.ascii3_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.868652527 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked2_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked2_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked2_info;
 },
 sat_s8LyR_entry() //  [R1]
         { info_tbl: [(c8LQU,
                       label: sat_s8LyR_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LQU: // global
           _s8LyR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LQV; else goto c8LQW;
       c8LQW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LQY; else goto c8LQX;
       c8LQY: // global
           HpAlloc = 56;
           goto c8LQV;
       c8LQV: // global
           R1 = _s8LyR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LQX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8LyR::P64;
           _s8LyD::I64 = I64[_s8LyR::P64 + 56];
           _s8LyN::I64 = I64[_s8LyR::P64 + 64];
           if (_s8LyN::I64 == _s8LyD::I64) goto c8LQT; else goto c8LQS;
       c8LQT: // global
           _s8LyL::P64 = P64[_s8LyR::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LyL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LQS: // global
           _s8Lyz::P64 = P64[_s8LyR::P64 + 16];
           _s8LyA::P64 = P64[_s8LyR::P64 + 24];
           _s8Lyy::I64 = I64[_s8LyR::P64 + 40];
           _s8LyB::I64 = I64[_s8LyR::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lyz::P64;
           P64[Hp - 32] = _s8LyA::P64;
           I64[Hp - 24] = _s8Lyy::I64;
           I64[Hp - 16] = _s8LyB::I64;
           I64[Hp - 8] = _s8LyN::I64;
           I64[Hp] = _s8LyD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8LyZ_entry() //  [R1]
         { info_tbl: [(c8LRg,
                       label: sat_s8LyZ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LRg: // global
           _s8LyZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LRh; else goto c8LRi;
       c8LRi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LRk; else goto c8LRj;
       c8LRk: // global
           HpAlloc = 56;
           goto c8LRh;
       c8LRh: // global
           R1 = _s8LyZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LRj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8LyZ::P64;
           _s8LyD::I64 = I64[_s8LyZ::P64 + 56];
           _s8LyV::I64 = I64[_s8LyZ::P64 + 64];
           if (_s8LyV::I64 == _s8LyD::I64) goto c8LRf; else goto c8LRe;
       c8LRf: // global
           _s8LyL::P64 = P64[_s8LyZ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LyL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LRe: // global
           _s8Lyz::P64 = P64[_s8LyZ::P64 + 16];
           _s8LyA::P64 = P64[_s8LyZ::P64 + 24];
           _s8Lyy::I64 = I64[_s8LyZ::P64 + 40];
           _s8LyB::I64 = I64[_s8LyZ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lyz::P64;
           P64[Hp - 32] = _s8LyA::P64;
           I64[Hp - 24] = _s8Lyy::I64;
           I64[Hp - 16] = _s8LyB::I64;
           I64[Hp - 8] = _s8LyV::I64;
           I64[Hp] = _s8LyD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Lz7_entry() //  [R1]
         { info_tbl: [(c8LRC,
                       label: sat_s8Lz7_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LRC: // global
           _s8Lz7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8LRD; else goto c8LRE;
       c8LRE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LRG; else goto c8LRF;
       c8LRG: // global
           HpAlloc = 56;
           goto c8LRD;
       c8LRD: // global
           R1 = _s8Lz7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LRF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Lz7::P64;
           _s8LyD::I64 = I64[_s8Lz7::P64 + 56];
           _s8Lz3::I64 = I64[_s8Lz7::P64 + 64];
           if (_s8Lz3::I64 == _s8LyD::I64) goto c8LRB; else goto c8LRA;
       c8LRB: // global
           _s8LyL::P64 = P64[_s8Lz7::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8LyL::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8LRA: // global
           _s8Lyz::P64 = P64[_s8Lz7::P64 + 16];
           _s8LyA::P64 = P64[_s8Lz7::P64 + 24];
           _s8Lyy::I64 = I64[_s8Lz7::P64 + 40];
           _s8LyB::I64 = I64[_s8Lz7::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Lyz::P64;
           P64[Hp - 32] = _s8LyA::P64;
           I64[Hp - 24] = _s8Lyy::I64;
           I64[Hp - 16] = _s8LyB::I64;
           I64[Hp - 8] = _s8Lz3::I64;
           I64[Hp] = _s8LyD::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.Latin1.latin1_checked2_entry() //  [R2, R3]
         { info_tbl: [(c8LRJ,
                       label: GHC.IO.Encoding.Latin1.latin1_checked2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LRJ: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8LRK; else goto c8LRL;
       c8LRK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.latin1_checked2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LRL: // global
           I64[Sp - 16] = block_c8LQu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LSS; else goto c8LQv;
       u8LSS: // global
           call _c8LQu(R1) args: 0, res: 0, upd: 0;
       c8LQv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LQu() //  [R1]
         { info_tbl: [(c8LQu,
                       label: block_c8LQu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LQu: // global
           I64[Sp - 40] = block_c8LQz_info;
           _s8Lyz::P64 = P64[R1 + 7];
           _s8LyA::P64 = P64[R1 + 15];
           _s8Lyy::I64 = I64[R1 + 23];
           _s8LyB::I64 = I64[R1 + 31];
           _s8LyC::I64 = I64[R1 + 39];
           _s8LyD::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8LyA::P64;
           I64[Sp - 24] = _s8LyB::I64;
           I64[Sp - 16] = _s8LyC::I64;
           I64[Sp - 8] = _s8LyD::I64;
           P64[Sp] = _s8Lyz::P64;
           I64[Sp + 8] = _s8Lyy::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8LSO; else goto c8LQA;
       u8LSO: // global
           call _c8LQz(R1) args: 0, res: 0, upd: 0;
       c8LQA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LQz() //  [R1]
         { info_tbl: [(c8LQz,
                       label: block_c8LQz_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LQz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8LRP; else goto c8LRO;
       c8LRP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8LRO: // global
           _s8LyG::P64 = P64[R1 + 7];
           _s8LyH::P64 = P64[R1 + 15];
           _s8LyF::I64 = I64[R1 + 23];
           _s8LyI::I64 = I64[R1 + 31];
           _s8LyJ::I64 = I64[R1 + 39];
           _s8LyK::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Lyz::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Lyz::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Lyy::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Lyy::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8LyD::I64 = I64[Sp + 32];
           _c8LQE::P64 = Hp - 47;
           _s8Lzc::I64 = _s8LyK::I64;
           _s8Lzb::I64 = I64[Sp + 24];
           goto c8LS4;
       c8LS4: // global
           if (%MO_S_Lt_W64(_s8Lzc::I64,
                            _s8LyI::I64)) goto c8LSr; else goto c8LSs;
       c8LSr: // global
           if (%MO_S_Lt_W64(_s8Lzb::I64,
                            _s8LyD::I64)) goto c8LSo; else goto c8LSp;
       c8LSo: // global
           _s8Lzi::I64 = %MO_UU_Conv_W32_W64(I32[_s8Lyy::I64 + (_s8Lzb::I64 << 2)]);
           call MO_Touch(_s8Lyz::P64);
           if (%MO_S_Le_W64(_s8Lzi::I64, 255)) goto c8LSl; else goto c8LSm;
       c8LSl: // global
           I8[_s8LyF::I64 + _s8Lzc::I64] = %MO_UU_Conv_W64_W8(_s8Lzi::I64);
           call MO_Touch(_s8LyG::P64);
           _s8Lzc::I64 = _s8Lzc::I64 + 1;
           _s8Lzb::I64 = _s8Lzb::I64 + 1;
           goto c8LS4;
       c8LSm: // global
           P64[Sp - 48] = _s8LyG::P64;
           P64[Sp - 40] = _s8LyH::P64;
           I64[Sp - 32] = _s8LyI::I64;
           I64[Sp - 24] = _s8LyJ::I64;
           I64[Sp - 16] = _s8Lzb::I64;
           I64[Sp - 8] = _s8Lzc::I64;
           I64[Sp] = _s8LyF::I64;
           P64[Sp + 24] = _c8LQE::P64;
           Sp = Sp - 56;
           call _c8LQH() args: 0, res: 0, upd: 0;
       c8LSp: // global
           P64[Sp - 48] = _s8LyG::P64;
           P64[Sp - 40] = _s8LyH::P64;
           I64[Sp - 32] = _s8LyI::I64;
           I64[Sp - 24] = _s8LyJ::I64;
           I64[Sp - 16] = _s8Lzb::I64;
           I64[Sp - 8] = _s8Lzc::I64;
           I64[Sp] = _s8LyF::I64;
           P64[Sp + 24] = _c8LQE::P64;
           Sp = Sp - 56;
           call _c8LR3() args: 0, res: 0, upd: 0;
       c8LSs: // global
           P64[Sp - 48] = _s8LyG::P64;
           P64[Sp - 40] = _s8LyH::P64;
           I64[Sp - 32] = _s8LyI::I64;
           I64[Sp - 24] = _s8LyJ::I64;
           I64[Sp - 16] = _s8Lzb::I64;
           I64[Sp - 8] = _s8Lzc::I64;
           I64[Sp] = _s8LyF::I64;
           P64[Sp + 24] = _c8LQE::P64;
           Sp = Sp - 56;
           call _c8LRp() args: 0, res: 0, upd: 0;
     }
 },
 _c8LQH() //  []
         { info_tbl: [(c8LQH,
                       label: block_c8LQH_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LQH: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LRT; else goto c8LRS;
       c8LRT: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LQH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LRS: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8LyR_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LR3() //  []
         { info_tbl: [(c8LR3,
                       label: block_c8LR3_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LR3: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LRX; else goto c8LRW;
       c8LRX: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LR3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LRW: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8LyZ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8LRp() //  []
         { info_tbl: [(c8LRp,
                       label: block_c8LRp_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LRp: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8LS1; else goto c8LS0;
       c8LS1: // global
           HpAlloc = 160;
           I64[Sp] = block_c8LRp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8LS0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Lz7_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.898197849 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_encode_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_encode_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked_encode_info;
 },
 GHC.IO.Encoding.Latin1.latin1_checked_encode_entry() //  [R2, R3]
         { info_tbl: [(c8LUR,
                       label: GHC.IO.Encoding.Latin1.latin1_checked_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LUR: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.Latin1.latin1_checked2_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.901850413 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule4_bytes" {
     GHC.IO.Encoding.Latin1.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.903782173 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule3_closure" {
     GHC.IO.Encoding.Latin1.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.905932073 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.$trModule2_bytes" {
     GHC.IO.Encoding.Latin1.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,76,97,116,105,110,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.907819726 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule1_closure" {
     GHC.IO.Encoding.Latin1.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.Latin1.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.909754438 UTC

[section ""data" . GHC.IO.Encoding.Latin1.$trModule_closure" {
     GHC.IO.Encoding.Latin1.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.Latin1.$trModule3_closure+1;
         const GHC.IO.Encoding.Latin1.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.911681839 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.ascii7_bytes" {
     GHC.IO.Encoding.Latin1.ascii7_bytes:
         I8[] [65,83,67,73,73]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.914494364 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii6_closure" {
     GHC.IO.Encoding.Latin1.ascii6_closure:
         const GHC.IO.Encoding.Latin1.ascii6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii6_entry() //  [R1]
         { info_tbl: [(c8LVa,
                       label: GHC.IO.Encoding.Latin1.ascii6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LVa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8LVb; else goto c8LVc;
       c8LVb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LVc: // global
           (_c8LV7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8LV7::I64 == 0) goto c8LV9; else goto c8LV8;
       c8LV9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8LV8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8LV7::I64;
           R2 = GHC.IO.Encoding.Latin1.ascii7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.919309637 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii2_closure" {
     GHC.IO.Encoding.Latin1.mkAscii2_closure:
         const GHC.IO.Encoding.Latin1.mkAscii2_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii2_entry() //  []
         { info_tbl: [(c8LVp,
                       label: GHC.IO.Encoding.Latin1.mkAscii2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LVp: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.922984044 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii1_closure" {
     GHC.IO.Encoding.Latin1.mkAscii1_closure:
         const GHC.IO.Encoding.Latin1.mkAscii1_info;
 },
 GHC.IO.Encoding.Latin1.mkAscii1_entry() //  []
         { info_tbl: [(c8LVC,
                       label: GHC.IO.Encoding.Latin1.mkAscii1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LVC: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.927349204 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkAscii_closure" {
     GHC.IO.Encoding.Latin1.mkAscii_closure:
         const GHC.IO.Encoding.Latin1.mkAscii_info;
         const 0;
 },
 sat_s8LzD_entry() //  [R1, R2, R3]
         { info_tbl: [(c8LVZ,
                       label: sat_s8LzD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LVZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8LzF_entry() //  [R1]
         { info_tbl: [(c8LW3,
                       label: sat_s8LzF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LW3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LW7; else goto c8LW6;
       c8LW7: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LW6: // global
           _s8Lzx::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LzD_info;
           P64[Hp - 48] = _s8Lzx::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Lzz_entry() //  [R1, R2, R3]
         { info_tbl: [(c8LWi,
                       label: sat_s8Lzz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LWi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8LzB_entry() //  [R1]
         { info_tbl: [(c8LWm,
                       label: sat_s8LzB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LWm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LWq; else goto c8LWp;
       c8LWq: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LWp: // global
           _s8Lzx::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Lzz_info;
           P64[Hp - 48] = _s8Lzx::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.ascii5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkAscii_entry() //  [R2]
         { info_tbl: [(c8LWs,
                       label: GHC.IO.Encoding.Latin1.mkAscii_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LWs: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LWw; else goto c8LWv;
       c8LWw: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkAscii_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8LWv: // global
           I64[Hp - 56] = sat_s8LzF_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8LzB_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.ascii6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.940668256 UTC

[section ""data" . lvl_r8Kux_closure" {
     lvl_r8Kux_closure:
         const lvl_r8Kux_info;
         const 0;
 },
 lvl_r8Kux_entry() //  [R2, R3]
         { info_tbl: [(c8LXi,
                       label: lvl_r8Kux_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LXi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8LXm; else goto c8LXn;
       c8LXm: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8Kux_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LXn: // global
           I64[Sp - 16] = block_c8LXf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LXv; else goto c8LXg;
       u8LXv: // global
           call _c8LXf() args: 0, res: 0, upd: 0;
       c8LXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LXf() //  []
         { info_tbl: [(c8LXf,
                       label: block_c8LXf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LXf: // global
           _s8LzH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8LXl_info;
           R1 = _s8LzH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8LXu; else goto c8LXp;
       u8LXu: // global
           call _c8LXl() args: 0, res: 0, upd: 0;
       c8LXp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LXl() //  []
         { info_tbl: [(c8LXl,
                       label: block_c8LXl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LXl: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.948597552 UTC

[section ""data" . lvl1_r8Kuy_closure" {
     lvl1_r8Kuy_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.950747253 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii4_closure" {
     GHC.IO.Encoding.Latin1.ascii4_closure:
         const GHC.IO.Encoding.Latin1.ascii4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii4_entry() //  []
         { info_tbl: [(c8LXQ,
                       label: GHC.IO.Encoding.Latin1.ascii4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LXQ: // global
           R1 = lvl1_r8Kuy_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.95593485 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii2_closure" {
     GHC.IO.Encoding.Latin1.ascii2_closure:
         const GHC.IO.Encoding.Latin1.ascii2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii2_entry() //  [R2, R3]
         { info_tbl: [(c8LY5,
                       label: GHC.IO.Encoding.Latin1.ascii2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LY5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8LY9; else goto c8LYa;
       c8LY9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.ascii2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8LYa: // global
           I64[Sp - 16] = block_c8LY2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LYj; else goto c8LY3;
       u8LYj: // global
           call _c8LY2(R1) args: 0, res: 0, upd: 0;
       c8LY3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LY2() //  [R1]
         { info_tbl: [(c8LY2,
                       label: block_c8LY2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LY2: // global
           I64[Sp - 16] = block_c8LY8_info;
           _s8LA3::P64 = P64[R1 + 7];
           _s8LA2::I64 = I64[R1 + 23];
           _s8LA6::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8LA6::I64;
           P64[Sp] = _s8LA3::P64;
           I64[Sp + 8] = _s8LA2::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8LYi; else goto c8LYc;
       u8LYi: // global
           call _c8LY8() args: 0, res: 0, upd: 0;
       c8LYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8LY8() //  []
         { info_tbl: [(c8LY8,
                       label: block_c8LY8_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LY8: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.964051554 UTC

[section ""data" . lvl2_r8Kuz_closure" {
     lvl2_r8Kuz_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.ascii3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.966205577 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii1_closure" {
     GHC.IO.Encoding.Latin1.ascii1_closure:
         const GHC.IO.Encoding.Latin1.ascii1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.ascii1_entry() //  []
         { info_tbl: [(c8LYE,
                       label: GHC.IO.Encoding.Latin1.ascii1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LYE: // global
           R1 = lvl2_r8Kuz_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.969773403 UTC

[section ""data" . GHC.IO.Encoding.Latin1.ascii_closure" {
     GHC.IO.Encoding.Latin1.ascii_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Latin1.ascii4_closure+1;
         const GHC.IO.Encoding.Latin1.ascii1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.971635485 UTC

[section ""cstring" . GHC.IO.Encoding.Latin1.latin7_bytes" {
     GHC.IO.Encoding.Latin1.latin7_bytes:
         I8[] [73,83,79,45,56,56,53,57,45,49]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.973715242 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin6_closure" {
     GHC.IO.Encoding.Latin1.latin6_closure:
         const GHC.IO.Encoding.Latin1.latin6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin6_entry() //  [R1]
         { info_tbl: [(c8LYU,
                       label: GHC.IO.Encoding.Latin1.latin6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LYU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8LYV; else goto c8LYW;
       c8LYV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8LYW: // global
           (_c8LYR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8LYR::I64 == 0) goto c8LYT; else goto c8LYS;
       c8LYT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8LYS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8LYR::I64;
           R2 = GHC.IO.Encoding.Latin1.latin7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.97885469 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_checked_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_checked_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_info;
         const 0;
 },
 sat_s8LAq_entry() //  [R1, R2, R3]
         { info_tbl: [(c8LZj,
                       label: sat_s8LAq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LZj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8LAs_entry() //  [R1]
         { info_tbl: [(c8LZn,
                       label: sat_s8LAs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LZn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LZr; else goto c8LZq;
       c8LZr: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LZq: // global
           _s8LAk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LAq_info;
           P64[Hp - 48] = _s8LAk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8LAm_entry() //  [R1, R2, R3]
         { info_tbl: [(c8LZC,
                       label: sat_s8LAm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LZC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8LAo_entry() //  [R1]
         { info_tbl: [(c8LZG,
                       label: sat_s8LAo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LZG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LZK; else goto c8LZJ;
       c8LZK: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8LZJ: // global
           _s8LAk::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LAm_info;
           P64[Hp - 48] = _s8LAk::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkLatin1_checked_entry() //  [R2]
         { info_tbl: [(c8LZM,
                       label: GHC.IO.Encoding.Latin1.mkLatin1_checked_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LZM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8LZQ; else goto c8LZP;
       c8LZQ: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8LZP: // global
           I64[Hp - 56] = sat_s8LAs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8LAo_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.992462492 UTC

[section ""data" . lvl3_r8KuA_closure" {
     lvl3_r8KuA_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin5_closure+3;
         const lvl_r8Kux_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.994901589 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin4_closure" {
     GHC.IO.Encoding.Latin1.latin4_closure:
         const GHC.IO.Encoding.Latin1.latin4_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin4_entry() //  []
         { info_tbl: [(c8M0z,
                       label: GHC.IO.Encoding.Latin1.latin4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M0z: // global
           R1 = lvl3_r8KuA_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:55.998429097 UTC

[section ""data" . lvl4_r8KuB_closure" {
     lvl4_r8KuB_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin1_checked2_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.000424882 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked1_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked1_closure:
         const GHC.IO.Encoding.Latin1.latin1_checked1_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin1_checked1_entry() //  []
         { info_tbl: [(c8M0M,
                       label: GHC.IO.Encoding.Latin1.latin1_checked1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M0M: // global
           R1 = lvl4_r8KuB_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.004173588 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_checked_closure" {
     GHC.IO.Encoding.Latin1.latin1_checked_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin1_checked1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.006870797 UTC

[section ""data" . GHC.IO.Encoding.Latin1.mkLatin1_closure" {
     GHC.IO.Encoding.Latin1.mkLatin1_closure:
         const GHC.IO.Encoding.Latin1.mkLatin1_info;
         const 0;
 },
 sat_s8LAB_entry() //  [R1, R2, R3]
         { info_tbl: [(c8M19,
                       label: sat_s8LAB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M19: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8LAD_entry() //  [R1]
         { info_tbl: [(c8M1d,
                       label: sat_s8LAD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M1d: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8M1h; else goto c8M1g;
       c8M1h: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8M1g: // global
           _s8LAv::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LAB_info;
           P64[Hp - 48] = _s8LAv::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8LAx_entry() //  [R1, R2, R3]
         { info_tbl: [(c8M1s,
                       label: sat_s8LAx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M1s: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8LAz_entry() //  [R1]
         { info_tbl: [(c8M1w,
                       label: sat_s8LAz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M1w: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8M1A; else goto c8M1z;
       c8M1A: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8M1z: // global
           _s8LAv::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8LAx_info;
           P64[Hp - 48] = _s8LAv::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.Latin1.latin5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
           P64[Hp] = GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.Latin1.mkLatin1_entry() //  [R2]
         { info_tbl: [(c8M1C,
                       label: GHC.IO.Encoding.Latin1.mkLatin1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M1C: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8M1G; else goto c8M1F;
       c8M1G: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.Latin1.mkLatin1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8M1F: // global
           I64[Hp - 56] = sat_s8LAD_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8LAz_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Latin1.latin6_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.019193881 UTC

[section ""data" . lvl5_r8KuC_closure" {
     lvl5_r8KuC_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.Latin1.latin3_closure+3;
         const GHC.IO.Encoding.Latin1.ascii2_closure+3;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii2_closure+1;
         const GHC.IO.Encoding.Latin1.mkAscii1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.021236917 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin2_closure" {
     GHC.IO.Encoding.Latin1.latin2_closure:
         const GHC.IO.Encoding.Latin1.latin2_info;
         const 0;
 },
 GHC.IO.Encoding.Latin1.latin2_entry() //  []
         { info_tbl: [(c8M2p,
                       label: GHC.IO.Encoding.Latin1.latin2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M2p: // global
           R1 = lvl5_r8KuC_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.024732849 UTC

[section ""data" . GHC.IO.Encoding.Latin1.latin1_closure" {
     GHC.IO.Encoding.Latin1.latin1_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const GHC.IO.Encoding.Latin1.latin4_closure+1;
         const GHC.IO.Encoding.Latin1.latin2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.027513902 UTC

[section ""relreadonly" . S8LWx_srt" {
     S8LWx_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.Latin1.mkAscii_closure;
         const GHC.IO.Encoding.Latin1.ascii6_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8Kux_closure;
         const lvl1_r8Kuy_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.Latin1.ascii2_closure;
         const lvl2_r8Kuz_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_checked_closure;
         const GHC.IO.Encoding.Latin1.latin6_closure;
         const lvl3_r8KuA_closure;
         const lvl4_r8KuB_closure;
         const GHC.IO.Encoding.Latin1.mkLatin1_closure;
         const lvl5_r8KuC_closure;
 }]

