
==================== Output Cmm ====================
2018-03-16 16:03:48.626812611 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:48.63308783 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF1_info;
 },
 sat_s8G24_entry() //  [R1]
         { info_tbl: [(c8Gga,
                       label: sat_s8G24_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gga: // global
           _s8G24::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ggb; else goto c8Ggc;
       c8Ggc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Gge; else goto c8Ggd;
       c8Gge: // global
           HpAlloc = 56;
           goto c8Ggb;
       c8Ggb: // global
           R1 = _s8G24::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ggd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G24::P64;
           _s8G1Q::I64 = I64[_s8G24::P64 + 56];
           _s8G20::I64 = I64[_s8G24::P64 + 64];
           if (_s8G20::I64 == _s8G1Q::I64) goto c8Gg9; else goto c8Gg8;
       c8Gg9: // global
           _s8G1Y::P64 = P64[_s8G24::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Gg8: // global
           _s8G1M::P64 = P64[_s8G24::P64 + 16];
           _s8G1N::P64 = P64[_s8G24::P64 + 24];
           _s8G1L::I64 = I64[_s8G24::P64 + 40];
           _s8G1O::I64 = I64[_s8G24::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G20::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2c_entry() //  [R1]
         { info_tbl: [(c8Ggw,
                       label: sat_s8G2c_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ggw: // global
           _s8G2c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ggx; else goto c8Ggy;
       c8Ggy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GgA; else goto c8Ggz;
       c8GgA: // global
           HpAlloc = 56;
           goto c8Ggx;
       c8Ggx: // global
           R1 = _s8G2c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ggz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2c::P64;
           _s8G1Q::I64 = I64[_s8G2c::P64 + 56];
           _s8G28::I64 = I64[_s8G2c::P64 + 64];
           if (_s8G28::I64 == _s8G1Q::I64) goto c8Ggv; else goto c8Ggu;
       c8Ggv: // global
           _s8G1Y::P64 = P64[_s8G2c::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Ggu: // global
           _s8G1M::P64 = P64[_s8G2c::P64 + 16];
           _s8G1N::P64 = P64[_s8G2c::P64 + 24];
           _s8G1L::I64 = I64[_s8G2c::P64 + 40];
           _s8G1O::I64 = I64[_s8G2c::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G28::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2k_entry() //  [R1]
         { info_tbl: [(c8GgS,
                       label: sat_s8G2k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GgS: // global
           _s8G2k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GgT; else goto c8GgU;
       c8GgU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GgW; else goto c8GgV;
       c8GgW: // global
           HpAlloc = 56;
           goto c8GgT;
       c8GgT: // global
           R1 = _s8G2k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GgV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2k::P64;
           _s8G1Q::I64 = I64[_s8G2k::P64 + 56];
           _s8G2g::I64 = I64[_s8G2k::P64 + 64];
           if (_s8G2g::I64 == _s8G1Q::I64) goto c8GgR; else goto c8GgQ;
       c8GgR: // global
           _s8G1Y::P64 = P64[_s8G2k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GgQ: // global
           _s8G1M::P64 = P64[_s8G2k::P64 + 16];
           _s8G1N::P64 = P64[_s8G2k::P64 + 24];
           _s8G1L::I64 = I64[_s8G2k::P64 + 40];
           _s8G1O::I64 = I64[_s8G2k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2g::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2s_entry() //  [R1]
         { info_tbl: [(c8Ghe,
                       label: sat_s8G2s_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ghe: // global
           _s8G2s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ghf; else goto c8Ghg;
       c8Ghg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Ghi; else goto c8Ghh;
       c8Ghi: // global
           HpAlloc = 56;
           goto c8Ghf;
       c8Ghf: // global
           R1 = _s8G2s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ghh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2s::P64;
           _s8G1Q::I64 = I64[_s8G2s::P64 + 56];
           _s8G2o::I64 = I64[_s8G2s::P64 + 64];
           if (_s8G2o::I64 == _s8G1Q::I64) goto c8Ghd; else goto c8Ghc;
       c8Ghd: // global
           _s8G1Y::P64 = P64[_s8G2s::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Ghc: // global
           _s8G1M::P64 = P64[_s8G2s::P64 + 16];
           _s8G1N::P64 = P64[_s8G2s::P64 + 24];
           _s8G1L::I64 = I64[_s8G2s::P64 + 40];
           _s8G1O::I64 = I64[_s8G2s::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2o::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2A_entry() //  [R1]
         { info_tbl: [(c8GhA,
                       label: sat_s8G2A_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GhA: // global
           _s8G2A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GhB; else goto c8GhC;
       c8GhC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GhE; else goto c8GhD;
       c8GhE: // global
           HpAlloc = 56;
           goto c8GhB;
       c8GhB: // global
           R1 = _s8G2A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GhD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2A::P64;
           _s8G1Q::I64 = I64[_s8G2A::P64 + 56];
           _s8G2w::I64 = I64[_s8G2A::P64 + 64];
           if (_s8G2w::I64 == _s8G1Q::I64) goto c8Ghz; else goto c8Ghy;
       c8Ghz: // global
           _s8G1Y::P64 = P64[_s8G2A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Ghy: // global
           _s8G1M::P64 = P64[_s8G2A::P64 + 16];
           _s8G1N::P64 = P64[_s8G2A::P64 + 24];
           _s8G1L::I64 = I64[_s8G2A::P64 + 40];
           _s8G1O::I64 = I64[_s8G2A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2w::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2I_entry() //  [R1]
         { info_tbl: [(c8GhW,
                       label: sat_s8G2I_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GhW: // global
           _s8G2I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GhX; else goto c8GhY;
       c8GhY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Gi0; else goto c8GhZ;
       c8Gi0: // global
           HpAlloc = 56;
           goto c8GhX;
       c8GhX: // global
           R1 = _s8G2I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GhZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2I::P64;
           _s8G1Q::I64 = I64[_s8G2I::P64 + 56];
           _s8G2E::I64 = I64[_s8G2I::P64 + 64];
           if (_s8G2E::I64 == _s8G1Q::I64) goto c8GhV; else goto c8GhU;
       c8GhV: // global
           _s8G1Y::P64 = P64[_s8G2I::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GhU: // global
           _s8G1M::P64 = P64[_s8G2I::P64 + 16];
           _s8G1N::P64 = P64[_s8G2I::P64 + 24];
           _s8G1L::I64 = I64[_s8G2I::P64 + 40];
           _s8G1O::I64 = I64[_s8G2I::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2E::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8Gi3,
                       label: GHC.IO.Encoding.UTF16.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gi3: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Gi4; else goto c8Gi5;
       c8Gi4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Gi5: // global
           I64[Sp - 16] = block_c8GfK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Gnb; else goto c8GfL;
       u8Gnb: // global
           call _c8GfK(R1) args: 0, res: 0, upd: 0;
       c8GfL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GfK() //  [R1]
         { info_tbl: [(c8GfK,
                       label: block_c8GfK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GfK: // global
           I64[Sp - 40] = block_c8GfP_info;
           _s8G1M::P64 = P64[R1 + 7];
           _s8G1N::P64 = P64[R1 + 15];
           _s8G1L::I64 = I64[R1 + 23];
           _s8G1O::I64 = I64[R1 + 31];
           _s8G1P::I64 = I64[R1 + 39];
           _s8G1Q::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G1N::P64;
           I64[Sp - 24] = _s8G1O::I64;
           I64[Sp - 16] = _s8G1P::I64;
           I64[Sp - 8] = _s8G1Q::I64;
           P64[Sp] = _s8G1M::P64;
           I64[Sp + 8] = _s8G1L::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Gn4; else goto c8GfQ;
       u8Gn4: // global
           call _c8GfP(R1) args: 0, res: 0, upd: 0;
       c8GfQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GfP() //  [R1]
         { info_tbl: [(c8GfP,
                       label: block_c8GfP_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GfP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Gi9; else goto c8Gi8;
       c8Gi9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Gi8: // global
           _s8G1T::P64 = P64[R1 + 7];
           _s8G1U::P64 = P64[R1 + 15];
           _s8G1S::I64 = I64[R1 + 23];
           _s8G1V::I64 = I64[R1 + 31];
           _s8G1W::I64 = I64[R1 + 39];
           _s8G1X::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G1M::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G1L::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G1Q::I64 = I64[Sp + 32];
           _c8GfU::P64 = Hp - 47;
           _s8G2N::I64 = _s8G1X::I64;
           _s8G2M::I64 = I64[Sp + 24];
           goto c8GiA;
       c8GiA: // global
           if (%MO_S_Lt_W64(_s8G2M::I64,
                            _s8G1Q::I64)) goto c8GjL; else goto c8GjM;
       c8GjL: // global
           if (%MO_S_Ge_W64(_s8G1V::I64 - _s8G2N::I64,
                            2)) goto c8GjI; else goto c8GjJ;
       c8GjI: // global
           _s8G2U::I64 = %MO_UU_Conv_W32_W64(I32[_s8G1L::I64 + (_s8G2M::I64 << 2)]);
           call MO_Touch(_s8G1M::P64);
           if (%MO_S_Ge_W64(_s8G2U::I64, 65536)) goto c8Gj3; else goto c8GjG;
       c8Gj3: // global
           if (%MO_S_Ge_W64(_s8G1V::I64 - _s8G2N::I64,
                            4)) goto c8Gj0; else goto c8Gj1;
       c8Gj0: // global
           _s8G30::I64 = _s8G2U::I64 - 65536;
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G30::I64,
                                                                            18) + 216);
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G30::I64,
                                                                                  10));
           call MO_Touch(_s8G1T::P64);
           _s8G3f::I64 = _s8G30::I64 & 1023;
           I8[_s8G1S::I64 + (_s8G2N::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G3f::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8G3f::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 4;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GiA;
       c8Gj1: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GfU::P64;
           Sp = Sp - 56;
           call _c8GfX() args: 0, res: 0, upd: 0;
       c8GjG: // global
           if (%MO_S_Gt_W64(55296, _s8G2U::I64)) goto c8Gjl; else goto c8GjF;
       c8Gjl: // global
           if (%MO_S_Gt_W64(56320, _s8G2U::I64)) goto c8Gjb; else goto c8Gjj;
       c8Gjb: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GiA;
       c8Gjj: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 57343)) goto c8Gjh; else goto c8Gji;
       c8Gjh: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GiA;
       c8Gji: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GfU::P64;
           Sp = Sp - 56;
           call _c8Ggj() args: 0, res: 0, upd: 0;
       c8GjF: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 56319)) goto c8GjD; else goto c8GjE;
       c8GjD: // global
           if (%MO_S_Gt_W64(56320, _s8G2U::I64)) goto c8Gjt; else goto c8GjB;
       c8Gjt: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GiA;
       c8GjB: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 57343)) goto c8Gjz; else goto c8GjA;
       c8Gjz: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GiA;
       c8GjA: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GfU::P64;
           Sp = Sp - 56;
           call _c8GgF() args: 0, res: 0, upd: 0;
       c8GjE: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GfU::P64;
           Sp = Sp - 56;
           call _c8Gh1() args: 0, res: 0, upd: 0;
       c8GjJ: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GfU::P64;
           Sp = Sp - 56;
           call _c8Ghn() args: 0, res: 0, upd: 0;
       c8GjM: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GfU::P64;
           Sp = Sp - 56;
           call _c8GhJ() args: 0, res: 0, upd: 0;
     }
 },
 _c8GfX() //  []
         { info_tbl: [(c8GfX,
                       label: block_c8GfX_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GfX: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Gid; else goto c8Gic;
       c8Gid: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GfX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Gic: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G24_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ggj() //  []
         { info_tbl: [(c8Ggj,
                       label: block_c8Ggj_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ggj: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Gih; else goto c8Gig;
       c8Gih: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ggj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Gig: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2c_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GgF() //  []
         { info_tbl: [(c8GgF,
                       label: block_c8GgF_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GgF: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Gil; else goto c8Gik;
       c8Gil: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GgF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Gik: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Gh1() //  []
         { info_tbl: [(c8Gh1,
                       label: block_c8Gh1_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gh1: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Gip; else goto c8Gio;
       c8Gip: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Gh1_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Gio: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2s_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ghn() //  []
         { info_tbl: [(c8Ghn,
                       label: block_c8Ghn_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ghn: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Git; else goto c8Gis;
       c8Git: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Ghn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Gis: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2A_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GhJ() //  []
         { info_tbl: [(c8GhJ,
                       label: block_c8GhJ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GhJ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Gix; else goto c8Giw;
       c8Gix: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GhJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Giw: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2I_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.643112695 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_encode_entry() //  [R2, R3]
         { info_tbl: [(c8Gng,
                       label: GHC.IO.Encoding.UTF16.utf16be_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gng: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.678793064 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le1_info;
 },
 sat_s8G4T_entry() //  [R1]
         { info_tbl: [(c8GnN,
                       label: sat_s8G4T_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GnN: // global
           _s8G4T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GnO; else goto c8GnP;
       c8GnP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GnR; else goto c8GnQ;
       c8GnR: // global
           HpAlloc = 56;
           goto c8GnO;
       c8GnO: // global
           R1 = _s8G4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GnQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G4T::P64;
           _s8G4F::I64 = I64[_s8G4T::P64 + 56];
           _s8G4P::I64 = I64[_s8G4T::P64 + 64];
           if (_s8G4P::I64 == _s8G4F::I64) goto c8GnM; else goto c8GnL;
       c8GnM: // global
           _s8G4N::P64 = P64[_s8G4T::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GnL: // global
           _s8G4B::P64 = P64[_s8G4T::P64 + 16];
           _s8G4C::P64 = P64[_s8G4T::P64 + 24];
           _s8G4A::I64 = I64[_s8G4T::P64 + 40];
           _s8G4D::I64 = I64[_s8G4T::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G4P::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G51_entry() //  [R1]
         { info_tbl: [(c8Go9,
                       label: sat_s8G51_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Go9: // global
           _s8G51::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Goa; else goto c8Gob;
       c8Gob: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8God; else goto c8Goc;
       c8God: // global
           HpAlloc = 56;
           goto c8Goa;
       c8Goa: // global
           R1 = _s8G51::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Goc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G51::P64;
           _s8G4F::I64 = I64[_s8G51::P64 + 56];
           _s8G4X::I64 = I64[_s8G51::P64 + 64];
           if (_s8G4X::I64 == _s8G4F::I64) goto c8Go8; else goto c8Go7;
       c8Go8: // global
           _s8G4N::P64 = P64[_s8G51::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Go7: // global
           _s8G4B::P64 = P64[_s8G51::P64 + 16];
           _s8G4C::P64 = P64[_s8G51::P64 + 24];
           _s8G4A::I64 = I64[_s8G51::P64 + 40];
           _s8G4D::I64 = I64[_s8G51::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G4X::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G59_entry() //  [R1]
         { info_tbl: [(c8Gov,
                       label: sat_s8G59_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gov: // global
           _s8G59::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Gow; else goto c8Gox;
       c8Gox: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Goz; else goto c8Goy;
       c8Goz: // global
           HpAlloc = 56;
           goto c8Gow;
       c8Gow: // global
           R1 = _s8G59::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Goy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G59::P64;
           _s8G4F::I64 = I64[_s8G59::P64 + 56];
           _s8G55::I64 = I64[_s8G59::P64 + 64];
           if (_s8G55::I64 == _s8G4F::I64) goto c8Gou; else goto c8Got;
       c8Gou: // global
           _s8G4N::P64 = P64[_s8G59::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Got: // global
           _s8G4B::P64 = P64[_s8G59::P64 + 16];
           _s8G4C::P64 = P64[_s8G59::P64 + 24];
           _s8G4A::I64 = I64[_s8G59::P64 + 40];
           _s8G4D::I64 = I64[_s8G59::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G55::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G5h_entry() //  [R1]
         { info_tbl: [(c8GoR,
                       label: sat_s8G5h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GoR: // global
           _s8G5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GoS; else goto c8GoT;
       c8GoT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GoV; else goto c8GoU;
       c8GoV: // global
           HpAlloc = 56;
           goto c8GoS;
       c8GoS: // global
           R1 = _s8G5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GoU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5h::P64;
           _s8G4F::I64 = I64[_s8G5h::P64 + 56];
           _s8G5d::I64 = I64[_s8G5h::P64 + 64];
           if (_s8G5d::I64 == _s8G4F::I64) goto c8GoQ; else goto c8GoP;
       c8GoQ: // global
           _s8G4N::P64 = P64[_s8G5h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GoP: // global
           _s8G4B::P64 = P64[_s8G5h::P64 + 16];
           _s8G4C::P64 = P64[_s8G5h::P64 + 24];
           _s8G4A::I64 = I64[_s8G5h::P64 + 40];
           _s8G4D::I64 = I64[_s8G5h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5d::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G5p_entry() //  [R1]
         { info_tbl: [(c8Gpd,
                       label: sat_s8G5p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gpd: // global
           _s8G5p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Gpe; else goto c8Gpf;
       c8Gpf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Gph; else goto c8Gpg;
       c8Gph: // global
           HpAlloc = 56;
           goto c8Gpe;
       c8Gpe: // global
           R1 = _s8G5p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Gpg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5p::P64;
           _s8G4F::I64 = I64[_s8G5p::P64 + 56];
           _s8G5l::I64 = I64[_s8G5p::P64 + 64];
           if (_s8G5l::I64 == _s8G4F::I64) goto c8Gpc; else goto c8Gpb;
       c8Gpc: // global
           _s8G4N::P64 = P64[_s8G5p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Gpb: // global
           _s8G4B::P64 = P64[_s8G5p::P64 + 16];
           _s8G4C::P64 = P64[_s8G5p::P64 + 24];
           _s8G4A::I64 = I64[_s8G5p::P64 + 40];
           _s8G4D::I64 = I64[_s8G5p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5l::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G5x_entry() //  [R1]
         { info_tbl: [(c8Gpz,
                       label: sat_s8G5x_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gpz: // global
           _s8G5x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GpA; else goto c8GpB;
       c8GpB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GpD; else goto c8GpC;
       c8GpD: // global
           HpAlloc = 56;
           goto c8GpA;
       c8GpA: // global
           R1 = _s8G5x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GpC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5x::P64;
           _s8G4F::I64 = I64[_s8G5x::P64 + 56];
           _s8G5t::I64 = I64[_s8G5x::P64 + 64];
           if (_s8G5t::I64 == _s8G4F::I64) goto c8Gpy; else goto c8Gpx;
       c8Gpy: // global
           _s8G4N::P64 = P64[_s8G5x::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Gpx: // global
           _s8G4B::P64 = P64[_s8G5x::P64 + 16];
           _s8G4C::P64 = P64[_s8G5x::P64 + 24];
           _s8G4A::I64 = I64[_s8G5x::P64 + 40];
           _s8G4D::I64 = I64[_s8G5x::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5t::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16le1_entry() //  [R2, R3]
         { info_tbl: [(c8GpG,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GpG: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8GpH; else goto c8GpI;
       c8GpH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GpI: // global
           I64[Sp - 16] = block_c8Gnn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8GuO; else goto c8Gno;
       u8GuO: // global
           call _c8Gnn(R1) args: 0, res: 0, upd: 0;
       c8Gno: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Gnn() //  [R1]
         { info_tbl: [(c8Gnn,
                       label: block_c8Gnn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gnn: // global
           I64[Sp - 40] = block_c8Gns_info;
           _s8G4B::P64 = P64[R1 + 7];
           _s8G4C::P64 = P64[R1 + 15];
           _s8G4A::I64 = I64[R1 + 23];
           _s8G4D::I64 = I64[R1 + 31];
           _s8G4E::I64 = I64[R1 + 39];
           _s8G4F::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G4C::P64;
           I64[Sp - 24] = _s8G4D::I64;
           I64[Sp - 16] = _s8G4E::I64;
           I64[Sp - 8] = _s8G4F::I64;
           P64[Sp] = _s8G4B::P64;
           I64[Sp + 8] = _s8G4A::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8GuH; else goto c8Gnt;
       u8GuH: // global
           call _c8Gns(R1) args: 0, res: 0, upd: 0;
       c8Gnt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Gns() //  [R1]
         { info_tbl: [(c8Gns,
                       label: block_c8Gns_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gns: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GpM; else goto c8GpL;
       c8GpM: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8GpL: // global
           _s8G4I::P64 = P64[R1 + 7];
           _s8G4J::P64 = P64[R1 + 15];
           _s8G4H::I64 = I64[R1 + 23];
           _s8G4K::I64 = I64[R1 + 31];
           _s8G4L::I64 = I64[R1 + 39];
           _s8G4M::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G4B::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G4A::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G4F::I64 = I64[Sp + 32];
           _c8Gnx::P64 = Hp - 47;
           _s8G5C::I64 = _s8G4M::I64;
           _s8G5B::I64 = I64[Sp + 24];
           goto c8Gqd;
       c8Gqd: // global
           if (%MO_S_Lt_W64(_s8G5B::I64,
                            _s8G4F::I64)) goto c8Gro; else goto c8Grp;
       c8Gro: // global
           if (%MO_S_Ge_W64(_s8G4K::I64 - _s8G5C::I64,
                            2)) goto c8Grl; else goto c8Grm;
       c8Grl: // global
           _s8G5J::I64 = %MO_UU_Conv_W32_W64(I32[_s8G4A::I64 + (_s8G5B::I64 << 2)]);
           call MO_Touch(_s8G4B::P64);
           if (%MO_S_Ge_W64(_s8G5J::I64, 65536)) goto c8GqG; else goto c8Grj;
       c8GqG: // global
           if (%MO_S_Ge_W64(_s8G4K::I64 - _s8G5C::I64,
                            4)) goto c8GqD; else goto c8GqE;
       c8GqD: // global
           _s8G5P::I64 = _s8G5J::I64 - 65536;
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5P::I64,
                                                                            10));
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5P::I64,
                                                                                  18) + 216);
           call MO_Touch(_s8G4I::P64);
           _s8G64::I64 = _s8G5P::I64 & 1023;
           I8[_s8G4H::I64 + (_s8G5C::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8G64::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G64::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 4;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8Gqd;
       c8GqE: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8Gnx::P64;
           Sp = Sp - 56;
           call _c8GnA() args: 0, res: 0, upd: 0;
       c8Grj: // global
           if (%MO_S_Gt_W64(55296, _s8G5J::I64)) goto c8GqY; else goto c8Gri;
       c8GqY: // global
           if (%MO_S_Gt_W64(56320, _s8G5J::I64)) goto c8GqO; else goto c8GqW;
       c8GqO: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8Gqd;
       c8GqW: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 57343)) goto c8GqU; else goto c8GqV;
       c8GqU: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8Gqd;
       c8GqV: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8Gnx::P64;
           Sp = Sp - 56;
           call _c8GnW() args: 0, res: 0, upd: 0;
       c8Gri: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 56319)) goto c8Grg; else goto c8Grh;
       c8Grg: // global
           if (%MO_S_Gt_W64(56320, _s8G5J::I64)) goto c8Gr6; else goto c8Gre;
       c8Gr6: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8Gqd;
       c8Gre: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 57343)) goto c8Grc; else goto c8Grd;
       c8Grc: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8Gqd;
       c8Grd: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8Gnx::P64;
           Sp = Sp - 56;
           call _c8Goi() args: 0, res: 0, upd: 0;
       c8Grh: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8Gnx::P64;
           Sp = Sp - 56;
           call _c8GoE() args: 0, res: 0, upd: 0;
       c8Grm: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8Gnx::P64;
           Sp = Sp - 56;
           call _c8Gp0() args: 0, res: 0, upd: 0;
       c8Grp: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8Gnx::P64;
           Sp = Sp - 56;
           call _c8Gpm() args: 0, res: 0, upd: 0;
     }
 },
 _c8GnA() //  []
         { info_tbl: [(c8GnA,
                       label: block_c8GnA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GnA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GpQ; else goto c8GpP;
       c8GpQ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GnA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GpP: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G4T_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GnW() //  []
         { info_tbl: [(c8GnW,
                       label: block_c8GnW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GnW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GpU; else goto c8GpT;
       c8GpU: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GnW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GpT: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G51_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Goi() //  []
         { info_tbl: [(c8Goi,
                       label: block_c8Goi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Goi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GpY; else goto c8GpX;
       c8GpY: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Goi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GpX: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G59_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GoE() //  []
         { info_tbl: [(c8GoE,
                       label: block_c8GoE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GoE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Gq2; else goto c8Gq1;
       c8Gq2: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GoE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Gq1: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Gp0() //  []
         { info_tbl: [(c8Gp0,
                       label: block_c8Gp0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gp0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Gq6; else goto c8Gq5;
       c8Gq6: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Gp0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Gq5: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Gpm() //  []
         { info_tbl: [(c8Gpm,
                       label: block_c8Gpm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gpm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Gqa; else goto c8Gq9;
       c8Gqa: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Gpm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Gq9: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5x_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.688273624 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_encode_entry() //  [R2, R3]
         { info_tbl: [(c8GuT,
                       label: GHC.IO.Encoding.UTF16.utf16le_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GuT: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF16le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.689021937 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule4_bytes" {
     GHC.IO.Encoding.UTF16.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.689659615 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule3_closure" {
     GHC.IO.Encoding.UTF16.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.690221638 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule2_bytes" {
     GHC.IO.Encoding.UTF16.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.690827395 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule1_closure" {
     GHC.IO.Encoding.UTF16.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.691419061 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule_closure" {
     GHC.IO.Encoding.UTF16.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF16.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF16.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.692957679 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_encode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_encode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GuX: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8Gv8,
                       label: GHC.IO.Encoding.UTF16.$wutf16_encode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gv8: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Gv9; else goto c8Gva;
       c8Gv9: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8Gva: // global
           I64[Sp - 48] = block_c8Gv1_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8GvQ; else goto c8Gv2;
       u8GvQ: // global
           call _c8Gv1(R1) args: 0, res: 0, upd: 0;
       c8Gv2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Gv1() //  [R1]
         { info_tbl: [(c8Gv1,
                       label: block_c8Gv1_info
                       rep:StackRep [False, False, True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gv1: // global
           _s8G7m::P64 = P64[Sp + 16];
           _s8G7n::I64 = I64[Sp + 24];
           _s8G7o::P64 = P64[Sp + 32];
           _s8G7p::P64 = P64[Sp + 40];
           _s8G7q::I64 = I64[Sp + 48];
           _s8G7r::I64 = I64[Sp + 56];
           _s8G7s::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8Gv5; else goto c8Gv6;
       c8Gv5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Gvf; else goto c8Gve;
       c8Gvf: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Gve: // global
           if (%MO_S_Ge_W64(_s8G7q::I64 - _s8G7s::I64,
                            2)) goto c8GvF; else goto c8GvJ;
       c8GvF: // global
           _s8G7l::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8G7l::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8G7l::P64);
           I8[_s8G7n::I64 + _s8G7s::I64] = 254 :: W8;
           call MO_Touch(_s8G7o::P64);
           I8[_s8G7n::I64 + (_s8G7s::I64 + 1)] = 255 :: W8;
           call MO_Touch(_s8G7o::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8G7o::P64;
           P64[Hp - 64] = _s8G7p::P64;
           I64[Hp - 56] = _s8G7n::I64;
           I64[Hp - 48] = _s8G7q::I64;
           I64[Hp - 40] = _s8G7r::I64;
           I64[Hp - 32] = _s8G7s::I64 + 2;
           _c8GvD::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8GvD::P64;
           R2 = _s8G7m::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8GvJ: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8G7o::P64;
           P64[Hp - 64] = _s8G7p::P64;
           I64[Hp - 56] = _s8G7n::I64;
           I64[Hp - 48] = _s8G7q::I64;
           I64[Hp - 40] = _s8G7r::I64;
           I64[Hp - 32] = _s8G7s::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8G7m::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Gv6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GvP; else goto c8GvO;
       c8GvP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8GvO: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G7o::P64;
           P64[Hp - 32] = _s8G7p::P64;
           I64[Hp - 24] = _s8G7n::I64;
           I64[Hp - 16] = _s8G7q::I64;
           I64[Hp - 8] = _s8G7r::I64;
           I64[Hp] = _s8G7s::I64;
           R3 = Hp - 47;
           R2 = _s8G7m::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.695537297 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8GvY,
                       label: GHC.IO.Encoding.UTF16.utf16_encode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GvY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Gw2; else goto c8Gw3;
       c8Gw2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Gw3: // global
           I64[Sp - 24] = block_c8GvV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Gwb; else goto c8GvW;
       u8Gwb: // global
           call _c8GvV(R1) args: 0, res: 0, upd: 0;
       c8GvW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GvV() //  [R1]
         { info_tbl: [(c8GvV,
                       label: block_c8GvV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GvV: // global
           I64[Sp] = block_c8Gw1_info;
           _s8G7S::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8G7S::P64;
           if (R1 & 7 != 0) goto u8Gwa; else goto c8Gw5;
       u8Gwa: // global
           call _c8Gw1(R1) args: 0, res: 0, upd: 0;
       c8Gw5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Gw1() //  [R1]
         { info_tbl: [(c8Gw1,
                       label: block_c8Gw1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gw1: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.696963928 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Gwg,
                       label: GHC.IO.Encoding.UTF16.utf16_encode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gwg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.703560021 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF3_closure" {
     GHC.IO.Encoding.UTF16.mkUTF3_closure:
         const GHC.IO.Encoding.UTF16.mkUTF3_info;
 },
 sat_s8G8n_entry() //  [R1]
         { info_tbl: [(c8GwN,
                       label: sat_s8G8n_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GwN: // global
           _s8G8n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GwO; else goto c8GwP;
       c8GwP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GwR; else goto c8GwQ;
       c8GwR: // global
           HpAlloc = 56;
           goto c8GwO;
       c8GwO: // global
           R1 = _s8G8n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GwQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8n::P64;
           _s8G89::I64 = I64[_s8G8n::P64 + 56];
           _s8G8j::I64 = I64[_s8G8n::P64 + 64];
           if (_s8G8j::I64 == _s8G89::I64) goto c8GwM; else goto c8GwL;
       c8GwM: // global
           _s8G8h::P64 = P64[_s8G8n::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GwL: // global
           _s8G85::P64 = P64[_s8G8n::P64 + 16];
           _s8G86::P64 = P64[_s8G8n::P64 + 24];
           _s8G84::I64 = I64[_s8G8n::P64 + 40];
           _s8G87::I64 = I64[_s8G8n::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8j::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8v_entry() //  [R1]
         { info_tbl: [(c8Gx9,
                       label: sat_s8G8v_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gx9: // global
           _s8G8v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Gxa; else goto c8Gxb;
       c8Gxb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Gxd; else goto c8Gxc;
       c8Gxd: // global
           HpAlloc = 56;
           goto c8Gxa;
       c8Gxa: // global
           R1 = _s8G8v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Gxc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8v::P64;
           _s8G89::I64 = I64[_s8G8v::P64 + 56];
           _s8G8r::I64 = I64[_s8G8v::P64 + 64];
           if (_s8G8r::I64 == _s8G89::I64) goto c8Gx8; else goto c8Gx7;
       c8Gx8: // global
           _s8G8h::P64 = P64[_s8G8v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Gx7: // global
           _s8G85::P64 = P64[_s8G8v::P64 + 16];
           _s8G86::P64 = P64[_s8G8v::P64 + 24];
           _s8G84::I64 = I64[_s8G8v::P64 + 40];
           _s8G87::I64 = I64[_s8G8v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8r::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8D_entry() //  [R1]
         { info_tbl: [(c8Gxv,
                       label: sat_s8G8D_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gxv: // global
           _s8G8D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Gxw; else goto c8Gxx;
       c8Gxx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Gxz; else goto c8Gxy;
       c8Gxz: // global
           HpAlloc = 56;
           goto c8Gxw;
       c8Gxw: // global
           R1 = _s8G8D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Gxy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8D::P64;
           _s8G89::I64 = I64[_s8G8D::P64 + 56];
           _s8G8z::I64 = I64[_s8G8D::P64 + 64];
           if (_s8G8z::I64 == _s8G89::I64) goto c8Gxu; else goto c8Gxt;
       c8Gxu: // global
           _s8G8h::P64 = P64[_s8G8D::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Gxt: // global
           _s8G85::P64 = P64[_s8G8D::P64 + 16];
           _s8G86::P64 = P64[_s8G8D::P64 + 24];
           _s8G84::I64 = I64[_s8G8D::P64 + 40];
           _s8G87::I64 = I64[_s8G8D::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8z::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8L_entry() //  [R1]
         { info_tbl: [(c8GxR,
                       label: sat_s8G8L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GxR: // global
           _s8G8L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GxS; else goto c8GxT;
       c8GxT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GxV; else goto c8GxU;
       c8GxV: // global
           HpAlloc = 56;
           goto c8GxS;
       c8GxS: // global
           R1 = _s8G8L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GxU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8L::P64;
           _s8G89::I64 = I64[_s8G8L::P64 + 56];
           _s8G8H::I64 = I64[_s8G8L::P64 + 64];
           if (_s8G8H::I64 == _s8G89::I64) goto c8GxQ; else goto c8GxP;
       c8GxQ: // global
           _s8G8h::P64 = P64[_s8G8L::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GxP: // global
           _s8G85::P64 = P64[_s8G8L::P64 + 16];
           _s8G86::P64 = P64[_s8G8L::P64 + 24];
           _s8G84::I64 = I64[_s8G8L::P64 + 40];
           _s8G87::I64 = I64[_s8G8L::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8H::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8T_entry() //  [R1]
         { info_tbl: [(c8Gyd,
                       label: sat_s8G8T_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gyd: // global
           _s8G8T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Gye; else goto c8Gyf;
       c8Gyf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Gyh; else goto c8Gyg;
       c8Gyh: // global
           HpAlloc = 56;
           goto c8Gye;
       c8Gye: // global
           R1 = _s8G8T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Gyg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8T::P64;
           _s8G89::I64 = I64[_s8G8T::P64 + 56];
           _s8G8P::I64 = I64[_s8G8T::P64 + 64];
           if (_s8G8P::I64 == _s8G89::I64) goto c8Gyc; else goto c8Gyb;
       c8Gyc: // global
           _s8G8h::P64 = P64[_s8G8T::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Gyb: // global
           _s8G85::P64 = P64[_s8G8T::P64 + 16];
           _s8G86::P64 = P64[_s8G8T::P64 + 24];
           _s8G84::I64 = I64[_s8G8T::P64 + 40];
           _s8G87::I64 = I64[_s8G8T::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8P::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G91_entry() //  [R1]
         { info_tbl: [(c8Gyz,
                       label: sat_s8G91_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gyz: // global
           _s8G91::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GyA; else goto c8GyB;
       c8GyB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GyD; else goto c8GyC;
       c8GyD: // global
           HpAlloc = 56;
           goto c8GyA;
       c8GyA: // global
           R1 = _s8G91::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GyC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G91::P64;
           _s8G89::I64 = I64[_s8G91::P64 + 56];
           _s8G8X::I64 = I64[_s8G91::P64 + 64];
           if (_s8G8X::I64 == _s8G89::I64) goto c8Gyy; else goto c8Gyx;
       c8Gyy: // global
           _s8G8h::P64 = P64[_s8G91::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Gyx: // global
           _s8G85::P64 = P64[_s8G91::P64 + 16];
           _s8G86::P64 = P64[_s8G91::P64 + 24];
           _s8G84::I64 = I64[_s8G91::P64 + 40];
           _s8G87::I64 = I64[_s8G91::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8X::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G99_entry() //  [R1]
         { info_tbl: [(c8GyV,
                       label: sat_s8G99_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GyV: // global
           _s8G99::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GyW; else goto c8GyX;
       c8GyX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GyZ; else goto c8GyY;
       c8GyZ: // global
           HpAlloc = 56;
           goto c8GyW;
       c8GyW: // global
           R1 = _s8G99::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GyY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G99::P64;
           _s8G89::I64 = I64[_s8G99::P64 + 56];
           _s8G95::I64 = I64[_s8G99::P64 + 64];
           if (_s8G95::I64 == _s8G89::I64) goto c8GyU; else goto c8GyT;
       c8GyU: // global
           _s8G8h::P64 = P64[_s8G99::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GyT: // global
           _s8G85::P64 = P64[_s8G99::P64 + 16];
           _s8G86::P64 = P64[_s8G99::P64 + 24];
           _s8G84::I64 = I64[_s8G99::P64 + 40];
           _s8G87::I64 = I64[_s8G99::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G95::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G9h_entry() //  [R1]
         { info_tbl: [(c8Gzh,
                       label: sat_s8G9h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gzh: // global
           _s8G9h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Gzi; else goto c8Gzj;
       c8Gzj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Gzl; else goto c8Gzk;
       c8Gzl: // global
           HpAlloc = 56;
           goto c8Gzi;
       c8Gzi: // global
           R1 = _s8G9h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Gzk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G9h::P64;
           _s8G89::I64 = I64[_s8G9h::P64 + 56];
           _s8G9d::I64 = I64[_s8G9h::P64 + 64];
           if (_s8G9d::I64 == _s8G89::I64) goto c8Gzg; else goto c8Gzf;
       c8Gzg: // global
           _s8G8h::P64 = P64[_s8G9h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Gzf: // global
           _s8G85::P64 = P64[_s8G9h::P64 + 16];
           _s8G86::P64 = P64[_s8G9h::P64 + 24];
           _s8G84::I64 = I64[_s8G9h::P64 + 40];
           _s8G87::I64 = I64[_s8G9h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G9d::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF3_entry() //  [R2, R3]
         { info_tbl: [(c8Gzo,
                       label: GHC.IO.Encoding.UTF16.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gzo: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Gzp; else goto c8Gzq;
       c8Gzp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Gzq: // global
           I64[Sp - 16] = block_c8Gwn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8GDa; else goto c8Gwo;
       u8GDa: // global
           call _c8Gwn(R1) args: 0, res: 0, upd: 0;
       c8Gwo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Gwn() //  [R1]
         { info_tbl: [(c8Gwn,
                       label: block_c8Gwn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gwn: // global
           I64[Sp - 40] = block_c8Gws_info;
           _s8G85::P64 = P64[R1 + 7];
           _s8G86::P64 = P64[R1 + 15];
           _s8G84::I64 = I64[R1 + 23];
           _s8G87::I64 = I64[R1 + 31];
           _s8G88::I64 = I64[R1 + 39];
           _s8G89::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G86::P64;
           I64[Sp - 24] = _s8G87::I64;
           I64[Sp - 16] = _s8G88::I64;
           I64[Sp - 8] = _s8G89::I64;
           P64[Sp] = _s8G85::P64;
           I64[Sp + 8] = _s8G84::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8GD1; else goto c8Gwt;
       u8GD1: // global
           call _c8Gws(R1) args: 0, res: 0, upd: 0;
       c8Gwt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Gws() //  [R1]
         { info_tbl: [(c8Gws,
                       label: block_c8Gws_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gws: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Gzu; else goto c8Gzt;
       c8Gzu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Gzt: // global
           _s8G8c::P64 = P64[R1 + 7];
           _s8G8d::P64 = P64[R1 + 15];
           _s8G8b::I64 = I64[R1 + 23];
           _s8G8e::I64 = I64[R1 + 31];
           _s8G8f::I64 = I64[R1 + 39];
           _s8G8g::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G85::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G84::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G89::I64 = I64[Sp + 32];
           _c8Gwx::P64 = Hp - 47;
           _s8G9m::I64 = _s8G8g::I64;
           _s8G9l::I64 = I64[Sp + 24];
           goto c8GA3;
       c8GA3: // global
           if (%MO_S_Lt_W64(_s8G9m::I64,
                            _s8G8e::I64)) goto c8GBY; else goto c8GBZ;
       c8GBY: // global
           if (%MO_S_Lt_W64(_s8G9l::I64,
                            _s8G89::I64)) goto c8GBV; else goto c8GBW;
       c8GBV: // global
           if ((_s8G9l::I64 + 1) == _s8G89::I64) goto c8GBT; else goto c8GBS;
       c8GBT: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8Gwx::P64;
           Sp = Sp - 56;
           call _c8Gym() args: 0, res: 0, upd: 0;
       c8GBS: // global
           _s8G9v::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + _s8G9l::I64]);
           call MO_Touch(_s8G85::P64);
           _s8G9B::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 1)]);
           call MO_Touch(_s8G85::P64);
           _s8G9D::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8G9B::I64 << 8)) + _s8G9v::I64));
           if (_s8G9D::I64 >= 55296) goto c8GBP; else goto c8GBQ;
       c8GBP: // global
           if (_s8G9D::I64 <= 57343) goto c8GBM; else goto c8GBN;
       c8GBM: // global
           if (%MO_S_Ge_W64(_s8G89::I64 - _s8G9l::I64,
                            4)) goto c8GBJ; else goto c8GBK;
       c8GBJ: // global
           _s8G9P::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 2)]);
           call MO_Touch(_s8G85::P64);
           _s8G9V::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 3)]);
           call MO_Touch(_s8G85::P64);
           if (_s8G9D::I64 < 55296) goto c8GB9; else goto c8GBH;
       c8GB9: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8Gwx::P64;
           Sp = Sp - 56;
           call _c8GwA() args: 0, res: 0, upd: 0;
       c8GBH: // global
           if (_s8G9D::I64 > 56319) goto c8GBf; else goto c8GBG;
       c8GBf: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8Gwx::P64;
           Sp = Sp - 56;
           call _c8GwW() args: 0, res: 0, upd: 0;
       c8GBG: // global
           _s8G9Z::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8G9V::I64 << 8)) + _s8G9P::I64));
           if (_s8G9Z::I64 < 56320) goto c8GBx; else goto c8GBF;
       c8GBx: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8Gwx::P64;
           Sp = Sp - 56;
           call _c8Gxi() args: 0, res: 0, upd: 0;
       c8GBF: // global
           if (_s8G9Z::I64 > 57343) goto c8GBD; else goto c8GBE;
       c8GBD: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8Gwx::P64;
           Sp = Sp - 56;
           call _c8GxE() args: 0, res: 0, upd: 0;
       c8GBE: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8G9D::I64 + -55296) << 10) + (_s8G9Z::I64 + -56320) + 65536);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 4;
           goto c8GA3;
       c8GBK: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8Gwx::P64;
           Sp = Sp - 56;
           call _c8Gy0() args: 0, res: 0, upd: 0;
       c8GBN: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8G9D::I64);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 2;
           goto c8GA3;
       c8GBQ: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8G9D::I64);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 2;
           goto c8GA3;
       c8GBW: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8Gwx::P64;
           Sp = Sp - 56;
           call _c8GyI() args: 0, res: 0, upd: 0;
       c8GBZ: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8Gwx::P64;
           Sp = Sp - 56;
           call _c8Gz4() args: 0, res: 0, upd: 0;
     }
 },
 _c8Gym() //  []
         { info_tbl: [(c8Gym,
                       label: block_c8Gym_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gym: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GzS; else goto c8GzR;
       c8GzS: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Gym_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GzR: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G91_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GwA() //  []
         { info_tbl: [(c8GwA,
                       label: block_c8GwA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GwA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Gzy; else goto c8Gzx;
       c8Gzy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GwA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Gzx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8n_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GwW() //  []
         { info_tbl: [(c8GwW,
                       label: block_c8GwW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GwW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GzC; else goto c8GzB;
       c8GzC: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GwW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GzB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8v_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Gxi() //  []
         { info_tbl: [(c8Gxi,
                       label: block_c8Gxi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gxi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GzG; else goto c8GzF;
       c8GzG: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Gxi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GzF: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8D_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GxE() //  []
         { info_tbl: [(c8GxE,
                       label: block_c8GxE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GxE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GzK; else goto c8GzJ;
       c8GzK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GxE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GzJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8L_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Gy0() //  []
         { info_tbl: [(c8Gy0,
                       label: block_c8Gy0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gy0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GzO; else goto c8GzN;
       c8GzO: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Gy0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GzN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8T_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GyI() //  []
         { info_tbl: [(c8GyI,
                       label: block_c8GyI_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GyI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GzW; else goto c8GzV;
       c8GzW: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GyI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GzV: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G99_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Gz4() //  []
         { info_tbl: [(c8Gz4,
                       label: block_c8Gz4_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gz4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GA0; else goto c8GzZ;
       c8GA0: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Gz4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GzZ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G9h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.71687567 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_decode_entry() //  [R2, R3]
         { info_tbl: [(c8GDf,
                       label: GHC.IO.Encoding.UTF16.utf16le_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GDf: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.717607241 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16le3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16le3_bytes:
         I8[] [85,84,70,49,54,45,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.718380922 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le2_entry() //  [R1]
         { info_tbl: [(c8GDo,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GDo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8GDp; else goto c8GDq;
       c8GDp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GDq: // global
           (_c8GDl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8GDl::I64 == 0) goto c8GDn; else goto c8GDm;
       c8GDn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8GDm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8GDl::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.719332526 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF2_entry() //  []
         { info_tbl: [(c8GDv,
                       label: GHC.IO.Encoding.UTF16.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GDv: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.720190792 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be1_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be1_entry() //  []
         { info_tbl: [(c8GDC,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GDC: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.721668194 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le_info;
         const 0;
 },
 sat_s8GaC_entry() //  [R1, R2, R3]
         { info_tbl: [(c8GDT,
                       label: sat_s8GaC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GDT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GaE_entry() //  [R1]
         { info_tbl: [(c8GDX,
                       label: sat_s8GaE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GDX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8GE1; else goto c8GE0;
       c8GE1: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8GE0: // global
           _s8Gaw::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GaC_info;
           P64[Hp - 48] = _s8Gaw::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gay_entry() //  [R1, R2, R3]
         { info_tbl: [(c8GEc,
                       label: sat_s8Gay_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GEc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GaA_entry() //  [R1]
         { info_tbl: [(c8GEg,
                       label: sat_s8GaA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GEg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8GEk; else goto c8GEj;
       c8GEk: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8GEj: // global
           _s8Gaw::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Gay_info;
           P64[Hp - 48] = _s8Gaw::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16le_entry() //  [R2]
         { info_tbl: [(c8GEm,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GEm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8GEq; else goto c8GEp;
       c8GEq: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8GEp: // global
           I64[Hp - 56] = sat_s8GaE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8GaA_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.72380966 UTC

[section ""data" . lvl_r8G1B_closure" {
     lvl_r8G1B_closure:
         const lvl_r8G1B_info;
         const 0;
 },
 lvl_r8G1B_entry() //  [R2, R3]
         { info_tbl: [(c8GEz,
                       label: lvl_r8G1B_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GEz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8GED; else goto c8GEE;
       c8GED: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8G1B_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GEE: // global
           I64[Sp - 16] = block_c8GEw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8GEM; else goto c8GEx;
       u8GEM: // global
           call _c8GEw() args: 0, res: 0, upd: 0;
       c8GEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GEw() //  []
         { info_tbl: [(c8GEw,
                       label: block_c8GEw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GEw: // global
           _s8GaG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8GEC_info;
           R1 = _s8GaG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8GEL; else goto c8GEG;
       u8GEL: // global
           call _c8GEC() args: 0, res: 0, upd: 0;
       c8GEG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GEC() //  []
         { info_tbl: [(c8GEC,
                       label: block_c8GEC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GEC: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.724974347 UTC

[section ""data" . lvl1_r8G1C_closure" {
     lvl1_r8G1C_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.725738555 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le2_closure" {
     GHC.IO.Encoding.UTF16.utf16le2_closure:
         const GHC.IO.Encoding.UTF16.utf16le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le2_entry() //  []
         { info_tbl: [(c8GER,
                       label: GHC.IO.Encoding.UTF16.utf16le2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GER: // global
           R1 = lvl1_r8G1C_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.72680602 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be2_closure" {
     GHC.IO.Encoding.UTF16.utf16be2_closure:
         const GHC.IO.Encoding.UTF16.utf16be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be2_entry() //  [R2, R3]
         { info_tbl: [(c8GF1,
                       label: GHC.IO.Encoding.UTF16.utf16be2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GF1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8GF5; else goto c8GF6;
       c8GF5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GF6: // global
           I64[Sp - 16] = block_c8GEY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8GFf; else goto c8GEZ;
       u8GFf: // global
           call _c8GEY(R1) args: 0, res: 0, upd: 0;
       c8GEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GEY() //  [R1]
         { info_tbl: [(c8GEY,
                       label: block_c8GEY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GEY: // global
           I64[Sp - 16] = block_c8GF4_info;
           _s8Gb2::P64 = P64[R1 + 7];
           _s8Gb1::I64 = I64[R1 + 23];
           _s8Gb5::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8Gb5::I64;
           P64[Sp] = _s8Gb2::P64;
           I64[Sp + 8] = _s8Gb1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8GFe; else goto c8GF8;
       u8GFe: // global
           call _c8GF4() args: 0, res: 0, upd: 0;
       c8GF8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GF4() //  []
         { info_tbl: [(c8GF4,
                       label: block_c8GF4_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GF4: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.728078389 UTC

[section ""data" . lvl2_r8G1D_closure" {
     lvl2_r8G1D_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.728795978 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le1_closure" {
     GHC.IO.Encoding.UTF16.utf16le1_closure:
         const GHC.IO.Encoding.UTF16.utf16le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le1_entry() //  []
         { info_tbl: [(c8GFk,
                       label: GHC.IO.Encoding.UTF16.utf16le1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GFk: // global
           R1 = lvl2_r8G1D_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.72957964 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_closure" {
     GHC.IO.Encoding.UTF16.utf16le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.UTF16.utf16le2_closure+1;
         const GHC.IO.Encoding.UTF16.utf16le1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.735870357 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF5_closure" {
     GHC.IO.Encoding.UTF16.mkUTF5_closure:
         const GHC.IO.Encoding.UTF16.mkUTF5_info;
 },
 sat_s8GbG_entry() //  [R1]
         { info_tbl: [(c8GFR,
                       label: sat_s8GbG_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GFR: // global
           _s8GbG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GFS; else goto c8GFT;
       c8GFT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GFV; else goto c8GFU;
       c8GFV: // global
           HpAlloc = 56;
           goto c8GFS;
       c8GFS: // global
           R1 = _s8GbG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GFU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbG::P64;
           _s8Gbs::I64 = I64[_s8GbG::P64 + 56];
           _s8GbC::I64 = I64[_s8GbG::P64 + 64];
           if (_s8GbC::I64 == _s8Gbs::I64) goto c8GFQ; else goto c8GFP;
       c8GFQ: // global
           _s8GbA::P64 = P64[_s8GbG::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GFP: // global
           _s8Gbo::P64 = P64[_s8GbG::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbG::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbG::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbG::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbC::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8GbO_entry() //  [R1]
         { info_tbl: [(c8GGd,
                       label: sat_s8GbO_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GGd: // global
           _s8GbO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GGe; else goto c8GGf;
       c8GGf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GGh; else goto c8GGg;
       c8GGh: // global
           HpAlloc = 56;
           goto c8GGe;
       c8GGe: // global
           R1 = _s8GbO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GGg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbO::P64;
           _s8Gbs::I64 = I64[_s8GbO::P64 + 56];
           _s8GbK::I64 = I64[_s8GbO::P64 + 64];
           if (_s8GbK::I64 == _s8Gbs::I64) goto c8GGc; else goto c8GGb;
       c8GGc: // global
           _s8GbA::P64 = P64[_s8GbO::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GGb: // global
           _s8Gbo::P64 = P64[_s8GbO::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbO::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbO::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbO::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbK::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8GbW_entry() //  [R1]
         { info_tbl: [(c8GGz,
                       label: sat_s8GbW_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GGz: // global
           _s8GbW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GGA; else goto c8GGB;
       c8GGB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GGD; else goto c8GGC;
       c8GGD: // global
           HpAlloc = 56;
           goto c8GGA;
       c8GGA: // global
           R1 = _s8GbW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GGC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbW::P64;
           _s8Gbs::I64 = I64[_s8GbW::P64 + 56];
           _s8GbS::I64 = I64[_s8GbW::P64 + 64];
           if (_s8GbS::I64 == _s8Gbs::I64) goto c8GGy; else goto c8GGx;
       c8GGy: // global
           _s8GbA::P64 = P64[_s8GbW::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GGx: // global
           _s8Gbo::P64 = P64[_s8GbW::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbW::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbW::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbW::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbS::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gc4_entry() //  [R1]
         { info_tbl: [(c8GGV,
                       label: sat_s8Gc4_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GGV: // global
           _s8Gc4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GGW; else goto c8GGX;
       c8GGX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GGZ; else goto c8GGY;
       c8GGZ: // global
           HpAlloc = 56;
           goto c8GGW;
       c8GGW: // global
           R1 = _s8Gc4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GGY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gc4::P64;
           _s8Gbs::I64 = I64[_s8Gc4::P64 + 56];
           _s8Gc0::I64 = I64[_s8Gc4::P64 + 64];
           if (_s8Gc0::I64 == _s8Gbs::I64) goto c8GGU; else goto c8GGT;
       c8GGU: // global
           _s8GbA::P64 = P64[_s8Gc4::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GGT: // global
           _s8Gbo::P64 = P64[_s8Gc4::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gc4::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gc4::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gc4::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gc0::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gcc_entry() //  [R1]
         { info_tbl: [(c8GHh,
                       label: sat_s8Gcc_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GHh: // global
           _s8Gcc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GHi; else goto c8GHj;
       c8GHj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GHl; else goto c8GHk;
       c8GHl: // global
           HpAlloc = 56;
           goto c8GHi;
       c8GHi: // global
           R1 = _s8Gcc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GHk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gcc::P64;
           _s8Gbs::I64 = I64[_s8Gcc::P64 + 56];
           _s8Gc8::I64 = I64[_s8Gcc::P64 + 64];
           if (_s8Gc8::I64 == _s8Gbs::I64) goto c8GHg; else goto c8GHf;
       c8GHg: // global
           _s8GbA::P64 = P64[_s8Gcc::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GHf: // global
           _s8Gbo::P64 = P64[_s8Gcc::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gcc::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gcc::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gcc::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gc8::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gck_entry() //  [R1]
         { info_tbl: [(c8GHD,
                       label: sat_s8Gck_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GHD: // global
           _s8Gck::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GHE; else goto c8GHF;
       c8GHF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GHH; else goto c8GHG;
       c8GHH: // global
           HpAlloc = 56;
           goto c8GHE;
       c8GHE: // global
           R1 = _s8Gck::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GHG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gck::P64;
           _s8Gbs::I64 = I64[_s8Gck::P64 + 56];
           _s8Gcg::I64 = I64[_s8Gck::P64 + 64];
           if (_s8Gcg::I64 == _s8Gbs::I64) goto c8GHC; else goto c8GHB;
       c8GHC: // global
           _s8GbA::P64 = P64[_s8Gck::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GHB: // global
           _s8Gbo::P64 = P64[_s8Gck::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gck::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gck::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gck::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gcg::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gcs_entry() //  [R1]
         { info_tbl: [(c8GHZ,
                       label: sat_s8Gcs_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GHZ: // global
           _s8Gcs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GI0; else goto c8GI1;
       c8GI1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GI3; else goto c8GI2;
       c8GI3: // global
           HpAlloc = 56;
           goto c8GI0;
       c8GI0: // global
           R1 = _s8Gcs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GI2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gcs::P64;
           _s8Gbs::I64 = I64[_s8Gcs::P64 + 56];
           _s8Gco::I64 = I64[_s8Gcs::P64 + 64];
           if (_s8Gco::I64 == _s8Gbs::I64) goto c8GHY; else goto c8GHX;
       c8GHY: // global
           _s8GbA::P64 = P64[_s8Gcs::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GHX: // global
           _s8Gbo::P64 = P64[_s8Gcs::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gcs::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gcs::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gcs::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gco::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8GcA_entry() //  [R1]
         { info_tbl: [(c8GIl,
                       label: sat_s8GcA_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GIl: // global
           _s8GcA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GIm; else goto c8GIn;
       c8GIn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GIp; else goto c8GIo;
       c8GIp: // global
           HpAlloc = 56;
           goto c8GIm;
       c8GIm: // global
           R1 = _s8GcA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GIo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GcA::P64;
           _s8Gbs::I64 = I64[_s8GcA::P64 + 56];
           _s8Gcw::I64 = I64[_s8GcA::P64 + 64];
           if (_s8Gcw::I64 == _s8Gbs::I64) goto c8GIk; else goto c8GIj;
       c8GIk: // global
           _s8GbA::P64 = P64[_s8GcA::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GIj: // global
           _s8Gbo::P64 = P64[_s8GcA::P64 + 16];
           _s8Gbp::P64 = P64[_s8GcA::P64 + 24];
           _s8Gbn::I64 = I64[_s8GcA::P64 + 40];
           _s8Gbq::I64 = I64[_s8GcA::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gcw::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF5_entry() //  [R2, R3]
         { info_tbl: [(c8GIs,
                       label: GHC.IO.Encoding.UTF16.mkUTF5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GIs: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8GIt; else goto c8GIu;
       c8GIt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GIu: // global
           I64[Sp - 16] = block_c8GFr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8GMe; else goto c8GFs;
       u8GMe: // global
           call _c8GFr(R1) args: 0, res: 0, upd: 0;
       c8GFs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GFr() //  [R1]
         { info_tbl: [(c8GFr,
                       label: block_c8GFr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GFr: // global
           I64[Sp - 40] = block_c8GFw_info;
           _s8Gbo::P64 = P64[R1 + 7];
           _s8Gbp::P64 = P64[R1 + 15];
           _s8Gbn::I64 = I64[R1 + 23];
           _s8Gbq::I64 = I64[R1 + 31];
           _s8Gbr::I64 = I64[R1 + 39];
           _s8Gbs::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Gbp::P64;
           I64[Sp - 24] = _s8Gbq::I64;
           I64[Sp - 16] = _s8Gbr::I64;
           I64[Sp - 8] = _s8Gbs::I64;
           P64[Sp] = _s8Gbo::P64;
           I64[Sp + 8] = _s8Gbn::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8GM5; else goto c8GFx;
       u8GM5: // global
           call _c8GFw(R1) args: 0, res: 0, upd: 0;
       c8GFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GFw() //  [R1]
         { info_tbl: [(c8GFw,
                       label: block_c8GFw_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GFw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GIy; else goto c8GIx;
       c8GIy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8GIx: // global
           _s8Gbv::P64 = P64[R1 + 7];
           _s8Gbw::P64 = P64[R1 + 15];
           _s8Gbu::I64 = I64[R1 + 23];
           _s8Gbx::I64 = I64[R1 + 31];
           _s8Gby::I64 = I64[R1 + 39];
           _s8Gbz::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Gbo::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Gbn::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Gbs::I64 = I64[Sp + 32];
           _c8GFB::P64 = Hp - 47;
           _s8GcF::I64 = _s8Gbz::I64;
           _s8GcE::I64 = I64[Sp + 24];
           goto c8GJ7;
       c8GJ7: // global
           if (%MO_S_Lt_W64(_s8GcF::I64,
                            _s8Gbx::I64)) goto c8GL2; else goto c8GL3;
       c8GL2: // global
           if (%MO_S_Lt_W64(_s8GcE::I64,
                            _s8Gbs::I64)) goto c8GKZ; else goto c8GL0;
       c8GKZ: // global
           if ((_s8GcE::I64 + 1) == _s8Gbs::I64) goto c8GKX; else goto c8GKW;
       c8GKX: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8GFB::P64;
           Sp = Sp - 56;
           call _c8GHq() args: 0, res: 0, upd: 0;
       c8GKW: // global
           _s8GcO::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + _s8GcE::I64]);
           call MO_Touch(_s8Gbo::P64);
           _s8GcU::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 1)]);
           call MO_Touch(_s8Gbo::P64);
           _s8GcW::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8GcO::I64 << 8)) + _s8GcU::I64));
           if (_s8GcW::I64 >= 55296) goto c8GKT; else goto c8GKU;
       c8GKT: // global
           if (_s8GcW::I64 <= 57343) goto c8GKQ; else goto c8GKR;
       c8GKQ: // global
           if (%MO_S_Ge_W64(_s8Gbs::I64 - _s8GcE::I64,
                            4)) goto c8GKN; else goto c8GKO;
       c8GKN: // global
           _s8Gd8::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 2)]);
           call MO_Touch(_s8Gbo::P64);
           _s8Gde::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 3)]);
           call MO_Touch(_s8Gbo::P64);
           if (_s8GcW::I64 < 55296) goto c8GKd; else goto c8GKL;
       c8GKd: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8GFB::P64;
           Sp = Sp - 56;
           call _c8GFE() args: 0, res: 0, upd: 0;
       c8GKL: // global
           if (_s8GcW::I64 > 56319) goto c8GKj; else goto c8GKK;
       c8GKj: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8GFB::P64;
           Sp = Sp - 56;
           call _c8GG0() args: 0, res: 0, upd: 0;
       c8GKK: // global
           _s8Gdi::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8Gd8::I64 << 8)) + _s8Gde::I64));
           if (_s8Gdi::I64 < 56320) goto c8GKB; else goto c8GKJ;
       c8GKB: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8GFB::P64;
           Sp = Sp - 56;
           call _c8GGm() args: 0, res: 0, upd: 0;
       c8GKJ: // global
           if (_s8Gdi::I64 > 57343) goto c8GKH; else goto c8GKI;
       c8GKH: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8GFB::P64;
           Sp = Sp - 56;
           call _c8GGI() args: 0, res: 0, upd: 0;
       c8GKI: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8GcW::I64 + -55296) << 10) + (_s8Gdi::I64 + -56320) + 65536);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 4;
           goto c8GJ7;
       c8GKO: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8GFB::P64;
           Sp = Sp - 56;
           call _c8GH4() args: 0, res: 0, upd: 0;
       c8GKR: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8GcW::I64);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 2;
           goto c8GJ7;
       c8GKU: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8GcW::I64);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 2;
           goto c8GJ7;
       c8GL0: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8GFB::P64;
           Sp = Sp - 56;
           call _c8GHM() args: 0, res: 0, upd: 0;
       c8GL3: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8GFB::P64;
           Sp = Sp - 56;
           call _c8GI8() args: 0, res: 0, upd: 0;
     }
 },
 _c8GHq() //  []
         { info_tbl: [(c8GHq,
                       label: block_c8GHq_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GHq: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GIW; else goto c8GIV;
       c8GIW: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GHq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GIV: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gck_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GFE() //  []
         { info_tbl: [(c8GFE,
                       label: block_c8GFE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GFE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GIC; else goto c8GIB;
       c8GIC: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GFE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GIB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbG_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GG0() //  []
         { info_tbl: [(c8GG0,
                       label: block_c8GG0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GG0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GIG; else goto c8GIF;
       c8GIG: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GG0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GIF: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbO_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GGm() //  []
         { info_tbl: [(c8GGm,
                       label: block_c8GGm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GGm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GIK; else goto c8GIJ;
       c8GIK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GGm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GIJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbW_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GGI() //  []
         { info_tbl: [(c8GGI,
                       label: block_c8GGI_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GGI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GIO; else goto c8GIN;
       c8GIO: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GGI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GIN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gc4_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GH4() //  []
         { info_tbl: [(c8GH4,
                       label: block_c8GH4_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GH4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GIS; else goto c8GIR;
       c8GIS: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GH4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GIR: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gcc_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GHM() //  []
         { info_tbl: [(c8GHM,
                       label: block_c8GHM_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GHM: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GJ0; else goto c8GIZ;
       c8GJ0: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GHM_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GIZ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gcs_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GI8() //  []
         { info_tbl: [(c8GI8,
                       label: block_c8GI8_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GI8: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GJ4; else goto c8GJ3;
       c8GJ4: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GI8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GJ3: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GcA_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.747466836 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_decode_entry() //  [R2, R3]
         { info_tbl: [(c8GMj,
                       label: GHC.IO.Encoding.UTF16.utf16be_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GMj: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.74821784 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16be3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16be3_bytes:
         I8[] [85,84,70,45,49,54,66,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.748928674 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be2_entry() //  [R1]
         { info_tbl: [(c8GMs,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GMs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8GMt; else goto c8GMu;
       c8GMt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GMu: // global
           (_c8GMp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8GMp::I64 == 0) goto c8GMr; else goto c8GMq;
       c8GMr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8GMq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8GMp::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.750865831 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be_info;
         const 0;
 },
 sat_s8GdS_entry() //  [R1, R2, R3]
         { info_tbl: [(c8GMJ,
                       label: sat_s8GdS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GMJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GdU_entry() //  [R1]
         { info_tbl: [(c8GMN,
                       label: sat_s8GdU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GMN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8GMR; else goto c8GMQ;
       c8GMR: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8GMQ: // global
           _s8GdM::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GdS_info;
           P64[Hp - 48] = _s8GdM::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GdO_entry() //  [R1, R2, R3]
         { info_tbl: [(c8GN2,
                       label: sat_s8GdO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GN2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GdQ_entry() //  [R1]
         { info_tbl: [(c8GN6,
                       label: sat_s8GdQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GN6: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8GNa; else goto c8GN9;
       c8GNa: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8GN9: // global
           _s8GdM::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GdO_info;
           P64[Hp - 48] = _s8GdM::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16be_entry() //  [R2]
         { info_tbl: [(c8GNc,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GNc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8GNg; else goto c8GNf;
       c8GNg: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8GNf: // global
           I64[Hp - 56] = sat_s8GdU_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8GdQ_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.75276593 UTC

[section ""data" . lvl3_r8G1E_closure" {
     lvl3_r8G1E_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.75349733 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be3_closure" {
     GHC.IO.Encoding.UTF16.utf16be3_closure:
         const GHC.IO.Encoding.UTF16.utf16be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be3_entry() //  []
         { info_tbl: [(c8GNl,
                       label: GHC.IO.Encoding.UTF16.utf16be3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GNl: // global
           R1 = lvl3_r8G1E_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.754228131 UTC

[section ""data" . lvl4_r8G1F_closure" {
     lvl4_r8G1F_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.75500325 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be1_closure" {
     GHC.IO.Encoding.UTF16.utf16be1_closure:
         const GHC.IO.Encoding.UTF16.utf16be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be1_entry() //  []
         { info_tbl: [(c8GNs,
                       label: GHC.IO.Encoding.UTF16.utf16be1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GNs: // global
           R1 = lvl4_r8G1F_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.755720518 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_closure" {
     GHC.IO.Encoding.UTF16.utf16be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const GHC.IO.Encoding.UTF16.utf16be3_closure+1;
         const GHC.IO.Encoding.UTF16.utf16be1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.756349326 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF6_closure" {
     GHC.IO.Encoding.UTF16.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.756974999 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF4_closure" {
     GHC.IO.Encoding.UTF16.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.759193067 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_decode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_decode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GNw: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8GNH,
                       label: GHC.IO.Encoding.UTF16.$wutf16_decode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GNH: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8GNI; else goto c8GNJ;
       c8GNI: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8GNJ: // global
           I64[Sp - 48] = block_c8GNA_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8GPc; else goto c8GNB;
       u8GPc: // global
           call _c8GNA(R1) args: 0, res: 0, upd: 0;
       c8GNB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GNA() //  [R1]
         { info_tbl: [(c8GNA,
                       label: block_c8GNA_info
                       rep:StackRep [False, True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GNA: // global
           _s8GdY::I64 = I64[Sp + 16];
           _s8GdZ::P64 = P64[Sp + 24];
           _s8Ge0::P64 = P64[Sp + 32];
           _s8Ge1::I64 = I64[Sp + 40];
           _s8Ge2::I64 = I64[Sp + 48];
           _s8Ge3::I64 = I64[Sp + 56];
           _s8Ge4::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8GNE; else goto c8GNF;
       c8GNE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8GNO; else goto c8GNN;
       c8GNO: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8GNN: // global
           if (%MO_S_Ge_W64(_s8Ge3::I64 - _s8Ge2::I64,
                            2)) goto c8GOZ; else goto c8GP3;
       c8GOZ: // global
           _s8GdX::P64 = P64[Sp + 8];
           _s8Gef::I64 = %MO_UU_Conv_W8_W64(I8[_s8GdY::I64 + _s8Ge2::I64]);
           call MO_Touch(_s8GdZ::P64);
           _s8Gel::I64 = %MO_UU_Conv_W8_W64(I8[_s8GdY::I64 + (_s8Ge2::I64 + 1)]);
           call MO_Touch(_s8GdZ::P64);
           if (_s8Gef::I64 != 254) goto c8GOM; else goto c8GOX;
       c8GOX: // global
           if (_s8Gel::I64 != 255) goto c8GOM; else goto c8GOW;
       c8GOM: // global
           Hp = Hp - 88;
           I64[Sp - 8] = _s8Gel::I64;
           I64[Sp] = _s8Gef::I64;
           Sp = Sp - 16;
           call _c8GO9() args: 0, res: 0, upd: 0;
       c8GOW: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8GdZ::P64;
           P64[Hp - 64] = _s8Ge0::P64;
           I64[Hp - 56] = _s8GdY::I64;
           I64[Hp - 48] = _s8Ge1::I64;
           I64[Hp - 40] = _s8Ge2::I64 + 2;
           I64[Hp - 32] = _s8Ge3::I64;
           _c8GOV::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8Ge4::P64;
           R2 = _c8GOV::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8GP3: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8GdZ::P64;
           P64[Hp - 64] = _s8Ge0::P64;
           I64[Hp - 56] = _s8GdY::I64;
           I64[Hp - 48] = _s8Ge1::I64;
           I64[Hp - 40] = _s8Ge2::I64;
           I64[Hp - 32] = _s8Ge3::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8Ge4::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8GNF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GP9; else goto c8GP8;
       c8GP9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8GP8: // global
           _s8GeE::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           R1 = _s8GeE::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GO9() //  []
         { info_tbl: [(c8GO9,
                       label: block_c8GO9_info
                       rep:StackRep [True, True, False, True, False, False, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GO9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GOd; else goto c8GOc;
       c8GOd: // global
           HpAlloc = 56;
           I64[Sp] = block_c8GO9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GOc: // global
           _s8GdX::P64 = P64[Sp + 24];
           _s8GdY::I64 = I64[Sp + 32];
           _s8GdZ::P64 = P64[Sp + 40];
           _s8Ge0::P64 = P64[Sp + 48];
           _s8Ge1::I64 = I64[Sp + 56];
           _s8Ge2::I64 = I64[Sp + 64];
           _s8Ge3::I64 = I64[Sp + 72];
           _s8Ge4::P64 = P64[Sp + 80];
           if (I64[Sp + 16] == 255) goto c8GOE; else goto c8GOl;
       c8GOE: // global
           if (I64[Sp + 8] == 254) goto c8GOD; else goto c8GOu;
       c8GOD: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64 + 2;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8GOu: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8GOl: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.764322897 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8GPk,
                       label: GHC.IO.Encoding.UTF16.utf16_decode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GPk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8GPo; else goto c8GPp;
       c8GPo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GPp: // global
           I64[Sp - 24] = block_c8GPh_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8GPx; else goto c8GPi;
       u8GPx: // global
           call _c8GPh(R1) args: 0, res: 0, upd: 0;
       c8GPi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GPh() //  [R1]
         { info_tbl: [(c8GPh,
                       label: block_c8GPh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GPh: // global
           I64[Sp] = block_c8GPn_info;
           _s8GeL::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8GeL::P64;
           if (R1 & 7 != 0) goto u8GPw; else goto c8GPr;
       u8GPw: // global
           call _c8GPn(R1) args: 0, res: 0, upd: 0;
       c8GPr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GPn() //  [R1]
         { info_tbl: [(c8GPn,
                       label: block_c8GPn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GPn: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.765754505 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8GPC,
                       label: GHC.IO.Encoding.UTF16.utf16_decode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GPC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.766496925 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF8_bytes:
         I8[] [85,84,70,45,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.767209166 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF7_closure" {
     GHC.IO.Encoding.UTF16.mkUTF7_closure:
         const GHC.IO.Encoding.UTF16.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF7_entry() //  [R1]
         { info_tbl: [(c8GPL,
                       label: GHC.IO.Encoding.UTF16.mkUTF7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GPL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8GPM; else goto c8GPN;
       c8GPM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GPN: // global
           (_c8GPI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8GPI::I64 == 0) goto c8GPK; else goto c8GPJ;
       c8GPK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8GPJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8GPI::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.770312789 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16_info;
         const 0;
 },
 sat_s8GfD_entry() //  [R1, R2]
         { info_tbl: [(c8GQ7,
                       label: sat_s8GfD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GQ7: // global
           _s8Gfl::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8Gfl::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Gfl::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfz_entry() //  [R1]
         { info_tbl: [(c8GQg,
                       label: sat_s8Gfz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GQg: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfx_entry() //  [R1, R2, R3]
         { info_tbl: [(c8GQo,
                       label: sat_s8Gfx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GQo: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfw_entry() //  [R1, R2, R3]
         { info_tbl: [(c8GQz,
                       label: sat_s8Gfw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GQz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8GQA; else goto c8GQB;
       c8GQA: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GQB: // global
           I64[Sp - 24] = block_c8GQw_info;
           _s8Gfl::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8Gfl::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8GQF; else goto c8GQx;
       u8GQF: // global
           call _c8GQw(R1) args: 0, res: 0, upd: 0;
       c8GQx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GQw() //  [R1]
         { info_tbl: [(c8GQw,
                       label: block_c8GQw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GQw: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8GfF_entry() //  [R1]
         { info_tbl: [(c8GQH,
                       label: sat_s8GfF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GQH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8GQI; else goto c8GQJ;
       c8GQI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8GQJ: // global
           I64[Sp - 16] = block_c8GPX_info;
           _s8GeT::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8GeT::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GPX() //  [R1]
         { info_tbl: [(c8GPX,
                       label: block_c8GPX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GPX: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8GQM; else goto c8GQL;
       c8GQM: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8GQL: // global
           I64[Hp - 104] = sat_s8GfD_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Gfz_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Gfx_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Gfw_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gff_entry() //  [R1, R2]
         { info_tbl: [(c8GR2,
                       label: sat_s8Gff_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GR2: // global
           _s8GeX::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8GeX::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GeX::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfb_entry() //  [R1]
         { info_tbl: [(c8GRb,
                       label: sat_s8Gfb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GRb: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gf9_entry() //  [R1, R2, R3]
         { info_tbl: [(c8GRj,
                       label: sat_s8Gf9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GRj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gf8_entry() //  [R1, R2, R3]
         { info_tbl: [(c8GRu,
                       label: sat_s8Gf8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GRu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8GRv; else goto c8GRw;
       c8GRv: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GRw: // global
           I64[Sp - 24] = block_c8GRr_info;
           _s8GeX::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8GeX::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8GRA; else goto c8GRs;
       u8GRA: // global
           call _c8GRr(R1) args: 0, res: 0, upd: 0;
       c8GRs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GRr() //  [R1]
         { info_tbl: [(c8GRr,
                       label: block_c8GRr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GRr: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8Gfh_entry() //  [R1]
         { info_tbl: [(c8GRC,
                       label: sat_s8Gfh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GRC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8GRD; else goto c8GRE;
       c8GRD: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8GRE: // global
           I64[Sp - 16] = block_c8GQS_info;
           _s8GeT::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8GeT::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GQS() //  [R1]
         { info_tbl: [(c8GQS,
                       label: block_c8GQS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GQS: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8GRH; else goto c8GRG;
       c8GRH: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8GRG: // global
           I64[Hp - 104] = sat_s8Gff_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Gfb_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Gf9_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Gf8_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16_entry() //  [R2]
         { info_tbl: [(c8GRJ,
                       label: GHC.IO.Encoding.UTF16.mkUTF16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GRJ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8GRN; else goto c8GRM;
       c8GRN: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8GRM: // global
           I64[Hp - 56] = sat_s8GfF_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Gfh_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.774563255 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_closure" {
     GHC.IO.Encoding.UTF16.utf16_closure:
         const GHC.IO.Encoding.UTF16.utf16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16_entry() //  [R1]
         { info_tbl: [(c8GRU,
                       label: GHC.IO.Encoding.UTF16.utf16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GRU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8GRV; else goto c8GRW;
       c8GRV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GRW: // global
           (_c8GRR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8GRR::I64 == 0) goto c8GRT; else goto c8GRS;
       c8GRT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8GRS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8GRR::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF16.mkUTF16_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.775488674 UTC

[section ""relreadonly" . S8GEr_srt" {
     S8GEr_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8G1B_closure;
         const lvl1_r8G1C_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF16.utf16be2_closure;
         const lvl2_r8G1D_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const lvl3_r8G1E_closure;
         const lvl4_r8G1F_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16_closure;
         const GHC.IO.Encoding.UTF16.mkUTF7_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.776131221 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:48.781997738 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF1_info;
 },
 sat_s8G24_entry() //  [R1]
         { info_tbl: [(c8GSr,
                       label: sat_s8G24_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GSr: // global
           _s8G24::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GSs; else goto c8GSt;
       c8GSt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GSv; else goto c8GSu;
       c8GSv: // global
           HpAlloc = 56;
           goto c8GSs;
       c8GSs: // global
           R1 = _s8G24::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GSu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G24::P64;
           _s8G1Q::I64 = I64[_s8G24::P64 + 56];
           _s8G20::I64 = I64[_s8G24::P64 + 64];
           if (_s8G20::I64 == _s8G1Q::I64) goto c8GSq; else goto c8GSp;
       c8GSq: // global
           _s8G1Y::P64 = P64[_s8G24::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GSp: // global
           _s8G1M::P64 = P64[_s8G24::P64 + 16];
           _s8G1N::P64 = P64[_s8G24::P64 + 24];
           _s8G1L::I64 = I64[_s8G24::P64 + 40];
           _s8G1O::I64 = I64[_s8G24::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G20::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2c_entry() //  [R1]
         { info_tbl: [(c8GSN,
                       label: sat_s8G2c_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GSN: // global
           _s8G2c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GSO; else goto c8GSP;
       c8GSP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GSR; else goto c8GSQ;
       c8GSR: // global
           HpAlloc = 56;
           goto c8GSO;
       c8GSO: // global
           R1 = _s8G2c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GSQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2c::P64;
           _s8G1Q::I64 = I64[_s8G2c::P64 + 56];
           _s8G28::I64 = I64[_s8G2c::P64 + 64];
           if (_s8G28::I64 == _s8G1Q::I64) goto c8GSM; else goto c8GSL;
       c8GSM: // global
           _s8G1Y::P64 = P64[_s8G2c::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GSL: // global
           _s8G1M::P64 = P64[_s8G2c::P64 + 16];
           _s8G1N::P64 = P64[_s8G2c::P64 + 24];
           _s8G1L::I64 = I64[_s8G2c::P64 + 40];
           _s8G1O::I64 = I64[_s8G2c::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G28::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2k_entry() //  [R1]
         { info_tbl: [(c8GT9,
                       label: sat_s8G2k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GT9: // global
           _s8G2k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GTa; else goto c8GTb;
       c8GTb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GTd; else goto c8GTc;
       c8GTd: // global
           HpAlloc = 56;
           goto c8GTa;
       c8GTa: // global
           R1 = _s8G2k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GTc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2k::P64;
           _s8G1Q::I64 = I64[_s8G2k::P64 + 56];
           _s8G2g::I64 = I64[_s8G2k::P64 + 64];
           if (_s8G2g::I64 == _s8G1Q::I64) goto c8GT8; else goto c8GT7;
       c8GT8: // global
           _s8G1Y::P64 = P64[_s8G2k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GT7: // global
           _s8G1M::P64 = P64[_s8G2k::P64 + 16];
           _s8G1N::P64 = P64[_s8G2k::P64 + 24];
           _s8G1L::I64 = I64[_s8G2k::P64 + 40];
           _s8G1O::I64 = I64[_s8G2k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2g::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2s_entry() //  [R1]
         { info_tbl: [(c8GTv,
                       label: sat_s8G2s_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GTv: // global
           _s8G2s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GTw; else goto c8GTx;
       c8GTx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GTz; else goto c8GTy;
       c8GTz: // global
           HpAlloc = 56;
           goto c8GTw;
       c8GTw: // global
           R1 = _s8G2s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GTy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2s::P64;
           _s8G1Q::I64 = I64[_s8G2s::P64 + 56];
           _s8G2o::I64 = I64[_s8G2s::P64 + 64];
           if (_s8G2o::I64 == _s8G1Q::I64) goto c8GTu; else goto c8GTt;
       c8GTu: // global
           _s8G1Y::P64 = P64[_s8G2s::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GTt: // global
           _s8G1M::P64 = P64[_s8G2s::P64 + 16];
           _s8G1N::P64 = P64[_s8G2s::P64 + 24];
           _s8G1L::I64 = I64[_s8G2s::P64 + 40];
           _s8G1O::I64 = I64[_s8G2s::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2o::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2A_entry() //  [R1]
         { info_tbl: [(c8GTR,
                       label: sat_s8G2A_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GTR: // global
           _s8G2A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GTS; else goto c8GTT;
       c8GTT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GTV; else goto c8GTU;
       c8GTV: // global
           HpAlloc = 56;
           goto c8GTS;
       c8GTS: // global
           R1 = _s8G2A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GTU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2A::P64;
           _s8G1Q::I64 = I64[_s8G2A::P64 + 56];
           _s8G2w::I64 = I64[_s8G2A::P64 + 64];
           if (_s8G2w::I64 == _s8G1Q::I64) goto c8GTQ; else goto c8GTP;
       c8GTQ: // global
           _s8G1Y::P64 = P64[_s8G2A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GTP: // global
           _s8G1M::P64 = P64[_s8G2A::P64 + 16];
           _s8G1N::P64 = P64[_s8G2A::P64 + 24];
           _s8G1L::I64 = I64[_s8G2A::P64 + 40];
           _s8G1O::I64 = I64[_s8G2A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2w::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2I_entry() //  [R1]
         { info_tbl: [(c8GUd,
                       label: sat_s8G2I_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GUd: // global
           _s8G2I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8GUe; else goto c8GUf;
       c8GUf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GUh; else goto c8GUg;
       c8GUh: // global
           HpAlloc = 56;
           goto c8GUe;
       c8GUe: // global
           R1 = _s8G2I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8GUg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2I::P64;
           _s8G1Q::I64 = I64[_s8G2I::P64 + 56];
           _s8G2E::I64 = I64[_s8G2I::P64 + 64];
           if (_s8G2E::I64 == _s8G1Q::I64) goto c8GUc; else goto c8GUb;
       c8GUc: // global
           _s8G1Y::P64 = P64[_s8G2I::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8GUb: // global
           _s8G1M::P64 = P64[_s8G2I::P64 + 16];
           _s8G1N::P64 = P64[_s8G2I::P64 + 24];
           _s8G1L::I64 = I64[_s8G2I::P64 + 40];
           _s8G1O::I64 = I64[_s8G2I::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2E::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8GUk,
                       label: GHC.IO.Encoding.UTF16.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GUk: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8GUl; else goto c8GUm;
       c8GUl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8GUm: // global
           I64[Sp - 16] = block_c8GS1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8GZs; else goto c8GS2;
       u8GZs: // global
           call _c8GS1(R1) args: 0, res: 0, upd: 0;
       c8GS2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GS1() //  [R1]
         { info_tbl: [(c8GS1,
                       label: block_c8GS1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GS1: // global
           I64[Sp - 40] = block_c8GS6_info;
           _s8G1M::P64 = P64[R1 + 7];
           _s8G1N::P64 = P64[R1 + 15];
           _s8G1L::I64 = I64[R1 + 23];
           _s8G1O::I64 = I64[R1 + 31];
           _s8G1P::I64 = I64[R1 + 39];
           _s8G1Q::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G1N::P64;
           I64[Sp - 24] = _s8G1O::I64;
           I64[Sp - 16] = _s8G1P::I64;
           I64[Sp - 8] = _s8G1Q::I64;
           P64[Sp] = _s8G1M::P64;
           I64[Sp + 8] = _s8G1L::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8GZl; else goto c8GS7;
       u8GZl: // global
           call _c8GS6(R1) args: 0, res: 0, upd: 0;
       c8GS7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GS6() //  [R1]
         { info_tbl: [(c8GS6,
                       label: block_c8GS6_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GS6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GUq; else goto c8GUp;
       c8GUq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8GUp: // global
           _s8G1T::P64 = P64[R1 + 7];
           _s8G1U::P64 = P64[R1 + 15];
           _s8G1S::I64 = I64[R1 + 23];
           _s8G1V::I64 = I64[R1 + 31];
           _s8G1W::I64 = I64[R1 + 39];
           _s8G1X::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G1M::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G1L::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G1Q::I64 = I64[Sp + 32];
           _c8GSb::P64 = Hp - 47;
           _s8G2N::I64 = _s8G1X::I64;
           _s8G2M::I64 = I64[Sp + 24];
           goto c8GUR;
       c8GUR: // global
           if (%MO_S_Lt_W64(_s8G2M::I64,
                            _s8G1Q::I64)) goto c8GW2; else goto c8GW3;
       c8GW2: // global
           if (%MO_S_Ge_W64(_s8G1V::I64 - _s8G2N::I64,
                            2)) goto c8GVZ; else goto c8GW0;
       c8GVZ: // global
           _s8G2U::I64 = %MO_UU_Conv_W32_W64(I32[_s8G1L::I64 + (_s8G2M::I64 << 2)]);
           call MO_Touch(_s8G1M::P64);
           if (%MO_S_Ge_W64(_s8G2U::I64, 65536)) goto c8GVk; else goto c8GVX;
       c8GVk: // global
           if (%MO_S_Ge_W64(_s8G1V::I64 - _s8G2N::I64,
                            4)) goto c8GVh; else goto c8GVi;
       c8GVh: // global
           _s8G30::I64 = _s8G2U::I64 - 65536;
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G30::I64,
                                                                            18) + 216);
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G30::I64,
                                                                                  10));
           call MO_Touch(_s8G1T::P64);
           _s8G3f::I64 = _s8G30::I64 & 1023;
           I8[_s8G1S::I64 + (_s8G2N::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G3f::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8G3f::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 4;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GUR;
       c8GVi: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GSb::P64;
           Sp = Sp - 56;
           call _c8GSe() args: 0, res: 0, upd: 0;
       c8GVX: // global
           if (%MO_S_Gt_W64(55296, _s8G2U::I64)) goto c8GVC; else goto c8GVW;
       c8GVC: // global
           if (%MO_S_Gt_W64(56320, _s8G2U::I64)) goto c8GVs; else goto c8GVA;
       c8GVs: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GUR;
       c8GVA: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 57343)) goto c8GVy; else goto c8GVz;
       c8GVy: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GUR;
       c8GVz: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GSb::P64;
           Sp = Sp - 56;
           call _c8GSA() args: 0, res: 0, upd: 0;
       c8GVW: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 56319)) goto c8GVU; else goto c8GVV;
       c8GVU: // global
           if (%MO_S_Gt_W64(56320, _s8G2U::I64)) goto c8GVK; else goto c8GVS;
       c8GVK: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GUR;
       c8GVS: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 57343)) goto c8GVQ; else goto c8GVR;
       c8GVQ: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8GUR;
       c8GVR: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GSb::P64;
           Sp = Sp - 56;
           call _c8GSW() args: 0, res: 0, upd: 0;
       c8GVV: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GSb::P64;
           Sp = Sp - 56;
           call _c8GTi() args: 0, res: 0, upd: 0;
       c8GW0: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GSb::P64;
           Sp = Sp - 56;
           call _c8GTE() args: 0, res: 0, upd: 0;
       c8GW3: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8GSb::P64;
           Sp = Sp - 56;
           call _c8GU0() args: 0, res: 0, upd: 0;
     }
 },
 _c8GSe() //  []
         { info_tbl: [(c8GSe,
                       label: block_c8GSe_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GSe: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GUu; else goto c8GUt;
       c8GUu: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GSe_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GUt: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G24_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GSA() //  []
         { info_tbl: [(c8GSA,
                       label: block_c8GSA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GSA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GUy; else goto c8GUx;
       c8GUy: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GSA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GUx: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2c_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GSW() //  []
         { info_tbl: [(c8GSW,
                       label: block_c8GSW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GSW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GUC; else goto c8GUB;
       c8GUC: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GSW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GUB: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GTi() //  []
         { info_tbl: [(c8GTi,
                       label: block_c8GTi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GTi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GUG; else goto c8GUF;
       c8GUG: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GTi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GUF: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2s_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GTE() //  []
         { info_tbl: [(c8GTE,
                       label: block_c8GTE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GTE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GUK; else goto c8GUJ;
       c8GUK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GTE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GUJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2A_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GU0() //  []
         { info_tbl: [(c8GU0,
                       label: block_c8GU0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GU0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8GUO; else goto c8GUN;
       c8GUO: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GU0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8GUN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2I_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.791713487 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_encode_entry() //  [R2, R3]
         { info_tbl: [(c8GZx,
                       label: GHC.IO.Encoding.UTF16.utf16be_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GZx: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.797874935 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le1_info;
 },
 sat_s8G4T_entry() //  [R1]
         { info_tbl: [(c8H04,
                       label: sat_s8G4T_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H04: // global
           _s8G4T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8H05; else goto c8H06;
       c8H06: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H08; else goto c8H07;
       c8H08: // global
           HpAlloc = 56;
           goto c8H05;
       c8H05: // global
           R1 = _s8G4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8H07: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G4T::P64;
           _s8G4F::I64 = I64[_s8G4T::P64 + 56];
           _s8G4P::I64 = I64[_s8G4T::P64 + 64];
           if (_s8G4P::I64 == _s8G4F::I64) goto c8H03; else goto c8H02;
       c8H03: // global
           _s8G4N::P64 = P64[_s8G4T::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8H02: // global
           _s8G4B::P64 = P64[_s8G4T::P64 + 16];
           _s8G4C::P64 = P64[_s8G4T::P64 + 24];
           _s8G4A::I64 = I64[_s8G4T::P64 + 40];
           _s8G4D::I64 = I64[_s8G4T::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G4P::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G51_entry() //  [R1]
         { info_tbl: [(c8H0q,
                       label: sat_s8G51_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H0q: // global
           _s8G51::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8H0r; else goto c8H0s;
       c8H0s: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H0u; else goto c8H0t;
       c8H0u: // global
           HpAlloc = 56;
           goto c8H0r;
       c8H0r: // global
           R1 = _s8G51::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8H0t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G51::P64;
           _s8G4F::I64 = I64[_s8G51::P64 + 56];
           _s8G4X::I64 = I64[_s8G51::P64 + 64];
           if (_s8G4X::I64 == _s8G4F::I64) goto c8H0p; else goto c8H0o;
       c8H0p: // global
           _s8G4N::P64 = P64[_s8G51::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8H0o: // global
           _s8G4B::P64 = P64[_s8G51::P64 + 16];
           _s8G4C::P64 = P64[_s8G51::P64 + 24];
           _s8G4A::I64 = I64[_s8G51::P64 + 40];
           _s8G4D::I64 = I64[_s8G51::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G4X::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G59_entry() //  [R1]
         { info_tbl: [(c8H0M,
                       label: sat_s8G59_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H0M: // global
           _s8G59::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8H0N; else goto c8H0O;
       c8H0O: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H0Q; else goto c8H0P;
       c8H0Q: // global
           HpAlloc = 56;
           goto c8H0N;
       c8H0N: // global
           R1 = _s8G59::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8H0P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G59::P64;
           _s8G4F::I64 = I64[_s8G59::P64 + 56];
           _s8G55::I64 = I64[_s8G59::P64 + 64];
           if (_s8G55::I64 == _s8G4F::I64) goto c8H0L; else goto c8H0K;
       c8H0L: // global
           _s8G4N::P64 = P64[_s8G59::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8H0K: // global
           _s8G4B::P64 = P64[_s8G59::P64 + 16];
           _s8G4C::P64 = P64[_s8G59::P64 + 24];
           _s8G4A::I64 = I64[_s8G59::P64 + 40];
           _s8G4D::I64 = I64[_s8G59::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G55::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G5h_entry() //  [R1]
         { info_tbl: [(c8H18,
                       label: sat_s8G5h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H18: // global
           _s8G5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8H19; else goto c8H1a;
       c8H1a: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H1c; else goto c8H1b;
       c8H1c: // global
           HpAlloc = 56;
           goto c8H19;
       c8H19: // global
           R1 = _s8G5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8H1b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5h::P64;
           _s8G4F::I64 = I64[_s8G5h::P64 + 56];
           _s8G5d::I64 = I64[_s8G5h::P64 + 64];
           if (_s8G5d::I64 == _s8G4F::I64) goto c8H17; else goto c8H16;
       c8H17: // global
           _s8G4N::P64 = P64[_s8G5h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8H16: // global
           _s8G4B::P64 = P64[_s8G5h::P64 + 16];
           _s8G4C::P64 = P64[_s8G5h::P64 + 24];
           _s8G4A::I64 = I64[_s8G5h::P64 + 40];
           _s8G4D::I64 = I64[_s8G5h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5d::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G5p_entry() //  [R1]
         { info_tbl: [(c8H1u,
                       label: sat_s8G5p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H1u: // global
           _s8G5p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8H1v; else goto c8H1w;
       c8H1w: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H1y; else goto c8H1x;
       c8H1y: // global
           HpAlloc = 56;
           goto c8H1v;
       c8H1v: // global
           R1 = _s8G5p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8H1x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5p::P64;
           _s8G4F::I64 = I64[_s8G5p::P64 + 56];
           _s8G5l::I64 = I64[_s8G5p::P64 + 64];
           if (_s8G5l::I64 == _s8G4F::I64) goto c8H1t; else goto c8H1s;
       c8H1t: // global
           _s8G4N::P64 = P64[_s8G5p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8H1s: // global
           _s8G4B::P64 = P64[_s8G5p::P64 + 16];
           _s8G4C::P64 = P64[_s8G5p::P64 + 24];
           _s8G4A::I64 = I64[_s8G5p::P64 + 40];
           _s8G4D::I64 = I64[_s8G5p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5l::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G5x_entry() //  [R1]
         { info_tbl: [(c8H1Q,
                       label: sat_s8G5x_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H1Q: // global
           _s8G5x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8H1R; else goto c8H1S;
       c8H1S: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H1U; else goto c8H1T;
       c8H1U: // global
           HpAlloc = 56;
           goto c8H1R;
       c8H1R: // global
           R1 = _s8G5x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8H1T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5x::P64;
           _s8G4F::I64 = I64[_s8G5x::P64 + 56];
           _s8G5t::I64 = I64[_s8G5x::P64 + 64];
           if (_s8G5t::I64 == _s8G4F::I64) goto c8H1P; else goto c8H1O;
       c8H1P: // global
           _s8G4N::P64 = P64[_s8G5x::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8H1O: // global
           _s8G4B::P64 = P64[_s8G5x::P64 + 16];
           _s8G4C::P64 = P64[_s8G5x::P64 + 24];
           _s8G4A::I64 = I64[_s8G5x::P64 + 40];
           _s8G4D::I64 = I64[_s8G5x::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5t::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16le1_entry() //  [R2, R3]
         { info_tbl: [(c8H1X,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H1X: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8H1Y; else goto c8H1Z;
       c8H1Y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8H1Z: // global
           I64[Sp - 16] = block_c8GZE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8H75; else goto c8GZF;
       u8H75: // global
           call _c8GZE(R1) args: 0, res: 0, upd: 0;
       c8GZF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GZE() //  [R1]
         { info_tbl: [(c8GZE,
                       label: block_c8GZE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GZE: // global
           I64[Sp - 40] = block_c8GZJ_info;
           _s8G4B::P64 = P64[R1 + 7];
           _s8G4C::P64 = P64[R1 + 15];
           _s8G4A::I64 = I64[R1 + 23];
           _s8G4D::I64 = I64[R1 + 31];
           _s8G4E::I64 = I64[R1 + 39];
           _s8G4F::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G4C::P64;
           I64[Sp - 24] = _s8G4D::I64;
           I64[Sp - 16] = _s8G4E::I64;
           I64[Sp - 8] = _s8G4F::I64;
           P64[Sp] = _s8G4B::P64;
           I64[Sp + 8] = _s8G4A::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8H6Y; else goto c8GZK;
       u8H6Y: // global
           call _c8GZJ(R1) args: 0, res: 0, upd: 0;
       c8GZK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GZJ() //  [R1]
         { info_tbl: [(c8GZJ,
                       label: block_c8GZJ_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GZJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H23; else goto c8H22;
       c8H23: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8H22: // global
           _s8G4I::P64 = P64[R1 + 7];
           _s8G4J::P64 = P64[R1 + 15];
           _s8G4H::I64 = I64[R1 + 23];
           _s8G4K::I64 = I64[R1 + 31];
           _s8G4L::I64 = I64[R1 + 39];
           _s8G4M::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G4B::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G4A::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G4F::I64 = I64[Sp + 32];
           _c8GZO::P64 = Hp - 47;
           _s8G5C::I64 = _s8G4M::I64;
           _s8G5B::I64 = I64[Sp + 24];
           goto c8H2u;
       c8H2u: // global
           if (%MO_S_Lt_W64(_s8G5B::I64,
                            _s8G4F::I64)) goto c8H3F; else goto c8H3G;
       c8H3F: // global
           if (%MO_S_Ge_W64(_s8G4K::I64 - _s8G5C::I64,
                            2)) goto c8H3C; else goto c8H3D;
       c8H3C: // global
           _s8G5J::I64 = %MO_UU_Conv_W32_W64(I32[_s8G4A::I64 + (_s8G5B::I64 << 2)]);
           call MO_Touch(_s8G4B::P64);
           if (%MO_S_Ge_W64(_s8G5J::I64, 65536)) goto c8H2X; else goto c8H3A;
       c8H2X: // global
           if (%MO_S_Ge_W64(_s8G4K::I64 - _s8G5C::I64,
                            4)) goto c8H2U; else goto c8H2V;
       c8H2U: // global
           _s8G5P::I64 = _s8G5J::I64 - 65536;
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5P::I64,
                                                                            10));
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5P::I64,
                                                                                  18) + 216);
           call MO_Touch(_s8G4I::P64);
           _s8G64::I64 = _s8G5P::I64 & 1023;
           I8[_s8G4H::I64 + (_s8G5C::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8G64::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G64::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 4;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8H2u;
       c8H2V: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8GZO::P64;
           Sp = Sp - 56;
           call _c8GZR() args: 0, res: 0, upd: 0;
       c8H3A: // global
           if (%MO_S_Gt_W64(55296, _s8G5J::I64)) goto c8H3f; else goto c8H3z;
       c8H3f: // global
           if (%MO_S_Gt_W64(56320, _s8G5J::I64)) goto c8H35; else goto c8H3d;
       c8H35: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8H2u;
       c8H3d: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 57343)) goto c8H3b; else goto c8H3c;
       c8H3b: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8H2u;
       c8H3c: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8GZO::P64;
           Sp = Sp - 56;
           call _c8H0d() args: 0, res: 0, upd: 0;
       c8H3z: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 56319)) goto c8H3x; else goto c8H3y;
       c8H3x: // global
           if (%MO_S_Gt_W64(56320, _s8G5J::I64)) goto c8H3n; else goto c8H3v;
       c8H3n: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8H2u;
       c8H3v: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 57343)) goto c8H3t; else goto c8H3u;
       c8H3t: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8H2u;
       c8H3u: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8GZO::P64;
           Sp = Sp - 56;
           call _c8H0z() args: 0, res: 0, upd: 0;
       c8H3y: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8GZO::P64;
           Sp = Sp - 56;
           call _c8H0V() args: 0, res: 0, upd: 0;
       c8H3D: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8GZO::P64;
           Sp = Sp - 56;
           call _c8H1h() args: 0, res: 0, upd: 0;
       c8H3G: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8GZO::P64;
           Sp = Sp - 56;
           call _c8H1D() args: 0, res: 0, upd: 0;
     }
 },
 _c8GZR() //  []
         { info_tbl: [(c8GZR,
                       label: block_c8GZR_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GZR: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8H27; else goto c8H26;
       c8H27: // global
           HpAlloc = 160;
           I64[Sp] = block_c8GZR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8H26: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G4T_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8H0d() //  []
         { info_tbl: [(c8H0d,
                       label: block_c8H0d_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H0d: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8H2b; else goto c8H2a;
       c8H2b: // global
           HpAlloc = 160;
           I64[Sp] = block_c8H0d_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8H2a: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G51_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8H0z() //  []
         { info_tbl: [(c8H0z,
                       label: block_c8H0z_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H0z: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8H2f; else goto c8H2e;
       c8H2f: // global
           HpAlloc = 160;
           I64[Sp] = block_c8H0z_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8H2e: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G59_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8H0V() //  []
         { info_tbl: [(c8H0V,
                       label: block_c8H0V_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H0V: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8H2j; else goto c8H2i;
       c8H2j: // global
           HpAlloc = 160;
           I64[Sp] = block_c8H0V_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8H2i: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8H1h() //  []
         { info_tbl: [(c8H1h,
                       label: block_c8H1h_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H1h: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8H2n; else goto c8H2m;
       c8H2n: // global
           HpAlloc = 160;
           I64[Sp] = block_c8H1h_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8H2m: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8H1D() //  []
         { info_tbl: [(c8H1D,
                       label: block_c8H1D_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H1D: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8H2r; else goto c8H2q;
       c8H2r: // global
           HpAlloc = 160;
           I64[Sp] = block_c8H1D_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8H2q: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5x_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.809262711 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_encode_entry() //  [R2, R3]
         { info_tbl: [(c8H7a,
                       label: GHC.IO.Encoding.UTF16.utf16le_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H7a: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF16le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.810030266 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule4_bytes" {
     GHC.IO.Encoding.UTF16.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.810610555 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule3_closure" {
     GHC.IO.Encoding.UTF16.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.811166996 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule2_bytes" {
     GHC.IO.Encoding.UTF16.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.811752238 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule1_closure" {
     GHC.IO.Encoding.UTF16.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.812333141 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule_closure" {
     GHC.IO.Encoding.UTF16.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF16.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF16.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.813830325 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_encode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_encode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H7e: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8H7p,
                       label: GHC.IO.Encoding.UTF16.$wutf16_encode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H7p: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8H7q; else goto c8H7r;
       c8H7q: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8H7r: // global
           I64[Sp - 48] = block_c8H7i_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8H87; else goto c8H7j;
       u8H87: // global
           call _c8H7i(R1) args: 0, res: 0, upd: 0;
       c8H7j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8H7i() //  [R1]
         { info_tbl: [(c8H7i,
                       label: block_c8H7i_info
                       rep:StackRep [False, False, True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H7i: // global
           _s8G7m::P64 = P64[Sp + 16];
           _s8G7n::I64 = I64[Sp + 24];
           _s8G7o::P64 = P64[Sp + 32];
           _s8G7p::P64 = P64[Sp + 40];
           _s8G7q::I64 = I64[Sp + 48];
           _s8G7r::I64 = I64[Sp + 56];
           _s8G7s::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8H7m; else goto c8H7n;
       c8H7m: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8H7w; else goto c8H7v;
       c8H7w: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8H7v: // global
           if (%MO_S_Ge_W64(_s8G7q::I64 - _s8G7s::I64,
                            2)) goto c8H7W; else goto c8H80;
       c8H7W: // global
           _s8G7l::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8G7l::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8G7l::P64);
           I8[_s8G7n::I64 + _s8G7s::I64] = 254 :: W8;
           call MO_Touch(_s8G7o::P64);
           I8[_s8G7n::I64 + (_s8G7s::I64 + 1)] = 255 :: W8;
           call MO_Touch(_s8G7o::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8G7o::P64;
           P64[Hp - 64] = _s8G7p::P64;
           I64[Hp - 56] = _s8G7n::I64;
           I64[Hp - 48] = _s8G7q::I64;
           I64[Hp - 40] = _s8G7r::I64;
           I64[Hp - 32] = _s8G7s::I64 + 2;
           _c8H7U::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8H7U::P64;
           R2 = _s8G7m::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8H80: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8G7o::P64;
           P64[Hp - 64] = _s8G7p::P64;
           I64[Hp - 56] = _s8G7n::I64;
           I64[Hp - 48] = _s8G7q::I64;
           I64[Hp - 40] = _s8G7r::I64;
           I64[Hp - 32] = _s8G7s::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8G7m::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8H7n: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H86; else goto c8H85;
       c8H86: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8H85: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G7o::P64;
           P64[Hp - 32] = _s8G7p::P64;
           I64[Hp - 24] = _s8G7n::I64;
           I64[Hp - 16] = _s8G7q::I64;
           I64[Hp - 8] = _s8G7r::I64;
           I64[Hp] = _s8G7s::I64;
           R3 = Hp - 47;
           R2 = _s8G7m::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.816320558 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8H8f,
                       label: GHC.IO.Encoding.UTF16.utf16_encode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H8f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8H8j; else goto c8H8k;
       c8H8j: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8H8k: // global
           I64[Sp - 24] = block_c8H8c_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8H8s; else goto c8H8d;
       u8H8s: // global
           call _c8H8c(R1) args: 0, res: 0, upd: 0;
       c8H8d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8H8c() //  [R1]
         { info_tbl: [(c8H8c,
                       label: block_c8H8c_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H8c: // global
           I64[Sp] = block_c8H8i_info;
           _s8G7S::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8G7S::P64;
           if (R1 & 7 != 0) goto u8H8r; else goto c8H8m;
       u8H8r: // global
           call _c8H8i(R1) args: 0, res: 0, upd: 0;
       c8H8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8H8i() //  [R1]
         { info_tbl: [(c8H8i,
                       label: block_c8H8i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H8i: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.817729419 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8H8x,
                       label: GHC.IO.Encoding.UTF16.utf16_encode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H8x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.824176633 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF3_closure" {
     GHC.IO.Encoding.UTF16.mkUTF3_closure:
         const GHC.IO.Encoding.UTF16.mkUTF3_info;
 },
 sat_s8G8n_entry() //  [R1]
         { info_tbl: [(c8H94,
                       label: sat_s8G8n_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H94: // global
           _s8G8n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8H95; else goto c8H96;
       c8H96: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H98; else goto c8H97;
       c8H98: // global
           HpAlloc = 56;
           goto c8H95;
       c8H95: // global
           R1 = _s8G8n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8H97: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8n::P64;
           _s8G89::I64 = I64[_s8G8n::P64 + 56];
           _s8G8j::I64 = I64[_s8G8n::P64 + 64];
           if (_s8G8j::I64 == _s8G89::I64) goto c8H93; else goto c8H92;
       c8H93: // global
           _s8G8h::P64 = P64[_s8G8n::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8H92: // global
           _s8G85::P64 = P64[_s8G8n::P64 + 16];
           _s8G86::P64 = P64[_s8G8n::P64 + 24];
           _s8G84::I64 = I64[_s8G8n::P64 + 40];
           _s8G87::I64 = I64[_s8G8n::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8j::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8v_entry() //  [R1]
         { info_tbl: [(c8H9q,
                       label: sat_s8G8v_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H9q: // global
           _s8G8v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8H9r; else goto c8H9s;
       c8H9s: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H9u; else goto c8H9t;
       c8H9u: // global
           HpAlloc = 56;
           goto c8H9r;
       c8H9r: // global
           R1 = _s8G8v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8H9t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8v::P64;
           _s8G89::I64 = I64[_s8G8v::P64 + 56];
           _s8G8r::I64 = I64[_s8G8v::P64 + 64];
           if (_s8G8r::I64 == _s8G89::I64) goto c8H9p; else goto c8H9o;
       c8H9p: // global
           _s8G8h::P64 = P64[_s8G8v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8H9o: // global
           _s8G85::P64 = P64[_s8G8v::P64 + 16];
           _s8G86::P64 = P64[_s8G8v::P64 + 24];
           _s8G84::I64 = I64[_s8G8v::P64 + 40];
           _s8G87::I64 = I64[_s8G8v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8r::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8D_entry() //  [R1]
         { info_tbl: [(c8H9M,
                       label: sat_s8G8D_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H9M: // global
           _s8G8D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8H9N; else goto c8H9O;
       c8H9O: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8H9Q; else goto c8H9P;
       c8H9Q: // global
           HpAlloc = 56;
           goto c8H9N;
       c8H9N: // global
           R1 = _s8G8D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8H9P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8D::P64;
           _s8G89::I64 = I64[_s8G8D::P64 + 56];
           _s8G8z::I64 = I64[_s8G8D::P64 + 64];
           if (_s8G8z::I64 == _s8G89::I64) goto c8H9L; else goto c8H9K;
       c8H9L: // global
           _s8G8h::P64 = P64[_s8G8D::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8H9K: // global
           _s8G85::P64 = P64[_s8G8D::P64 + 16];
           _s8G86::P64 = P64[_s8G8D::P64 + 24];
           _s8G84::I64 = I64[_s8G8D::P64 + 40];
           _s8G87::I64 = I64[_s8G8D::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8z::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8L_entry() //  [R1]
         { info_tbl: [(c8Ha8,
                       label: sat_s8G8L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ha8: // global
           _s8G8L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ha9; else goto c8Haa;
       c8Haa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hac; else goto c8Hab;
       c8Hac: // global
           HpAlloc = 56;
           goto c8Ha9;
       c8Ha9: // global
           R1 = _s8G8L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hab: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8L::P64;
           _s8G89::I64 = I64[_s8G8L::P64 + 56];
           _s8G8H::I64 = I64[_s8G8L::P64 + 64];
           if (_s8G8H::I64 == _s8G89::I64) goto c8Ha7; else goto c8Ha6;
       c8Ha7: // global
           _s8G8h::P64 = P64[_s8G8L::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Ha6: // global
           _s8G85::P64 = P64[_s8G8L::P64 + 16];
           _s8G86::P64 = P64[_s8G8L::P64 + 24];
           _s8G84::I64 = I64[_s8G8L::P64 + 40];
           _s8G87::I64 = I64[_s8G8L::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8H::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8T_entry() //  [R1]
         { info_tbl: [(c8Hau,
                       label: sat_s8G8T_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hau: // global
           _s8G8T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hav; else goto c8Haw;
       c8Haw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hay; else goto c8Hax;
       c8Hay: // global
           HpAlloc = 56;
           goto c8Hav;
       c8Hav: // global
           R1 = _s8G8T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hax: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8T::P64;
           _s8G89::I64 = I64[_s8G8T::P64 + 56];
           _s8G8P::I64 = I64[_s8G8T::P64 + 64];
           if (_s8G8P::I64 == _s8G89::I64) goto c8Hat; else goto c8Has;
       c8Hat: // global
           _s8G8h::P64 = P64[_s8G8T::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Has: // global
           _s8G85::P64 = P64[_s8G8T::P64 + 16];
           _s8G86::P64 = P64[_s8G8T::P64 + 24];
           _s8G84::I64 = I64[_s8G8T::P64 + 40];
           _s8G87::I64 = I64[_s8G8T::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8P::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G91_entry() //  [R1]
         { info_tbl: [(c8HaQ,
                       label: sat_s8G91_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HaQ: // global
           _s8G91::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HaR; else goto c8HaS;
       c8HaS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HaU; else goto c8HaT;
       c8HaU: // global
           HpAlloc = 56;
           goto c8HaR;
       c8HaR: // global
           R1 = _s8G91::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HaT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G91::P64;
           _s8G89::I64 = I64[_s8G91::P64 + 56];
           _s8G8X::I64 = I64[_s8G91::P64 + 64];
           if (_s8G8X::I64 == _s8G89::I64) goto c8HaP; else goto c8HaO;
       c8HaP: // global
           _s8G8h::P64 = P64[_s8G91::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HaO: // global
           _s8G85::P64 = P64[_s8G91::P64 + 16];
           _s8G86::P64 = P64[_s8G91::P64 + 24];
           _s8G84::I64 = I64[_s8G91::P64 + 40];
           _s8G87::I64 = I64[_s8G91::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8X::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G99_entry() //  [R1]
         { info_tbl: [(c8Hbc,
                       label: sat_s8G99_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hbc: // global
           _s8G99::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hbd; else goto c8Hbe;
       c8Hbe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hbg; else goto c8Hbf;
       c8Hbg: // global
           HpAlloc = 56;
           goto c8Hbd;
       c8Hbd: // global
           R1 = _s8G99::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hbf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G99::P64;
           _s8G89::I64 = I64[_s8G99::P64 + 56];
           _s8G95::I64 = I64[_s8G99::P64 + 64];
           if (_s8G95::I64 == _s8G89::I64) goto c8Hbb; else goto c8Hba;
       c8Hbb: // global
           _s8G8h::P64 = P64[_s8G99::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hba: // global
           _s8G85::P64 = P64[_s8G99::P64 + 16];
           _s8G86::P64 = P64[_s8G99::P64 + 24];
           _s8G84::I64 = I64[_s8G99::P64 + 40];
           _s8G87::I64 = I64[_s8G99::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G95::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G9h_entry() //  [R1]
         { info_tbl: [(c8Hby,
                       label: sat_s8G9h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hby: // global
           _s8G9h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hbz; else goto c8HbA;
       c8HbA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HbC; else goto c8HbB;
       c8HbC: // global
           HpAlloc = 56;
           goto c8Hbz;
       c8Hbz: // global
           R1 = _s8G9h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HbB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G9h::P64;
           _s8G89::I64 = I64[_s8G9h::P64 + 56];
           _s8G9d::I64 = I64[_s8G9h::P64 + 64];
           if (_s8G9d::I64 == _s8G89::I64) goto c8Hbx; else goto c8Hbw;
       c8Hbx: // global
           _s8G8h::P64 = P64[_s8G9h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hbw: // global
           _s8G85::P64 = P64[_s8G9h::P64 + 16];
           _s8G86::P64 = P64[_s8G9h::P64 + 24];
           _s8G84::I64 = I64[_s8G9h::P64 + 40];
           _s8G87::I64 = I64[_s8G9h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G9d::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF3_entry() //  [R2, R3]
         { info_tbl: [(c8HbF,
                       label: GHC.IO.Encoding.UTF16.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HbF: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8HbG; else goto c8HbH;
       c8HbG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HbH: // global
           I64[Sp - 16] = block_c8H8E_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Hfr; else goto c8H8F;
       u8Hfr: // global
           call _c8H8E(R1) args: 0, res: 0, upd: 0;
       c8H8F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8H8E() //  [R1]
         { info_tbl: [(c8H8E,
                       label: block_c8H8E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H8E: // global
           I64[Sp - 40] = block_c8H8J_info;
           _s8G85::P64 = P64[R1 + 7];
           _s8G86::P64 = P64[R1 + 15];
           _s8G84::I64 = I64[R1 + 23];
           _s8G87::I64 = I64[R1 + 31];
           _s8G88::I64 = I64[R1 + 39];
           _s8G89::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G86::P64;
           I64[Sp - 24] = _s8G87::I64;
           I64[Sp - 16] = _s8G88::I64;
           I64[Sp - 8] = _s8G89::I64;
           P64[Sp] = _s8G85::P64;
           I64[Sp + 8] = _s8G84::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Hfi; else goto c8H8K;
       u8Hfi: // global
           call _c8H8J(R1) args: 0, res: 0, upd: 0;
       c8H8K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8H8J() //  [R1]
         { info_tbl: [(c8H8J,
                       label: block_c8H8J_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H8J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HbL; else goto c8HbK;
       c8HbL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HbK: // global
           _s8G8c::P64 = P64[R1 + 7];
           _s8G8d::P64 = P64[R1 + 15];
           _s8G8b::I64 = I64[R1 + 23];
           _s8G8e::I64 = I64[R1 + 31];
           _s8G8f::I64 = I64[R1 + 39];
           _s8G8g::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G85::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G84::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G89::I64 = I64[Sp + 32];
           _c8H8O::P64 = Hp - 47;
           _s8G9m::I64 = _s8G8g::I64;
           _s8G9l::I64 = I64[Sp + 24];
           goto c8Hck;
       c8Hck: // global
           if (%MO_S_Lt_W64(_s8G9m::I64,
                            _s8G8e::I64)) goto c8Hef; else goto c8Heg;
       c8Hef: // global
           if (%MO_S_Lt_W64(_s8G9l::I64,
                            _s8G89::I64)) goto c8Hec; else goto c8Hed;
       c8Hec: // global
           if ((_s8G9l::I64 + 1) == _s8G89::I64) goto c8Hea; else goto c8He9;
       c8Hea: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8H8O::P64;
           Sp = Sp - 56;
           call _c8HaD() args: 0, res: 0, upd: 0;
       c8He9: // global
           _s8G9v::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + _s8G9l::I64]);
           call MO_Touch(_s8G85::P64);
           _s8G9B::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 1)]);
           call MO_Touch(_s8G85::P64);
           _s8G9D::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8G9B::I64 << 8)) + _s8G9v::I64));
           if (_s8G9D::I64 >= 55296) goto c8He6; else goto c8He7;
       c8He6: // global
           if (_s8G9D::I64 <= 57343) goto c8He3; else goto c8He4;
       c8He3: // global
           if (%MO_S_Ge_W64(_s8G89::I64 - _s8G9l::I64,
                            4)) goto c8He0; else goto c8He1;
       c8He0: // global
           _s8G9P::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 2)]);
           call MO_Touch(_s8G85::P64);
           _s8G9V::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 3)]);
           call MO_Touch(_s8G85::P64);
           if (_s8G9D::I64 < 55296) goto c8Hdq; else goto c8HdY;
       c8Hdq: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8H8O::P64;
           Sp = Sp - 56;
           call _c8H8R() args: 0, res: 0, upd: 0;
       c8HdY: // global
           if (_s8G9D::I64 > 56319) goto c8Hdw; else goto c8HdX;
       c8Hdw: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8H8O::P64;
           Sp = Sp - 56;
           call _c8H9d() args: 0, res: 0, upd: 0;
       c8HdX: // global
           _s8G9Z::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8G9V::I64 << 8)) + _s8G9P::I64));
           if (_s8G9Z::I64 < 56320) goto c8HdO; else goto c8HdW;
       c8HdO: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8H8O::P64;
           Sp = Sp - 56;
           call _c8H9z() args: 0, res: 0, upd: 0;
       c8HdW: // global
           if (_s8G9Z::I64 > 57343) goto c8HdU; else goto c8HdV;
       c8HdU: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8H8O::P64;
           Sp = Sp - 56;
           call _c8H9V() args: 0, res: 0, upd: 0;
       c8HdV: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8G9D::I64 + -55296) << 10) + (_s8G9Z::I64 + -56320) + 65536);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 4;
           goto c8Hck;
       c8He1: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8H8O::P64;
           Sp = Sp - 56;
           call _c8Hah() args: 0, res: 0, upd: 0;
       c8He4: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8G9D::I64);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 2;
           goto c8Hck;
       c8He7: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8G9D::I64);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 2;
           goto c8Hck;
       c8Hed: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8H8O::P64;
           Sp = Sp - 56;
           call _c8HaZ() args: 0, res: 0, upd: 0;
       c8Heg: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8H8O::P64;
           Sp = Sp - 56;
           call _c8Hbl() args: 0, res: 0, upd: 0;
     }
 },
 _c8HaD() //  []
         { info_tbl: [(c8HaD,
                       label: block_c8HaD_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HaD: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hc9; else goto c8Hc8;
       c8Hc9: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HaD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hc8: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G91_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8H8R() //  []
         { info_tbl: [(c8H8R,
                       label: block_c8H8R_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H8R: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HbP; else goto c8HbO;
       c8HbP: // global
           HpAlloc = 160;
           I64[Sp] = block_c8H8R_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HbO: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8n_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8H9d() //  []
         { info_tbl: [(c8H9d,
                       label: block_c8H9d_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H9d: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HbT; else goto c8HbS;
       c8HbT: // global
           HpAlloc = 160;
           I64[Sp] = block_c8H9d_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HbS: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8v_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8H9z() //  []
         { info_tbl: [(c8H9z,
                       label: block_c8H9z_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H9z: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HbX; else goto c8HbW;
       c8HbX: // global
           HpAlloc = 160;
           I64[Sp] = block_c8H9z_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HbW: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8D_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8H9V() //  []
         { info_tbl: [(c8H9V,
                       label: block_c8H9V_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H9V: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hc1; else goto c8Hc0;
       c8Hc1: // global
           HpAlloc = 160;
           I64[Sp] = block_c8H9V_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hc0: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8L_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hah() //  []
         { info_tbl: [(c8Hah,
                       label: block_c8Hah_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hah: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hc5; else goto c8Hc4;
       c8Hc5: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hah_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hc4: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8T_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HaZ() //  []
         { info_tbl: [(c8HaZ,
                       label: block_c8HaZ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HaZ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hcd; else goto c8Hcc;
       c8Hcd: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HaZ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hcc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G99_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hbl() //  []
         { info_tbl: [(c8Hbl,
                       label: block_c8Hbl_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hbl: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hch; else goto c8Hcg;
       c8Hch: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hbl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hcg: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G9h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.835835573 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_decode_entry() //  [R2, R3]
         { info_tbl: [(c8Hfw,
                       label: GHC.IO.Encoding.UTF16.utf16le_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hfw: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.836589482 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16le3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16le3_bytes:
         I8[] [85,84,70,49,54,45,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.837380582 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le2_entry() //  [R1]
         { info_tbl: [(c8HfF,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HfF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8HfG; else goto c8HfH;
       c8HfG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HfH: // global
           (_c8HfC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8HfC::I64 == 0) goto c8HfE; else goto c8HfD;
       c8HfE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8HfD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8HfC::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.838411503 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF2_entry() //  []
         { info_tbl: [(c8HfM,
                       label: GHC.IO.Encoding.UTF16.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HfM: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.839215668 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be1_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be1_entry() //  []
         { info_tbl: [(c8HfT,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HfT: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.840699036 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le_info;
         const 0;
 },
 sat_s8GaC_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Hga,
                       label: sat_s8GaC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hga: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GaE_entry() //  [R1]
         { info_tbl: [(c8Hge,
                       label: sat_s8GaE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hge: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Hgi; else goto c8Hgh;
       c8Hgi: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Hgh: // global
           _s8Gaw::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GaC_info;
           P64[Hp - 48] = _s8Gaw::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gay_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Hgt,
                       label: sat_s8Gay_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hgt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GaA_entry() //  [R1]
         { info_tbl: [(c8Hgx,
                       label: sat_s8GaA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hgx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8HgB; else goto c8HgA;
       c8HgB: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8HgA: // global
           _s8Gaw::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Gay_info;
           P64[Hp - 48] = _s8Gaw::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16le_entry() //  [R2]
         { info_tbl: [(c8HgD,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HgD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8HgH; else goto c8HgG;
       c8HgH: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8HgG: // global
           I64[Hp - 56] = sat_s8GaE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8GaA_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.842961287 UTC

[section ""data" . lvl_r8G1B_closure" {
     lvl_r8G1B_closure:
         const lvl_r8G1B_info;
         const 0;
 },
 lvl_r8G1B_entry() //  [R2, R3]
         { info_tbl: [(c8HgP,
                       label: lvl_r8G1B_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HgP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8HgT; else goto c8HgU;
       c8HgT: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8G1B_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HgU: // global
           I64[Sp - 16] = block_c8HgM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Hh2; else goto c8HgN;
       u8Hh2: // global
           call _c8HgM() args: 0, res: 0, upd: 0;
       c8HgN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HgM() //  []
         { info_tbl: [(c8HgM,
                       label: block_c8HgM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HgM: // global
           _s8GaG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8HgS_info;
           R1 = _s8GaG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Hh1; else goto c8HgW;
       u8Hh1: // global
           call _c8HgS() args: 0, res: 0, upd: 0;
       c8HgW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HgS() //  []
         { info_tbl: [(c8HgS,
                       label: block_c8HgS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HgS: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.844206319 UTC

[section ""data" . lvl1_r8G1C_closure" {
     lvl1_r8G1C_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.844978244 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le2_closure" {
     GHC.IO.Encoding.UTF16.utf16le2_closure:
         const GHC.IO.Encoding.UTF16.utf16le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le2_entry() //  []
         { info_tbl: [(c8Hh7,
                       label: GHC.IO.Encoding.UTF16.utf16le2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hh7: // global
           R1 = lvl1_r8G1C_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.84617789 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be2_closure" {
     GHC.IO.Encoding.UTF16.utf16be2_closure:
         const GHC.IO.Encoding.UTF16.utf16be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be2_entry() //  [R2, R3]
         { info_tbl: [(c8Hhh,
                       label: GHC.IO.Encoding.UTF16.utf16be2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hhh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Hhl; else goto c8Hhm;
       c8Hhl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Hhm: // global
           I64[Sp - 16] = block_c8Hhe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Hhv; else goto c8Hhf;
       u8Hhv: // global
           call _c8Hhe(R1) args: 0, res: 0, upd: 0;
       c8Hhf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Hhe() //  [R1]
         { info_tbl: [(c8Hhe,
                       label: block_c8Hhe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hhe: // global
           I64[Sp - 16] = block_c8Hhk_info;
           _s8Gb2::P64 = P64[R1 + 7];
           _s8Gb1::I64 = I64[R1 + 23];
           _s8Gb5::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8Gb5::I64;
           P64[Sp] = _s8Gb2::P64;
           I64[Sp + 8] = _s8Gb1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Hhu; else goto c8Hho;
       u8Hhu: // global
           call _c8Hhk() args: 0, res: 0, upd: 0;
       c8Hho: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Hhk() //  []
         { info_tbl: [(c8Hhk,
                       label: block_c8Hhk_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hhk: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.847563045 UTC

[section ""data" . lvl2_r8G1D_closure" {
     lvl2_r8G1D_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.849819382 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le1_closure" {
     GHC.IO.Encoding.UTF16.utf16le1_closure:
         const GHC.IO.Encoding.UTF16.utf16le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le1_entry() //  []
         { info_tbl: [(c8HhA,
                       label: GHC.IO.Encoding.UTF16.utf16le1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HhA: // global
           R1 = lvl2_r8G1D_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.850524378 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_closure" {
     GHC.IO.Encoding.UTF16.utf16le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.UTF16.utf16le2_closure+1;
         const GHC.IO.Encoding.UTF16.utf16le1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.856805762 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF5_closure" {
     GHC.IO.Encoding.UTF16.mkUTF5_closure:
         const GHC.IO.Encoding.UTF16.mkUTF5_info;
 },
 sat_s8GbG_entry() //  [R1]
         { info_tbl: [(c8Hi7,
                       label: sat_s8GbG_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hi7: // global
           _s8GbG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hi8; else goto c8Hi9;
       c8Hi9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hib; else goto c8Hia;
       c8Hib: // global
           HpAlloc = 56;
           goto c8Hi8;
       c8Hi8: // global
           R1 = _s8GbG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbG::P64;
           _s8Gbs::I64 = I64[_s8GbG::P64 + 56];
           _s8GbC::I64 = I64[_s8GbG::P64 + 64];
           if (_s8GbC::I64 == _s8Gbs::I64) goto c8Hi6; else goto c8Hi5;
       c8Hi6: // global
           _s8GbA::P64 = P64[_s8GbG::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hi5: // global
           _s8Gbo::P64 = P64[_s8GbG::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbG::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbG::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbG::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbC::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8GbO_entry() //  [R1]
         { info_tbl: [(c8Hit,
                       label: sat_s8GbO_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hit: // global
           _s8GbO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hiu; else goto c8Hiv;
       c8Hiv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hix; else goto c8Hiw;
       c8Hix: // global
           HpAlloc = 56;
           goto c8Hiu;
       c8Hiu: // global
           R1 = _s8GbO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hiw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbO::P64;
           _s8Gbs::I64 = I64[_s8GbO::P64 + 56];
           _s8GbK::I64 = I64[_s8GbO::P64 + 64];
           if (_s8GbK::I64 == _s8Gbs::I64) goto c8His; else goto c8Hir;
       c8His: // global
           _s8GbA::P64 = P64[_s8GbO::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hir: // global
           _s8Gbo::P64 = P64[_s8GbO::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbO::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbO::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbO::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbK::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8GbW_entry() //  [R1]
         { info_tbl: [(c8HiP,
                       label: sat_s8GbW_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HiP: // global
           _s8GbW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HiQ; else goto c8HiR;
       c8HiR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HiT; else goto c8HiS;
       c8HiT: // global
           HpAlloc = 56;
           goto c8HiQ;
       c8HiQ: // global
           R1 = _s8GbW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HiS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbW::P64;
           _s8Gbs::I64 = I64[_s8GbW::P64 + 56];
           _s8GbS::I64 = I64[_s8GbW::P64 + 64];
           if (_s8GbS::I64 == _s8Gbs::I64) goto c8HiO; else goto c8HiN;
       c8HiO: // global
           _s8GbA::P64 = P64[_s8GbW::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HiN: // global
           _s8Gbo::P64 = P64[_s8GbW::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbW::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbW::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbW::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbS::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gc4_entry() //  [R1]
         { info_tbl: [(c8Hjb,
                       label: sat_s8Gc4_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hjb: // global
           _s8Gc4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hjc; else goto c8Hjd;
       c8Hjd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hjf; else goto c8Hje;
       c8Hjf: // global
           HpAlloc = 56;
           goto c8Hjc;
       c8Hjc: // global
           R1 = _s8Gc4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hje: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gc4::P64;
           _s8Gbs::I64 = I64[_s8Gc4::P64 + 56];
           _s8Gc0::I64 = I64[_s8Gc4::P64 + 64];
           if (_s8Gc0::I64 == _s8Gbs::I64) goto c8Hja; else goto c8Hj9;
       c8Hja: // global
           _s8GbA::P64 = P64[_s8Gc4::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hj9: // global
           _s8Gbo::P64 = P64[_s8Gc4::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gc4::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gc4::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gc4::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gc0::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gcc_entry() //  [R1]
         { info_tbl: [(c8Hjx,
                       label: sat_s8Gcc_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hjx: // global
           _s8Gcc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hjy; else goto c8Hjz;
       c8Hjz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HjB; else goto c8HjA;
       c8HjB: // global
           HpAlloc = 56;
           goto c8Hjy;
       c8Hjy: // global
           R1 = _s8Gcc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HjA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gcc::P64;
           _s8Gbs::I64 = I64[_s8Gcc::P64 + 56];
           _s8Gc8::I64 = I64[_s8Gcc::P64 + 64];
           if (_s8Gc8::I64 == _s8Gbs::I64) goto c8Hjw; else goto c8Hjv;
       c8Hjw: // global
           _s8GbA::P64 = P64[_s8Gcc::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hjv: // global
           _s8Gbo::P64 = P64[_s8Gcc::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gcc::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gcc::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gcc::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gc8::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gck_entry() //  [R1]
         { info_tbl: [(c8HjT,
                       label: sat_s8Gck_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HjT: // global
           _s8Gck::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HjU; else goto c8HjV;
       c8HjV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HjX; else goto c8HjW;
       c8HjX: // global
           HpAlloc = 56;
           goto c8HjU;
       c8HjU: // global
           R1 = _s8Gck::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HjW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gck::P64;
           _s8Gbs::I64 = I64[_s8Gck::P64 + 56];
           _s8Gcg::I64 = I64[_s8Gck::P64 + 64];
           if (_s8Gcg::I64 == _s8Gbs::I64) goto c8HjS; else goto c8HjR;
       c8HjS: // global
           _s8GbA::P64 = P64[_s8Gck::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HjR: // global
           _s8Gbo::P64 = P64[_s8Gck::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gck::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gck::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gck::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gcg::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gcs_entry() //  [R1]
         { info_tbl: [(c8Hkf,
                       label: sat_s8Gcs_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hkf: // global
           _s8Gcs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hkg; else goto c8Hkh;
       c8Hkh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hkj; else goto c8Hki;
       c8Hkj: // global
           HpAlloc = 56;
           goto c8Hkg;
       c8Hkg: // global
           R1 = _s8Gcs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hki: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gcs::P64;
           _s8Gbs::I64 = I64[_s8Gcs::P64 + 56];
           _s8Gco::I64 = I64[_s8Gcs::P64 + 64];
           if (_s8Gco::I64 == _s8Gbs::I64) goto c8Hke; else goto c8Hkd;
       c8Hke: // global
           _s8GbA::P64 = P64[_s8Gcs::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hkd: // global
           _s8Gbo::P64 = P64[_s8Gcs::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gcs::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gcs::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gcs::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gco::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8GcA_entry() //  [R1]
         { info_tbl: [(c8HkB,
                       label: sat_s8GcA_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HkB: // global
           _s8GcA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HkC; else goto c8HkD;
       c8HkD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HkF; else goto c8HkE;
       c8HkF: // global
           HpAlloc = 56;
           goto c8HkC;
       c8HkC: // global
           R1 = _s8GcA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HkE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GcA::P64;
           _s8Gbs::I64 = I64[_s8GcA::P64 + 56];
           _s8Gcw::I64 = I64[_s8GcA::P64 + 64];
           if (_s8Gcw::I64 == _s8Gbs::I64) goto c8HkA; else goto c8Hkz;
       c8HkA: // global
           _s8GbA::P64 = P64[_s8GcA::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hkz: // global
           _s8Gbo::P64 = P64[_s8GcA::P64 + 16];
           _s8Gbp::P64 = P64[_s8GcA::P64 + 24];
           _s8Gbn::I64 = I64[_s8GcA::P64 + 40];
           _s8Gbq::I64 = I64[_s8GcA::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gcw::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF5_entry() //  [R2, R3]
         { info_tbl: [(c8HkI,
                       label: GHC.IO.Encoding.UTF16.mkUTF5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HkI: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8HkJ; else goto c8HkK;
       c8HkJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HkK: // global
           I64[Sp - 16] = block_c8HhH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Hou; else goto c8HhI;
       u8Hou: // global
           call _c8HhH(R1) args: 0, res: 0, upd: 0;
       c8HhI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HhH() //  [R1]
         { info_tbl: [(c8HhH,
                       label: block_c8HhH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HhH: // global
           I64[Sp - 40] = block_c8HhM_info;
           _s8Gbo::P64 = P64[R1 + 7];
           _s8Gbp::P64 = P64[R1 + 15];
           _s8Gbn::I64 = I64[R1 + 23];
           _s8Gbq::I64 = I64[R1 + 31];
           _s8Gbr::I64 = I64[R1 + 39];
           _s8Gbs::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Gbp::P64;
           I64[Sp - 24] = _s8Gbq::I64;
           I64[Sp - 16] = _s8Gbr::I64;
           I64[Sp - 8] = _s8Gbs::I64;
           P64[Sp] = _s8Gbo::P64;
           I64[Sp + 8] = _s8Gbn::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Hol; else goto c8HhN;
       u8Hol: // global
           call _c8HhM(R1) args: 0, res: 0, upd: 0;
       c8HhN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HhM() //  [R1]
         { info_tbl: [(c8HhM,
                       label: block_c8HhM_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HhM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HkO; else goto c8HkN;
       c8HkO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HkN: // global
           _s8Gbv::P64 = P64[R1 + 7];
           _s8Gbw::P64 = P64[R1 + 15];
           _s8Gbu::I64 = I64[R1 + 23];
           _s8Gbx::I64 = I64[R1 + 31];
           _s8Gby::I64 = I64[R1 + 39];
           _s8Gbz::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Gbo::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Gbn::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Gbs::I64 = I64[Sp + 32];
           _c8HhR::P64 = Hp - 47;
           _s8GcF::I64 = _s8Gbz::I64;
           _s8GcE::I64 = I64[Sp + 24];
           goto c8Hln;
       c8Hln: // global
           if (%MO_S_Lt_W64(_s8GcF::I64,
                            _s8Gbx::I64)) goto c8Hni; else goto c8Hnj;
       c8Hni: // global
           if (%MO_S_Lt_W64(_s8GcE::I64,
                            _s8Gbs::I64)) goto c8Hnf; else goto c8Hng;
       c8Hnf: // global
           if ((_s8GcE::I64 + 1) == _s8Gbs::I64) goto c8Hnd; else goto c8Hnc;
       c8Hnd: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8HhR::P64;
           Sp = Sp - 56;
           call _c8HjG() args: 0, res: 0, upd: 0;
       c8Hnc: // global
           _s8GcO::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + _s8GcE::I64]);
           call MO_Touch(_s8Gbo::P64);
           _s8GcU::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 1)]);
           call MO_Touch(_s8Gbo::P64);
           _s8GcW::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8GcO::I64 << 8)) + _s8GcU::I64));
           if (_s8GcW::I64 >= 55296) goto c8Hn9; else goto c8Hna;
       c8Hn9: // global
           if (_s8GcW::I64 <= 57343) goto c8Hn6; else goto c8Hn7;
       c8Hn6: // global
           if (%MO_S_Ge_W64(_s8Gbs::I64 - _s8GcE::I64,
                            4)) goto c8Hn3; else goto c8Hn4;
       c8Hn3: // global
           _s8Gd8::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 2)]);
           call MO_Touch(_s8Gbo::P64);
           _s8Gde::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 3)]);
           call MO_Touch(_s8Gbo::P64);
           if (_s8GcW::I64 < 55296) goto c8Hmt; else goto c8Hn1;
       c8Hmt: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8HhR::P64;
           Sp = Sp - 56;
           call _c8HhU() args: 0, res: 0, upd: 0;
       c8Hn1: // global
           if (_s8GcW::I64 > 56319) goto c8Hmz; else goto c8Hn0;
       c8Hmz: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8HhR::P64;
           Sp = Sp - 56;
           call _c8Hig() args: 0, res: 0, upd: 0;
       c8Hn0: // global
           _s8Gdi::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8Gd8::I64 << 8)) + _s8Gde::I64));
           if (_s8Gdi::I64 < 56320) goto c8HmR; else goto c8HmZ;
       c8HmR: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8HhR::P64;
           Sp = Sp - 56;
           call _c8HiC() args: 0, res: 0, upd: 0;
       c8HmZ: // global
           if (_s8Gdi::I64 > 57343) goto c8HmX; else goto c8HmY;
       c8HmX: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8HhR::P64;
           Sp = Sp - 56;
           call _c8HiY() args: 0, res: 0, upd: 0;
       c8HmY: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8GcW::I64 + -55296) << 10) + (_s8Gdi::I64 + -56320) + 65536);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 4;
           goto c8Hln;
       c8Hn4: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8HhR::P64;
           Sp = Sp - 56;
           call _c8Hjk() args: 0, res: 0, upd: 0;
       c8Hn7: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8GcW::I64);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 2;
           goto c8Hln;
       c8Hna: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8GcW::I64);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 2;
           goto c8Hln;
       c8Hng: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8HhR::P64;
           Sp = Sp - 56;
           call _c8Hk2() args: 0, res: 0, upd: 0;
       c8Hnj: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8HhR::P64;
           Sp = Sp - 56;
           call _c8Hko() args: 0, res: 0, upd: 0;
     }
 },
 _c8HjG() //  []
         { info_tbl: [(c8HjG,
                       label: block_c8HjG_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HjG: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hlc; else goto c8Hlb;
       c8Hlc: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HjG_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hlb: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gck_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HhU() //  []
         { info_tbl: [(c8HhU,
                       label: block_c8HhU_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HhU: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HkS; else goto c8HkR;
       c8HkS: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HhU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HkR: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbG_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hig() //  []
         { info_tbl: [(c8Hig,
                       label: block_c8Hig_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hig: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HkW; else goto c8HkV;
       c8HkW: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hig_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HkV: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbO_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HiC() //  []
         { info_tbl: [(c8HiC,
                       label: block_c8HiC_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HiC: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hl0; else goto c8HkZ;
       c8Hl0: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HiC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HkZ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbW_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HiY() //  []
         { info_tbl: [(c8HiY,
                       label: block_c8HiY_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HiY: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hl4; else goto c8Hl3;
       c8Hl4: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HiY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hl3: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gc4_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hjk() //  []
         { info_tbl: [(c8Hjk,
                       label: block_c8Hjk_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hjk: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hl8; else goto c8Hl7;
       c8Hl8: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hjk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hl7: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gcc_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hk2() //  []
         { info_tbl: [(c8Hk2,
                       label: block_c8Hk2_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hk2: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hlg; else goto c8Hlf;
       c8Hlg: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hk2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hlf: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gcs_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hko() //  []
         { info_tbl: [(c8Hko,
                       label: block_c8Hko_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hko: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hlk; else goto c8Hlj;
       c8Hlk: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hko_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hlj: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GcA_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.868299477 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_decode_entry() //  [R2, R3]
         { info_tbl: [(c8Hoz,
                       label: GHC.IO.Encoding.UTF16.utf16be_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hoz: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.869048625 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16be3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16be3_bytes:
         I8[] [85,84,70,45,49,54,66,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.86989146 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be2_entry() //  [R1]
         { info_tbl: [(c8HoI,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HoI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8HoJ; else goto c8HoK;
       c8HoJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HoK: // global
           (_c8HoF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8HoF::I64 == 0) goto c8HoH; else goto c8HoG;
       c8HoH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8HoG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8HoF::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.871572678 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be_info;
         const 0;
 },
 sat_s8GdS_entry() //  [R1, R2, R3]
         { info_tbl: [(c8HoZ,
                       label: sat_s8GdS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HoZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GdU_entry() //  [R1]
         { info_tbl: [(c8Hp3,
                       label: sat_s8GdU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hp3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Hp7; else goto c8Hp6;
       c8Hp7: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Hp6: // global
           _s8GdM::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GdS_info;
           P64[Hp - 48] = _s8GdM::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GdO_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Hpi,
                       label: sat_s8GdO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hpi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GdQ_entry() //  [R1]
         { info_tbl: [(c8Hpm,
                       label: sat_s8GdQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hpm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Hpq; else goto c8Hpp;
       c8Hpq: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Hpp: // global
           _s8GdM::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GdO_info;
           P64[Hp - 48] = _s8GdM::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16be_entry() //  [R2]
         { info_tbl: [(c8Hps,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hps: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Hpw; else goto c8Hpv;
       c8Hpw: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Hpv: // global
           I64[Hp - 56] = sat_s8GdU_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8GdQ_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.873512491 UTC

[section ""data" . lvl3_r8G1E_closure" {
     lvl3_r8G1E_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.874220993 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be3_closure" {
     GHC.IO.Encoding.UTF16.utf16be3_closure:
         const GHC.IO.Encoding.UTF16.utf16be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be3_entry() //  []
         { info_tbl: [(c8HpB,
                       label: GHC.IO.Encoding.UTF16.utf16be3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HpB: // global
           R1 = lvl3_r8G1E_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.874984602 UTC

[section ""data" . lvl4_r8G1F_closure" {
     lvl4_r8G1F_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.875663581 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be1_closure" {
     GHC.IO.Encoding.UTF16.utf16be1_closure:
         const GHC.IO.Encoding.UTF16.utf16be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be1_entry() //  []
         { info_tbl: [(c8HpI,
                       label: GHC.IO.Encoding.UTF16.utf16be1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HpI: // global
           R1 = lvl4_r8G1F_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.876427674 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_closure" {
     GHC.IO.Encoding.UTF16.utf16be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const GHC.IO.Encoding.UTF16.utf16be3_closure+1;
         const GHC.IO.Encoding.UTF16.utf16be1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.877021866 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF6_closure" {
     GHC.IO.Encoding.UTF16.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.877679689 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF4_closure" {
     GHC.IO.Encoding.UTF16.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.879749346 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_decode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_decode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HpM: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8HpX,
                       label: GHC.IO.Encoding.UTF16.$wutf16_decode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HpX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8HpY; else goto c8HpZ;
       c8HpY: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8HpZ: // global
           I64[Sp - 48] = block_c8HpQ_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8Hrs; else goto c8HpR;
       u8Hrs: // global
           call _c8HpQ(R1) args: 0, res: 0, upd: 0;
       c8HpR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HpQ() //  [R1]
         { info_tbl: [(c8HpQ,
                       label: block_c8HpQ_info
                       rep:StackRep [False, True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HpQ: // global
           _s8GdY::I64 = I64[Sp + 16];
           _s8GdZ::P64 = P64[Sp + 24];
           _s8Ge0::P64 = P64[Sp + 32];
           _s8Ge1::I64 = I64[Sp + 40];
           _s8Ge2::I64 = I64[Sp + 48];
           _s8Ge3::I64 = I64[Sp + 56];
           _s8Ge4::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8HpU; else goto c8HpV;
       c8HpU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Hq4; else goto c8Hq3;
       c8Hq4: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Hq3: // global
           if (%MO_S_Ge_W64(_s8Ge3::I64 - _s8Ge2::I64,
                            2)) goto c8Hrf; else goto c8Hrj;
       c8Hrf: // global
           _s8GdX::P64 = P64[Sp + 8];
           _s8Gef::I64 = %MO_UU_Conv_W8_W64(I8[_s8GdY::I64 + _s8Ge2::I64]);
           call MO_Touch(_s8GdZ::P64);
           _s8Gel::I64 = %MO_UU_Conv_W8_W64(I8[_s8GdY::I64 + (_s8Ge2::I64 + 1)]);
           call MO_Touch(_s8GdZ::P64);
           if (_s8Gef::I64 != 254) goto c8Hr2; else goto c8Hrd;
       c8Hrd: // global
           if (_s8Gel::I64 != 255) goto c8Hr2; else goto c8Hrc;
       c8Hr2: // global
           Hp = Hp - 88;
           I64[Sp - 8] = _s8Gel::I64;
           I64[Sp] = _s8Gef::I64;
           Sp = Sp - 16;
           call _c8Hqp() args: 0, res: 0, upd: 0;
       c8Hrc: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8GdZ::P64;
           P64[Hp - 64] = _s8Ge0::P64;
           I64[Hp - 56] = _s8GdY::I64;
           I64[Hp - 48] = _s8Ge1::I64;
           I64[Hp - 40] = _s8Ge2::I64 + 2;
           I64[Hp - 32] = _s8Ge3::I64;
           _c8Hrb::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8Ge4::P64;
           R2 = _c8Hrb::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8Hrj: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8GdZ::P64;
           P64[Hp - 64] = _s8Ge0::P64;
           I64[Hp - 56] = _s8GdY::I64;
           I64[Hp - 48] = _s8Ge1::I64;
           I64[Hp - 40] = _s8Ge2::I64;
           I64[Hp - 32] = _s8Ge3::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8Ge4::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8HpV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hrp; else goto c8Hro;
       c8Hrp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Hro: // global
           _s8GeE::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           R1 = _s8GeE::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hqp() //  []
         { info_tbl: [(c8Hqp,
                       label: block_c8Hqp_info
                       rep:StackRep [True, True, False, True, False, False, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hqp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hqt; else goto c8Hqs;
       c8Hqt: // global
           HpAlloc = 56;
           I64[Sp] = block_c8Hqp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hqs: // global
           _s8GdX::P64 = P64[Sp + 24];
           _s8GdY::I64 = I64[Sp + 32];
           _s8GdZ::P64 = P64[Sp + 40];
           _s8Ge0::P64 = P64[Sp + 48];
           _s8Ge1::I64 = I64[Sp + 56];
           _s8Ge2::I64 = I64[Sp + 64];
           _s8Ge3::I64 = I64[Sp + 72];
           _s8Ge4::P64 = P64[Sp + 80];
           if (I64[Sp + 16] == 255) goto c8HqU; else goto c8HqB;
       c8HqU: // global
           if (I64[Sp + 8] == 254) goto c8HqT; else goto c8HqK;
       c8HqT: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64 + 2;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8HqK: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8HqB: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.883385445 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8HrA,
                       label: GHC.IO.Encoding.UTF16.utf16_decode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HrA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8HrE; else goto c8HrF;
       c8HrE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HrF: // global
           I64[Sp - 24] = block_c8Hrx_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8HrN; else goto c8Hry;
       u8HrN: // global
           call _c8Hrx(R1) args: 0, res: 0, upd: 0;
       c8Hry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Hrx() //  [R1]
         { info_tbl: [(c8Hrx,
                       label: block_c8Hrx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hrx: // global
           I64[Sp] = block_c8HrD_info;
           _s8GeL::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8GeL::P64;
           if (R1 & 7 != 0) goto u8HrM; else goto c8HrH;
       u8HrM: // global
           call _c8HrD(R1) args: 0, res: 0, upd: 0;
       c8HrH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HrD() //  [R1]
         { info_tbl: [(c8HrD,
                       label: block_c8HrD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HrD: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.884829977 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8HrS,
                       label: GHC.IO.Encoding.UTF16.utf16_decode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HrS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.885844416 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF8_bytes:
         I8[] [85,84,70,45,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.886553202 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF7_closure" {
     GHC.IO.Encoding.UTF16.mkUTF7_closure:
         const GHC.IO.Encoding.UTF16.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF7_entry() //  [R1]
         { info_tbl: [(c8Hs1,
                       label: GHC.IO.Encoding.UTF16.mkUTF7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hs1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hs2; else goto c8Hs3;
       c8Hs2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hs3: // global
           (_c8HrY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8HrY::I64 == 0) goto c8Hs0; else goto c8HrZ;
       c8Hs0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8HrZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8HrY::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.889484216 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16_info;
         const 0;
 },
 sat_s8GfD_entry() //  [R1, R2]
         { info_tbl: [(c8Hsn,
                       label: sat_s8GfD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hsn: // global
           _s8Gfl::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8Gfl::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Gfl::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfz_entry() //  [R1]
         { info_tbl: [(c8Hsw,
                       label: sat_s8Gfz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hsw: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfx_entry() //  [R1, R2, R3]
         { info_tbl: [(c8HsE,
                       label: sat_s8Gfx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HsE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfw_entry() //  [R1, R2, R3]
         { info_tbl: [(c8HsP,
                       label: sat_s8Gfw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HsP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8HsQ; else goto c8HsR;
       c8HsQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HsR: // global
           I64[Sp - 24] = block_c8HsM_info;
           _s8Gfl::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8Gfl::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8HsV; else goto c8HsN;
       u8HsV: // global
           call _c8HsM(R1) args: 0, res: 0, upd: 0;
       c8HsN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HsM() //  [R1]
         { info_tbl: [(c8HsM,
                       label: block_c8HsM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HsM: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8GfF_entry() //  [R1]
         { info_tbl: [(c8HsX,
                       label: sat_s8GfF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HsX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8HsY; else goto c8HsZ;
       c8HsY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8HsZ: // global
           I64[Sp - 16] = block_c8Hsd_info;
           _s8GeT::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8GeT::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Hsd() //  [R1]
         { info_tbl: [(c8Hsd,
                       label: block_c8Hsd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hsd: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8Ht2; else goto c8Ht1;
       c8Ht2: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ht1: // global
           I64[Hp - 104] = sat_s8GfD_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Gfz_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Gfx_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Gfw_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gff_entry() //  [R1, R2]
         { info_tbl: [(c8Hti,
                       label: sat_s8Gff_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hti: // global
           _s8GeX::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8GeX::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GeX::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfb_entry() //  [R1]
         { info_tbl: [(c8Htr,
                       label: sat_s8Gfb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Htr: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gf9_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Htz,
                       label: sat_s8Gf9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Htz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gf8_entry() //  [R1, R2, R3]
         { info_tbl: [(c8HtK,
                       label: sat_s8Gf8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HtK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8HtL; else goto c8HtM;
       c8HtL: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HtM: // global
           I64[Sp - 24] = block_c8HtH_info;
           _s8GeX::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8GeX::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8HtQ; else goto c8HtI;
       u8HtQ: // global
           call _c8HtH(R1) args: 0, res: 0, upd: 0;
       c8HtI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HtH() //  [R1]
         { info_tbl: [(c8HtH,
                       label: block_c8HtH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HtH: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8Gfh_entry() //  [R1]
         { info_tbl: [(c8HtS,
                       label: sat_s8Gfh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HtS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8HtT; else goto c8HtU;
       c8HtT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8HtU: // global
           I64[Sp - 16] = block_c8Ht8_info;
           _s8GeT::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8GeT::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ht8() //  [R1]
         { info_tbl: [(c8Ht8,
                       label: block_c8Ht8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ht8: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8HtX; else goto c8HtW;
       c8HtX: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HtW: // global
           I64[Hp - 104] = sat_s8Gff_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Gfb_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Gf9_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Gf8_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16_entry() //  [R2]
         { info_tbl: [(c8HtZ,
                       label: GHC.IO.Encoding.UTF16.mkUTF16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HtZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Hu3; else goto c8Hu2;
       c8Hu3: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Hu2: // global
           I64[Hp - 56] = sat_s8GfF_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Gfh_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.895534328 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_closure" {
     GHC.IO.Encoding.UTF16.utf16_closure:
         const GHC.IO.Encoding.UTF16.utf16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16_entry() //  [R1]
         { info_tbl: [(c8Hua,
                       label: GHC.IO.Encoding.UTF16.utf16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hua: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hub; else goto c8Huc;
       c8Hub: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Huc: // global
           (_c8Hu7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Hu7::I64 == 0) goto c8Hu9; else goto c8Hu8;
       c8Hu9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Hu8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Hu7::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF16.mkUTF16_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.896427454 UTC

[section ""relreadonly" . S8GEr_srt" {
     S8GEr_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8G1B_closure;
         const lvl1_r8G1C_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF16.utf16be2_closure;
         const lvl2_r8G1D_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const lvl3_r8G1E_closure;
         const lvl4_r8G1F_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16_closure;
         const GHC.IO.Encoding.UTF16.mkUTF7_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.897337806 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:48.903657009 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF1_info;
 },
 sat_s8G24_entry() //  [R1]
         { info_tbl: [(c8HuH,
                       label: sat_s8G24_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HuH: // global
           _s8G24::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HuI; else goto c8HuJ;
       c8HuJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HuL; else goto c8HuK;
       c8HuL: // global
           HpAlloc = 56;
           goto c8HuI;
       c8HuI: // global
           R1 = _s8G24::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HuK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G24::P64;
           _s8G1Q::I64 = I64[_s8G24::P64 + 56];
           _s8G20::I64 = I64[_s8G24::P64 + 64];
           if (_s8G20::I64 == _s8G1Q::I64) goto c8HuG; else goto c8HuF;
       c8HuG: // global
           _s8G1Y::P64 = P64[_s8G24::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HuF: // global
           _s8G1M::P64 = P64[_s8G24::P64 + 16];
           _s8G1N::P64 = P64[_s8G24::P64 + 24];
           _s8G1L::I64 = I64[_s8G24::P64 + 40];
           _s8G1O::I64 = I64[_s8G24::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G20::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2c_entry() //  [R1]
         { info_tbl: [(c8Hv3,
                       label: sat_s8G2c_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hv3: // global
           _s8G2c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hv4; else goto c8Hv5;
       c8Hv5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hv7; else goto c8Hv6;
       c8Hv7: // global
           HpAlloc = 56;
           goto c8Hv4;
       c8Hv4: // global
           R1 = _s8G2c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hv6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2c::P64;
           _s8G1Q::I64 = I64[_s8G2c::P64 + 56];
           _s8G28::I64 = I64[_s8G2c::P64 + 64];
           if (_s8G28::I64 == _s8G1Q::I64) goto c8Hv2; else goto c8Hv1;
       c8Hv2: // global
           _s8G1Y::P64 = P64[_s8G2c::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hv1: // global
           _s8G1M::P64 = P64[_s8G2c::P64 + 16];
           _s8G1N::P64 = P64[_s8G2c::P64 + 24];
           _s8G1L::I64 = I64[_s8G2c::P64 + 40];
           _s8G1O::I64 = I64[_s8G2c::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G28::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2k_entry() //  [R1]
         { info_tbl: [(c8Hvp,
                       label: sat_s8G2k_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hvp: // global
           _s8G2k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hvq; else goto c8Hvr;
       c8Hvr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hvt; else goto c8Hvs;
       c8Hvt: // global
           HpAlloc = 56;
           goto c8Hvq;
       c8Hvq: // global
           R1 = _s8G2k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hvs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2k::P64;
           _s8G1Q::I64 = I64[_s8G2k::P64 + 56];
           _s8G2g::I64 = I64[_s8G2k::P64 + 64];
           if (_s8G2g::I64 == _s8G1Q::I64) goto c8Hvo; else goto c8Hvn;
       c8Hvo: // global
           _s8G1Y::P64 = P64[_s8G2k::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hvn: // global
           _s8G1M::P64 = P64[_s8G2k::P64 + 16];
           _s8G1N::P64 = P64[_s8G2k::P64 + 24];
           _s8G1L::I64 = I64[_s8G2k::P64 + 40];
           _s8G1O::I64 = I64[_s8G2k::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2g::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2s_entry() //  [R1]
         { info_tbl: [(c8HvL,
                       label: sat_s8G2s_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HvL: // global
           _s8G2s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HvM; else goto c8HvN;
       c8HvN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HvP; else goto c8HvO;
       c8HvP: // global
           HpAlloc = 56;
           goto c8HvM;
       c8HvM: // global
           R1 = _s8G2s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HvO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2s::P64;
           _s8G1Q::I64 = I64[_s8G2s::P64 + 56];
           _s8G2o::I64 = I64[_s8G2s::P64 + 64];
           if (_s8G2o::I64 == _s8G1Q::I64) goto c8HvK; else goto c8HvJ;
       c8HvK: // global
           _s8G1Y::P64 = P64[_s8G2s::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HvJ: // global
           _s8G1M::P64 = P64[_s8G2s::P64 + 16];
           _s8G1N::P64 = P64[_s8G2s::P64 + 24];
           _s8G1L::I64 = I64[_s8G2s::P64 + 40];
           _s8G1O::I64 = I64[_s8G2s::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2o::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2A_entry() //  [R1]
         { info_tbl: [(c8Hw7,
                       label: sat_s8G2A_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hw7: // global
           _s8G2A::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hw8; else goto c8Hw9;
       c8Hw9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hwb; else goto c8Hwa;
       c8Hwb: // global
           HpAlloc = 56;
           goto c8Hw8;
       c8Hw8: // global
           R1 = _s8G2A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hwa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2A::P64;
           _s8G1Q::I64 = I64[_s8G2A::P64 + 56];
           _s8G2w::I64 = I64[_s8G2A::P64 + 64];
           if (_s8G2w::I64 == _s8G1Q::I64) goto c8Hw6; else goto c8Hw5;
       c8Hw6: // global
           _s8G1Y::P64 = P64[_s8G2A::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hw5: // global
           _s8G1M::P64 = P64[_s8G2A::P64 + 16];
           _s8G1N::P64 = P64[_s8G2A::P64 + 24];
           _s8G1L::I64 = I64[_s8G2A::P64 + 40];
           _s8G1O::I64 = I64[_s8G2A::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2w::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G2I_entry() //  [R1]
         { info_tbl: [(c8Hwt,
                       label: sat_s8G2I_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hwt: // global
           _s8G2I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hwu; else goto c8Hwv;
       c8Hwv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Hwx; else goto c8Hww;
       c8Hwx: // global
           HpAlloc = 56;
           goto c8Hwu;
       c8Hwu: // global
           R1 = _s8G2I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Hww: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G2I::P64;
           _s8G1Q::I64 = I64[_s8G2I::P64 + 56];
           _s8G2E::I64 = I64[_s8G2I::P64 + 64];
           if (_s8G2E::I64 == _s8G1Q::I64) goto c8Hws; else goto c8Hwr;
       c8Hws: // global
           _s8G1Y::P64 = P64[_s8G2I::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G1Y::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Hwr: // global
           _s8G1M::P64 = P64[_s8G2I::P64 + 16];
           _s8G1N::P64 = P64[_s8G2I::P64 + 24];
           _s8G1L::I64 = I64[_s8G2I::P64 + 40];
           _s8G1O::I64 = I64[_s8G2I::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = _s8G1N::P64;
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = _s8G1O::I64;
           I64[Hp - 8] = _s8G2E::I64;
           I64[Hp] = _s8G1Q::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8HwA,
                       label: GHC.IO.Encoding.UTF16.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HwA: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8HwB; else goto c8HwC;
       c8HwB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HwC: // global
           I64[Sp - 16] = block_c8Huh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8HBI; else goto c8Hui;
       u8HBI: // global
           call _c8Huh(R1) args: 0, res: 0, upd: 0;
       c8Hui: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Huh() //  [R1]
         { info_tbl: [(c8Huh,
                       label: block_c8Huh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Huh: // global
           I64[Sp - 40] = block_c8Hum_info;
           _s8G1M::P64 = P64[R1 + 7];
           _s8G1N::P64 = P64[R1 + 15];
           _s8G1L::I64 = I64[R1 + 23];
           _s8G1O::I64 = I64[R1 + 31];
           _s8G1P::I64 = I64[R1 + 39];
           _s8G1Q::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G1N::P64;
           I64[Sp - 24] = _s8G1O::I64;
           I64[Sp - 16] = _s8G1P::I64;
           I64[Sp - 8] = _s8G1Q::I64;
           P64[Sp] = _s8G1M::P64;
           I64[Sp + 8] = _s8G1L::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8HBB; else goto c8Hun;
       u8HBB: // global
           call _c8Hum(R1) args: 0, res: 0, upd: 0;
       c8Hun: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Hum() //  [R1]
         { info_tbl: [(c8Hum,
                       label: block_c8Hum_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hum: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HwG; else goto c8HwF;
       c8HwG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HwF: // global
           _s8G1T::P64 = P64[R1 + 7];
           _s8G1U::P64 = P64[R1 + 15];
           _s8G1S::I64 = I64[R1 + 23];
           _s8G1V::I64 = I64[R1 + 31];
           _s8G1W::I64 = I64[R1 + 39];
           _s8G1X::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G1M::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G1M::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G1L::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G1L::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G1Q::I64 = I64[Sp + 32];
           _c8Hur::P64 = Hp - 47;
           _s8G2N::I64 = _s8G1X::I64;
           _s8G2M::I64 = I64[Sp + 24];
           goto c8Hx7;
       c8Hx7: // global
           if (%MO_S_Lt_W64(_s8G2M::I64,
                            _s8G1Q::I64)) goto c8Hyi; else goto c8Hyj;
       c8Hyi: // global
           if (%MO_S_Ge_W64(_s8G1V::I64 - _s8G2N::I64,
                            2)) goto c8Hyf; else goto c8Hyg;
       c8Hyf: // global
           _s8G2U::I64 = %MO_UU_Conv_W32_W64(I32[_s8G1L::I64 + (_s8G2M::I64 << 2)]);
           call MO_Touch(_s8G1M::P64);
           if (%MO_S_Ge_W64(_s8G2U::I64, 65536)) goto c8HxA; else goto c8Hyd;
       c8HxA: // global
           if (%MO_S_Ge_W64(_s8G1V::I64 - _s8G2N::I64,
                            4)) goto c8Hxx; else goto c8Hxy;
       c8Hxx: // global
           _s8G30::I64 = _s8G2U::I64 - 65536;
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G30::I64,
                                                                            18) + 216);
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G30::I64,
                                                                                  10));
           call MO_Touch(_s8G1T::P64);
           _s8G3f::I64 = _s8G30::I64 & 1023;
           I8[_s8G1S::I64 + (_s8G2N::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G3f::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8G3f::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 4;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8Hxy: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8Huu() args: 0, res: 0, upd: 0;
       c8Hyd: // global
           if (%MO_S_Gt_W64(55296, _s8G2U::I64)) goto c8HxS; else goto c8Hyc;
       c8HxS: // global
           if (%MO_S_Gt_W64(56320, _s8G2U::I64)) goto c8HxI; else goto c8HxQ;
       c8HxI: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8HxQ: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 57343)) goto c8HxO; else goto c8HxP;
       c8HxO: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8HxP: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8HuQ() args: 0, res: 0, upd: 0;
       c8Hyc: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 56319)) goto c8Hya; else goto c8Hyb;
       c8Hya: // global
           if (%MO_S_Gt_W64(56320, _s8G2U::I64)) goto c8Hy0; else goto c8Hy8;
       c8Hy0: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8Hy8: // global
           if (%MO_S_Gt_W64(_s8G2U::I64, 57343)) goto c8Hy6; else goto c8Hy7;
       c8Hy6: // global
           I8[_s8G1S::I64 + _s8G2N::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G2U::I64,
                                                                            8));
           call MO_Touch(_s8G1T::P64);
           I8[_s8G1S::I64 + (_s8G2N::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8G2U::I64);
           call MO_Touch(_s8G1T::P64);
           _s8G2N::I64 = _s8G2N::I64 + 2;
           _s8G2M::I64 = _s8G2M::I64 + 1;
           goto c8Hx7;
       c8Hy7: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8Hvc() args: 0, res: 0, upd: 0;
       c8Hyb: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8Hvy() args: 0, res: 0, upd: 0;
       c8Hyg: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8HvU() args: 0, res: 0, upd: 0;
       c8Hyj: // global
           P64[Sp - 48] = _s8G1T::P64;
           P64[Sp - 40] = _s8G1U::P64;
           I64[Sp - 32] = _s8G1V::I64;
           I64[Sp - 24] = _s8G1W::I64;
           I64[Sp - 16] = _s8G2M::I64;
           I64[Sp - 8] = _s8G2N::I64;
           I64[Sp] = _s8G1S::I64;
           P64[Sp + 24] = _c8Hur::P64;
           Sp = Sp - 56;
           call _c8Hwg() args: 0, res: 0, upd: 0;
     }
 },
 _c8Huu() //  []
         { info_tbl: [(c8Huu,
                       label: block_c8Huu_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Huu: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HwK; else goto c8HwJ;
       c8HwK: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Huu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwJ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G24_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HuQ() //  []
         { info_tbl: [(c8HuQ,
                       label: block_c8HuQ_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HuQ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HwO; else goto c8HwN;
       c8HwO: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HuQ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwN: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2c_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hvc() //  []
         { info_tbl: [(c8Hvc,
                       label: block_c8Hvc_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hvc: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HwS; else goto c8HwR;
       c8HwS: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hvc_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwR: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2k_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hvy() //  []
         { info_tbl: [(c8Hvy,
                       label: block_c8Hvy_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hvy: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HwW; else goto c8HwV;
       c8HwW: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hvy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwV: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2s_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HvU() //  []
         { info_tbl: [(c8HvU,
                       label: block_c8HvU_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HvU: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hx0; else goto c8HwZ;
       c8Hx0: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HvU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HwZ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2A_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Hwg() //  []
         { info_tbl: [(c8Hwg,
                       label: block_c8Hwg_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hwg: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Hx4; else goto c8Hx3;
       c8Hx4: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Hwg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Hx3: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G2I_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.950870633 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_encode_entry() //  [R2, R3]
         { info_tbl: [(c8HEX,
                       label: GHC.IO.Encoding.UTF16.utf16be_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HEX: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:48.960894514 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le1_info;
 },
 sat_s8G4T_entry() //  [R1]
         { info_tbl: [(c8HFy,
                       label: sat_s8G4T_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HFy: // global
           _s8G4T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HFz; else goto c8HFA;
       c8HFA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HFC; else goto c8HFB;
       c8HFC: // global
           HpAlloc = 56;
           goto c8HFz;
       c8HFz: // global
           R1 = _s8G4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HFB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G4T::P64;
           _s8G4F::I64 = I64[_s8G4T::P64 + 56];
           _s8G4P::I64 = I64[_s8G4T::P64 + 64];
           if (_s8G4P::I64 == _s8G4F::I64) goto c8HFx; else goto c8HFw;
       c8HFx: // global
           _s8G4N::P64 = P64[_s8G4T::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HFw: // global
           _s8G4B::P64 = P64[_s8G4T::P64 + 16];
           _s8G4C::P64 = P64[_s8G4T::P64 + 24];
           _s8G4A::I64 = I64[_s8G4T::P64 + 40];
           _s8G4D::I64 = I64[_s8G4T::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G4P::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G51_entry() //  [R1]
         { info_tbl: [(c8HFU,
                       label: sat_s8G51_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HFU: // global
           _s8G51::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HFV; else goto c8HFW;
       c8HFW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HFY; else goto c8HFX;
       c8HFY: // global
           HpAlloc = 56;
           goto c8HFV;
       c8HFV: // global
           R1 = _s8G51::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HFX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G51::P64;
           _s8G4F::I64 = I64[_s8G51::P64 + 56];
           _s8G4X::I64 = I64[_s8G51::P64 + 64];
           if (_s8G4X::I64 == _s8G4F::I64) goto c8HFT; else goto c8HFS;
       c8HFT: // global
           _s8G4N::P64 = P64[_s8G51::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HFS: // global
           _s8G4B::P64 = P64[_s8G51::P64 + 16];
           _s8G4C::P64 = P64[_s8G51::P64 + 24];
           _s8G4A::I64 = I64[_s8G51::P64 + 40];
           _s8G4D::I64 = I64[_s8G51::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G4X::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G59_entry() //  [R1]
         { info_tbl: [(c8HGg,
                       label: sat_s8G59_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HGg: // global
           _s8G59::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HGh; else goto c8HGi;
       c8HGi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HGk; else goto c8HGj;
       c8HGk: // global
           HpAlloc = 56;
           goto c8HGh;
       c8HGh: // global
           R1 = _s8G59::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HGj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G59::P64;
           _s8G4F::I64 = I64[_s8G59::P64 + 56];
           _s8G55::I64 = I64[_s8G59::P64 + 64];
           if (_s8G55::I64 == _s8G4F::I64) goto c8HGf; else goto c8HGe;
       c8HGf: // global
           _s8G4N::P64 = P64[_s8G59::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HGe: // global
           _s8G4B::P64 = P64[_s8G59::P64 + 16];
           _s8G4C::P64 = P64[_s8G59::P64 + 24];
           _s8G4A::I64 = I64[_s8G59::P64 + 40];
           _s8G4D::I64 = I64[_s8G59::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G55::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G5h_entry() //  [R1]
         { info_tbl: [(c8HGC,
                       label: sat_s8G5h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HGC: // global
           _s8G5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HGD; else goto c8HGE;
       c8HGE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HGG; else goto c8HGF;
       c8HGG: // global
           HpAlloc = 56;
           goto c8HGD;
       c8HGD: // global
           R1 = _s8G5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5h::P64;
           _s8G4F::I64 = I64[_s8G5h::P64 + 56];
           _s8G5d::I64 = I64[_s8G5h::P64 + 64];
           if (_s8G5d::I64 == _s8G4F::I64) goto c8HGB; else goto c8HGA;
       c8HGB: // global
           _s8G4N::P64 = P64[_s8G5h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HGA: // global
           _s8G4B::P64 = P64[_s8G5h::P64 + 16];
           _s8G4C::P64 = P64[_s8G5h::P64 + 24];
           _s8G4A::I64 = I64[_s8G5h::P64 + 40];
           _s8G4D::I64 = I64[_s8G5h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5d::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G5p_entry() //  [R1]
         { info_tbl: [(c8HGY,
                       label: sat_s8G5p_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HGY: // global
           _s8G5p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HGZ; else goto c8HH0;
       c8HH0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HH2; else goto c8HH1;
       c8HH2: // global
           HpAlloc = 56;
           goto c8HGZ;
       c8HGZ: // global
           R1 = _s8G5p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HH1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5p::P64;
           _s8G4F::I64 = I64[_s8G5p::P64 + 56];
           _s8G5l::I64 = I64[_s8G5p::P64 + 64];
           if (_s8G5l::I64 == _s8G4F::I64) goto c8HGX; else goto c8HGW;
       c8HGX: // global
           _s8G4N::P64 = P64[_s8G5p::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HGW: // global
           _s8G4B::P64 = P64[_s8G5p::P64 + 16];
           _s8G4C::P64 = P64[_s8G5p::P64 + 24];
           _s8G4A::I64 = I64[_s8G5p::P64 + 40];
           _s8G4D::I64 = I64[_s8G5p::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5l::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G5x_entry() //  [R1]
         { info_tbl: [(c8HHk,
                       label: sat_s8G5x_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HHk: // global
           _s8G5x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HHl; else goto c8HHm;
       c8HHm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HHo; else goto c8HHn;
       c8HHo: // global
           HpAlloc = 56;
           goto c8HHl;
       c8HHl: // global
           R1 = _s8G5x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HHn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G5x::P64;
           _s8G4F::I64 = I64[_s8G5x::P64 + 56];
           _s8G5t::I64 = I64[_s8G5x::P64 + 64];
           if (_s8G5t::I64 == _s8G4F::I64) goto c8HHj; else goto c8HHi;
       c8HHj: // global
           _s8G4N::P64 = P64[_s8G5x::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G4N::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HHi: // global
           _s8G4B::P64 = P64[_s8G5x::P64 + 16];
           _s8G4C::P64 = P64[_s8G5x::P64 + 24];
           _s8G4A::I64 = I64[_s8G5x::P64 + 40];
           _s8G4D::I64 = I64[_s8G5x::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = _s8G4C::P64;
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = _s8G4D::I64;
           I64[Hp - 8] = _s8G5t::I64;
           I64[Hp] = _s8G4F::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16le1_entry() //  [R2, R3]
         { info_tbl: [(c8HHr,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HHr: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8HHs; else goto c8HHt;
       c8HHs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HHt: // global
           I64[Sp - 16] = block_c8HF8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8HMz; else goto c8HF9;
       u8HMz: // global
           call _c8HF8(R1) args: 0, res: 0, upd: 0;
       c8HF9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HF8() //  [R1]
         { info_tbl: [(c8HF8,
                       label: block_c8HF8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HF8: // global
           I64[Sp - 40] = block_c8HFd_info;
           _s8G4B::P64 = P64[R1 + 7];
           _s8G4C::P64 = P64[R1 + 15];
           _s8G4A::I64 = I64[R1 + 23];
           _s8G4D::I64 = I64[R1 + 31];
           _s8G4E::I64 = I64[R1 + 39];
           _s8G4F::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G4C::P64;
           I64[Sp - 24] = _s8G4D::I64;
           I64[Sp - 16] = _s8G4E::I64;
           I64[Sp - 8] = _s8G4F::I64;
           P64[Sp] = _s8G4B::P64;
           I64[Sp + 8] = _s8G4A::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8HMs; else goto c8HFe;
       u8HMs: // global
           call _c8HFd(R1) args: 0, res: 0, upd: 0;
       c8HFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HFd() //  [R1]
         { info_tbl: [(c8HFd,
                       label: block_c8HFd_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HFd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HHx; else goto c8HHw;
       c8HHx: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HHw: // global
           _s8G4I::P64 = P64[R1 + 7];
           _s8G4J::P64 = P64[R1 + 15];
           _s8G4H::I64 = I64[R1 + 23];
           _s8G4K::I64 = I64[R1 + 31];
           _s8G4L::I64 = I64[R1 + 39];
           _s8G4M::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G4B::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G4B::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G4A::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G4A::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G4F::I64 = I64[Sp + 32];
           _c8HFi::P64 = Hp - 47;
           _s8G5C::I64 = _s8G4M::I64;
           _s8G5B::I64 = I64[Sp + 24];
           goto c8HHY;
       c8HHY: // global
           if (%MO_S_Lt_W64(_s8G5B::I64,
                            _s8G4F::I64)) goto c8HJ9; else goto c8HJa;
       c8HJ9: // global
           if (%MO_S_Ge_W64(_s8G4K::I64 - _s8G5C::I64,
                            2)) goto c8HJ6; else goto c8HJ7;
       c8HJ6: // global
           _s8G5J::I64 = %MO_UU_Conv_W32_W64(I32[_s8G4A::I64 + (_s8G5B::I64 << 2)]);
           call MO_Touch(_s8G4B::P64);
           if (%MO_S_Ge_W64(_s8G5J::I64, 65536)) goto c8HIr; else goto c8HJ4;
       c8HIr: // global
           if (%MO_S_Ge_W64(_s8G4K::I64 - _s8G5C::I64,
                            4)) goto c8HIo; else goto c8HIp;
       c8HIo: // global
           _s8G5P::I64 = _s8G5J::I64 - 65536;
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5P::I64,
                                                                            10));
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5P::I64,
                                                                                  18) + 216);
           call MO_Touch(_s8G4I::P64);
           _s8G64::I64 = _s8G5P::I64 & 1023;
           I8[_s8G4H::I64 + (_s8G5C::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8G64::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G64::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 4;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIp: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HFl() args: 0, res: 0, upd: 0;
       c8HJ4: // global
           if (%MO_S_Gt_W64(55296, _s8G5J::I64)) goto c8HIJ; else goto c8HJ3;
       c8HIJ: // global
           if (%MO_S_Gt_W64(56320, _s8G5J::I64)) goto c8HIz; else goto c8HIH;
       c8HIz: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIH: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 57343)) goto c8HIF; else goto c8HIG;
       c8HIF: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIG: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HFH() args: 0, res: 0, upd: 0;
       c8HJ3: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 56319)) goto c8HJ1; else goto c8HJ2;
       c8HJ1: // global
           if (%MO_S_Gt_W64(56320, _s8G5J::I64)) goto c8HIR; else goto c8HIZ;
       c8HIR: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIZ: // global
           if (%MO_S_Gt_W64(_s8G5J::I64, 57343)) goto c8HIX; else goto c8HIY;
       c8HIX: // global
           I8[_s8G4H::I64 + _s8G5C::I64] = %MO_UU_Conv_W64_W8(_s8G5J::I64);
           call MO_Touch(_s8G4I::P64);
           I8[_s8G4H::I64 + (_s8G5C::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8G5J::I64,
                                                                                  8));
           call MO_Touch(_s8G4I::P64);
           _s8G5C::I64 = _s8G5C::I64 + 2;
           _s8G5B::I64 = _s8G5B::I64 + 1;
           goto c8HHY;
       c8HIY: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HG3() args: 0, res: 0, upd: 0;
       c8HJ2: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HGp() args: 0, res: 0, upd: 0;
       c8HJ7: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HGL() args: 0, res: 0, upd: 0;
       c8HJa: // global
           P64[Sp - 48] = _s8G4I::P64;
           P64[Sp - 40] = _s8G4J::P64;
           I64[Sp - 32] = _s8G4K::I64;
           I64[Sp - 24] = _s8G4L::I64;
           I64[Sp - 16] = _s8G5B::I64;
           I64[Sp - 8] = _s8G5C::I64;
           I64[Sp] = _s8G4H::I64;
           P64[Sp + 24] = _c8HFi::P64;
           Sp = Sp - 56;
           call _c8HH7() args: 0, res: 0, upd: 0;
     }
 },
 _c8HFl() //  []
         { info_tbl: [(c8HFl,
                       label: block_c8HFl_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HFl: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHB; else goto c8HHA;
       c8HHB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HFl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G4T_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HFH() //  []
         { info_tbl: [(c8HFH,
                       label: block_c8HFH_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HFH: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHF; else goto c8HHE;
       c8HHF: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HFH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHE: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G51_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HG3() //  []
         { info_tbl: [(c8HG3,
                       label: block_c8HG3_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HG3: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHJ; else goto c8HHI;
       c8HHJ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HG3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHI: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G59_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HGp() //  []
         { info_tbl: [(c8HGp,
                       label: block_c8HGp_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HGp: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHN; else goto c8HHM;
       c8HHN: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HGp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHM: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HGL() //  []
         { info_tbl: [(c8HGL,
                       label: block_c8HGL_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HGL: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHR; else goto c8HHQ;
       c8HHR: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HGL_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHQ: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5p_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HH7() //  []
         { info_tbl: [(c8HH7,
                       label: block_c8HH7_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HH7: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HHV; else goto c8HHU;
       c8HHV: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HH7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HHU: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G5x_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.008594581 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_encode_entry() //  [R2, R3]
         { info_tbl: [(c8HPO,
                       label: GHC.IO.Encoding.UTF16.utf16le_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HPO: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF16le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.011886655 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule4_bytes" {
     GHC.IO.Encoding.UTF16.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.013625317 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule3_closure" {
     GHC.IO.Encoding.UTF16.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.015807931 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule2_bytes" {
     GHC.IO.Encoding.UTF16.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.017835005 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule1_closure" {
     GHC.IO.Encoding.UTF16.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.019435219 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule_closure" {
     GHC.IO.Encoding.UTF16.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF16.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF16.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.022172046 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_encode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_encode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HQ1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8HQc,
                       label: GHC.IO.Encoding.UTF16.$wutf16_encode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HQc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8HQd; else goto c8HQe;
       c8HQd: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8HQe: // global
           I64[Sp - 48] = block_c8HQ5_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8HQU; else goto c8HQ6;
       u8HQU: // global
           call _c8HQ5(R1) args: 0, res: 0, upd: 0;
       c8HQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HQ5() //  [R1]
         { info_tbl: [(c8HQ5,
                       label: block_c8HQ5_info
                       rep:StackRep [False, False, True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HQ5: // global
           _s8G7m::P64 = P64[Sp + 16];
           _s8G7n::I64 = I64[Sp + 24];
           _s8G7o::P64 = P64[Sp + 32];
           _s8G7p::P64 = P64[Sp + 40];
           _s8G7q::I64 = I64[Sp + 48];
           _s8G7r::I64 = I64[Sp + 56];
           _s8G7s::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8HQ9; else goto c8HQa;
       c8HQ9: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8HQj; else goto c8HQi;
       c8HQj: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HQi: // global
           if (%MO_S_Ge_W64(_s8G7q::I64 - _s8G7s::I64,
                            2)) goto c8HQJ; else goto c8HQN;
       c8HQJ: // global
           _s8G7l::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8G7l::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8G7l::P64);
           I8[_s8G7n::I64 + _s8G7s::I64] = 254 :: W8;
           call MO_Touch(_s8G7o::P64);
           I8[_s8G7n::I64 + (_s8G7s::I64 + 1)] = 255 :: W8;
           call MO_Touch(_s8G7o::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8G7o::P64;
           P64[Hp - 64] = _s8G7p::P64;
           I64[Hp - 56] = _s8G7n::I64;
           I64[Hp - 48] = _s8G7q::I64;
           I64[Hp - 40] = _s8G7r::I64;
           I64[Hp - 32] = _s8G7s::I64 + 2;
           _c8HQH::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8HQH::P64;
           R2 = _s8G7m::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8HQN: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8G7o::P64;
           P64[Hp - 64] = _s8G7p::P64;
           I64[Hp - 56] = _s8G7n::I64;
           I64[Hp - 48] = _s8G7q::I64;
           I64[Hp - 40] = _s8G7r::I64;
           I64[Hp - 32] = _s8G7s::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8G7m::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8HQa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HQT; else goto c8HQS;
       c8HQT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HQS: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G7o::P64;
           P64[Hp - 32] = _s8G7p::P64;
           I64[Hp - 24] = _s8G7n::I64;
           I64[Hp - 16] = _s8G7q::I64;
           I64[Hp - 8] = _s8G7r::I64;
           I64[Hp] = _s8G7s::I64;
           R3 = Hp - 47;
           R2 = _s8G7m::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.031897068 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8HRm,
                       label: GHC.IO.Encoding.UTF16.utf16_encode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HRm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8HRq; else goto c8HRr;
       c8HRq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HRr: // global
           I64[Sp - 24] = block_c8HRj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8HRz; else goto c8HRk;
       u8HRz: // global
           call _c8HRj(R1) args: 0, res: 0, upd: 0;
       c8HRk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HRj() //  [R1]
         { info_tbl: [(c8HRj,
                       label: block_c8HRj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HRj: // global
           I64[Sp] = block_c8HRp_info;
           _s8G7S::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8G7S::P64;
           if (R1 & 7 != 0) goto u8HRy; else goto c8HRt;
       u8HRy: // global
           call _c8HRp(R1) args: 0, res: 0, upd: 0;
       c8HRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HRp() //  [R1]
         { info_tbl: [(c8HRp,
                       label: block_c8HRp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HRp: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.039198515 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8HRU,
                       label: GHC.IO.Encoding.UTF16.utf16_encode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HRU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.048702307 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF3_closure" {
     GHC.IO.Encoding.UTF16.mkUTF3_closure:
         const GHC.IO.Encoding.UTF16.mkUTF3_info;
 },
 sat_s8G8n_entry() //  [R1]
         { info_tbl: [(c8HSv,
                       label: sat_s8G8n_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HSv: // global
           _s8G8n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HSw; else goto c8HSx;
       c8HSx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HSz; else goto c8HSy;
       c8HSz: // global
           HpAlloc = 56;
           goto c8HSw;
       c8HSw: // global
           R1 = _s8G8n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HSy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8n::P64;
           _s8G89::I64 = I64[_s8G8n::P64 + 56];
           _s8G8j::I64 = I64[_s8G8n::P64 + 64];
           if (_s8G8j::I64 == _s8G89::I64) goto c8HSu; else goto c8HSt;
       c8HSu: // global
           _s8G8h::P64 = P64[_s8G8n::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HSt: // global
           _s8G85::P64 = P64[_s8G8n::P64 + 16];
           _s8G86::P64 = P64[_s8G8n::P64 + 24];
           _s8G84::I64 = I64[_s8G8n::P64 + 40];
           _s8G87::I64 = I64[_s8G8n::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8j::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8v_entry() //  [R1]
         { info_tbl: [(c8HSR,
                       label: sat_s8G8v_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HSR: // global
           _s8G8v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HSS; else goto c8HST;
       c8HST: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HSV; else goto c8HSU;
       c8HSV: // global
           HpAlloc = 56;
           goto c8HSS;
       c8HSS: // global
           R1 = _s8G8v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HSU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8v::P64;
           _s8G89::I64 = I64[_s8G8v::P64 + 56];
           _s8G8r::I64 = I64[_s8G8v::P64 + 64];
           if (_s8G8r::I64 == _s8G89::I64) goto c8HSQ; else goto c8HSP;
       c8HSQ: // global
           _s8G8h::P64 = P64[_s8G8v::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HSP: // global
           _s8G85::P64 = P64[_s8G8v::P64 + 16];
           _s8G86::P64 = P64[_s8G8v::P64 + 24];
           _s8G84::I64 = I64[_s8G8v::P64 + 40];
           _s8G87::I64 = I64[_s8G8v::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8r::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8D_entry() //  [R1]
         { info_tbl: [(c8HTd,
                       label: sat_s8G8D_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HTd: // global
           _s8G8D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HTe; else goto c8HTf;
       c8HTf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HTh; else goto c8HTg;
       c8HTh: // global
           HpAlloc = 56;
           goto c8HTe;
       c8HTe: // global
           R1 = _s8G8D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HTg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8D::P64;
           _s8G89::I64 = I64[_s8G8D::P64 + 56];
           _s8G8z::I64 = I64[_s8G8D::P64 + 64];
           if (_s8G8z::I64 == _s8G89::I64) goto c8HTc; else goto c8HTb;
       c8HTc: // global
           _s8G8h::P64 = P64[_s8G8D::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HTb: // global
           _s8G85::P64 = P64[_s8G8D::P64 + 16];
           _s8G86::P64 = P64[_s8G8D::P64 + 24];
           _s8G84::I64 = I64[_s8G8D::P64 + 40];
           _s8G87::I64 = I64[_s8G8D::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8z::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8L_entry() //  [R1]
         { info_tbl: [(c8HTz,
                       label: sat_s8G8L_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HTz: // global
           _s8G8L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HTA; else goto c8HTB;
       c8HTB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HTD; else goto c8HTC;
       c8HTD: // global
           HpAlloc = 56;
           goto c8HTA;
       c8HTA: // global
           R1 = _s8G8L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HTC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8L::P64;
           _s8G89::I64 = I64[_s8G8L::P64 + 56];
           _s8G8H::I64 = I64[_s8G8L::P64 + 64];
           if (_s8G8H::I64 == _s8G89::I64) goto c8HTy; else goto c8HTx;
       c8HTy: // global
           _s8G8h::P64 = P64[_s8G8L::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HTx: // global
           _s8G85::P64 = P64[_s8G8L::P64 + 16];
           _s8G86::P64 = P64[_s8G8L::P64 + 24];
           _s8G84::I64 = I64[_s8G8L::P64 + 40];
           _s8G87::I64 = I64[_s8G8L::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8H::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G8T_entry() //  [R1]
         { info_tbl: [(c8HTV,
                       label: sat_s8G8T_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HTV: // global
           _s8G8T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HTW; else goto c8HTX;
       c8HTX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HTZ; else goto c8HTY;
       c8HTZ: // global
           HpAlloc = 56;
           goto c8HTW;
       c8HTW: // global
           R1 = _s8G8T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HTY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G8T::P64;
           _s8G89::I64 = I64[_s8G8T::P64 + 56];
           _s8G8P::I64 = I64[_s8G8T::P64 + 64];
           if (_s8G8P::I64 == _s8G89::I64) goto c8HTU; else goto c8HTT;
       c8HTU: // global
           _s8G8h::P64 = P64[_s8G8T::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HTT: // global
           _s8G85::P64 = P64[_s8G8T::P64 + 16];
           _s8G86::P64 = P64[_s8G8T::P64 + 24];
           _s8G84::I64 = I64[_s8G8T::P64 + 40];
           _s8G87::I64 = I64[_s8G8T::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8P::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G91_entry() //  [R1]
         { info_tbl: [(c8HUh,
                       label: sat_s8G91_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HUh: // global
           _s8G91::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HUi; else goto c8HUj;
       c8HUj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HUl; else goto c8HUk;
       c8HUl: // global
           HpAlloc = 56;
           goto c8HUi;
       c8HUi: // global
           R1 = _s8G91::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HUk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G91::P64;
           _s8G89::I64 = I64[_s8G91::P64 + 56];
           _s8G8X::I64 = I64[_s8G91::P64 + 64];
           if (_s8G8X::I64 == _s8G89::I64) goto c8HUg; else goto c8HUf;
       c8HUg: // global
           _s8G8h::P64 = P64[_s8G91::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HUf: // global
           _s8G85::P64 = P64[_s8G91::P64 + 16];
           _s8G86::P64 = P64[_s8G91::P64 + 24];
           _s8G84::I64 = I64[_s8G91::P64 + 40];
           _s8G87::I64 = I64[_s8G91::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G8X::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G99_entry() //  [R1]
         { info_tbl: [(c8HUD,
                       label: sat_s8G99_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HUD: // global
           _s8G99::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HUE; else goto c8HUF;
       c8HUF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HUH; else goto c8HUG;
       c8HUH: // global
           HpAlloc = 56;
           goto c8HUE;
       c8HUE: // global
           R1 = _s8G99::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HUG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G99::P64;
           _s8G89::I64 = I64[_s8G99::P64 + 56];
           _s8G95::I64 = I64[_s8G99::P64 + 64];
           if (_s8G95::I64 == _s8G89::I64) goto c8HUC; else goto c8HUB;
       c8HUC: // global
           _s8G8h::P64 = P64[_s8G99::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HUB: // global
           _s8G85::P64 = P64[_s8G99::P64 + 16];
           _s8G86::P64 = P64[_s8G99::P64 + 24];
           _s8G84::I64 = I64[_s8G99::P64 + 40];
           _s8G87::I64 = I64[_s8G99::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G95::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8G9h_entry() //  [R1]
         { info_tbl: [(c8HUZ,
                       label: sat_s8G9h_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HUZ: // global
           _s8G9h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8HV0; else goto c8HV1;
       c8HV1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HV3; else goto c8HV2;
       c8HV3: // global
           HpAlloc = 56;
           goto c8HV0;
       c8HV0: // global
           R1 = _s8G9h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8HV2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8G9h::P64;
           _s8G89::I64 = I64[_s8G9h::P64 + 56];
           _s8G9d::I64 = I64[_s8G9h::P64 + 64];
           if (_s8G9d::I64 == _s8G89::I64) goto c8HUY; else goto c8HUX;
       c8HUY: // global
           _s8G8h::P64 = P64[_s8G9h::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8G8h::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8HUX: // global
           _s8G85::P64 = P64[_s8G9h::P64 + 16];
           _s8G86::P64 = P64[_s8G9h::P64 + 24];
           _s8G84::I64 = I64[_s8G9h::P64 + 40];
           _s8G87::I64 = I64[_s8G9h::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = _s8G86::P64;
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = _s8G87::I64;
           I64[Hp - 8] = _s8G9d::I64;
           I64[Hp] = _s8G89::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF3_entry() //  [R2, R3]
         { info_tbl: [(c8HV6,
                       label: GHC.IO.Encoding.UTF16.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HV6: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8HV7; else goto c8HV8;
       c8HV7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HV8: // global
           I64[Sp - 16] = block_c8HS5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8HYS; else goto c8HS6;
       u8HYS: // global
           call _c8HS5(R1) args: 0, res: 0, upd: 0;
       c8HS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HS5() //  [R1]
         { info_tbl: [(c8HS5,
                       label: block_c8HS5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HS5: // global
           I64[Sp - 40] = block_c8HSa_info;
           _s8G85::P64 = P64[R1 + 7];
           _s8G86::P64 = P64[R1 + 15];
           _s8G84::I64 = I64[R1 + 23];
           _s8G87::I64 = I64[R1 + 31];
           _s8G88::I64 = I64[R1 + 39];
           _s8G89::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8G86::P64;
           I64[Sp - 24] = _s8G87::I64;
           I64[Sp - 16] = _s8G88::I64;
           I64[Sp - 8] = _s8G89::I64;
           P64[Sp] = _s8G85::P64;
           I64[Sp + 8] = _s8G84::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8HYJ; else goto c8HSb;
       u8HYJ: // global
           call _c8HSa(R1) args: 0, res: 0, upd: 0;
       c8HSb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HSa() //  [R1]
         { info_tbl: [(c8HSa,
                       label: block_c8HSa_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HSa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8HVc; else goto c8HVb;
       c8HVc: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8HVb: // global
           _s8G8c::P64 = P64[R1 + 7];
           _s8G8d::P64 = P64[R1 + 15];
           _s8G8b::I64 = I64[R1 + 23];
           _s8G8e::I64 = I64[R1 + 31];
           _s8G8f::I64 = I64[R1 + 39];
           _s8G8g::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8G85::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8G85::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8G84::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8G84::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8G89::I64 = I64[Sp + 32];
           _c8HSf::P64 = Hp - 47;
           _s8G9m::I64 = _s8G8g::I64;
           _s8G9l::I64 = I64[Sp + 24];
           goto c8HVL;
       c8HVL: // global
           if (%MO_S_Lt_W64(_s8G9m::I64,
                            _s8G8e::I64)) goto c8HXG; else goto c8HXH;
       c8HXG: // global
           if (%MO_S_Lt_W64(_s8G9l::I64,
                            _s8G89::I64)) goto c8HXD; else goto c8HXE;
       c8HXD: // global
           if ((_s8G9l::I64 + 1) == _s8G89::I64) goto c8HXB; else goto c8HXA;
       c8HXB: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HU4() args: 0, res: 0, upd: 0;
       c8HXA: // global
           _s8G9v::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + _s8G9l::I64]);
           call MO_Touch(_s8G85::P64);
           _s8G9B::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 1)]);
           call MO_Touch(_s8G85::P64);
           _s8G9D::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8G9B::I64 << 8)) + _s8G9v::I64));
           if (_s8G9D::I64 >= 55296) goto c8HXx; else goto c8HXy;
       c8HXx: // global
           if (_s8G9D::I64 <= 57343) goto c8HXu; else goto c8HXv;
       c8HXu: // global
           if (%MO_S_Ge_W64(_s8G89::I64 - _s8G9l::I64,
                            4)) goto c8HXr; else goto c8HXs;
       c8HXr: // global
           _s8G9P::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 2)]);
           call MO_Touch(_s8G85::P64);
           _s8G9V::I64 = %MO_UU_Conv_W8_W64(I8[_s8G84::I64 + (_s8G9l::I64 + 3)]);
           call MO_Touch(_s8G85::P64);
           if (_s8G9D::I64 < 55296) goto c8HWR; else goto c8HXp;
       c8HWR: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HSi() args: 0, res: 0, upd: 0;
       c8HXp: // global
           if (_s8G9D::I64 > 56319) goto c8HWX; else goto c8HXo;
       c8HWX: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HSE() args: 0, res: 0, upd: 0;
       c8HXo: // global
           _s8G9Z::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8G9V::I64 << 8)) + _s8G9P::I64));
           if (_s8G9Z::I64 < 56320) goto c8HXf; else goto c8HXn;
       c8HXf: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HT0() args: 0, res: 0, upd: 0;
       c8HXn: // global
           if (_s8G9Z::I64 > 57343) goto c8HXl; else goto c8HXm;
       c8HXl: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HTm() args: 0, res: 0, upd: 0;
       c8HXm: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8G9D::I64 + -55296) << 10) + (_s8G9Z::I64 + -56320) + 65536);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 4;
           goto c8HVL;
       c8HXs: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HTI() args: 0, res: 0, upd: 0;
       c8HXv: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8G9D::I64);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 2;
           goto c8HVL;
       c8HXy: // global
           I32[_s8G8b::I64 + (_s8G9m::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8G9D::I64);
           call MO_Touch(_s8G8c::P64);
           _s8G9m::I64 = _s8G9m::I64 + 1;
           _s8G9l::I64 = _s8G9l::I64 + 2;
           goto c8HVL;
       c8HXE: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HUq() args: 0, res: 0, upd: 0;
       c8HXH: // global
           P64[Sp - 48] = _s8G8c::P64;
           P64[Sp - 40] = _s8G8d::P64;
           I64[Sp - 32] = _s8G8e::I64;
           I64[Sp - 24] = _s8G8f::I64;
           I64[Sp - 16] = _s8G9l::I64;
           I64[Sp - 8] = _s8G9m::I64;
           I64[Sp] = _s8G8b::I64;
           P64[Sp + 24] = _c8HSf::P64;
           Sp = Sp - 56;
           call _c8HUM() args: 0, res: 0, upd: 0;
     }
 },
 _c8HU4() //  []
         { info_tbl: [(c8HU4,
                       label: block_c8HU4_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HU4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVA; else goto c8HVz;
       c8HVA: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HU4_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVz: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G91_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HSi() //  []
         { info_tbl: [(c8HSi,
                       label: block_c8HSi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HSi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVg; else goto c8HVf;
       c8HVg: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HSi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVf: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8n_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HSE() //  []
         { info_tbl: [(c8HSE,
                       label: block_c8HSE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HSE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVk; else goto c8HVj;
       c8HVk: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HSE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVj: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8v_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HT0() //  []
         { info_tbl: [(c8HT0,
                       label: block_c8HT0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HT0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVo; else goto c8HVn;
       c8HVo: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HT0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVn: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8D_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HTm() //  []
         { info_tbl: [(c8HTm,
                       label: block_c8HTm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HTm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVs; else goto c8HVr;
       c8HVs: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HTm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVr: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8L_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HTI() //  []
         { info_tbl: [(c8HTI,
                       label: block_c8HTI_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HTI: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVw; else goto c8HVv;
       c8HVw: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HTI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVv: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G8T_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HUq() //  []
         { info_tbl: [(c8HUq,
                       label: block_c8HUq_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HUq: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVE; else goto c8HVD;
       c8HVE: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HUq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVD: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G99_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8HUM() //  []
         { info_tbl: [(c8HUM,
                       label: block_c8HUM_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HUM: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8HVI; else goto c8HVH;
       c8HVI: // global
           HpAlloc = 160;
           I64[Sp] = block_c8HUM_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8HVH: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8G9h_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.10886021 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_decode_entry() //  [R2, R3]
         { info_tbl: [(c8I2J,
                       label: GHC.IO.Encoding.UTF16.utf16le_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I2J: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.112133581 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16le3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16le3_bytes:
         I8[] [85,84,70,49,54,45,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.114467794 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le2_entry() //  [R1]
         { info_tbl: [(c8I2X,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I2X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8I2Y; else goto c8I2Z;
       c8I2Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I2Z: // global
           (_c8I2U::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8I2U::I64 == 0) goto c8I2W; else goto c8I2V;
       c8I2W: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8I2V: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8I2U::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.118766614 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF2_entry() //  []
         { info_tbl: [(c8I3b,
                       label: GHC.IO.Encoding.UTF16.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I3b: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.122233528 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be1_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be1_entry() //  []
         { info_tbl: [(c8I3n,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I3n: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.126693096 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le_info;
         const 0;
 },
 sat_s8GaC_entry() //  [R1, R2, R3]
         { info_tbl: [(c8I3J,
                       label: sat_s8GaC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I3J: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GaE_entry() //  [R1]
         { info_tbl: [(c8I3N,
                       label: sat_s8GaE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I3N: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8I3R; else goto c8I3Q;
       c8I3R: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8I3Q: // global
           _s8Gaw::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GaC_info;
           P64[Hp - 48] = _s8Gaw::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gay_entry() //  [R1, R2, R3]
         { info_tbl: [(c8I42,
                       label: sat_s8Gay_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I42: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GaA_entry() //  [R1]
         { info_tbl: [(c8I46,
                       label: sat_s8GaA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I46: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8I4a; else goto c8I49;
       c8I4a: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8I49: // global
           _s8Gaw::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Gay_info;
           P64[Hp - 48] = _s8Gaw::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16le_entry() //  [R2]
         { info_tbl: [(c8I4c,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I4c: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8I4g; else goto c8I4f;
       c8I4g: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8I4f: // global
           I64[Hp - 56] = sat_s8GaE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8GaA_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.139751218 UTC

[section ""data" . lvl_r8G1B_closure" {
     lvl_r8G1B_closure:
         const lvl_r8G1B_info;
         const 0;
 },
 lvl_r8G1B_entry() //  [R2, R3]
         { info_tbl: [(c8I4L,
                       label: lvl_r8G1B_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I4L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8I4P; else goto c8I4Q;
       c8I4P: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8G1B_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8I4Q: // global
           I64[Sp - 16] = block_c8I4I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8I4Y; else goto c8I4J;
       u8I4Y: // global
           call _c8I4I() args: 0, res: 0, upd: 0;
       c8I4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8I4I() //  []
         { info_tbl: [(c8I4I,
                       label: block_c8I4I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I4I: // global
           _s8GaG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8I4O_info;
           R1 = _s8GaG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8I4X; else goto c8I4S;
       u8I4X: // global
           call _c8I4O() args: 0, res: 0, upd: 0;
       c8I4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8I4O() //  []
         { info_tbl: [(c8I4O,
                       label: block_c8I4O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I4O: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.146719223 UTC

[section ""data" . lvl1_r8G1C_closure" {
     lvl1_r8G1C_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.148681368 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le2_closure" {
     GHC.IO.Encoding.UTF16.utf16le2_closure:
         const GHC.IO.Encoding.UTF16.utf16le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le2_entry() //  []
         { info_tbl: [(c8I5h,
                       label: GHC.IO.Encoding.UTF16.utf16le2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I5h: // global
           R1 = lvl1_r8G1C_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.15295027 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be2_closure" {
     GHC.IO.Encoding.UTF16.utf16be2_closure:
         const GHC.IO.Encoding.UTF16.utf16be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be2_entry() //  [R2, R3]
         { info_tbl: [(c8I5w,
                       label: GHC.IO.Encoding.UTF16.utf16be2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I5w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8I5A; else goto c8I5B;
       c8I5A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8I5B: // global
           I64[Sp - 16] = block_c8I5t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8I5K; else goto c8I5u;
       u8I5K: // global
           call _c8I5t(R1) args: 0, res: 0, upd: 0;
       c8I5u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8I5t() //  [R1]
         { info_tbl: [(c8I5t,
                       label: block_c8I5t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I5t: // global
           I64[Sp - 16] = block_c8I5z_info;
           _s8Gb2::P64 = P64[R1 + 7];
           _s8Gb1::I64 = I64[R1 + 23];
           _s8Gb5::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8Gb5::I64;
           P64[Sp] = _s8Gb2::P64;
           I64[Sp + 8] = _s8Gb1::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8I5J; else goto c8I5D;
       u8I5J: // global
           call _c8I5z() args: 0, res: 0, upd: 0;
       c8I5D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8I5z() //  []
         { info_tbl: [(c8I5z,
                       label: block_c8I5z_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I5z: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.160305673 UTC

[section ""data" . lvl2_r8G1D_closure" {
     lvl2_r8G1D_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.162741909 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le1_closure" {
     GHC.IO.Encoding.UTF16.utf16le1_closure:
         const GHC.IO.Encoding.UTF16.utf16le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le1_entry() //  []
         { info_tbl: [(c8I63,
                       label: GHC.IO.Encoding.UTF16.utf16le1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I63: // global
           R1 = lvl2_r8G1D_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.166304567 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_closure" {
     GHC.IO.Encoding.UTF16.utf16le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.UTF16.utf16le2_closure+1;
         const GHC.IO.Encoding.UTF16.utf16le1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.174353784 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF5_closure" {
     GHC.IO.Encoding.UTF16.mkUTF5_closure:
         const GHC.IO.Encoding.UTF16.mkUTF5_info;
 },
 sat_s8GbG_entry() //  [R1]
         { info_tbl: [(c8I6G,
                       label: sat_s8GbG_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I6G: // global
           _s8GbG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I6H; else goto c8I6I;
       c8I6I: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I6K; else goto c8I6J;
       c8I6K: // global
           HpAlloc = 56;
           goto c8I6H;
       c8I6H: // global
           R1 = _s8GbG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I6J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbG::P64;
           _s8Gbs::I64 = I64[_s8GbG::P64 + 56];
           _s8GbC::I64 = I64[_s8GbG::P64 + 64];
           if (_s8GbC::I64 == _s8Gbs::I64) goto c8I6F; else goto c8I6E;
       c8I6F: // global
           _s8GbA::P64 = P64[_s8GbG::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I6E: // global
           _s8Gbo::P64 = P64[_s8GbG::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbG::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbG::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbG::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbC::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8GbO_entry() //  [R1]
         { info_tbl: [(c8I72,
                       label: sat_s8GbO_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I72: // global
           _s8GbO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I73; else goto c8I74;
       c8I74: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I76; else goto c8I75;
       c8I76: // global
           HpAlloc = 56;
           goto c8I73;
       c8I73: // global
           R1 = _s8GbO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I75: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbO::P64;
           _s8Gbs::I64 = I64[_s8GbO::P64 + 56];
           _s8GbK::I64 = I64[_s8GbO::P64 + 64];
           if (_s8GbK::I64 == _s8Gbs::I64) goto c8I71; else goto c8I70;
       c8I71: // global
           _s8GbA::P64 = P64[_s8GbO::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I70: // global
           _s8Gbo::P64 = P64[_s8GbO::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbO::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbO::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbO::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbK::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8GbW_entry() //  [R1]
         { info_tbl: [(c8I7o,
                       label: sat_s8GbW_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I7o: // global
           _s8GbW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I7p; else goto c8I7q;
       c8I7q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I7s; else goto c8I7r;
       c8I7s: // global
           HpAlloc = 56;
           goto c8I7p;
       c8I7p: // global
           R1 = _s8GbW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I7r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GbW::P64;
           _s8Gbs::I64 = I64[_s8GbW::P64 + 56];
           _s8GbS::I64 = I64[_s8GbW::P64 + 64];
           if (_s8GbS::I64 == _s8Gbs::I64) goto c8I7n; else goto c8I7m;
       c8I7n: // global
           _s8GbA::P64 = P64[_s8GbW::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I7m: // global
           _s8Gbo::P64 = P64[_s8GbW::P64 + 16];
           _s8Gbp::P64 = P64[_s8GbW::P64 + 24];
           _s8Gbn::I64 = I64[_s8GbW::P64 + 40];
           _s8Gbq::I64 = I64[_s8GbW::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8GbS::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gc4_entry() //  [R1]
         { info_tbl: [(c8I7K,
                       label: sat_s8Gc4_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I7K: // global
           _s8Gc4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I7L; else goto c8I7M;
       c8I7M: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I7O; else goto c8I7N;
       c8I7O: // global
           HpAlloc = 56;
           goto c8I7L;
       c8I7L: // global
           R1 = _s8Gc4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I7N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gc4::P64;
           _s8Gbs::I64 = I64[_s8Gc4::P64 + 56];
           _s8Gc0::I64 = I64[_s8Gc4::P64 + 64];
           if (_s8Gc0::I64 == _s8Gbs::I64) goto c8I7J; else goto c8I7I;
       c8I7J: // global
           _s8GbA::P64 = P64[_s8Gc4::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I7I: // global
           _s8Gbo::P64 = P64[_s8Gc4::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gc4::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gc4::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gc4::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gc0::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gcc_entry() //  [R1]
         { info_tbl: [(c8I86,
                       label: sat_s8Gcc_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I86: // global
           _s8Gcc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I87; else goto c8I88;
       c8I88: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I8a; else goto c8I89;
       c8I8a: // global
           HpAlloc = 56;
           goto c8I87;
       c8I87: // global
           R1 = _s8Gcc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I89: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gcc::P64;
           _s8Gbs::I64 = I64[_s8Gcc::P64 + 56];
           _s8Gc8::I64 = I64[_s8Gcc::P64 + 64];
           if (_s8Gc8::I64 == _s8Gbs::I64) goto c8I85; else goto c8I84;
       c8I85: // global
           _s8GbA::P64 = P64[_s8Gcc::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I84: // global
           _s8Gbo::P64 = P64[_s8Gcc::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gcc::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gcc::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gcc::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gc8::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gck_entry() //  [R1]
         { info_tbl: [(c8I8s,
                       label: sat_s8Gck_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I8s: // global
           _s8Gck::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I8t; else goto c8I8u;
       c8I8u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I8w; else goto c8I8v;
       c8I8w: // global
           HpAlloc = 56;
           goto c8I8t;
       c8I8t: // global
           R1 = _s8Gck::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I8v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gck::P64;
           _s8Gbs::I64 = I64[_s8Gck::P64 + 56];
           _s8Gcg::I64 = I64[_s8Gck::P64 + 64];
           if (_s8Gcg::I64 == _s8Gbs::I64) goto c8I8r; else goto c8I8q;
       c8I8r: // global
           _s8GbA::P64 = P64[_s8Gck::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I8q: // global
           _s8Gbo::P64 = P64[_s8Gck::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gck::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gck::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gck::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gcg::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Gcs_entry() //  [R1]
         { info_tbl: [(c8I8O,
                       label: sat_s8Gcs_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I8O: // global
           _s8Gcs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I8P; else goto c8I8Q;
       c8I8Q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I8S; else goto c8I8R;
       c8I8S: // global
           HpAlloc = 56;
           goto c8I8P;
       c8I8P: // global
           R1 = _s8Gcs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I8R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Gcs::P64;
           _s8Gbs::I64 = I64[_s8Gcs::P64 + 56];
           _s8Gco::I64 = I64[_s8Gcs::P64 + 64];
           if (_s8Gco::I64 == _s8Gbs::I64) goto c8I8N; else goto c8I8M;
       c8I8N: // global
           _s8GbA::P64 = P64[_s8Gcs::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I8M: // global
           _s8Gbo::P64 = P64[_s8Gcs::P64 + 16];
           _s8Gbp::P64 = P64[_s8Gcs::P64 + 24];
           _s8Gbn::I64 = I64[_s8Gcs::P64 + 40];
           _s8Gbq::I64 = I64[_s8Gcs::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gco::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8GcA_entry() //  [R1]
         { info_tbl: [(c8I9a,
                       label: sat_s8GcA_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I9a: // global
           _s8GcA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8I9b; else goto c8I9c;
       c8I9c: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I9e; else goto c8I9d;
       c8I9e: // global
           HpAlloc = 56;
           goto c8I9b;
       c8I9b: // global
           R1 = _s8GcA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8I9d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8GcA::P64;
           _s8Gbs::I64 = I64[_s8GcA::P64 + 56];
           _s8Gcw::I64 = I64[_s8GcA::P64 + 64];
           if (_s8Gcw::I64 == _s8Gbs::I64) goto c8I99; else goto c8I98;
       c8I99: // global
           _s8GbA::P64 = P64[_s8GcA::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8GbA::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8I98: // global
           _s8Gbo::P64 = P64[_s8GcA::P64 + 16];
           _s8Gbp::P64 = P64[_s8GcA::P64 + 24];
           _s8Gbn::I64 = I64[_s8GcA::P64 + 40];
           _s8Gbq::I64 = I64[_s8GcA::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = _s8Gbp::P64;
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = _s8Gbq::I64;
           I64[Hp - 8] = _s8Gcw::I64;
           I64[Hp] = _s8Gbs::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF5_entry() //  [R2, R3]
         { info_tbl: [(c8I9h,
                       label: GHC.IO.Encoding.UTF16.mkUTF5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I9h: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8I9i; else goto c8I9j;
       c8I9i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8I9j: // global
           I64[Sp - 16] = block_c8I6g_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Id3; else goto c8I6h;
       u8Id3: // global
           call _c8I6g(R1) args: 0, res: 0, upd: 0;
       c8I6h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8I6g() //  [R1]
         { info_tbl: [(c8I6g,
                       label: block_c8I6g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I6g: // global
           I64[Sp - 40] = block_c8I6l_info;
           _s8Gbo::P64 = P64[R1 + 7];
           _s8Gbp::P64 = P64[R1 + 15];
           _s8Gbn::I64 = I64[R1 + 23];
           _s8Gbq::I64 = I64[R1 + 31];
           _s8Gbr::I64 = I64[R1 + 39];
           _s8Gbs::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Gbp::P64;
           I64[Sp - 24] = _s8Gbq::I64;
           I64[Sp - 16] = _s8Gbr::I64;
           I64[Sp - 8] = _s8Gbs::I64;
           P64[Sp] = _s8Gbo::P64;
           I64[Sp + 8] = _s8Gbn::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8IcU; else goto c8I6m;
       u8IcU: // global
           call _c8I6l(R1) args: 0, res: 0, upd: 0;
       c8I6m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8I6l() //  [R1]
         { info_tbl: [(c8I6l,
                       label: block_c8I6l_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I6l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8I9n; else goto c8I9m;
       c8I9n: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8I9m: // global
           _s8Gbv::P64 = P64[R1 + 7];
           _s8Gbw::P64 = P64[R1 + 15];
           _s8Gbu::I64 = I64[R1 + 23];
           _s8Gbx::I64 = I64[R1 + 31];
           _s8Gby::I64 = I64[R1 + 39];
           _s8Gbz::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Gbo::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Gbo::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Gbn::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Gbn::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Gbs::I64 = I64[Sp + 32];
           _c8I6q::P64 = Hp - 47;
           _s8GcF::I64 = _s8Gbz::I64;
           _s8GcE::I64 = I64[Sp + 24];
           goto c8I9W;
       c8I9W: // global
           if (%MO_S_Lt_W64(_s8GcF::I64,
                            _s8Gbx::I64)) goto c8IbR; else goto c8IbS;
       c8IbR: // global
           if (%MO_S_Lt_W64(_s8GcE::I64,
                            _s8Gbs::I64)) goto c8IbO; else goto c8IbP;
       c8IbO: // global
           if ((_s8GcE::I64 + 1) == _s8Gbs::I64) goto c8IbM; else goto c8IbL;
       c8IbM: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I8f() args: 0, res: 0, upd: 0;
       c8IbL: // global
           _s8GcO::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + _s8GcE::I64]);
           call MO_Touch(_s8Gbo::P64);
           _s8GcU::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 1)]);
           call MO_Touch(_s8Gbo::P64);
           _s8GcW::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8GcO::I64 << 8)) + _s8GcU::I64));
           if (_s8GcW::I64 >= 55296) goto c8IbI; else goto c8IbJ;
       c8IbI: // global
           if (_s8GcW::I64 <= 57343) goto c8IbF; else goto c8IbG;
       c8IbF: // global
           if (%MO_S_Ge_W64(_s8Gbs::I64 - _s8GcE::I64,
                            4)) goto c8IbC; else goto c8IbD;
       c8IbC: // global
           _s8Gd8::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 2)]);
           call MO_Touch(_s8Gbo::P64);
           _s8Gde::I64 = %MO_UU_Conv_W8_W64(I8[_s8Gbn::I64 + (_s8GcE::I64 + 3)]);
           call MO_Touch(_s8Gbo::P64);
           if (_s8GcW::I64 < 55296) goto c8Ib2; else goto c8IbA;
       c8Ib2: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I6t() args: 0, res: 0, upd: 0;
       c8IbA: // global
           if (_s8GcW::I64 > 56319) goto c8Ib8; else goto c8Ibz;
       c8Ib8: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I6P() args: 0, res: 0, upd: 0;
       c8Ibz: // global
           _s8Gdi::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8Gd8::I64 << 8)) + _s8Gde::I64));
           if (_s8Gdi::I64 < 56320) goto c8Ibq; else goto c8Iby;
       c8Ibq: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I7b() args: 0, res: 0, upd: 0;
       c8Iby: // global
           if (_s8Gdi::I64 > 57343) goto c8Ibw; else goto c8Ibx;
       c8Ibw: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I7x() args: 0, res: 0, upd: 0;
       c8Ibx: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8GcW::I64 + -55296) << 10) + (_s8Gdi::I64 + -56320) + 65536);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 4;
           goto c8I9W;
       c8IbD: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I7T() args: 0, res: 0, upd: 0;
       c8IbG: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8GcW::I64);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 2;
           goto c8I9W;
       c8IbJ: // global
           I32[_s8Gbu::I64 + (_s8GcF::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8GcW::I64);
           call MO_Touch(_s8Gbv::P64);
           _s8GcF::I64 = _s8GcF::I64 + 1;
           _s8GcE::I64 = _s8GcE::I64 + 2;
           goto c8I9W;
       c8IbP: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I8B() args: 0, res: 0, upd: 0;
       c8IbS: // global
           P64[Sp - 48] = _s8Gbv::P64;
           P64[Sp - 40] = _s8Gbw::P64;
           I64[Sp - 32] = _s8Gbx::I64;
           I64[Sp - 24] = _s8Gby::I64;
           I64[Sp - 16] = _s8GcE::I64;
           I64[Sp - 8] = _s8GcF::I64;
           I64[Sp] = _s8Gbu::I64;
           P64[Sp + 24] = _c8I6q::P64;
           Sp = Sp - 56;
           call _c8I8X() args: 0, res: 0, upd: 0;
     }
 },
 _c8I8f() //  []
         { info_tbl: [(c8I8f,
                       label: block_c8I8f_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I8f: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9L; else goto c8I9K;
       c8I9L: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I8f_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9K: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gck_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8I6t() //  []
         { info_tbl: [(c8I6t,
                       label: block_c8I6t_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I6t: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9r; else goto c8I9q;
       c8I9r: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I6t_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9q: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbG_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8I6P() //  []
         { info_tbl: [(c8I6P,
                       label: block_c8I6P_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I6P: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9v; else goto c8I9u;
       c8I9v: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I6P_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9u: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbO_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8I7b() //  []
         { info_tbl: [(c8I7b,
                       label: block_c8I7b_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I7b: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9z; else goto c8I9y;
       c8I9z: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I7b_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9y: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GbW_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8I7x() //  []
         { info_tbl: [(c8I7x,
                       label: block_c8I7x_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I7x: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9D; else goto c8I9C;
       c8I9D: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I7x_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9C: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gc4_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8I7T() //  []
         { info_tbl: [(c8I7T,
                       label: block_c8I7T_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I7T: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9H; else goto c8I9G;
       c8I9H: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I7T_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9G: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gcc_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8I8B() //  []
         { info_tbl: [(c8I8B,
                       label: block_c8I8B_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I8B: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9P; else goto c8I9O;
       c8I9P: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I8B_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9O: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Gcs_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8I8X() //  []
         { info_tbl: [(c8I8X,
                       label: block_c8I8X_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I8X: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8I9T; else goto c8I9S;
       c8I9T: // global
           HpAlloc = 160;
           I64[Sp] = block_c8I8X_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8I9S: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8GcA_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.234765777 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_decode_entry() //  [R2, R3]
         { info_tbl: [(c8IgU,
                       label: GHC.IO.Encoding.UTF16.utf16be_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IgU: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.238497619 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16be3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16be3_bytes:
         I8[] [85,84,70,45,49,54,66,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.240455147 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be2_entry() //  [R1]
         { info_tbl: [(c8Ih8,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ih8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ih9; else goto c8Iha;
       c8Ih9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Iha: // global
           (_c8Ih5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Ih5::I64 == 0) goto c8Ih7; else goto c8Ih6;
       c8Ih7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ih6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Ih5::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.246969133 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be_info;
         const 0;
 },
 sat_s8GdS_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Ihw,
                       label: sat_s8GdS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ihw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GdU_entry() //  [R1]
         { info_tbl: [(c8IhA,
                       label: sat_s8GdU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IhA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8IhE; else goto c8IhD;
       c8IhE: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8IhD: // global
           _s8GdM::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GdS_info;
           P64[Hp - 48] = _s8GdM::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GdO_entry() //  [R1, R2, R3]
         { info_tbl: [(c8IhP,
                       label: sat_s8GdO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IhP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8GdQ_entry() //  [R1]
         { info_tbl: [(c8IhT,
                       label: sat_s8GdQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IhT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8IhX; else goto c8IhW;
       c8IhX: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8IhW: // global
           _s8GdM::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8GdO_info;
           P64[Hp - 48] = _s8GdM::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16be_entry() //  [R2]
         { info_tbl: [(c8IhZ,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IhZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Ii3; else goto c8Ii2;
       c8Ii3: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Ii2: // global
           I64[Hp - 56] = sat_s8GdU_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8GdQ_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.259218073 UTC

[section ""data" . lvl3_r8G1E_closure" {
     lvl3_r8G1E_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.262150326 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be3_closure" {
     GHC.IO.Encoding.UTF16.utf16be3_closure:
         const GHC.IO.Encoding.UTF16.utf16be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be3_entry() //  []
         { info_tbl: [(c8Iiw,
                       label: GHC.IO.Encoding.UTF16.utf16be3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Iiw: // global
           R1 = lvl3_r8G1E_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.265616253 UTC

[section ""data" . lvl4_r8G1F_closure" {
     lvl4_r8G1F_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.26758348 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be1_closure" {
     GHC.IO.Encoding.UTF16.utf16be1_closure:
         const GHC.IO.Encoding.UTF16.utf16be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be1_entry() //  []
         { info_tbl: [(c8IiJ,
                       label: GHC.IO.Encoding.UTF16.utf16be1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IiJ: // global
           R1 = lvl4_r8G1F_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.270843395 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_closure" {
     GHC.IO.Encoding.UTF16.utf16be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const GHC.IO.Encoding.UTF16.utf16be3_closure+1;
         const GHC.IO.Encoding.UTF16.utf16be1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.272695494 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF6_closure" {
     GHC.IO.Encoding.UTF16.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.275168051 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF4_closure" {
     GHC.IO.Encoding.UTF16.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.278696801 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_decode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_decode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IiV: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8Ij6,
                       label: GHC.IO.Encoding.UTF16.$wutf16_decode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ij6: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8Ij7; else goto c8Ij8;
       c8Ij7: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8Ij8: // global
           I64[Sp - 48] = block_c8IiZ_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8IkB; else goto c8Ij0;
       u8IkB: // global
           call _c8IiZ(R1) args: 0, res: 0, upd: 0;
       c8Ij0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8IiZ() //  [R1]
         { info_tbl: [(c8IiZ,
                       label: block_c8IiZ_info
                       rep:StackRep [False, True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IiZ: // global
           _s8GdY::I64 = I64[Sp + 16];
           _s8GdZ::P64 = P64[Sp + 24];
           _s8Ge0::P64 = P64[Sp + 32];
           _s8Ge1::I64 = I64[Sp + 40];
           _s8Ge2::I64 = I64[Sp + 48];
           _s8Ge3::I64 = I64[Sp + 56];
           _s8Ge4::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8Ij3; else goto c8Ij4;
       c8Ij3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Ijd; else goto c8Ijc;
       c8Ijd: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ijc: // global
           if (%MO_S_Ge_W64(_s8Ge3::I64 - _s8Ge2::I64,
                            2)) goto c8Iko; else goto c8Iks;
       c8Iko: // global
           _s8GdX::P64 = P64[Sp + 8];
           _s8Gef::I64 = %MO_UU_Conv_W8_W64(I8[_s8GdY::I64 + _s8Ge2::I64]);
           call MO_Touch(_s8GdZ::P64);
           _s8Gel::I64 = %MO_UU_Conv_W8_W64(I8[_s8GdY::I64 + (_s8Ge2::I64 + 1)]);
           call MO_Touch(_s8GdZ::P64);
           if (_s8Gef::I64 != 254) goto c8Ikb; else goto c8Ikm;
       c8Ikm: // global
           if (_s8Gel::I64 != 255) goto c8Ikb; else goto c8Ikl;
       c8Ikb: // global
           Hp = Hp - 88;
           I64[Sp - 8] = _s8Gel::I64;
           I64[Sp] = _s8Gef::I64;
           Sp = Sp - 16;
           call _c8Ijy() args: 0, res: 0, upd: 0;
       c8Ikl: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8GdZ::P64;
           P64[Hp - 64] = _s8Ge0::P64;
           I64[Hp - 56] = _s8GdY::I64;
           I64[Hp - 48] = _s8Ge1::I64;
           I64[Hp - 40] = _s8Ge2::I64 + 2;
           I64[Hp - 32] = _s8Ge3::I64;
           _c8Ikk::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8Ge4::P64;
           R2 = _c8Ikk::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8Iks: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8GdZ::P64;
           P64[Hp - 64] = _s8Ge0::P64;
           I64[Hp - 56] = _s8GdY::I64;
           I64[Hp - 48] = _s8Ge1::I64;
           I64[Hp - 40] = _s8Ge2::I64;
           I64[Hp - 32] = _s8Ge3::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8Ge4::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Ij4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Iky; else goto c8Ikx;
       c8Iky: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ikx: // global
           _s8GeE::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           R1 = _s8GeE::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ijy() //  []
         { info_tbl: [(c8Ijy,
                       label: block_c8Ijy_info
                       rep:StackRep [True, True, False, True, False, False, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ijy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IjC; else goto c8IjB;
       c8IjC: // global
           HpAlloc = 56;
           I64[Sp] = block_c8Ijy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IjB: // global
           _s8GdX::P64 = P64[Sp + 24];
           _s8GdY::I64 = I64[Sp + 32];
           _s8GdZ::P64 = P64[Sp + 40];
           _s8Ge0::P64 = P64[Sp + 48];
           _s8Ge1::I64 = I64[Sp + 56];
           _s8Ge2::I64 = I64[Sp + 64];
           _s8Ge3::I64 = I64[Sp + 72];
           _s8Ge4::P64 = P64[Sp + 80];
           if (I64[Sp + 16] == 255) goto c8Ik3; else goto c8IjK;
       c8Ik3: // global
           if (I64[Sp + 8] == 254) goto c8Ik2; else goto c8IjT;
       c8Ik2: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64 + 2;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8IjT: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8IjK: // global
           call MO_WriteBarrier();
           P64[_s8GdX::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GdX::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8GdZ::P64;
           P64[Hp - 32] = _s8Ge0::P64;
           I64[Hp - 24] = _s8GdY::I64;
           I64[Hp - 16] = _s8Ge1::I64;
           I64[Hp - 8] = _s8Ge2::I64;
           I64[Hp] = _s8Ge3::I64;
           R3 = _s8Ge4::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.294000437 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Ila,
                       label: GHC.IO.Encoding.UTF16.utf16_decode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ila: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ile; else goto c8Ilf;
       c8Ile: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ilf: // global
           I64[Sp - 24] = block_c8Il7_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Iln; else goto c8Il8;
       u8Iln: // global
           call _c8Il7(R1) args: 0, res: 0, upd: 0;
       c8Il8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Il7() //  [R1]
         { info_tbl: [(c8Il7,
                       label: block_c8Il7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Il7: // global
           I64[Sp] = block_c8Ild_info;
           _s8GeL::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8GeL::P64;
           if (R1 & 7 != 0) goto u8Ilm; else goto c8Ilh;
       u8Ilm: // global
           call _c8Ild(R1) args: 0, res: 0, upd: 0;
       c8Ilh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ild() //  [R1]
         { info_tbl: [(c8Ild,
                       label: block_c8Ild_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ild: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.302949568 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8IlH,
                       label: GHC.IO.Encoding.UTF16.utf16_decode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IlH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.306941917 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF8_bytes:
         I8[] [85,84,70,45,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.308873224 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF7_closure" {
     GHC.IO.Encoding.UTF16.mkUTF7_closure:
         const GHC.IO.Encoding.UTF16.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF7_entry() //  [R1]
         { info_tbl: [(c8IlV,
                       label: GHC.IO.Encoding.UTF16.mkUTF7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IlV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8IlW; else goto c8IlX;
       c8IlW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IlX: // global
           (_c8IlS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8IlS::I64 == 0) goto c8IlU; else goto c8IlT;
       c8IlU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8IlT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8IlS::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.315095325 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16_info;
         const 0;
 },
 sat_s8GfD_entry() //  [R1, R2]
         { info_tbl: [(c8Imo,
                       label: sat_s8GfD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Imo: // global
           _s8Gfl::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8Gfl::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Gfl::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfz_entry() //  [R1]
         { info_tbl: [(c8Imx,
                       label: sat_s8Gfz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Imx: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfx_entry() //  [R1, R2, R3]
         { info_tbl: [(c8ImF,
                       label: sat_s8Gfx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ImF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfw_entry() //  [R1, R2, R3]
         { info_tbl: [(c8ImQ,
                       label: sat_s8Gfw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ImQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ImR; else goto c8ImS;
       c8ImR: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ImS: // global
           I64[Sp - 24] = block_c8ImN_info;
           _s8Gfl::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8Gfl::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8ImW; else goto c8ImO;
       u8ImW: // global
           call _c8ImN(R1) args: 0, res: 0, upd: 0;
       c8ImO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ImN() //  [R1]
         { info_tbl: [(c8ImN,
                       label: block_c8ImN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ImN: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8GfF_entry() //  [R1]
         { info_tbl: [(c8ImY,
                       label: sat_s8GfF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ImY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ImZ; else goto c8In0;
       c8ImZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8In0: // global
           I64[Sp - 16] = block_c8Ime_info;
           _s8GeT::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8GeT::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ime() //  [R1]
         { info_tbl: [(c8Ime,
                       label: block_c8Ime_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ime: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8In3; else goto c8In2;
       c8In3: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8In2: // global
           I64[Hp - 104] = sat_s8GfD_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Gfz_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Gfx_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Gfw_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gff_entry() //  [R1, R2]
         { info_tbl: [(c8Inj,
                       label: sat_s8Gff_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Inj: // global
           _s8GeX::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8GeX::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8GeX::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gfb_entry() //  [R1]
         { info_tbl: [(c8Ins,
                       label: sat_s8Gfb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ins: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gf9_entry() //  [R1, R2, R3]
         { info_tbl: [(c8InA,
                       label: sat_s8Gf9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8InA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Gf8_entry() //  [R1, R2, R3]
         { info_tbl: [(c8InL,
                       label: sat_s8Gf8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8InL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8InM; else goto c8InN;
       c8InM: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8InN: // global
           I64[Sp - 24] = block_c8InI_info;
           _s8GeX::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8GeX::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8InR; else goto c8InJ;
       u8InR: // global
           call _c8InI(R1) args: 0, res: 0, upd: 0;
       c8InJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8InI() //  [R1]
         { info_tbl: [(c8InI,
                       label: block_c8InI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8InI: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8Gfh_entry() //  [R1]
         { info_tbl: [(c8InT,
                       label: sat_s8Gfh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8InT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8InU; else goto c8InV;
       c8InU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8InV: // global
           I64[Sp - 16] = block_c8In9_info;
           _s8GeT::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8GeT::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8In9() //  [R1]
         { info_tbl: [(c8In9,
                       label: block_c8In9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8In9: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8InY; else goto c8InX;
       c8InY: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8InX: // global
           I64[Hp - 104] = sat_s8Gff_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8Gfb_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8Gf9_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8Gf8_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16_entry() //  [R2]
         { info_tbl: [(c8Io0,
                       label: GHC.IO.Encoding.UTF16.mkUTF16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Io0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Io4; else goto c8Io3;
       c8Io4: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Io3: // global
           I64[Hp - 56] = sat_s8GfF_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Gfh_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.346470225 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_closure" {
     GHC.IO.Encoding.UTF16.utf16_closure:
         const GHC.IO.Encoding.UTF16.utf16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16_entry() //  [R1]
         { info_tbl: [(c8Ipt,
                       label: GHC.IO.Encoding.UTF16.utf16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ipt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ipu; else goto c8Ipv;
       c8Ipu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ipv: // global
           (_c8Ipq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Ipq::I64 == 0) goto c8Ips; else goto c8Ipr;
       c8Ips: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ipr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Ipq::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF16.mkUTF16_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:49.350516921 UTC

[section ""relreadonly" . S8GEr_srt" {
     S8GEr_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8G1B_closure;
         const lvl1_r8G1C_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF16.utf16be2_closure;
         const lvl2_r8G1D_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const lvl3_r8G1E_closure;
         const lvl4_r8G1F_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16_closure;
         const GHC.IO.Encoding.UTF16.mkUTF7_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.600138884 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:53.606768178 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF1_info;
 },
 sat_s8Iq1_entry() //  [R1]
         { info_tbl: [(c8IE7,
                       label: sat_s8Iq1_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IE7: // global
           _s8Iq1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IE8; else goto c8IE9;
       c8IE9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IEb; else goto c8IEa;
       c8IEb: // global
           HpAlloc = 56;
           goto c8IE8;
       c8IE8: // global
           R1 = _s8Iq1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IEa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iq1::P64;
           _s8IpN::I64 = I64[_s8Iq1::P64 + 56];
           _s8IpX::I64 = I64[_s8Iq1::P64 + 64];
           if (_s8IpX::I64 == _s8IpN::I64) goto c8IE6; else goto c8IE5;
       c8IE6: // global
           _s8IpV::P64 = P64[_s8Iq1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IE5: // global
           _s8IpJ::P64 = P64[_s8Iq1::P64 + 16];
           _s8IpK::P64 = P64[_s8Iq1::P64 + 24];
           _s8IpI::I64 = I64[_s8Iq1::P64 + 40];
           _s8IpL::I64 = I64[_s8Iq1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8IpX::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Iq9_entry() //  [R1]
         { info_tbl: [(c8IEt,
                       label: sat_s8Iq9_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IEt: // global
           _s8Iq9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IEu; else goto c8IEv;
       c8IEv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IEx; else goto c8IEw;
       c8IEx: // global
           HpAlloc = 56;
           goto c8IEu;
       c8IEu: // global
           R1 = _s8Iq9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IEw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iq9::P64;
           _s8IpN::I64 = I64[_s8Iq9::P64 + 56];
           _s8Iq5::I64 = I64[_s8Iq9::P64 + 64];
           if (_s8Iq5::I64 == _s8IpN::I64) goto c8IEs; else goto c8IEr;
       c8IEs: // global
           _s8IpV::P64 = P64[_s8Iq9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IEr: // global
           _s8IpJ::P64 = P64[_s8Iq9::P64 + 16];
           _s8IpK::P64 = P64[_s8Iq9::P64 + 24];
           _s8IpI::I64 = I64[_s8Iq9::P64 + 40];
           _s8IpL::I64 = I64[_s8Iq9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8Iq5::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Iqh_entry() //  [R1]
         { info_tbl: [(c8IEP,
                       label: sat_s8Iqh_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IEP: // global
           _s8Iqh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IEQ; else goto c8IER;
       c8IER: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IET; else goto c8IES;
       c8IET: // global
           HpAlloc = 56;
           goto c8IEQ;
       c8IEQ: // global
           R1 = _s8Iqh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IES: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iqh::P64;
           _s8IpN::I64 = I64[_s8Iqh::P64 + 56];
           _s8Iqd::I64 = I64[_s8Iqh::P64 + 64];
           if (_s8Iqd::I64 == _s8IpN::I64) goto c8IEO; else goto c8IEN;
       c8IEO: // global
           _s8IpV::P64 = P64[_s8Iqh::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IEN: // global
           _s8IpJ::P64 = P64[_s8Iqh::P64 + 16];
           _s8IpK::P64 = P64[_s8Iqh::P64 + 24];
           _s8IpI::I64 = I64[_s8Iqh::P64 + 40];
           _s8IpL::I64 = I64[_s8Iqh::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8Iqd::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Iqp_entry() //  [R1]
         { info_tbl: [(c8IFb,
                       label: sat_s8Iqp_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IFb: // global
           _s8Iqp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IFc; else goto c8IFd;
       c8IFd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IFf; else goto c8IFe;
       c8IFf: // global
           HpAlloc = 56;
           goto c8IFc;
       c8IFc: // global
           R1 = _s8Iqp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IFe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iqp::P64;
           _s8IpN::I64 = I64[_s8Iqp::P64 + 56];
           _s8Iql::I64 = I64[_s8Iqp::P64 + 64];
           if (_s8Iql::I64 == _s8IpN::I64) goto c8IFa; else goto c8IF9;
       c8IFa: // global
           _s8IpV::P64 = P64[_s8Iqp::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IF9: // global
           _s8IpJ::P64 = P64[_s8Iqp::P64 + 16];
           _s8IpK::P64 = P64[_s8Iqp::P64 + 24];
           _s8IpI::I64 = I64[_s8Iqp::P64 + 40];
           _s8IpL::I64 = I64[_s8Iqp::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8Iql::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Iqx_entry() //  [R1]
         { info_tbl: [(c8IFx,
                       label: sat_s8Iqx_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IFx: // global
           _s8Iqx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IFy; else goto c8IFz;
       c8IFz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IFB; else goto c8IFA;
       c8IFB: // global
           HpAlloc = 56;
           goto c8IFy;
       c8IFy: // global
           R1 = _s8Iqx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IFA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iqx::P64;
           _s8IpN::I64 = I64[_s8Iqx::P64 + 56];
           _s8Iqt::I64 = I64[_s8Iqx::P64 + 64];
           if (_s8Iqt::I64 == _s8IpN::I64) goto c8IFw; else goto c8IFv;
       c8IFw: // global
           _s8IpV::P64 = P64[_s8Iqx::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IFv: // global
           _s8IpJ::P64 = P64[_s8Iqx::P64 + 16];
           _s8IpK::P64 = P64[_s8Iqx::P64 + 24];
           _s8IpI::I64 = I64[_s8Iqx::P64 + 40];
           _s8IpL::I64 = I64[_s8Iqx::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8Iqt::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IqF_entry() //  [R1]
         { info_tbl: [(c8IFT,
                       label: sat_s8IqF_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IFT: // global
           _s8IqF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IFU; else goto c8IFV;
       c8IFV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IFX; else goto c8IFW;
       c8IFX: // global
           HpAlloc = 56;
           goto c8IFU;
       c8IFU: // global
           R1 = _s8IqF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IFW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IqF::P64;
           _s8IpN::I64 = I64[_s8IqF::P64 + 56];
           _s8IqB::I64 = I64[_s8IqF::P64 + 64];
           if (_s8IqB::I64 == _s8IpN::I64) goto c8IFS; else goto c8IFR;
       c8IFS: // global
           _s8IpV::P64 = P64[_s8IqF::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IpV::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IFR: // global
           _s8IpJ::P64 = P64[_s8IqF::P64 + 16];
           _s8IpK::P64 = P64[_s8IqF::P64 + 24];
           _s8IpI::I64 = I64[_s8IqF::P64 + 40];
           _s8IpL::I64 = I64[_s8IqF::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = _s8IpK::P64;
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = _s8IpL::I64;
           I64[Hp - 8] = _s8IqB::I64;
           I64[Hp] = _s8IpN::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF1_entry() //  [R2, R3]
         { info_tbl: [(c8IG0,
                       label: GHC.IO.Encoding.UTF16.mkUTF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IG0: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8IG1; else goto c8IG2;
       c8IG1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8IG2: // global
           I64[Sp - 16] = block_c8IDH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8IL8; else goto c8IDI;
       u8IL8: // global
           call _c8IDH(R1) args: 0, res: 0, upd: 0;
       c8IDI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8IDH() //  [R1]
         { info_tbl: [(c8IDH,
                       label: block_c8IDH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IDH: // global
           I64[Sp - 40] = block_c8IDM_info;
           _s8IpJ::P64 = P64[R1 + 7];
           _s8IpK::P64 = P64[R1 + 15];
           _s8IpI::I64 = I64[R1 + 23];
           _s8IpL::I64 = I64[R1 + 31];
           _s8IpM::I64 = I64[R1 + 39];
           _s8IpN::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8IpK::P64;
           I64[Sp - 24] = _s8IpL::I64;
           I64[Sp - 16] = _s8IpM::I64;
           I64[Sp - 8] = _s8IpN::I64;
           P64[Sp] = _s8IpJ::P64;
           I64[Sp + 8] = _s8IpI::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8IL1; else goto c8IDN;
       u8IL1: // global
           call _c8IDM(R1) args: 0, res: 0, upd: 0;
       c8IDN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8IDM() //  [R1]
         { info_tbl: [(c8IDM,
                       label: block_c8IDM_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IDM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IG6; else goto c8IG5;
       c8IG6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8IG5: // global
           _s8IpQ::P64 = P64[R1 + 7];
           _s8IpR::P64 = P64[R1 + 15];
           _s8IpP::I64 = I64[R1 + 23];
           _s8IpS::I64 = I64[R1 + 31];
           _s8IpT::I64 = I64[R1 + 39];
           _s8IpU::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8IpJ::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8IpJ::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8IpI::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8IpI::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8IpN::I64 = I64[Sp + 32];
           _c8IDR::P64 = Hp - 47;
           _s8IqK::I64 = _s8IpU::I64;
           _s8IqJ::I64 = I64[Sp + 24];
           goto c8IGx;
       c8IGx: // global
           if (%MO_S_Lt_W64(_s8IqJ::I64,
                            _s8IpN::I64)) goto c8IHI; else goto c8IHJ;
       c8IHI: // global
           if (%MO_S_Ge_W64(_s8IpS::I64 - _s8IqK::I64,
                            2)) goto c8IHF; else goto c8IHG;
       c8IHF: // global
           _s8IqR::I64 = %MO_UU_Conv_W32_W64(I32[_s8IpI::I64 + (_s8IqJ::I64 << 2)]);
           call MO_Touch(_s8IpJ::P64);
           if (%MO_S_Ge_W64(_s8IqR::I64, 65536)) goto c8IH0; else goto c8IHD;
       c8IH0: // global
           if (%MO_S_Ge_W64(_s8IpS::I64 - _s8IqK::I64,
                            4)) goto c8IGX; else goto c8IGY;
       c8IGX: // global
           _s8IqX::I64 = _s8IqR::I64 - 65536;
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqX::I64,
                                                                            18) + 216);
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqX::I64,
                                                                                  10));
           call MO_Touch(_s8IpQ::P64);
           _s8Irc::I64 = _s8IqX::I64 & 1023;
           I8[_s8IpP::I64 + (_s8IqK::I64 + 2)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8Irc::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 3)] = %MO_UU_Conv_W64_W8(_s8Irc::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 4;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IGY: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IDU() args: 0, res: 0, upd: 0;
       c8IHD: // global
           if (%MO_S_Gt_W64(55296, _s8IqR::I64)) goto c8IHi; else goto c8IHC;
       c8IHi: // global
           if (%MO_S_Gt_W64(56320, _s8IqR::I64)) goto c8IH8; else goto c8IHg;
       c8IH8: // global
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqR::I64,
                                                                            8));
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8IqR::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 2;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IHg: // global
           if (%MO_S_Gt_W64(_s8IqR::I64, 57343)) goto c8IHe; else goto c8IHf;
       c8IHe: // global
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqR::I64,
                                                                            8));
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8IqR::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 2;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IHf: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IEg() args: 0, res: 0, upd: 0;
       c8IHC: // global
           if (%MO_S_Gt_W64(_s8IqR::I64, 56319)) goto c8IHA; else goto c8IHB;
       c8IHA: // global
           if (%MO_S_Gt_W64(56320, _s8IqR::I64)) goto c8IHq; else goto c8IHy;
       c8IHq: // global
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqR::I64,
                                                                            8));
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8IqR::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 2;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IHy: // global
           if (%MO_S_Gt_W64(_s8IqR::I64, 57343)) goto c8IHw; else goto c8IHx;
       c8IHw: // global
           I8[_s8IpP::I64 + _s8IqK::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8IqR::I64,
                                                                            8));
           call MO_Touch(_s8IpQ::P64);
           I8[_s8IpP::I64 + (_s8IqK::I64 + 1)] = %MO_UU_Conv_W64_W8(_s8IqR::I64);
           call MO_Touch(_s8IpQ::P64);
           _s8IqK::I64 = _s8IqK::I64 + 2;
           _s8IqJ::I64 = _s8IqJ::I64 + 1;
           goto c8IGx;
       c8IHx: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IEC() args: 0, res: 0, upd: 0;
       c8IHB: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IEY() args: 0, res: 0, upd: 0;
       c8IHG: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IFk() args: 0, res: 0, upd: 0;
       c8IHJ: // global
           P64[Sp - 48] = _s8IpQ::P64;
           P64[Sp - 40] = _s8IpR::P64;
           I64[Sp - 32] = _s8IpS::I64;
           I64[Sp - 24] = _s8IpT::I64;
           I64[Sp - 16] = _s8IqJ::I64;
           I64[Sp - 8] = _s8IqK::I64;
           I64[Sp] = _s8IpP::I64;
           P64[Sp + 24] = _c8IDR::P64;
           Sp = Sp - 56;
           call _c8IFG() args: 0, res: 0, upd: 0;
     }
 },
 _c8IDU() //  []
         { info_tbl: [(c8IDU,
                       label: block_c8IDU_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IDU: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGa; else goto c8IG9;
       c8IGa: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IDU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IG9: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iq1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IEg() //  []
         { info_tbl: [(c8IEg,
                       label: block_c8IEg_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IEg: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGe; else goto c8IGd;
       c8IGe: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IEg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGd: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iq9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IEC() //  []
         { info_tbl: [(c8IEC,
                       label: block_c8IEC_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IEC: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGi; else goto c8IGh;
       c8IGi: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IEC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGh: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iqh_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IEY() //  []
         { info_tbl: [(c8IEY,
                       label: block_c8IEY_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IEY: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGm; else goto c8IGl;
       c8IGm: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IEY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGl: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iqp_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IFk() //  []
         { info_tbl: [(c8IFk,
                       label: block_c8IFk_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IFk: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGq; else goto c8IGp;
       c8IGq: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IFk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGp: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iqx_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IFG() //  []
         { info_tbl: [(c8IFG,
                       label: block_c8IFG_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IFG: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IGu; else goto c8IGt;
       c8IGu: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IFG_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IGt: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IqF_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.654849237 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_encode_entry() //  [R2, R3]
         { info_tbl: [(c8IPc,
                       label: GHC.IO.Encoding.UTF16.utf16be_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IPc: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.663584875 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le1_info;
 },
 sat_s8IsQ_entry() //  [R1]
         { info_tbl: [(c8IPN,
                       label: sat_s8IsQ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IPN: // global
           _s8IsQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IPO; else goto c8IPP;
       c8IPP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IPR; else goto c8IPQ;
       c8IPR: // global
           HpAlloc = 56;
           goto c8IPO;
       c8IPO: // global
           R1 = _s8IsQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IPQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IsQ::P64;
           _s8IsC::I64 = I64[_s8IsQ::P64 + 56];
           _s8IsM::I64 = I64[_s8IsQ::P64 + 64];
           if (_s8IsM::I64 == _s8IsC::I64) goto c8IPM; else goto c8IPL;
       c8IPM: // global
           _s8IsK::P64 = P64[_s8IsQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IPL: // global
           _s8Isy::P64 = P64[_s8IsQ::P64 + 16];
           _s8Isz::P64 = P64[_s8IsQ::P64 + 24];
           _s8Isx::I64 = I64[_s8IsQ::P64 + 40];
           _s8IsA::I64 = I64[_s8IsQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8IsM::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IsY_entry() //  [R1]
         { info_tbl: [(c8IQ9,
                       label: sat_s8IsY_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IQ9: // global
           _s8IsY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IQa; else goto c8IQb;
       c8IQb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IQd; else goto c8IQc;
       c8IQd: // global
           HpAlloc = 56;
           goto c8IQa;
       c8IQa: // global
           R1 = _s8IsY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IQc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IsY::P64;
           _s8IsC::I64 = I64[_s8IsY::P64 + 56];
           _s8IsU::I64 = I64[_s8IsY::P64 + 64];
           if (_s8IsU::I64 == _s8IsC::I64) goto c8IQ8; else goto c8IQ7;
       c8IQ8: // global
           _s8IsK::P64 = P64[_s8IsY::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IQ7: // global
           _s8Isy::P64 = P64[_s8IsY::P64 + 16];
           _s8Isz::P64 = P64[_s8IsY::P64 + 24];
           _s8Isx::I64 = I64[_s8IsY::P64 + 40];
           _s8IsA::I64 = I64[_s8IsY::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8IsU::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8It6_entry() //  [R1]
         { info_tbl: [(c8IQv,
                       label: sat_s8It6_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IQv: // global
           _s8It6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IQw; else goto c8IQx;
       c8IQx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IQz; else goto c8IQy;
       c8IQz: // global
           HpAlloc = 56;
           goto c8IQw;
       c8IQw: // global
           R1 = _s8It6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IQy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8It6::P64;
           _s8IsC::I64 = I64[_s8It6::P64 + 56];
           _s8It2::I64 = I64[_s8It6::P64 + 64];
           if (_s8It2::I64 == _s8IsC::I64) goto c8IQu; else goto c8IQt;
       c8IQu: // global
           _s8IsK::P64 = P64[_s8It6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IQt: // global
           _s8Isy::P64 = P64[_s8It6::P64 + 16];
           _s8Isz::P64 = P64[_s8It6::P64 + 24];
           _s8Isx::I64 = I64[_s8It6::P64 + 40];
           _s8IsA::I64 = I64[_s8It6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8It2::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Ite_entry() //  [R1]
         { info_tbl: [(c8IQR,
                       label: sat_s8Ite_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IQR: // global
           _s8Ite::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IQS; else goto c8IQT;
       c8IQT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IQV; else goto c8IQU;
       c8IQV: // global
           HpAlloc = 56;
           goto c8IQS;
       c8IQS: // global
           R1 = _s8Ite::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IQU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Ite::P64;
           _s8IsC::I64 = I64[_s8Ite::P64 + 56];
           _s8Ita::I64 = I64[_s8Ite::P64 + 64];
           if (_s8Ita::I64 == _s8IsC::I64) goto c8IQQ; else goto c8IQP;
       c8IQQ: // global
           _s8IsK::P64 = P64[_s8Ite::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IQP: // global
           _s8Isy::P64 = P64[_s8Ite::P64 + 16];
           _s8Isz::P64 = P64[_s8Ite::P64 + 24];
           _s8Isx::I64 = I64[_s8Ite::P64 + 40];
           _s8IsA::I64 = I64[_s8Ite::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8Ita::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Itm_entry() //  [R1]
         { info_tbl: [(c8IRd,
                       label: sat_s8Itm_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IRd: // global
           _s8Itm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IRe; else goto c8IRf;
       c8IRf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IRh; else goto c8IRg;
       c8IRh: // global
           HpAlloc = 56;
           goto c8IRe;
       c8IRe: // global
           R1 = _s8Itm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IRg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Itm::P64;
           _s8IsC::I64 = I64[_s8Itm::P64 + 56];
           _s8Iti::I64 = I64[_s8Itm::P64 + 64];
           if (_s8Iti::I64 == _s8IsC::I64) goto c8IRc; else goto c8IRb;
       c8IRc: // global
           _s8IsK::P64 = P64[_s8Itm::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IRb: // global
           _s8Isy::P64 = P64[_s8Itm::P64 + 16];
           _s8Isz::P64 = P64[_s8Itm::P64 + 24];
           _s8Isx::I64 = I64[_s8Itm::P64 + 40];
           _s8IsA::I64 = I64[_s8Itm::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8Iti::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Itu_entry() //  [R1]
         { info_tbl: [(c8IRz,
                       label: sat_s8Itu_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IRz: // global
           _s8Itu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8IRA; else goto c8IRB;
       c8IRB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IRD; else goto c8IRC;
       c8IRD: // global
           HpAlloc = 56;
           goto c8IRA;
       c8IRA: // global
           R1 = _s8Itu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8IRC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Itu::P64;
           _s8IsC::I64 = I64[_s8Itu::P64 + 56];
           _s8Itq::I64 = I64[_s8Itu::P64 + 64];
           if (_s8Itq::I64 == _s8IsC::I64) goto c8IRy; else goto c8IRx;
       c8IRy: // global
           _s8IsK::P64 = P64[_s8Itu::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8IsK::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8IRx: // global
           _s8Isy::P64 = P64[_s8Itu::P64 + 16];
           _s8Isz::P64 = P64[_s8Itu::P64 + 24];
           _s8Isx::I64 = I64[_s8Itu::P64 + 40];
           _s8IsA::I64 = I64[_s8Itu::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = _s8Isz::P64;
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = _s8IsA::I64;
           I64[Hp - 8] = _s8Itq::I64;
           I64[Hp] = _s8IsC::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16le1_entry() //  [R2, R3]
         { info_tbl: [(c8IRG,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IRG: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8IRH; else goto c8IRI;
       c8IRH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8IRI: // global
           I64[Sp - 16] = block_c8IPn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8IWO; else goto c8IPo;
       u8IWO: // global
           call _c8IPn(R1) args: 0, res: 0, upd: 0;
       c8IPo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8IPn() //  [R1]
         { info_tbl: [(c8IPn,
                       label: block_c8IPn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IPn: // global
           I64[Sp - 40] = block_c8IPs_info;
           _s8Isy::P64 = P64[R1 + 7];
           _s8Isz::P64 = P64[R1 + 15];
           _s8Isx::I64 = I64[R1 + 23];
           _s8IsA::I64 = I64[R1 + 31];
           _s8IsB::I64 = I64[R1 + 39];
           _s8IsC::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Isz::P64;
           I64[Sp - 24] = _s8IsA::I64;
           I64[Sp - 16] = _s8IsB::I64;
           I64[Sp - 8] = _s8IsC::I64;
           P64[Sp] = _s8Isy::P64;
           I64[Sp + 8] = _s8Isx::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8IWH; else goto c8IPt;
       u8IWH: // global
           call _c8IPs(R1) args: 0, res: 0, upd: 0;
       c8IPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8IPs() //  [R1]
         { info_tbl: [(c8IPs,
                       label: block_c8IPs_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IPs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IRM; else goto c8IRL;
       c8IRM: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8IRL: // global
           _s8IsF::P64 = P64[R1 + 7];
           _s8IsG::P64 = P64[R1 + 15];
           _s8IsE::I64 = I64[R1 + 23];
           _s8IsH::I64 = I64[R1 + 31];
           _s8IsI::I64 = I64[R1 + 39];
           _s8IsJ::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Isy::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Isy::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Isx::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Isx::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8IsC::I64 = I64[Sp + 32];
           _c8IPx::P64 = Hp - 47;
           _s8Itz::I64 = _s8IsJ::I64;
           _s8Ity::I64 = I64[Sp + 24];
           goto c8ISd;
       c8ISd: // global
           if (%MO_S_Lt_W64(_s8Ity::I64,
                            _s8IsC::I64)) goto c8ITo; else goto c8ITp;
       c8ITo: // global
           if (%MO_S_Ge_W64(_s8IsH::I64 - _s8Itz::I64,
                            2)) goto c8ITl; else goto c8ITm;
       c8ITl: // global
           _s8ItG::I64 = %MO_UU_Conv_W32_W64(I32[_s8Isx::I64 + (_s8Ity::I64 << 2)]);
           call MO_Touch(_s8Isy::P64);
           if (%MO_S_Ge_W64(_s8ItG::I64, 65536)) goto c8ISG; else goto c8ITj;
       c8ISG: // global
           if (%MO_S_Ge_W64(_s8IsH::I64 - _s8Itz::I64,
                            4)) goto c8ISD; else goto c8ISE;
       c8ISD: // global
           _s8ItM::I64 = _s8ItG::I64 - 65536;
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItM::I64,
                                                                            10));
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItM::I64,
                                                                                  18) + 216);
           call MO_Touch(_s8IsF::P64);
           _s8Iu1::I64 = _s8ItM::I64 & 1023;
           I8[_s8IsE::I64 + (_s8Itz::I64 + 2)] = %MO_UU_Conv_W64_W8(_s8Iu1::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 3)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8Iu1::I64,
                                                                                  8) + 220);
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 4;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ISE: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IPA() args: 0, res: 0, upd: 0;
       c8ITj: // global
           if (%MO_S_Gt_W64(55296, _s8ItG::I64)) goto c8ISY; else goto c8ITi;
       c8ISY: // global
           if (%MO_S_Gt_W64(56320, _s8ItG::I64)) goto c8ISO; else goto c8ISW;
       c8ISO: // global
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(_s8ItG::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItG::I64,
                                                                                  8));
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 2;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ISW: // global
           if (%MO_S_Gt_W64(_s8ItG::I64, 57343)) goto c8ISU; else goto c8ISV;
       c8ISU: // global
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(_s8ItG::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItG::I64,
                                                                                  8));
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 2;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ISV: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IPW() args: 0, res: 0, upd: 0;
       c8ITi: // global
           if (%MO_S_Gt_W64(_s8ItG::I64, 56319)) goto c8ITg; else goto c8ITh;
       c8ITg: // global
           if (%MO_S_Gt_W64(56320, _s8ItG::I64)) goto c8IT6; else goto c8ITe;
       c8IT6: // global
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(_s8ItG::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItG::I64,
                                                                                  8));
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 2;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ITe: // global
           if (%MO_S_Gt_W64(_s8ItG::I64, 57343)) goto c8ITc; else goto c8ITd;
       c8ITc: // global
           I8[_s8IsE::I64 + _s8Itz::I64] = %MO_UU_Conv_W64_W8(_s8ItG::I64);
           call MO_Touch(_s8IsF::P64);
           I8[_s8IsE::I64 + (_s8Itz::I64 + 1)] = %MO_UU_Conv_W64_W8(%MO_S_Shr_W64(_s8ItG::I64,
                                                                                  8));
           call MO_Touch(_s8IsF::P64);
           _s8Itz::I64 = _s8Itz::I64 + 2;
           _s8Ity::I64 = _s8Ity::I64 + 1;
           goto c8ISd;
       c8ITd: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IQi() args: 0, res: 0, upd: 0;
       c8ITh: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IQE() args: 0, res: 0, upd: 0;
       c8ITm: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IR0() args: 0, res: 0, upd: 0;
       c8ITp: // global
           P64[Sp - 48] = _s8IsF::P64;
           P64[Sp - 40] = _s8IsG::P64;
           I64[Sp - 32] = _s8IsH::I64;
           I64[Sp - 24] = _s8IsI::I64;
           I64[Sp - 16] = _s8Ity::I64;
           I64[Sp - 8] = _s8Itz::I64;
           I64[Sp] = _s8IsE::I64;
           P64[Sp + 24] = _c8IPx::P64;
           Sp = Sp - 56;
           call _c8IRm() args: 0, res: 0, upd: 0;
     }
 },
 _c8IPA() //  []
         { info_tbl: [(c8IPA,
                       label: block_c8IPA_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IPA: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IRQ; else goto c8IRP;
       c8IRQ: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IPA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IRP: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IsQ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IPW() //  []
         { info_tbl: [(c8IPW,
                       label: block_c8IPW_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IPW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IRU; else goto c8IRT;
       c8IRU: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IPW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IRT: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IsY_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IQi() //  []
         { info_tbl: [(c8IQi,
                       label: block_c8IQi_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IQi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IRY; else goto c8IRX;
       c8IRY: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IQi_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IRX: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8It6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IQE() //  []
         { info_tbl: [(c8IQE,
                       label: block_c8IQE_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IQE: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IS2; else goto c8IS1;
       c8IS2: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IQE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IS1: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Ite_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IR0() //  []
         { info_tbl: [(c8IR0,
                       label: block_c8IR0_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IR0: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8IS6; else goto c8IS5;
       c8IS6: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IR0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IS5: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Itm_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8IRm() //  []
         { info_tbl: [(c8IRm,
                       label: block_c8IRm_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IRm: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8ISa; else goto c8IS9;
       c8ISa: // global
           HpAlloc = 160;
           I64[Sp] = block_c8IRm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8IS9: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Itu_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.71055796 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_encode_entry() //  [R2, R3]
         { info_tbl: [(c8J0S,
                       label: GHC.IO.Encoding.UTF16.utf16le_encode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J0S: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF16le1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.714093074 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule4_bytes" {
     GHC.IO.Encoding.UTF16.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.715776109 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule3_closure" {
     GHC.IO.Encoding.UTF16.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.717501356 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.$trModule2_bytes" {
     GHC.IO.Encoding.UTF16.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,69,110,99,111,100,105,110,103,46,85,84,70,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.719213315 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule1_closure" {
     GHC.IO.Encoding.UTF16.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Encoding.UTF16.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.720944837 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$trModule_closure" {
     GHC.IO.Encoding.UTF16.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Encoding.UTF16.$trModule3_closure+1;
         const GHC.IO.Encoding.UTF16.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.724040444 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_encode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_encode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J15: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_encode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8J1g,
                       label: GHC.IO.Encoding.UTF16.$wutf16_encode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, True, False, False, True, True,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J1g: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8J1h; else goto c8J1i;
       c8J1h: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_encode_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8J1i: // global
           I64[Sp - 48] = block_c8J19_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           I64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8J1Y; else goto c8J1a;
       u8J1Y: // global
           call _c8J19(R1) args: 0, res: 0, upd: 0;
       c8J1a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8J19() //  [R1]
         { info_tbl: [(c8J19,
                       label: block_c8J19_info
                       rep:StackRep [False, False, True, False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J19: // global
           _s8Ivj::P64 = P64[Sp + 16];
           _s8Ivk::I64 = I64[Sp + 24];
           _s8Ivl::P64 = P64[Sp + 32];
           _s8Ivm::P64 = P64[Sp + 40];
           _s8Ivn::I64 = I64[Sp + 48];
           _s8Ivo::I64 = I64[Sp + 56];
           _s8Ivp::I64 = I64[Sp + 64];
           if (R1 & 7 == 1) goto c8J1d; else goto c8J1e;
       c8J1d: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8J1n; else goto c8J1m;
       c8J1n: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8J1m: // global
           if (%MO_S_Ge_W64(_s8Ivn::I64 - _s8Ivp::I64,
                            2)) goto c8J1N; else goto c8J1R;
       c8J1N: // global
           _s8Ivi::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_s8Ivi::P64 + 8] = GHC.Types.True_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8Ivi::P64);
           I8[_s8Ivk::I64 + _s8Ivp::I64] = 254 :: W8;
           call MO_Touch(_s8Ivl::P64);
           I8[_s8Ivk::I64 + (_s8Ivp::I64 + 1)] = 255 :: W8;
           call MO_Touch(_s8Ivl::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Ivl::P64;
           P64[Hp - 64] = _s8Ivm::P64;
           I64[Hp - 56] = _s8Ivk::I64;
           I64[Hp - 48] = _s8Ivn::I64;
           I64[Hp - 40] = _s8Ivo::I64;
           I64[Hp - 32] = _s8Ivp::I64 + 2;
           _c8J1L::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _c8J1L::P64;
           R2 = _s8Ivj::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8J1R: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8Ivl::P64;
           P64[Hp - 64] = _s8Ivm::P64;
           I64[Hp - 56] = _s8Ivk::I64;
           I64[Hp - 48] = _s8Ivn::I64;
           I64[Hp - 40] = _s8Ivo::I64;
           I64[Hp - 32] = _s8Ivp::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = _s8Ivj::P64;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8J1e: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J1X; else goto c8J1W;
       c8J1X: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8J1W: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Ivl::P64;
           P64[Hp - 32] = _s8Ivm::P64;
           I64[Hp - 24] = _s8Ivk::I64;
           I64[Hp - 16] = _s8Ivn::I64;
           I64[Hp - 8] = _s8Ivo::I64;
           I64[Hp] = _s8Ivp::I64;
           R3 = Hp - 47;
           R2 = _s8Ivj::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.735109747 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8J2z,
                       label: GHC.IO.Encoding.UTF16.utf16_encode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J2z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8J2D; else goto c8J2E;
       c8J2D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_encode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8J2E: // global
           I64[Sp - 24] = block_c8J2w_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8J2M; else goto c8J2x;
       u8J2M: // global
           call _c8J2w(R1) args: 0, res: 0, upd: 0;
       c8J2x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8J2w() //  [R1]
         { info_tbl: [(c8J2w,
                       label: block_c8J2w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J2w: // global
           I64[Sp] = block_c8J2C_info;
           _s8IvP::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8IvP::P64;
           if (R1 & 7 != 0) goto u8J2L; else goto c8J2G;
       u8J2L: // global
           call _c8J2C(R1) args: 0, res: 0, upd: 0;
       c8J2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8J2C() //  [R1]
         { info_tbl: [(c8J2C,
                       label: block_c8J2C_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J2C: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.742947111 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_encode_closure" {
     GHC.IO.Encoding.UTF16.utf16_encode_closure:
         const GHC.IO.Encoding.UTF16.utf16_encode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_encode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8J39,
                       label: GHC.IO.Encoding.UTF16.utf16_encode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J39: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_encode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.7525615 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF3_closure" {
     GHC.IO.Encoding.UTF16.mkUTF3_closure:
         const GHC.IO.Encoding.UTF16.mkUTF3_info;
 },
 sat_s8Iwk_entry() //  [R1]
         { info_tbl: [(c8J3K,
                       label: sat_s8Iwk_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J3K: // global
           _s8Iwk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J3L; else goto c8J3M;
       c8J3M: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J3O; else goto c8J3N;
       c8J3O: // global
           HpAlloc = 56;
           goto c8J3L;
       c8J3L: // global
           R1 = _s8Iwk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J3N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iwk::P64;
           _s8Iw6::I64 = I64[_s8Iwk::P64 + 56];
           _s8Iwg::I64 = I64[_s8Iwk::P64 + 64];
           if (_s8Iwg::I64 == _s8Iw6::I64) goto c8J3J; else goto c8J3I;
       c8J3J: // global
           _s8Iwe::P64 = P64[_s8Iwk::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J3I: // global
           _s8Iw2::P64 = P64[_s8Iwk::P64 + 16];
           _s8Iw3::P64 = P64[_s8Iwk::P64 + 24];
           _s8Iw1::I64 = I64[_s8Iwk::P64 + 40];
           _s8Iw4::I64 = I64[_s8Iwk::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Iwg::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Iws_entry() //  [R1]
         { info_tbl: [(c8J46,
                       label: sat_s8Iws_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J46: // global
           _s8Iws::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J47; else goto c8J48;
       c8J48: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J4a; else goto c8J49;
       c8J4a: // global
           HpAlloc = 56;
           goto c8J47;
       c8J47: // global
           R1 = _s8Iws::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J49: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Iws::P64;
           _s8Iw6::I64 = I64[_s8Iws::P64 + 56];
           _s8Iwo::I64 = I64[_s8Iws::P64 + 64];
           if (_s8Iwo::I64 == _s8Iw6::I64) goto c8J45; else goto c8J44;
       c8J45: // global
           _s8Iwe::P64 = P64[_s8Iws::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J44: // global
           _s8Iw2::P64 = P64[_s8Iws::P64 + 16];
           _s8Iw3::P64 = P64[_s8Iws::P64 + 24];
           _s8Iw1::I64 = I64[_s8Iws::P64 + 40];
           _s8Iw4::I64 = I64[_s8Iws::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Iwo::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IwA_entry() //  [R1]
         { info_tbl: [(c8J4s,
                       label: sat_s8IwA_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J4s: // global
           _s8IwA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J4t; else goto c8J4u;
       c8J4u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J4w; else goto c8J4v;
       c8J4w: // global
           HpAlloc = 56;
           goto c8J4t;
       c8J4t: // global
           R1 = _s8IwA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J4v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IwA::P64;
           _s8Iw6::I64 = I64[_s8IwA::P64 + 56];
           _s8Iww::I64 = I64[_s8IwA::P64 + 64];
           if (_s8Iww::I64 == _s8Iw6::I64) goto c8J4r; else goto c8J4q;
       c8J4r: // global
           _s8Iwe::P64 = P64[_s8IwA::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J4q: // global
           _s8Iw2::P64 = P64[_s8IwA::P64 + 16];
           _s8Iw3::P64 = P64[_s8IwA::P64 + 24];
           _s8Iw1::I64 = I64[_s8IwA::P64 + 40];
           _s8Iw4::I64 = I64[_s8IwA::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Iww::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IwI_entry() //  [R1]
         { info_tbl: [(c8J4O,
                       label: sat_s8IwI_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J4O: // global
           _s8IwI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J4P; else goto c8J4Q;
       c8J4Q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J4S; else goto c8J4R;
       c8J4S: // global
           HpAlloc = 56;
           goto c8J4P;
       c8J4P: // global
           R1 = _s8IwI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J4R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IwI::P64;
           _s8Iw6::I64 = I64[_s8IwI::P64 + 56];
           _s8IwE::I64 = I64[_s8IwI::P64 + 64];
           if (_s8IwE::I64 == _s8Iw6::I64) goto c8J4N; else goto c8J4M;
       c8J4N: // global
           _s8Iwe::P64 = P64[_s8IwI::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J4M: // global
           _s8Iw2::P64 = P64[_s8IwI::P64 + 16];
           _s8Iw3::P64 = P64[_s8IwI::P64 + 24];
           _s8Iw1::I64 = I64[_s8IwI::P64 + 40];
           _s8Iw4::I64 = I64[_s8IwI::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8IwE::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IwQ_entry() //  [R1]
         { info_tbl: [(c8J5a,
                       label: sat_s8IwQ_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J5a: // global
           _s8IwQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J5b; else goto c8J5c;
       c8J5c: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J5e; else goto c8J5d;
       c8J5e: // global
           HpAlloc = 56;
           goto c8J5b;
       c8J5b: // global
           R1 = _s8IwQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J5d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IwQ::P64;
           _s8Iw6::I64 = I64[_s8IwQ::P64 + 56];
           _s8IwM::I64 = I64[_s8IwQ::P64 + 64];
           if (_s8IwM::I64 == _s8Iw6::I64) goto c8J59; else goto c8J58;
       c8J59: // global
           _s8Iwe::P64 = P64[_s8IwQ::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J58: // global
           _s8Iw2::P64 = P64[_s8IwQ::P64 + 16];
           _s8Iw3::P64 = P64[_s8IwQ::P64 + 24];
           _s8Iw1::I64 = I64[_s8IwQ::P64 + 40];
           _s8Iw4::I64 = I64[_s8IwQ::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8IwM::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IwY_entry() //  [R1]
         { info_tbl: [(c8J5w,
                       label: sat_s8IwY_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J5w: // global
           _s8IwY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J5x; else goto c8J5y;
       c8J5y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J5A; else goto c8J5z;
       c8J5A: // global
           HpAlloc = 56;
           goto c8J5x;
       c8J5x: // global
           R1 = _s8IwY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J5z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IwY::P64;
           _s8Iw6::I64 = I64[_s8IwY::P64 + 56];
           _s8IwU::I64 = I64[_s8IwY::P64 + 64];
           if (_s8IwU::I64 == _s8Iw6::I64) goto c8J5v; else goto c8J5u;
       c8J5v: // global
           _s8Iwe::P64 = P64[_s8IwY::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J5u: // global
           _s8Iw2::P64 = P64[_s8IwY::P64 + 16];
           _s8Iw3::P64 = P64[_s8IwY::P64 + 24];
           _s8Iw1::I64 = I64[_s8IwY::P64 + 40];
           _s8Iw4::I64 = I64[_s8IwY::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8IwU::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Ix6_entry() //  [R1]
         { info_tbl: [(c8J5S,
                       label: sat_s8Ix6_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J5S: // global
           _s8Ix6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J5T; else goto c8J5U;
       c8J5U: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J5W; else goto c8J5V;
       c8J5W: // global
           HpAlloc = 56;
           goto c8J5T;
       c8J5T: // global
           R1 = _s8Ix6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J5V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Ix6::P64;
           _s8Iw6::I64 = I64[_s8Ix6::P64 + 56];
           _s8Ix2::I64 = I64[_s8Ix6::P64 + 64];
           if (_s8Ix2::I64 == _s8Iw6::I64) goto c8J5R; else goto c8J5Q;
       c8J5R: // global
           _s8Iwe::P64 = P64[_s8Ix6::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J5Q: // global
           _s8Iw2::P64 = P64[_s8Ix6::P64 + 16];
           _s8Iw3::P64 = P64[_s8Ix6::P64 + 24];
           _s8Iw1::I64 = I64[_s8Ix6::P64 + 40];
           _s8Iw4::I64 = I64[_s8Ix6::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Ix2::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Ixe_entry() //  [R1]
         { info_tbl: [(c8J6e,
                       label: sat_s8Ixe_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J6e: // global
           _s8Ixe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8J6f; else goto c8J6g;
       c8J6g: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J6i; else goto c8J6h;
       c8J6i: // global
           HpAlloc = 56;
           goto c8J6f;
       c8J6f: // global
           R1 = _s8Ixe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8J6h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Ixe::P64;
           _s8Iw6::I64 = I64[_s8Ixe::P64 + 56];
           _s8Ixa::I64 = I64[_s8Ixe::P64 + 64];
           if (_s8Ixa::I64 == _s8Iw6::I64) goto c8J6d; else goto c8J6c;
       c8J6d: // global
           _s8Iwe::P64 = P64[_s8Ixe::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Iwe::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8J6c: // global
           _s8Iw2::P64 = P64[_s8Ixe::P64 + 16];
           _s8Iw3::P64 = P64[_s8Ixe::P64 + 24];
           _s8Iw1::I64 = I64[_s8Ixe::P64 + 40];
           _s8Iw4::I64 = I64[_s8Ixe::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = _s8Iw3::P64;
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = _s8Iw4::I64;
           I64[Hp - 8] = _s8Ixa::I64;
           I64[Hp] = _s8Iw6::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF3_entry() //  [R2, R3]
         { info_tbl: [(c8J6l,
                       label: GHC.IO.Encoding.UTF16.mkUTF3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J6l: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8J6m; else goto c8J6n;
       c8J6m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8J6n: // global
           I64[Sp - 16] = block_c8J3k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Ja7; else goto c8J3l;
       u8Ja7: // global
           call _c8J3k(R1) args: 0, res: 0, upd: 0;
       c8J3l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8J3k() //  [R1]
         { info_tbl: [(c8J3k,
                       label: block_c8J3k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J3k: // global
           I64[Sp - 40] = block_c8J3p_info;
           _s8Iw2::P64 = P64[R1 + 7];
           _s8Iw3::P64 = P64[R1 + 15];
           _s8Iw1::I64 = I64[R1 + 23];
           _s8Iw4::I64 = I64[R1 + 31];
           _s8Iw5::I64 = I64[R1 + 39];
           _s8Iw6::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Iw3::P64;
           I64[Sp - 24] = _s8Iw4::I64;
           I64[Sp - 16] = _s8Iw5::I64;
           I64[Sp - 8] = _s8Iw6::I64;
           P64[Sp] = _s8Iw2::P64;
           I64[Sp + 8] = _s8Iw1::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8J9Y; else goto c8J3q;
       u8J9Y: // global
           call _c8J3p(R1) args: 0, res: 0, upd: 0;
       c8J3q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8J3p() //  [R1]
         { info_tbl: [(c8J3p,
                       label: block_c8J3p_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J3p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8J6r; else goto c8J6q;
       c8J6r: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8J6q: // global
           _s8Iw9::P64 = P64[R1 + 7];
           _s8Iwa::P64 = P64[R1 + 15];
           _s8Iw8::I64 = I64[R1 + 23];
           _s8Iwb::I64 = I64[R1 + 31];
           _s8Iwc::I64 = I64[R1 + 39];
           _s8Iwd::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Iw2::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Iw2::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Iw1::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Iw1::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Iw6::I64 = I64[Sp + 32];
           _c8J3u::P64 = Hp - 47;
           _s8Ixj::I64 = _s8Iwd::I64;
           _s8Ixi::I64 = I64[Sp + 24];
           goto c8J70;
       c8J70: // global
           if (%MO_S_Lt_W64(_s8Ixj::I64,
                            _s8Iwb::I64)) goto c8J8V; else goto c8J8W;
       c8J8V: // global
           if (%MO_S_Lt_W64(_s8Ixi::I64,
                            _s8Iw6::I64)) goto c8J8S; else goto c8J8T;
       c8J8S: // global
           if ((_s8Ixi::I64 + 1) == _s8Iw6::I64) goto c8J8Q; else goto c8J8P;
       c8J8Q: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J5j() args: 0, res: 0, upd: 0;
       c8J8P: // global
           _s8Ixs::I64 = %MO_UU_Conv_W8_W64(I8[_s8Iw1::I64 + _s8Ixi::I64]);
           call MO_Touch(_s8Iw2::P64);
           _s8Ixy::I64 = %MO_UU_Conv_W8_W64(I8[_s8Iw1::I64 + (_s8Ixi::I64 + 1)]);
           call MO_Touch(_s8Iw2::P64);
           _s8IxA::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8Ixy::I64 << 8)) + _s8Ixs::I64));
           if (_s8IxA::I64 >= 55296) goto c8J8M; else goto c8J8N;
       c8J8M: // global
           if (_s8IxA::I64 <= 57343) goto c8J8J; else goto c8J8K;
       c8J8J: // global
           if (%MO_S_Ge_W64(_s8Iw6::I64 - _s8Ixi::I64,
                            4)) goto c8J8G; else goto c8J8H;
       c8J8G: // global
           _s8IxM::I64 = %MO_UU_Conv_W8_W64(I8[_s8Iw1::I64 + (_s8Ixi::I64 + 2)]);
           call MO_Touch(_s8Iw2::P64);
           _s8IxS::I64 = %MO_UU_Conv_W8_W64(I8[_s8Iw1::I64 + (_s8Ixi::I64 + 3)]);
           call MO_Touch(_s8Iw2::P64);
           if (_s8IxA::I64 < 55296) goto c8J86; else goto c8J8E;
       c8J86: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J3x() args: 0, res: 0, upd: 0;
       c8J8E: // global
           if (_s8IxA::I64 > 56319) goto c8J8c; else goto c8J8D;
       c8J8c: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J3T() args: 0, res: 0, upd: 0;
       c8J8D: // global
           _s8IxW::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8IxS::I64 << 8)) + _s8IxM::I64));
           if (_s8IxW::I64 < 56320) goto c8J8u; else goto c8J8C;
       c8J8u: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J4f() args: 0, res: 0, upd: 0;
       c8J8C: // global
           if (_s8IxW::I64 > 57343) goto c8J8A; else goto c8J8B;
       c8J8A: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J4B() args: 0, res: 0, upd: 0;
       c8J8B: // global
           I32[_s8Iw8::I64 + (_s8Ixj::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8IxA::I64 + -55296) << 10) + (_s8IxW::I64 + -56320) + 65536);
           call MO_Touch(_s8Iw9::P64);
           _s8Ixj::I64 = _s8Ixj::I64 + 1;
           _s8Ixi::I64 = _s8Ixi::I64 + 4;
           goto c8J70;
       c8J8H: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J4X() args: 0, res: 0, upd: 0;
       c8J8K: // global
           I32[_s8Iw8::I64 + (_s8Ixj::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8IxA::I64);
           call MO_Touch(_s8Iw9::P64);
           _s8Ixj::I64 = _s8Ixj::I64 + 1;
           _s8Ixi::I64 = _s8Ixi::I64 + 2;
           goto c8J70;
       c8J8N: // global
           I32[_s8Iw8::I64 + (_s8Ixj::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8IxA::I64);
           call MO_Touch(_s8Iw9::P64);
           _s8Ixj::I64 = _s8Ixj::I64 + 1;
           _s8Ixi::I64 = _s8Ixi::I64 + 2;
           goto c8J70;
       c8J8T: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J5F() args: 0, res: 0, upd: 0;
       c8J8W: // global
           P64[Sp - 48] = _s8Iw9::P64;
           P64[Sp - 40] = _s8Iwa::P64;
           I64[Sp - 32] = _s8Iwb::I64;
           I64[Sp - 24] = _s8Iwc::I64;
           I64[Sp - 16] = _s8Ixi::I64;
           I64[Sp - 8] = _s8Ixj::I64;
           I64[Sp] = _s8Iw8::I64;
           P64[Sp + 24] = _c8J3u::P64;
           Sp = Sp - 56;
           call _c8J61() args: 0, res: 0, upd: 0;
     }
 },
 _c8J5j() //  []
         { info_tbl: [(c8J5j,
                       label: block_c8J5j_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J5j: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6P; else goto c8J6O;
       c8J6P: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J5j_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6O: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IwY_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8J3x() //  []
         { info_tbl: [(c8J3x,
                       label: block_c8J3x_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J3x: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6v; else goto c8J6u;
       c8J6v: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J3x_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6u: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iwk_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8J3T() //  []
         { info_tbl: [(c8J3T,
                       label: block_c8J3T_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J3T: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6z; else goto c8J6y;
       c8J6z: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J3T_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6y: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Iws_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8J4f() //  []
         { info_tbl: [(c8J4f,
                       label: block_c8J4f_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J4f: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6D; else goto c8J6C;
       c8J6D: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J4f_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6C: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IwA_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8J4B() //  []
         { info_tbl: [(c8J4B,
                       label: block_c8J4B_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J4B: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6H; else goto c8J6G;
       c8J6H: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J4B_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6G: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IwI_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8J4X() //  []
         { info_tbl: [(c8J4X,
                       label: block_c8J4X_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J4X: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6L; else goto c8J6K;
       c8J6L: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J4X_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6K: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IwQ_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8J5F() //  []
         { info_tbl: [(c8J5F,
                       label: block_c8J5F_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J5F: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6T; else goto c8J6S;
       c8J6T: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J5F_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6S: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Ix6_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8J61() //  []
         { info_tbl: [(c8J61,
                       label: block_c8J61_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J61: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8J6X; else goto c8J6W;
       c8J6X: // global
           HpAlloc = 160;
           I64[Sp] = block_c8J61_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8J6W: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8Ixe_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.812554725 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16le_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16le_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16le_decode_entry() //  [R2, R3]
         { info_tbl: [(c8Jf3,
                       label: GHC.IO.Encoding.UTF16.utf16le_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jf3: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.815768114 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16le3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16le3_bytes:
         I8[] [85,84,70,49,54,45,76,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.817689371 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16le2_entry() //  [R1]
         { info_tbl: [(c8Jfh,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jfh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jfi; else goto c8Jfj;
       c8Jfi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jfj: // global
           (_c8Jfe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Jfe::I64 == 0) goto c8Jfg; else goto c8Jff;
       c8Jfg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Jff: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Jfe::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16le3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.822517578 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF2_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF2_entry() //  []
         { info_tbl: [(c8Jfw,
                       label: GHC.IO.Encoding.UTF16.mkUTF2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jfw: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.825933326 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be1_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be1_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be1_info;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be1_entry() //  []
         { info_tbl: [(c8JfJ,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JfJ: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.83028533 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16le_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16le_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16le_info;
         const 0;
 },
 sat_s8Iyz_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Jg6,
                       label: sat_s8Iyz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jg6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8IyB_entry() //  [R1]
         { info_tbl: [(c8Jga,
                       label: sat_s8IyB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jga: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Jge; else goto c8Jgd;
       c8Jge: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Jgd: // global
           _s8Iyt::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Iyz_info;
           P64[Hp - 48] = _s8Iyt::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Iyv_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Jgp,
                       label: sat_s8Iyv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jgp: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Iyx_entry() //  [R1]
         { info_tbl: [(c8Jgt,
                       label: sat_s8Iyx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jgt: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Jgx; else goto c8Jgw;
       c8Jgx: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Jgw: // global
           _s8Iyt::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8Iyv_info;
           P64[Hp - 48] = _s8Iyt::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16le_entry() //  [R2]
         { info_tbl: [(c8Jgz,
                       label: GHC.IO.Encoding.UTF16.mkUTF16le_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jgz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8JgD; else goto c8JgC;
       c8JgD: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16le_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8JgC: // global
           I64[Hp - 56] = sat_s8IyB_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8Iyx_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.842954001 UTC

[section ""data" . lvl_r8G1B_closure" {
     lvl_r8G1B_closure:
         const lvl_r8G1B_info;
         const 0;
 },
 lvl_r8G1B_entry() //  [R2, R3]
         { info_tbl: [(c8Jhp,
                       label: lvl_r8G1B_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jhp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jht; else goto c8Jhu;
       c8Jht: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_r8G1B_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Jhu: // global
           I64[Sp - 16] = block_c8Jhm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8JhC; else goto c8Jhn;
       u8JhC: // global
           call _c8Jhm() args: 0, res: 0, upd: 0;
       c8Jhn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jhm() //  []
         { info_tbl: [(c8Jhm,
                       label: block_c8Jhm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jhm: // global
           _s8IyD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Jhs_info;
           R1 = _s8IyD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8JhB; else goto c8Jhw;
       u8JhB: // global
           call _c8Jhs() args: 0, res: 0, upd: 0;
       c8Jhw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jhs() //  []
         { info_tbl: [(c8Jhs,
                       label: block_c8Jhs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jhs: // global
           R1 = GHC.IO.Encoding.Failure.recoverDecode2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.849887127 UTC

[section ""data" . lvl1_r8G1C_closure" {
     lvl1_r8G1C_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.851881503 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le2_closure" {
     GHC.IO.Encoding.UTF16.utf16le2_closure:
         const GHC.IO.Encoding.UTF16.utf16le2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le2_entry() //  []
         { info_tbl: [(c8JhX,
                       label: GHC.IO.Encoding.UTF16.utf16le2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JhX: // global
           R1 = lvl1_r8G1C_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.855716563 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be2_closure" {
     GHC.IO.Encoding.UTF16.utf16be2_closure:
         const GHC.IO.Encoding.UTF16.utf16be2_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be2_entry() //  [R2, R3]
         { info_tbl: [(c8Jic,
                       label: GHC.IO.Encoding.UTF16.utf16be2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jic: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Jig; else goto c8Jih;
       c8Jig: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16be2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Jih: // global
           I64[Sp - 16] = block_c8Ji9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Jiq; else goto c8Jia;
       u8Jiq: // global
           call _c8Ji9(R1) args: 0, res: 0, upd: 0;
       c8Jia: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ji9() //  [R1]
         { info_tbl: [(c8Ji9,
                       label: block_c8Ji9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ji9: // global
           I64[Sp - 16] = block_c8Jif_info;
           _s8IyZ::P64 = P64[R1 + 7];
           _s8IyY::I64 = I64[R1 + 23];
           _s8Iz2::I64 = I64[R1 + 39];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s8Iz2::I64;
           P64[Sp] = _s8IyZ::P64;
           I64[Sp + 8] = _s8IyY::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Jip; else goto c8Jij;
       u8Jip: // global
           call _c8Jif() args: 0, res: 0, upd: 0;
       c8Jij: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jif() //  []
         { info_tbl: [(c8Jif,
                       label: block_c8Jif_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jif: // global
           call MO_Touch(P64[Sp + 16]);
           R1 = GHC.IO.Encoding.Failure.recoverEncode2_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.86333687 UTC

[section ""data" . lvl2_r8G1D_closure" {
     lvl2_r8G1D_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.865349742 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le1_closure" {
     GHC.IO.Encoding.UTF16.utf16le1_closure:
         const GHC.IO.Encoding.UTF16.utf16le1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16le1_entry() //  []
         { info_tbl: [(c8JiL,
                       label: GHC.IO.Encoding.UTF16.utf16le1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JiL: // global
           R1 = lvl2_r8G1D_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.868698953 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16le_closure" {
     GHC.IO.Encoding.UTF16.utf16le_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.UTF16.utf16le2_closure+1;
         const GHC.IO.Encoding.UTF16.utf16le1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.877130549 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF5_closure" {
     GHC.IO.Encoding.UTF16.mkUTF5_closure:
         const GHC.IO.Encoding.UTF16.mkUTF5_info;
 },
 sat_s8IzD_entry() //  [R1]
         { info_tbl: [(c8Jjo,
                       label: sat_s8IzD_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jjo: // global
           _s8IzD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jjp; else goto c8Jjq;
       c8Jjq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jjs; else goto c8Jjr;
       c8Jjs: // global
           HpAlloc = 56;
           goto c8Jjp;
       c8Jjp: // global
           R1 = _s8IzD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jjr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IzD::P64;
           _s8Izp::I64 = I64[_s8IzD::P64 + 56];
           _s8Izz::I64 = I64[_s8IzD::P64 + 64];
           if (_s8Izz::I64 == _s8Izp::I64) goto c8Jjn; else goto c8Jjm;
       c8Jjn: // global
           _s8Izx::P64 = P64[_s8IzD::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jjm: // global
           _s8Izl::P64 = P64[_s8IzD::P64 + 16];
           _s8Izm::P64 = P64[_s8IzD::P64 + 24];
           _s8Izk::I64 = I64[_s8IzD::P64 + 40];
           _s8Izn::I64 = I64[_s8IzD::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8Izz::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IzL_entry() //  [R1]
         { info_tbl: [(c8JjK,
                       label: sat_s8IzL_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JjK: // global
           _s8IzL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8JjL; else goto c8JjM;
       c8JjM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JjO; else goto c8JjN;
       c8JjO: // global
           HpAlloc = 56;
           goto c8JjL;
       c8JjL: // global
           R1 = _s8IzL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JjN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IzL::P64;
           _s8Izp::I64 = I64[_s8IzL::P64 + 56];
           _s8IzH::I64 = I64[_s8IzL::P64 + 64];
           if (_s8IzH::I64 == _s8Izp::I64) goto c8JjJ; else goto c8JjI;
       c8JjJ: // global
           _s8Izx::P64 = P64[_s8IzL::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8JjI: // global
           _s8Izl::P64 = P64[_s8IzL::P64 + 16];
           _s8Izm::P64 = P64[_s8IzL::P64 + 24];
           _s8Izk::I64 = I64[_s8IzL::P64 + 40];
           _s8Izn::I64 = I64[_s8IzL::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IzH::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IzT_entry() //  [R1]
         { info_tbl: [(c8Jk6,
                       label: sat_s8IzT_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jk6: // global
           _s8IzT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jk7; else goto c8Jk8;
       c8Jk8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jka; else goto c8Jk9;
       c8Jka: // global
           HpAlloc = 56;
           goto c8Jk7;
       c8Jk7: // global
           R1 = _s8IzT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jk9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IzT::P64;
           _s8Izp::I64 = I64[_s8IzT::P64 + 56];
           _s8IzP::I64 = I64[_s8IzT::P64 + 64];
           if (_s8IzP::I64 == _s8Izp::I64) goto c8Jk5; else goto c8Jk4;
       c8Jk5: // global
           _s8Izx::P64 = P64[_s8IzT::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jk4: // global
           _s8Izl::P64 = P64[_s8IzT::P64 + 16];
           _s8Izm::P64 = P64[_s8IzT::P64 + 24];
           _s8Izk::I64 = I64[_s8IzT::P64 + 40];
           _s8Izn::I64 = I64[_s8IzT::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IzP::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IA1_entry() //  [R1]
         { info_tbl: [(c8Jks,
                       label: sat_s8IA1_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jks: // global
           _s8IA1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jkt; else goto c8Jku;
       c8Jku: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jkw; else goto c8Jkv;
       c8Jkw: // global
           HpAlloc = 56;
           goto c8Jkt;
       c8Jkt: // global
           R1 = _s8IA1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jkv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IA1::P64;
           _s8Izp::I64 = I64[_s8IA1::P64 + 56];
           _s8IzX::I64 = I64[_s8IA1::P64 + 64];
           if (_s8IzX::I64 == _s8Izp::I64) goto c8Jkr; else goto c8Jkq;
       c8Jkr: // global
           _s8Izx::P64 = P64[_s8IA1::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jkq: // global
           _s8Izl::P64 = P64[_s8IA1::P64 + 16];
           _s8Izm::P64 = P64[_s8IA1::P64 + 24];
           _s8Izk::I64 = I64[_s8IA1::P64 + 40];
           _s8Izn::I64 = I64[_s8IA1::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IzX::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IA9_entry() //  [R1]
         { info_tbl: [(c8JkO,
                       label: sat_s8IA9_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JkO: // global
           _s8IA9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8JkP; else goto c8JkQ;
       c8JkQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JkS; else goto c8JkR;
       c8JkS: // global
           HpAlloc = 56;
           goto c8JkP;
       c8JkP: // global
           R1 = _s8IA9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JkR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IA9::P64;
           _s8Izp::I64 = I64[_s8IA9::P64 + 56];
           _s8IA5::I64 = I64[_s8IA9::P64 + 64];
           if (_s8IA5::I64 == _s8Izp::I64) goto c8JkN; else goto c8JkM;
       c8JkN: // global
           _s8Izx::P64 = P64[_s8IA9::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8JkM: // global
           _s8Izl::P64 = P64[_s8IA9::P64 + 16];
           _s8Izm::P64 = P64[_s8IA9::P64 + 24];
           _s8Izk::I64 = I64[_s8IA9::P64 + 40];
           _s8Izn::I64 = I64[_s8IA9::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IA5::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IAh_entry() //  [R1]
         { info_tbl: [(c8Jla,
                       label: sat_s8IAh_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jla: // global
           _s8IAh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jlb; else goto c8Jlc;
       c8Jlc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jle; else goto c8Jld;
       c8Jle: // global
           HpAlloc = 56;
           goto c8Jlb;
       c8Jlb: // global
           R1 = _s8IAh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jld: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IAh::P64;
           _s8Izp::I64 = I64[_s8IAh::P64 + 56];
           _s8IAd::I64 = I64[_s8IAh::P64 + 64];
           if (_s8IAd::I64 == _s8Izp::I64) goto c8Jl9; else goto c8Jl8;
       c8Jl9: // global
           _s8Izx::P64 = P64[_s8IAh::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jl8: // global
           _s8Izl::P64 = P64[_s8IAh::P64 + 16];
           _s8Izm::P64 = P64[_s8IAh::P64 + 24];
           _s8Izk::I64 = I64[_s8IAh::P64 + 40];
           _s8Izn::I64 = I64[_s8IAh::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IAd::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IAp_entry() //  [R1]
         { info_tbl: [(c8Jlw,
                       label: sat_s8IAp_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jlw: // global
           _s8IAp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jlx; else goto c8Jly;
       c8Jly: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JlA; else goto c8Jlz;
       c8JlA: // global
           HpAlloc = 56;
           goto c8Jlx;
       c8Jlx: // global
           R1 = _s8IAp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Jlz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IAp::P64;
           _s8Izp::I64 = I64[_s8IAp::P64 + 56];
           _s8IAl::I64 = I64[_s8IAp::P64 + 64];
           if (_s8IAl::I64 == _s8Izp::I64) goto c8Jlv; else goto c8Jlu;
       c8Jlv: // global
           _s8Izx::P64 = P64[_s8IAp::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Jlu: // global
           _s8Izl::P64 = P64[_s8IAp::P64 + 16];
           _s8Izm::P64 = P64[_s8IAp::P64 + 24];
           _s8Izk::I64 = I64[_s8IAp::P64 + 40];
           _s8Izn::I64 = I64[_s8IAp::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IAl::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8IAx_entry() //  [R1]
         { info_tbl: [(c8JlS,
                       label: sat_s8IAx_info
                       rep:HeapRep 3 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JlS: // global
           _s8IAx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8JlT; else goto c8JlU;
       c8JlU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JlW; else goto c8JlV;
       c8JlW: // global
           HpAlloc = 56;
           goto c8JlT;
       c8JlT: // global
           R1 = _s8IAx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JlV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8IAx::P64;
           _s8Izp::I64 = I64[_s8IAx::P64 + 56];
           _s8IAt::I64 = I64[_s8IAx::P64 + 64];
           if (_s8IAt::I64 == _s8Izp::I64) goto c8JlR; else goto c8JlQ;
       c8JlR: // global
           _s8Izx::P64 = P64[_s8IAx::P64 + 32];
           Hp = Hp - 56;
           R1 = _s8Izx::P64;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8JlQ: // global
           _s8Izl::P64 = P64[_s8IAx::P64 + 16];
           _s8Izm::P64 = P64[_s8IAx::P64 + 24];
           _s8Izk::I64 = I64[_s8IAx::P64 + 40];
           _s8Izn::I64 = I64[_s8IAx::P64 + 48];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = _s8Izm::P64;
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = _s8Izn::I64;
           I64[Hp - 8] = _s8IAt::I64;
           I64[Hp] = _s8Izp::I64;
           R1 = Hp - 47;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF5_entry() //  [R2, R3]
         { info_tbl: [(c8JlZ,
                       label: GHC.IO.Encoding.UTF16.mkUTF5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JlZ: // global
           if ((Sp + -112) < SpLim) (likely: False) goto c8Jm0; else goto c8Jm1;
       c8Jm0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Jm1: // global
           I64[Sp - 16] = block_c8JiY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8JpL; else goto c8JiZ;
       u8JpL: // global
           call _c8JiY(R1) args: 0, res: 0, upd: 0;
       c8JiZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8JiY() //  [R1]
         { info_tbl: [(c8JiY,
                       label: block_c8JiY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JiY: // global
           I64[Sp - 40] = block_c8Jj3_info;
           _s8Izl::P64 = P64[R1 + 7];
           _s8Izm::P64 = P64[R1 + 15];
           _s8Izk::I64 = I64[R1 + 23];
           _s8Izn::I64 = I64[R1 + 31];
           _s8Izo::I64 = I64[R1 + 39];
           _s8Izp::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s8Izm::P64;
           I64[Sp - 24] = _s8Izn::I64;
           I64[Sp - 16] = _s8Izo::I64;
           I64[Sp - 8] = _s8Izp::I64;
           P64[Sp] = _s8Izl::P64;
           I64[Sp + 8] = _s8Izk::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8JpC; else goto c8Jj4;
       u8JpC: // global
           call _c8Jj3(R1) args: 0, res: 0, upd: 0;
       c8Jj4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jj3() //  [R1]
         { info_tbl: [(c8Jj3,
                       label: block_c8Jj3_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jj3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Jm5; else goto c8Jm4;
       c8Jm5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Jm4: // global
           _s8Izs::P64 = P64[R1 + 7];
           _s8Izt::P64 = P64[R1 + 15];
           _s8Izr::I64 = I64[R1 + 23];
           _s8Izu::I64 = I64[R1 + 31];
           _s8Izv::I64 = I64[R1 + 39];
           _s8Izw::I64 = I64[R1 + 47];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           _s8Izl::P64 = P64[Sp + 40];
           P64[Hp - 40] = _s8Izl::P64;
           P64[Hp - 32] = P64[Sp + 8];
           _s8Izk::I64 = I64[Sp + 48];
           I64[Hp - 24] = _s8Izk::I64;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _s8Izp::I64 = I64[Sp + 32];
           _c8Jj8::P64 = Hp - 47;
           _s8IAC::I64 = _s8Izw::I64;
           _s8IAB::I64 = I64[Sp + 24];
           goto c8JmE;
       c8JmE: // global
           if (%MO_S_Lt_W64(_s8IAC::I64,
                            _s8Izu::I64)) goto c8Joz; else goto c8JoA;
       c8Joz: // global
           if (%MO_S_Lt_W64(_s8IAB::I64,
                            _s8Izp::I64)) goto c8Jow; else goto c8Jox;
       c8Jow: // global
           if ((_s8IAB::I64 + 1) == _s8Izp::I64) goto c8Jou; else goto c8Jot;
       c8Jou: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8JkX() args: 0, res: 0, upd: 0;
       c8Jot: // global
           _s8IAL::I64 = %MO_UU_Conv_W8_W64(I8[_s8Izk::I64 + _s8IAB::I64]);
           call MO_Touch(_s8Izl::P64);
           _s8IAR::I64 = %MO_UU_Conv_W8_W64(I8[_s8Izk::I64 + (_s8IAB::I64 + 1)]);
           call MO_Touch(_s8Izl::P64);
           _s8IAT::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8IAL::I64 << 8)) + _s8IAR::I64));
           if (_s8IAT::I64 >= 55296) goto c8Joq; else goto c8Jor;
       c8Joq: // global
           if (_s8IAT::I64 <= 57343) goto c8Jon; else goto c8Joo;
       c8Jon: // global
           if (%MO_S_Ge_W64(_s8Izp::I64 - _s8IAB::I64,
                            4)) goto c8Jok; else goto c8Jol;
       c8Jok: // global
           _s8IB5::I64 = %MO_UU_Conv_W8_W64(I8[_s8Izk::I64 + (_s8IAB::I64 + 2)]);
           call MO_Touch(_s8Izl::P64);
           _s8IBb::I64 = %MO_UU_Conv_W8_W64(I8[_s8Izk::I64 + (_s8IAB::I64 + 3)]);
           call MO_Touch(_s8Izl::P64);
           if (_s8IAT::I64 < 55296) goto c8JnK; else goto c8Joi;
       c8JnK: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8Jjb() args: 0, res: 0, upd: 0;
       c8Joi: // global
           if (_s8IAT::I64 > 56319) goto c8JnQ; else goto c8Joh;
       c8JnQ: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8Jjx() args: 0, res: 0, upd: 0;
       c8Joh: // global
           _s8IBf::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(%MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s8IB5::I64 << 8)) + _s8IBb::I64));
           if (_s8IBf::I64 < 56320) goto c8Jo8; else goto c8Jog;
       c8Jo8: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8JjT() args: 0, res: 0, upd: 0;
       c8Jog: // global
           if (_s8IBf::I64 > 57343) goto c8Joe; else goto c8Jof;
       c8Joe: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8Jkf() args: 0, res: 0, upd: 0;
       c8Jof: // global
           I32[_s8Izr::I64 + (_s8IAC::I64 << 2)] = %MO_UU_Conv_W64_W32(((_s8IAT::I64 + -55296) << 10) + (_s8IBf::I64 + -56320) + 65536);
           call MO_Touch(_s8Izs::P64);
           _s8IAC::I64 = _s8IAC::I64 + 1;
           _s8IAB::I64 = _s8IAB::I64 + 4;
           goto c8JmE;
       c8Jol: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8JkB() args: 0, res: 0, upd: 0;
       c8Joo: // global
           I32[_s8Izr::I64 + (_s8IAC::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8IAT::I64);
           call MO_Touch(_s8Izs::P64);
           _s8IAC::I64 = _s8IAC::I64 + 1;
           _s8IAB::I64 = _s8IAB::I64 + 2;
           goto c8JmE;
       c8Jor: // global
           I32[_s8Izr::I64 + (_s8IAC::I64 << 2)] = %MO_UU_Conv_W64_W32(_s8IAT::I64);
           call MO_Touch(_s8Izs::P64);
           _s8IAC::I64 = _s8IAC::I64 + 1;
           _s8IAB::I64 = _s8IAB::I64 + 2;
           goto c8JmE;
       c8Jox: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8Jlj() args: 0, res: 0, upd: 0;
       c8JoA: // global
           P64[Sp - 48] = _s8Izs::P64;
           P64[Sp - 40] = _s8Izt::P64;
           I64[Sp - 32] = _s8Izu::I64;
           I64[Sp - 24] = _s8Izv::I64;
           I64[Sp - 16] = _s8IAB::I64;
           I64[Sp - 8] = _s8IAC::I64;
           I64[Sp] = _s8Izr::I64;
           P64[Sp + 24] = _c8Jj8::P64;
           Sp = Sp - 56;
           call _c8JlF() args: 0, res: 0, upd: 0;
     }
 },
 _c8JkX() //  []
         { info_tbl: [(c8JkX,
                       label: block_c8JkX_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JkX: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmt; else goto c8Jms;
       c8Jmt: // global
           HpAlloc = 160;
           I64[Sp] = block_c8JkX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jms: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IAh_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Jjb() //  []
         { info_tbl: [(c8Jjb,
                       label: block_c8Jjb_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jjb: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jm9; else goto c8Jm8;
       c8Jm9: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Jjb_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jm8: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IzD_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Jjx() //  []
         { info_tbl: [(c8Jjx,
                       label: block_c8Jjx_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jjx: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmd; else goto c8Jmc;
       c8Jmd: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Jjx_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmc: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IzL_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8JjT() //  []
         { info_tbl: [(c8JjT,
                       label: block_c8JjT_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JjT: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmh; else goto c8Jmg;
       c8Jmh: // global
           HpAlloc = 160;
           I64[Sp] = block_c8JjT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmg: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IzT_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Jkf() //  []
         { info_tbl: [(c8Jkf,
                       label: block_c8Jkf_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jkf: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jml; else goto c8Jmk;
       c8Jml: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Jkf_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmk: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IA1_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InvalidSequence_closure+3;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8JkB() //  []
         { info_tbl: [(c8JkB,
                       label: block_c8JkB_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JkB: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmp; else goto c8Jmo;
       c8Jmp: // global
           HpAlloc = 160;
           I64[Sp] = block_c8JkB_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmo: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IA9_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Jlj() //  []
         { info_tbl: [(c8Jlj,
                       label: block_c8Jlj_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jlj: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8Jmx; else goto c8Jmw;
       c8Jmx: // global
           HpAlloc = 160;
           I64[Sp] = block_c8Jlj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Jmw: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IAp_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8JlF() //  []
         { info_tbl: [(c8JlF,
                       label: block_c8JlF_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JlF: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto c8JmB; else goto c8JmA;
       c8JmB: // global
           HpAlloc = 160;
           I64[Sp] = block_c8JlF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8JmA: // global
           I64[Hp - 152] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           I64[Hp - 128] = I64[Sp + 56];
           I64[Hp - 120] = I64[Sp + 24];
           I64[Hp - 112] = I64[Sp + 32];
           I64[Hp - 104] = I64[Sp + 48];
           I64[Hp - 96] = sat_s8IAx_info;
           P64[Hp - 80] = P64[Sp + 96];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 80];
           I64[Hp - 56] = I64[Sp + 104];
           I64[Hp - 48] = I64[Sp + 72];
           I64[Hp - 40] = I64[Sp + 88];
           I64[Hp - 32] = I64[Sp + 40];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.OutputUnderflow_closure+2;
           P64[Hp - 8] = Hp - 96;
           P64[Hp] = Hp - 151;
           R1 = Hp - 23;
           Sp = Sp + 112;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.933891338 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16be_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16be_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16be_decode_entry() //  [R2, R3]
         { info_tbl: [(c8JuH,
                       label: GHC.IO.Encoding.UTF16.utf16be_decode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JuH: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.938023716 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF16be3_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF16be3_bytes:
         I8[] [85,84,70,45,49,54,66,69]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.939861911 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be2_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be2_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF16be2_entry() //  [R1]
         { info_tbl: [(c8JuV,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JuV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JuW; else goto c8JuX;
       c8JuW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JuX: // global
           (_c8JuS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8JuS::I64 == 0) goto c8JuU; else goto c8JuT;
       c8JuU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8JuT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8JuS::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF16be3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.944578185 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16be_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16be_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16be_info;
         const 0;
 },
 sat_s8IBP_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Jvk,
                       label: sat_s8IBP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jvk: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8IBR_entry() //  [R1]
         { info_tbl: [(c8Jvo,
                       label: sat_s8IBR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jvo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Jvs; else goto c8Jvr;
       c8Jvs: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Jvr: // global
           _s8IBJ::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8IBP_info;
           P64[Hp - 48] = _s8IBJ::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8IBL_entry() //  [R1, R2, R3]
         { info_tbl: [(c8JvD,
                       label: sat_s8IBL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JvD: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8IBN_entry() //  [R1]
         { info_tbl: [(c8JvH,
                       label: sat_s8IBN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JvH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8JvL; else goto c8JvK;
       c8JvL: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8JvK: // global
           _s8IBJ::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s8IBL_info;
           P64[Hp - 48] = _s8IBJ::P64;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
           P64[Hp - 24] = Hp - 53;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp] = GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16be_entry() //  [R2]
         { info_tbl: [(c8JvN,
                       label: GHC.IO.Encoding.UTF16.mkUTF16be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JvN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8JvR; else goto c8JvQ;
       c8JvR: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8JvQ: // global
           I64[Hp - 56] = sat_s8IBR_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8IBN_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.956055739 UTC

[section ""data" . lvl3_r8G1E_closure" {
     lvl3_r8G1E_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const lvl_r8G1B_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.957986359 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be3_closure" {
     GHC.IO.Encoding.UTF16.utf16be3_closure:
         const GHC.IO.Encoding.UTF16.utf16be3_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be3_entry() //  []
         { info_tbl: [(c8JwA,
                       label: GHC.IO.Encoding.UTF16.utf16be3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JwA: // global
           R1 = lvl3_r8G1E_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.961264887 UTC

[section ""data" . lvl4_r8G1F_closure" {
     lvl4_r8G1F_closure:
         const GHC.IO.Encoding.Types.BufferCodec_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF1_closure+3;
         const GHC.IO.Encoding.UTF16.utf16be2_closure+3;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
         const GHC.IO.Encoding.UTF16.mkUTF16be1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.963115546 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be1_closure" {
     GHC.IO.Encoding.UTF16.utf16be1_closure:
         const GHC.IO.Encoding.UTF16.utf16be1_info;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16be1_entry() //  []
         { info_tbl: [(c8JwN,
                       label: GHC.IO.Encoding.UTF16.utf16be1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JwN: // global
           R1 = lvl4_r8G1F_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.966497469 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16be_closure" {
     GHC.IO.Encoding.UTF16.utf16be_closure:
         const GHC.IO.Encoding.Types.TextEncoding_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const GHC.IO.Encoding.UTF16.utf16be3_closure+1;
         const GHC.IO.Encoding.UTF16.utf16be1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.968733279 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF6_closure" {
     GHC.IO.Encoding.UTF16.mkUTF6_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.970445537 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF4_closure" {
     GHC.IO.Encoding.UTF16.mkUTF4_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Encoding.UTF16.mkUTF3_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.973738084 UTC

[section ""data" . GHC.IO.Encoding.UTF16.$wutf16_decode_closure" {
     GHC.IO.Encoding.UTF16.$wutf16_decode_closure:
         const GHC.IO.Encoding.UTF16.$wutf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JwZ: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2,
                                                           R1) args: 32, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.$wutf16_decode_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(c8Jxa,
                       label: GHC.IO.Encoding.UTF16.$wutf16_decode_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, True, False, False, True, True, True,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jxa: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8Jxb; else goto c8Jxc;
       c8Jxb: // global
           R1 = GHC.IO.Encoding.UTF16.$wutf16_decode_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c8Jxc: // global
           I64[Sp - 48] = block_c8Jx3_info;
           R1 = P64[R2 + 8];
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u8JyF; else goto c8Jx4;
       u8JyF: // global
           call _c8Jx3(R1) args: 0, res: 0, upd: 0;
       c8Jx4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jx3() //  [R1]
         { info_tbl: [(c8Jx3,
                       label: block_c8Jx3_info
                       rep:StackRep [False, True, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jx3: // global
           _s8IBV::I64 = I64[Sp + 16];
           _s8IBW::P64 = P64[Sp + 24];
           _s8IBX::P64 = P64[Sp + 32];
           _s8IBY::I64 = I64[Sp + 40];
           _s8IBZ::I64 = I64[Sp + 48];
           _s8IC0::I64 = I64[Sp + 56];
           _s8IC1::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c8Jx7; else goto c8Jx8;
       c8Jx7: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Jxh; else goto c8Jxg;
       c8Jxh: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Jxg: // global
           if (%MO_S_Ge_W64(_s8IC0::I64 - _s8IBZ::I64,
                            2)) goto c8Jys; else goto c8Jyw;
       c8Jys: // global
           _s8IBU::P64 = P64[Sp + 8];
           _s8ICc::I64 = %MO_UU_Conv_W8_W64(I8[_s8IBV::I64 + _s8IBZ::I64]);
           call MO_Touch(_s8IBW::P64);
           _s8ICi::I64 = %MO_UU_Conv_W8_W64(I8[_s8IBV::I64 + (_s8IBZ::I64 + 1)]);
           call MO_Touch(_s8IBW::P64);
           if (_s8ICc::I64 != 254) goto c8Jyf; else goto c8Jyq;
       c8Jyq: // global
           if (_s8ICi::I64 != 255) goto c8Jyf; else goto c8Jyp;
       c8Jyf: // global
           Hp = Hp - 88;
           I64[Sp - 8] = _s8ICi::I64;
           I64[Sp] = _s8ICc::I64;
           Sp = Sp - 16;
           call _c8JxC() args: 0, res: 0, upd: 0;
       c8Jyp: // global
           call MO_WriteBarrier();
           P64[_s8IBU::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IBU::P64);
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8IBW::P64;
           P64[Hp - 64] = _s8IBX::P64;
           I64[Hp - 56] = _s8IBV::I64;
           I64[Hp - 48] = _s8IBY::I64;
           I64[Hp - 40] = _s8IBZ::I64 + 2;
           I64[Hp - 32] = _s8IC0::I64;
           _c8Jyo::P64 = Hp - 79;
           Hp = Hp - 32;
           R3 = _s8IC1::P64;
           R2 = _c8Jyo::P64;
           Sp = Sp + 72;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8Jyw: // global
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = _s8IBW::P64;
           P64[Hp - 64] = _s8IBX::P64;
           I64[Hp - 56] = _s8IBV::I64;
           I64[Hp - 48] = _s8IBY::I64;
           I64[Hp - 40] = _s8IBZ::I64;
           I64[Hp - 32] = _s8IC0::I64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.Types.InputUnderflow_closure+1;
           P64[Hp - 8] = Hp - 79;
           P64[Hp] = _s8IC1::P64;
           R1 = Hp - 23;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Jx8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JyC; else goto c8JyB;
       c8JyC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8JyB: // global
           _s8ICB::P64 = P64[R1 + 6];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IBW::P64;
           P64[Hp - 32] = _s8IBX::P64;
           I64[Hp - 24] = _s8IBV::I64;
           I64[Hp - 16] = _s8IBY::I64;
           I64[Hp - 8] = _s8IBZ::I64;
           I64[Hp] = _s8IC0::I64;
           R3 = _s8IC1::P64;
           R2 = Hp - 47;
           R1 = _s8ICB::P64;
           Sp = Sp + 72;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8JxC() //  []
         { info_tbl: [(c8JxC,
                       label: block_c8JxC_info
                       rep:StackRep [True, True, False, True, False, False, True, True,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JxC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8JxG; else goto c8JxF;
       c8JxG: // global
           HpAlloc = 56;
           I64[Sp] = block_c8JxC_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8JxF: // global
           _s8IBU::P64 = P64[Sp + 24];
           _s8IBV::I64 = I64[Sp + 32];
           _s8IBW::P64 = P64[Sp + 40];
           _s8IBX::P64 = P64[Sp + 48];
           _s8IBY::I64 = I64[Sp + 56];
           _s8IBZ::I64 = I64[Sp + 64];
           _s8IC0::I64 = I64[Sp + 72];
           _s8IC1::P64 = P64[Sp + 80];
           if (I64[Sp + 16] == 255) goto c8Jy7; else goto c8JxO;
       c8Jy7: // global
           if (I64[Sp + 8] == 254) goto c8Jy6; else goto c8JxX;
       c8Jy6: // global
           call MO_WriteBarrier();
           P64[_s8IBU::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF4_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IBU::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IBW::P64;
           P64[Hp - 32] = _s8IBX::P64;
           I64[Hp - 24] = _s8IBV::I64;
           I64[Hp - 16] = _s8IBY::I64;
           I64[Hp - 8] = _s8IBZ::I64 + 2;
           I64[Hp] = _s8IC0::I64;
           R3 = _s8IC1::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF3_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8JxX: // global
           call MO_WriteBarrier();
           P64[_s8IBU::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IBU::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IBW::P64;
           P64[Hp - 32] = _s8IBX::P64;
           I64[Hp - 24] = _s8IBV::I64;
           I64[Hp - 16] = _s8IBY::I64;
           I64[Hp - 8] = _s8IBZ::I64;
           I64[Hp] = _s8IC0::I64;
           R3 = _s8IC1::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
       c8JxO: // global
           call MO_WriteBarrier();
           P64[_s8IBU::P64 + 8] = GHC.IO.Encoding.UTF16.mkUTF6_closure+2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IBU::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s8IBW::P64;
           P64[Hp - 32] = _s8IBX::P64;
           I64[Hp - 24] = _s8IBV::I64;
           I64[Hp - 16] = _s8IBY::I64;
           I64[Hp - 8] = _s8IBZ::I64;
           I64[Hp] = _s8IC0::I64;
           R3 = _s8IC1::P64;
           R2 = Hp - 47;
           Sp = Sp + 88;
           call GHC.IO.Encoding.UTF16.mkUTF5_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.988730769 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode1_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode1_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode1_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Jzt,
                       label: GHC.IO.Encoding.UTF16.utf16_decode1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jzt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Jzx; else goto c8Jzy;
       c8Jzx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.utf16_decode1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Jzy: // global
           I64[Sp - 24] = block_c8Jzq_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8JzG; else goto c8Jzr;
       u8JzG: // global
           call _c8Jzq(R1) args: 0, res: 0, upd: 0;
       c8Jzr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jzq() //  [R1]
         { info_tbl: [(c8Jzq,
                       label: block_c8Jzq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jzq: // global
           I64[Sp] = block_c8Jzw_info;
           _s8ICI::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8ICI::P64;
           if (R1 & 7 != 0) goto u8JzF; else goto c8JzA;
       u8JzF: // global
           call _c8Jzw(R1) args: 0, res: 0, upd: 0;
       c8JzA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jzw() //  [R1]
         { info_tbl: [(c8Jzw,
                       label: block_c8Jzw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jzw: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.996172716 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_decode_closure" {
     GHC.IO.Encoding.UTF16.utf16_decode_closure:
         const GHC.IO.Encoding.UTF16.utf16_decode_info;
 },
 GHC.IO.Encoding.UTF16.utf16_decode_entry() //  [R2, R3, R4]
         { info_tbl: [(c8JA2,
                       label: GHC.IO.Encoding.UTF16.utf16_decode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JA2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Encoding.UTF16.utf16_decode1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:53.999306407 UTC

[section ""cstring" . GHC.IO.Encoding.UTF16.mkUTF8_bytes" {
     GHC.IO.Encoding.UTF16.mkUTF8_bytes:
         I8[] [85,84,70,45,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.001017803 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF7_closure" {
     GHC.IO.Encoding.UTF16.mkUTF7_closure:
         const GHC.IO.Encoding.UTF16.mkUTF7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.mkUTF7_entry() //  [R1]
         { info_tbl: [(c8JAg,
                       label: GHC.IO.Encoding.UTF16.mkUTF7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JAg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JAh; else goto c8JAi;
       c8JAh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JAi: // global
           (_c8JAd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8JAd::I64 == 0) goto c8JAf; else goto c8JAe;
       c8JAf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8JAe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8JAd::I64;
           R2 = GHC.IO.Encoding.UTF16.mkUTF8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.00687889 UTC

[section ""data" . GHC.IO.Encoding.UTF16.mkUTF16_closure" {
     GHC.IO.Encoding.UTF16.mkUTF16_closure:
         const GHC.IO.Encoding.UTF16.mkUTF16_info;
         const 0;
 },
 sat_s8IDA_entry() //  [R1, R2]
         { info_tbl: [(c8JAK,
                       label: sat_s8IDA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JAK: // global
           _s8IDi::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8IDi::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8IDi::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8IDw_entry() //  [R1]
         { info_tbl: [(c8JAT,
                       label: sat_s8IDw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JAT: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8IDu_entry() //  [R1, R2, R3]
         { info_tbl: [(c8JB1,
                       label: sat_s8IDu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JB1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverEncode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8IDt_entry() //  [R1, R2, R3]
         { info_tbl: [(c8JBc,
                       label: sat_s8IDt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JBc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8JBd; else goto c8JBe;
       c8JBd: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8JBe: // global
           I64[Sp - 24] = block_c8JB9_info;
           _s8IDi::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8IDi::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8JBi; else goto c8JBa;
       u8JBi: // global
           call _c8JB9(R1) args: 0, res: 0, upd: 0;
       c8JBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8JB9() //  [R1]
         { info_tbl: [(c8JB9,
                       label: block_c8JB9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JB9: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = I64[R1 + 23];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 31];
           I64[Sp + 8] = I64[R1 + 39];
           I64[Sp + 16] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_encode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8IDC_entry() //  [R1]
         { info_tbl: [(c8JBk,
                       label: sat_s8IDC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JBk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JBl; else goto c8JBm;
       c8JBl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8JBm: // global
           I64[Sp - 16] = block_c8JAA_info;
           _s8ICQ::P64 = P64[R1 + 7];
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = _s8ICQ::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8JAA() //  [R1]
         { info_tbl: [(c8JAA,
                       label: block_c8JAA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JAA: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8JBp; else goto c8JBo;
       c8JBp: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8JBo: // global
           I64[Hp - 104] = sat_s8IDA_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8IDw_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8IDu_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8IDt_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8IDc_entry() //  [R1, R2]
         { info_tbl: [(c8JBF,
                       label: sat_s8IDc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JBF: // global
           _s8ICU::P64 = P64[R1 + 6];
           call MO_WriteBarrier();
           P64[_s8ICU::P64 + 8] = R2;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s8ICU::P64);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ID8_entry() //  [R1]
         { info_tbl: [(c8JBO,
                       label: sat_s8ID8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JBO: // global
           R1 = P64[P64[R1 + 7] + 8];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ID6_entry() //  [R1, R2, R3]
         { info_tbl: [(c8JBW,
                       label: sat_s8ID6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JBW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.IO.Encoding.Failure.recoverDecode1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ID5_entry() //  [R1, R2, R3]
         { info_tbl: [(c8JC7,
                       label: sat_s8ID5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JC7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8JC8; else goto c8JC9;
       c8JC8: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8JC9: // global
           I64[Sp - 24] = block_c8JC4_info;
           _s8ICU::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 16] = _s8ICU::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8JCd; else goto c8JC5;
       u8JCd: // global
           call _c8JC4(R1) args: 0, res: 0, upd: 0;
       c8JC5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8JC4() //  [R1]
         { info_tbl: [(c8JC4,
                       label: block_c8JC4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JC4: // global
           R6 = I64[R1 + 31];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = I64[R1 + 23];
           R2 = P64[Sp + 8];
           I64[Sp] = I64[R1 + 39];
           I64[Sp + 8] = I64[R1 + 47];
           call GHC.IO.Encoding.UTF16.$wutf16_decode_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8IDe_entry() //  [R1]
         { info_tbl: [(c8JCf,
                       label: sat_s8IDe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JCf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JCg; else goto c8JCh;
       c8JCg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8JCh: // global
           I64[Sp - 16] = block_c8JBv_info;
           _s8ICQ::P64 = P64[R1 + 7];
           R1 = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _s8ICQ::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8JBv() //  [R1]
         { info_tbl: [(c8JBv,
                       label: block_c8JBv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JBv: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8JCk; else goto c8JCj;
       c8JCk: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8JCj: // global
           I64[Hp - 104] = sat_s8IDc_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = sat_s8ID8_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = sat_s8ID6_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = sat_s8ID5_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = GHC.IO.Encoding.Types.BufferCodec_con_info;
           P64[Hp - 32] = Hp - 53;
           P64[Hp - 24] = Hp - 69;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF2_closure+1;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 102;
           R1 = Hp - 39;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Encoding.UTF16.mkUTF16_entry() //  [R2]
         { info_tbl: [(c8JCm,
                       label: GHC.IO.Encoding.UTF16.mkUTF16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JCm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8JCq; else goto c8JCp;
       c8JCq: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = GHC.IO.Encoding.UTF16.mkUTF16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8JCp: // global
           I64[Hp - 56] = sat_s8IDC_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8IDe_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.IO.Encoding.Types.TextEncoding_con_info;
           P64[Hp - 16] = GHC.IO.Encoding.UTF16.mkUTF7_closure;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 55;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.03660425 UTC

[section ""data" . GHC.IO.Encoding.UTF16.utf16_closure" {
     GHC.IO.Encoding.UTF16.utf16_closure:
         const GHC.IO.Encoding.UTF16.utf16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Encoding.UTF16.utf16_entry() //  [R1]
         { info_tbl: [(c8JEd,
                       label: GHC.IO.Encoding.UTF16.utf16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JEd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JEe; else goto c8JEf;
       c8JEe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8JEf: // global
           (_c8JEa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8JEa::I64 == 0) goto c8JEc; else goto c8JEb;
       c8JEc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8JEb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8JEa::I64;
           R2 = GHC.IO.Encoding.Failure.ErrorOnCodingFailure_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Encoding.UTF16.mkUTF16_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:54.040443832 UTC

[section ""relreadonly" . S8JgE_srt" {
     S8JgE_srt:
         const GHC.IO.Encoding.Failure.recoverEncode1_closure;
         const GHC.IO.Encoding.Failure.recoverDecode1_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16le2_closure;
         const GHC.IO.Encoding.Failure.recoverDecode2_closure;
         const lvl_r8G1B_closure;
         const lvl1_r8G1C_closure;
         const GHC.IO.Encoding.Failure.recoverEncode2_closure;
         const GHC.IO.Encoding.UTF16.utf16be2_closure;
         const lvl2_r8G1D_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16be2_closure;
         const lvl3_r8G1E_closure;
         const lvl4_r8G1F_closure;
         const GHC.IO.Encoding.UTF16.mkUTF16_closure;
         const GHC.IO.Encoding.UTF16.mkUTF7_closure;
 }]

